1
00:00:12,356 --> 00:00:13,036
>> Good morning.


2
00:00:13,806 --> 00:00:16,166
Welcome to Writing Energy
Efficient Code, Part 1.


3
00:00:16,436 --> 00:00:19,806
I'm Anthony Chivetta from the
OS X Power & Performance team.


4
00:00:20,726 --> 00:00:22,646
And hopefully, everyone
is feeling awake


5
00:00:22,646 --> 00:00:25,266
and recharged this morning now
that you've had your first cup


6
00:00:25,266 --> 00:00:26,866
of coffee, your iDevices


7
00:00:26,866 --> 00:00:28,926
and Macs have a full
charge from overnight.


8
00:00:29,476 --> 00:00:32,735
But unfortunately, as we all
know, as the day wears on,


9
00:00:33,616 --> 00:00:36,196
sometimes our energy
can begin to drain,


10
00:00:36,946 --> 00:00:38,846
we find our batteries
just aren't as full.


11
00:00:39,576 --> 00:00:40,636
And I want to talk to you today


12
00:00:40,636 --> 00:00:44,896
about how you can help make sure
your applications contribute


13
00:00:44,896 --> 00:00:47,516
to extending users' battery
life for as long as possible,


14
00:00:47,706 --> 00:00:49,386
and improving the
user experience


15
00:00:50,576 --> 00:00:52,136
by making sure users
can continue


16
00:00:52,136 --> 00:00:53,556
to use your app all day long.


17
00:00:53,556 --> 00:00:55,546
And of course, you know running


18
00:00:55,546 --> 00:00:57,066
out of battery life is
something we all hate.


19
00:00:57,416 --> 00:00:59,546
So, hopefully, that in
itself is motivation to try


20
00:00:59,546 --> 00:01:01,866
to help improve the energy
efficiency of your application.


21
00:01:02,346 --> 00:01:06,676
But if not, in OS X
Mavericks and iOS 8,


22
00:01:07,016 --> 00:01:09,916
we've been helping
provide users better tools


23
00:01:10,256 --> 00:01:12,716
to understand what
applications are contributing


24
00:01:12,716 --> 00:01:14,566
to battery life on their system.


25
00:01:15,016 --> 00:01:17,606
So, on the left in
OS X Mavericks,


26
00:01:17,636 --> 00:01:20,546
we added to the Battery
menu a list of applications


27
00:01:20,546 --> 00:01:22,156
that are using significant
amounts of energy.


28
00:01:22,706 --> 00:01:25,606
And on the right, you can see
the new Battery Usage screen


29
00:01:25,606 --> 00:01:26,906
in iOS 8 settings.


30
00:01:27,346 --> 00:01:30,756
And with these tools, users
can make smart decisions


31
00:01:30,756 --> 00:01:32,116
about what apps they use,


32
00:01:32,396 --> 00:01:35,156
understanding how those apps
impact their battery life.


33
00:01:35,216 --> 00:01:36,886
So, if your app is
energy inefficient,


34
00:01:36,886 --> 00:01:38,876
you might find users
stop using your apps


35
00:01:39,616 --> 00:01:41,176
or give them poor
App Store ratings.


36
00:01:41,496 --> 00:01:43,576
And so, it's in everyone's
interest


37
00:01:43,656 --> 00:01:46,096
to make sure your apps are as
energy efficient as possible.


38
00:01:46,386 --> 00:01:49,616
So, with that, what are we
going to talk about today?


39
00:01:50,736 --> 00:01:52,896
We'll start by going
through some general power


40
00:01:52,896 --> 00:01:53,906
energy concepts.


41
00:01:53,906 --> 00:01:55,676
So, you have kind of a
high level understanding


42
00:01:55,676 --> 00:01:56,986
of what it is we're discussing.


43
00:01:57,176 --> 00:02:00,466
And then, we'll go
through some specific ways


44
00:02:00,466 --> 00:02:01,996
that you can improve
your energy use.


45
00:02:02,456 --> 00:02:04,886
We'll start with the technique
of doing something never,


46
00:02:05,856 --> 00:02:07,496
progress to doing
it at a better time,


47
00:02:08,545 --> 00:02:10,096
discuss how to do
it more efficiently,


48
00:02:11,396 --> 00:02:13,356
and finally, how to do less.


49
00:02:13,356 --> 00:02:17,066
And then, for Part 2, in
the same room immediately


50
00:02:17,066 --> 00:02:20,296
after this talk, Albert will
come up and talk specifically


51
00:02:20,296 --> 00:02:22,516
about networking, location,


52
00:02:22,966 --> 00:02:25,736
and sleep/wake issues
in much more depth.


53
00:02:26,316 --> 00:02:27,896
And so with that,
let's get started.


54
00:02:28,706 --> 00:02:30,376
So, first, what uses energy?


55
00:02:30,376 --> 00:02:31,876
Well, the short answer
is everything


56
00:02:31,876 --> 00:02:33,046
on the system uses energy.


57
00:02:33,046 --> 00:02:35,866
Any resource you
might use as part


58
00:02:35,866 --> 00:02:38,126
of your code's execution is
going to consume some energy.


59
00:02:38,806 --> 00:02:41,406
And a few things you want to
keep particularly in mind,


60
00:02:41,406 --> 00:02:43,026
the first is your
CPU consumption.


61
00:02:43,406 --> 00:02:45,776
And CPU has a huge dynamic
range, using a little


62
00:02:45,776 --> 00:02:47,506
versus using a lot
makes a big difference.


63
00:02:48,796 --> 00:02:50,856
How you use Flash
storage in particular.


64
00:02:50,856 --> 00:02:53,416
Flash also has a
big dynamic range.


65
00:02:53,816 --> 00:02:56,496
So, any time you read or
write to a storage device,


66
00:02:56,496 --> 00:02:58,376
you're going to incur
more energy consumption.


67
00:02:59,456 --> 00:03:01,636
Networking, especially
on iOS devices


68
00:03:01,636 --> 00:03:04,006
with so many different types
of networking, can play,


69
00:03:04,166 --> 00:03:07,706
can be a large factor in
your energy consumption.


70
00:03:07,706 --> 00:03:11,836
And then Graphics, you might
do a little bit of drawing


71
00:03:11,836 --> 00:03:13,476
in your app but this
can cause a lot of work


72
00:03:13,476 --> 00:03:15,266
to happen downstream
the Graphics pipeline.


73
00:03:15,736 --> 00:03:17,416
This is obviously not
an exhaustive list,


74
00:03:17,856 --> 00:03:19,846
but just some areas of your
application you should kind


75
00:03:19,846 --> 00:03:22,116
of keep in the back of your
head as we talk about some


76
00:03:22,116 --> 00:03:23,376
of these power fundamentals.


77
00:03:24,936 --> 00:03:26,336
So, let's look at
the graph here.


78
00:03:26,676 --> 00:03:28,686
And we're going to see a number
of graphs like this today.


79
00:03:28,686 --> 00:03:30,906
So, just to kind of orient
you, on the bottom here,


80
00:03:30,906 --> 00:03:34,136
we have time going
across from left to right.


81
00:03:34,136 --> 00:03:36,436
And on the vertical
axis, we have power.


82
00:03:36,436 --> 00:03:37,746
So, you can imagine,
we took a device


83
00:03:37,746 --> 00:03:38,816
and attached the power meter.


84
00:03:39,286 --> 00:03:40,856
And we would like
to see a reading


85
00:03:40,856 --> 00:03:42,266
that looks something like this.


86
00:03:42,716 --> 00:03:47,586
There's a couple of features of
this graph I want to point out.


87
00:03:48,066 --> 00:03:50,726
The first is this very low
idle power at the beginning.


88
00:03:50,876 --> 00:03:52,416
Our devices are really
good at getting


89
00:03:52,416 --> 00:03:54,536
into low-power states
when not being used.


90
00:03:54,806 --> 00:03:57,876
And so, the idle power of
a device is very, very low.


91
00:03:58,546 --> 00:04:01,116
We then have these portions
where the system is active.


92
00:04:01,116 --> 00:04:02,956
Your code might have been
running, doing something,


93
00:04:03,296 --> 00:04:05,416
were actively consuming
resources


94
00:04:05,416 --> 00:04:06,466
and accomplishing work.


95
00:04:06,916 --> 00:04:09,436
And then we also have
these intermediate states.


96
00:04:09,696 --> 00:04:11,426
And these are places
where the system is idle,


97
00:04:11,526 --> 00:04:13,386
but we haven't been able
to get all the way back


98
00:04:13,386 --> 00:04:14,956
down to our lowest idle power.


99
00:04:15,886 --> 00:04:17,546
We need some time to
achieve that state


100
00:04:17,546 --> 00:04:18,805
and you can see at
the end, we do.


101
00:04:19,315 --> 00:04:20,546
But if you have sporadic work,


102
00:04:20,546 --> 00:04:22,436
we can stay in these
intermediate states


103
00:04:22,436 --> 00:04:23,316
for a very long time.


104
00:04:24,486 --> 00:04:26,456
So, ultimately, what we can
do is we can divide this graph


105
00:04:26,456 --> 00:04:26,966
in half.


106
00:04:27,196 --> 00:04:30,256
We can say everything in the
top half is the dynamic cost.


107
00:04:30,496 --> 00:04:32,936
This is the cost associated
with actually accomplishing more


108
00:04:32,936 --> 00:04:35,976
and more work, whereas the
bottom part is the fixed cost.


109
00:04:35,976 --> 00:04:38,126
This is what we pay just
to have accomplished any


110
00:04:38,126 --> 00:04:38,956
work whatsoever.


111
00:04:39,396 --> 00:04:42,116
And this fixed-cost
concept can come


112
00:04:42,116 --> 00:04:43,996
into play whenever you
have sporadic work.


113
00:04:43,996 --> 00:04:45,656
So, you can imagine here,


114
00:04:45,966 --> 00:04:47,326
we have a workload
that's doing a bunch


115
00:04:47,326 --> 00:04:48,706
of little tasks sporadically.


116
00:04:49,576 --> 00:04:53,096
Well, all of this blue area at
the bottom is the fixed cost.


117
00:04:53,496 --> 00:04:55,166
That's a lot of energy
we're consuming


118
00:04:55,166 --> 00:04:58,156
to get a very small
actual amount of work done.


119
00:04:59,096 --> 00:05:02,566
So, any time you can help
avoid small sporadic work units


120
00:05:02,776 --> 00:05:04,076
by aggregating them together,


121
00:05:04,616 --> 00:05:08,706
you can dramatically reduce
the fixed cost of your work.


122
00:05:09,386 --> 00:05:11,846
And this is an easy way
to get energy savings.


123
00:05:12,116 --> 00:05:13,586
And it's also important
to keep in mind


124
00:05:13,586 --> 00:05:15,246
because your app
probably does lots


125
00:05:15,246 --> 00:05:16,676
of things exponentially
concurrently.


126
00:05:16,956 --> 00:05:19,016
And you have to think
holistically about the behavior


127
00:05:19,016 --> 00:05:21,216
of your application to make
sure you're grouping work


128
00:05:21,216 --> 00:05:22,276
together appropriately.


129
00:05:24,576 --> 00:05:26,156
So, we've also mentioned
these terms,


130
00:05:26,156 --> 00:05:27,836
energy and power, a few times.


131
00:05:28,106 --> 00:05:30,256
Let's put some more
specific definitions to them.


132
00:05:30,676 --> 00:05:32,176
So, first, power.


133
00:05:32,636 --> 00:05:34,246
Power is an instantaneous
measurement.


134
00:05:34,326 --> 00:05:36,236
So, as we're looking at
these graphs it's the value


135
00:05:36,236 --> 00:05:37,236
at one point in time.


136
00:05:37,786 --> 00:05:41,146
On the other hand, energy is
the area under that graph.


137
00:05:41,446 --> 00:05:44,266
So, we might say that something
consumes a certain number


138
00:05:44,266 --> 00:05:46,436
of watts as an instantaneous
power measurement.


139
00:05:46,746 --> 00:05:49,106
But to accomplish a task,
we want to talk about joules


140
00:05:49,106 --> 00:05:50,486
and the total energy it uses.


141
00:05:51,266 --> 00:05:53,456
And it's important to keep
these concepts separate


142
00:05:53,456 --> 00:05:55,576
because we can actually
trade power for energy.


143
00:05:55,866 --> 00:05:58,466
So, let's imagine we have
a single-threaded workload.


144
00:05:59,006 --> 00:06:01,856
The actual dynamic cost of
that work is just this top part


145
00:06:01,856 --> 00:06:02,276
in blue.


146
00:06:02,276 --> 00:06:03,866
And if we were to make


147
00:06:03,866 --> 00:06:05,546
that single-threaded
workload multi-threaded,


148
00:06:06,456 --> 00:06:09,486
we can have the same dynamic
cost but reduce our fixed cost


149
00:06:09,486 --> 00:06:10,746
by getting the work done faster.


150
00:06:11,116 --> 00:06:13,806
In this way, our
instantaneous power is increased


151
00:06:14,236 --> 00:06:16,556
but our overall energy
consumption is decreased.


152
00:06:16,606 --> 00:06:18,866
In essence, by getting
better performance,


153
00:06:18,866 --> 00:06:20,726
we've also achieved
better energy use.


154
00:06:21,126 --> 00:06:22,556
And that's a common
theme we'll talk about,


155
00:06:22,556 --> 00:06:24,436
is that any time you
can improve performance,


156
00:06:24,716 --> 00:06:26,306
it's also likely going
to improve energy,


157
00:06:26,486 --> 00:06:27,666
and these things
go hand in hand.


158
00:06:28,176 --> 00:06:31,216
So, that's our power
fundamentals.


159
00:06:31,286 --> 00:06:33,426
Things to remember is
that work is a fixed cost.


160
00:06:33,426 --> 00:06:36,686
For small workloads, that
fixed cost will often dominate.


161
00:06:37,106 --> 00:06:38,256
For intensive workloads,


162
00:06:38,256 --> 00:06:39,856
the dynamic cost will
usually dominate.


163
00:06:40,316 --> 00:06:42,496
And better performance
often means better energy.


164
00:06:43,096 --> 00:06:48,086
OK, so, let's dive into
techniques you can use


165
00:06:48,086 --> 00:06:50,016
to improve the energy
consumption of your app.


166
00:06:50,666 --> 00:06:52,436
The first we want to talk
about is Do It Never.


167
00:06:52,746 --> 00:06:56,116
So, this might seem simple-if
you can avoid doing work,


168
00:06:56,276 --> 00:06:57,016
avoid doing it.


169
00:06:57,556 --> 00:07:00,086
That's certainly going to have
better energy consumption.


170
00:07:00,176 --> 00:07:01,966
So, let's imagine we
have an application


171
00:07:01,996 --> 00:07:04,906
and some ad that's animating,
maybe it's a scrolling marquee


172
00:07:04,906 --> 00:07:07,096
like in our iTunes
or App Stores.


173
00:07:07,596 --> 00:07:10,916
And this is fine, you know,
that's a nice user interface.


174
00:07:11,256 --> 00:07:16,776
But what happens if another app
comes along and they're sitting


175
00:07:16,776 --> 00:07:17,996
in front of your application?


176
00:07:18,766 --> 00:07:22,306
Are you still doing the work
necessary for that, for your ad


177
00:07:22,306 --> 00:07:24,946
or marquee or what it might be
to draw it up into the screen?


178
00:07:25,486 --> 00:07:26,796
Are your timers still firing?


179
00:07:27,026 --> 00:07:29,216
Are you still consuming energy
even though the user can't see


180
00:07:29,216 --> 00:07:29,716
your app?


181
00:07:30,606 --> 00:07:32,836
It's very important to make
sure that we're not doing work


182
00:07:33,136 --> 00:07:35,676
to power user interface features
that the user isn't aware of.


183
00:07:36,176 --> 00:07:40,536
So, on iOS, hopefully, most of
you are familiar with these.


184
00:07:40,536 --> 00:07:43,026
There's two
UIApplicationDelegate methods


185
00:07:43,026 --> 00:07:45,666
you can implement,
applicationDidResignActive


186
00:07:45,666 --> 00:07:47,176
and applicationDidBecomeActive.


187
00:07:47,306 --> 00:07:49,106
And you'll get didResignActive


188
00:07:49,106 --> 00:07:50,466
when your app enters
the background


189
00:07:50,736 --> 00:07:53,006
or becomes not visible on
screen due to, let's say,


190
00:07:53,006 --> 00:07:54,046
the user gets a phone call.


191
00:07:54,126 --> 00:07:56,286
And then of course,
you'll get didBecomeActive


192
00:07:56,286 --> 00:07:57,906
when you are now visible again.


193
00:07:58,366 --> 00:07:59,996
It's important to
use the pair of these


194
00:07:59,996 --> 00:08:02,946
to pause any animations,
UI updating timers


195
00:08:02,946 --> 00:08:06,096
that might be firing and make
sure your app gets as quiesced


196
00:08:06,096 --> 00:08:08,456
and energy efficient
as possible,


197
00:08:08,456 --> 00:08:10,556
because the user can't see any


198
00:08:10,556 --> 00:08:11,886
of the work you're
doing to update the UI.


199
00:08:12,596 --> 00:08:15,896
You can also listen to
the UIApplicationWill


200
00:08:15,896 --> 00:08:18,616
ResignActiveNotification as well
in other parts of your code.


201
00:08:19,046 --> 00:08:24,466
Now, in OS X, it's similar,
same application didResignActive


202
00:08:24,466 --> 00:08:26,626
and becomeActive on your
NSApplication Delegate.


203
00:08:28,286 --> 00:08:30,506
But OS X makes things a
little more complicated


204
00:08:30,506 --> 00:08:32,616
because there are multiple
applications on the screen.


205
00:08:33,986 --> 00:08:35,476
And so, on OS X, we
have something called


206
00:08:35,476 --> 00:08:36,676
Occlusion Notifications.


207
00:08:36,676 --> 00:08:39,275
So, this is a new feature
that was new in OS X Mavericks


208
00:08:39,515 --> 00:08:41,746
and it lets you determine
the visibility


209
00:08:41,746 --> 00:08:43,836
of a particular window
or application.


210
00:08:45,016 --> 00:08:48,326
For application, you have the
delegate method application


211
00:08:48,326 --> 00:08:49,446
DidChangeOcclusionState.


212
00:08:50,356 --> 00:08:51,726
And for a window, you can check,


213
00:08:51,726 --> 00:08:53,736
get
windowDidChangeOcclusionState


214
00:08:53,736 --> 00:08:55,076
to know when a particular window


215
00:08:55,076 --> 00:08:57,296
or the whole application
becomes visible


216
00:08:57,296 --> 00:08:58,506
or becomes fully occluded.


217
00:08:58,966 --> 00:09:04,316
And with the use of these and
the applicationDidBecomeActive


218
00:09:04,316 --> 00:09:06,406
and resignActive,
which changes based


219
00:09:06,406 --> 00:09:08,406
on what the frontmost
app on the system is.


220
00:09:08,456 --> 00:09:11,196
So, you are active on OS X when
you're in the menu at the top


221
00:09:11,196 --> 00:09:12,996
of the screen and
you resignActive


222
00:09:12,996 --> 00:09:14,536
when another app
becomes frontmost.


223
00:09:14,536 --> 00:09:16,586
So, between that and
occlusion notifications,


224
00:09:16,586 --> 00:09:18,886
you can determine the full
state of your app on the system


225
00:09:19,146 --> 00:09:20,056
and make smart decisions


226
00:09:20,056 --> 00:09:21,676
about whether it's
appropriate to do work.


227
00:09:22,146 --> 00:09:23,696
And some of you might want


228
00:09:23,696 --> 00:09:25,996
to know how App Nap
factors into all this.


229
00:09:25,996 --> 00:09:28,526
So, App Nap is the feature
reintroduced in OS X Mavericks


230
00:09:28,886 --> 00:09:31,566
that can reduce an inactive
application's energy use


231
00:09:31,726 --> 00:09:33,146
by constraining its resources.


232
00:09:33,896 --> 00:09:36,826
But, the problem is that App
Nap relies on heuristics.


233
00:09:36,826 --> 00:09:39,816
We have to make guesses
as to whether a user cares


234
00:09:39,816 --> 00:09:42,106
about a particular application
at a particular time.


235
00:09:42,536 --> 00:09:46,286
And so, there are cases where
we cannot put an app in App Nap,


236
00:09:46,286 --> 00:09:49,336
because we're not certain
the app isn't in use.


237
00:09:49,656 --> 00:09:52,336
But as a developer, you are the
authoritative source for this.


238
00:09:52,666 --> 00:09:54,236
Once you've taken
into account things


239
00:09:54,236 --> 00:09:55,466
like occlusion notifications,


240
00:09:55,466 --> 00:09:57,826
you know whether a particular
piece of work is necessary.


241
00:09:58,576 --> 00:10:00,966
And so, ultimately,
in a well-behaved app,


242
00:10:00,966 --> 00:10:02,706
App Nap should never
have an effect.


243
00:10:03,136 --> 00:10:05,526
If the user isn't using the app,
you shouldn't be doing any work.


244
00:10:05,846 --> 00:10:08,646
And if you are doing work
on behalf of the user,


245
00:10:09,096 --> 00:10:11,606
you should be using
the NSProcessInfo


246
00:10:11,686 --> 00:10:15,006
PerformActivityWithOptions
API to let the system know


247
00:10:15,006 --> 00:10:17,206
that you're doing work and
now is not an appropriate time


248
00:10:17,526 --> 00:10:18,096
to nap you.


249
00:10:18,786 --> 00:10:20,946
So, ultimately, App
Nap is a fallback


250
00:10:20,946 --> 00:10:23,016
and in a well-behaved
application you really shouldn't


251
00:10:23,016 --> 00:10:25,366
have any effects from App Nap.


252
00:10:27,516 --> 00:10:30,046
So, remember, try to
avoid unnecessary work.


253
00:10:30,256 --> 00:10:32,126
Monitor the app, your
application's state to know


254
00:10:32,126 --> 00:10:32,936
when it's not visible.


255
00:10:33,336 --> 00:10:36,296
Avoid updating the UI until
the user can see the results


256
00:10:36,516 --> 00:10:39,806
and make sure to be efficient in
napping yourself when not in use


257
00:10:39,806 --> 00:10:41,406
so App Nap doesn't
have to take effect.


258
00:10:41,876 --> 00:10:46,816
So, with that, let's talk about
doing it at a better time.


259
00:10:47,186 --> 00:10:49,976
So, user devices have lots
of different power states.


260
00:10:49,976 --> 00:10:51,026
Sometimes, they're plugged in.


261
00:10:51,026 --> 00:10:52,026
Sometimes, they're on battery.


262
00:10:52,916 --> 00:10:54,706
And when you do work, in effect,


263
00:10:55,366 --> 00:10:57,686
what the user's overall
experience over a long period


264
00:10:57,686 --> 00:10:59,526
of time is with respect
to their battery life.


265
00:11:00,576 --> 00:11:03,966
So, if we imagine here,
your typical user day, oh,


266
00:11:03,966 --> 00:11:06,676
maybe not typical, but
the user forgets to plug


267
00:11:06,676 --> 00:11:08,636
in their device overnight,
they get a little bit of charge


268
00:11:08,636 --> 00:11:11,166
in the morning and then
they have this big window


269
00:11:11,166 --> 00:11:13,386
until noon before they can
plug in their device again.


270
00:11:13,846 --> 00:11:15,396
And our goal here is
obviously to make it


271
00:11:15,396 --> 00:11:16,826
so the user never
runs out of battery.


272
00:11:17,096 --> 00:11:18,386
So, let's take a
look at what happens.


273
00:11:19,496 --> 00:11:21,996
We start out, user is doing OK.


274
00:11:21,996 --> 00:11:23,226
They get a little
charge in the morning.


275
00:11:23,476 --> 00:11:25,206
And now, they're
sitting around at 10 a.m.


276
00:11:25,336 --> 00:11:26,496
and they run your application.


277
00:11:27,996 --> 00:11:29,956
Well, your application
decides it wants


278
00:11:29,956 --> 00:11:31,676
to do something very
power intensive,


279
00:11:31,726 --> 00:11:33,786
wants to download new
content, do some update,


280
00:11:34,186 --> 00:11:35,576
and that uses a lot of energy.


281
00:11:36,576 --> 00:11:39,076
Well, now, we've dramatically
reduced the user's battery life


282
00:11:39,146 --> 00:11:39,816
and they're going to run


283
00:11:39,816 --> 00:11:41,586
out of energy before they
have a chance to plug in.


284
00:11:41,736 --> 00:11:44,736
And the user is now very sad,
we're sad, everyone is sad,


285
00:11:44,736 --> 00:11:45,956
this isn't a good experience.


286
00:11:46,566 --> 00:11:48,936
But what if instead of
running that work immediately,


287
00:11:49,436 --> 00:11:51,396
you knew this just needs
to happen sometimes soon.


288
00:11:51,396 --> 00:11:52,866
It doesn't need to
happen right now.


289
00:11:52,866 --> 00:11:54,326
And you were to tell the system,


290
00:11:54,326 --> 00:11:56,356
please let me know
when a good time is.


291
00:11:56,766 --> 00:11:58,406
Give the system a
window to schedule in


292
00:11:59,326 --> 00:12:02,386
and then let the system
automatically move


293
00:12:02,386 --> 00:12:04,706
that work out to a better time.


294
00:12:05,426 --> 00:12:09,626
And now, rather than running out
of battery, our user makes it


295
00:12:09,626 --> 00:12:10,886
to a time when they can plug in.


296
00:12:11,256 --> 00:12:11,896
They're happy.


297
00:12:12,226 --> 00:12:14,816
Your app isn't blamed for
causing their poor battery life,


298
00:12:15,556 --> 00:12:18,256
and we have a general
improvement in user experience.


299
00:12:19,646 --> 00:12:24,316
So, on OS X Yosemite, we have
a new foundation API called


300
00:12:24,356 --> 00:12:27,896
NSBackgroundActivityScheduler
that you can use


301
00:12:27,896 --> 00:12:29,246
to accomplish exactly this.


302
00:12:29,616 --> 00:12:32,006
It allows you to
schedule an arbitrary task


303
00:12:32,006 --> 00:12:33,336
for some good time
in the future.


304
00:12:34,186 --> 00:12:36,776
It supports repeating or
non-repeating activities.


305
00:12:36,776 --> 00:12:39,526
So, it's great for any periodic
updating you might need to do.


306
00:12:39,526 --> 00:12:42,476
And you can use it
to schedule things


307
00:12:42,476 --> 00:12:45,956
like periodic content
fetches, update installs,


308
00:12:45,956 --> 00:12:47,906
garbage collection or
data maintenance tasks,


309
00:12:48,186 --> 00:12:50,346
automatic saves or
backups-really anything you do


310
00:12:50,346 --> 00:12:52,086
in the background that
doesn't need to happen


311
00:12:52,086 --> 00:12:54,136
at a particular time,
you can sort of do


312
00:12:54,136 --> 00:12:55,836
when the system conditions
are right.


313
00:12:56,896 --> 00:12:58,756
So, let's take a look
at how to use this API.


314
00:13:00,146 --> 00:13:01,516
The first thing you'll
do is create an


315
00:13:01,516 --> 00:13:03,336
NSBackgroundActivityScheduler
object.


316
00:13:03,556 --> 00:13:05,396
And you'll use the
initWithIdentifier method


317
00:13:05,876 --> 00:13:08,616
to pass in an identifier for
that particular activity.


318
00:13:09,326 --> 00:13:11,536
This is something that you
should put in reverse-DNS style


319
00:13:11,896 --> 00:13:13,936
and use it to identify the
particular action you're


320
00:13:13,936 --> 00:13:14,826
doing uniquely.


321
00:13:15,096 --> 00:13:17,696
But you also want to try
to reuse these identifiers


322
00:13:17,696 --> 00:13:21,336
over multiple invocations
of that activity or launches


323
00:13:21,336 --> 00:13:24,586
of your app because the system
will use identifiers as a way


324
00:13:24,586 --> 00:13:26,266
to learn about the
activity you're doing


325
00:13:26,266 --> 00:13:27,846
and make better scheduling
decisions.


326
00:13:28,866 --> 00:13:31,196
So, once you've created
a scheduler,


327
00:13:31,196 --> 00:13:33,156
you can now specify
scheduling properties.


328
00:13:33,526 --> 00:13:36,006
So, and let's say we want
to have something fire


329
00:13:36,006 --> 00:13:37,106
in the next 10 minutes.


330
00:13:37,306 --> 00:13:40,576
What we can do is specify the
tolerance to be 600 seconds.


331
00:13:40,976 --> 00:13:43,406
And then, when we
run the activity,


332
00:13:43,446 --> 00:13:46,016
we'll try to schedule it within
that 10-minute tolerance period.


333
00:13:46,556 --> 00:13:49,096
On the other hand, if we
want to schedule something


334
00:13:49,096 --> 00:13:52,306
out for the future, let's say
we want it to happen between 15


335
00:13:52,306 --> 00:13:55,596
and 45 minutes from now,
we can specify an interval


336
00:13:55,996 --> 00:13:58,726
of 30 minutes and a
tolerance of 15 minutes.


337
00:13:59,246 --> 00:14:01,196
And what this means is
that we want this work


338
00:14:01,196 --> 00:14:04,596
to happen 30 minutes plus or
minus 15 minutes in the future.


339
00:14:05,646 --> 00:14:08,646
And finally, if we want
the activity to repeat,


340
00:14:09,046 --> 00:14:11,276
let's say we want to check
for new content every hour,


341
00:14:11,786 --> 00:14:15,466
you can set repeats equals YES
and then interval to 60 minutes.


342
00:14:15,666 --> 00:14:18,416
And now, we'll try to have the
activity run once each hour.


343
00:14:18,806 --> 00:14:21,256
It's actually once each hour
in the sense that if you were


344
00:14:21,256 --> 00:14:23,686
to break up time into one-hour
periods, we'll make sure


345
00:14:23,686 --> 00:14:25,516
to run it once in each period.


346
00:14:25,516 --> 00:14:27,746
So, your average time
will be once every hour.


347
00:14:27,746 --> 00:14:30,796
But within a period, it
might happen sooner or later.


348
00:14:31,246 --> 00:14:32,016
But the benefit of this is


349
00:14:32,016 --> 00:14:33,876
that you won't experience
drift over time.


350
00:14:34,216 --> 00:14:34,546
All right.


351
00:14:35,576 --> 00:14:38,246
So, once you've specified
scheduling properties,


352
00:14:38,246 --> 00:14:39,976
now it's time to actually go
ahead and schedule the work.


353
00:14:40,376 --> 00:14:41,286
This is pretty simple.


354
00:14:41,886 --> 00:14:44,166
You'll call the
scheduleWithBlock method


355
00:14:44,296 --> 00:14:45,326
on the activity object.


356
00:14:45,846 --> 00:14:48,296
And you'll pass in a block that
takes a completion handler.


357
00:14:48,366 --> 00:14:51,336
In that block, you can do
whatever work you might need


358
00:14:51,336 --> 00:14:54,336
to do and it's perfectly OK
to do that work asynchronously


359
00:14:54,336 --> 00:14:55,716
and save off the
completion handler.


360
00:14:56,186 --> 00:14:57,116
But then when you're done,


361
00:14:57,436 --> 00:14:58,656
you'll call the completion
handler


362
00:14:58,656 --> 00:15:00,046
with NSBackgroundActivity


363
00:15:00,046 --> 00:15:02,406
ResultFinished to
indicate that to the system


364
00:15:02,406 --> 00:15:05,546
that now this activity is done,
you've completed the work.


365
00:15:06,046 --> 00:15:10,146
Of course, if the work is really
long running, maybe, you know,


366
00:15:10,146 --> 00:15:13,066
multiple minutes, it's possible
the system power state will


367
00:15:13,176 --> 00:15:15,746
change during the
execution of that work.


368
00:15:16,056 --> 00:15:18,786
In this case, you want to
give the system the ability


369
00:15:18,786 --> 00:15:21,606
to tell you to pause and
later resume that work.


370
00:15:22,006 --> 00:15:25,246
And you can do this by checking
the shouldDefer property


371
00:15:25,246 --> 00:15:25,906
of the activity.


372
00:15:26,346 --> 00:15:27,346
This returns YES.


373
00:15:27,646 --> 00:15:30,016
The state of the system has
changed and we would like you


374
00:15:30,016 --> 00:15:32,526
to defer the remaining
work until a better time.


375
00:15:32,786 --> 00:15:34,266
So, you can check that property


376
00:15:34,636 --> 00:15:36,146
and then call the
completion handler


377
00:15:36,146 --> 00:15:37,636
with NSBackgroundActivity


378
00:15:37,636 --> 00:15:40,586
ResultDeferred to indicate
to the system that it should,


379
00:15:40,976 --> 00:15:42,296
that you're going
to pause the work


380
00:15:42,296 --> 00:15:43,776
and that it should
call you back later.


381
00:15:45,326 --> 00:15:47,956
We're using the same scheduling
parameters as you started with.


382
00:15:48,606 --> 00:15:52,416
So, that's
NSBackgroundActivityScheduler.


383
00:15:52,886 --> 00:15:55,386
You specify the scheduling
requirements for the work.


384
00:15:55,966 --> 00:15:58,096
The system selects the best
time to perform that work.


385
00:15:58,976 --> 00:16:01,696
We have support for
repeating tasks without drift,


386
00:16:02,086 --> 00:16:05,736
and it's available in OS
X Yosemite, or if you want


387
00:16:05,886 --> 00:16:07,836
to use a C API, it was available


388
00:16:07,896 --> 00:16:10,926
as XPC activity in
10.9 Mavericks.


389
00:16:11,496 --> 00:16:14,996
Now, this works really
well for CPU or I/O or kind


390
00:16:14,996 --> 00:16:16,746
of other local intensive tasks.


391
00:16:17,256 --> 00:16:20,976
But if you want to do large
transfers to or from a server


392
00:16:20,976 --> 00:16:23,176
on the network, we actually
have an even better solution


393
00:16:23,176 --> 00:16:25,556
and that comes in the
form of the NSURLSession


394
00:16:25,826 --> 00:16:27,056
with the Background Session.


395
00:16:28,336 --> 00:16:30,116
So, let's imagine we
have an application,


396
00:16:30,706 --> 00:16:32,296
and your app has a number


397
00:16:32,296 --> 00:16:34,626
of NSURLRequests it
would like to issue.


398
00:16:35,656 --> 00:16:37,586
What the Background Session
lets you do is create an


399
00:16:37,586 --> 00:16:41,836
NSURLSession, pass it
those NSURLRequests.


400
00:16:42,296 --> 00:16:44,586
But then, instead of
creating in-process tasks,


401
00:16:44,896 --> 00:16:46,956
those go out of process
to a system daemon


402
00:16:47,356 --> 00:16:49,316
that can then handle
executing those tasks for you.


403
00:16:49,726 --> 00:16:51,586
And if your app sticks around,


404
00:16:51,586 --> 00:16:53,946
then you'll get delegate methods
called on your delegate just


405
00:16:53,946 --> 00:16:55,846
like you normally would
with NSURLSession.


406
00:16:56,366 --> 00:17:00,086
But the really cool thing is
if your app happens to go away,


407
00:17:00,556 --> 00:17:03,506
let's say the user quits it,
maybe the system reboots,


408
00:17:04,056 --> 00:17:07,156
those tasks will stick around
in that out-of-process session


409
00:17:07,665 --> 00:17:10,445
and get processed while
your app isn't running.


410
00:17:11,016 --> 00:17:13,006
So, that means if you need to
do, you know, many hundreds


411
00:17:13,006 --> 00:17:15,596
of megabyte download, your app
doesn't have to stay running


412
00:17:15,596 --> 00:17:16,656
for that download to continue.


413
00:17:17,566 --> 00:17:19,336
Then, when your app
gets relaunched,


414
00:17:20,136 --> 00:17:23,195
you'll use the same
backgroundSession


415
00:17:23,195 --> 00:17:26,346
ConfigurationWithIdentifier
call and make sure you pass


416
00:17:26,346 --> 00:17:27,925
in the same identifier
as before,


417
00:17:28,236 --> 00:17:30,556
and you'll get reconnected
with that existing session


418
00:17:30,826 --> 00:17:33,906
and then get your delegate
methods called for those tasks


419
00:17:34,236 --> 00:17:35,766
for whatever progress
has happened


420
00:17:35,766 --> 00:17:37,446
on those tasks while
your app isn't running.


421
00:17:38,316 --> 00:17:41,536
This is already great
features in an iOS.


422
00:17:41,706 --> 00:17:44,596
It supports multitasking, so
your app can get re-awoken


423
00:17:44,596 --> 00:17:46,256
to receive these
delegate methods.


424
00:17:46,726 --> 00:17:50,366
But the really cool part
for power comes into play


425
00:17:50,366 --> 00:17:53,286
when we talk about the
concepts of discretionary tasks.


426
00:17:54,086 --> 00:17:55,306
So, there's a configuration


427
00:17:55,586 --> 00:17:57,856
on the NSURLSession
configuration object.


428
00:17:58,226 --> 00:18:00,186
You can set the discretionary
property to TRUE.


429
00:18:00,496 --> 00:18:03,496
And it's something
that's available in iOS 7


430
00:18:03,496 --> 00:18:04,976
or now in OS X Yosemite.


431
00:18:05,676 --> 00:18:08,666
And what this tells the system
to do is to pick the best time


432
00:18:08,666 --> 00:18:11,076
to do the work based on
a variety of factors,


433
00:18:11,186 --> 00:18:14,686
including system power state,
network state and more.


434
00:18:14,846 --> 00:18:18,316
And it will automatically
provide things


435
00:18:18,316 --> 00:18:20,456
like bandwidth monitoring
and automatic retry.


436
00:18:20,596 --> 00:18:22,376
So, bandwidth monitoring
is important


437
00:18:22,376 --> 00:18:24,836
because it's very energy
inefficient to do work


438
00:18:24,836 --> 00:18:26,546
over super-slow connections.


439
00:18:26,756 --> 00:18:28,856
And so, when you're using
the Background Session


440
00:18:28,856 --> 00:18:32,456
with a discretionary task, we'll
monitor the effective bandwidth.


441
00:18:32,456 --> 00:18:35,156
And if it falls below certain
levels, automatically stop


442
00:18:35,156 --> 00:18:36,646
and later retry that task


443
00:18:36,646 --> 00:18:38,556
to make sure we can download
it quickly and efficiently.


444
00:18:39,246 --> 00:18:41,906
We can also, because of
this, do automatic retry.


445
00:18:42,216 --> 00:18:43,636
So, if the network
gets disconnected,


446
00:18:43,926 --> 00:18:45,846
we'll then automatically
retry the task later


447
00:18:45,846 --> 00:18:48,616
when the network becomes
available, handling a variety


448
00:18:48,646 --> 00:18:51,886
of edge cases in uploads and
downloads automatically for you.


449
00:18:53,386 --> 00:18:56,516
Now, you can adjust this way
we schedule discretionary tasks


450
00:18:56,636 --> 00:18:58,756
by changing the
timeoutIntervalForResource


451
00:18:58,756 --> 00:19:00,496
property on the configuration
object.


452
00:19:00,856 --> 00:19:02,726
So, in this case, we
specified one day.


453
00:19:02,726 --> 00:19:05,646
So then, we want this to happen
sometime within 24 hours.


454
00:19:06,206 --> 00:19:09,336
Now, if this timeout elapses,
you'll get an error thrown.


455
00:19:09,676 --> 00:19:11,556
So, generally, you want to
make sure this is long enough


456
00:19:11,556 --> 00:19:13,366
that we can reasonably
do the download,


457
00:19:13,886 --> 00:19:16,056
taking into account the fact
there might not always be


458
00:19:16,056 --> 00:19:17,436
appropriate networking
available.


459
00:19:18,206 --> 00:19:20,826
It's why anything less than
12 hours is probably going


460
00:19:20,826 --> 00:19:22,446
to put stress in
the system's ability


461
00:19:22,446 --> 00:19:23,706
to effectively do the work.


462
00:19:24,786 --> 00:19:28,096
This was a very high level
overview to NSURLSession,


463
00:19:28,096 --> 00:19:30,616
just enough to kind
of whet your appetite.


464
00:19:30,616 --> 00:19:33,396
If you want to learn more,
check out yesterday's What's New


465
00:19:33,396 --> 00:19:35,676
in Foundation Networking
talk, where they go


466
00:19:35,676 --> 00:19:36,566
into much more detail


467
00:19:36,566 --> 00:19:38,766
on the Background
Session and how to use it.


468
00:19:40,356 --> 00:19:42,756
So that was Do It
at a Better Time.


469
00:19:42,756 --> 00:19:45,346
We talked about how you can let
the system schedule your work


470
00:19:45,346 --> 00:19:46,716
for power optimum execution.


471
00:19:47,086 --> 00:19:48,566
But let's say you're
already executing,


472
00:19:49,086 --> 00:19:50,286
maybe at the better time.


473
00:19:51,106 --> 00:19:52,376
I want to talk now about ways


474
00:19:52,376 --> 00:19:54,076
that you can do your
work more efficiently.


475
00:19:55,316 --> 00:19:58,036
So, our system has a variety of
resource management properties.


476
00:19:58,426 --> 00:20:00,726
Some of these affect the
responsiveness of the system


477
00:20:00,726 --> 00:20:01,976
when a particular
task is going on.


478
00:20:02,656 --> 00:20:05,566
This includes things like
the CPU Scheduler Priority


479
00:20:05,646 --> 00:20:08,126
and the I/O Priority
for a particular task.


480
00:20:08,376 --> 00:20:11,446
We also have properties that
affect the efficiency of work.


481
00:20:11,826 --> 00:20:13,876
This includes the amount of
time we're coalescing or willing


482
00:20:13,876 --> 00:20:17,046
to apply, or hence, as to
whether we should run the CPU


483
00:20:17,046 --> 00:20:20,236
in a throughput or
efficiency-oriented mode.


484
00:20:21,316 --> 00:20:23,456
Now, these properties
are very difficult


485
00:20:23,456 --> 00:20:25,136
to specify individually.


486
00:20:25,226 --> 00:20:26,956
It's complicated
to get it right.


487
00:20:27,276 --> 00:20:29,976
And so, most developers are
simply left the whens they could


488
00:20:29,976 --> 00:20:31,556
get by using these
properties on the table.


489
00:20:32,226 --> 00:20:34,096
So, we want to make
this easy to be able


490
00:20:34,096 --> 00:20:37,016
to use the correct values
for all these properties.


491
00:20:37,406 --> 00:20:39,366
And in OS X Yosemite and iOS 8,


492
00:20:39,786 --> 00:20:41,326
we're introducing
something called Quality


493
00:20:41,326 --> 00:20:43,726
of Service Classes that
can help you do this.


494
00:20:44,316 --> 00:20:46,026
So, there are four Quality


495
00:20:46,026 --> 00:20:47,716
of Service Classes we have
defined on the system.


496
00:20:48,276 --> 00:20:50,306
The first is User
Interactive, which indicates


497
00:20:50,306 --> 00:20:51,736
that this work is involved


498
00:20:51,736 --> 00:20:53,836
in creating a smooth,
buttery user UI.


499
00:20:54,366 --> 00:20:56,676
It's these things like the
main thread, animations,


500
00:20:56,846 --> 00:20:59,386
event processing, whether
that's touch events or meeting


501
00:20:59,386 --> 00:21:02,176
or some other kind
of event processing


502
00:21:02,176 --> 00:21:04,516
where we need very,
very short latencies.


503
00:21:05,366 --> 00:21:08,836
User Initiated is
for doing request,


504
00:21:08,836 --> 00:21:11,426
making servicing requests
that the user has made in ways


505
00:21:11,426 --> 00:21:14,446
that we need to provide
immediate results.


506
00:21:14,596 --> 00:21:17,086
So, these are clicks on an
object to get more information


507
00:21:17,086 --> 00:21:18,406
about it in your user interface.


508
00:21:18,796 --> 00:21:20,596
The task of getting the
details of that object


509
00:21:20,596 --> 00:21:23,456
and populating them onscreen
would fall into User Initiated.


510
00:21:24,476 --> 00:21:26,736
Utility, for longer
running tasks.


511
00:21:26,736 --> 00:21:29,946
So User Initiated and User
Interactive are designed to be


512
00:21:29,946 --> 00:21:31,836
as performant as possible.


513
00:21:32,456 --> 00:21:35,216
Utility, we try to achieve a
good balance between throughput


514
00:21:35,216 --> 00:21:36,116
and energy efficiency.


515
00:21:36,306 --> 00:21:38,116
So, we want to put
longer-running tasks


516
00:21:38,456 --> 00:21:42,306
where we don't want to
have an over, we don't want


517
00:21:43,286 --> 00:21:45,416
to put a large power
drain on the system.


518
00:21:45,946 --> 00:21:47,526
And then Background, for things


519
00:21:47,526 --> 00:21:49,146
that are not visible
to the user.


520
00:21:49,986 --> 00:21:52,086
So, with all these
classes, how do you pick?


521
00:21:52,186 --> 00:21:55,486
So, the question you
want to ask yourself,


522
00:21:55,486 --> 00:21:58,396
or User Interactive is, Is
this work actively involved


523
00:21:58,396 --> 00:21:59,156
in updating the UI?


524
00:22:00,106 --> 00:22:02,796
If this doesn't happen, will
the UI appear to be frozen?


525
00:22:03,416 --> 00:22:05,106
This includes things
like the main thread,


526
00:22:05,106 --> 00:22:08,036
which we handle automatically
for you, animations


527
00:22:08,036 --> 00:22:09,736
or input event processing.


528
00:22:10,616 --> 00:22:12,536
If the answer is no,
then you want to think


529
00:22:12,536 --> 00:22:14,436
about User Initiated and
ask yourself the question,


530
00:22:14,676 --> 00:22:17,526
Is this work required to
continue user interaction?


531
00:22:18,296 --> 00:22:20,686
So, for example, is
this actively involved


532
00:22:20,686 --> 00:22:22,176
in loading content
that the user needs


533
00:22:22,176 --> 00:22:25,636
to see before they can make
the next user interaction


534
00:22:25,636 --> 00:22:26,466
in your application?


535
00:22:27,686 --> 00:22:29,186
If this isn't the
case, for example,


536
00:22:29,186 --> 00:22:31,936
the user initiates a task
and it's long running


537
00:22:31,936 --> 00:22:33,076
and displays a progress bar.


538
00:22:33,416 --> 00:22:35,266
So, either they can
continue interacting


539
00:22:35,266 --> 00:22:37,066
with your application
or you might expect them


540
00:22:37,066 --> 00:22:40,806
to take a break or go switch
to another app on OS X.


541
00:22:40,806 --> 00:22:42,916
You want to think about Utility.


542
00:22:42,976 --> 00:22:45,156
In which case, the question
you can ask yourself is,


543
00:22:45,926 --> 00:22:47,966
Is the user aware of the
progress of this work?


544
00:22:48,436 --> 00:22:50,656
If it's a longer-running job
with a progress indicator,


545
00:22:50,656 --> 00:22:52,416
that's perfectly
suited to Utility.


546
00:22:53,496 --> 00:22:55,606
And then finally,
for Background,


547
00:22:56,106 --> 00:22:56,966
that's the remaining work


548
00:22:56,966 --> 00:22:58,746
that the user isn't
aware of the progress of.


549
00:22:59,006 --> 00:23:00,706
And for Background work,
you want to ask yourself,


550
00:23:00,996 --> 00:23:03,896
Can this work be
deferred to a better time?


551
00:23:04,346 --> 00:23:07,016
If so, use the
NSBackgroundActivityScheduler


552
00:23:07,016 --> 00:23:09,206
object in addition to
running in Background.


553
00:23:10,506 --> 00:23:13,186
So, let's say you've gone
through, you've thought


554
00:23:13,186 --> 00:23:15,586
about a piece of work in your
application and you decide


555
00:23:15,586 --> 00:23:18,066
that User Initiated is
probably the right Quality


556
00:23:18,066 --> 00:23:18,926
of Service Class.


557
00:23:19,386 --> 00:23:21,516
Well, the next thing you want


558
00:23:21,516 --> 00:23:23,166
to do is ask yourself
a few more questions.


559
00:23:23,566 --> 00:23:27,396
The first is, Is it OK if User
Interactive work happens before


560
00:23:28,016 --> 00:23:29,076
my User Initiated work?


561
00:23:30,126 --> 00:23:31,986
Is it OK for this
work to compete


562
00:23:31,986 --> 00:23:33,336
with other User Initiated work?


563
00:23:34,086 --> 00:23:36,546
And is it OK for my
work to take precedence


564
00:23:36,546 --> 00:23:38,196
over Utility and
Background work?


565
00:23:38,866 --> 00:23:41,476
Ultimately, these Quality of
Service Classes form a hierarchy


566
00:23:41,906 --> 00:23:44,736
and the system will prefer
things higher up in this list.


567
00:23:44,736 --> 00:23:47,246
So, you want to make sure
that within your application,


568
00:23:47,656 --> 00:23:49,556
you've picked a set of
Quality of Service Classes


569
00:23:49,816 --> 00:23:51,736
that let the system
appropriately prioritize


570
00:23:51,736 --> 00:23:55,316
resources, which brings
us to what exactly happens


571
00:23:55,316 --> 00:23:57,116
when you specify a
Quality of Service Class.


572
00:23:57,116 --> 00:23:59,986
So, let's imagine we
have a Background Quality


573
00:23:59,986 --> 00:24:03,226
of Service operation running,
and it's using a lot of CPU


574
00:24:03,226 --> 00:24:05,386
and has a lot of I/O going on.


575
00:24:06,006 --> 00:24:08,736
And then, a User
Initiated task comes around.


576
00:24:09,706 --> 00:24:11,626
Well, what the system is
going to do is it's going


577
00:24:11,626 --> 00:24:15,006
to prioritize resources to
the User Initiated task,


578
00:24:15,496 --> 00:24:18,126
letting that get the majority
of the throughput on the system


579
00:24:18,376 --> 00:24:20,086
and letting that
work happen quickly.


580
00:24:21,936 --> 00:24:26,656
Similarly, if we were to look at
power graphs for User Initiated


581
00:24:26,656 --> 00:24:29,806
and Background work, in User
Initiated, we run the work


582
00:24:29,806 --> 00:24:32,156
as quickly as possible,
but potentially


583
00:24:32,156 --> 00:24:33,576
in power-inefficient ways.


584
00:24:34,116 --> 00:24:36,896
Whereas, for Background work,
we will try to run the system


585
00:24:36,896 --> 00:24:38,306
in power-efficient ways.


586
00:24:38,346 --> 00:24:39,916
It might take slightly longer,


587
00:24:40,366 --> 00:24:42,726
but your overall energy
consumption will be reduced.


588
00:24:43,656 --> 00:24:46,526
And, of course, Utility falls
on the middle of the spectrum.


589
00:24:47,016 --> 00:24:48,066
And so in this way,


590
00:24:48,236 --> 00:24:50,346
by appropriately
classifying your Utility


591
00:24:50,346 --> 00:24:53,426
and Background work, you can
both improve the responsiveness


592
00:24:53,786 --> 00:24:55,816
of User Initiated and
User Interactive work


593
00:24:56,176 --> 00:24:58,286
and improve your overall
energy efficiency.


594
00:24:59,496 --> 00:25:00,356
All right.


595
00:25:00,356 --> 00:25:02,266
So, let's take a look at
an example application


596
00:25:02,266 --> 00:25:05,626
and how we might apply
Quality of Service to it.


597
00:25:05,866 --> 00:25:07,906
So, we have PhotoMeister 3000.


598
00:25:07,906 --> 00:25:09,956
It's our kind of generic
photos application.


599
00:25:10,396 --> 00:25:13,236
You connect the camera
containing a bunch of RAW images


600
00:25:13,556 --> 00:25:15,516
and we pull off some
JPEG previews


601
00:25:15,726 --> 00:25:17,036
and display a bunch
of thumbnails.


602
00:25:17,036 --> 00:25:18,466
And then in the background,


603
00:25:18,676 --> 00:25:20,506
load the full-size
images and convert them.


604
00:25:21,296 --> 00:25:23,026
They, of course also
have search functionality


605
00:25:23,026 --> 00:25:24,816
because every app needs
search functionality.


606
00:25:24,816 --> 00:25:28,096
So, how do we apply
Quality of Service?


607
00:25:28,386 --> 00:25:30,326
Well, User Interactive
is just going to be used


608
00:25:30,326 --> 00:25:32,026
for the main thread
in our application.


609
00:25:32,246 --> 00:25:33,866
And that happens automatically


610
00:25:33,866 --> 00:25:35,546
without you having
to do any work.


611
00:25:37,566 --> 00:25:40,156
User Initiated, we're going to
use for thumbnail generation.


612
00:25:40,156 --> 00:25:43,746
And this is because the
user plugs in their camera,


613
00:25:43,746 --> 00:25:44,666
and the next thing they want


614
00:25:44,666 --> 00:25:46,136
to do is start browsing
the thumbnails.


615
00:25:46,406 --> 00:25:48,596
And so, their ability to
make the next interaction


616
00:25:48,596 --> 00:25:51,326
with their application is
dependent upon those thumbnails


617
00:25:51,326 --> 00:25:51,986
being available.


618
00:25:52,136 --> 00:25:53,916
So, it's going to run
at User Initiated.


619
00:25:53,916 --> 00:25:56,776
Now, imagine that the user
is browsing these thumbnails


620
00:25:56,776 --> 00:25:59,326
and they click on one to try
to view the photo full size.


621
00:25:59,736 --> 00:26:02,126
Their next interaction, which
might be looking at the photos,


622
00:26:02,126 --> 00:26:04,196
scrolling through it,
depends on the ability


623
00:26:04,196 --> 00:26:05,566
to load that full-size image.


624
00:26:05,976 --> 00:26:08,486
So, we're going to load
just that particular image


625
00:26:08,486 --> 00:26:09,996
in that case at User Initiated.


626
00:26:11,116 --> 00:26:13,666
But all the other images we're
going to load off the camera


627
00:26:13,666 --> 00:26:15,686
and convert should
happen at Utility.


628
00:26:15,776 --> 00:26:17,876
The user might be able to
see the progress of it,


629
00:26:18,056 --> 00:26:21,486
but you want this work to
happen in deference to the work


630
00:26:21,486 --> 00:26:23,706
of updating the UI, scrolling,


631
00:26:23,706 --> 00:26:25,196
displaying the thumbnails
and so on.


632
00:26:25,726 --> 00:26:28,576
And finally, any
work we have to do


633
00:26:28,576 --> 00:26:30,566
to update our search index
would happen at Background.


634
00:26:31,186 --> 00:26:33,296
This isn't something the user
is aware of the progress of.


635
00:26:33,496 --> 00:26:35,846
And so, we want it to happen
in deference to things


636
00:26:35,846 --> 00:26:37,186
like loading the
images off the camera.


637
00:26:37,846 --> 00:26:42,166
So, let's imagine that our
app, we're trying to figure


638
00:26:42,166 --> 00:26:43,096
out how to build this thing.


639
00:26:43,456 --> 00:26:47,206
Let's kind of create a simple
NSOperation-based approach


640
00:26:47,206 --> 00:26:49,316
to writing this application.


641
00:26:50,086 --> 00:26:53,066
We might create an
NSOperationQueue


642
00:26:53,066 --> 00:26:55,416
for thumbnail generation
and create an NSOperation


643
00:26:55,416 --> 00:26:56,716
for each thumbnail
we want to generate.


644
00:26:57,246 --> 00:27:00,456
And we might create another
queue for image conversion


645
00:27:00,906 --> 00:27:03,066
and an operation for each
image we want to convert.


646
00:27:04,046 --> 00:27:06,606
So, how does this play into QOS?


647
00:27:07,436 --> 00:27:12,516
So, in OS X Yosemite
and iOS 8, NSOperation,


648
00:27:12,616 --> 00:27:15,606
NSOperationQueue now have
a qualityOfService property


649
00:27:15,836 --> 00:27:17,836
that you can use
to set what Quality


650
00:27:17,836 --> 00:27:19,296
of Service particular
work should run at.


651
00:27:19,896 --> 00:27:22,476
So, if we want to run an
NSOperation at Utility,


652
00:27:22,856 --> 00:27:25,146
we can simply say
operation.qualityOfService


653
00:27:25,146 --> 00:27:27,056
equals
NSQualityOfServiceUtility.


654
00:27:27,496 --> 00:27:31,486
If you set a Quality of
Service on both an operation


655
00:27:31,606 --> 00:27:33,956
and the queue, we'll use
the higher of the two.


656
00:27:35,106 --> 00:27:37,776
And if you don't set
NSOperation, for example,


657
00:27:37,776 --> 00:27:39,976
in the code you're shipping
today, we will attempt


658
00:27:39,976 --> 00:27:43,116
to infer an NSOperation from the
environment whenever possible.


659
00:27:43,476 --> 00:27:45,846
So, what this means is that
if you have code executing


660
00:27:45,846 --> 00:27:47,276
at Utility Quality of Service


661
00:27:47,656 --> 00:27:50,576
and you create a new
NSOperation inside of that code,


662
00:27:51,086 --> 00:27:53,746
that new NSOperation will
automatically use Utility


663
00:27:54,136 --> 00:27:56,466
if there isn't a Quality
of Service set later


664
00:27:56,466 --> 00:27:58,016
on that operation
or on the queue.


665
00:27:58,626 --> 00:28:03,386
So, if we go back to
our application example,


666
00:28:03,456 --> 00:28:05,746
if we want to apply
Quality of Service to this,


667
00:28:05,746 --> 00:28:07,676
the first thing we'll
do is set User Initiated


668
00:28:07,676 --> 00:28:10,906
on our thumbnail generation
queue, and then Utility


669
00:28:11,216 --> 00:28:12,386
on our image conversion queue.


670
00:28:12,826 --> 00:28:14,426
And now, those pieces
of work will happen


671
00:28:14,426 --> 00:28:16,126
at the appropriate
Quality of Service.


672
00:28:17,196 --> 00:28:19,596
But Quality of Service
isn't static.


673
00:28:19,966 --> 00:28:21,406
And the logical Quality
of Service


674
00:28:21,406 --> 00:28:23,186
of an operation might
change over time.


675
00:28:23,646 --> 00:28:26,466
So, for example, you start
doing a conversion of an image


676
00:28:26,706 --> 00:28:28,986
at Utility but the user
wants to view the result.


677
00:28:29,646 --> 00:28:32,466
Well now, that work needs to
happen at User Initiated Quality


678
00:28:32,466 --> 00:28:33,716
of Service instead of Utility.


679
00:28:35,316 --> 00:28:36,996
With NSOperation,
we have three ways


680
00:28:36,996 --> 00:28:40,046
that we can promote the Quality
of Service of existing work.


681
00:28:40,646 --> 00:28:43,836
The first is enqueueing a higher
Quality of Service operation


682
00:28:43,836 --> 00:28:45,256
on the same queue as that work.


683
00:28:46,176 --> 00:28:49,006
If you have a queue full
of utility operations


684
00:28:49,376 --> 00:28:51,166
and you enqueue something
that's User Initiated,


685
00:28:51,606 --> 00:28:54,656
we will then promote everything
in front of that operation.


686
00:28:54,796 --> 00:28:55,936
Also, to User Initiated.


687
00:28:56,256 --> 00:28:58,796
So, that operation gets to the
front of the queue and runs


688
00:28:58,796 --> 00:29:00,546
at an appropriate time.


689
00:29:01,566 --> 00:29:05,196
If you use addDependency and
make a, let's for example,


690
00:29:05,326 --> 00:29:07,226
User Initiated operation
dependent


691
00:29:07,356 --> 00:29:09,616
on a Background operation,
we'll promote


692
00:29:09,616 --> 00:29:11,526
that Background operation
to User Initiated.


693
00:29:11,986 --> 00:29:14,486
And finally, if you
use waitUntilFinished


694
00:29:14,516 --> 00:29:16,376
or waitUntilAllOperations


695
00:29:16,376 --> 00:29:18,686
AreFinished from a higher
Quality of Service thread,


696
00:29:18,686 --> 00:29:20,996
we will promote the
operations you're waiting on.


697
00:29:21,546 --> 00:29:24,026
So, if we go back
to our example,


698
00:29:24,196 --> 00:29:27,206
and let's say you get an event
that indicates the user tapped


699
00:29:27,206 --> 00:29:29,326
on a particular image
to view it full size,


700
00:29:30,136 --> 00:29:32,696
the first thing you'll do is
find the operation associated


701
00:29:32,696 --> 00:29:33,826
with converting that image.


702
00:29:34,956 --> 00:29:36,506
You'll then adjust
this queuePriority


703
00:29:36,656 --> 00:29:39,766
to set queuePriority very
high, and after that,


704
00:29:40,126 --> 00:29:42,226
adjust its Quality of
Service to set its Quality


705
00:29:42,226 --> 00:29:43,446
of Service to User Initiated.


706
00:29:44,006 --> 00:29:45,286
And now, if this is our queue,


707
00:29:46,276 --> 00:29:48,606
we've now promoted the operation
we care about to the front


708
00:29:48,606 --> 00:29:51,836
of that queue by adjusting the
queuePriority, and then cause it


709
00:29:51,836 --> 00:29:52,796
to run at User Initiated


710
00:29:52,966 --> 00:29:54,446
by adjusting the
Quality of Service.


711
00:29:56,986 --> 00:29:58,676
All right.


712
00:29:58,676 --> 00:29:59,336
So, quiz time.


713
00:29:59,496 --> 00:29:59,976
This is your turn.


714
00:30:00,326 --> 00:30:02,096
We have another example
app and I'm going to walk


715
00:30:02,096 --> 00:30:04,336
through the different features
of this app, and I want you


716
00:30:04,336 --> 00:30:06,186
to think about what
Quality of Service each


717
00:30:06,186 --> 00:30:07,326
of these features should run at.


718
00:30:07,676 --> 00:30:08,696
Then, I'll let you
know the answer.


719
00:30:09,556 --> 00:30:11,546
So, it's Feed Reader 9000.


720
00:30:11,546 --> 00:30:15,326
It's a kind of typical RSS
or newsreader application.


721
00:30:15,776 --> 00:30:19,326
So, if the user clicks on a
particular item in the feed


722
00:30:19,466 --> 00:30:21,676
and we need to display
the content of that item,


723
00:30:22,386 --> 00:30:26,716
the work to read the item on
our database, render the HTML,


724
00:30:26,766 --> 00:30:28,006
generally get it onscreen.


725
00:30:28,416 --> 00:30:30,276
What do you think
that might run at?


726
00:30:30,756 --> 00:30:35,096
So, that's going to
run at User Initiated.


727
00:30:35,336 --> 00:30:38,126
The user asked for it,
and so we need to display


728
00:30:38,126 --> 00:30:40,116
that content before the
user can interact with it.


729
00:30:40,616 --> 00:30:43,726
But it's not actively
involved scrolling


730
00:30:43,726 --> 00:30:47,016
or otherwise be creating
a buttery user experience.


731
00:30:47,236 --> 00:30:49,606
It's certainly longer
running work than that.


732
00:30:50,336 --> 00:30:52,886
Now, imagine all the
users reading this item,


733
00:30:52,886 --> 00:30:55,656
at the same time, we're
pre-fetching images


734
00:30:55,906 --> 00:30:58,396
that happen later on
in this stream of news.


735
00:30:58,906 --> 00:31:02,046
What Quality of Service
might that run at?


736
00:31:04,696 --> 00:31:06,556
So, we're going to want
to run that at Background.


737
00:31:06,556 --> 00:31:08,686
The user is not aware of
the progress of this work.


738
00:31:09,026 --> 00:31:12,426
And so, we don't need to
give it quite the performance


739
00:31:12,426 --> 00:31:12,986
of Utility.


740
00:31:13,636 --> 00:31:15,356
The Background work
will certainly happen


741
00:31:15,616 --> 00:31:18,046
and we'll be able to
catch those images.


742
00:31:18,296 --> 00:31:20,656
Of course, if the user then
goes to that post or wants


743
00:31:20,656 --> 00:31:21,726
to promote that operation.


744
00:31:23,196 --> 00:31:26,796
What about fetching
new content, new feeds?


745
00:31:27,406 --> 00:31:32,526
So, this one is kind
of a trick question.


746
00:31:33,056 --> 00:31:34,976
If the user requested
the content,


747
00:31:34,976 --> 00:31:38,156
so they click Get New Items
or Get New Feeds button,


748
00:31:38,676 --> 00:31:41,316
the expectation is that now
they're going to be watching


749
00:31:41,316 --> 00:31:43,946
that list of items and be
unable to interact with it


750
00:31:43,946 --> 00:31:46,146
until we've populated
it with new entries.


751
00:31:46,466 --> 00:31:49,446
In that case, doing just the
minimum amount of work possible,


752
00:31:49,636 --> 00:31:51,956
to get the list of items
that they can browse through,


753
00:31:52,176 --> 00:31:53,266
should be User Initiated.


754
00:31:53,956 --> 00:31:56,486
On the other hand, this
happens automatically.


755
00:31:56,486 --> 00:31:57,906
Let's say we have a timer,


756
00:31:58,146 --> 00:32:00,906
hopefully using
NSBackgroundActivityScheduler


757
00:32:01,326 --> 00:32:04,376
that causes us to fetch
new content every hour.


758
00:32:04,796 --> 00:32:06,296
That work should
happen at Utility.


759
00:32:07,376 --> 00:32:09,576
This is something the user
is aware of the progress of.


760
00:32:09,576 --> 00:32:11,186
If it doesn't happen
then, obviously,


761
00:32:11,186 --> 00:32:13,106
they won't see their new items.


762
00:32:13,446 --> 00:32:14,566
But they're not watching for it


763
00:32:14,566 --> 00:32:16,286
and it's not preventing
their further interaction.


764
00:32:16,796 --> 00:32:19,246
And finally, search indexing.


765
00:32:22,516 --> 00:32:24,866
This would happen at Background
because the user isn't aware


766
00:32:24,866 --> 00:32:26,016
of the progress of this work.


767
00:32:26,596 --> 00:32:30,306
So, you've taken
your application.


768
00:32:30,306 --> 00:32:32,526
You've diligently gone
through and adopted Quality


769
00:32:32,526 --> 00:32:33,416
of Service everywhere.


770
00:32:33,496 --> 00:32:34,606
All your work is classified.


771
00:32:34,836 --> 00:32:36,186
How do you actually validate


772
00:32:36,186 --> 00:32:37,506
that this is working
and debug it?


773
00:32:37,796 --> 00:32:39,786
So, there are three things
that you'll want to do.


774
00:32:40,216 --> 00:32:42,256
The first is after
adopting Quality of Service,


775
00:32:42,256 --> 00:32:44,976
set breakpoints to confirm
that your work is running


776
00:32:44,976 --> 00:32:46,576
with the Quality of
Service you adopted.


777
00:32:47,026 --> 00:32:50,386
Use the powermetrics
tool to confirm


778
00:32:50,386 --> 00:32:53,916
for a longer running task which
Quality of Services are in use.


779
00:32:54,426 --> 00:32:58,216
And then you can use the
spindump tool to determine


780
00:32:58,216 --> 00:32:59,726
which Quality of Service
a particular piece


781
00:32:59,726 --> 00:33:02,446
of code is executing with
if what you find using one


782
00:33:02,446 --> 00:33:03,746
of these other methods
is unexpected.


783
00:33:05,386 --> 00:33:07,956
So, let's start with
the first of these.


784
00:33:08,286 --> 00:33:12,306
In Xcode 6, if you first pause
your application, whether using,


785
00:33:12,306 --> 00:33:15,826
just pausing it or setting a
breakpoint, and then you go


786
00:33:15,826 --> 00:33:18,396
to the CPU debug gauge, which
is part of the debug navigator.


787
00:33:18,596 --> 00:33:20,736
Most of you are probably
familiar with this.


788
00:33:21,086 --> 00:33:23,796
The top, you see a graph
of CPU use over time.


789
00:33:24,246 --> 00:33:25,246
And so, we can see
in our example,


790
00:33:25,246 --> 00:33:27,126
we have something burning CPU.


791
00:33:27,816 --> 00:33:29,516
If you then go down
through the threads list,


792
00:33:30,086 --> 00:33:32,936
underneath each thread will
tell you what Quality of Service


793
00:33:32,936 --> 00:33:34,136
that thread currently has.


794
00:33:34,136 --> 00:33:36,396
So, in this case, this
thread has Utility.


795
00:33:36,436 --> 00:33:38,796
And so, we know that that CPU
time is happening at Utility.


796
00:33:39,606 --> 00:33:41,746
Now, this is the
Quality of Service


797
00:33:41,746 --> 00:33:42,806
that your code requested.


798
00:33:43,256 --> 00:33:45,566
So, if you start an operation at
a particular Quality of Service,


799
00:33:45,566 --> 00:33:46,786
that's what will
be displayed here.


800
00:33:47,326 --> 00:33:49,016
If another part of
your application tries


801
00:33:49,016 --> 00:33:51,666
to change the Quality of Service
of that thread, for example,


802
00:33:51,666 --> 00:33:53,566
using the override
API that you'll learn


803
00:33:53,566 --> 00:33:57,026
about in a session later
today, that won't appear here.


804
00:33:59,016 --> 00:34:00,386
So, let's say you've
gone through,


805
00:34:00,516 --> 00:34:03,846
validated your initial adoption,
and now you want to know, OK,


806
00:34:04,066 --> 00:34:06,656
what is my code actually
using in practice?


807
00:34:06,656 --> 00:34:09,726
You can use the powermetrics
command line tool


808
00:34:09,726 --> 00:34:12,226
with the show-process-QOS to see


809
00:34:12,226 --> 00:34:13,746
where your code is
spending time.


810
00:34:14,606 --> 00:34:16,946
So, in this case,
we'll run powermetrics


811
00:34:17,065 --> 00:34:18,436
and we'll get a list
of running tasks


812
00:34:18,436 --> 00:34:20,085
and we can see MyApplication
is here.


813
00:34:20,606 --> 00:34:23,536
And I'm spending 80
milliseconds per second


814
00:34:23,536 --> 00:34:26,446
on the CPU, or about 8 percent.


815
00:34:26,446 --> 00:34:29,985
I can see some information
about timers, which we'll talk


816
00:34:29,985 --> 00:34:30,846
about later in the talk.


817
00:34:31,286 --> 00:34:34,106
But then, what's important to
us here is I get a breakdown


818
00:34:34,106 --> 00:34:36,085
of what Quality of Service
Classes I was using.


819
00:34:36,226 --> 00:34:39,755
So, I can see that I'm spending
88 milliseconds at Utility,


820
00:34:39,976 --> 00:34:41,446
so almost all of
my time is there.


821
00:34:41,686 --> 00:34:42,626
And if that's what I wanted,


822
00:34:42,626 --> 00:34:44,775
then I've done a good job
adopting Quality of Service.


823
00:34:45,556 --> 00:34:47,996
Now, if you find that what
you see here isn't expected,


824
00:34:49,436 --> 00:34:50,746
you can use the spindump tool


825
00:34:50,746 --> 00:34:52,606
to get a more detailed
understanding


826
00:34:52,606 --> 00:34:54,596
of where your code is
executing with respect


827
00:34:54,596 --> 00:34:55,636
to Quality of Service.


828
00:34:56,295 --> 00:34:57,526
So, if you're not
familiar with spindump,


829
00:34:57,526 --> 00:34:59,466
it's kind of like
sample or time profile.


830
00:34:59,466 --> 00:35:01,186
It's a sampling-based profiler.


831
00:35:01,946 --> 00:35:05,956
But in OS X Yosemite, we added a
new option, the timeline option


832
00:35:06,636 --> 00:35:11,436
that can show your stacks
chronologically instead


833
00:35:11,436 --> 00:35:12,856
of by heaviest first.


834
00:35:14,026 --> 00:35:15,646
So, in this case,
we've run spindump


835
00:35:15,646 --> 00:35:16,476
against our application.


836
00:35:17,156 --> 00:35:19,706
And you can see that we
have a particular thread


837
00:35:19,706 --> 00:35:21,326
and it starts at
executing Utility.


838
00:35:21,956 --> 00:35:25,676
And then, if later that thread
happens to change to executing


839
00:35:25,676 --> 00:35:29,056
at Background, we'll see another
indication of our Quality


840
00:35:29,056 --> 00:35:29,986
of Service of that thread.


841
00:35:29,986 --> 00:35:31,706
In this way, you
can kind of walk


842
00:35:31,706 --> 00:35:33,576
through what code
you're executed during,


843
00:35:34,526 --> 00:35:36,806
what code your app executed
during the spindump,


844
00:35:37,356 --> 00:35:39,596
and see what Quality of
Services that code was using.


845
00:35:40,146 --> 00:35:43,846
So, that's Quality of Service.


846
00:35:44,186 --> 00:35:46,156
It lets you specify
the responsiveness


847
00:35:46,156 --> 00:35:47,456
and energy requirements of work.


848
00:35:47,886 --> 00:35:49,466
We expose it as both
a foundation


849
00:35:49,466 --> 00:35:51,896
and C-level APIs
including dispatch.


850
00:35:52,586 --> 00:35:56,146
It lets you, your goal just
kind of immediately walking


851
00:35:56,146 --> 00:35:58,656
out of the session, should be
to try to classify long running


852
00:35:58,656 --> 00:36:01,186
or resource intensive
parts of your application.


853
00:36:01,746 --> 00:36:04,176
And this can get you the biggest
bang for the buck both in terms


854
00:36:04,176 --> 00:36:07,016
of responsiveness benefits
and energy improvement.


855
00:36:08,056 --> 00:36:09,876
And you want to try
to aim for 90 percent


856
00:36:09,876 --> 00:36:13,116
of your application's execution
to be at Utility or below


857
00:36:13,116 --> 00:36:15,656
when the user isn't
actively interacting


858
00:36:15,656 --> 00:36:16,396
with your application.


859
00:36:17,056 --> 00:36:19,936
This is kind of a
high-level overview.


860
00:36:20,056 --> 00:36:22,466
There's a lot more details
including discussion


861
00:36:22,466 --> 00:36:24,936
of the dispatch-based APIs
that you can use for this


862
00:36:25,136 --> 00:36:26,186
at the Power Performance


863
00:36:26,186 --> 00:36:28,936
and Diagnostic session
tomorrow afternoon.


864
00:36:29,306 --> 00:36:31,446
I highly encourage
you to attend that.


865
00:36:33,716 --> 00:36:36,006
So, that was Do It
More Efficiently.


866
00:36:36,756 --> 00:36:38,426
So, let's talk about Do It Less.


867
00:36:39,376 --> 00:36:41,436
So, you're running your
code at the right time.


868
00:36:42,036 --> 00:36:42,816
You're not doing work.


869
00:36:42,816 --> 00:36:43,476
You don't need to.


870
00:36:43,476 --> 00:36:45,486
You're doing it with
Quality of Service specified.


871
00:36:46,336 --> 00:36:49,126
Now, how do you just simply
make your code do less work?


872
00:36:50,166 --> 00:36:51,726
So, we're going to talk
about three things.


873
00:36:52,226 --> 00:36:55,986
CPU, Graphics, and Storage,
and techniques you can use


874
00:36:55,986 --> 00:36:57,836
to improve your efficiency
in each of these areas.


875
00:36:58,966 --> 00:37:01,036
But before we talk
about a specific topic,


876
00:37:01,036 --> 00:37:03,446
how do you just generally
monitor your energy consumption?


877
00:37:04,306 --> 00:37:08,456
Well, if you are debugging your
application in Xcode and you go


878
00:37:08,456 --> 00:37:12,336
to Debug Navigator, there's
the energy impact gauge.


879
00:37:12,996 --> 00:37:16,226
This is an indication of how
much energy your app is using,


880
00:37:16,226 --> 00:37:17,906
taking into account
a variety of factors.


881
00:37:18,216 --> 00:37:20,126
And you can see in this case,


882
00:37:20,126 --> 00:37:24,756
our application has high energy
impact that is unexpected or bad


883
00:37:24,846 --> 00:37:26,766
if we don't think we're
doing something that's


884
00:37:26,766 --> 00:37:27,506
energy intensive.


885
00:37:27,506 --> 00:37:30,576
And so, you want to keep an
eye on the energy impact gauge,


886
00:37:30,896 --> 00:37:33,626
and what your application is
scoring on as you're developing,


887
00:37:33,966 --> 00:37:36,076
to look for things that
are unexpectedly expensive.


888
00:37:36,596 --> 00:37:39,616
So, with that, let's
dive into CPU.


889
00:37:39,986 --> 00:37:42,336
So, why is it important
to reduce CPU use?


890
00:37:43,226 --> 00:37:46,006
Well, if I have 1
percent CPU use,


891
00:37:46,266 --> 00:37:49,416
I'm going to cause 10 percent
higher power draw from the CPU.


892
00:37:49,996 --> 00:37:54,726
If I have 10 percent CPU use, I
will cause two times the amount


893
00:37:54,726 --> 00:37:56,476
of power draw compared
to an idle CPU.


894
00:37:57,076 --> 00:38:00,786
And finally, if I have
100 percent CPU use,


895
00:38:00,786 --> 00:38:03,036
I will cause 10 times
the power draw.


896
00:38:03,626 --> 00:38:07,346
And so, in this way, your use of
the CPU can have a huge impact


897
00:38:07,346 --> 00:38:10,996
on the amount of power
consumed by your application.


898
00:38:11,356 --> 00:38:15,706
Now, if we go back to
our Debug Navigator,


899
00:38:15,986 --> 00:38:17,676
we can look at the CPU gauge


900
00:38:18,166 --> 00:38:20,966
to see how much CPU our
app is using over time.


901
00:38:21,316 --> 00:38:22,836
This is another thing you
want to try to monitor


902
00:38:22,836 --> 00:38:25,346
as you're developing your
app, to look for places


903
00:38:25,346 --> 00:38:27,226
where you're using
unexpected amounts of CPU.


904
00:38:28,356 --> 00:38:30,696
If you do find you're using
more CPU than you expect,


905
00:38:31,216 --> 00:38:33,486
your best friend is going to
be Instruments Time Profiler.


906
00:38:33,906 --> 00:38:36,946
There's a variety of
talks and guides online


907
00:38:36,946 --> 00:38:38,186
on how to use Time Profiler.


908
00:38:38,726 --> 00:38:40,106
But the short of it is
that it lets you see


909
00:38:40,106 --> 00:38:42,346
where your application is
spending its time to look


910
00:38:42,346 --> 00:38:44,196
for CPU-intensive
routines that you can try


911
00:38:44,196 --> 00:38:45,436
to optimize or eliminate.


912
00:38:47,356 --> 00:38:50,666
One feature that's new in Xcode
6 is Performance Unit Tests.


913
00:38:51,376 --> 00:38:53,486
This is an addition
to the XCTestCase API,


914
00:38:53,486 --> 00:38:56,286
and it helps you find
performance regressions


915
00:38:56,286 --> 00:38:58,016
in your code by measuring
the performance


916
00:38:58,016 --> 00:38:59,806
of particular parts
of your application.


917
00:39:00,066 --> 00:39:03,596
I mentioned before performance
and energy go hand in hand.


918
00:39:03,936 --> 00:39:06,096
And so, making sure you're
doing good performance testing


919
00:39:06,096 --> 00:39:09,396
of your code can help you
find energy regressions early.


920
00:39:10,546 --> 00:39:12,506
API is pretty simple.


921
00:39:12,616 --> 00:39:14,066
You simply call measureBlock


922
00:39:14,066 --> 00:39:15,646
and tell it what code
you want to measure.


923
00:39:16,166 --> 00:39:19,276
And then you'll get a
variety of performance metrics


924
00:39:19,636 --> 00:39:24,476
from that code, including, for
our purposes here, wall time.


925
00:39:24,476 --> 00:39:27,956
If you want to learn more
about this, you should check


926
00:39:27,956 --> 00:39:30,996
out Testing in Xcode 6
and Continuous Integration


927
00:39:30,996 --> 00:39:33,956
with Xcode 6 tomorrow, and
I'll have all these at the end


928
00:39:33,956 --> 00:39:34,956
of the presentation as well.


929
00:39:35,566 --> 00:39:38,986
So, that's reducing CPU use.


930
00:39:39,506 --> 00:39:42,426
And remember that CPU has a
huge dynamic range in power.


931
00:39:43,496 --> 00:39:45,566
Monitor CPU with the
Xcode debug gauge


932
00:39:45,566 --> 00:39:46,936
as you're developing
your application.


933
00:39:48,316 --> 00:39:50,396
Profile your code with
Instruments to find


934
00:39:50,396 --> 00:39:53,346
and eliminate CPU
hogging routines.


935
00:39:54,846 --> 00:39:57,756
And use performance unit
tests to prevent regressions.


936
00:40:00,066 --> 00:40:02,636
Now, reducing the amount
of CPU use is important,


937
00:40:02,636 --> 00:40:04,786
but it's also important
to consider how you use it


938
00:40:04,786 --> 00:40:07,206
in the context of fixed costs
that we discussed earlier.


939
00:40:07,496 --> 00:40:10,906
So, you want to make sure
you minimize timer use


940
00:40:10,906 --> 00:40:11,656
in your application.


941
00:40:12,126 --> 00:40:14,976
There are lots of
timer APIs in a system.


942
00:40:14,976 --> 00:40:18,496
Everything from NSTimer,
Grand Central Dispatch timers,


943
00:40:18,676 --> 00:40:23,386
CVDisplayLink, all these
APIs will cause timer wakeups


944
00:40:23,386 --> 00:40:24,536
to happen in your application.


945
00:40:24,536 --> 00:40:27,626
And so it's important to
understand how you're using them


946
00:40:27,886 --> 00:40:29,936
and make sure to minimize
your use of these sorts


947
00:40:29,936 --> 00:40:31,376
of APIs as much as possible.


948
00:40:31,726 --> 00:40:35,236
And if we go back to one of our
power graphs, if we imagine each


949
00:40:35,236 --> 00:40:37,776
of these small units of work
is actually a timer firing


950
00:40:37,776 --> 00:40:42,386
in your application, we now
pay all of this fixed cost just


951
00:40:42,576 --> 00:40:44,456
to service these
very small timers.


952
00:40:44,986 --> 00:40:48,116
Who knows whether these are
actually important or not?


953
00:40:48,556 --> 00:40:53,836
So, what you can do is use the
Energy Impact Gauge in Xcode


954
00:40:53,966 --> 00:40:56,376
and look at the wakes
in CPU area


955
00:40:56,376 --> 00:40:58,656
to see how often your
application is waking due


956
00:40:58,656 --> 00:40:59,546
to a timer firing.


957
00:41:00,606 --> 00:41:02,236
If you find this is
higher than expected,


958
00:41:03,466 --> 00:41:05,446
you can use the timerfires
command line tool.


959
00:41:05,516 --> 00:41:07,826
And in this case, we'll
want it with a dash-g option


960
00:41:08,036 --> 00:41:09,756
that gives us a summary
of the timers


961
00:41:09,756 --> 00:41:10,866
that fired in our application.


962
00:41:11,096 --> 00:41:13,516
So, you start this tool,
run your application


963
00:41:13,596 --> 00:41:16,246
for a little while, kill
the tool with Control-C,


964
00:41:17,586 --> 00:41:19,656
and then you'll get
a list of the timers


965
00:41:19,656 --> 00:41:21,786
that fired while the tool was
running in your application.


966
00:41:21,976 --> 00:41:25,676
In this case, we can see we
had a lot of calls to sleep,


967
00:41:26,066 --> 00:41:29,046
some dispatch timers and
what routine they called,


968
00:41:29,046 --> 00:41:30,736
and some CF timers, what
routine they called.


969
00:41:32,396 --> 00:41:34,206
Now, reducing timers is great.


970
00:41:34,326 --> 00:41:36,836
Sometimes, you can't
eliminate a timer completely.


971
00:41:37,286 --> 00:41:39,816
In that case, you want to
help the system do a good job


972
00:41:39,816 --> 00:41:42,016
of scheduling that timer
in energy efficient time.


973
00:41:42,676 --> 00:41:44,906
This includes just something
we call Timer Coalescing.


974
00:41:45,106 --> 00:41:48,276
This is a feature we introduced
in last year's releases.


975
00:41:49,156 --> 00:41:51,516
And what this does
is take timers


976
00:41:51,516 --> 00:41:54,196
that are firing the
system and coalesce them


977
00:41:54,196 --> 00:41:55,536
to fire at the same time.


978
00:41:55,686 --> 00:41:57,276
In this way, we can
keep the system


979
00:41:57,276 --> 00:41:58,536
in an idle state for longer.


980
00:41:59,456 --> 00:42:02,226
And we will try to do this
as best we can but we have


981
00:42:02,226 --> 00:42:03,816
to subject it to
some limitations


982
00:42:03,816 --> 00:42:07,716
to make sure we don't delay a
timer more than is appropriate.


983
00:42:08,536 --> 00:42:10,216
But you can help us
determine the amount


984
00:42:10,216 --> 00:42:12,586
of tolerance you're willing that
time, for that timer to have


985
00:42:13,126 --> 00:42:16,146
by specifying a timer tolerance
whenever you create a timer.


986
00:42:16,826 --> 00:42:18,926
So, this first example
is for NSTimer.


987
00:42:19,046 --> 00:42:20,726
You can simply call setTolerance


988
00:42:20,986 --> 00:42:22,716
and indicate how much
tolerance you're willing


989
00:42:22,716 --> 00:42:23,626
for that timer to have.


990
00:42:23,886 --> 00:42:25,826
In this case, we
specified 60 seconds.


991
00:42:26,416 --> 00:42:28,716
For a CFRunLoopTimer,
you can call


992
00:42:28,716 --> 00:42:30,436
a CFRunLoopTimerSetTolerance.


993
00:42:30,866 --> 00:42:32,856
And then for a dispatch
source timer,


994
00:42:33,156 --> 00:42:34,796
when you call dispatch
source set timer,


995
00:42:34,796 --> 00:42:36,776
that last parameter
is a tolerance value.


996
00:42:37,276 --> 00:42:38,776
And so, in all these
cases, what we're indicating


997
00:42:38,776 --> 00:42:41,106
in the system is that we're
willing for this timer to take


998
00:42:41,476 --> 00:42:43,376
up to an extra 60
seconds to fire


999
00:42:43,776 --> 00:42:45,616
if that will improve
our energy consumption.


1000
00:42:47,356 --> 00:42:49,276
So, let's minimize timers.


1001
00:42:49,746 --> 00:42:51,856
Be mindful of the
wakeup overhead timers.


1002
00:42:52,036 --> 00:42:55,066
Monitor your app for wakeups
using the Xcode Debug Gauge.


1003
00:42:56,446 --> 00:42:58,876
Debug with timerfires
if you find more wakeups


1004
00:42:58,876 --> 00:43:01,866
than you expect, and make sure
you specify a timer tolerance


1005
00:43:02,446 --> 00:43:03,456
whenever you create a timer.


1006
00:43:04,066 --> 00:43:07,496
Now, this is a very brief
introduction to timers.


1007
00:43:07,546 --> 00:43:10,656
If you want a lot more details
and some examples of good


1008
00:43:10,656 --> 00:43:12,186
and bad timer-related code,


1009
00:43:12,426 --> 00:43:14,676
check out last year's
Energy Best Practices talk.


1010
00:43:14,676 --> 00:43:19,926
So, next I want to talk
about efficient Graphics.


1011
00:43:20,466 --> 00:43:22,336
Why is Graphics an
important area?


1012
00:43:22,966 --> 00:43:24,686
Well, let's say you
have an application


1013
00:43:24,946 --> 00:43:26,506
and your app does some drawing.


1014
00:43:26,826 --> 00:43:30,096
Well, that drawing now needs
to get handed to the system


1015
00:43:30,096 --> 00:43:31,906
so that it can compute how


1016
00:43:31,906 --> 00:43:35,356
that drawing affects the overall
user interface, do some work


1017
00:43:35,356 --> 00:43:36,936
in core animation
or core graphics.


1018
00:43:37,446 --> 00:43:39,446
Eventually, we'll hand
that work off to the GPU.


1019
00:43:39,446 --> 00:43:43,206
That GPU now needs to wake up
out of its low power states


1020
00:43:43,206 --> 00:43:44,196
and do some processing.


1021
00:43:44,826 --> 00:43:46,536
And then, we eventually
have to hand that off


1022
00:43:46,536 --> 00:43:48,686
to the display itself,
which might also be


1023
00:43:48,686 --> 00:43:50,186
in a low-power state
and it has to wake up


1024
00:43:50,186 --> 00:43:51,546
and do work to update the UI.


1025
00:43:51,546 --> 00:43:53,756
And so, it's very important


1026
00:43:53,756 --> 00:43:55,916
that we limit our screen
updates as much as possible.


1027
00:43:56,676 --> 00:43:58,976
This includes avoiding updating
the screen when we don't need


1028
00:43:58,976 --> 00:44:02,776
to because unnecessary drawing
can kick the graphics hardware


1029
00:44:02,776 --> 00:44:03,896
out of low-power modes.


1030
00:44:04,556 --> 00:44:07,036
It also means avoiding drawing
more content than needed.


1031
00:44:07,356 --> 00:44:09,876
So, if you get a, if
you have a custom view


1032
00:44:10,006 --> 00:44:13,006
and you get a DrawRect
call for a very small area,


1033
00:44:13,286 --> 00:44:15,726
make sure you don't draw more
than the area you're required.


1034
00:44:16,146 --> 00:44:19,606
And you can use needsToDrawRect
or getRectsBeingDrawn:count


1035
00:44:19,906 --> 00:44:22,256
to fine tune what areas
you update in your view.


1036
00:44:22,256 --> 00:44:25,686
And there's a great view drawing
guide available and we'll go


1037
00:44:25,686 --> 00:44:27,396
into that in more
detail if you're curious.


1038
00:44:28,256 --> 00:44:30,856
So, how do you determine whether
you're doing the right thing


1039
00:44:30,856 --> 00:44:31,746
with respect to drawing?


1040
00:44:32,686 --> 00:44:34,556
Well, you can use
Flash Screen Updates.


1041
00:44:34,556 --> 00:44:36,776
So, this is the Quartz
Debug utility that comes


1042
00:44:36,776 --> 00:44:38,176
with Graphics tools for Xcode.


1043
00:44:38,556 --> 00:44:41,996
If you run this and check the
Flash Screen Updates box-I'm not


1044
00:44:41,996 --> 00:44:42,896
going to demo this for you


1045
00:44:42,896 --> 00:44:44,496
because it can be a little
bit seizure inducing.


1046
00:44:45,026 --> 00:44:48,336
But, if you were to look at the
Shut Down dialog, you would,


1047
00:44:48,336 --> 00:44:51,416
on OS X Mavericks, you'd see
the Shut Down button flashing


1048
00:44:51,416 --> 00:44:52,526
at 30 frames per second.


1049
00:44:53,066 --> 00:44:55,206
And this is correct
behavior in this case,


1050
00:44:55,206 --> 00:44:56,346
because that button pulses.


1051
00:44:56,586 --> 00:44:59,086
And so, as long as you see
a flash only when we expect


1052
00:44:59,086 --> 00:45:02,016
that button to be updated
and that the region flashed,


1053
00:45:02,016 --> 00:45:03,316
which is indicated in yellow,


1054
00:45:03,776 --> 00:45:05,986
is only the area
immediately surrounding


1055
00:45:05,986 --> 00:45:09,076
that UI element that's changing,
then we're behaving correctly.


1056
00:45:09,256 --> 00:45:12,116
On the other hand, if you'd
seen the entire window flash,


1057
00:45:12,466 --> 00:45:13,766
that would have been
a cause for concern.


1058
00:45:14,616 --> 00:45:17,796
Now, if you were to compare
this to OS X Yosemite,


1059
00:45:18,306 --> 00:45:20,406
you'd see that the Shut Down
button doesn't pulse anymore,


1060
00:45:20,626 --> 00:45:21,986
so you wouldn't get
any flashing.


1061
00:45:22,446 --> 00:45:25,066
And we've improved
the energy consumption


1062
00:45:25,066 --> 00:45:26,146
of the Shut Down dialogue.


1063
00:45:27,126 --> 00:45:31,276
Now, for iOS, we, if you go to
the Core Animation instrument,


1064
00:45:31,456 --> 00:45:35,116
there's a debug option
for Flash Updated Regions


1065
00:45:35,116 --> 00:45:35,746
that you can check.


1066
00:45:35,746 --> 00:45:38,216
And this will produce
similar behavior


1067
00:45:38,216 --> 00:45:39,606
on your tethered iOS device.


1068
00:45:40,096 --> 00:45:43,396
And also, one other
thing you want to keep


1069
00:45:43,446 --> 00:45:44,896
in mind is visual effects.


1070
00:45:45,256 --> 00:45:49,776
So, with the new UI in OS
X Yosemite or the iOS 7 UI,


1071
00:45:50,686 --> 00:45:52,946
you might want to
place a translucency


1072
00:45:52,946 --> 00:45:54,446
or blur effect on some element.


1073
00:45:54,966 --> 00:45:56,906
But you want to make sure
you avoid placing these


1074
00:45:56,906 --> 00:45:58,406
over frequently updating
elements.


1075
00:45:58,406 --> 00:46:01,556
Because if something
underneath that effect changes,


1076
00:46:01,806 --> 00:46:03,956
you have to update
the, and redo the work


1077
00:46:03,956 --> 00:46:05,356
to do the blur and translucency.


1078
00:46:05,686 --> 00:46:07,076
So, you can imagine, if we were


1079
00:46:07,076 --> 00:46:09,196
to put Animating
Content underneath the


1080
00:46:09,196 --> 00:46:12,626
NSVisualEffectView, we
would magnify the power cost


1081
00:46:12,626 --> 00:46:14,166
of updating that
Animating Content.


1082
00:46:14,256 --> 00:46:16,256
On the other hand, if
you move that content


1083
00:46:16,256 --> 00:46:17,626
out from underneath
the EffectView,


1084
00:46:18,476 --> 00:46:22,666
then you won't see dramatically
increased cost due to that.


1085
00:46:23,456 --> 00:46:24,986
So, that's Efficient Graphics.


1086
00:46:25,686 --> 00:46:27,236
Make sure to draw
minimally and efficiently.


1087
00:46:28,136 --> 00:46:30,846
Monitor your drawing with
Quartz Debug or Instruments


1088
00:46:31,266 --> 00:46:33,186
and avoid blurs on
updating content.


1089
00:46:33,686 --> 00:46:36,926
And finally, Flash Power.


1090
00:46:37,636 --> 00:46:41,056
So, Flash is a little
bit of a different beast


1091
00:46:41,056 --> 00:46:43,566
than the rotating hard drives
you might have been familiar


1092
00:46:43,566 --> 00:46:44,556
with in older Macs.


1093
00:46:45,026 --> 00:46:48,116
In particular, writes to Flash
are significantly more energy


1094
00:46:48,116 --> 00:46:49,076
hungry than reads.


1095
00:46:49,196 --> 00:46:51,676
So, you want to make sure
you write the minimum amount


1096
00:46:51,676 --> 00:46:55,286
of content necessary and
do writing in aggregate


1097
00:46:55,586 --> 00:46:57,796
to help amortize some
of those fixed costs.


1098
00:46:58,886 --> 00:47:02,086
Also, remember that any I/O you
do can pull the storage device


1099
00:47:02,216 --> 00:47:03,396
out of a lower-power state.


1100
00:47:04,156 --> 00:47:05,276
And so, you want
to take advantage


1101
00:47:05,276 --> 00:47:06,926
of the I/O caching
available to you


1102
00:47:07,716 --> 00:47:10,266
to ensure you're not doing
lots of sporadic I/Os


1103
00:47:10,266 --> 00:47:11,726
to keep the device from idling.


1104
00:47:12,306 --> 00:47:15,816
So, that was Do It Less.


1105
00:47:16,456 --> 00:47:17,796
Things you want to
remember, profile


1106
00:47:17,796 --> 00:47:19,346
and monitor your CPU use.


1107
00:47:19,836 --> 00:47:20,806
Reduce your timers.


1108
00:47:21,286 --> 00:47:24,526
Be efficient in the use of
graphics and minimize your I/O.


1109
00:47:24,626 --> 00:47:25,206
All right.


1110
00:47:26,596 --> 00:47:29,046
So, to summarize what
we talked about today,


1111
00:47:30,116 --> 00:47:32,106
improving your app's energy
consumption improves the


1112
00:47:32,106 --> 00:47:33,016
user experience.


1113
00:47:33,536 --> 00:47:36,106
Keep in mind how you're
using the device and how,


1114
00:47:36,106 --> 00:47:37,726
what kind of impact that
will have on energy.


1115
00:47:39,826 --> 00:47:42,206
Make sure you continuously
monitor your app's energy


1116
00:47:42,206 --> 00:47:43,516
and resource consumption
as you're developing.


1117
00:47:44,316 --> 00:47:47,386
And look for ways to apply the
four techniques we talked about.


1118
00:47:47,616 --> 00:47:50,556
Do It Never, respond to
changes in your app's active


1119
00:47:50,786 --> 00:47:53,326
or occlusion state to minimize
the amount of work you do


1120
00:47:53,326 --> 00:47:55,776
when that work won't
be visible to the user.


1121
00:47:55,776 --> 00:47:59,936
Do It at a Better Time, let the
system schedule work using the


1122
00:47:59,936 --> 00:48:04,166
NSBackgroundActivityScheduler or
NSURLSessionBackground Session.


1123
00:48:04,776 --> 00:48:08,526
Do It More Efficiently, specify
Quality of Service Classes


1124
00:48:08,526 --> 00:48:11,386
on your work-and this can
provide huge benefits both


1125
00:48:11,386 --> 00:48:15,536
in energy and responsiveness-and
Do It Less.


1126
00:48:15,846 --> 00:48:17,576
Optimize and improve
your resource use.


1127
00:48:18,316 --> 00:48:20,626
For more information, you
can contact Paul Danbold,


1128
00:48:20,776 --> 00:48:22,316
the Core OS Evangelist.


1129
00:48:22,376 --> 00:48:24,466
You can also check out
these talks from last year,


1130
00:48:24,466 --> 00:48:27,076
Energy Best Practices and
Building Resource Efficient Apps


1131
00:48:27,436 --> 00:48:29,296
for more depth in some of
the things we covered today.


1132
00:48:30,426 --> 00:48:32,586
There's a variety of related
sessions I'd highly encourage


1133
00:48:32,586 --> 00:48:33,946
you to check out.


1134
00:48:33,946 --> 00:48:36,286
Yesterday's What's New in
Foundation Networking talk went


1135
00:48:36,286 --> 00:48:38,036
in more depth about
the Background Session.


1136
00:48:39,196 --> 00:48:42,056
Improving Your App with
Instruments is a great session


1137
00:48:42,056 --> 00:48:43,326
to learn more about
Instruments and some


1138
00:48:43,326 --> 00:48:44,586
of the new features available.


1139
00:48:45,376 --> 00:48:48,116
Writing Energy Efficient Code,
Part 2, right here on this stage


1140
00:48:48,116 --> 00:48:50,056
in just a few minutes.


1141
00:48:51,006 --> 00:48:54,666
Testing in Xcode 6 and
the Continuous Integration


1142
00:48:54,666 --> 00:48:56,246
with Xcode 6 will
go into more depth


1143
00:48:56,346 --> 00:48:58,226
about the performance
unit tests.


1144
00:48:58,656 --> 00:49:01,596
Fix Bugs Faster Using Activity
Tracking is a great way


1145
00:49:01,596 --> 00:49:03,616
to help understand the
asynchronous work your


1146
00:49:03,616 --> 00:49:04,486
application is doing.


1147
00:49:05,036 --> 00:49:07,306
And, of course, Power,
Performance, and Diagnostics,


1148
00:49:07,626 --> 00:49:10,276
tomorrow afternoon, will go into
much more depth about Quality


1149
00:49:10,276 --> 00:49:12,416
of Service Classes and
how to specify them


1150
00:49:12,416 --> 00:49:13,926
in a variety of layers
in the API.


1151
00:49:15,416 --> 00:49:15,966
Thank you.


1152
00:49:16,516 --> 00:49:23,880
[ Applause ]

