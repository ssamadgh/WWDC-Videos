1
00:00:06,516 --> 00:00:18,500
[ Music ]


2
00:00:22,516 --> 00:00:28,496
[ Applause ]


3
00:00:28,996 --> 00:00:30,296
>> Good afternoon,
ladies and gentlemen.


4
00:00:30,826 --> 00:00:32,326
It's great to see
so many people here.


5
00:00:33,216 --> 00:00:35,946
How many of you are here
for the first time at WWDC?


6
00:00:37,636 --> 00:00:39,056
Wow! That's incredible.


7
00:00:39,096 --> 00:00:40,156
Well, welcome.


8
00:00:40,156 --> 00:00:42,826
I hope WWDC is going
well for you.


9
00:00:42,826 --> 00:00:46,606
Now we're going to talk
about some networking topics.


10
00:00:47,686 --> 00:00:49,326
I've got five things
to cover today.


11
00:00:49,896 --> 00:00:51,426
We're going to give
you an update


12
00:00:51,966 --> 00:00:54,646
on Explicit Congestion
Notification


13
00:00:54,646 --> 00:00:55,776
that we talked about last year.


14
00:00:56,626 --> 00:00:59,386
We're going to give you an
update in the progress on IPv6.


15
00:00:59,426 --> 00:01:04,166
We're going to talk a little
bit about international text,


16
00:01:04,416 --> 00:01:06,106
which is becoming
increasingly important.


17
00:01:07,606 --> 00:01:11,476
We're going to explore
how you control access


18
00:01:11,476 --> 00:01:13,916
to network interfaces
to avoid running


19
00:01:13,916 --> 00:01:15,656
up big data bills
for your customers.


20
00:01:16,416 --> 00:01:19,276
And we're going to finish
off with some discussion


21
00:01:19,276 --> 00:01:20,766
of network quality of service.


22
00:01:21,606 --> 00:01:24,796
You may have heard
about the Apple Cisco


23
00:01:25,016 --> 00:01:26,176
Fastlane announcement.


24
00:01:26,686 --> 00:01:28,646
We're going to talk a
little bit about how


25
00:01:28,646 --> 00:01:30,226
that might apply to
your applications.


26
00:01:33,086 --> 00:01:34,266
So let's start with ECN.


27
00:01:36,486 --> 00:01:38,046
To recap from last year,


28
00:01:39,316 --> 00:01:41,456
we showed how Smart
Queue Management


29
00:01:42,066 --> 00:01:46,956
and marking packets instead of
dropping them can lower latency,


30
00:01:48,056 --> 00:01:50,356
reduce delays due
to retransmission,


31
00:01:50,996 --> 00:01:55,206
and improve the user
experience for all applications,


32
00:01:55,286 --> 00:01:57,176
and especially for things
like streaming video.


33
00:02:00,326 --> 00:02:06,656
In iOS 9, we did not enable
ECN for TCP connections,


34
00:02:06,826 --> 00:02:08,316
but in an unrelated change,


35
00:02:08,366 --> 00:02:11,836
the VPN software would pay
attention to ECN markings.


36
00:02:11,836 --> 00:02:16,086
We found one ISP in Germany
that marked all packets


37
00:02:16,176 --> 00:02:19,826
"congestion experienced,"
which was bad for VPN.


38
00:02:20,426 --> 00:02:22,886
The good news is they
fixed their network


39
00:02:22,886 --> 00:02:23,916
within a couple of weeks.


40
00:02:24,186 --> 00:02:26,696
We had no reports of any
problems anywhere else


41
00:02:26,696 --> 00:02:30,936
in the world, and what that
tells us now is we rolled


42
00:02:30,936 --> 00:02:34,866
out iOS all around the world,
found one problem, fixed it;


43
00:02:35,586 --> 00:02:37,646
the Internet is now
safe for ECN.


44
00:02:39,746 --> 00:02:46,286
And because of that, in iOS
9.3 and OS X El Capitan,


45
00:02:47,116 --> 00:02:50,716
five percent of TCP connections
at random are using ECN,


46
00:02:50,716 --> 00:02:55,456
and we're using this to gather
performance data and check


47
00:02:55,456 --> 00:02:57,956
that the Internet
continues to be safe for ECN.


48
00:02:58,576 --> 00:03:01,576
In the Developer Seed
that you have already,


49
00:03:02,216 --> 00:03:06,106
100 percent of Wi-Fi connections
and 100 percent of connections


50
00:03:06,106 --> 00:03:08,886
on these three carriers
are now using ECN.


51
00:03:10,636 --> 00:03:16,356
So last year, I reported
that 56 percent


52
00:03:16,626 --> 00:03:20,776
of the Alexa top million
websites supported ECN,


53
00:03:21,246 --> 00:03:24,326
which is a pretty
impressive support number


54
00:03:24,326 --> 00:03:26,026
for a technology
no one was using.


55
00:03:27,456 --> 00:03:33,886
I talked to my good friends
at ETH Zurich, and Brian,


56
00:03:34,576 --> 00:03:37,076
Brian Trammell and
Mira Coolwind,


57
00:03:37,076 --> 00:03:39,786
and their colleagues reran
the experiment for us.


58
00:03:40,436 --> 00:03:43,066
This year the percentage
is up to 70 percent.


59
00:03:43,446 --> 00:03:46,996
And if you only look at IPv6
sites, it's up to 83 percent.


60
00:03:47,856 --> 00:03:55,766
So this is a call to
action to ISPs and carriers


61
00:03:56,116 --> 00:03:58,006
and their vendors who
sell equipment to them.


62
00:03:58,826 --> 00:04:00,406
The clients are now doing ECN.


63
00:04:00,826 --> 00:04:02,326
The services are supporting ECN.


64
00:04:02,796 --> 00:04:04,416
It's time for the
network in the middle


65
00:04:04,756 --> 00:04:07,296
to start marking packets
instead of dropping them.


66
00:04:07,796 --> 00:04:09,606
It gives you a better
user experience,


67
00:04:10,526 --> 00:04:13,276
it reduces delays due
to retransmission,


68
00:04:13,456 --> 00:04:15,356
and it makes more
efficient use of your network


69
00:04:15,486 --> 00:04:17,305
because you are avoiding
wasted bandwidth


70
00:04:17,305 --> 00:04:20,005
retransmitting packets.


71
00:04:21,005 --> 00:04:23,616
Our next topic is IPv6.


72
00:04:26,486 --> 00:04:30,806
World IPv6 launch was
four years ago last week,


73
00:04:31,656 --> 00:04:34,856
and it continues to grow.


74
00:04:36,146 --> 00:04:39,496
I looked at a variety of
statistics, and I'm going


75
00:04:39,496 --> 00:04:42,066
to show you just a
small sampling here.


76
00:04:42,656 --> 00:04:49,026
I looked at accesses to Apple's
home page but coming over IPv6.


77
00:04:49,686 --> 00:04:53,716
In Belgium, it's now
up to 39 percent.


78
00:04:54,696 --> 00:04:57,386
On T-Mobile USA, we're
up to 54 percent.


79
00:04:58,696 --> 00:05:01,846
On Verizon, we're
up to 74 percent.


80
00:05:02,346 --> 00:05:05,906
So it's pretty clear
now on these carriers


81
00:05:06,186 --> 00:05:08,686
that IPv6 traffic
is the majority.


82
00:05:10,586 --> 00:05:12,896
And the reason is clear.


83
00:05:13,586 --> 00:05:16,766
IPv6 is simpler,
it's more reliable,


84
00:05:16,766 --> 00:05:18,266
it's less expensive to operate.


85
00:05:18,356 --> 00:05:21,966
So it's very clear why the
carriers want to move to IPv6.


86
00:05:22,036 --> 00:05:26,556
But at what cost to
developers and customers?


87
00:05:27,096 --> 00:05:28,796
Is IPv6 less mature?


88
00:05:29,106 --> 00:05:30,136
Is it slower?


89
00:05:30,466 --> 00:05:33,596
Is there less capacity
allocated to IPv6?


90
00:05:33,936 --> 00:05:38,216
These are important
questions, and content providers


91
00:05:38,386 --> 00:05:41,296
and developers pay
close attention to this.


92
00:05:42,136 --> 00:05:45,796
They use statistics
gathering in the web browsers


93
00:05:45,906 --> 00:05:49,186
to measure things like page
load times for every single one


94
00:05:49,186 --> 00:05:52,496
of their users viewing the
web page and report that back,


95
00:05:52,666 --> 00:05:56,246
so they can tell how well
their product is working


96
00:05:56,356 --> 00:05:59,396
in different countries around
the world, different ISPs,


97
00:05:59,576 --> 00:06:00,846
different carrier networks.


98
00:06:02,856 --> 00:06:06,636
LinkedIn reports that now 10
percent of their traffic is


99
00:06:06,636 --> 00:06:11,196
over IPv6, and they find the
page load time on average is 10


100
00:06:11,356 --> 00:06:14,146
to 40 percent faster
than over IPv4.


101
00:06:15,396 --> 00:06:18,816
They theorize that that
is due to less overhead,


102
00:06:19,596 --> 00:06:22,856
setting up connections through
overloaded large scale NATs.


103
00:06:23,846 --> 00:06:25,976
Facebook found similar results.


104
00:06:26,036 --> 00:06:28,926
45 percent of their
traffic is now over IPv6,


105
00:06:29,816 --> 00:06:32,026
and they reported recently


106
00:06:32,266 --> 00:06:37,636
that on average ATP GET requests
are 15 percent faster over IPv6.


107
00:06:37,696 --> 00:06:42,756
If you only look at the iPhone
data in that collection,


108
00:06:43,026 --> 00:06:45,586
it turns out to be
30 percent over IPv6.


109
00:06:47,866 --> 00:06:53,766
So IPv6 is better for
network operators.


110
00:06:54,386 --> 00:06:56,366
It's better for users
and content providers.


111
00:06:56,806 --> 00:07:01,596
And that's why Apple is 100
percent backing the move


112
00:07:01,906 --> 00:07:02,656
to IPv6.


113
00:07:03,446 --> 00:07:07,196
And you will have all seen
this announcement last month.


114
00:07:08,056 --> 00:07:11,226
We announced last year we were
going to be requiring all apps


115
00:07:12,156 --> 00:07:14,766
to be compatible
with IPv6 networks,


116
00:07:15,106 --> 00:07:19,886
and we said we would be testing
all apps on our own IPv6 network


117
00:07:19,886 --> 00:07:21,146
with the NAT64 Gateway.


118
00:07:22,386 --> 00:07:25,326
Starting this month we started
enforcing that requirement,


119
00:07:25,806 --> 00:07:29,056
and we looked very
closely for any evidence


120
00:07:29,496 --> 00:07:32,046
that this was causing
an increase in the rate


121
00:07:32,046 --> 00:07:35,566
of application rejection,
because if that were the case,


122
00:07:35,896 --> 00:07:38,306
we would have to look into
it and work out what to do.


123
00:07:38,856 --> 00:07:41,896
But the good news is,
look as hard as we can,


124
00:07:42,596 --> 00:07:46,046
we don't find any change
in application rejection,


125
00:07:46,506 --> 00:07:51,626
so what that really tell us is
that 99 percent of you have apps


126
00:07:51,736 --> 00:07:53,866
that are working just
fine with IPv6 support,


127
00:07:54,226 --> 00:07:57,106
which is what we expected,
but it's still really good


128
00:07:57,106 --> 00:07:58,066
to have that confirmed.


129
00:07:59,396 --> 00:08:01,996
Now, if you've had
an app rejected


130
00:08:02,156 --> 00:08:06,906
and you think it might be to
do with IPv6, then come on down


131
00:08:06,906 --> 00:08:08,586
to the labs today or tomorrow.


132
00:08:09,226 --> 00:08:12,596
You can test your app here
at WWDC on the NAT64 network,


133
00:08:12,596 --> 00:08:17,406
and we can help you troubleshoot
what might be going wrong.


134
00:08:18,636 --> 00:08:22,246
Our advice continues to
be, as it always has been,


135
00:08:23,036 --> 00:08:27,996
use the high level APIs that
are address-family agnostic.


136
00:08:31,066 --> 00:08:34,405
If you have to use the
low level BSD APIs,


137
00:08:34,405 --> 00:08:38,756
then there is extra work that
you are going to have to do,


138
00:08:39,275 --> 00:08:42,046
which is why we really advise
using the high level APIs


139
00:08:42,046 --> 00:08:42,846
that do that for you.


140
00:08:44,035 --> 00:08:47,776
Another key piece of
advice is use hostnames,


141
00:08:48,476 --> 00:08:50,206
not literal IPv4 addresses.


142
00:08:50,756 --> 00:08:54,496
Because IPv4 addresses are
inherently tied to IPv4.


143
00:08:54,976 --> 00:08:57,306
And let me give you a
little picture showing why.


144
00:08:58,816 --> 00:09:01,336
This is a typical situation
from a few years ago.


145
00:09:01,336 --> 00:09:02,916
You have a client on IPv4.


146
00:09:02,976 --> 00:09:04,556
You have a server on IPv4.


147
00:09:04,626 --> 00:09:08,126
The packets make their little
detour via the NAT Gateway,


148
00:09:08,566 --> 00:09:12,846
and that's how you
connect to the server.


149
00:09:12,926 --> 00:09:16,466
Nowadays, many more carriers
are rolling out IPv6 networks


150
00:09:16,986 --> 00:09:20,596
with a NAT64 Gateway, and the
packets still make their little


151
00:09:20,596 --> 00:09:22,666
detour through the NAT
Gateway and connect


152
00:09:22,666 --> 00:09:25,906
to that old legacy IPv4
service on the Internet.


153
00:09:28,926 --> 00:09:34,486
Now, if your data center guys
bring up dual-stack services


154
00:09:35,046 --> 00:09:38,376
but you're still using
v4 literals in your apps,


155
00:09:39,026 --> 00:09:41,676
then the packets are going
to make that same detour


156
00:09:41,676 --> 00:09:44,596
through the NAT to get to the
v4 interface at the service.


157
00:09:45,486 --> 00:09:47,076
But if you look up by hostname


158
00:09:47,076 --> 00:09:50,916
and they put the IPv6
quota records into the DNS,


159
00:09:51,806 --> 00:09:57,006
that's how you get the straight
through data path without going


160
00:09:57,006 --> 00:09:57,896
through the NAT Gateway.


161
00:10:02,446 --> 00:10:03,996
I talked about literal
addresses.


162
00:10:05,396 --> 00:10:09,166
We now support using
IPv4 literal addresses


163
00:10:09,286 --> 00:10:10,496
in selected APIs.


164
00:10:11,616 --> 00:10:13,396
And if you use one
of those addresses,


165
00:10:13,846 --> 00:10:18,416
we will actually do the DNS64
synthesis for you locally


166
00:10:18,416 --> 00:10:22,896
on the device, create a
temporary IPv6 address


167
00:10:22,896 --> 00:10:25,336
corresponding with your v4
service on the Internet,


168
00:10:25,696 --> 00:10:27,806
and then connect through
the NAT64 Gateway.


169
00:10:29,026 --> 00:10:33,676
Now, remember, using literal v4
addresses will prevent your app


170
00:10:33,676 --> 00:10:35,576
from ever connecting
to an ATV6 server.


171
00:10:35,576 --> 00:10:39,296
But that said, if that's what
you need to do for your app,


172
00:10:40,536 --> 00:10:42,976
here is an example
of how you do it.


173
00:10:44,816 --> 00:10:47,966
If you're writing
code using Swift


174
00:10:48,526 --> 00:10:51,316
and the high layer
Cocoa APIs, this happens


175
00:10:51,316 --> 00:10:52,276
for you automatically.


176
00:10:52,756 --> 00:10:55,546
But if you're writing
UDP code today


177
00:10:55,546 --> 00:10:58,376
and you're using BSD
sockets, the API you need


178
00:10:58,376 --> 00:10:59,876
to use is getaddrinfo.


179
00:11:00,966 --> 00:11:03,346
You pass in the address
you want to connect


180
00:11:03,346 --> 00:11:04,866
to as a literal string.


181
00:11:06,156 --> 00:11:07,496
You pass in the port you want.


182
00:11:07,496 --> 00:11:10,886
Here https is a synonym
for port 443.


183
00:11:12,266 --> 00:11:14,466
You loop through all
the addresses you get.


184
00:11:14,746 --> 00:11:16,546
Remember, don't just
take the first one.


185
00:11:16,546 --> 00:11:18,996
You'll get back an array of
multiple addresses to try, and,


186
00:11:19,756 --> 00:11:21,436
of course, free the memory
when you're finished.


187
00:11:23,956 --> 00:11:27,436
Another question we
get from developers is


188
00:11:27,756 --> 00:11:29,606
about the Internet of things.


189
00:11:30,416 --> 00:11:33,076
There are developers
writing apps that interact


190
00:11:33,076 --> 00:11:34,566
with the device that
they don't make,


191
00:11:35,446 --> 00:11:39,696
and some of those devices
are not very modern.


192
00:11:40,636 --> 00:11:43,536
Now, we'd like those
devices to support IPv6.


193
00:11:44,706 --> 00:11:47,506
And if they don't support
IPv6, we recommend that they


194
00:11:47,506 --> 00:11:50,156
at least support IPv4
link-local addressing.


195
00:11:50,906 --> 00:11:52,876
So even on a v6 only network,


196
00:11:53,646 --> 00:11:56,716
devices can use v4 amongst
themselves to communicate


197
00:11:56,996 --> 00:11:58,046
with link-local addressing.


198
00:11:59,306 --> 00:12:00,956
Now, if the device
can't do either


199
00:12:00,956 --> 00:12:02,876
of those things, that's okay.


200
00:12:03,566 --> 00:12:06,176
Inform app review, when
you submit your app,


201
00:12:07,116 --> 00:12:09,706
that is not grounds for
rejection of your app.


202
00:12:10,086 --> 00:12:12,746
It probably is grounds
for putting one


203
00:12:12,746 --> 00:12:13,996
of these stickers on the device.


204
00:12:14,316 --> 00:12:20,096
[Laughter] And remember, all off
link communication still have


205
00:12:20,096 --> 00:12:23,536
to be compatible
with IPv6 and NAT64.


206
00:12:26,356 --> 00:12:32,256
So to summarize, we recommend
you support both IPv4 and IPv6


207
00:12:33,146 --> 00:12:35,466
at both ends, in the
clients and the servers.


208
00:12:36,386 --> 00:12:38,356
We recommend you use hostnames.


209
00:12:38,756 --> 00:12:41,206
That way you can get a v4
address on a v4 network


210
00:12:41,206 --> 00:12:43,986
and a v6 address
on a v6 network.


211
00:12:45,626 --> 00:12:47,546
If you do need to use
literal addresses,


212
00:12:48,056 --> 00:12:50,206
those are now supported
in select APIs,


213
00:12:50,616 --> 00:12:51,666
as long as you do it properly.


214
00:12:51,666 --> 00:12:55,496
But remember, imbedding
v4 literals will block


215
00:12:55,586 --> 00:12:57,856
communication to v6
servers in the future.


216
00:13:00,156 --> 00:13:03,436
So that brings us to our next
session, international text.


217
00:13:06,476 --> 00:13:08,516
You may have started to
see things like this,


218
00:13:09,126 --> 00:13:10,986
and if you're a native
English speaker,


219
00:13:11,486 --> 00:13:14,076
this can look pretty
daunting and scary.


220
00:13:15,276 --> 00:13:17,286
And what I want to talk


221
00:13:17,286 --> 00:13:20,136
about today is how
simple this really is.


222
00:13:20,916 --> 00:13:24,446
International support in
your application doesn't need


223
00:13:24,446 --> 00:13:25,366
to be a big task.


224
00:13:25,956 --> 00:13:28,766
In fact, it really is no
harder than supporting ASCII.


225
00:13:29,416 --> 00:13:33,196
So even though the title of this
session is International Text


226
00:13:33,196 --> 00:13:35,976
and Networking, really we
can scratch the networking.


227
00:13:37,146 --> 00:13:38,346
For now I just want to talk


228
00:13:38,346 --> 00:13:41,326
about how you support
international text in general.


229
00:13:43,616 --> 00:13:45,546
I'm going to start
with some background.


230
00:13:46,196 --> 00:13:49,846
Not because many of you will
need to encounter this day


231
00:13:49,846 --> 00:13:53,136
to day, but I want to
de-mystify some of this


232
00:13:53,406 --> 00:13:58,126
and make it less scary,
because it really isn't any more


233
00:13:58,126 --> 00:13:59,276
complicated than ASCII.


234
00:14:00,206 --> 00:14:02,076
So the first concept
we have is Unicode.


235
00:14:03,526 --> 00:14:07,686
Unicode is a big list of
numbers, and corresponding


236
00:14:07,686 --> 00:14:11,206
to each number a human
visible character,


237
00:14:11,966 --> 00:14:15,366
and it's like a big
phone directory.


238
00:14:15,366 --> 00:14:17,046
In fact, it is available
in book form.


239
00:14:17,236 --> 00:14:19,176
It's a big, thick book
with page after page


240
00:14:19,176 --> 00:14:20,126
of number and character.


241
00:14:21,226 --> 00:14:23,406
And that's an abstract concept.


242
00:14:23,626 --> 00:14:26,166
You have integers and you have
the characters they represent.


243
00:14:27,026 --> 00:14:31,046
Now, to use those integers in
our computers, we need some way


244
00:14:31,046 --> 00:14:34,146
of representing those
numbers, in memory,


245
00:14:34,356 --> 00:14:35,966
on disk, over the network.


246
00:14:37,016 --> 00:14:40,106
One way of representing
them is UTF-32,


247
00:14:40,866 --> 00:14:43,196
which is just a 32-bit number.


248
00:14:43,696 --> 00:14:45,246
And like any 32-bit number,


249
00:14:45,696 --> 00:14:47,486
you have to be concerned
whether it's big endian


250
00:14:47,486 --> 00:14:48,276
or little endian.


251
00:14:49,066 --> 00:14:52,196
And it takes up four times
as much space as ASCII.


252
00:14:54,226 --> 00:14:55,946
UTF-16 is more compact.


253
00:14:55,946 --> 00:14:57,876
It uses 16-bit numbers.


254
00:14:58,206 --> 00:15:01,386
It still has the same problem of
little endian versus big endian,


255
00:15:02,486 --> 00:15:04,286
and because it's only 16-bits,


256
00:15:04,286 --> 00:15:06,796
it can only represent
65,000 values.


257
00:15:07,366 --> 00:15:09,446
So you have to use
the surrogate pairs


258
00:15:09,626 --> 00:15:11,696
to represent the values
outside that range.


259
00:15:11,696 --> 00:15:12,856
So that's a bit cumbersome.


260
00:15:14,446 --> 00:15:18,606
UTF-8 is an 8-bit
byte-oriented encoding.


261
00:15:19,316 --> 00:15:21,726
Because of that, there
are no byte order issues,


262
00:15:22,396 --> 00:15:28,536
and this is really what makes
it the ideal encoding to use.


263
00:15:28,686 --> 00:15:31,296
So let's dive in a
bit deeper into UTF-8.


264
00:15:32,966 --> 00:15:38,386
It was invented late night in
New Jersey 1992, and it's one


265
00:15:38,416 --> 00:15:41,976
of those rare pieces of
computer science genius.


266
00:15:42,296 --> 00:15:44,156
And when I first
heard about that,


267
00:15:44,316 --> 00:15:46,556
I immediately saw,
this is the answer.


268
00:15:46,556 --> 00:15:48,426
This solves the problem
for international text.


269
00:15:49,156 --> 00:15:52,276
So I want to tell you guys a
little bit about how it works


270
00:15:52,276 --> 00:15:54,786
so you can understand
how simple it is.


271
00:15:57,386 --> 00:15:59,356
The Codepoints in Unicode from 0


272
00:15:59,356 --> 00:16:02,506
to 7F are exactly the
same as the ASCII values.


273
00:16:02,836 --> 00:16:06,106
And UTF represents them using
the exact same bytes in memory.


274
00:16:06,776 --> 00:16:09,316
So what that means is if
you've got a disk full


275
00:16:09,316 --> 00:16:13,786
of plain ASCII files, I can wave
my magic wand over it and say,


276
00:16:14,166 --> 00:16:15,676
I declare you to be UTF-8.


277
00:16:16,476 --> 00:16:18,426
Not a single byte
on disk changes.


278
00:16:19,186 --> 00:16:21,266
The meaning of the
files doesn't change.


279
00:16:21,946 --> 00:16:24,716
You have automatic backwards
compatibility with all


280
00:16:24,716 --> 00:16:28,036
that legacy of ASCII, so
that is a wonderful thing.


281
00:16:28,096 --> 00:16:31,716
UTF-16, UTF-32, other encodings
don't have that property.


282
00:16:32,096 --> 00:16:36,306
For the values that are
outside the ASCII range,


283
00:16:36,686 --> 00:16:39,506
they are represented as
multi-byte sequences.


284
00:16:39,696 --> 00:16:43,096
But all those multi-byte
sequences only use byte values


285
00:16:43,436 --> 00:16:45,726
above 128.


286
00:16:46,386 --> 00:16:50,146
So there was no overlap
between the ASCII characters


287
00:16:50,356 --> 00:16:51,936
and the multi-byte encodings


288
00:16:52,206 --> 00:16:54,756
of the higher value
Unicode Codepoints.


289
00:16:55,466 --> 00:16:57,926
That property is not
true of other encodings


290
00:16:58,176 --> 00:17:01,036
that re-use the high code
bytes to mean something else.


291
00:17:02,736 --> 00:17:06,116
UTF-8 has three flavors
of bytes.


292
00:17:06,646 --> 00:17:09,796
It has the plain ASCII bytes.


293
00:17:11,306 --> 00:17:14,576
If a byte starts with the
most significant bit being 0,


294
00:17:14,656 --> 00:17:16,306
that tells you it's plain ASCII.


295
00:17:18,036 --> 00:17:20,915
If the top two, three,
or four bits are 1s,


296
00:17:20,915 --> 00:17:23,646
that tells you it's a two,
three, or four byte sequence.


297
00:17:24,336 --> 00:17:25,965
And if the top bits are 1 0,


298
00:17:25,965 --> 00:17:27,705
that tells you it's
a continuation


299
00:17:27,826 --> 00:17:29,086
of a multi-byte sequence.


300
00:17:29,586 --> 00:17:31,016
So I'll show that in context.


301
00:17:32,146 --> 00:17:34,016
The ASCII characters
stand alone.


302
00:17:35,706 --> 00:17:41,166
The bytes with two leading
1s signify two byte sequence.


303
00:17:41,606 --> 00:17:43,556
Three leading 1s is a
three byte sequence.


304
00:17:44,156 --> 00:17:46,196
Four leading 1s is a
four byte sequence.


305
00:17:48,656 --> 00:17:51,256
And this gives it a wonderful
property that you can jump


306
00:17:51,256 --> 00:17:56,646
into the middle of a UTF-8 file
anywhere, and by just looking


307
00:17:56,646 --> 00:17:58,666
at any old byte, you can
tell what you've got.


308
00:17:59,226 --> 00:18:00,736
Does this stand alone as ASCII?


309
00:18:00,766 --> 00:18:02,726
Is this the start of
a multi-byte sequence?


310
00:18:03,126 --> 00:18:05,336
Did I land in the middle of a
multi-byte sequence and I have


311
00:18:05,336 --> 00:18:07,776
to skip forward or back to
find the character boundary?


312
00:18:08,426 --> 00:18:12,416
So it's very, very robust to
insertion and deletion errors.


313
00:18:12,966 --> 00:18:18,576
It's an encoding that is
efficient enough to be compact


314
00:18:18,646 --> 00:18:21,386
but has just enough
redundancy to be very reliable.


315
00:18:23,806 --> 00:18:28,256
Another useful property it
has is in an UTF encoding


316
00:18:28,256 --> 00:18:30,106
of a string, there
are no 0 bytes.


317
00:18:30,416 --> 00:18:33,106
And C treats 0 as the
string terminator,


318
00:18:33,106 --> 00:18:34,856
so that's a very
useful property.


319
00:18:34,856 --> 00:18:37,316
UTF-16 strings have
zeros all over the place.


320
00:18:38,916 --> 00:18:41,536
And another nice property is


321
00:18:41,536 --> 00:18:45,296
if you do a naive simple
byte-wise string sort


322
00:18:45,446 --> 00:18:48,476
on UTF strings, they
sort in the same order


323
00:18:48,596 --> 00:18:51,666
as if you sorted the
Unicode Codepoints directly.


324
00:18:52,356 --> 00:18:55,336
So a whole bunch of really
wonderful properties,


325
00:18:56,006 --> 00:18:59,576
and this is why just six years
after Ken Thompson invented it,


326
00:19:00,196 --> 00:19:03,956
the IETF issued a document
saying that from then on,


327
00:19:04,446 --> 00:19:07,216
all new Internet
standard protocols had


328
00:19:07,216 --> 00:19:08,776
to work with UTF-8.


329
00:19:10,146 --> 00:19:13,796
And that philosophy has
been embraced on the web.


330
00:19:15,346 --> 00:19:19,056
Four years ago, Google did a
survey and found that 80 percent


331
00:19:19,056 --> 00:19:22,736
of web pages were UTF-8, and
that includes a small percentage


332
00:19:22,786 --> 00:19:24,786
that were old fashioned,
plain ASCII,


333
00:19:24,786 --> 00:19:27,266
which is of course a
compatible subset of UTF-8.


334
00:19:30,216 --> 00:19:33,356
Last month that number
is now up to 87 percent.


335
00:19:33,636 --> 00:19:38,886
And because of that, the
W3C, just like the IETF,


336
00:19:39,326 --> 00:19:43,156
also recommends that we only
use UTF-8 for everything.


337
00:19:43,786 --> 00:19:44,576
And this is wonderful.


338
00:19:46,326 --> 00:19:47,786
There is, however, one catch.


339
00:19:48,556 --> 00:19:50,896
For some reason,
lost in history,


340
00:19:51,296 --> 00:19:53,936
the DNS community
decided not to do that,


341
00:19:53,936 --> 00:19:55,736
and they invented a
different encoding


342
00:19:56,076 --> 00:19:57,206
that they call Punycode.


343
00:19:58,726 --> 00:20:04,466
And Punycode re-uses
existing ASCII byte values


344
00:20:04,466 --> 00:20:05,566
to mean different things.


345
00:20:06,396 --> 00:20:09,416
So those are the byte
values that correspond


346
00:20:09,416 --> 00:20:10,926
to letters, digits, and hyphens.


347
00:20:12,286 --> 00:20:17,466
A result of this is that if
we have a block of bytes,


348
00:20:18,346 --> 00:20:22,786
I can interpret those bytes as
ASCII values and get something


349
00:20:22,786 --> 00:20:27,976
like that, or I can interpret
them as being Punycode encoding


350
00:20:28,636 --> 00:20:29,836
and get what they're
meant to be.


351
00:20:30,806 --> 00:20:33,306
And that dual interpretation


352
00:20:33,306 --> 00:20:36,186
of the same bytes can
be very problematic,


353
00:20:36,556 --> 00:20:40,926
because it becomes unclear what
you want to display to the user


354
00:20:40,926 --> 00:20:42,266
or what the user meant.


355
00:20:42,516 --> 00:20:44,326
If we contrast that with UTF-8,


356
00:20:44,906 --> 00:20:47,386
the first thing you notice is
the encoding is more compact.


357
00:20:47,386 --> 00:20:48,516
It takes fewer bytes,


358
00:20:48,906 --> 00:20:51,286
and there's also only
one valid interpretation.


359
00:20:51,886 --> 00:20:54,576
So there was no ambiguity there.


360
00:20:55,946 --> 00:20:59,046
The good news for you guys
is you don't need to care


361
00:20:59,046 --> 00:21:01,316
about this, because
we handle it for you.


362
00:21:03,036 --> 00:21:07,646
In iOS 9 and OS X El
Capitan, if you tried


363
00:21:07,646 --> 00:21:11,906
to ping a UTF-8 hostname on the
command line, it would fail.


364
00:21:12,716 --> 00:21:17,826
You type in UTF-8, those
characters pass through the tool


365
00:21:18,246 --> 00:21:23,336
to the APIs on to the network,
but that name was not put


366
00:21:23,336 --> 00:21:26,016
into the DNS as UTF-8
and it fails.


367
00:21:26,946 --> 00:21:32,336
Starting now in iOS 10 and macOS
Sierra, the same ping command


368
00:21:32,336 --> 00:21:36,376
on the command line with
the same UTF-8 input,


369
00:21:37,216 --> 00:21:41,496
we will now translate that
automatically to Punycode,


370
00:21:42,716 --> 00:21:45,316
do the query, and it
will be successful.


371
00:21:46,086 --> 00:21:50,376
Now, here the ping command
is taking that Punycode


372
00:21:50,826 --> 00:21:54,586
and displaying it as if it were
ASCII so you get this gibberish


373
00:21:54,586 --> 00:21:57,466
on the screen instead of the
actual name that you meant,


374
00:21:58,036 --> 00:21:59,076
and that's part of the problem


375
00:21:59,076 --> 00:22:01,276
of having dual interpretations
of the same string.


376
00:22:01,866 --> 00:22:04,576
But the good news
is all the Bonjour


377
00:22:04,576 --> 00:22:08,206
and DSA APIs will now accept
international text input


378
00:22:08,206 --> 00:22:10,676
in UTF-8 format, because --


379
00:22:11,516 --> 00:22:16,906
[ Applause ]


380
00:22:17,406 --> 00:22:17,706
Thank you.


381
00:22:18,976 --> 00:22:21,326
Because the Punycode
format is quite restrictive,


382
00:22:21,436 --> 00:22:25,046
it doesn't support even simple
things like spaces in names,


383
00:22:25,136 --> 00:22:28,906
and we use DNS for Bonjour
search discovery, we don't want


384
00:22:28,906 --> 00:22:29,756
to be that restrictive.


385
00:22:30,276 --> 00:22:33,976
So the way the algorithm works,
which is what's documented


386
00:22:33,976 --> 00:22:39,676
in RFC 6763, we will
first try UTF-8 as is,


387
00:22:40,156 --> 00:22:43,986
and if the DNS administrator
put UTF-8 into their zone file,


388
00:22:43,986 --> 00:22:46,266
which is very easy to do, and
people were doing that back


389
00:22:46,266 --> 00:22:48,966
in the '90s, we do the
query, we are successful,


390
00:22:48,966 --> 00:22:50,576
we get the result,
everything is fine.


391
00:22:51,056 --> 00:22:54,336
What's new now is that if we
fail, instead of giving up,


392
00:22:54,336 --> 00:22:57,766
we will do one more try with
Punycode and see if that works.


393
00:22:57,996 --> 00:23:01,856
So we support both
in the same API.


394
00:23:03,566 --> 00:23:05,406
Email addresses are
also becoming


395
00:23:05,846 --> 00:23:07,066
internationalized today.


396
00:23:07,736 --> 00:23:13,596
And this is also not hard to
do, but users face problems


397
00:23:13,596 --> 00:23:14,956
for a silly, trivial reason.


398
00:23:15,746 --> 00:23:18,716
Many apps, when you sign
up for an account or you go


399
00:23:18,716 --> 00:23:22,226
onto the website to sign up for
an account, they try to validate


400
00:23:22,226 --> 00:23:25,976
if the email address is valid
and they check whether it ends


401
00:23:25,976 --> 00:23:29,226
in .com or things of that form.


402
00:23:30,126 --> 00:23:34,126
And users with perfectly valid
email addresses are not allowed


403
00:23:34,126 --> 00:23:37,986
to sign up for accounts because
their email address is rejected.


404
00:23:38,426 --> 00:23:43,696
So we need to remove those
ill-advised validators.


405
00:23:43,806 --> 00:23:45,326
Really the only thing
you can check


406
00:23:45,326 --> 00:23:47,966
for in an email address is
it has to have an @ sign.


407
00:23:47,966 --> 00:23:51,336
And if it's got that, it could
be a valid email address.


408
00:23:51,386 --> 00:23:54,926
If you want to know if it's
valid, send a validation email


409
00:23:55,016 --> 00:23:58,016
and have the user respond
to confirm that it's live.


410
00:23:59,696 --> 00:24:03,206
If you're writing an email
client or an email server,


411
00:24:03,206 --> 00:24:06,466
there are a bunch of RFCs you
are going to need to look at.


412
00:24:06,936 --> 00:24:09,666
But for the rest of you, you
don't need to worry about that.


413
00:24:09,666 --> 00:24:13,416
Let the user enter their
email address as UTF-8,


414
00:24:14,036 --> 00:24:15,736
stick it in your
customer database,


415
00:24:16,186 --> 00:24:19,846
and have the mail server send
that out correctly encoding


416
00:24:19,846 --> 00:24:20,966
with the email standards.


417
00:24:24,356 --> 00:24:28,596
So to wrap up this section, we
recommend UTF-8 for everything.


418
00:24:29,326 --> 00:24:31,086
Makes everything
so much simpler.


419
00:24:31,636 --> 00:24:32,866
Don't worry about Punycode.


420
00:24:32,866 --> 00:24:33,796
We handle it for you.


421
00:24:34,566 --> 00:24:38,746
And be liberal about
accepting user input


422
00:24:39,086 --> 00:24:41,496
in this new international
multi-lingual world.


423
00:24:44,006 --> 00:24:46,826
That brings us to
interface selection.


424
00:24:48,376 --> 00:24:53,286
Now, Wi-Fi Assist is something
that we introduced last year.


425
00:24:55,556 --> 00:24:56,876
Really, this is not new.


426
00:24:57,396 --> 00:24:59,846
This is the way things
have worked


427
00:24:59,846 --> 00:25:01,406
since the very first iPhone.


428
00:25:02,556 --> 00:25:05,156
If I have Wi-Fi, I want
my phone to use it.


429
00:25:06,096 --> 00:25:09,866
If I don't have Wi-Fi, that's
why I pay for cellular data,


430
00:25:10,046 --> 00:25:12,656
so I have network access
outside the home as well.


431
00:25:13,656 --> 00:25:15,816
And the first iPhone did this.


432
00:25:16,396 --> 00:25:19,556
What we changed last
year is we did it better.


433
00:25:20,476 --> 00:25:23,106
We were smarter about
making that determination,


434
00:25:24,156 --> 00:25:26,416
because there's always
this gray area right


435
00:25:26,416 --> 00:25:27,846
on the edge of a Wi-Fi network.


436
00:25:29,046 --> 00:25:31,916
And mobility factors
into this as well.


437
00:25:31,916 --> 00:25:34,296
We have a situation that we
call the parking lot problem,


438
00:25:34,296 --> 00:25:37,756
and it happens at the end of
the day when you leave work.


439
00:25:38,146 --> 00:25:41,066
You leave the office, you get
your phone out, you have Wi-Fi,


440
00:25:41,186 --> 00:25:44,076
you're walking out to the car
and you want to check maps


441
00:25:44,076 --> 00:25:46,856
or weather forecasts or
look for movies or something


442
00:25:47,576 --> 00:25:49,526
and your phone thought
it had Wi-Fi.


443
00:25:49,526 --> 00:25:53,706
It had Wi-Fi a moment ago, but
you just walked out of range


444
00:25:54,316 --> 00:25:55,546
and it hasn't realized yet.


445
00:25:56,746 --> 00:25:58,726
With Wi-Fi Assist,
we will detect that.


446
00:25:59,466 --> 00:26:00,756
We'll try to use Wi-Fi.


447
00:26:00,796 --> 00:26:02,996
If it doesn't work, we'll
use cellular instead.


448
00:26:04,856 --> 00:26:09,186
But like any new feature,
there's sometimes a tendency


449
00:26:09,666 --> 00:26:12,486
for the new thing to be the
whipping boy that gets blamed


450
00:26:12,486 --> 00:26:13,446
for people's problems.


451
00:26:13,896 --> 00:26:17,626
Everybody hates it when
some app uses a ton of data


452
00:26:17,626 --> 00:26:19,416
and they get a big bill
they weren't expecting,


453
00:26:20,176 --> 00:26:23,046
and it's human nature to
blame the new feature.


454
00:26:23,406 --> 00:26:25,916
But if you actually look
at your Wi-Fi Assist data,


455
00:26:25,916 --> 00:26:27,956
you will probably find
they are very small.


456
00:26:28,616 --> 00:26:30,986
Wi-Fi Assist is normally
not the problem here.


457
00:26:31,556 --> 00:26:33,806
Now, apps have the switch.


458
00:26:34,036 --> 00:26:35,736
If you don't want
that app using lots


459
00:26:35,736 --> 00:26:37,426
of data, you can turn it off.


460
00:26:38,286 --> 00:26:39,336
But that's very crude.


461
00:26:39,416 --> 00:26:40,986
That's kind of an all
or nothing switch.


462
00:26:41,856 --> 00:26:44,496
And a lot of apps want to do
something a bit more subtle.


463
00:26:45,426 --> 00:26:47,376
Say you have a video
streaming app.


464
00:26:48,836 --> 00:26:53,046
You may want the user to be
able to browse the catalog,


465
00:26:53,046 --> 00:26:54,546
see little thumbnail pictures,


466
00:26:54,546 --> 00:26:57,706
read the descriptions
over mobile data.


467
00:26:58,056 --> 00:26:59,166
Doesn't cost very much.


468
00:26:59,926 --> 00:27:01,886
But you may want the
setting in your app


469
00:27:02,256 --> 00:27:05,056
that says don't stream
videos over mobile


470
00:27:06,186 --> 00:27:07,856
because users may
not want to spend


471
00:27:07,856 --> 00:27:09,306
that much money on mobile data.


472
00:27:10,076 --> 00:27:13,056
And if you have that, you're
going to want to be able


473
00:27:13,056 --> 00:27:16,766
to differentiate between getting
the thumbnail, which is allowed


474
00:27:16,766 --> 00:27:19,026
over cellular, and streaming
the video, which is not.


475
00:27:20,156 --> 00:27:24,256
A lot of developers have
done things like this.


476
00:27:24,636 --> 00:27:28,886
They use the reachability
API to say, am I on cell?


477
00:27:29,096 --> 00:27:29,986
Yes or no?


478
00:27:30,216 --> 00:27:32,836
If I'm not on cell, go
ahead and do that download.


479
00:27:33,226 --> 00:27:36,096
Well, things don't stay
the same in networking.


480
00:27:36,096 --> 00:27:37,946
Things change from
second to second.


481
00:27:38,386 --> 00:27:41,586
And between you checking
whether you're on cell


482
00:27:41,586 --> 00:27:43,016
and actually doing
the connection,


483
00:27:43,406 --> 00:27:45,436
the user may be walking
across the parking lot.


484
00:27:46,216 --> 00:27:49,006
So this is not the
right way to do it.


485
00:27:49,716 --> 00:27:52,706
The right way to do it
is to express your intent


486
00:27:52,856 --> 00:27:56,766
to the networking layers, and
we will honor what you tell us.


487
00:27:58,356 --> 00:28:02,406
The first step here is don't
bother with preflight checks.


488
00:28:02,946 --> 00:28:05,356
If you want to do a network
transaction, just try it.


489
00:28:06,306 --> 00:28:09,996
If that's a transaction that you
don't want to use cellular data,


490
00:28:10,546 --> 00:28:12,976
then you can express that
to the networking layers.


491
00:28:13,536 --> 00:28:15,246
Using the CoreMedia APIs,


492
00:28:15,686 --> 00:28:21,106
you set the allow cellular
access key using NSURLSession.


493
00:28:21,616 --> 00:28:24,376
If you set allows
cellular access to false,


494
00:28:24,756 --> 00:28:27,076
then we won't use
cellular data connection.


495
00:28:27,846 --> 00:28:28,496
Nice and simple.


496
00:28:29,516 --> 00:28:35,666
[ Applause ]


497
00:28:36,166 --> 00:28:38,996
If that connection fails,
you can ask the user,


498
00:28:38,996 --> 00:28:41,376
do you want to stream this
video over mobile data,


499
00:28:42,376 --> 00:28:46,796
or you can just wait, subscribe
for better route notifications,


500
00:28:47,146 --> 00:28:50,536
and when the phone comes back on
Wi-Fi, you'll be told about it


501
00:28:50,836 --> 00:28:53,776
and then you can retry your
connection once Wi-Fi is


502
00:28:53,776 --> 00:28:57,776
available again.


503
00:28:58,956 --> 00:29:02,426
So to summarize, don't
assume that because you're


504
00:29:02,426 --> 00:29:06,696
on Wi-Fi now, you will still be
on Wi-Fi one second from now,


505
00:29:06,696 --> 00:29:08,006
or even half a second from now.


506
00:29:08,896 --> 00:29:09,816
Conditions change.


507
00:29:10,926 --> 00:29:13,266
Express what you want
to the networking layers


508
00:29:13,266 --> 00:29:15,846
and we will respect that.


509
00:29:16,886 --> 00:29:20,666
Our last topic is
networking quality of service.


510
00:29:23,256 --> 00:29:26,556
Last summer, we announced
a partnership between Cisco


511
00:29:26,556 --> 00:29:30,066
and Apple, and I'm going to
tell you a little bit about one


512
00:29:30,066 --> 00:29:35,226
of the new APIs that you can
use to express your needs


513
00:29:35,226 --> 00:29:36,406
to the networking layers.


514
00:29:38,646 --> 00:29:40,556
There are different kinds
of networking traffic.


515
00:29:41,926 --> 00:29:45,336
99 percent of what
we do is good,


516
00:29:45,596 --> 00:29:48,056
standard Internet
best effort traffic.


517
00:29:48,466 --> 00:29:50,316
We want the best
throughput we can get,


518
00:29:51,066 --> 00:29:53,556
and ideally we'd like low delay.


519
00:29:53,556 --> 00:29:57,136
But we definitely want as
much throughput as we can get.


520
00:29:57,436 --> 00:29:59,976
This supplies browsing
the web, sending an email.


521
00:30:01,066 --> 00:30:04,846
Another thing that we
do is online backup,


522
00:30:06,046 --> 00:30:07,546
uploading photos to iCloud.


523
00:30:08,396 --> 00:30:13,306
And that also wants to have
good throughput, but not as good


524
00:30:13,306 --> 00:30:14,636
as the priority stuff.


525
00:30:15,256 --> 00:30:19,066
We'd like to be able to upload
all of our photos to iCloud


526
00:30:19,106 --> 00:30:24,686
in the background without
disrupting our Netflix TV binge.


527
00:30:25,646 --> 00:30:28,706
The photo upload should take
place when we're sleeping.


528
00:30:28,706 --> 00:30:31,506
It is what we call
scavenger-class traffic.


529
00:30:31,506 --> 00:30:34,606
It uses the otherwise idle
capacity of the network


530
00:30:34,606 --> 00:30:38,276
that would otherwise have been
wasted, but it is second class


531
00:30:38,566 --> 00:30:40,596
to sending emails,
browsing the web,


532
00:30:40,596 --> 00:30:42,776
anything that the human
is actively involved with.


533
00:30:42,826 --> 00:30:47,926
The third class of
traffic is telephony,


534
00:30:48,846 --> 00:30:50,396
interactive voice and video.


535
00:30:50,396 --> 00:30:53,206
And I say interactive,
because that's the key thing.


536
00:30:53,666 --> 00:30:56,216
When we're having a
conversation, I speak,


537
00:30:56,586 --> 00:30:59,876
you hear me, you respond,
you speak back, I hear you.


538
00:31:00,166 --> 00:31:03,176
If that round-trip is more than
a couple hundred milliseconds,


539
00:31:03,566 --> 00:31:07,776
human communication breaks down.


540
00:31:08,396 --> 00:31:12,386
When people talk about voice and
video, it's important to realize


541
00:31:12,466 --> 00:31:15,616
that watching a YouTube
video may be video,


542
00:31:16,116 --> 00:31:17,416
but it's not interactive.


543
00:31:17,466 --> 00:31:21,926
It doesn't need that sub 200
millisecond round-trip time.


544
00:31:21,926 --> 00:31:23,776
Listening to a podcast
may be voice;


545
00:31:24,026 --> 00:31:26,046
that doesn't mean a
podcast is voice traffic.


546
00:31:26,046 --> 00:31:26,996
It's not interactive.


547
00:31:27,936 --> 00:31:31,176
So that's why I labeled this
part of the chart telephony,


548
00:31:31,476 --> 00:31:33,476
because this is interactive
voice and video.


549
00:31:34,386 --> 00:31:37,206
For that traffic you want the
lowest round-trip time possible,


550
00:31:38,706 --> 00:31:40,006
and it's very small throughput.


551
00:31:40,096 --> 00:31:41,476
It's a few kilobits per second.


552
00:31:41,526 --> 00:31:43,326
You don't need 50
megabits of voice.


553
00:31:44,056 --> 00:31:45,946
So marking your traffic


554
00:31:45,946 --> 00:31:49,886
as telephony tells the
network keep the latency low,


555
00:31:49,886 --> 00:31:52,136
but you also don't
have a big queue.


556
00:31:52,536 --> 00:31:56,036
If you try to do any kind of
bulk transfer as voice class,


557
00:31:56,226 --> 00:31:59,076
you're going to lose
most of your packets,


558
00:31:59,346 --> 00:32:01,026
because a very small amount


559
00:32:01,026 --> 00:32:03,416
of the network capacity is
allocated for that traffic.


560
00:32:03,986 --> 00:32:07,596
So one of our FAQ
questions people ask us,


561
00:32:07,596 --> 00:32:09,306
will Fastlane make
my app faster?


562
00:32:09,306 --> 00:32:11,596
And the answer is no, it
doesn't make it faster.


563
00:32:11,966 --> 00:32:13,866
It will lower the
latency for voice traffic.


564
00:32:16,496 --> 00:32:19,726
You may be wondering,
how does this relate


565
00:32:19,846 --> 00:32:21,216
to the Smart Queue Management


566
00:32:21,286 --> 00:32:23,166
and Explicit Congestion
Notification


567
00:32:23,546 --> 00:32:24,826
that we were talking
about earlier?


568
00:32:24,826 --> 00:32:30,056
And the answer is those
technologies improve the delay


569
00:32:30,706 --> 00:32:33,766
for all traffic across
the board,


570
00:32:34,426 --> 00:32:38,166
but telephony will probably
still be an extreme case


571
00:32:38,456 --> 00:32:40,766
that wants the very,
very lowest latency


572
00:32:40,766 --> 00:32:46,916
and doesn't mind sacrificing
throughput to get that.


573
00:32:47,716 --> 00:32:51,786
Starting in iOS 5 we had the
network service type API,


574
00:32:51,786 --> 00:32:55,376
and that lets you express some
of these needs to the network.


575
00:32:56,116 --> 00:32:59,446
But many of the developers
writing apps like Skype


576
00:32:59,446 --> 00:33:01,616
and Facetime that
are doing this kind


577
00:33:01,616 --> 00:33:05,456
of voice telephony
are using UDP.


578
00:33:05,456 --> 00:33:09,596
And to use UDP today on iOS, you
need to be using BSD sockets.


579
00:33:10,056 --> 00:33:12,786
So we now have a socket option


580
00:33:13,326 --> 00:33:15,636
that exposes the
same functionality


581
00:33:15,946 --> 00:33:19,156
so your UDP clients
can benefit from this.


582
00:33:20,176 --> 00:33:24,176
We know some developers had been
previously setting the IP type


583
00:33:24,176 --> 00:33:27,586
of service bits in an attempt
to get the same effect.


584
00:33:28,946 --> 00:33:30,166
The problem is those type


585
00:33:30,166 --> 00:33:32,766
of service bits are
not well defined.


586
00:33:32,826 --> 00:33:34,266
They are not specified anywhere.


587
00:33:34,726 --> 00:33:38,466
Some Wi-Fi chip vendors will
look at the type of service bits


588
00:33:38,606 --> 00:33:42,936
and use that as a hint to
set the Wi-Fi traffic class


589
00:33:43,456 --> 00:33:45,756
to voice, video, background.


590
00:33:47,056 --> 00:33:49,936
But the problem is with no
standard definition of the bits,


591
00:33:50,216 --> 00:33:52,606
that interpretation
is not consistent.


592
00:33:52,606 --> 00:33:56,486
So you may test it in your
office and think it works fine,


593
00:33:56,876 --> 00:33:58,576
but for a customer, it
does something different.


594
00:33:59,156 --> 00:34:00,866
And that's why we have
the new socket option


595
00:34:00,866 --> 00:34:01,856
that gives you reliable,


596
00:34:01,856 --> 00:34:04,066
consistent behavior
across all devices.


597
00:34:06,486 --> 00:34:07,956
If you're writing Swift code,


598
00:34:08,536 --> 00:34:10,726
you can set the network
service type property


599
00:34:10,726 --> 00:34:12,396
to voice, video, or background.


600
00:34:12,746 --> 00:34:13,985
Or if you don't set it at all,


601
00:34:13,985 --> 00:34:16,786
then that is traditional
best effort.


602
00:34:17,716 --> 00:34:19,356
If you are using
the socket option,


603
00:34:19,775 --> 00:34:21,216
we have the same options.


604
00:34:21,735 --> 00:34:25,936
We have about another seven
more than this, which is more


605
00:34:25,936 --> 00:34:26,835
than most of you will need.


606
00:34:27,286 --> 00:34:30,326
These are the four
interesting ones.


607
00:34:31,886 --> 00:34:35,126
When you set these options,
a couple of things happen.


608
00:34:36,726 --> 00:34:39,676
On the device itself, there
are multiple outband queues,


609
00:34:40,466 --> 00:34:43,795
and the type of service you set


610
00:34:43,795 --> 00:34:46,045
for your traffic controls
which queue it uses.


611
00:34:47,775 --> 00:34:51,565
On Wi-Fi interfaces, it
will also set the wireless


612
00:34:51,565 --> 00:34:52,985
multi-media access category.


613
00:34:54,446 --> 00:34:57,686
This is supported on all
devices, iOS and OS X,


614
00:34:58,396 --> 00:35:00,566
and the outband queue
selection also applies


615
00:35:00,566 --> 00:35:01,936
for Ethernet as well as Wi-Fi.


616
00:35:03,696 --> 00:35:07,506
Now, if your device is on one


617
00:35:07,506 --> 00:35:12,056
of these new Cisco Fastlane
networks, we will recognize that


618
00:35:12,056 --> 00:35:16,296
and we will also set the IP
layer differentiating services


619
00:35:16,296 --> 00:35:20,626
Code Point so that you get
that handling that you want,


620
00:35:20,846 --> 00:35:23,566
not just on the first
hop leaving the device


621
00:35:23,906 --> 00:35:26,206
but in subsequent hops
through the enterprise network.


622
00:35:27,136 --> 00:35:31,786
I want to stress this is not
something that you all need


623
00:35:31,816 --> 00:35:34,266
to feel obliged to go
away and change your code.


624
00:35:34,876 --> 00:35:36,856
If you're writing an
online backup app,


625
00:35:37,476 --> 00:35:39,296
definitely set background
traffic class.


626
00:35:39,996 --> 00:35:44,686
If you're writing the next
Skype, then set the voice class.


627
00:35:45,156 --> 00:35:46,616
But for the rest of you,


628
00:35:47,476 --> 00:35:50,306
standard best effort is almost
certainly what you want.


629
00:35:51,736 --> 00:35:53,246
Some other things you
ought to remember:


630
00:35:55,146 --> 00:35:58,776
The outband queue
selection and Wi-Fi layer,


631
00:35:58,776 --> 00:36:01,776
quality of service marking
is supported on all devices,


632
00:36:02,016 --> 00:36:04,106
but remember it only
applies to outband packets.


633
00:36:04,106 --> 00:36:06,456
The packets coming in have
to be marked by the thing


634
00:36:06,456 --> 00:36:07,546
at the other end sending them.


635
00:36:08,526 --> 00:36:14,116
And the IP layer marking is
also only for outbound packets.


636
00:36:14,866 --> 00:36:18,966
It's today only supported
on Cisco networks


637
00:36:18,966 --> 00:36:20,106
with compatible hardware.


638
00:36:20,906 --> 00:36:22,006
It's only on iOS.


639
00:36:22,136 --> 00:36:25,406
It's not supported on Macs
or Apple TV or anything else.


640
00:36:26,196 --> 00:36:28,296
And for now it's only
supported on Wi-Fi.


641
00:36:28,296 --> 00:36:30,756
I know most people don't use
Ethernet with your iPads,


642
00:36:30,756 --> 00:36:32,796
but if you do plug in
an Ethernet adaptor,


643
00:36:33,436 --> 00:36:35,646
the quality of service is
not supported on Ethernet.


644
00:36:36,476 --> 00:36:39,956
And finally if the
administrator chooses


645
00:36:40,016 --> 00:36:42,706
to install a management
profile on the device,


646
00:36:43,316 --> 00:36:47,126
then that management profile can
restrict which apps are allowed


647
00:36:47,126 --> 00:36:50,936
to use this type of service
option, and only apps


648
00:36:50,936 --> 00:36:52,766
that are listed in the
profile will be able


649
00:36:52,766 --> 00:36:53,896
to set type of service.


650
00:36:53,896 --> 00:36:57,296
It will be a no op
for all other apps.


651
00:37:00,006 --> 00:37:01,486
So to summarize this section,


652
00:37:01,996 --> 00:37:05,996
most of your traffic should
continue to be best effort.


653
00:37:07,276 --> 00:37:09,806
If you are doing
large, bulk transfers


654
00:37:09,806 --> 00:37:12,646
that are not time critical,
background traffic is a way


655
00:37:12,646 --> 00:37:14,026
for you to be less disruptive


656
00:37:14,026 --> 00:37:15,696
and be a better citizen
on the network.


657
00:37:16,666 --> 00:37:18,786
Remember, it's not
a priority level.


658
00:37:19,186 --> 00:37:20,906
There isn't a ranked
ordering here


659
00:37:20,906 --> 00:37:22,556
of high priority
to low priority.


660
00:37:23,056 --> 00:37:25,946
It's a web expressing whether
you want low throughput


661
00:37:25,946 --> 00:37:30,286
and low latency or high
throughput and moderate latency.


662
00:37:34,716 --> 00:37:35,876
So that ends our session.


663
00:37:35,876 --> 00:37:37,106
Thank you for coming.


664
00:37:37,656 --> 00:37:42,456
We've talked about Smart Queue
Management, and this is a call


665
00:37:42,456 --> 00:37:46,666
to action to all the ISPs and
carriers and network vendors.


666
00:37:47,506 --> 00:37:48,986
The clients are supporting ECN.


667
00:37:49,076 --> 00:37:50,636
The servers are supporting ECN.


668
00:37:51,106 --> 00:37:53,726
If you start marking the
packets in your network instead


669
00:37:53,726 --> 00:37:56,226
of dropping them, you will
make your users much happier.


670
00:37:57,166 --> 00:37:58,796
The message for developers


671
00:37:58,796 --> 00:38:03,096
in the room is IPv6 is now
the majority of traffic


672
00:38:03,226 --> 00:38:05,296
for many carriers
on many networks.


673
00:38:06,006 --> 00:38:09,316
Support IPv6 in your
applications.


674
00:38:09,846 --> 00:38:13,656
Support IPv6 and
IPv4 in your servers.


675
00:38:15,146 --> 00:38:18,016
For your text, UTF-8
is the new ASCII.


676
00:38:18,456 --> 00:38:19,866
It's no harder than ASCII.


677
00:38:20,766 --> 00:38:22,366
It's really very
simple to use it.


678
00:38:22,776 --> 00:38:26,096
All of our devices
now have good support


679
00:38:26,316 --> 00:38:28,356
for all the Unicode
characters in the fonts,


680
00:38:28,586 --> 00:38:29,856
so you should have no worries


681
00:38:29,856 --> 00:38:32,236
about supporting UTF-8
without hesitation.


682
00:38:33,266 --> 00:38:36,926
And finally, we have new ways
for you to express intent


683
00:38:36,926 --> 00:38:38,076
to the networking layers.


684
00:38:39,146 --> 00:38:41,936
You can control when you don't
want to use cellular data,


685
00:38:42,796 --> 00:38:45,936
and you now also
have finer control


686
00:38:46,306 --> 00:38:49,026
of the throughput latency
characteristics of your data.


687
00:38:50,546 --> 00:38:53,016
So with that, there's a link


688
00:38:53,356 --> 00:38:54,846
where you can find
more information.


689
00:38:55,646 --> 00:38:58,676
We have other sessions
that you can watch on video


690
00:38:58,676 --> 00:39:00,446
that you may find interesting.


691
00:39:00,446 --> 00:39:02,336
We have sessions
about networking


692
00:39:02,336 --> 00:39:03,936
and security, which
is important.


693
00:39:04,426 --> 00:39:05,576
We have a couple
of other sessions


694
00:39:05,576 --> 00:39:07,106
about internationalization.


695
00:39:07,806 --> 00:39:08,716
We have some sessions


696
00:39:08,716 --> 00:39:12,216
about higher layer networking
applications, like HomeKit.


697
00:39:12,586 --> 00:39:14,976
So with that, thank
you for coming to WWDC.


698
00:39:15,516 --> 00:39:25,650
[ Applause ]

