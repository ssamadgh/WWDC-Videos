1
00:00:00,506 --> 00:00:09,516
[ Silence ]


2
00:00:10,016 --> 00:00:14,000
[ Applause ]


3
00:00:15,326 --> 00:00:16,076
>> Good afternoon.


4
00:00:17,186 --> 00:00:20,116
My name is Doug Gregor and I'm
here today to talk today to you


5
00:00:20,276 --> 00:00:22,196
about Advances in Objective-C.


6
00:00:23,786 --> 00:00:27,906
Objective-C is a great language
with the vibrant user community.


7
00:00:28,846 --> 00:00:31,776
If you're here last year,
you saw that we are really,


8
00:00:31,836 --> 00:00:33,966
really excited that
we could see this here


9
00:00:33,966 --> 00:00:35,876
in the TIOBE Programming
Community Index.


10
00:00:35,876 --> 00:00:38,096
This is from May 2012.


11
00:00:38,806 --> 00:00:40,916
And we see that Objective-C
had moved all the way


12
00:00:40,916 --> 00:00:42,526
up to fourth place
in the rankings.


13
00:00:42,856 --> 00:00:43,796
Just pretty amazing.


14
00:00:44,666 --> 00:00:47,946
Well in just the last
year, Objective-C has moved


15
00:00:47,946 --> 00:00:51,376
up even further displacing
the vulnerable C++


16
00:00:51,376 --> 00:00:52,846
for the number three spot.


17
00:00:52,846 --> 00:00:53,586
Whoo!


18
00:00:54,516 --> 00:00:59,306
[ Applause ]


19
00:00:59,806 --> 00:01:01,526
So how do we evolve
the Objective-C?


20
00:01:01,886 --> 00:01:04,296
Well, there are some
things that we focus on.


21
00:01:04,676 --> 00:01:07,486
The two things in general that
we really do want to focus


22
00:01:07,486 --> 00:01:10,016
on are developer
productivity, that's your time,


23
00:01:10,686 --> 00:01:13,336
and software quality,
that's the quality that goes


24
00:01:13,336 --> 00:01:14,506
into your applications.


25
00:01:14,976 --> 00:01:17,336
And we can improve
both of these things


26
00:01:17,946 --> 00:01:20,506
through evolving the language
and the tools that support it.


27
00:01:21,626 --> 00:01:25,026
So in the realm of developer
productivity, we can do things


28
00:01:25,026 --> 00:01:27,316
like find places where
there's boilerplate,


29
00:01:27,316 --> 00:01:30,256
you're writing the same thing
over and over and over again,


30
00:01:30,256 --> 00:01:33,546
at synthesize, at synthesize,
at synthesize, and eliminate


31
00:01:33,546 --> 00:01:36,276
that from the language by
getting the right defaults.


32
00:01:36,676 --> 00:01:39,806
Second, we can find other
operations that you do day in


33
00:01:39,806 --> 00:01:42,316
and day out throughout many,
many different code bases


34
00:01:42,536 --> 00:01:45,036
and simplify them, bring the
syntax into the language,


35
00:01:45,036 --> 00:01:49,746
make them easier to use, faster
to write, faster to read.


36
00:01:49,746 --> 00:01:52,146
And finally, we can
provide great tools


37
00:01:52,196 --> 00:01:55,336
because you use tools to
write codes in Objective-C.


38
00:01:55,696 --> 00:01:59,186
And part of this is developing
the tools themselves and part


39
00:01:59,186 --> 00:02:02,186
of this is making sure that
the language itself is amenable


40
00:02:02,186 --> 00:02:03,326
to building great tools.


41
00:02:03,326 --> 00:02:06,246
We'll actually get back to that
with our first major feature.


42
00:02:07,456 --> 00:02:09,556
The other area is
software quality


43
00:02:09,556 --> 00:02:12,026
and how can we help there
through the language.


44
00:02:12,856 --> 00:02:13,756
So, couple of areas.


45
00:02:13,846 --> 00:02:16,246
We can try to catch
more bugs earlier.


46
00:02:16,686 --> 00:02:20,646
You can do this through stronger
and better static type safety


47
00:02:21,056 --> 00:02:23,476
so the compiler can reason
about the type in your program


48
00:02:23,476 --> 00:02:25,946
and warn when something
is going wrong.


49
00:02:26,166 --> 00:02:30,086
Next, we can find error
prone tasks, for example,


50
00:02:30,086 --> 00:02:33,576
writing retain and release
everywhere, automate those away


51
00:02:33,576 --> 00:02:36,736
within the compiler to eliminate
huge classes of problems.


52
00:02:38,056 --> 00:02:40,916
And finally, Objective-C is a
language with a rich history.


53
00:02:40,916 --> 00:02:42,666
We have a large developer
community


54
00:02:42,666 --> 00:02:45,316
that has established
best practices for how


55
00:02:45,316 --> 00:02:46,866
to use this language well.


56
00:02:46,866 --> 00:02:49,366
And we can bring those
into the language


57
00:02:49,366 --> 00:02:50,926
to help you build
better software.


58
00:02:52,376 --> 00:02:54,836
Today, we're going to talk
about a couple of things.


59
00:02:55,246 --> 00:02:57,176
We're going to talk about a new
Objective-C language feature


60
00:02:57,336 --> 00:02:58,426
called Modules.


61
00:02:58,426 --> 00:03:01,666
We're also going to talk
about better productivity


62
00:03:01,786 --> 00:03:03,276
in the use of Objective-C.


63
00:03:03,626 --> 00:03:05,106
And finally, some improvements


64
00:03:05,106 --> 00:03:10,176
to Automatic Reference
Counting or ARC.


65
00:03:10,446 --> 00:03:16,006
Modules. So, the idea behind
Modules is that if you look


66
00:03:16,006 --> 00:03:19,166
at applications built
for iOS and OS X,


67
00:03:19,246 --> 00:03:23,506
at the core of these
applications is the use of a ton


68
00:03:23,506 --> 00:03:25,436
of really great systems
frameworks.


69
00:03:26,246 --> 00:03:28,166
This is how you integrate
with services


70
00:03:28,236 --> 00:03:30,576
like iCloud or with Game Center.


71
00:03:30,966 --> 00:03:33,636
Maybe it's using
iAd to introduce ads


72
00:03:33,636 --> 00:03:36,716
into your application or
core location services


73
00:03:37,476 --> 00:03:39,866
so that you give your
user relevant content


74
00:03:39,916 --> 00:03:41,836
where they at right now.


75
00:03:42,876 --> 00:03:45,316
And so, this is sort of
the foundational layer


76
00:03:45,316 --> 00:03:48,736
on which you build all of the
magic of your applications.


77
00:03:49,326 --> 00:03:51,326
So we looked at the
process of how is it


78
00:03:51,326 --> 00:03:52,346
that you use a framework.


79
00:03:53,156 --> 00:03:54,986
Well, first, you go into Xcode.


80
00:03:54,986 --> 00:03:56,056
You go into your coding window.


81
00:03:56,746 --> 00:03:58,666
You write the #import for
the framework you want.


82
00:03:58,916 --> 00:04:01,176
In this case, we're going
to pull in iAd and use


83
00:04:01,176 --> 00:04:02,696
that as our demonstration.


84
00:04:03,096 --> 00:04:05,466
And the name is really
important, so you see iAd twice


85
00:04:05,466 --> 00:04:09,906
when you import iAd/iAd.h.
That's fine.


86
00:04:09,906 --> 00:04:12,066
You start writing your
code to the iAd framework,


87
00:04:12,066 --> 00:04:13,916
use some tutorial
samples and so on.


88
00:04:14,196 --> 00:04:16,906
You hit Build and you get
the dreaded link error.


89
00:04:17,555 --> 00:04:20,636
If this is the first time you've
seen this, this is horrifying


90
00:04:20,636 --> 00:04:22,666
and you have to search to
see what actually went wrong.


91
00:04:23,056 --> 00:04:25,016
But of course seasoned
developers know.


92
00:04:25,296 --> 00:04:26,896
Fine, there's several
ways to fix this.


93
00:04:26,896 --> 00:04:28,926
You can go edit the project,


94
00:04:28,926 --> 00:04:32,056
just go over to the build
phases, just close the triangle,


95
00:04:32,126 --> 00:04:34,746
hit the Plus, go find
the framework again.


96
00:04:34,746 --> 00:04:37,196
We said iAd three times
now if you're counting.


97
00:04:37,796 --> 00:04:40,496
Hit Add and we can actually
build our application,


98
00:04:41,346 --> 00:04:42,786
not exactly wonderful.


99
00:04:43,456 --> 00:04:46,606
And both of these steps
are very disjointed.


100
00:04:46,636 --> 00:04:49,456
We have the #import which is
what you write in your code


101
00:04:49,456 --> 00:04:51,366
and then we have the
addition of the library


102
00:04:51,366 --> 00:04:53,216
which is something you
do in Xcode, elsewhere.


103
00:04:53,896 --> 00:04:56,416
And so, let's go back to
the #import side of things


104
00:04:56,816 --> 00:05:00,356
because #import is a
teeny tiny innovation


105
00:05:00,666 --> 00:05:04,036
over the basic #include
that's been in C for three,


106
00:05:04,126 --> 00:05:06,136
four decades based
on the preprocessor.


107
00:05:06,766 --> 00:05:09,106
And so, we're going to look a
little bit at how the #import


108
00:05:09,106 --> 00:05:10,796
and #include actually work.


109
00:05:10,866 --> 00:05:14,176
So you have your application,
some .m file from it.


110
00:05:14,176 --> 00:05:18,306
And what it does is it
#imports iAd.h. Fine,


111
00:05:18,306 --> 00:05:19,056
what does that actually do?


112
00:05:19,056 --> 00:05:22,166
Well, it resolves iAd.h and
the compiler goes and hunts


113
00:05:22,166 --> 00:05:24,486
for the next thing
that iAd included


114
00:05:24,486 --> 00:05:26,076
and the next thing
that that included.


115
00:05:26,366 --> 00:05:29,066
Eventually, we get back to
UIKit and all of its headers


116
00:05:29,066 --> 00:05:30,506
and all the things
that that brings in.


117
00:05:30,506 --> 00:05:33,146
And so, really, the
dependency that you have


118
00:05:33,616 --> 00:05:36,386
from your data .m is
out to a whole bunch


119
00:05:36,386 --> 00:05:40,346
of different header
files within the SDK.


120
00:05:40,576 --> 00:05:44,236
How does this actually
work as the language model?


121
00:05:44,356 --> 00:05:47,146
Well, again, this is the C
model of the preprocessor.


122
00:05:47,146 --> 00:05:48,946
It's essentially
textual inclusion


123
00:05:49,246 --> 00:05:51,386
or a fancy form of
cut and paste.


124
00:05:51,956 --> 00:05:55,176
So, here we have, you know,
simple .m for an app delegate.


125
00:05:55,506 --> 00:05:57,776
It imports iAd.h.
What's that do?


126
00:05:58,376 --> 00:05:59,386
First thing compiler does,


127
00:05:59,386 --> 00:06:03,776
go find what is iAd/iAd.h
actually refers to and it comes


128
00:06:03,776 --> 00:06:04,846
up with a file on disk.


129
00:06:05,626 --> 00:06:08,836
Fine, it copies that
file, preprocess it,


130
00:06:09,206 --> 00:06:15,496
and pastes the results
into our .m at the end.


131
00:06:15,546 --> 00:06:17,536
Okay. And then what do we have?


132
00:06:17,536 --> 00:06:18,356
More imports.


133
00:06:18,726 --> 00:06:20,886
So we go hunt for the next file.


134
00:06:21,056 --> 00:06:25,256
Take its text, copy it,
preprocess it, paste it in,


135
00:06:25,256 --> 00:06:27,266
and the .m gets as
little longer.


136
00:06:27,346 --> 00:06:30,646
And we go hunt for more files
and we copy and paste those in.


137
00:06:30,646 --> 00:06:33,976
And once you get at the
end is one big long .m


138
00:06:33,976 --> 00:06:36,746
which is what the
compiler actually sees


139
00:06:36,976 --> 00:06:38,696
for each .m file in
your application.


140
00:06:40,036 --> 00:06:42,016
This model has been
working for decades,


141
00:06:42,096 --> 00:06:44,316
so what's wrong with it?


142
00:06:44,316 --> 00:06:46,006
Well, it has two problems.


143
00:06:46,006 --> 00:06:47,226
The first problem
we're going to talk


144
00:06:47,226 --> 00:06:49,656
about is it's a very
fragile model.


145
00:06:49,656 --> 00:06:51,776
So I'm going to do
something here


146
00:06:51,776 --> 00:06:53,246
that may make a few
of you cringe.


147
00:06:53,606 --> 00:06:57,226
I'm going to define a
constant read-only to 0x01


148
00:06:57,226 --> 00:07:00,416
because that makes sense for
my .m, for my application code.


149
00:07:00,466 --> 00:07:05,766
And I happen to do that
before #importing iAd.h. See,


150
00:07:05,766 --> 00:07:08,016
preprocessor does
what its design to do.


151
00:07:08,306 --> 00:07:10,856
It goes and hunts down
these files, copies them,


152
00:07:10,956 --> 00:07:13,126
preprocess them,
paste the result,


153
00:07:13,566 --> 00:07:15,566
and we end up with
this file up here


154
00:07:15,566 --> 00:07:17,846
which is the .m the
compiler sees.


155
00:07:18,886 --> 00:07:22,116
The compiler is not going to
like this .m and it's going


156
00:07:22,116 --> 00:07:25,456
to complain, 0x01 is not a
valid property attribute,


157
00:07:25,826 --> 00:07:26,896
it is very correct.


158
00:07:27,896 --> 00:07:31,056
The really unfortunate
thing here is that the error


159
00:07:31,056 --> 00:07:32,706
that you get is in
the system headers.


160
00:07:32,706 --> 00:07:34,826
That's not code you wrote and


161
00:07:34,826 --> 00:07:39,256
yet somehow you accidentally
broke it just by doing something


162
00:07:39,326 --> 00:07:41,546
where you defined the local
constant in your header file.


163
00:07:41,956 --> 00:07:43,946
And now, you can blame
me for doing this.


164
00:07:43,946 --> 00:07:45,656
I'm the one that write--
wrote this code in this slide.


165
00:07:45,786 --> 00:07:49,636
Clearly, it's my fault because
what I should have done is used


166
00:07:49,906 --> 00:07:54,186
a prefixed very long
uppercase name for my constant


167
00:07:54,216 --> 00:07:55,826
because that's what
we do with macros.


168
00:07:56,126 --> 00:07:57,976
It's the convention
that we've established


169
00:07:58,016 --> 00:08:00,836
within the C programming
world to cope


170
00:08:00,836 --> 00:08:02,886
with this fragility problem.


171
00:08:03,146 --> 00:08:05,286
And so, this doesn't
happen often


172
00:08:05,286 --> 00:08:06,436
that you hit these problems.


173
00:08:06,646 --> 00:08:09,036
But we do hit them
in programming.


174
00:08:09,036 --> 00:08:10,576
And usually, they
come in as some sort


175
00:08:10,576 --> 00:08:11,776
of header include-dependency.


176
00:08:12,216 --> 00:08:15,086
Someone's header over here
didn't follow the rules.


177
00:08:15,086 --> 00:08:16,056
He didn't get the memo.


178
00:08:16,396 --> 00:08:18,396
And it stomps on
another header over here.


179
00:08:18,396 --> 00:08:21,086
And if you include them in
one order, things work fine,


180
00:08:21,086 --> 00:08:23,756
or with one version of some
framework, it works fine.


181
00:08:24,206 --> 00:08:25,746
You migrate to another
version and, suddenly,


182
00:08:25,746 --> 00:08:27,646
there's a conflict
that you get to debug.


183
00:08:27,866 --> 00:08:30,566
If you're lucky, it manifests
an error that's fairly easy


184
00:08:30,566 --> 00:08:31,276
to track down.


185
00:08:31,996 --> 00:08:35,035
If you're not so lucky, it could
actually be a runtime that's


186
00:08:35,176 --> 00:08:37,356
really hard to track down
for something that ends


187
00:08:37,356 --> 00:08:39,096
up being just flipping
to include.


188
00:08:39,726 --> 00:08:43,676
So this is a problem that we
deal with but we've been working


189
00:08:43,746 --> 00:08:45,196
through it through
our conventions.


190
00:08:45,576 --> 00:08:46,156
It's fine.


191
00:08:47,076 --> 00:08:48,926
The real issue here, however,


192
00:08:48,926 --> 00:08:51,866
is that this whole model
is inherently not scalable.


193
00:08:52,436 --> 00:08:56,726
And so, to see this, we took
all of the .m files in iOS Mail


194
00:08:56,756 --> 00:08:59,176
and we plot them according
to their size on disk.


195
00:08:59,806 --> 00:09:02,386
So it's got, you know,
about 250 .ms here


196
00:09:02,756 --> 00:09:05,246
and you can see they range
from half a kilobyte up to


197
00:09:05,246 --> 00:09:09,156
about 200 kilobytes in
size with a very large skew


198
00:09:09,186 --> 00:09:10,676
with really tiny files.


199
00:09:10,676 --> 00:09:13,446
And we see this across the
numerous projects that you tend


200
00:09:13,446 --> 00:09:15,806
to have many, many
small .m files.


201
00:09:17,096 --> 00:09:20,546
Now, we've added iAd.h,
an import of iAd.h


202
00:09:20,696 --> 00:09:23,136
into a fairly central header.


203
00:09:23,586 --> 00:09:25,606
So what that really means
is for all these .m files,


204
00:09:25,606 --> 00:09:27,476
we're not just parsing
what's in the .m file,


205
00:09:27,476 --> 00:09:30,356
we're also parsing
everything that's in iAd.


206
00:09:30,466 --> 00:09:34,196
iAd is a fairly small
framework and the headers come


207
00:09:34,196 --> 00:09:35,896
in about 25 kilobytes.


208
00:09:35,946 --> 00:09:39,546
So, for many of these
files, just the size


209
00:09:39,786 --> 00:09:42,786
of iAd works the size
of the actual code


210
00:09:42,786 --> 00:09:44,966
that you wrote in your .m file.


211
00:09:45,916 --> 00:09:47,476
Of course, iAd isn't standalone


212
00:09:47,476 --> 00:09:49,626
and everyone needs
UIKit everywhere


213
00:09:49,626 --> 00:09:52,236
and UIKit is more
like 400 kilobytes.


214
00:09:53,336 --> 00:09:56,456
Okay. So now, our tiny
little files which is most


215
00:09:56,456 --> 00:10:01,906
of what's here are actually
going through 425 kilobytes


216
00:10:01,906 --> 00:10:03,596
of header files pulling
all those


217
00:10:03,596 --> 00:10:07,276
in from disk parsing
them just to get


218
00:10:07,276 --> 00:10:09,266
at your tiny little bit of code.


219
00:10:10,306 --> 00:10:11,406
And if you think this is bad,


220
00:10:11,406 --> 00:10:14,136
this is iOS where UIKit
is actually fairly small.


221
00:10:14,436 --> 00:10:19,096
So, on OS X, the Cocoa framework
that you pull in everywhere,


222
00:10:19,096 --> 00:10:23,096
it's about 29 times
larger than UIKit.


223
00:10:23,226 --> 00:10:26,556
So you can't even see the
.m files, your own code


224
00:10:26,556 --> 00:10:27,796
in this kind of chart.


225
00:10:28,276 --> 00:10:32,356
So what this presents is
inherent scalability problem.


226
00:10:32,356 --> 00:10:34,166
You can't scale with
a system like this


227
00:10:34,216 --> 00:10:36,306
because you have
your M source files


228
00:10:36,456 --> 00:10:38,316
and you have the N headers.


229
00:10:39,476 --> 00:10:41,986
That's the storage
on disk, M plus N.


230
00:10:42,046 --> 00:10:44,526
But the time to compile
is M times N


231
00:10:44,526 --> 00:10:46,956
because you're reparsing
every one of those headers


232
00:10:46,956 --> 00:10:48,456
for all of your .m files.


233
00:10:48,566 --> 00:10:51,476
And of course, both
M and N are growing


234
00:10:51,836 --> 00:10:54,656
as you build your applications
and add more code to them


235
00:10:54,976 --> 00:10:59,936
and as the system adds more
frameworks and APIs to them.


236
00:11:00,126 --> 00:11:03,426
So clearly, it can't be this
horrible or I'll be screaming


237
00:11:03,426 --> 00:11:05,016
at us to fix the
compile time issue.


238
00:11:05,466 --> 00:11:08,686
And so, one of that features
that we've had for a long time


239
00:11:08,686 --> 00:11:11,306
to try to solve this
is precompiled headers.


240
00:11:12,206 --> 00:11:14,626
And so, precompiled headers
actually do help a lot.


241
00:11:14,676 --> 00:11:15,866
The idea is fairly simple.


242
00:11:16,226 --> 00:11:18,396
You take some subset of
headers that's common


243
00:11:18,396 --> 00:11:21,866
across your entire project,
like maybe all of UIKit.


244
00:11:21,866 --> 00:11:25,256
And you compile it once
into some efficient


245
00:11:25,446 --> 00:11:26,896
on disk representation.


246
00:11:27,726 --> 00:11:29,746
And then whenever
you build a .m file,


247
00:11:29,996 --> 00:11:31,706
you load that representation
first,


248
00:11:31,706 --> 00:11:33,376
that binary representation
that's fast,


249
00:11:33,676 --> 00:11:36,216
no parsing, and start
from there.


250
00:11:36,866 --> 00:11:38,556
Now, this is great
because you don't have


251
00:11:38,556 --> 00:11:40,906
to parse UIKit or Cocoa.


252
00:11:40,906 --> 00:11:43,706
And in fact, when you started
with your project with Xcode,


253
00:11:43,706 --> 00:11:46,206
you got a precompiled
header for UIKit or Cocoa


254
00:11:46,206 --> 00:11:47,326
for free as you started.


255
00:11:48,206 --> 00:11:51,136
But anything else that you've
added later on, when you add


256
00:11:51,136 --> 00:11:54,816
that #import of iAd.h
is still being parsed


257
00:11:54,816 --> 00:11:56,146
over and over again.


258
00:11:57,176 --> 00:11:59,106
You could fix this if
you really wanted to.


259
00:11:59,426 --> 00:12:01,626
You could extend your
precompiled header


260
00:12:01,756 --> 00:12:04,416
to include iAd.h. And now,


261
00:12:04,416 --> 00:12:06,186
you're no longer
parsing this every time.


262
00:12:06,226 --> 00:12:08,406
What we've seen, however,


263
00:12:08,406 --> 00:12:11,216
is that developers don't
generally maintain their


264
00:12:11,266 --> 00:12:12,276
precompiled headers.


265
00:12:12,646 --> 00:12:14,686
A few people do and
they see more benefits


266
00:12:14,686 --> 00:12:15,866
out of precompiled headers.


267
00:12:16,236 --> 00:12:19,176
But most don't, partly because
they don't know about it,


268
00:12:19,176 --> 00:12:22,146
partly because they don't want
to be optimizing for our tools.


269
00:12:22,796 --> 00:12:26,666
But also, there's another
reason you might want to this


270
00:12:26,666 --> 00:12:29,196
and that's using
precompiled headers introduces


271
00:12:29,196 --> 00:12:30,116
namespace pollution.


272
00:12:30,646 --> 00:12:34,426
You may not want to have iAd in
every part of your application.


273
00:12:34,426 --> 00:12:36,726
It maybe fairly centralized
but putting it


274
00:12:36,726 --> 00:12:39,696
into your precompiled header
makes it available everywhere.


275
00:12:39,696 --> 00:12:40,796
So they're always showing


276
00:12:40,796 --> 00:12:42,866
up in code completion
results, for example.


277
00:12:43,156 --> 00:12:44,256
It's always available.


278
00:12:44,256 --> 00:12:46,486
And so, there's principle
reasons for not wanting


279
00:12:46,486 --> 00:12:47,856
to use precompiled
headers anywhere.


280
00:12:48,486 --> 00:12:52,416
So Modules are designed to
solve these two problems,


281
00:12:53,226 --> 00:12:55,636
the problem of the inherent
scalability problem of headers


282
00:12:55,636 --> 00:12:57,556
and also the fragility
problem of headers.


283
00:12:58,716 --> 00:13:00,156
So what are these Modules?


284
00:13:00,586 --> 00:13:02,986
So think of them
as an encapsulation


285
00:13:03,046 --> 00:13:04,896
of what a framework is.


286
00:13:05,206 --> 00:13:08,096
It's API and its
corresponding implementation.


287
00:13:09,096 --> 00:13:11,946
A Module is something that's
separately compiled all


288
00:13:11,946 --> 00:13:12,286
the time.


289
00:13:12,756 --> 00:13:17,646
So, it's compiled once and
set aside so that later


290
00:13:17,646 --> 00:13:19,816
on your application
can import that Module,


291
00:13:19,816 --> 00:13:22,816
get access to the API, get
access to the implementation


292
00:13:23,696 --> 00:13:25,726
without having the go
through and parse the headers.


293
00:13:26,936 --> 00:13:28,396
Now in support of Modules,


294
00:13:28,516 --> 00:13:30,656
we introduced one
little bit of syntax.


295
00:13:31,256 --> 00:13:32,936
It's the @import declaration.


296
00:13:33,906 --> 00:13:38,896
What @import does is it pulls in
the API for a particular Module


297
00:13:38,896 --> 00:13:40,046
which corresponds
to the framework.


298
00:13:40,276 --> 00:13:44,146
So here, we're importing
the iAd frameworks API


299
00:13:44,396 --> 00:13:45,396
into our application.


300
00:13:46,466 --> 00:13:48,896
Now this is what we
call a Semantic Import


301
00:13:48,896 --> 00:13:51,756
and it's very different from the
textual inclusion that you get


302
00:13:51,756 --> 00:13:54,216
with headers 'cause
semantic import, of course,


303
00:13:54,296 --> 00:13:55,726
it doesn't parse the headers


304
00:13:56,566 --> 00:13:59,916
but it also doesn't let
the API that's exposed


305
00:13:59,916 --> 00:14:03,616
by @import be changed by
any of your local context.


306
00:14:03,616 --> 00:14:06,556
So if I do this horrible
thing that I did earlier,


307
00:14:06,786 --> 00:14:10,826
# defining read-only to
0x01, it's perfectly fine.


308
00:14:10,936 --> 00:14:15,516
That doesn't change or break
the API of iAd in any way.


309
00:14:16,096 --> 00:14:20,346
The API you get out of the iAd
Module is exactly as the authors


310
00:14:20,406 --> 00:14:21,736
of iAd intended you to get.


311
00:14:21,826 --> 00:14:23,106
You can't make mistake here.


312
00:14:23,676 --> 00:14:29,186
Now, Modules can be thought
of as monolithic things,


313
00:14:29,186 --> 00:14:30,716
like we often think
of frameworks


314
00:14:30,716 --> 00:14:31,786
as a monolithic thing.


315
00:14:31,836 --> 00:14:35,966
I want to get all of the API of
iAd, but you don't have to think


316
00:14:35,966 --> 00:14:37,046
about frameworks this way.


317
00:14:37,046 --> 00:14:38,866
And therefore, you don't have
to think about Modules this way.


318
00:14:39,346 --> 00:14:43,196
And so, we can think of Modules
as being a larger structure,


319
00:14:43,196 --> 00:14:46,806
so here we have the iAd Module
and their smaller pieces


320
00:14:46,806 --> 00:14:48,026
which we call submodules.


321
00:14:48,176 --> 00:14:50,176
So here, we have the
ADInterstitialAd,


322
00:14:50,176 --> 00:14:57,256
the ADBannerView as submodules
within the iAd module itself.


323
00:14:57,556 --> 00:15:00,326
We can import just
part of a framework


324
00:15:00,636 --> 00:15:02,716
by writing @import of iAd.


325
00:15:02,716 --> 00:15:04,336
and then one of the
submodule names.


326
00:15:04,336 --> 00:15:05,746
In this case, it's ADBannerView.


327
00:15:05,746 --> 00:15:09,876
And what that does is it gives
us just the API corresponding


328
00:15:09,876 --> 00:15:11,736
to ADBannerView within iAd.


329
00:15:12,236 --> 00:15:14,326
So from an API perspective,


330
00:15:14,326 --> 00:15:17,916
this is giving you exactly the
same thing that you would get


331
00:15:17,916 --> 00:15:21,836
out of #import of
iAd/ADBannerView.h. And in fact,


332
00:15:21,836 --> 00:15:23,666
the frameworks and the sub--


333
00:15:23,666 --> 00:15:27,726
the framework headers and the
submodules match up exactly.


334
00:15:27,726 --> 00:15:30,036
It's something you can see if
you look at code completion


335
00:15:30,036 --> 00:15:32,416
for example after @import iAd.


336
00:15:33,286 --> 00:15:37,186
is the submodule structure here
to get at exactly what you want


337
00:15:37,186 --> 00:15:41,726
and this match up exactly what
the file names that are there.


338
00:15:41,726 --> 00:15:45,436
Now, once you've used @import,
you get the API of a framework.


339
00:15:46,246 --> 00:15:47,506
You also get the implementation


340
00:15:47,506 --> 00:15:49,266
for free via the
Autolinking feature.


341
00:15:50,156 --> 00:15:53,716
And so, once you've
switch over to Modules


342
00:15:53,896 --> 00:15:56,046
and you're importing
a particular Module,


343
00:15:56,046 --> 00:15:57,766
the compiler is just
going to record


344
00:15:57,766 --> 00:16:00,766
in the object files it
create what Modules you used


345
00:16:01,036 --> 00:16:03,516
so that we'll automatically
link against these things


346
00:16:03,736 --> 00:16:05,856
and you never have
to go in-- thank you.


347
00:16:06,516 --> 00:16:10,476
[ Applause ]


348
00:16:10,976 --> 00:16:13,236
Right. So you should not have
to go in and then link binary


349
00:16:13,236 --> 00:16:14,066
with libraries anymore.


350
00:16:14,576 --> 00:16:16,556
So what does it takes
to use Modules?


351
00:16:16,556 --> 00:16:19,276
We've shown the new
syntax, the @import syntax.


352
00:16:20,296 --> 00:16:22,416
So Modules are an
opting feature.


353
00:16:23,536 --> 00:16:25,786
So you can opt in via
build setting and I'll show


354
00:16:25,786 --> 00:16:27,366
in just a few moments.


355
00:16:28,476 --> 00:16:31,146
And of course, once you've
opted in, you have access


356
00:16:31,146 --> 00:16:32,526
to the @import syntax.


357
00:16:32,526 --> 00:16:37,206
Now, you probably have
a couple of #imports


358
00:16:37,206 --> 00:16:38,936
and maybe some #includes
in your code,


359
00:16:38,936 --> 00:16:41,316
maybe a handful,
hundreds, thousands.


360
00:16:42,166 --> 00:16:44,236
We don't actually want you to
have to go and rewrite those,


361
00:16:44,516 --> 00:16:46,376
not even automatically.


362
00:16:46,376 --> 00:16:47,466
Of course, we could
migrate them.


363
00:16:47,466 --> 00:16:50,106
What we really want is you
to be able to turn on Modules


364
00:16:50,106 --> 00:16:51,866
and go use the feature
immediately.


365
00:16:52,216 --> 00:16:52,976
And so, the way we deal


366
00:16:52,976 --> 00:16:55,506
with this is we actually
automatically remapped the


367
00:16:55,686 --> 00:16:57,986
#includes and the #includes
in your source code.


368
00:16:58,426 --> 00:17:00,566
When those refer to a
header that we know is part


369
00:17:00,566 --> 00:17:02,216
of a Module, we just treat it


370
00:17:02,216 --> 00:17:05,066
as if you had written
@import all along.


371
00:17:05,195 --> 00:17:07,136
And the great thing
here is you don't have


372
00:17:07,205 --> 00:17:09,556
to change your source
code to use Modules.


373
00:17:09,715 --> 00:17:12,066
You just need to opt in
via the build settings.


374
00:17:12,756 --> 00:17:16,076
The Modules, the @import
provides the exact same API


375
00:17:16,076 --> 00:17:19,596
that you got before just
through a different mechanism


376
00:17:19,596 --> 00:17:21,945
that is safer and
more efficient.


377
00:17:23,376 --> 00:17:26,685
Now, all of the system
frameworks in iOS 7


378
00:17:26,685 --> 00:17:30,496
and OS X Mavericks are
available as Modules.


379
00:17:31,226 --> 00:17:34,546
And so, when you opt in to
Modules, anything you're using


380
00:17:34,546 --> 00:17:37,176
from the system, any of those
system frameworks automatically


381
00:17:37,176 --> 00:17:41,196
goes through this more
efficient, safer path.


382
00:17:41,376 --> 00:17:43,196
You may be wondering, how
does this actually work


383
00:17:43,196 --> 00:17:43,746
under the hood?


384
00:17:43,746 --> 00:17:45,286
Well, let's take a quick look.


385
00:17:45,576 --> 00:17:51,926
So, the basic idea is we have
this notion of Module Maps.


386
00:17:52,086 --> 00:17:56,936
And a Module Map establishes a
relationship between the headers


387
00:17:57,026 --> 00:17:59,876
that are part of the framework
and have always been there,


388
00:18:00,326 --> 00:18:02,886
and the actual logical
Module structure.


389
00:18:03,166 --> 00:18:04,826
So here's a fragment
of a Module Map.


390
00:18:05,366 --> 00:18:08,586
It defines the UIKit Module
based on the UIKit framework.


391
00:18:09,586 --> 00:18:13,186
It says that to actually get
the contents of the UIKit model,


392
00:18:13,186 --> 00:18:15,276
you parse the umbrella
header UIKit.h


393
00:18:15,546 --> 00:18:18,036
which UIKit.h is what
you generally import.


394
00:18:18,036 --> 00:18:19,736
So this is the same
API description.


395
00:18:20,406 --> 00:18:25,446
And that anything that UIKit.h
itself imports becomes a


396
00:18:25,446 --> 00:18:26,966
submodule within UIKit.


397
00:18:26,966 --> 00:18:29,286
This is what reflects
the header structure


398
00:18:29,866 --> 00:18:31,726
within the logical
Module structure.


399
00:18:33,046 --> 00:18:34,966
And finally, you can
see Autolinking here


400
00:18:34,966 --> 00:18:37,736
through the link framework
line here that says


401
00:18:37,806 --> 00:18:40,526
when you actually use the
UIKit Module, you should link


402
00:18:40,526 --> 00:18:41,816
against the UIKit framework.


403
00:18:42,996 --> 00:18:45,056
Now, these Module Maps
are actually very crucial


404
00:18:45,446 --> 00:18:48,836
because in our SDKs, we
don't ship Module binaries.


405
00:18:49,246 --> 00:18:51,766
Instead, we ship headers
like we always have.


406
00:18:51,766 --> 00:18:55,286
And when the compiler asks
for a Module, when you ask


407
00:18:55,286 --> 00:19:00,016
to @import UIKit, the compiler
will find the Module Map,


408
00:19:00,016 --> 00:19:01,486
it tells it how to build UIKit


409
00:19:01,486 --> 00:19:04,506
and effectively spawn a
separate compilation process


410
00:19:04,506 --> 00:19:08,896
to go separately compile
UIkit.h into the UIKit Module


411
00:19:09,206 --> 00:19:11,736
which is then cached in
Xcode's derived data.


412
00:19:12,216 --> 00:19:15,486
So the next time you come
through and ask to import UIKit,


413
00:19:15,676 --> 00:19:17,956
it's already there and
it's instantaneous to load.


414
00:19:18,336 --> 00:19:22,366
So this is what breaks the M
times N scalability problem


415
00:19:22,366 --> 00:19:24,416
down to actually
efficient compilation model.


416
00:19:24,416 --> 00:19:27,626
So let's take a quick look at
what this does to build times?


417
00:19:28,126 --> 00:19:31,016
So build times, of course, build
time for an entire project.


418
00:19:31,016 --> 00:19:32,666
And so, we'll talk about
a couple of projects


419
00:19:32,666 --> 00:19:35,896
at different scales and with
different levels of utilization


420
00:19:35,896 --> 00:19:37,476
of the precompiled
headers feature.


421
00:19:37,896 --> 00:19:41,046
So Xcode is a very, very
large Objective-C project,


422
00:19:41,306 --> 00:19:42,736
a lot going on in the build.


423
00:19:43,356 --> 00:19:45,806
And in fact, they've been
tuning their precompiled headers


424
00:19:45,806 --> 00:19:46,366
for years.


425
00:19:46,656 --> 00:19:48,436
And so, what we see when
we turn on Modules is


426
00:19:48,436 --> 00:19:50,706
that they don't have to change
their source code at all.


427
00:19:50,706 --> 00:19:51,706
It's just a build setting.


428
00:19:52,206 --> 00:19:53,706
And they get a smallish win,


429
00:19:53,706 --> 00:19:55,716
a couple of percent
win in the build time.


430
00:19:56,286 --> 00:19:58,336
Since they had optimized
precompiled headers,


431
00:19:58,336 --> 00:19:59,446
this isn't a huge surprise.


432
00:20:00,906 --> 00:20:05,816
Preview on the Mac is
actually a much smaller project


433
00:20:05,816 --> 00:20:06,606
as you might expect.


434
00:20:06,906 --> 00:20:11,046
Also, has fairly decent
precompiled header.


435
00:20:11,046 --> 00:20:14,006
And so, you get a small
win [inaudible] larger win


436
00:20:14,306 --> 00:20:15,366
out of using Modules.


437
00:20:15,366 --> 00:20:18,696
Again, no source code-- yeah--
source code changes required,


438
00:20:19,296 --> 00:20:21,176
so it's essentially a
free performance here.


439
00:20:21,876 --> 00:20:25,846
And finally, the Mail
Application on iOS didn't have


440
00:20:25,846 --> 00:20:26,606
such great use


441
00:20:26,606 --> 00:20:29,456
of the precompiled headers
'cause they hadn't been actively


442
00:20:29,456 --> 00:20:30,256
maintained, like most


443
00:20:30,256 --> 00:20:32,336
of all operators don't actively
maintained their precompiled


444
00:20:32,336 --> 00:20:35,786
headers and it's a huge
40 percent speed up just


445
00:20:35,786 --> 00:20:37,866
from flipping the
switch, turning on Modules


446
00:20:37,866 --> 00:20:40,036
and not doing anything
else, all right.


447
00:20:40,456 --> 00:20:41,656
This is the elimination


448
00:20:41,656 --> 00:20:44,256
of repeated header
processing really helping.


449
00:20:45,596 --> 00:20:48,456
So now, build times or
overall project build times,


450
00:20:48,716 --> 00:20:50,766
they're a little
bit messy in a sense


451
00:20:50,766 --> 00:20:52,336
that we're not really
just measuring what the


452
00:20:52,336 --> 00:20:52,926
compiler does.


453
00:20:52,926 --> 00:20:54,556
There's a whole lot of
other things going on.


454
00:20:55,216 --> 00:20:58,616
So, let's go to something
a little bit more heavy


455
00:20:58,616 --> 00:21:01,386
on the parsing and
that is indexing.


456
00:21:01,386 --> 00:21:03,786
When an Xcode is
indexing your project,


457
00:21:03,786 --> 00:21:06,766
it's parsing all the sources
in your project so it can build


458
00:21:06,766 --> 00:21:09,906
that rich cross reference
to give you more information


459
00:21:09,906 --> 00:21:11,126
at your fingertips
within the IDE.


460
00:21:11,126 --> 00:21:15,636
And so if we take these
same projects, indexing time


461
00:21:15,636 --> 00:21:17,496
for Xcode got a bit faster,


462
00:21:17,496 --> 00:21:20,496
we're in the seven
percent range or so.


463
00:21:21,476 --> 00:21:24,716
Preview on the other hand got
pretty significantly faster,


464
00:21:24,716 --> 00:21:27,526
so 32 percent faster
indexing time just


465
00:21:27,526 --> 00:21:28,846
from switching to Modules.


466
00:21:29,986 --> 00:21:32,556
And iOS Mail, as you may have
seen earlier this morning,


467
00:21:32,866 --> 00:21:36,486
got 2.3 times faster
indexing just


468
00:21:36,486 --> 00:21:37,796
from doing the switch
to Modules.


469
00:21:40,016 --> 00:21:42,036
Hopefully, at this
point, I've convinced you,


470
00:21:42,036 --> 00:21:45,176
you should at least try out
Modules, fairly easy to do.


471
00:21:45,176 --> 00:21:47,696
So if you start a new
project in Xcode 5,


472
00:21:47,696 --> 00:21:49,316
Modules are enabled by default.


473
00:21:49,316 --> 00:21:52,106
We really thinking this is the
way forward for Objective-C


474
00:21:52,266 --> 00:21:54,536
to get access to
system frameworks.


475
00:21:54,786 --> 00:21:58,096
If you have an existing
project, to covert it Modules,


476
00:21:58,096 --> 00:22:01,186
just go into your Build Settings
and find the Module Setting,


477
00:22:01,456 --> 00:22:02,996
change it to Yes
and then Rebuild.


478
00:22:02,996 --> 00:22:04,586
Nothing else is needed.


479
00:22:05,756 --> 00:22:08,426
Now, if you're doing some
fancy linking tricks,


480
00:22:09,106 --> 00:22:11,406
you may actually want to turn
off the Autolinking feature


481
00:22:11,956 --> 00:22:13,816
in which case there is
a separate option here


482
00:22:13,816 --> 00:22:16,046
where you can turn off
the Autolinking feature.


483
00:22:16,286 --> 00:22:20,076
Most users shouldn't
actually need to do this.


484
00:22:20,286 --> 00:22:22,576
As you may expect, there's
a couple of caveats.


485
00:22:22,576 --> 00:22:26,706
So, first caveat, you
need to be using the iOS 7


486
00:22:26,826 --> 00:22:28,416
or OS X Mavericks SDK.


487
00:22:28,416 --> 00:22:30,806
Only those SDKs have
support for Modules.


488
00:22:31,146 --> 00:22:32,986
Now, of course, you
can deploy backward


489
00:22:33,396 --> 00:22:35,886
because you can use the new
SDK and deploy backward.


490
00:22:36,146 --> 00:22:39,316
Modules don't change how
your code is actually built.


491
00:22:39,316 --> 00:22:40,836
They don't change
for your source code.


492
00:22:40,836 --> 00:22:42,336
They don't change how
your code is built.


493
00:22:42,336 --> 00:22:45,736
You just need to move to
the newer SDK to get those--


494
00:22:45,796 --> 00:22:46,936
essentially the Module Maps


495
00:22:47,316 --> 00:22:50,356
that tell the Module
system how to work.


496
00:22:50,536 --> 00:22:54,416
Second point is that
Modules aren't available C++.


497
00:22:54,736 --> 00:22:58,656
Now, it's perfectly fine to
enable Modules in a C++ project.


498
00:22:58,946 --> 00:23:01,836
Essentially, the fact that you
requested Modules will just be


499
00:23:01,836 --> 00:23:05,176
ignored for the C++ sources,
you'll still get the benefits


500
00:23:05,176 --> 00:23:07,146
of Modules for your
Objective-C sources.


501
00:23:07,756 --> 00:23:10,386
The only downside here is you
can't use the fancy new @import


502
00:23:10,386 --> 00:23:12,096
syntax in something
that's shared


503
00:23:12,546 --> 00:23:16,066
between C++ and non-C++ code.


504
00:23:16,276 --> 00:23:19,206
And finally, while Modules
are available for all


505
00:23:19,206 --> 00:23:22,986
of the system frameworks,
on iOS and the Mac,


506
00:23:22,986 --> 00:23:24,686
they're not available
for user frameworks.


507
00:23:26,116 --> 00:23:28,676
So, let's wrap up here.


508
00:23:29,596 --> 00:23:32,176
We talked about this
new feature, Modules.


509
00:23:32,696 --> 00:23:35,826
The idea behind Modules is to
simplify the user frameworks


510
00:23:35,826 --> 00:23:39,896
so you can just get the nice
semantic import behavior


511
00:23:40,326 --> 00:23:41,516
which is much harder to break


512
00:23:41,586 --> 00:23:44,766
than the textual inclusion
behavior that would, so--


513
00:23:44,766 --> 00:23:47,816
and this means we've essentially
eliminated all of the problems


514
00:23:47,816 --> 00:23:50,246
with strange header
order dependencies


515
00:23:50,246 --> 00:23:52,556
between system frameworks
and user code,


516
00:23:54,166 --> 00:23:57,946
and we've eliminated the
separate link with library step


517
00:23:57,946 --> 00:24:00,426
through the Autolinking
feature of Modules.


518
00:24:01,696 --> 00:24:04,096
Now, Modules are
actually a lot more


519
00:24:04,096 --> 00:24:05,646
than just a user convenience.


520
00:24:06,226 --> 00:24:09,196
We're actually fundamentally
changing the underlying model


521
00:24:09,196 --> 00:24:11,916
and how we can access
to APIs in a way


522
00:24:11,916 --> 00:24:15,076
that can significantly improve
the performance of source tools.


523
00:24:15,416 --> 00:24:17,056
And the very nice thing here is


524
00:24:17,056 --> 00:24:19,176
that improvement
essentially comes for free.


525
00:24:19,496 --> 00:24:21,546
You no longer have to tweak
your precompiled header


526
00:24:21,546 --> 00:24:22,526
to get the build times.


527
00:24:22,826 --> 00:24:25,476
Just use Modules and forget
about the precompiled header,


528
00:24:25,716 --> 00:24:27,396
Modules will do the right thing.


529
00:24:28,616 --> 00:24:31,886
And finally, you can enable
this feature without any changes


530
00:24:31,886 --> 00:24:33,156
to your source code, whatsoever.


531
00:24:33,226 --> 00:24:36,186
It's changing your Build Setting
and rebuilding your application.


532
00:24:36,456 --> 00:24:37,436
The application doesn't change.


533
00:24:37,436 --> 00:24:38,496
Your source code doesn't change.


534
00:24:39,936 --> 00:24:42,346
So with that, I'd like to
turn you over to my colleague,


535
00:24:42,346 --> 00:24:44,886
Dave Zarzycki to talk about
advances in Objective-C.


536
00:24:44,886 --> 00:24:45,446
[applause]


537
00:24:45,446 --> 00:24:47,516
>> All right.


538
00:24:48,066 --> 00:24:48,556
Thanks, Doug.


539
00:24:51,396 --> 00:24:53,796
So I'm going to be talking
to you about more advances


540
00:24:53,796 --> 00:24:56,536
in Objective-C, some
recent, some new.


541
00:24:57,336 --> 00:24:59,146
So, I'm going to be
starting off talking


542
00:24:59,146 --> 00:25:00,216
about better productivity.


543
00:25:00,216 --> 00:25:01,986
We're going to be
talking about tool support


544
00:25:01,986 --> 00:25:03,236
for modernizing your code.


545
00:25:03,236 --> 00:25:05,576
We'll be talking about
improvements in the SDK


546
00:25:05,576 --> 00:25:08,146
and how they make your life
better and more productive


547
00:25:08,146 --> 00:25:09,066
and generate better code.


548
00:25:09,066 --> 00:25:12,466
And we'll be talking
about block return safety


549
00:25:12,556 --> 00:25:13,926
and catching some common errors.


550
00:25:14,436 --> 00:25:16,196
And then we'll be talking
about the runtime in your code.


551
00:25:16,196 --> 00:25:19,886
And then, for the rest of
the talk, we'll be talking


552
00:25:19,886 --> 00:25:21,216
about Automatic Reference
Counting.


553
00:25:21,296 --> 00:25:24,486
We'll be talking about
updates we've made to it


554
00:25:24,486 --> 00:25:26,576
and we've been talking--
we'll talk about improvements


555
00:25:26,616 --> 00:25:28,206
in generating better warnings


556
00:25:28,206 --> 00:25:29,716
that help you generate
more correct code.


557
00:25:30,476 --> 00:25:32,386
So with that, let's
jump in and talk


558
00:25:32,386 --> 00:25:34,136
about Tools Support
for Modernization.


559
00:25:35,066 --> 00:25:38,336
Something we did recently
was adding a Refactoring Tool


560
00:25:38,386 --> 00:25:39,716
to modernize your code.


561
00:25:40,676 --> 00:25:42,516
It's found right
here in the Edit Menu


562
00:25:42,656 --> 00:25:45,956
under the Refactoring
Submenu and you just convert


563
00:25:45,956 --> 00:25:48,506
to the Modern Objective-C
Syntax.


564
00:25:49,546 --> 00:25:50,736
So what does this do?


565
00:25:50,976 --> 00:25:54,336
Well, it reduces a ton of
boilerplate in your code.


566
00:25:54,336 --> 00:25:57,756
We have object-- more object
literals, container literals.


567
00:25:58,246 --> 00:25:59,936
We have improved subscripting.


568
00:26:00,536 --> 00:26:01,596
And this is covered in-depth


569
00:26:01,596 --> 00:26:03,036
at last year's version
of this talk.


570
00:26:04,416 --> 00:26:05,806
So let's look at
the example of this.


571
00:26:05,946 --> 00:26:08,236
Here is an example of one of
my favorite jazz musicians.


572
00:26:09,436 --> 00:26:12,046
Now, we do have literals.


573
00:26:12,046 --> 00:26:12,736
We have string literals.


574
00:26:12,796 --> 00:26:13,846
We have a lot of other things.


575
00:26:13,846 --> 00:26:15,406
We need to remember how
to create a dictionary.


576
00:26:15,406 --> 00:26:17,506
What factory method to call?


577
00:26:17,866 --> 00:26:21,146
We need to remember the order
of the keys and the objects.


578
00:26:21,586 --> 00:26:23,856
We need to remember that
they have to be objects.


579
00:26:23,986 --> 00:26:26,246
And we have to remember to
nil-terminate this list.


580
00:26:26,916 --> 00:26:28,846
And similarly for NSArray,


581
00:26:28,846 --> 00:26:30,716
we have to remember the
right factory method to call.


582
00:26:30,796 --> 00:26:33,256
And like NSDictionary, we need


583
00:26:33,256 --> 00:26:34,496
to remember the nil-terminate
it.


584
00:26:35,866 --> 00:26:38,166
Similarly, NSNumber
has the same problem.


585
00:26:39,366 --> 00:26:41,646
We need to remember the
right factory method to call.


586
00:26:41,646 --> 00:26:42,276
Is that an end?


587
00:26:42,276 --> 00:26:43,456
Is it a long?


588
00:26:43,456 --> 00:26:45,106
Is it a short?


589
00:26:45,106 --> 00:26:47,466
We need to remember
the right one for Bool.


590
00:26:48,056 --> 00:26:50,726
There's a lot of opportunity
here to reduce boilerplate.


591
00:26:51,666 --> 00:26:55,256
Well, with the Refactoring Tool,
you can adopt the modern syntax.


592
00:26:55,736 --> 00:26:58,126
Dictionary literals just
become @, curly brace.


593
00:26:58,596 --> 00:27:01,916
Array literals become
@ square bracket.


594
00:27:03,026 --> 00:27:06,136
The compiler helps you remember
keys and values and the fact


595
00:27:06,136 --> 00:27:07,266
that they have to be objects.


596
00:27:07,836 --> 00:27:10,036
You don't need to worry about
nil terminating the list.


597
00:27:10,106 --> 00:27:13,436
And similarly, for NSNumber,
you don't need to worry


598
00:27:13,436 --> 00:27:14,546
about what type it is anymore.


599
00:27:14,546 --> 00:27:17,826
You can just say @
number or @ yes or @ no.


600
00:27:17,826 --> 00:27:21,046
So this is a huge simplification
and we have tools to help you


601
00:27:21,046 --> 00:27:23,556
about the syntax so you can
focus on writing great code


602
00:27:23,556 --> 00:27:26,046
and sweeping away the details.


603
00:27:27,876 --> 00:27:30,386
Similarly, we can consider
containers before the


604
00:27:30,386 --> 00:27:31,416
modern syntax.


605
00:27:32,276 --> 00:27:34,966
Throughout your code, you work
with containers and you have


606
00:27:35,026 --> 00:27:37,196
to write this code repeatedly.


607
00:27:37,196 --> 00:27:40,236
You have to remember
if in the case--


608
00:27:40,266 --> 00:27:43,506
whether the key comes first
or the object comes first,


609
00:27:44,056 --> 00:27:46,976
it's just a lot of boilerplate
that could be simplified.


610
00:27:47,976 --> 00:27:49,876
Well, with modern
syntax, you can do that.


611
00:27:50,506 --> 00:27:53,966
You can use common subscripting
syntax that's available


612
00:27:53,966 --> 00:27:56,676
in a variety of languages
to access containers


613
00:27:56,676 --> 00:27:59,296
in the modern SDK and
the modern syntax.


614
00:27:59,816 --> 00:28:03,766
Now, there's a ton more to
modern syntax that I'm not going


615
00:28:03,766 --> 00:28:05,176
to cover here and
I strongly suggest


616
00:28:05,176 --> 00:28:06,346
that you watch last year's talk.


617
00:28:07,266 --> 00:28:09,726
We have boxed expressions
via @ parenthesis.


618
00:28:10,786 --> 00:28:14,456
We have the full intersection
with C types if you want


619
00:28:14,456 --> 00:28:17,476
to understand how they work,
like shorts and chars and longs


620
00:28:17,476 --> 00:28:18,466
and unsigned behavior.


621
00:28:19,736 --> 00:28:24,016
We have-- we teach you how
to implement subscripting


622
00:28:24,016 --> 00:28:27,786
for your own classes and you can
see this on last year's version


623
00:28:27,936 --> 00:28:31,056
of this talk, number
four or five.


624
00:28:31,926 --> 00:28:35,276
So with that, I'd like to
jump into SDK improvements


625
00:28:35,446 --> 00:28:37,616
and how they will
improve your productivity.


626
00:28:38,686 --> 00:28:42,116
So the SDK is constantly
leveraging the compiler.


627
00:28:42,116 --> 00:28:43,486
It's adopting new features.


628
00:28:43,876 --> 00:28:47,026
It's helping you write more
correct code, safer code,


629
00:28:47,546 --> 00:28:50,836
and get better compiled time
error detection and problems


630
00:28:50,836 --> 00:28:51,846
that you might be running into.


631
00:28:52,846 --> 00:28:55,186
And specifically, I'd like
to call out two features


632
00:28:55,186 --> 00:28:57,756
that the new SDKs have adopted


633
00:28:57,806 --> 00:29:00,676
that will affect
potentially your experience


634
00:29:00,676 --> 00:29:03,806
and help you write better code.


635
00:29:04,026 --> 00:29:06,186
And specifically, where there--


636
00:29:06,836 --> 00:29:09,956
instancetype keyword and
explicitly-typed enums.


637
00:29:11,086 --> 00:29:12,866
So let's jump in and
consider with that is.


638
00:29:14,236 --> 00:29:16,786
Now, some of you probably
can look at this code


639
00:29:16,896 --> 00:29:18,006
and already see the bug.


640
00:29:18,806 --> 00:29:20,916
We're taking an NSArray
and we're assigning it


641
00:29:20,916 --> 00:29:22,976
to an NSDictionary variable.


642
00:29:22,976 --> 00:29:24,386
That's terrible.


643
00:29:24,866 --> 00:29:27,766
But, copy and paste
errors are easy.


644
00:29:28,676 --> 00:29:30,586
Refactoring are easy.


645
00:29:31,236 --> 00:29:35,346
And in fact, now with the
SDKs worshipping this,


646
00:29:35,486 --> 00:29:39,376
you will actually get a warning
pointing out the problem.


647
00:29:40,636 --> 00:29:42,926
So how is it that the compiler
knows if we have a problem?


648
00:29:43,746 --> 00:29:45,256
When previous versions
of the SDK,


649
00:29:45,256 --> 00:29:48,876
array and many similar
APIs returned IDE.


650
00:29:49,676 --> 00:29:52,516
The problem is that IDE
implicitly converts to anything,


651
00:29:52,556 --> 00:29:54,746
so the compiler didn't
historically know


652
00:29:54,746 --> 00:29:56,346
that there was a problem here.


653
00:29:57,826 --> 00:30:01,146
In the new SDK, array
returns instancetype.


654
00:30:02,176 --> 00:30:03,946
This is a contextual keyword.


655
00:30:04,896 --> 00:30:06,796
It's only for return types.


656
00:30:07,286 --> 00:30:12,066
And subclasses don't need
to redeclare array here


657
00:30:12,066 --> 00:30:14,786
to expose the fact that
they're returning an instance


658
00:30:14,866 --> 00:30:16,656
of their subclass.


659
00:30:17,156 --> 00:30:20,446
And finally, the compiler
contextually matches the return


660
00:30:20,446 --> 00:30:21,756
type to that other receiver.


661
00:30:23,056 --> 00:30:24,306
Okay, well what does that mean?


662
00:30:25,016 --> 00:30:27,506
Let's consider our
subclassing NSArray.


663
00:30:27,646 --> 00:30:29,516
And let's say we create
a class name Foobar.


664
00:30:30,116 --> 00:30:31,596
We don't do anything more.


665
00:30:31,596 --> 00:30:33,036
We just put in @end.


666
00:30:33,226 --> 00:30:37,526
And what happens in this code
now that we're taking a Foobar


667
00:30:37,526 --> 00:30:40,726
and calling array and this
signage NSDictionary variable?


668
00:30:40,726 --> 00:30:44,606
Well, the compiler would still
print out the warning, great.


669
00:30:45,866 --> 00:30:47,476
But I'd like to point out is


670
00:30:47,476 --> 00:30:49,836
that the compiler is
contextually taking the receive


671
00:30:49,836 --> 00:30:53,706
type Foobar and printing
out the warning pointing


672
00:30:53,706 --> 00:30:55,696
out that the return
value is also a Foobar,


673
00:30:55,696 --> 00:30:57,156
and that's the source
of the problem.


674
00:30:58,246 --> 00:30:59,926
So that's the instancetype
keyword.


675
00:31:00,776 --> 00:31:04,206
Next up, I'd like to talk
about explicitly-typed enum.


676
00:31:04,206 --> 00:31:07,886
Another feature that the SDK
has adopted that will show


677
00:31:07,886 --> 00:31:09,946
up in your code and help
you detect more errors


678
00:31:10,036 --> 00:31:10,946
and be more productive.


679
00:31:12,386 --> 00:31:14,356
So let's look at this code.


680
00:31:15,016 --> 00:31:16,446
Some of you that have experience


681
00:31:16,446 --> 00:31:19,106
with URLs may already
see the bug.


682
00:31:19,966 --> 00:31:22,266
These are not the same enum.


683
00:31:23,166 --> 00:31:26,016
We have an NSURLHandleStatus
on the left.


684
00:31:26,456 --> 00:31:29,086
We have an NSURLSessionTaskState
on the right.


685
00:31:29,986 --> 00:31:34,326
Whoops. Well, again, copy
and paste errors are easy


686
00:31:35,126 --> 00:31:36,736
and refactoring errors
are really easy.


687
00:31:37,646 --> 00:31:40,266
And the reason this is used
to compile in the past is


688
00:31:40,266 --> 00:31:43,276
that enums are essentially
just global integers.


689
00:31:43,276 --> 00:31:45,296
So, we're just assigning
one number to another.


690
00:31:46,476 --> 00:31:51,416
Well now, with the SDKs, you
will get a warning pointing


691
00:31:51,416 --> 00:31:53,366
out that these are
of different types


692
00:31:53,456 --> 00:31:54,666
which is exactly what you want.


693
00:31:54,666 --> 00:31:58,396
So how does the compiler know?


694
00:31:59,446 --> 00:32:01,756
In the past, we declared
enums like this.


695
00:32:02,576 --> 00:32:05,536
In one line, we would declare
the enum and enumerate,


696
00:32:05,966 --> 00:32:08,016
you know, ABC, JKL, XYZ.


697
00:32:08,016 --> 00:32:12,396
And the next line, we
declare a typedef where we say


698
00:32:12,396 --> 00:32:17,066
that what the storage is
and then give it a name.


699
00:32:17,066 --> 00:32:21,126
Well, this is where the
first line is just mint.


700
00:32:21,286 --> 00:32:24,466
We haven't actually bound the
two pieces of information here.


701
00:32:26,736 --> 00:32:28,706
And how we fixed this in the SDK


702
00:32:28,706 --> 00:32:31,046
and with the compiler is the
compiler supports a new feature


703
00:32:31,046 --> 00:32:32,766
for explicitly-typed enums.


704
00:32:33,286 --> 00:32:34,016
What you can see here


705
00:32:34,016 --> 00:32:37,266
on the first line is we've
actually moved the storage up


706
00:32:37,266 --> 00:32:39,476
and now the enum knows
what its storage type is


707
00:32:39,476 --> 00:32:42,306
and then now it's no longer
an int, it's an NSUInteger.


708
00:32:42,306 --> 00:32:46,806
Now in the next line,
we actually bind or enum


709
00:32:46,806 --> 00:32:49,126
to a type available for use.


710
00:32:49,796 --> 00:32:53,126
This is all covered last year
in-depth and this version--


711
00:32:53,256 --> 00:32:54,546
in this talk last year.


712
00:32:56,036 --> 00:32:59,346
Now, the Cocoa team have
provided convenient macros


713
00:32:59,456 --> 00:33:00,716
that exposed this feature.


714
00:33:00,996 --> 00:33:04,056
We have NS Enum for a
traditional enumerations,


715
00:33:04,056 --> 00:33:05,326
like we just demonstrated.


716
00:33:06,036 --> 00:33:07,696
You know, ABC, JKL, XYZ.


717
00:33:07,696 --> 00:33:11,826
And they also have a
convenient macro for NS Options.


718
00:33:12,686 --> 00:33:16,756
So, a bit wise operations,
like, you know, different flags.


719
00:33:17,336 --> 00:33:21,416
So I recommend the use of these
macros and you'll see them


720
00:33:21,416 --> 00:33:22,536
in the system frameworks.


721
00:33:24,146 --> 00:33:26,646
But we don't stop
with just warnings.


722
00:33:27,166 --> 00:33:30,816
We also improved code
completion with NS Enum


723
00:33:30,816 --> 00:33:32,146
and explicitly-typed enums.


724
00:33:33,236 --> 00:33:37,186
So before NS Enum, if you tried


725
00:33:37,186 --> 00:33:40,806
to code complete our
example enumeration here


726
00:33:40,806 --> 00:33:45,086
and you typed X, you would see
a bunch of XPC-related APIs


727
00:33:45,086 --> 00:33:46,976
and you wouldn't see your enum.


728
00:33:47,456 --> 00:33:48,396
That's not fun.


729
00:33:49,356 --> 00:33:52,756
Well, if we just switch to
the NS Enum macro and then get


730
00:33:52,756 --> 00:33:53,886
up the compiler feature,


731
00:33:53,886 --> 00:33:55,966
Code Completion gives
us exactly what we want


732
00:33:56,656 --> 00:33:58,736
and we see our enumeration
available


733
00:33:58,736 --> 00:33:59,936
in Code Completion
which is great.


734
00:34:00,426 --> 00:34:04,326
But it just doesn't--
it doesn't stop there.


735
00:34:04,476 --> 00:34:08,376
The power of explicitly-typed
enums manifest in multiple ways.


736
00:34:09,536 --> 00:34:12,476
So in this particular
case, we have an NSArray


737
00:34:12,476 --> 00:34:17,025
that we're trying to
sort using a comparator.


738
00:34:17,116 --> 00:34:19,025
And we do some logic
and then we decide


739
00:34:19,025 --> 00:34:20,666
to return ascending
or descending.


740
00:34:21,646 --> 00:34:22,456
Now if you look closely,


741
00:34:22,456 --> 00:34:24,956
we actually haven't specified
the return type of this block


742
00:34:24,956 --> 00:34:26,946
between the caret and
the opening parenthesis.


743
00:34:27,525 --> 00:34:32,156
And the compiler would actually
give us an error saying that,


744
00:34:32,226 --> 00:34:35,735
"Well, we infer the type of
this block as returning int


745
00:34:35,735 --> 00:34:42,005
but the API actually takes
NS-- comparison result."


746
00:34:42,005 --> 00:34:44,025
All right.


747
00:34:44,676 --> 00:34:46,146
Well, how do we fix this?


748
00:34:46,706 --> 00:34:50,116
Before explicitly-typed
enums, we have the Cast, thus,


749
00:34:50,556 --> 00:34:51,866
assigning the correct type.


750
00:34:53,146 --> 00:34:54,896
And yes, this would
make the warning go away


751
00:34:54,896 --> 00:34:57,366
but now we have this lingering
cast in our code that, you know,


752
00:34:57,406 --> 00:34:58,956
could create future problems.


753
00:34:59,266 --> 00:35:01,686
Because the explicitly-typed
enums allow us to fix this


754
00:35:01,686 --> 00:35:04,146
and make the enum how
many explicit-type,


755
00:35:05,216 --> 00:35:08,186
we can help you avoid casting
and in fact you can now go


756
00:35:08,266 --> 00:35:09,646
and delete these
casts and go back


757
00:35:09,646 --> 00:35:11,966
to the natural looking
code you wanted to have


758
00:35:11,996 --> 00:35:14,506
in the first place and
write it as intended.


759
00:35:16,776 --> 00:35:19,526
Digging deeper on what
NS Enum can do for you,


760
00:35:20,046 --> 00:35:21,666
let's consider the fact


761
00:35:21,666 --> 00:35:24,806
of how implicitly-typed enums
can manifest in different ways.


762
00:35:25,396 --> 00:35:27,396
Again, before explicitly-typed
enums,


763
00:35:27,456 --> 00:35:30,506
these two URL-related enums


764
00:35:30,506 --> 00:35:33,486
that are actually different
were just ints as far


765
00:35:33,486 --> 00:35:35,226
as the compiler was concerned.


766
00:35:36,746 --> 00:35:39,636
And this manifested as a
silent bug in your code.


767
00:35:40,296 --> 00:35:42,966
Now with NS Enum, you get
the warning that you want


768
00:35:43,106 --> 00:35:46,266
and now you have to
decide how to fix the code.


769
00:35:46,266 --> 00:35:48,256
Now, here, this is pointing
out a design problem


770
00:35:48,256 --> 00:35:49,716
so that there is
no quick solution.


771
00:35:49,716 --> 00:35:51,646
You'd have to think about
it and actually figure


772
00:35:51,646 --> 00:35:52,796
out what you originally
intended.


773
00:35:53,306 --> 00:35:56,536
So with that, now
I'd like to move


774
00:35:56,536 --> 00:35:59,216
on to the Objective-C
Runtime and you.


775
00:35:59,216 --> 00:36:02,806
The Objective-C Runtime is
the core of the language.


776
00:36:03,406 --> 00:36:05,816
It enables a ton of
dynamic behavior.


777
00:36:05,816 --> 00:36:10,286
We have, you know, of course,
dynamic method dispatch.


778
00:36:10,736 --> 00:36:12,296
We have object introspection.


779
00:36:12,826 --> 00:36:14,846
We have object proxies.


780
00:36:15,066 --> 00:36:16,686
And we have dynamic
class construction,


781
00:36:16,686 --> 00:36:18,306
even a dynamic method
replacement.


782
00:36:20,056 --> 00:36:23,596
The runtime enables a ton of
innovation in the language.


783
00:36:24,336 --> 00:36:26,666
We've added many
features over the years


784
00:36:26,666 --> 00:36:28,546
and it's really the heart
of all these features.


785
00:36:29,646 --> 00:36:32,646
So to give you an example, we've
added a new key-value observing,


786
00:36:32,646 --> 00:36:38,326
associated objects, we've added
@synchronized to do locking,


787
00:36:38,936 --> 00:36:41,786
we've added weak references,
we've added tagged pointers,


788
00:36:41,786 --> 00:36:44,236
and the list go on, on and on.


789
00:36:44,286 --> 00:36:46,466
I'd like to actually call
out tagged pointers though


790
00:36:46,466 --> 00:36:50,006
because we have some new
warnings to enable innovation.


791
00:36:51,006 --> 00:36:54,036
So, let's first dive deep
and ask the question,


792
00:36:54,036 --> 00:36:55,136
what are tagged pointers?


793
00:36:56,006 --> 00:37:00,936
They were added in 64-bit Cocoa
for a small value-like objects.


794
00:37:01,006 --> 00:37:03,336
And examples of a
value-like objects are


795
00:37:03,336 --> 00:37:06,576
like NSNumber, NSDate,
just values.


796
00:37:07,436 --> 00:37:11,416
What we're doing is we're
actually storing the object


797
00:37:11,416 --> 00:37:13,696
in the pointer itself,
so we don't actually need


798
00:37:13,696 --> 00:37:15,066
to call malloc or free.


799
00:37:15,066 --> 00:37:18,456
And when you don't call
malloc or free, you could've--


800
00:37:19,056 --> 00:37:21,976
code gets a ton faster and
it's more space efficient.


801
00:37:22,066 --> 00:37:23,936
It's three times more
space efficient and it's


802
00:37:23,936 --> 00:37:25,506
over 100 times faster
to allocate


803
00:37:25,506 --> 00:37:27,446
and deallocate these
small value-like objects.


804
00:37:28,856 --> 00:37:31,636
Okay, it's great in theory
but I'm a visual person.


805
00:37:31,636 --> 00:37:32,896
Show me how this actually works.


806
00:37:34,116 --> 00:37:35,066
In a normal pointer,


807
00:37:35,436 --> 00:37:37,856
we're actually only
using the top 60 bits.


808
00:37:38,186 --> 00:37:40,616
The bottom four bits of
a pointer are always zero


809
00:37:40,616 --> 00:37:42,476
because objects are
always 16-byte aligned.


810
00:37:43,056 --> 00:37:45,376
We can take advantage
of this fact


811
00:37:45,376 --> 00:37:49,206
to implement what we call tagged
pointers where we actually store


812
00:37:49,206 --> 00:37:52,146
in the bottom bit discriminators
and when it's one,


813
00:37:52,466 --> 00:37:54,886
we can actually store a ton of
data in the rest of the bits.


814
00:37:55,306 --> 00:37:58,076
And this is in fact what we do.


815
00:37:58,286 --> 00:38:01,686
Having said all this, this
is an implementation detail.


816
00:38:02,116 --> 00:38:03,876
Some of you have
discovered this feature


817
00:38:03,876 --> 00:38:05,116
and we need you to
undiscover it.


818
00:38:05,966 --> 00:38:10,616
[laughter] The runtime
details are private.


819
00:38:10,616 --> 00:38:13,616
And in fact, what
remaining little tidbits


820
00:38:13,616 --> 00:38:15,756
of data structures you're
finding that are still public


821
00:38:15,756 --> 00:38:17,596
in the data structures
are becoming private.


822
00:38:18,796 --> 00:38:21,926
Most URI-- applications
are well behaved


823
00:38:21,926 --> 00:38:24,256
and we thank you for that.


824
00:38:24,256 --> 00:38:26,176
Use APIs to instropect things


825
00:38:26,776 --> 00:38:28,556
and this lets us
innovate considerably


826
00:38:28,556 --> 00:38:29,596
as we've already described.


827
00:38:30,206 --> 00:38:34,866
But we've added some new
warnings to detect the use


828
00:38:34,866 --> 00:38:39,036
of tagged pointers and a related
problem of Raw 'isa' access.


829
00:38:40,416 --> 00:38:43,896
So, you might have code
like this in your program


830
00:38:44,026 --> 00:38:46,836
where you're testing the tag bit
and then you are like, "Great,


831
00:38:47,036 --> 00:38:50,256
I have discovered the tag bit
isn't set, I'm just going to run


832
00:38:50,256 --> 00:38:53,196
in there and just access
the isa directly and--


833
00:38:53,546 --> 00:38:55,696
because I'm think I'm
optimizing, this is fun."


834
00:38:56,506 --> 00:38:58,446
But in the case when
the tag bit is set,


835
00:38:58,446 --> 00:38:59,796
you actually called
the correct API.


836
00:39:01,326 --> 00:39:04,556
Well now, you're going to get a
warning for that tag bit check.


837
00:39:05,636 --> 00:39:06,936
And you're actually
going to get an error


838
00:39:06,936 --> 00:39:08,626
for the direct usage of the isa.


839
00:39:09,836 --> 00:39:10,916
Well how do you fix this?


840
00:39:11,576 --> 00:39:14,316
You delete the testing of that
bit and direct that access


841
00:39:14,316 --> 00:39:15,846
to the isa and you actually call


842
00:39:15,846 --> 00:39:18,816
like it isKindOfClass
or object getClass.


843
00:39:19,866 --> 00:39:21,126
We really need you to do this


844
00:39:21,126 --> 00:39:22,926
so we can unlock the
next level of innovation.


845
00:39:23,336 --> 00:39:25,726
And failure to do so, might
break your code in the future.


846
00:39:25,876 --> 00:39:28,466
So please, heed these warnings
and errors in your code


847
00:39:28,806 --> 00:39:30,386
and do the right thing.


848
00:39:31,476 --> 00:39:32,506
Thank you.


849
00:39:32,726 --> 00:39:35,706
Finally on the runtime part
of this talk, I'd like to talk


850
00:39:35,706 --> 00:39:36,806
about Garbage Collection.


851
00:39:38,096 --> 00:39:40,186
GC only exists on the Mac.


852
00:39:41,026 --> 00:39:42,176
We have replaced it with ARC


853
00:39:43,126 --> 00:39:47,216
and in fact we deprecated
Garbage Collection as of 10.8.


854
00:39:48,376 --> 00:39:50,006
We're very serious about this.


855
00:39:50,186 --> 00:39:52,566
We're not supporting Garbage
Collection in new frameworks,


856
00:39:52,606 --> 00:39:55,726
things like AVKit or Accounts
or GameController or GameKit,


857
00:39:56,736 --> 00:39:59,626
et cetera, et cetera, we're not
supporting Garbage Collection.


858
00:40:01,176 --> 00:40:03,686
We really need you to
use the ARC Migrator


859
00:40:03,686 --> 00:40:05,866
to transition off GC.


860
00:40:06,676 --> 00:40:09,866
So with that, let's talk about
Automatic Reference Counting


861
00:40:10,276 --> 00:40:13,006
and tell you about updates we've
been doing and some improvements


862
00:40:13,226 --> 00:40:15,276
to help you write better code.


863
00:40:16,706 --> 00:40:18,346
Let's start with the updates.


864
00:40:19,306 --> 00:40:22,636
Cocoa is designed with reference
counting semantics in mind.


865
00:40:22,936 --> 00:40:23,696
This is great.


866
00:40:24,136 --> 00:40:26,016
Being able to deterministically
know


867
00:40:26,016 --> 00:40:27,706
when an object is
destroyed allows you


868
00:40:27,706 --> 00:40:28,996
to better reason
about your code.


869
00:40:29,546 --> 00:40:31,066
It allows you to
better schedule things.


870
00:40:31,066 --> 00:40:32,536
It allows you to better design.


871
00:40:32,536 --> 00:40:34,266
And it's also just
great for debugging.


872
00:40:34,966 --> 00:40:38,296
ARC also helps you
write great code.


873
00:40:38,296 --> 00:40:42,026
It allows you to focus on what
matters and not the minutia


874
00:40:42,026 --> 00:40:45,986
of details of when things
need to be released.


875
00:40:47,256 --> 00:40:51,726
The majority of new App Store
submissions are using ARC.


876
00:40:51,726 --> 00:40:54,776
So a lot of you also agree that
this is a really great tool


877
00:40:54,776 --> 00:40:56,086
for focusing on what matters.


878
00:40:57,736 --> 00:41:01,236
Specific-- another great
example of ARC is Xcode 5.0.


879
00:41:01,716 --> 00:41:03,626
This used to be a GC app.


880
00:41:04,266 --> 00:41:05,266
It was a large app.


881
00:41:06,006 --> 00:41:07,596
Nevertheless, we were
able to convert it


882
00:41:07,596 --> 00:41:08,906
to Automatic Reference Counting


883
00:41:08,966 --> 00:41:10,506
and we're thrilled
with the results.


884
00:41:11,486 --> 00:41:13,226
We're thrilled with
the better determinism.


885
00:41:13,526 --> 00:41:14,786
We love the better debugging.


886
00:41:14,956 --> 00:41:17,426
We love that we're able to offer
tons of better performance.


887
00:41:17,936 --> 00:41:20,996
And we hope that you'll
find the same experience.


888
00:41:20,996 --> 00:41:25,486
Speaking of performance,
we are continuing


889
00:41:25,486 --> 00:41:27,476
to improve the performance
of ARC.


890
00:41:27,876 --> 00:41:30,146
Weak references are
now about twice as fast


891
00:41:30,276 --> 00:41:31,456
and this year's version


892
00:41:31,516 --> 00:41:34,906
of our operating system
iOS 7 and 10.9 for the Mac.


893
00:41:36,316 --> 00:41:39,246
And we're also improving the
debug experience as well.


894
00:41:39,366 --> 00:41:41,946
We have more predictable memory
usage under debug builds.


895
00:41:42,636 --> 00:41:44,376
Specifically, the lifetime


896
00:41:44,376 --> 00:41:47,156
of autoreleased objects is
much more like released builds.


897
00:41:48,586 --> 00:41:49,996
Now when you autorelease
an object,


898
00:41:49,996 --> 00:41:51,696
you don't necessarily
know when it goes away.


899
00:41:52,066 --> 00:41:54,926
And in fact, ARC
optimizations could kick in


900
00:41:54,926 --> 00:41:56,046
and change that timing.


901
00:41:56,736 --> 00:41:58,266
We've improved the compilers


902
00:41:58,266 --> 00:42:02,436
so the debug builds now
release the object much more


903
00:42:02,436 --> 00:42:06,166
like when released builds and
we hope you appreciate that.


904
00:42:11,746 --> 00:42:13,926
[applause] So this is our
great [inaudible] ARC.


905
00:42:14,736 --> 00:42:15,766
Well, we have Migrator.


906
00:42:16,326 --> 00:42:17,896
It does all the heavy
lifting for you.


907
00:42:17,896 --> 00:42:19,856
It removes retain,
release, autorelease.


908
00:42:20,616 --> 00:42:24,366
It deletes empty dealloc methods


909
00:42:24,366 --> 00:42:26,656
if all your dealloc method
was doing was calling release,


910
00:42:26,656 --> 00:42:27,386
release, release.


911
00:42:28,846 --> 00:42:30,726
It converts NSAutoreleasePool


912
00:42:30,726 --> 00:42:33,646
to @autoreleasepool
in the modern syntax.


913
00:42:34,986 --> 00:42:36,106
But you have to do the rest.


914
00:42:36,466 --> 00:42:39,966
You need to reason about some
rare things like id in structs.


915
00:42:39,966 --> 00:42:42,556
Usually the easiest thing to
do is convert these to classes


916
00:42:42,556 --> 00:42:44,536
and then, you know,
your code looks prettier


917
00:42:44,536 --> 00:42:45,146
in the end anyway.


918
00:42:45,906 --> 00:42:48,276
You also need to reason
about some atypical uses


919
00:42:48,276 --> 00:42:50,466
of memory management APIs.


920
00:42:51,736 --> 00:42:53,976
This was covered
in depth last year


921
00:42:54,106 --> 00:42:55,856
in the Automatic
Reference Counting talk


922
00:42:56,136 --> 00:42:57,536
and you can get all
the details there.


923
00:42:58,566 --> 00:43:00,436
But if you don't have time
to jump back to the video,


924
00:43:00,436 --> 00:43:01,836
here's what you need to do.


925
00:43:02,186 --> 00:43:05,626
Just like with modern syntax,
you can go to the Edit Menu,


926
00:43:05,626 --> 00:43:10,256
go to the Refracturing Submenu,
and you can convert to ARC


927
00:43:10,256 --> 00:43:14,566
and let the tools help
you along the way.


928
00:43:14,796 --> 00:43:18,746
So ARC and your app, we really
want you to switch to ARC


929
00:43:18,746 --> 00:43:21,606
by default and focus on what
matters which is your app


930
00:43:21,606 --> 00:43:22,606
and writing great code.


931
00:43:23,166 --> 00:43:25,876
You can always opt out specific
files if you run into problems.


932
00:43:25,876 --> 00:43:27,956
So you can just go to the
Profile Build Settings


933
00:43:27,956 --> 00:43:32,816
and select the Compiler
Flag for turning off ARC.


934
00:43:33,756 --> 00:43:35,746
And I'd also like to point


935
00:43:35,746 --> 00:43:38,866
out that the ARC Migrator
supports both manual reference


936
00:43:38,916 --> 00:43:41,156
counting code and
garbage-collected code


937
00:43:41,156 --> 00:43:44,436
and it helps you migrate both
easily and straight forward.


938
00:43:45,066 --> 00:43:49,726
Now for an update on
new things we've added


939
00:43:49,796 --> 00:43:51,886
that we think you will love.


940
00:43:51,886 --> 00:43:54,976
Let's talk about some new memory
management warnings we have


941
00:43:54,976 --> 00:43:58,606
added to help you better
reason about life under ARC.


942
00:43:59,356 --> 00:44:02,736
So, there are three things
I'm going to be talking about


943
00:44:03,316 --> 00:44:06,056
and we're going to be talking
about the implicit referencing


944
00:44:06,056 --> 00:44:08,716
of self and retain
cycles with blocks.


945
00:44:08,716 --> 00:44:13,876
We're going to be talking about
repeated use of a weak variable


946
00:44:13,876 --> 00:44:15,386
and what does that even mean.


947
00:44:16,046 --> 00:44:18,796
And then thirdly, we'll be
talking about sending messages


948
00:44:18,796 --> 00:44:22,316
to weak and had a better reason
about the behavior thereof.


949
00:44:23,716 --> 00:44:26,856
So let's jump in first and
talk about retain cycles.


950
00:44:27,296 --> 00:44:28,276
As a brief refresher,


951
00:44:28,276 --> 00:44:30,786
let's imagine your app is
just referencing an object.


952
00:44:31,266 --> 00:44:34,076
The reference count of this
object will start out is one.


953
00:44:35,136 --> 00:44:38,826
And similarly, if that object
references another object,


954
00:44:38,946 --> 00:44:41,216
that will be one.


955
00:44:41,216 --> 00:44:44,146
But, if we actually
have a reference back


956
00:44:44,146 --> 00:44:46,786
to the original object, its
reference count would be two.


957
00:44:46,786 --> 00:44:50,676
And if our app lets go of
the object, we have a leak


958
00:44:50,676 --> 00:44:52,766
because now these two
objects are holding references


959
00:44:52,766 --> 00:44:54,976
on to each other and
keeping the object alive.


960
00:44:56,206 --> 00:44:58,836
So with that in mind,
let's look at some code.


961
00:44:59,896 --> 00:45:02,376
Let's say in a method you
have two instance variables.


962
00:45:03,546 --> 00:45:05,526
And one of the instance
variables holds the block


963
00:45:05,526 --> 00:45:06,966
and the other one
is just an object.


964
00:45:06,966 --> 00:45:08,116
It doesn't really
matter what kind.


965
00:45:09,146 --> 00:45:10,186
In the block we use ivar2,


966
00:45:10,266 --> 00:45:12,346
and then we assign
the block to ivar1.


967
00:45:12,346 --> 00:45:15,796
Well what's actually
going on under the covers


968
00:45:15,796 --> 00:45:17,226
and how the compiler reasons


969
00:45:17,226 --> 00:45:19,146
about this is we have
implicit use of self


970
00:45:19,146 --> 00:45:20,256
in both of these cases.


971
00:45:20,556 --> 00:45:23,166
And those are the actual
objects in question


972
00:45:23,166 --> 00:45:26,606
that we need to think about.


973
00:45:26,606 --> 00:45:30,236
So let's delete that and then
see what warning the compiler


974
00:45:30,236 --> 00:45:31,036
can now print out.


975
00:45:32,276 --> 00:45:35,736
So I've enabled this warning,
the compiler will print out,


976
00:45:36,126 --> 00:45:39,516
they were capturing self
strongly in the ivar2 case,


977
00:45:39,516 --> 00:45:41,856
and then it points
out the related case


978
00:45:41,856 --> 00:45:43,546
where it believes
the cycle began.


979
00:45:44,846 --> 00:45:46,196
Well, again, I'm
a visual person,


980
00:45:46,196 --> 00:45:47,916
but show what this
looks like in practice.


981
00:45:48,486 --> 00:45:52,616
So we have an instance of
our class and we have ivar2.


982
00:45:52,726 --> 00:45:55,506
Again, ivar2 can be any
object, string, whatever.


983
00:45:56,466 --> 00:45:57,876
And now we're creating
this block.


984
00:45:59,096 --> 00:46:01,496
Now when we wrote the code,
it may look like this.


985
00:46:01,496 --> 00:46:04,206
It may look like we're just
assigning the block to ivar1


986
00:46:04,206 --> 00:46:05,086
and we're using ivar2.


987
00:46:05,256 --> 00:46:06,516
What's the problem?


988
00:46:06,516 --> 00:46:07,376
I don't see any cycle.


989
00:46:08,866 --> 00:46:11,086
Well because there is
an implicit use of self,


990
00:46:11,176 --> 00:46:13,326
the block is actually
retaining self.


991
00:46:13,326 --> 00:46:17,416
And now we have a cycle and now
it's indirectly accessing ivar2.


992
00:46:17,416 --> 00:46:19,696
And again, we'll
get the same leak


993
00:46:19,696 --> 00:46:22,916
that we demonstrated earlier
if we let go of the instance


994
00:46:22,916 --> 00:46:25,296
of our class, the
block will be keeping


995
00:46:25,296 --> 00:46:28,656
that instance alive
and we have a leak.


996
00:46:28,796 --> 00:46:30,566
So let's go back to the
code and the warning.


997
00:46:30,856 --> 00:46:31,936
How do we fix this?


998
00:46:32,706 --> 00:46:34,996
Well we make some room and
we add a weak variable.


999
00:46:35,696 --> 00:46:38,716
So what we do is we create
a weak variable on the stack


1000
00:46:39,776 --> 00:46:41,306
and assign self to it.


1001
00:46:41,306 --> 00:46:44,856
And this variable is an instance
of the same type of our class.


1002
00:46:45,926 --> 00:46:49,596
And then what we do is we use
this weak variable in our block.


1003
00:46:50,376 --> 00:46:52,786
And if we do that,
the warning goes away.


1004
00:46:54,476 --> 00:46:56,466
So what's going on here?


1005
00:46:57,746 --> 00:47:01,246
Weak variables do not extend
the lifetime on objects.


1006
00:47:02,116 --> 00:47:04,806
They are-- and therefore,


1007
00:47:04,806 --> 00:47:06,806
they don't implicitly
create retain cycles.


1008
00:47:07,326 --> 00:47:11,636
And the great thing about weak
variables is they safely become


1009
00:47:11,636 --> 00:47:12,826
nil when the reference count


1010
00:47:12,826 --> 00:47:14,906
of the object they're
referring to drops to zero.


1011
00:47:15,686 --> 00:47:18,696
Now in this particular
case, they are tied together


1012
00:47:18,696 --> 00:47:19,646
so we don't have a problem.


1013
00:47:19,646 --> 00:47:21,206
But it allows us
to break the cycle


1014
00:47:21,206 --> 00:47:22,576
and actually get
the paper we want


1015
00:47:22,576 --> 00:47:26,486
when we release the
instance of our class.


1016
00:47:26,636 --> 00:47:29,536
So building on this, let's talk
about weak variables in general.


1017
00:47:30,666 --> 00:47:31,806
Consider this simple method


1018
00:47:31,806 --> 00:47:34,746
where we're logging the
description of a weak ivar.


1019
00:47:36,176 --> 00:47:37,576
Does this method
even called call?


1020
00:47:37,576 --> 00:47:39,096
What happens if the weak is nil?


1021
00:47:39,396 --> 00:47:41,196
You know, what actually
happens here?


1022
00:47:41,856 --> 00:47:45,876
How do we reason
about this at all?


1023
00:47:45,936 --> 00:47:49,526
Well, now the compiler
can warn about this saying


1024
00:47:50,246 --> 00:47:55,516
that we're using weak variable
and it may unpredictably be nil.


1025
00:47:56,686 --> 00:48:00,056
Well what do we do about this?


1026
00:48:00,266 --> 00:48:01,706
Well, it's actually
worst than that.


1027
00:48:01,706 --> 00:48:05,406
It can get-- we can have a
weak variable and use it twice.


1028
00:48:05,956 --> 00:48:08,606
Does this get called
zero, one or two times?


1029
00:48:08,886 --> 00:48:10,416
You know, how do we
reason about this?


1030
00:48:11,346 --> 00:48:13,296
Well there's actually a
solution for both of these


1031
00:48:13,436 --> 00:48:16,176
and I'd like to-- oh, sorry.


1032
00:48:17,106 --> 00:48:19,246
In the repeated use case, we
now have a specific warning


1033
00:48:19,246 --> 00:48:21,046
for that too pointing
out that, you know,


1034
00:48:21,116 --> 00:48:23,636
you can't actually reason about
the zero, one or two case.


1035
00:48:24,516 --> 00:48:28,716
[ Pause ]


1036
00:48:29,216 --> 00:48:33,656
So let's go back to the original
code and the original warning


1037
00:48:33,716 --> 00:48:34,826
and look at how we fix this.


1038
00:48:35,266 --> 00:48:39,826
Let's make some room and
do as the compiler advices


1039
00:48:39,826 --> 00:48:42,376
and put a local strong
variable on the stack,


1040
00:48:42,986 --> 00:48:45,056
assign our weak variable
into it.


1041
00:48:45,516 --> 00:48:46,566
And once we've done that,


1042
00:48:47,116 --> 00:48:50,506
that strong variable is
either nil or not nil.


1043
00:48:50,816 --> 00:48:52,106
It's not going to
change magically


1044
00:48:52,106 --> 00:48:53,106
out from underneath us.


1045
00:48:53,836 --> 00:48:56,156
And because we know that,
we can now test for it.


1046
00:48:56,156 --> 00:48:59,886
And if it's not nil, we can now
safely print the description.


1047
00:48:59,886 --> 00:49:02,736
And if we do that, of
course, the warning goes away.


1048
00:49:03,646 --> 00:49:06,786
So this is great.


1049
00:49:07,216 --> 00:49:10,126
We now can reason about the
lifetime of this variable.


1050
00:49:11,056 --> 00:49:14,396
And the great thing too is
handling the nil case becomes


1051
00:49:14,396 --> 00:49:15,086
very obvious.


1052
00:49:15,086 --> 00:49:20,716
We just add the else block
and do the right thing.


1053
00:49:20,936 --> 00:49:24,206
Next up in the Automatic
Reference Counting Improvements,


1054
00:49:24,476 --> 00:49:26,976
I'd like to talk
about the relationship


1055
00:49:27,066 --> 00:49:28,726
between ARC and CoreFoundation.


1056
00:49:29,296 --> 00:49:31,766
If you've already
been using ARC,


1057
00:49:31,766 --> 00:49:32,956
you may have been writing a code


1058
00:49:32,956 --> 00:49:34,946
like this every time you
interact with CoreFoundation.


1059
00:49:34,946 --> 00:49:38,836
You have a CFDictionary,
getting some value out of it.


1060
00:49:39,246 --> 00:49:43,736
And in order to help ARC reason
about the object lifetime,


1061
00:49:43,846 --> 00:49:46,756
we use a bridge cast saying
that there's no net change


1062
00:49:46,756 --> 00:49:47,696
in the reference count here.


1063
00:49:49,196 --> 00:49:52,546
This is required because
anytime we come in and out


1064
00:49:52,546 --> 00:49:54,396
of the ARC system, we
need the ARC compiler


1065
00:49:54,396 --> 00:49:55,926
to actually be tracking
the reference count


1066
00:49:55,926 --> 00:49:58,386
so that way objects live
only as long as they need to,


1067
00:49:58,386 --> 00:49:59,626
and no longer and no shorter.


1068
00:49:59,626 --> 00:50:06,836
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.


1069
00:50:07,116 --> 00:50:09,116
You can express a decrement


1070
00:50:09,116 --> 00:50:11,376
of the reference count
via CFBridgingRelease.


1071
00:50:12,036 --> 00:50:18,976
And you can express a no
net change via bridge cast.


1072
00:50:19,156 --> 00:50:22,036
Well, you know, it's
great that we're using ARC


1073
00:50:22,036 --> 00:50:23,806
and we've been able
to make our CF code


1074
00:50:23,806 --> 00:50:25,386
and our Foundation
code work together,


1075
00:50:25,386 --> 00:50:26,926
but can we improve
this situation?


1076
00:50:27,816 --> 00:50:29,716
Well, CoreFoundation
actually has some really


1077
00:50:29,716 --> 00:50:30,796
strong conventions.


1078
00:50:31,296 --> 00:50:33,516
Create and copy methods
return +1


1079
00:50:33,816 --> 00:50:35,526
and everything else returns +0.


1080
00:50:36,456 --> 00:50:39,596
And in fact, we already have
some compiler attributes


1081
00:50:39,596 --> 00:50:42,026
for the exceptions,
like CF RETUNS RETAINED


1082
00:50:42,026 --> 00:50:46,806
and CF RETURNS NOT RETAINED and
CF releases argument for APIs


1083
00:50:46,806 --> 00:50:48,466
that consume their argument.


1084
00:50:49,416 --> 00:50:52,236
And these are there to
help the static analyzer


1085
00:50:52,236 --> 00:50:53,986
and you may have already
seen this kick in,


1086
00:50:53,986 --> 00:50:55,536
in your use of the
static analyzer.


1087
00:50:56,326 --> 00:51:00,696
Well, what if we can just
use these conventions


1088
00:51:00,696 --> 00:51:03,146
to make this bridge
cast go away?


1089
00:51:04,186 --> 00:51:07,376
In fact, we've formalized
the everything else cast now.


1090
00:51:08,406 --> 00:51:13,096
The common CF APIs you use
now allow implicit bridging


1091
00:51:13,096 --> 00:51:14,846
as opposed to this
explicit bridging.


1092
00:51:15,516 --> 00:51:21,086
[ Applause ]


1093
00:51:21,586 --> 00:51:24,286
There are new macros
available for use too.


1094
00:51:24,286 --> 00:51:26,336
And with that, I'd like to
show you how this works.


1095
00:51:27,126 --> 00:51:29,656
So, how do we enable
implicit bridging?


1096
00:51:30,206 --> 00:51:34,706
Let's imagine we're wrapping
a CoreFoundation Array


1097
00:51:34,706 --> 00:51:36,066
and we have our example
Foo that--


1098
00:51:36,066 --> 00:51:37,896
we have just bunch of
wrappers around the array.


1099
00:51:39,376 --> 00:51:41,716
Well the first API we
have here is great.


1100
00:51:41,716 --> 00:51:43,876
It follows the convention
as copying the name.


1101
00:51:44,266 --> 00:51:45,456
We don't need to do anything.


1102
00:51:46,856 --> 00:51:48,606
The second API is also great.


1103
00:51:48,756 --> 00:51:49,756
We don't need to anything


1104
00:51:49,756 --> 00:51:50,956
because it follows
the convention.


1105
00:51:50,956 --> 00:51:51,936
It returns +1.


1106
00:51:51,936 --> 00:51:53,316
It doesn't consume
any arguments.


1107
00:51:54,376 --> 00:51:57,176
But our third API, we don't
know what we were thinking.


1108
00:51:57,176 --> 00:52:01,486
We decided that we're going
to return retained and--


1109
00:52:01,746 --> 00:52:03,136
but we're following
the convention.


1110
00:52:03,756 --> 00:52:07,936
Well, what we need to do is put
a CF RETURNS RETAINED attribute


1111
00:52:07,976 --> 00:52:13,016
there via macro and let the
compiler know what's going on.


1112
00:52:13,576 --> 00:52:14,966
Even if we just stop
here and do this,


1113
00:52:14,966 --> 00:52:17,496
we've already help the static
analyzer reason about our code.


1114
00:52:18,066 --> 00:52:20,196
But once we're done auditing,


1115
00:52:20,196 --> 00:52:22,886
what we can do is
add these macros,


1116
00:52:22,936 --> 00:52:26,786
CF IMPLICIT BRIDGING ENABLED and
CF IMPLICIT BRIDGING DISABLED


1117
00:52:26,986 --> 00:52:29,246
to tell the compiler
that we've audited code.


1118
00:52:30,586 --> 00:52:33,636
Now, this must be
after all #includes.


1119
00:52:33,766 --> 00:52:36,006
Obviously, you're not
auditing somebody else's code.


1120
00:52:36,006 --> 00:52:37,226
You're auditing your code.


1121
00:52:38,476 --> 00:52:40,696
And you don't have to
do it around everything.


1122
00:52:40,696 --> 00:52:42,526
If there's code you don't
want to think about right now,


1123
00:52:42,526 --> 00:52:45,466
you could have the explicitly
bridge code remain outside


1124
00:52:45,466 --> 00:52:48,346
of the macros they are using.


1125
00:52:49,786 --> 00:52:51,576
And that is implicit bridging


1126
00:52:51,576 --> 00:52:54,736
and this is all the
common CF plist types


1127
00:52:54,776 --> 00:52:57,876
or have been auditing and you
can go remove this bridge cast


1128
00:52:57,876 --> 00:53:00,316
from your code if you're
using the new SDKs.


1129
00:53:00,836 --> 00:53:04,656
So to wrap up, we have Modules.


1130
00:53:05,206 --> 00:53:08,696
This is really great for finally
fixing the textual inclusion


1131
00:53:08,696 --> 00:53:11,236
problem and all the
associated bugs.


1132
00:53:11,706 --> 00:53:13,536
It also adds great performance


1133
00:53:13,536 --> 00:53:15,986
for compilation time
and indexing.


1134
00:53:16,596 --> 00:53:19,076
And it's just a much more
pleasurable experience


1135
00:53:19,076 --> 00:53:20,246
with features like Autolinking.


1136
00:53:20,826 --> 00:53:22,246
We also have improved
productivity


1137
00:53:22,246 --> 00:53:25,946
with better compiler warnings
throughout the SDK adoption


1138
00:53:25,946 --> 00:53:28,686
of these compiler warnings to
help you catch errors early


1139
00:53:29,106 --> 00:53:30,696
and write more productive code.


1140
00:53:31,326 --> 00:53:33,176
And with ARC, we've made
it better and faster


1141
00:53:33,176 --> 00:53:37,356
by allowing you to better
reason about simple retain cycle


1142
00:53:37,356 --> 00:53:40,386
and weak reference bugs,
and also easier in the fact


1143
00:53:40,386 --> 00:53:42,316
that you no longer need
to write bridge cast


1144
00:53:42,316 --> 00:53:45,046
for common CF plist types.


1145
00:53:45,236 --> 00:53:46,986
For more information,
I'd like to point you


1146
00:53:47,086 --> 00:53:48,596
at Dave DeLong, our evangelist.


1147
00:53:49,576 --> 00:53:51,016
We also have tons
of documentation


1148
00:53:51,016 --> 00:53:54,816
on the developer website and
of course the Developer Forums.


1149
00:53:55,576 --> 00:53:58,376
We have two labs,
one tomorrow morning


1150
00:53:58,376 --> 00:54:00,156
and one Thursday afternoon.


1151
00:54:01,326 --> 00:54:02,666
Oh sorry, related sessions.


1152
00:54:03,006 --> 00:54:04,816
We have What's New
in LLVM Compiler,


1153
00:54:04,816 --> 00:54:07,146
it happened earlier today, you
have to catch them on video.


1154
00:54:07,196 --> 00:54:10,136
But tomorrow, we have
Optimize Your Code Using LLVM


1155
00:54:10,226 --> 00:54:12,306
in Nob Hill at 3:30.


1156
00:54:12,656 --> 00:54:13,706
So, thanks for coming.


1157
00:54:14,516 --> 00:54:21,840
[ Applause ]

