1
00:00:00,506 --> 00:00:11,626
[ Silence ]


2
00:00:12,126 --> 00:00:16,686
>> Hello, good afternoon,
welcome to session 505,


3
00:00:16,756 --> 00:00:19,426
"Harnessing Metadata
in Audiovisual Media".


4
00:00:20,026 --> 00:00:22,846
I've heard we are competing
with the "Intro to Swift" talk


5
00:00:22,846 --> 00:00:24,956
so get intimate with
your neighbors here.


6
00:00:25,626 --> 00:00:28,476
My name is Adam Sonnanstine.


7
00:00:28,476 --> 00:00:30,916
I'm an engineer on
the AVFoundation team


8
00:00:30,916 --> 00:00:33,586
and today we are going to talk
about, of course, metadata.


9
00:00:34,296 --> 00:00:35,646
So what do I mean by metadata?


10
00:00:35,996 --> 00:00:38,416
Well, for the purposes
of this talk we're going


11
00:00:38,416 --> 00:00:40,896
to define metadata to mean
any data that is stored


12
00:00:40,896 --> 00:00:44,296
in movie files, streaming
presentations, any other sort


13
00:00:44,296 --> 00:00:49,636
of audiovisual presentation
that describes the primary data,


14
00:00:49,636 --> 00:00:51,876
like the audio and video that
we think about when we think


15
00:00:51,876 --> 00:00:53,146
of those sorts of presentations.


16
00:00:53,856 --> 00:00:55,556
Some examples are
always helpful.


17
00:00:56,336 --> 00:00:58,946
One you should be familiar
is iTunes metadata,


18
00:00:59,376 --> 00:01:02,606
when you have this sort of
the song names and the artists


19
00:01:02,606 --> 00:01:05,756
and the album artwork
in your iTunes library.


20
00:01:05,986 --> 00:01:08,376
All these things are stored
as the sort of metadata


21
00:01:08,376 --> 00:01:10,436
that I'm talking about
today in the files


22
00:01:10,436 --> 00:01:11,506
in your iTunes library.


23
00:01:12,756 --> 00:01:15,426
Besides iTunes metadata,
we also have things


24
00:01:15,426 --> 00:01:16,836
like location information.


25
00:01:17,166 --> 00:01:20,006
If you have a movie that
you took with your iPhone


26
00:01:20,006 --> 00:01:23,226
or some other location-enabled
device and you played it


27
00:01:23,226 --> 00:01:26,146
in QuickTime player, that will
show up in the info window


28
00:01:26,216 --> 00:01:28,956
to tell you where you were
when you took that movie.


29
00:01:29,356 --> 00:01:31,206
That's also stored as
the kind of metadata


30
00:01:31,206 --> 00:01:33,816
that we are talking about today.


31
00:01:33,816 --> 00:01:36,966
Some new features, we know that
you're not always standing still


32
00:01:36,966 --> 00:01:38,006
when you are taking your videos.


33
00:01:38,086 --> 00:01:43,006
So new in iOS 8 and OS X
Yosemite, we have features


34
00:01:43,106 --> 00:01:46,456
that support things like dynamic
location, that's a location


35
00:01:46,456 --> 00:01:47,666
that changes over time.


36
00:01:47,666 --> 00:01:49,456
So these are some new features
that we are going to be talking


37
00:01:49,456 --> 00:01:52,996
about later on that we are
pretty excited about and,


38
00:01:53,406 --> 00:01:57,436
in addition to location, this
really applies to any sort


39
00:01:57,436 --> 00:02:00,176
of metadata that you might
want to add that changes


40
00:02:00,176 --> 00:02:01,636
over time in your movie.


41
00:02:02,066 --> 00:02:04,536
This is a screen shot of a
demo app we'll show you later


42
00:02:04,856 --> 00:02:07,786
but the circle and the
annotation text that's all


43
00:02:07,786 --> 00:02:12,456
stored as the same sort of timed
metadata as a timed location.


44
00:02:13,136 --> 00:02:14,846
So hopefully that whets
your appetite a little bit.


45
00:02:15,206 --> 00:02:17,526
We'll talk about what
we're going to cover today,


46
00:02:17,526 --> 00:02:19,716
we're going to start, I'm going
to give you an intro to metadata


47
00:02:19,716 --> 00:02:21,986
and AVFoundation, some of
the classes that have been


48
00:02:21,986 --> 00:02:25,006
around for a while for
describing all sorts


49
00:02:25,006 --> 00:02:27,776
of metadata, how to inspect
that and how to author it.


50
00:02:27,776 --> 00:02:29,126
We're going to talk more


51
00:02:29,126 --> 00:02:30,966
about those new timed
metadata features


52
00:02:31,046 --> 00:02:35,256
and then I'll give you some best
practices including some privacy


53
00:02:35,256 --> 00:02:37,856
things to keep in mind and
some other best practices.


54
00:02:38,856 --> 00:02:42,006
So our first topic: metadata
in AVFoundation..What kind


55
00:02:42,006 --> 00:02:44,906
of classes are we going to be
using to describe our metadata?


56
00:02:45,346 --> 00:02:48,316
Well our primary model
objects that we use


57
00:02:48,376 --> 00:02:54,536
to describe both movie files
or HLS streams is AVAsset.


58
00:02:54,986 --> 00:03:00,036
AVAsset can contain any
number of AV metadata objects


59
00:03:00,376 --> 00:03:05,646
and each AVMetadataItem instance
represents a single piece


60
00:03:05,646 --> 00:03:08,686
of metadata, either your
track name or your album mark,


61
00:03:08,976 --> 00:03:13,316
even your location stuff that's
going to be separate pieces


62
00:03:13,316 --> 00:03:15,836
of metadata in our
runtime environment.


63
00:03:16,196 --> 00:03:19,946
So a closer look at
AVMetadataItem: at its core,


64
00:03:20,196 --> 00:03:21,436
it has two properties.


65
00:03:22,076 --> 00:03:24,536
The first is identifier, which
is actually a new property


66
00:03:24,906 --> 00:03:26,636
and that is going
to describe the kind


67
00:03:26,636 --> 00:03:27,676
of metadata that you have.


68
00:03:27,866 --> 00:03:31,626
In this example we have the
song name and it's represented


69
00:03:31,626 --> 00:03:33,036
by this long symbol name,


70
00:03:33,036 --> 00:03:36,396
AVMetadataIdentifieriTunes
MetadataSongName,


71
00:03:37,026 --> 00:03:38,276
and then you have the value


72
00:03:38,276 --> 00:03:40,436
which is the actual payload
of the metadata item.


73
00:03:40,436 --> 00:03:43,136
So for song name, it's the
name of the song as a string.


74
00:03:44,896 --> 00:03:47,446
As an example for cover art,


75
00:03:47,446 --> 00:03:49,706
you can see that the
value doesn't have


76
00:03:49,706 --> 00:03:53,256
to be a string it can be an
image or any other object


77
00:03:53,506 --> 00:03:57,576
that supports both the NSObject
and NSCopying protocols.


78
00:03:58,456 --> 00:04:00,696
Now if you've used
AVMetadataItem


79
00:04:00,696 --> 00:04:03,356
in the past you might
be familiar with the key


80
00:04:03,356 --> 00:04:04,646
and key space properties.


81
00:04:05,196 --> 00:04:07,266
Well the identifier I
mentioned that was new,


82
00:04:07,616 --> 00:04:09,306
it's new because
it is a combination


83
00:04:09,306 --> 00:04:11,626
of the old properties,
key and key space.


84
00:04:11,626 --> 00:04:14,216
So I'm not going to talking much
about key and key space today


85
00:04:14,216 --> 00:04:17,065
but mostly going to be talking
about identifier going forward


86
00:04:17,065 --> 00:04:19,375
as the way to describe
your metadata.


87
00:04:20,446 --> 00:04:22,846
Take a look at some of the
built-in identifiers we have;


88
00:04:23,346 --> 00:04:24,736
this is just a tiny sampling.


89
00:04:24,736 --> 00:04:25,626
There's a lot of them.


90
00:04:25,626 --> 00:04:26,376
You can find them


91
00:04:26,376 --> 00:04:29,856
in AVMetadataIdentifiers.h. I've
arranged them here according


92
00:04:29,856 --> 00:04:34,476
roughly to the old notion of
key space so that's just sort


93
00:04:34,476 --> 00:04:37,526
of a sampling of the kind of
metadata that we already know


94
00:04:37,526 --> 00:04:38,866
that you might want
to represent.


95
00:04:40,196 --> 00:04:42,846
Going back to the
metadata item itself,


96
00:04:43,926 --> 00:04:47,826
we have a property that's
also new called dataType,


97
00:04:47,826 --> 00:04:49,686
which describes the
native data type


98
00:04:50,026 --> 00:04:51,886
that your metadata
is representing.


99
00:04:52,236 --> 00:04:54,956
So for the case of our song
name it's stored as a string


100
00:04:54,956 --> 00:04:57,486
so we see that the data
type is a UTF8 string;


101
00:04:57,926 --> 00:04:59,526
and these string constants


102
00:04:59,526 --> 00:05:02,336
that represent the different
data types are all defined


103
00:05:02,336 --> 00:05:07,956
in CMMetadata.h. And besides
the data type property,


104
00:05:07,956 --> 00:05:11,356
we also have several
type coercion properties


105
00:05:11,356 --> 00:05:14,106
that you can use if you know
you want to get your payload


106
00:05:14,346 --> 00:05:17,536
in the form of a certain
type of Objective C object.


107
00:05:17,536 --> 00:05:21,286
So you have string value, number
value, date value and data value


108
00:05:21,566 --> 00:05:24,656
and those are going to give
you exactly what you'd expect.


109
00:05:24,976 --> 00:05:28,726
For the case of where our
native payload is a string,


110
00:05:28,946 --> 00:05:31,526
only string value is going to
give you an interesting answer.


111
00:05:31,526 --> 00:05:32,596
The rest will give you NULL.


112
00:05:33,226 --> 00:05:36,476
For our artwork example where
the payload is a JPEG image,


113
00:05:36,976 --> 00:05:39,236
the top three are
going to give you NULL


114
00:05:39,496 --> 00:05:42,286
and the data value is going
to give you the NSData


115
00:05:42,286 --> 00:05:45,646
that you're looking for to grab
the bytes of the JPEG image.


116
00:05:46,506 --> 00:05:48,796
There are examples
where you can have more


117
00:05:48,796 --> 00:05:52,466
than one non-nil
tech coercion method.


118
00:05:52,756 --> 00:05:56,986
And one is creation date if
you have the date represented


119
00:05:56,986 --> 00:05:59,236
as a standard string
format for dates.


120
00:05:59,666 --> 00:06:05,126
You can either get the actual
string that was stored that way


121
00:06:05,376 --> 00:06:08,286
or you can ask the metadata
item to give you an instance


122
00:06:08,286 --> 00:06:10,266
of NSDate that describes
the same thing


123
00:06:10,266 --> 00:06:12,326
in a more convenient
representation.


124
00:06:12,636 --> 00:06:15,536
So that's your brief
intro to AVMetadataItem,


125
00:06:15,536 --> 00:06:17,636
we're going to be talking a lot
about it throughout the talk.


126
00:06:17,906 --> 00:06:19,356
Let's go back to AVAsset


127
00:06:19,356 --> 00:06:21,866
so we can see how we actually
get these metadata items.


128
00:06:21,866 --> 00:06:25,606
So the easiest way is just to
ask for all of the metadata


129
00:06:25,606 --> 00:06:27,286
that applies to the
entire asset.


130
00:06:27,626 --> 00:06:30,456
There are types of metadata that
apply to just parts of the asset


131
00:06:30,706 --> 00:06:33,686
but this is how you get the
metadata to, like, the location


132
00:06:33,686 --> 00:06:35,796
and the song title that
applies to the entire asset.


133
00:06:36,686 --> 00:06:40,036
There's also a way to get
just a subset of the metadata.


134
00:06:40,586 --> 00:06:42,926
We have this notion of metadata
format but I'm not going


135
00:06:42,926 --> 00:06:45,496
to be talking about too much
today but you can use it


136
00:06:45,496 --> 00:06:47,656
to get just that
subset of the metadata.


137
00:06:48,046 --> 00:06:50,656
So for our example, when we
are getting iTunes metadata,


138
00:06:50,946 --> 00:06:54,426
we're going to use that
AVMetadataFormatiTunesMetadata


139
00:06:54,426 --> 00:06:58,526
and grab all of that using
the metadataForFormat method.


140
00:06:58,976 --> 00:07:02,146
And then from there we can
use this filtering method,


141
00:07:02,146 --> 00:07:04,646
metadataItemsFromArray,
filtered by an identifier


142
00:07:04,646 --> 00:07:07,346
to get just the items
that correspond


143
00:07:07,346 --> 00:07:08,716
to the song name identifier.


144
00:07:09,166 --> 00:07:11,026
You might be wondering
why you can have more


145
00:07:11,026 --> 00:07:13,106
than one song name
in a single asset?


146
00:07:13,336 --> 00:07:15,876
We'll get back to that in just
a little bit but first I want


147
00:07:15,876 --> 00:07:19,986
to talk about how you load the
payload of your metadata items.


148
00:07:20,336 --> 00:07:23,196
AVMetadataItem conforms


149
00:07:23,196 --> 00:07:25,216
to the
AVAsynchronousKeyValueLoading.h


150
00:07:25,216 --> 00:07:25,726
protocol.


151
00:07:25,726 --> 00:07:28,706
This is a protocol we define
ourselves in AVFoundation


152
00:07:28,776 --> 00:07:32,076
and a lot of our core
model objects conform to it


153
00:07:32,546 --> 00:07:35,686
because a lot of times
when you get an AVAsset


154
00:07:35,686 --> 00:07:38,686
or an AVMetadataItem we haven't
actually loaded the data behind


155
00:07:38,686 --> 00:07:39,006
it yet.


156
00:07:39,006 --> 00:07:43,326
So you can use this method, load
values asynchronously for keys


157
00:07:43,826 --> 00:07:46,326
to load the specific values
you want and they'll do


158
00:07:46,326 --> 00:07:48,926
that asynchronously so you're
not blocking your main thread


159
00:07:49,206 --> 00:07:51,876
with some sort of synchronous
I/O or something like that.


160
00:07:52,426 --> 00:07:54,436
So for this case we
have our metadata item.


161
00:07:54,796 --> 00:07:58,216
We're looking for the value so
we just load the key value and,


162
00:07:58,216 --> 00:07:59,516
when we get our completion
handler,


163
00:07:59,856 --> 00:08:01,556
we're going to check
the status to make sure


164
00:08:01,556 --> 00:08:04,256
that that loading succeeded
and, assuming that we did,


165
00:08:04,386 --> 00:08:06,386
we can then just go
ahead and grab the value


166
00:08:06,386 --> 00:08:07,856
and use it however we see fit.


167
00:08:08,556 --> 00:08:12,836
So back to that whole multiple
titles in one asset string.


168
00:08:12,836 --> 00:08:16,396
Well, one reason we
might have that is


169
00:08:16,446 --> 00:08:20,016
if we have the asset localized
in multiple languages.


170
00:08:20,016 --> 00:08:22,836
So an asset can have
the same metadata items


171
00:08:22,836 --> 00:08:23,976
in multiple languages.


172
00:08:24,426 --> 00:08:25,836
The example that
we're going to talk


173
00:08:25,836 --> 00:08:28,466
about is
QuickTimeUserDataFullName


174
00:08:28,776 --> 00:08:29,696
dat identifier.


175
00:08:29,936 --> 00:08:32,135
If you use this identifier
in your files,


176
00:08:32,416 --> 00:08:35,395
then QuickTime Player, for
example, can pick up the title


177
00:08:35,566 --> 00:08:36,885
and display it in the title bar.


178
00:08:36,885 --> 00:08:39,206
So this is just yet
another example


179
00:08:39,206 --> 00:08:41,996
of how metadata is used
in our applications.


180
00:08:42,525 --> 00:08:44,576
This particular example


181
00:08:44,576 --> 00:08:49,176
of the movie actually has the
title available in both English


182
00:08:49,176 --> 00:08:53,456
and Spanish so here we have the
English as the system language


183
00:08:53,456 --> 00:08:56,486
so QuickTime Player picks that
up, picks up the English title


184
00:08:56,486 --> 00:08:59,816
but if we set our system
language to Spanish it will pick


185
00:08:59,816 --> 00:09:02,286
up the Spanish localization
of that title instead.


186
00:09:02,746 --> 00:09:06,986
These are represented as two
distinct pieces of metadata


187
00:09:06,986 --> 00:09:10,456
within the file and the way that
you distinguish between them is


188
00:09:10,456 --> 00:09:11,696
that they'll have
different values


189
00:09:11,696 --> 00:09:15,056
for these final two properties
of AVMetadataItem locale


190
00:09:15,116 --> 00:09:16,406
and extendedLanguageTag.


191
00:09:17,106 --> 00:09:19,586
ExtendedLanguageTag is
new in this release.


192
00:09:19,716 --> 00:09:23,166
It's a BCP 47 language tag
and it's particularly useful


193
00:09:23,166 --> 00:09:24,856
when you want to
distinguish written languages.


194
00:09:25,616 --> 00:09:29,596
So that's one reason
why you might have more


195
00:09:29,596 --> 00:09:32,326
than one metadata item
with the same identifier.


196
00:09:32,326 --> 00:09:36,916
So I mentioned before that
not all metadata applies


197
00:09:37,036 --> 00:09:40,726
to the entire asset, well one
example of that is metadata


198
00:09:40,726 --> 00:09:42,566
that only applies to
a particular track,


199
00:09:42,636 --> 00:09:45,976
so for this example we have
a special label attached


200
00:09:45,976 --> 00:09:49,506
to our subtitle track called
SDH, that stands for Subtitles


201
00:09:49,506 --> 00:09:51,336
for the Deaf or Hard of Hearing


202
00:09:51,866 --> 00:09:56,616
and that's basically just a
more rich form of subtitles


203
00:09:57,196 --> 00:09:59,956
that includes things like
labeling who's talking


204
00:10:00,176 --> 00:10:01,956
and mentioning sound effects


205
00:10:01,956 --> 00:10:04,056
that are vital to
the understanding.


206
00:10:04,056 --> 00:10:09,416
We talked a little bit more
about SDH and accessibility


207
00:10:09,416 --> 00:10:11,956
in general last year in our
"Preparing and Presenting Media


208
00:10:11,956 --> 00:10:14,766
for Accessibility" talk so check
that one out for more details.


209
00:10:14,766 --> 00:10:16,076
For the purposes of this talk,


210
00:10:16,416 --> 00:10:18,886
just know that to get
this SDH label here,


211
00:10:19,106 --> 00:10:21,446
it involves setting
track-specific metadata.


212
00:10:21,936 --> 00:10:23,816
So let's talk about
how you actually find


213
00:10:23,816 --> 00:10:25,806
out if your track has
this metadata in it,


214
00:10:26,356 --> 00:10:29,166
well you're going
to use AVAsset track


215
00:10:29,466 --> 00:10:31,586
and it has pretty much
the exact same API


216
00:10:31,586 --> 00:10:32,976
as AVAsset for reading metadata.


217
00:10:33,196 --> 00:10:35,486
You have your metadata property;


218
00:10:35,896 --> 00:10:39,736
you have your metadataForFormat
method and so if we want


219
00:10:39,736 --> 00:10:42,676
to find all the tagged
characteristics that are


220
00:10:42,676 --> 00:10:46,526
in an asset track, we're
going to ask the track


221
00:10:46,526 --> 00:10:49,186
for its metadata for the
FormatQuickTimeUserData.


222
00:10:49,866 --> 00:10:50,996
Once we have that we use


223
00:10:51,036 --> 00:10:54,556
that same filtering method we
saw before in order to get all


224
00:10:54,556 --> 00:10:58,506
of the items that
have the identifier,


225
00:10:58,506 --> 00:11:00,806
QuickTimeUserDataTagged
Characteristic.


226
00:11:00,916 --> 00:11:05,136
So this is one example of tagged
characteristics is the SDH


227
00:11:05,256 --> 00:11:07,726
that I just talked about
and it's the payload


228
00:11:07,726 --> 00:11:09,986
of the metadata items
that tells you what kind


229
00:11:09,986 --> 00:11:12,316
of tagged characteristic
you're dealing with.


230
00:11:12,716 --> 00:11:14,726
We'll talk a little bit
more detail about SDH


231
00:11:14,726 --> 00:11:18,156
and how you author it
in just a little bit.


232
00:11:18,586 --> 00:11:20,326
So going back to our list


233
00:11:20,326 --> 00:11:23,506
of identifiers you might
have noticed some patterns


234
00:11:23,506 --> 00:11:24,636
if you were looking closely.


235
00:11:25,856 --> 00:11:29,796
Each of these groups has
their own version of a title


236
00:11:29,796 --> 00:11:31,496
or a song name or
something like that.


237
00:11:32,116 --> 00:11:36,036
We noticed that and come up
with our own special kind


238
00:11:36,036 --> 00:11:38,226
of identifier called
a CommonIdentifier


239
00:11:38,776 --> 00:11:41,296
which can be used when
you want to look up, say,


240
00:11:41,296 --> 00:11:45,236
for this example a title without
caring exactly how it's stored


241
00:11:45,236 --> 00:11:45,966
in your file.


242
00:11:46,616 --> 00:11:49,946
Same for copyright here; we
also have a common identifier


243
00:11:49,946 --> 00:11:51,116
that represents copyright.


244
00:11:51,756 --> 00:11:53,566
These are not the only
common identifiers;


245
00:11:53,646 --> 00:11:56,766
there's a whole list of them
but these are just two examples.


246
00:11:57,256 --> 00:11:59,366
So if we go back to our
example where we're looking


247
00:11:59,366 --> 00:12:02,526
for our iTunes song name,
if we don't actually care


248
00:12:02,526 --> 00:12:06,496
that the title of our asset
is stored as iTunes metadata


249
00:12:06,496 --> 00:12:09,356
and we just want a title so
we can display it somewhere,


250
00:12:09,646 --> 00:12:12,606
you can ask the asset for
its array of commonMetadata


251
00:12:12,606 --> 00:12:14,216
and this is all the
metadata items


252
00:12:14,536 --> 00:12:18,816
that can be represented
using a common identifier.


253
00:12:19,296 --> 00:12:22,176
Then you use that same filtering
method we've been using


254
00:12:22,176 --> 00:12:23,956
to filter down to just the ones


255
00:12:23,956 --> 00:12:25,696
that have the
CommonIdentifierTitle


256
00:12:26,076 --> 00:12:28,996
and you can go from
there with your title.


257
00:12:28,996 --> 00:12:30,216
Also worth noting is


258
00:12:30,276 --> 00:12:34,976
that AVAssetTrack has the
same property, commonMetadata,


259
00:12:34,976 --> 00:12:36,886
so you can do the same
thing over there as well.


260
00:12:37,426 --> 00:12:40,856
So that is your brief
introduction


261
00:12:40,856 --> 00:12:43,076
to inspecting metadata
with AVFoundation.


262
00:12:43,316 --> 00:12:45,186
Let's talk a little
bit about authoring.


263
00:12:45,186 --> 00:12:48,096
If you want to make your own
files that have say location


264
00:12:48,096 --> 00:12:52,156
or iTunes metadata in them, we
have several different classes


265
00:12:52,156 --> 00:12:55,766
that can write movie
files, AVAssetExportSession,


266
00:12:55,766 --> 00:12:59,396
AVAssetWriter and the capture
movie and audio files outputs


267
00:12:59,446 --> 00:13:02,576
and these all have the exact
same redirect property called


268
00:13:02,576 --> 00:13:03,426
simply, metadata.


269
00:13:03,426 --> 00:13:06,126
So you give an array of
metadata items and then


270
00:13:06,126 --> 00:13:07,706
that will be written
out to the file.


271
00:13:08,476 --> 00:13:11,246
Similarly for track-specific
metadata


272
00:13:11,246 --> 00:13:12,806
like those tagged
characteristics,


273
00:13:13,186 --> 00:13:15,426
you can use an AVAssetWriter
input


274
00:13:15,656 --> 00:13:18,176
which also has the
exact same property.


275
00:13:19,166 --> 00:13:23,696
Now you are not limited to
just writing out metadata


276
00:13:23,696 --> 00:13:25,636
that you got from somewhere
else, like another file


277
00:13:25,636 --> 00:13:27,146
through the APIs
we've been looking at.


278
00:13:27,386 --> 00:13:29,336
You can also create
your own metadata items


279
00:13:29,336 --> 00:13:32,006
with a mutable subclass
of metadataItem.


280
00:13:32,356 --> 00:13:34,996
And as you might expect, this
just has read/write properties


281
00:13:34,996 --> 00:13:38,536
for all of the properties
in AVMetadataItem.


282
00:13:39,056 --> 00:13:42,546
So if we use an example of
writing a subtitle track


283
00:13:42,546 --> 00:13:46,666
that is marked as SDH, well
it's actually two different tag


284
00:13:46,666 --> 00:13:48,266
characteristics that
you have to use


285
00:13:48,376 --> 00:13:50,566
and so we'll create two
different metadata items,


286
00:13:50,936 --> 00:13:55,556
set both of their identifiers
to the identifier we just saw,


287
00:13:55,776 --> 00:13:58,106
the QuickTimeUserData
tag characteristic,


288
00:13:58,616 --> 00:14:00,206
but one of them will
set the value


289
00:14:00,206 --> 00:14:02,816
to TranscribesSpokenDialogue
ForAccessibility


290
00:14:02,816 --> 00:14:05,116
and the other will be
DescribesMusicAndSound


291
00:14:05,116 --> 00:14:06,066
ForAccessibility.


292
00:14:06,476 --> 00:14:09,556
Then we get the subtitle
AssetWriterInputthat's going


293
00:14:09,556 --> 00:14:13,486
to write our subtitle track and
set that array of the two items


294
00:14:13,486 --> 00:14:15,126
on our asset writer input.


295
00:14:15,336 --> 00:14:18,486
So that's how you would
author a subtitle track


296
00:14:18,596 --> 00:14:20,516
that is marked as SDH.


297
00:14:20,516 --> 00:14:23,506
Just one example of
using tag characteristics


298
00:14:23,776 --> 00:14:25,316
in AVMutableMetadataItem.


299
00:14:26,116 --> 00:14:29,646
Special note about
AVAssetExportSession:


300
00:14:30,776 --> 00:14:33,896
by default the ExportSession
is actually going to take any


301
00:14:33,896 --> 00:14:37,006
of the metadata that's
in the source asset


302
00:14:37,006 --> 00:14:37,976
that you're exporting.


303
00:14:38,236 --> 00:14:40,696
It's going to copy that
over to the output file.


304
00:14:41,326 --> 00:14:43,656
Now that's not the case
if you set metadata


305
00:14:43,656 --> 00:14:44,906
on its metadata property.


306
00:14:45,396 --> 00:14:47,386
That will be the signal
to tell the ExportSession


307
00:14:47,386 --> 00:14:49,516
to ignore the metadata
in the source file


308
00:14:49,726 --> 00:14:52,506
and instead write just what
you put on the property.


309
00:14:52,956 --> 00:14:55,836
So if you want to do
augmentation of the metadata


310
00:14:55,836 --> 00:14:59,146
or some other sort of
modification you'll want to grab


311
00:14:59,146 --> 00:15:01,926
that array of metadata,
make a mutable copy


312
00:15:01,926 --> 00:15:04,216
and do any adjustments
that you want and then set


313
00:15:04,216 --> 00:15:05,956
that on the metadata property.


314
00:15:06,046 --> 00:15:08,316
So that's just a quick
note about ExportSession.


315
00:15:08,676 --> 00:15:12,536
The last note about authoring
metadata is HTTP Live Streaming,


316
00:15:12,536 --> 00:15:16,006
this is actually a new
feature in iOS 8, OS X Yosemite


317
00:15:16,086 --> 00:15:20,496
and you can use a new tag
called session-data tag


318
00:15:20,496 --> 00:15:23,396
in your playlist, which
has two required fields:


319
00:15:23,426 --> 00:15:26,226
the data ID which is a
lot like our identifiers


320
00:15:26,226 --> 00:15:29,926
that we're talking about, a URI
which can point to the payload


321
00:15:29,926 --> 00:15:33,376
or a value which directly
specifies the payload and,


322
00:15:33,536 --> 00:15:35,276
optionally, some
language information.


323
00:15:35,276 --> 00:15:37,316
So here's an example
that shows very similar


324
00:15:37,316 --> 00:15:38,986
to what we saw before
with the titles


325
00:15:38,986 --> 00:15:42,316
in two different languages but
this is the markup you'd use


326
00:15:42,316 --> 00:15:44,356
for HTTP Live Streaming.


327
00:15:44,896 --> 00:15:47,586
So for more information
on reading


328
00:15:47,586 --> 00:15:49,896
and writing metadata we
do have some sample code,


329
00:15:50,106 --> 00:15:53,806
it's called AVmetadataeditor
and for more information


330
00:15:53,806 --> 00:15:58,416
about the details of writing
HTTP Live Streaming metadata see


331
00:15:58,416 --> 00:16:00,326
the documents at this URL.


332
00:16:00,436 --> 00:16:03,466
All right so that is your
crash course in metadata


333
00:16:03,466 --> 00:16:07,206
in AVFoundation, our next
topic is timed metadata.


334
00:16:08,046 --> 00:16:10,716
So timed metadata, although I
mentioned we have new features,


335
00:16:10,716 --> 00:16:11,946
it is not a new concept.


336
00:16:12,806 --> 00:16:15,426
We supported the notion of
chapters for quite some time


337
00:16:15,716 --> 00:16:18,166
and conceptually chapters
are just an example


338
00:16:18,166 --> 00:16:19,096
of times metadata.


339
00:16:19,436 --> 00:16:22,616
Each of these chapter markers
is just a piece of metadata


340
00:16:22,896 --> 00:16:26,446
that is describing
a particular range


341
00:16:26,446 --> 00:16:27,836
of the timeline of the movie.


342
00:16:28,496 --> 00:16:31,096
That's all that timed
metadata is,


343
00:16:31,146 --> 00:16:34,336
it's just metadata associated
with a range of time.


344
00:16:34,886 --> 00:16:40,076
So similarly, with our
dynamic location example,


345
00:16:40,586 --> 00:16:43,336
we have the path that's drawn
here that's really just composed


346
00:16:43,336 --> 00:16:45,216
of a number of pieces


347
00:16:45,216 --> 00:16:48,106
of metadata indicating
the current location,


348
00:16:48,306 --> 00:16:50,766
each one of them associated
with a particular time


349
00:16:50,956 --> 00:16:52,036
in the movie's timeline.


350
00:16:52,036 --> 00:16:55,496
So to demonstrate
QuickTime Player's features


351
00:16:55,496 --> 00:16:57,896
with dynamic location
in Yosemite,


352
00:16:57,896 --> 00:16:59,456
I want to bring my
colleague, Shalini,


353
00:16:59,456 --> 00:17:00,606
up to the stage for a demo.


354
00:17:01,566 --> 00:17:04,226
>> Hi, I'm here to
demonstrate how to read


355
00:17:04,266 --> 00:17:06,726
and play back metadata
using QuickTime Player.


356
00:17:07,876 --> 00:17:11,406
Here I have a movie file
which has both audio and video


357
00:17:11,665 --> 00:17:14,906
and timed locations data
stored in a different track.


358
00:17:15,685 --> 00:17:17,996
So now if I bring this
up in QuickTime Player,


359
00:17:19,146 --> 00:17:21,455
this is the usual UI
for audio and video.


360
00:17:22,205 --> 00:17:23,896
New in OS X Yosemite:


361
00:17:24,286 --> 00:17:28,165
in the Movie Inspector
you can see a map view


362
00:17:28,906 --> 00:17:30,746
if your movie file
has location data.


363
00:17:31,226 --> 00:17:33,966
Your map view is presented
along with the route


364
00:17:34,566 --> 00:17:35,996
where you have recorded
this video.


365
00:17:37,186 --> 00:17:39,716
So here the blue line
indicates the path


366
00:17:39,716 --> 00:17:43,496
where we recorded the video and
the red pin is an indication


367
00:17:43,556 --> 00:17:45,736
of the current location
or the location


368
00:17:46,166 --> 00:17:50,076
on the timeline of the movie.


369
00:17:50,076 --> 00:17:52,556
So if I zoom in a little
bit and start play,


370
00:17:52,906 --> 00:17:57,996
you can see as the movie
progresses the pin's location is


371
00:17:57,996 --> 00:18:00,976
being updated to be in
sync with the video.


372
00:18:01,576 --> 00:18:05,456
I can drag the scrubber around


373
00:18:06,076 --> 00:18:08,116
and you can see the pin
moving back and forth.


374
00:18:09,466 --> 00:18:15,296
I can also go and click
at any point in the map


375
00:18:15,296 --> 00:18:18,376
and you see the video seek
to that location to present


376
00:18:18,436 --> 00:18:21,576
where your video was when
you were at that location.


377
00:18:22,876 --> 00:18:26,966
This is map view in QuickTime
Player on OS X Yosemite.


378
00:18:27,866 --> 00:18:28,516
>> Thank you, Shalini.


379
00:18:29,266 --> 00:18:31,386
So let's talk about
what we just saw there.


380
00:18:32,256 --> 00:18:35,676
So that location information
was stored as timed metadata


381
00:18:35,676 --> 00:18:38,866
in the file and in order to
have QuickTime Player draw


382
00:18:38,866 --> 00:18:43,436
that information on the map, we
use AVAssetReader to read all


383
00:18:43,436 --> 00:18:46,906
of the location information
from that asset.


384
00:18:46,906 --> 00:18:50,436
And because timed metadata
is stored in its own track,


385
00:18:50,746 --> 00:18:53,436
we use an
AVAssetReaderTrackOutput to read


386
00:18:53,436 --> 00:18:56,836
that data and we use a new
class called AVAssetReaderOutput


387
00:18:56,836 --> 00:19:00,066
MetadataAdaptor that knows how
to give us that data in the


388
00:19:00,066 --> 00:19:02,946
from of a class called
AVTimedMetadataGroup.


389
00:19:03,356 --> 00:19:05,636
Then from there we
can grab each location


390
00:19:05,636 --> 00:19:07,066
and draw that path on the map.


391
00:19:08,116 --> 00:19:11,376
So AVTimedMetadataGroup
is a very simple class.


392
00:19:11,746 --> 00:19:13,476
It's really just
these two properties:


393
00:19:13,476 --> 00:19:16,806
an array of metadata items
combined with a time range


394
00:19:16,806 --> 00:19:20,106
that describes where in the
movie that data applies.


395
00:19:20,646 --> 00:19:25,006
So to see a little bit of
code for using AssetReader


396
00:19:25,006 --> 00:19:27,016
for this purpose, the
first thing you want


397
00:19:27,016 --> 00:19:28,186
to do is find the track


398
00:19:28,386 --> 00:19:31,616
that contains your location
information and we'll talk more


399
00:19:31,616 --> 00:19:33,286
about how to do that
in just a second.


400
00:19:33,676 --> 00:19:37,586
Then you use that track to
create an AssetReaderTrackOutput


401
00:19:38,156 --> 00:19:39,736
and you use nil output settings


402
00:19:40,276 --> 00:19:42,796
and then you'll create
your metadataAdaptor


403
00:19:42,796 --> 00:19:43,916
with that trackOutput.


404
00:19:44,626 --> 00:19:47,756
And then, in a loop we just
take your metadataAdaptor


405
00:19:47,756 --> 00:19:50,866
and call the
nextTimedMetadataGroup method


406
00:19:51,156 --> 00:19:53,606
over and over again, doing
something with each piece


407
00:19:53,606 --> 00:19:55,496
of data, like drawing
it on the map


408
00:19:55,666 --> 00:19:57,446
until that method returns nil.


409
00:19:57,446 --> 00:19:58,946
Then you know there's
no more data to draw.


410
00:19:58,946 --> 00:20:02,656
So in terms of finding
the right track to read,


411
00:20:03,096 --> 00:20:05,616
the way you're going to do
that is by examining the tracks


412
00:20:05,616 --> 00:20:08,276
in your asset and looking
through the format description


413
00:20:08,276 --> 00:20:10,796
of each track to find the
identifiers you're looking for.


414
00:20:10,876 --> 00:20:13,626
So you first start
by getting the tracks


415
00:20:13,626 --> 00:20:15,826
with the MediaTypeMetadata
and then for each


416
00:20:15,826 --> 00:20:17,806
of those tracks you're
going to loop through all


417
00:20:17,806 --> 00:20:20,986
of its format descriptions,
usually there's only one


418
00:20:21,316 --> 00:20:24,016
and for each format description
you're going to grab its list


419
00:20:24,016 --> 00:20:26,916
of identifiers using this
function and check whether


420
00:20:26,916 --> 00:20:28,596
that identifier array
contains the identifier you're


421
00:20:28,596 --> 00:20:28,976
looking for.


422
00:20:29,176 --> 00:20:30,226
In this case we're looking


423
00:20:30,226 --> 00:20:34,966
for the location
ISO 6709 identifier.


424
00:20:34,966 --> 00:20:37,516
So once we've found it we're
good to go and we can resume


425
00:20:37,516 --> 00:20:39,016
with the code on
the previous slide.


426
00:20:39,566 --> 00:20:42,296
So that's how QuickTime
Player is drawing the map


427
00:20:42,296 --> 00:20:45,046
or drawing the path on the
map before you start playback.


428
00:20:45,676 --> 00:20:48,256
The other thing that QuickTime
Player does, as you saw,


429
00:20:48,256 --> 00:20:50,886
is it can update the current
location while you're doing


430
00:20:50,886 --> 00:20:53,456
playback or even scrubbing
around and the way it does


431
00:20:53,526 --> 00:20:57,246
that while it's already playing
the asset using an AVPlayerItem


432
00:20:57,556 --> 00:20:59,556
and we're going to
use a new class called


433
00:20:59,556 --> 00:21:03,456
AVPlayerItemMetadataOutput that
you attach to your PlayerItem,


434
00:21:03,766 --> 00:21:06,196
which also notes how to
vend this data in the form


435
00:21:06,196 --> 00:21:07,406
of TimedMetadataGroups.


436
00:21:07,706 --> 00:21:10,456
But unlike the asset reader,
instead of getting all the data


437
00:21:10,456 --> 00:21:12,196
up front you're going
to be getting it piece


438
00:21:12,196 --> 00:21:13,936
by piece as the movie plays.


439
00:21:14,436 --> 00:21:16,526
So a little bit of code,


440
00:21:16,826 --> 00:21:18,856
you first create your
metadata output using the


441
00:21:18,856 --> 00:21:20,356
initWithIdentifiers method


442
00:21:20,586 --> 00:21:23,956
and in this case we're only
interested in metadata that has


443
00:21:23,956 --> 00:21:27,096
that location identifier so
that's all we're going to get


444
00:21:27,096 --> 00:21:28,436
by opting into this way.


445
00:21:29,086 --> 00:21:31,646
Then you create a
delegate that you define


446
00:21:31,916 --> 00:21:32,816
and that's what's going


447
00:21:32,816 --> 00:21:35,416
to receive the metadata
during playback and you set


448
00:21:35,416 --> 00:21:36,516
that delegate on your output


449
00:21:36,516 --> 00:21:40,256
and tell us what cue you
want us to send the data on.


450
00:21:41,476 --> 00:21:45,376
Then you create or grab your
AVPlayerItem and call addOutput


451
00:21:45,376 --> 00:21:48,296
to attach your output, to attach
your output to the playerItem


452
00:21:48,456 --> 00:21:52,676
and finally make your player
and associate your item


453
00:21:52,676 --> 00:21:55,106
with the player as the current
item and start playback.


454
00:21:55,596 --> 00:21:58,106
It's important to get the
smoothest playback experience


455
00:21:58,106 --> 00:22:01,116
possible, we highly recommend
that you do all of this sort


456
00:22:01,116 --> 00:22:03,466
of setup work before
you start playback


457
00:22:03,466 --> 00:22:05,636
or even attach the
item to the player.


458
00:22:06,186 --> 00:22:12,266
So a little bit of look at
what your delegate method might


459
00:22:12,266 --> 00:22:12,796
look like.


460
00:22:13,316 --> 00:22:15,966
There's only one delegate
method; it's the metadataOutput,


461
00:22:15,966 --> 00:22:19,146
didOutputTimedMetadataGroups,
fromPlayerItemTrack method.


462
00:22:19,196 --> 00:22:21,536
And the first thing you
want to do is grab an item


463
00:22:21,536 --> 00:22:23,336
that you can get your
payload data from.


464
00:22:23,666 --> 00:22:25,046
In this case, to
keep things simple,


465
00:22:25,046 --> 00:22:27,956
I'm just grabbing the first item
from the first group but keep


466
00:22:27,956 --> 00:22:29,636
in mind there could
be multiple items,


467
00:22:29,636 --> 00:22:31,066
there could even
be multiple groups.


468
00:22:31,426 --> 00:22:33,446
One reason there could
be multiple groups given


469
00:22:33,446 --> 00:22:38,456
to this method is that the
metadata output will keep track


470
00:22:38,456 --> 00:22:41,216
of whether the metadata
is coming faster


471
00:22:41,216 --> 00:22:43,736
than you're processing it and,
if it is, it will start to batch


472
00:22:43,736 --> 00:22:46,706
that up and give you
the metadata in batches


473
00:22:46,706 --> 00:22:48,696
when you're done with the
previous batch of metadata.


474
00:22:49,306 --> 00:22:51,916
So moving on with your
item; you're going


475
00:22:51,916 --> 00:22:55,076
to do this
LoadValueAsynchronouslyForKeys


476
00:22:55,116 --> 00:22:56,556
dance that we talked
about before.


477
00:22:56,786 --> 00:22:59,576
In this case, we're
interested in the value


478
00:22:59,826 --> 00:23:01,386
and data type properties
so we're going


479
00:23:01,386 --> 00:23:02,196
to load both of those.


480
00:23:02,716 --> 00:23:05,336
I've admitted the error
checking for brevity here


481
00:23:05,336 --> 00:23:07,326
which you'll probably want
to do that error checking


482
00:23:07,326 --> 00:23:08,496
like we had in the other slide.


483
00:23:09,126 --> 00:23:12,966
And once we have the completion
handler we can ask the item


484
00:23:12,966 --> 00:23:16,276
for its data type and make
sure that's the data type we're


485
00:23:16,276 --> 00:23:18,816
prepared to handle, in this
case my code only knows how


486
00:23:18,816 --> 00:23:23,096
to handle location information
in ISO 6709 format so we got


487
00:23:23,096 --> 00:23:26,416
to make sure that's the right
data type and from there we go


488
00:23:26,416 --> 00:23:28,146
and dispatch our code
to the main thread


489
00:23:28,146 --> 00:23:29,566
that will update our UI.


490
00:23:29,856 --> 00:23:34,966
So that's how QuickTime Player
is updating the location


491
00:23:35,396 --> 00:23:36,726
metadata during playback.


492
00:23:37,366 --> 00:23:40,506
Of course this is not the
first API that we have offered


493
00:23:40,506 --> 00:23:42,466
for reading timed
metadata during playback.


494
00:23:43,196 --> 00:23:46,096
There is an existing
property called timedMetadata


495
00:23:46,096 --> 00:23:48,516
on AVPlayerItem but
I'm here to say


496
00:23:48,516 --> 00:23:50,276
that the
AVPlayerItemMetadataOutput


497
00:23:50,276 --> 00:23:54,196
replaces that property for
all of these use cases.


498
00:23:55,386 --> 00:23:57,686
Now we're not deprecating
the property yet


499
00:23:57,966 --> 00:24:01,066
but we do recommend, if
you're new to timed metadata,


500
00:24:01,066 --> 00:24:03,356
just adopt the metadataOutput


501
00:24:03,356 --> 00:24:04,626
and not worry about
the property.


502
00:24:05,126 --> 00:24:09,066
If you're already using the
property version we do recommend


503
00:24:09,066 --> 00:24:12,726
that you move over but just you
know that you should make sure


504
00:24:12,726 --> 00:24:16,206
that your code is working
properly after that transition,


505
00:24:16,446 --> 00:24:17,506
in particular I'll point


506
00:24:17,506 --> 00:24:21,596
out that the metadataOutput
will give you, for certain kinds


507
00:24:21,596 --> 00:24:26,026
of HLS content, will give
more specific identifiers


508
00:24:26,366 --> 00:24:27,926
than the old property did.


509
00:24:27,926 --> 00:24:30,556
So just make sure your code
is prepared to handle that.


510
00:24:31,386 --> 00:24:35,536
The last topic on reading
timed metadata is Chapters.


511
00:24:36,066 --> 00:24:38,386
Chapters, like I said, have
been supported for some time;


512
00:24:38,386 --> 00:24:39,816
they even have their own API:


513
00:24:40,336 --> 00:24:43,076
chapterMetadataGroupsBest
MatchingPreferredLanguages.


514
00:24:43,146 --> 00:24:44,766
This is on AVAsset.


515
00:24:45,636 --> 00:24:48,926
This will give you an array
of timed metadata groups


516
00:24:49,296 --> 00:24:52,286
that contain items
with the identifier,


517
00:24:52,286 --> 00:24:55,766
QuickTimeUserDataChapter,
and we've supported this


518
00:24:55,766 --> 00:24:59,686
for some time for QuickTime
movie files and M4Vs and,


519
00:24:59,686 --> 00:25:05,776
new in iOS 8 is the-and OS X
Yosemite-is support for chapters


520
00:25:05,776 --> 00:25:08,936
in HTTP Live Streams
as well as MP3 files.


521
00:25:09,176 --> 00:25:10,356
And I'll tell you more about how


522
00:25:10,356 --> 00:25:13,766
to author those HLS chapters
in just a little bit.


523
00:25:14,566 --> 00:25:17,516
So for more information,
we have some sample code


524
00:25:17,516 --> 00:25:20,916
that does approximately what
QuickTime Player is doing,


525
00:25:21,416 --> 00:25:24,326
where it can show your
location during play back.


526
00:25:24,756 --> 00:25:28,716
We also have a previous session
about AssetReader that goes


527
00:25:28,716 --> 00:25:31,736
into much more detail than I did
here, called "Working with Media


528
00:25:31,736 --> 00:25:34,476
in AVFoundation" from 2011.


529
00:25:34,506 --> 00:25:36,836
So that's how you read and
play back timed metadata.


530
00:25:37,636 --> 00:25:40,776
Our next timed metadata topic
is how you can create your own


531
00:25:40,776 --> 00:25:42,536
movies that contain
timed metadata.


532
00:25:43,116 --> 00:25:45,056
We saw the screenshot
before and I mentioned


533
00:25:45,106 --> 00:25:48,796
that these annotations are
stored as timed metadata and,


534
00:25:48,876 --> 00:25:51,696
to show you this demo app, I'd
like to invite Shalini back


535
00:25:51,696 --> 00:25:53,396
up on stage to demo it.


536
00:25:54,216 --> 00:25:56,396
>> This time let's
look at an app on how


537
00:25:56,396 --> 00:25:59,816
to author your own custom
metadata movie files.


538
00:26:00,356 --> 00:26:04,266
Here I have a video and if I
would like to share some notes


539
00:26:04,476 --> 00:26:07,706
with my friend, who is good
at fixing colors in a movie,


540
00:26:07,936 --> 00:26:11,246
I can now do that
within the app.


541
00:26:11,516 --> 00:26:15,066
To add annotations, I
use a two-finger gesture,


542
00:26:15,306 --> 00:26:22,096
I can use a pinch gesture to
resize and then add a comment


543
00:26:24,156 --> 00:26:28,266
which is enough for my whoever
looks at the video later


544
00:26:28,396 --> 00:26:31,786
to fix the colors there
and then I begin playback.


545
00:26:33,296 --> 00:26:36,366
And as playback progresses,
I track the circle


546
00:26:37,116 --> 00:26:39,246
to where I want this
to be fixed.


547
00:26:39,926 --> 00:26:43,206
And now that I have this
annotation and I can write it


548
00:26:43,206 --> 00:26:46,626
out along with the audio and
video to do that, I hit "export"


549
00:26:47,996 --> 00:26:51,076
and now we see an AV
player view controller


550
00:26:51,076 --> 00:26:54,256
which shows the exported
movie along with the metadata


551
00:26:54,256 --> 00:26:55,216
which was written to it.


552
00:26:55,586 --> 00:27:00,556
So if I start playback you see
the annotation is moving along


553
00:27:00,556 --> 00:27:04,476
the timeline in the
part in which I traced.


554
00:27:04,906 --> 00:27:09,996
So if I scrub back in time you
can see the annotation moving.


555
00:27:10,336 --> 00:27:12,646
You might wonder that
the annotation is baked


556
00:27:12,646 --> 00:27:14,126
into the video frame; it is not.


557
00:27:15,346 --> 00:27:19,286
It is being rendered real-time
using AVPlayerItemMetadataOutput


558
00:27:19,886 --> 00:27:23,586
and you can change the color
or the font of the annotation.


559
00:27:24,016 --> 00:27:27,356
So if I begin playback, you
see the rendering is happening


560
00:27:27,356 --> 00:27:31,266
in real time.


561
00:27:31,266 --> 00:27:34,656
That's AVTimedAnnotationWriter,
we have this available


562
00:27:34,656 --> 00:27:36,846
as a sample code
as well, thank you.


563
00:27:36,846 --> 00:27:38,946
>> So that was a
great demonstration


564
00:27:38,946 --> 00:27:42,836
of not only the playback part
of it but also how to write


565
00:27:42,836 --> 00:27:45,206
that data into the file,
so let's take a look at how


566
00:27:45,206 --> 00:27:46,056
that was accomplished.


567
00:27:46,056 --> 00:27:50,296
So we're going to use an
AVAssetWriter to write the file


568
00:27:50,626 --> 00:27:53,596
and we're going to use an
AVAssetWriterInput in order


569
00:27:53,596 --> 00:27:55,816
to write that metadata
track to the file.


570
00:27:55,816 --> 00:27:58,056
Just like the reader side,


571
00:27:58,336 --> 00:28:01,736
the writer has a new class
that's a metadataAdaptor


572
00:28:02,266 --> 00:28:04,976
and that class knows how
to interpret instances


573
00:28:04,976 --> 00:28:08,286
of AVTimedMetadataGroup and
write that into the file.


574
00:28:08,286 --> 00:28:12,866
See a little bit of code;
first thing we're going


575
00:28:12,866 --> 00:28:15,666
to do is create our
AssetWriter Input.


576
00:28:15,666 --> 00:28:20,046
We're going to use the media
type AVMediaTypeMetadata,


577
00:28:20,286 --> 00:28:23,026
once again nil outputSettings
and we're going to have


578
00:28:23,026 --> 00:28:26,396
to provide a clue to
the source format, well,


579
00:28:26,396 --> 00:28:28,496
the format of the data that
we're going to be appending.


580
00:28:28,496 --> 00:28:30,086
We'll talk more about this


581
00:28:30,176 --> 00:28:32,126
and why it's required
on the next slide.


582
00:28:32,736 --> 00:28:34,676
Then you simply create
your metadataAdaptor


583
00:28:34,676 --> 00:28:38,526
with the reference to that
input and, as you generate


584
00:28:38,526 --> 00:28:40,506
or receive your timed
metadata groups,


585
00:28:40,906 --> 00:28:43,666
you simply use the
appendTimedMetadataGroup method


586
00:28:43,926 --> 00:28:47,416
to continue to append those
and write them to the file.


587
00:28:47,646 --> 00:28:50,306
So what's the deal with
that source format thing.


588
00:28:50,856 --> 00:28:55,476
Well, it turns out in order
for AVAssetWriter to be able


589
00:28:55,476 --> 00:28:59,036
to write your metadata in the
most efficient way possible,


590
00:28:59,196 --> 00:29:01,566
it needs to know up
front exactly what kind


591
00:29:01,566 --> 00:29:02,936
of metadata it is
going to be writing.


592
00:29:03,756 --> 00:29:08,556
This will result in the most
lowest storage overhead in terms


593
00:29:08,556 --> 00:29:10,176
of the number of bytes
your file takes up


594
00:29:10,176 --> 00:29:13,376
and it also has a effect
on how efficient it is


595
00:29:13,376 --> 00:29:15,546
to play back this
kind of contents.


596
00:29:15,546 --> 00:29:17,116
You don't want to be
using too much power


597
00:29:17,426 --> 00:29:19,436
when you're playing this
kind of content back.


598
00:29:19,606 --> 00:29:21,486
So you do have some
options in terms


599
00:29:21,486 --> 00:29:24,046
of how you actually construct
one of these format hits.


600
00:29:24,796 --> 00:29:25,586
If you're reading


601
00:29:25,586 --> 00:29:28,566
from AVAssetReader you
can actually ask the track


602
00:29:28,566 --> 00:29:30,306
that you are reading
from to give you its list


603
00:29:30,306 --> 00:29:33,136
of format descriptions
and use one of those.


604
00:29:33,936 --> 00:29:36,806
If you're creating the metadata
group yourself or getting it


605
00:29:36,806 --> 00:29:40,386
from some other source then
you can use a new method called


606
00:29:40,386 --> 00:29:43,446
copyFormatDescription that
will give you back an instance


607
00:29:43,446 --> 00:29:46,166
of CM format description that
will do this job for you.


608
00:29:46,776 --> 00:29:49,086
It's important to note that
if you go this route you need


609
00:29:49,086 --> 00:29:50,376
to make sure that the contents


610
00:29:50,376 --> 00:29:53,276
of your metadata group
are comprehensive in terms


611
00:29:53,276 --> 00:29:55,766
of it containing
every combination


612
00:29:55,766 --> 00:29:58,926
of identifier data
type and language tag


613
00:29:58,926 --> 00:30:00,496
that you are going
to be appending.


614
00:30:00,746 --> 00:30:03,946
That is. it contains an item
with each of those combinations.


615
00:30:04,626 --> 00:30:07,976
Of course, since the CM format
description is a CF type,


616
00:30:08,266 --> 00:30:10,006
you'll need a CFRelease
app when you're done.


617
00:30:10,746 --> 00:30:12,846
Of course, there's one
more way you can do this:


618
00:30:12,846 --> 00:30:15,166
you can create the format
description directly using


619
00:30:15,166 --> 00:30:16,336
CoreMedia APIs.


620
00:30:16,666 --> 00:30:21,016
And here you use this long name
CMMetadataFormatDescription


621
00:30:21,016 --> 00:30:23,496
CreateWith
MetadataSpecifications function.


622
00:30:23,536 --> 00:30:26,386
You're going to pass in
the metadataType box.


623
00:30:26,386 --> 00:30:28,096
That's the sort of
metadata we've been talking


624
00:30:28,096 --> 00:30:29,976
about this whole time
with timed metadata.


625
00:30:31,056 --> 00:30:34,006
And these metadata
specifications it's just an


626
00:30:34,006 --> 00:30:35,086
array of dictionaries.


627
00:30:35,576 --> 00:30:38,626
Each dictionary contains those
combinations I was talking


628
00:30:38,626 --> 00:30:39,306
about before.


629
00:30:39,306 --> 00:30:43,226
The identifier dataType and
optionally extended language tag


630
00:30:43,526 --> 00:30:46,736
so you want to make one of
these metadata specifications


631
00:30:46,736 --> 00:30:49,386
dictionaries for each
combination you plan to append.


632
00:30:50,556 --> 00:30:54,106
So the one thing that was not
obvious about that demo is


633
00:30:54,236 --> 00:30:58,016
that we're actually writing
metadata timed metadata


634
00:30:58,016 --> 00:31:00,656
that describes one
particular other track.


635
00:31:01,106 --> 00:31:03,116
So for the example
of these annotations,


636
00:31:03,116 --> 00:31:06,076
we're really just talking about
the video track of the movie


637
00:31:06,076 --> 00:31:08,656
and not the sound or
anything else like that.


638
00:31:08,716 --> 00:31:13,766
So just like we had a way of
making track-specific metadata


639
00:31:13,766 --> 00:31:15,256
that applied to the
entire track,


640
00:31:15,256 --> 00:31:16,526
with those tagged
characteristics


641
00:31:16,526 --> 00:31:18,806
that we saw before, you
also have the ability


642
00:31:18,806 --> 00:31:21,466
to formerly mark
your metadata track


643
00:31:21,676 --> 00:31:24,066
as describing one
particular other track.


644
00:31:24,686 --> 00:31:27,246
You do that with the
addTrackAssociationWith


645
00:31:27,246 --> 00:31:31,326
TrackOfInput method using as the
parameter the AssetWriterInput


646
00:31:31,326 --> 00:31:33,016
that you are using to
write your video track.


647
00:31:33,226 --> 00:31:35,406
And your receiver is the
input that you are using


648
00:31:35,406 --> 00:31:36,546
to write your metadata track.


649
00:31:36,936 --> 00:31:39,126
You use the
AssociationTypeMetadataReferent.


650
00:31:39,916 --> 00:31:43,186
So that's how your create
metadata that's timed


651
00:31:43,186 --> 00:31:45,326
but also specific to
a particular track.


652
00:31:46,096 --> 00:31:49,326
The next thing we did that was
interesting in that demo is


653
00:31:49,326 --> 00:31:51,706
that we actually used our
own custom identifiers.


654
00:31:51,706 --> 00:31:53,986
So we had that big list
of built in identifiers.


655
00:31:54,246 --> 00:31:55,406
Well, you don't have
to use those;


656
00:31:55,406 --> 00:31:56,636
you can actually build your own


657
00:31:57,036 --> 00:31:59,836
and as I mentioned before an
identifier is just a combination


658
00:31:59,836 --> 00:32:02,866
of key space and key and
it has a particular format:


659
00:32:02,866 --> 00:32:04,936
it's just a string but it
is in a particular format


660
00:32:05,246 --> 00:32:07,336
so to help you make your
own custom identifiers,


661
00:32:07,336 --> 00:32:10,256
we have this method,
identifierFor Key, and keySpace,


662
00:32:10,326 --> 00:32:14,086
it's a class method
on AVMetadataItem.


663
00:32:14,086 --> 00:32:17,476
There are some rules to
follow: your key space needs


664
00:32:17,476 --> 00:32:19,326
to be four characters
long if you want to use it


665
00:32:19,326 --> 00:32:20,376
for timed metadata


666
00:32:20,696 --> 00:32:22,996
so we actually recommend you
use our built-in key space,


667
00:32:23,106 --> 00:32:24,836
the QuickTimeMetadata keySpace.


668
00:32:25,376 --> 00:32:28,816
We also highly recommend
you use reverse DNS notation


669
00:32:28,816 --> 00:32:30,776
for your custom keys
to avoid collisions


670
00:32:31,026 --> 00:32:32,636
with other kinds of metadata.


671
00:32:32,806 --> 00:32:36,256
So a brief code snippet you
can see you can simply use this


672
00:32:36,256 --> 00:32:39,666
method to make your custom
identifier and then set


673
00:32:39,666 --> 00:32:42,536
that on the identifier property
of your mutableMetadataItem.


674
00:32:42,936 --> 00:32:46,936
So in addition to custom
identifiers you can also create


675
00:32:46,936 --> 00:32:48,346
your own custom data types.


676
00:32:49,966 --> 00:32:52,746
So we're all familiar by now,
through this presentation,


677
00:32:52,746 --> 00:32:55,026
with some of the built-in
data types that we defined;


678
00:32:55,256 --> 00:32:56,306
there's a lot more than these


679
00:32:56,306 --> 00:32:58,266
but we've been using these
quite heavily already.


680
00:32:58,266 --> 00:33:00,256
These are really useful


681
00:33:00,256 --> 00:33:02,656
but sometimes you want
your data type information


682
00:33:02,656 --> 00:33:05,896
to express more, maybe about
the domain you're working in,


683
00:33:06,616 --> 00:33:08,956
so if you are doing a serial
number or a bar code kind


684
00:33:08,956 --> 00:33:10,156
of thing you might want


685
00:33:10,156 --> 00:33:13,236
to define a data type that's
this sort of serial number


686
00:33:13,236 --> 00:33:17,196
as string data type or
barcode image as JPEG data type


687
00:33:17,326 --> 00:33:19,066
so you have more
specific information


688
00:33:19,066 --> 00:33:20,966
about what your metadata
actually contains.


689
00:33:21,576 --> 00:33:26,136
The way that this works is,
you have to tell us exactly how


690
00:33:26,136 --> 00:33:30,596
to serialize that custom
data type and the way you do


691
00:33:30,596 --> 00:33:33,516
that is you tell us that your
custom data type conforms to one


692
00:33:33,516 --> 00:33:34,836
of our built-in data types.


693
00:33:35,346 --> 00:33:37,796
So in this case the
serial number conforms


694
00:33:37,846 --> 00:33:41,736
to the UTF8 data type so under
the hood it's UTF8 string,


695
00:33:41,736 --> 00:33:44,986
but we know that it really
represents a serial number


696
00:33:45,276 --> 00:33:46,716
and the same with
the barcode image.


697
00:33:47,126 --> 00:33:49,926
The way that you do this is you
register your data type using


698
00:33:49,926 --> 00:33:54,266
the CMMetadataDataTypeRegistry
RegisterDataType function that's


699
00:33:54,266 --> 00:33:55,256
defined in Core Media.


700
00:33:55,776 --> 00:33:58,716
You can't create your
own custom base types


701
00:33:59,206 --> 00:34:03,816
but you can create your own
custom type that conforms


702
00:34:03,816 --> 00:34:06,556
to our raw data built-in type


703
00:34:06,556 --> 00:34:10,146
if your data type really is
just a custom sequence of bytes.


704
00:34:11,396 --> 00:34:14,235
So there are some rules
to using AVAssetWriter


705
00:34:14,386 --> 00:34:17,056
for writing timed metadata.


706
00:34:17,056 --> 00:34:20,755
Most importantly, every metadata
item that you append has


707
00:34:20,755 --> 00:34:24,226
to have non-nil values for
identifier, data type and value.


708
00:34:24,226 --> 00:34:28,835
Your identifier has to conform
to the format that we specify,


709
00:34:28,835 --> 00:34:31,076
so we highly recommend
using that utility method


710
00:34:31,076 --> 00:34:31,856
that we just talked about.


711
00:34:32,666 --> 00:34:34,985
The value has to be
compatible with the data type


712
00:34:35,045 --> 00:34:39,106
so you can tell us that your
NSString value is an UTF8 string


713
00:34:39,396 --> 00:34:40,335
but don't try telling us


714
00:34:40,386 --> 00:34:43,806
that your custom class is a UTF8
string because we won't know how


715
00:34:43,806 --> 00:34:47,056
to serialize that properly
and the AssetWriter will fail.


716
00:34:47,516 --> 00:34:50,755
As I mentioned before, you have
to create your AssetWriterInput


717
00:34:50,755 --> 00:34:53,056
with a format hint and
that must be comprehensive


718
00:34:53,416 --> 00:34:54,666
and we described that before.


719
00:34:54,766 --> 00:34:57,646
So the last topic
about AssetWriter


720
00:34:57,646 --> 00:35:01,886
and timed metadata is a recipe
for creating your own movies


721
00:35:02,156 --> 00:35:04,206
that have the same sort
of dynamic location


722
00:35:04,206 --> 00:35:05,676
that we've seen a
couple of times already.


723
00:35:06,706 --> 00:35:09,706
To do this, you can
use AVCapture audio


724
00:35:09,706 --> 00:35:12,456
and video data outputs
and target that data


725
00:35:12,456 --> 00:35:15,436
at twin instances of
AssetWriterInput and,


726
00:35:15,506 --> 00:35:19,736
at the same time, grab
information from Core Location


727
00:35:19,736 --> 00:35:22,266
that represents the location
information and write


728
00:35:22,266 --> 00:35:23,906
that to its own
AssetWriterInput.


729
00:35:24,766 --> 00:35:28,676
For more detail about how to do
that we've actually implemented


730
00:35:28,676 --> 00:35:30,546
that and made it
available as sample code,


731
00:35:30,846 --> 00:35:34,436
so see AVCaptureLocation if you
want to make your own movies


732
00:35:34,436 --> 00:35:35,986
that contain dynamic location.


733
00:35:36,626 --> 00:35:39,116
We also have sample code
as Shalini mentioned


734
00:35:39,116 --> 00:35:40,416
for the demo we just showed you,


735
00:35:40,686 --> 00:35:42,776
that's called
AVTimedAnnotationWriter.


736
00:35:43,106 --> 00:35:45,376
And, of course, for more
information about AssetWriter


737
00:35:45,376 --> 00:35:48,146
in general, see that same
talk I referenced earlier:


738
00:35:48,146 --> 00:35:50,326
"Working with Media
in AVFoundation".


739
00:35:51,096 --> 00:35:54,726
Last two quick topics about
timed metadata: ExportSession.


740
00:35:55,366 --> 00:35:57,966
Just like we've said the
asset ExportSession will


741
00:35:57,966 --> 00:36:01,456
by default pass through any
of your metadata that applies


742
00:36:01,456 --> 00:36:04,436
to the entire asset or
entire track, it will pass


743
00:36:04,496 --> 00:36:06,356
that through, copy it
to the output file.


744
00:36:06,626 --> 00:36:09,376
It will do the same thing with
timed metadata that exists


745
00:36:09,376 --> 00:36:11,126
in the source file provided


746
00:36:11,126 --> 00:36:13,786
that your destination file
type is QuickTime Movie.


747
00:36:14,046 --> 00:36:16,916
We'll talk more about file
types in just a little bit


748
00:36:17,316 --> 00:36:20,596
but basically ExportSession
behaves exactly


749
00:36:20,596 --> 00:36:21,466
as you would expect.


750
00:36:22,526 --> 00:36:27,396
In our last timed metadata
authoring topic is HTTP Live


751
00:36:27,396 --> 00:36:30,536
Streaming chapters so if
you want to author chapters


752
00:36:30,536 --> 00:36:34,556
in your HLS stream, you can use
the session-data tag we talked


753
00:36:34,556 --> 00:36:40,386
about earlier and the special
data ID, com.apple.hls.chapters.


754
00:36:40,826 --> 00:36:43,296
Your URL should point
to a JSON file


755
00:36:43,476 --> 00:36:47,346
that describes the chapter
information for that stream and,


756
00:36:47,346 --> 00:36:50,066
of course for more detail
on this, see that same link


757
00:36:50,066 --> 00:36:53,166
that I referenced earlier
for HTTP Live Streaming.


758
00:36:53,446 --> 00:36:55,716
All right, so that
is timed metadata,


759
00:36:55,716 --> 00:36:57,326
our next topic is privacy.


760
00:36:58,066 --> 00:37:00,546
Why is privacy important
in this context?


761
00:37:00,546 --> 00:37:04,446
Well, any time that you
are writing your users data


762
00:37:04,446 --> 00:37:07,856
to a file you need to
be at least considerate


763
00:37:07,856 --> 00:37:12,546
about their privacy and be aware
that the metadata that you write


764
00:37:12,546 --> 00:37:15,926
out to these movie files can
contain user identifiable


765
00:37:15,926 --> 00:37:19,176
information, the most obvious
example of that is location.


766
00:37:19,836 --> 00:37:23,696
And so because movie files
can be distributed and we want


767
00:37:23,696 --> 00:37:25,446
to protect the privacy
of our users,


768
00:37:26,136 --> 00:37:29,776
for our built-in sharing
services, we do our best


769
00:37:29,776 --> 00:37:33,276
to strip out any potentially
user identifiable information,


770
00:37:33,336 --> 00:37:36,356
such as this location and we
recommend that you do the same.


771
00:37:36,686 --> 00:37:38,046
So we've given you a utility


772
00:37:38,046 --> 00:37:41,736
for that called
AVMetadataItemFilter.


773
00:37:42,276 --> 00:37:44,716
Right now there is only one
filter that we make available


774
00:37:44,716 --> 00:37:46,316
but it is geared
towards privacy,


775
00:37:46,316 --> 00:37:49,686
it is the metadata item filter
for sharing and that will strip


776
00:37:49,686 --> 00:37:52,716
out any of this sort of
user identifying information


777
00:37:52,716 --> 00:37:55,086
that we're talking about;
location is only one example.


778
00:37:55,086 --> 00:37:57,986
But it will also strip out
anything it doesn't recognize,


779
00:37:58,016 --> 00:37:59,186
because it doesn't know whether


780
00:37:59,186 --> 00:38:02,126
that might contain user
identifiable information.


781
00:38:02,126 --> 00:38:05,356
So that includes any
metadata that uses identifiers


782
00:38:05,356 --> 00:38:06,536
that you define yourself.


783
00:38:07,306 --> 00:38:11,476
It will leave in some things
like metadata that's important


784
00:38:11,476 --> 00:38:12,656
to the structure of the movie


785
00:38:12,656 --> 00:38:14,746
and chapters are the
best example of that,


786
00:38:15,166 --> 00:38:18,166
and also any commercial
related data like your Apple ID.


787
00:38:19,406 --> 00:38:23,776
So to use the MetadataItemFilter
you're going to first


788
00:38:23,776 --> 00:38:27,986
of all create your filter and
feed it your original array


789
00:38:27,986 --> 00:38:31,296
of metadata items using
this metadataItemsFromArray


790
00:38:31,296 --> 00:38:33,656
filteredByMetadataItemFilter
method.


791
00:38:33,966 --> 00:38:36,696
This is a companion to that
other filtering method based


792
00:38:36,696 --> 00:38:38,406
on identifiers we've
been using all day


793
00:38:39,276 --> 00:38:41,666
and then once you have
your filtered array


794
00:38:41,746 --> 00:38:45,686
of metadata items just set
that on your AssetWriter


795
00:38:45,686 --> 00:38:47,566
or ExportSession as
you normally would.


796
00:38:47,916 --> 00:38:49,976
Well actually I mentioned
ExportSession


797
00:38:49,976 --> 00:38:53,006
but things can be simple if
you're using the ExportSession


798
00:38:53,006 --> 00:38:56,646
and only want to
copy the metadata


799
00:38:56,766 --> 00:38:59,046
from the source asset
and not add your own.


800
00:38:59,356 --> 00:39:01,606
You just set the filter
on the ExportSession


801
00:39:01,606 --> 00:39:03,326
and it will actually do
the filtering for you,


802
00:39:03,976 --> 00:39:07,186
this will filter both
static and timed metadata


803
00:39:07,186 --> 00:39:10,726
but it will only filter the
metadata from the source asset.


804
00:39:10,726 --> 00:39:13,236
If you set your own metadata
on the metadata property,


805
00:39:13,596 --> 00:39:16,146
it won't filter that for you;
you'll need to do the process


806
00:39:16,146 --> 00:39:19,246
that I just described of
doing the filtering yourself.


807
00:39:19,246 --> 00:39:20,726
The only other thing
to keep in mind is


808
00:39:20,726 --> 00:39:22,456
that the export may
take more time


809
00:39:22,696 --> 00:39:25,496
when the filter is being used
because it has to go through


810
00:39:25,496 --> 00:39:27,356
and examine all of
the metadata items.


811
00:39:27,876 --> 00:39:29,396
So that's privacy.


812
00:39:30,196 --> 00:39:34,016
Our last section of the talk
today is some assorted best


813
00:39:34,016 --> 00:39:36,366
practices when you are
writing your own files


814
00:39:36,416 --> 00:39:37,636
that contain metadata.


815
00:39:39,536 --> 00:39:42,436
First up, what if you're
writing timed metadata


816
00:39:42,676 --> 00:39:45,986
and you have multiple
streams of metadata


817
00:39:46,136 --> 00:39:47,686
that use different identifiers.


818
00:39:48,256 --> 00:39:50,146
How do you get those
into the same file?


819
00:39:50,146 --> 00:39:52,986
Well, we actually have the
situation in the demo app,


820
00:39:53,206 --> 00:39:56,266
we have that circle is comprised
of two different pieces


821
00:39:56,266 --> 00:39:59,096
of information, the
position and the radius.


822
00:39:59,676 --> 00:40:02,406
So we're representing these


823
00:40:02,406 --> 00:40:04,826
and the demo app is two
distinct streams of metadata.


824
00:40:05,366 --> 00:40:07,666
And so the most obvious way
I can think of to get this


825
00:40:07,666 --> 00:40:12,816
into a file is to use two
different AVAssetWriterInputs,


826
00:40:13,186 --> 00:40:15,386
which result in having
two metadata tracks


827
00:40:15,386 --> 00:40:17,046
in the output file,
pretty simple.


828
00:40:17,466 --> 00:40:20,336
But there is another
way you can do it,


829
00:40:20,336 --> 00:40:23,966
you could instead combine those
two different types of metadata


830
00:40:23,966 --> 00:40:26,816
into one timed metadata
group and write


831
00:40:26,816 --> 00:40:28,806
that to a single
AssetWriterInput


832
00:40:28,806 --> 00:40:31,766
and that will result in
only one metadata track


833
00:40:31,766 --> 00:40:34,576
in the output file that contains
multiple different kinds


834
00:40:34,576 --> 00:40:35,366
of identifiers.


835
00:40:35,876 --> 00:40:38,426
There are some advantages to
this approach, not the least


836
00:40:38,426 --> 00:40:41,316
of which is it can result
in lower storage overhead


837
00:40:41,626 --> 00:40:44,036
and therefore as we always
see more efficient playback.


838
00:40:45,136 --> 00:40:48,246
But there are of course
pros and cons to everything.


839
00:40:48,696 --> 00:40:50,976
So you'll definitely want
to consider combining


840
00:40:51,216 --> 00:40:53,436
into one track your
different metadata


841
00:40:53,616 --> 00:40:55,716
if they are used
together during playback


842
00:40:56,316 --> 00:40:58,296
and they have identical timing.


843
00:40:58,296 --> 00:41:00,616
This is definitely the case
with the example we just saw


844
00:41:00,616 --> 00:41:03,046
with the circle center
and the circle radius.


845
00:41:03,866 --> 00:41:07,096
If these are not true then
you might not want to combine.


846
00:41:07,096 --> 00:41:09,346
And in fact one instance where
you definitely do not want


847
00:41:09,346 --> 00:41:12,596
to combine, is if
you have one type


848
00:41:12,596 --> 00:41:15,856
of metadata that's associated
with another track in the file,


849
00:41:15,856 --> 00:41:18,346
so that's like our
annotations are associated


850
00:41:18,416 --> 00:41:20,736
with the video track, but
then you have another type


851
00:41:20,736 --> 00:41:23,466
of metadata like location
that is associated


852
00:41:23,466 --> 00:41:24,756
with the entire asset.


853
00:41:24,756 --> 00:41:27,316
You don't want to combine
those into one track,


854
00:41:27,316 --> 00:41:31,836
otherwise your location in that
example will become mistakenly


855
00:41:31,836 --> 00:41:33,406
associated with just
the video track,


856
00:41:33,406 --> 00:41:34,746
and that's not what you want.


857
00:41:35,006 --> 00:41:36,076
So that's how to deal


858
00:41:36,076 --> 00:41:38,156
with multiple streams
of timed metadata.


859
00:41:38,956 --> 00:41:43,466
Next topic is duration of
your timed metadata groups,


860
00:41:44,216 --> 00:41:45,766
when you get a timed
metadata group


861
00:41:45,766 --> 00:41:47,526
from AVFoundation
it's always going


862
00:41:47,526 --> 00:41:51,466
to have a fully formed
time range.


863
00:41:51,756 --> 00:41:54,456
So that means it will have
a start time and a duration.


864
00:41:54,846 --> 00:41:57,426
We actually recommend when you
make your own timed metadata


865
00:41:57,426 --> 00:41:59,906
groups for a pending
with the AVAssetWriter


866
00:42:00,196 --> 00:42:02,236
that you don't bother
giving us a duration.


867
00:42:02,636 --> 00:42:05,466
And to see how that works,
here's an example of a group


868
00:42:05,466 --> 00:42:08,266
that starts at time 0 but
it doesn't have a duration


869
00:42:08,266 --> 00:42:10,326
so how do we know when it ends?


870
00:42:10,326 --> 00:42:12,536
Well, of course we'll wait
until you append the next one


871
00:42:12,536 --> 00:42:15,596
and then we'll say that,
"Okay, the end time


872
00:42:15,596 --> 00:42:17,696
of the first group is the same


873
00:42:17,696 --> 00:42:19,386
as the start time
of the next one."


874
00:42:19,906 --> 00:42:22,206
So this ensures that your
metadata track is going


875
00:42:22,206 --> 00:42:27,636
to have a continuous stream of
contiguous metadata and we think


876
00:42:27,636 --> 00:42:30,266
that for most cases this is the
best way to store your metadata.


877
00:42:31,036 --> 00:42:32,916
The way you accomplish this is,


878
00:42:32,916 --> 00:42:34,356
when you're making
your time range,


879
00:42:34,576 --> 00:42:38,356
you just use KCMTimeInvalid
for your duration


880
00:42:38,656 --> 00:42:39,956
and we'll take care of the rest.


881
00:42:40,576 --> 00:42:43,846
We do recognize that there are
cases where you might not want


882
00:42:43,846 --> 00:42:46,536
to have contiguous
metadata, you might want


883
00:42:46,536 --> 00:42:50,246
to author an explicit gap into
your metadata stream and so,


884
00:42:50,246 --> 00:42:52,246
for that, our recommendation
is that you give us


885
00:42:52,656 --> 00:42:55,596
in the middle there a group
that contains zero items.


886
00:42:55,746 --> 00:42:58,526
This is the best way to
author a gap in the metadata.


887
00:42:58,526 --> 00:43:03,086
And you can see we just do that
by presenting an empty array


888
00:43:03,166 --> 00:43:05,076
when we're creating our
timed metadata group.


889
00:43:05,506 --> 00:43:08,636
Notice that we're still
using KCMTimeInvalid


890
00:43:08,636 --> 00:43:09,876
for our duration here.


891
00:43:10,326 --> 00:43:13,406
Just tell us when the beginning
of the metadata silence,


892
00:43:13,406 --> 00:43:16,976
so to speak, is and we'll figure
out how long it lasts based


893
00:43:16,976 --> 00:43:19,966
on when you append your
next non-empty group.


894
00:43:20,566 --> 00:43:22,756
So that's how you write
gaps in your metadata.


895
00:43:23,446 --> 00:43:24,946
Our last best practice,


896
00:43:25,516 --> 00:43:27,346
I mentioned output
file type before


897
00:43:27,636 --> 00:43:29,876
and here's the longer
explanation.


898
00:43:30,916 --> 00:43:32,366
Well, AssetWriter


899
00:43:32,366 --> 00:43:35,166
and AssetExportSessions
support writing


900
00:43:35,166 --> 00:43:37,566
to a wide variety of file types.


901
00:43:39,626 --> 00:43:42,376
You've got QuickTime
movie, MPEG4, and all sorts


902
00:43:42,376 --> 00:43:44,916
of other kind of file types


903
00:43:45,406 --> 00:43:49,426
and those file types can carry
different kinds of metadata;


904
00:43:49,496 --> 00:43:51,746
some have more restrictions
than others about what kind


905
00:43:51,746 --> 00:43:53,526
of metadata can go
into that file type.


906
00:43:53,526 --> 00:43:57,246
So the easiest situation, say
if you have an ExportSession


907
00:43:57,486 --> 00:44:01,546
and you're going from one,
from the same file type


908
00:44:01,546 --> 00:44:02,946
as your source to the output,


909
00:44:02,946 --> 00:44:05,436
so for this example they're
both QuickTime movie files.


910
00:44:06,186 --> 00:44:08,426
This is the easiest
way to ensure that all


911
00:44:08,426 --> 00:44:11,206
of that data is actually going
to make it into the output file.


912
00:44:11,706 --> 00:44:14,476
If instead you're using a
different output file type,


913
00:44:14,726 --> 00:44:16,536
like MPEG4 in this example,


914
00:44:16,836 --> 00:44:19,626
then some different things
are going to have to happen.


915
00:44:19,966 --> 00:44:22,306
You notice those last few
items didn't quite make it


916
00:44:22,306 --> 00:44:23,276
into the output file;


917
00:44:23,386 --> 00:44:25,626
it's because they have no
equivalent representation


918
00:44:25,806 --> 00:44:27,716
that works with an MPEG4 file.


919
00:44:28,576 --> 00:44:30,126
If you're looking
closely you'll also notice


920
00:44:30,126 --> 00:44:32,356
that those top two
items have changed,


921
00:44:32,886 --> 00:44:36,136
although they sound very similar
they are slightly different


922
00:44:36,136 --> 00:44:38,406
identifiers because that's
the kind of identifier


923
00:44:38,406 --> 00:44:39,396
that works with MPEG4.


924
00:44:39,396 --> 00:44:43,836
So both AssetExportSession and
AssetWriter will do the sort


925
00:44:43,836 --> 00:44:44,906
of three step process.


926
00:44:45,346 --> 00:44:48,876
First, they'll try to pass
that data through directly


927
00:44:49,196 --> 00:44:52,986
if possible and, if not, they'll
try to convert the identifier


928
00:44:52,986 --> 00:44:54,706
into an equivalent
representation


929
00:44:54,866 --> 00:44:56,006
in the output file type.


930
00:44:56,626 --> 00:44:59,816
If neither of those work, we
have no choice but to just drop


931
00:44:59,816 --> 00:45:01,636
that piece of metadata
on the floor.


932
00:45:01,636 --> 00:45:05,766
So in terms of guidance on how
to choose an output file type,


933
00:45:06,126 --> 00:45:07,776
well, my two recommendations
are,


934
00:45:08,266 --> 00:45:12,876
if you are using say an
ExportSession to copy all


935
00:45:12,966 --> 00:45:17,426
of the metadata, timed or
otherwise, from the source asset


936
00:45:17,426 --> 00:45:20,336
to your destination file,
the best way is to try


937
00:45:20,336 --> 00:45:22,766
and use the same file type
that you started with,


938
00:45:22,876 --> 00:45:25,716
and if you don't know what the
file type is you can use the


939
00:45:25,716 --> 00:45:27,776
NSURLTypeIdentifierKey
to find out.


940
00:45:28,276 --> 00:45:32,746
You can also always use
the QuickTime Movie file


941
00:45:32,746 --> 00:45:37,216
because that is going to
have the greatest chance


942
00:45:37,216 --> 00:45:39,726
of supporting your metadata
no matter where it came from.


943
00:45:39,966 --> 00:45:42,416
If AVFoundation supports
it, there's a good chance


944
00:45:42,416 --> 00:45:44,496
that it will be supported
by the QuickTime movie file.


945
00:45:44,826 --> 00:45:46,936
Of course, this is the only way


946
00:45:46,936 --> 00:45:48,446
if you're writing
timed metadata,


947
00:45:48,716 --> 00:45:51,326
to get your timed
metadata into a file is


948
00:45:51,366 --> 00:45:53,816
to use QuickTime Movie file;
it's the only file form


949
00:45:53,816 --> 00:45:55,216
that supports it right now.


950
00:45:55,856 --> 00:45:58,596
Of course good advice is always


951
00:45:58,596 --> 00:46:00,186
to check the results,
no matter what.


952
00:46:00,886 --> 00:46:04,246
Check that your output files
contain the kind of metadata


953
00:46:04,246 --> 00:46:06,436
that you expect, all the
metadata that you expect


954
00:46:07,046 --> 00:46:09,036
and you can choose to
use some of the APIs


955
00:46:09,146 --> 00:46:10,656
that we've already
talked about if you want


956
00:46:10,656 --> 00:46:11,546
to do that at runtime.


957
00:46:12,926 --> 00:46:16,106
Some guidance if that
doesn't end up being the case:


958
00:46:16,196 --> 00:46:18,486
if you don't get all the
metadata that you expect, well,


959
00:46:18,486 --> 00:46:20,106
you can try to do the
conversion yourself.


960
00:46:20,536 --> 00:46:23,316
Especially if you have a
custom identifier and are going


961
00:46:23,316 --> 00:46:25,936
to a file type that doesn't
support your custom identifier,


962
00:46:26,456 --> 00:46:29,386
take a look at that long list
of built-in identifiers we have


963
00:46:29,616 --> 00:46:31,746
and see if there is something
that's roughly equivalent


964
00:46:31,746 --> 00:46:33,546
to what you're trying
to store and you can do


965
00:46:33,546 --> 00:46:34,536
that conversion yourself.


966
00:46:35,226 --> 00:46:36,966
One particular example
I want to call


967
00:46:36,966 --> 00:46:39,886
out that involves only
built-in identifiers is


968
00:46:39,886 --> 00:46:42,936
when you're trying to
go from ID3 to iTunes,


969
00:46:43,246 --> 00:46:45,496
well AVFoundation
currently isn't going to do


970
00:46:45,496 --> 00:46:46,966
that conversion for you.


971
00:46:47,436 --> 00:46:49,366
But there's no reason you
couldn't do that yourself,


972
00:46:49,636 --> 00:46:52,386
so once again just take a look
at our long list of identifiers


973
00:46:52,626 --> 00:46:55,596
and match them up and do the
conversion in your own code.


974
00:46:56,956 --> 00:46:59,146
So that is the end of the talk.


975
00:46:59,496 --> 00:47:02,926
See what we covered: we talked
obviously a lot about metadata


976
00:47:02,926 --> 00:47:04,986
in AVFoundation,
we talked about all


977
00:47:04,986 --> 00:47:07,576
of the different classes
you can use for inspection,


978
00:47:07,816 --> 00:47:10,286
we talked about AVAsset
and AVMetadataItem


979
00:47:10,286 --> 00:47:12,806
and how those work
together and also authoring,


980
00:47:12,806 --> 00:47:15,266
we talked about the AssetWriter,


981
00:47:15,266 --> 00:47:18,376
the AssetExportSession even
briefly on the capture audio


982
00:47:18,376 --> 00:47:19,556
and movie file outputs.


983
00:47:20,406 --> 00:47:23,316
We dove into timed metadata,
including all the new features


984
00:47:23,316 --> 00:47:26,096
that enable things like
the dynamic location


985
00:47:26,316 --> 00:47:29,436
and your own timed metadata
like the annotation demo.


986
00:47:30,416 --> 00:47:33,016
We also talked about
privacy considerations


987
00:47:33,266 --> 00:47:36,136
and some best practices like how
to choose the right file type.


988
00:47:36,546 --> 00:47:40,146
So for more information, you
can contact our evangelism team


989
00:47:40,456 --> 00:47:41,826
or see our programing guide,


990
00:47:42,266 --> 00:47:44,586
there are some other
related sessions you might be


991
00:47:44,586 --> 00:47:45,186
interested in.


992
00:47:45,486 --> 00:47:47,226
If you missed this
morning's presentation


993
00:47:47,226 --> 00:47:48,926
on "Modern Media
Playback", you can catch


994
00:47:48,976 --> 00:47:50,566
that on the video recording.


995
00:47:51,016 --> 00:47:55,626
Tomorrow there is also a
camera capture talk focusing


996
00:47:55,626 --> 00:47:56,746
on manual controls.


997
00:47:57,266 --> 00:48:00,776
And on Thursday we'll have
a talk about direct access


998
00:48:00,896 --> 00:48:03,546
to video encoding and
decoding, which I'm sure a lot


999
00:48:03,546 --> 00:48:04,786
of you will be interested in.


1000
00:48:06,516 --> 00:48:13,440
[ Silence ]

