1
00:00:22,516 --> 00:00:25,886
[ Applause ]


2
00:00:26,386 --> 00:00:28,356
>> PETER TSOI: Hey, everyone.


3
00:00:28,416 --> 00:00:28,926
Good afternoon.


4
00:00:28,926 --> 00:00:31,606
And welcome to Advanced
Touch Input on iOS.


5
00:00:32,476 --> 00:00:33,256
My name is Peter.


6
00:00:33,566 --> 00:00:35,636
I work on the iOS
Performance team on Apple.


7
00:00:36,306 --> 00:00:39,236
Today with my friend
Jacob, from the UIKit team,


8
00:00:39,236 --> 00:00:41,116
we would like to tell
you a little bit more


9
00:00:41,386 --> 00:00:44,706
about how touch input works
on iOS and how you can use


10
00:00:44,706 --> 00:00:47,266
that information to make
your applications even more


11
00:00:47,266 --> 00:00:48,586
responsive to touch input.


12
00:00:49,576 --> 00:00:51,386
We've got a lot to
talk about today.


13
00:00:51,906 --> 00:00:56,016
As the previous slide alluded
to, reducing latency is the name


14
00:00:56,016 --> 00:00:57,396
of the game when it comes


15
00:00:57,526 --> 00:00:59,556
to making your applications
even more responsive.


16
00:00:59,556 --> 00:01:03,136
We will talk about what latency
is and why you should care


17
00:01:03,136 --> 00:01:04,696
about latency in
your application


18
00:01:05,135 --> 00:01:06,906
and latency in iOS as a whole.


19
00:01:08,046 --> 00:01:10,336
In order to discuss where
this latency comes from,


20
00:01:10,566 --> 00:01:14,306
we will discuss and dissect
the major pieces of iOS,


21
00:01:14,306 --> 00:01:16,106
which are responsible
for everything


22
00:01:16,106 --> 00:01:17,576
between handling
your touch input


23
00:01:17,966 --> 00:01:20,086
to drawing the pixels
underneath your finger


24
00:01:20,086 --> 00:01:21,336
in response to that touch.


25
00:01:22,506 --> 00:01:25,006
We have made a lot of
improvements to this system


26
00:01:25,176 --> 00:01:27,666
over the last year in iOS 9,
and we would like to tell you


27
00:01:27,666 --> 00:01:29,306
about the improvements
as well as some


28
00:01:29,306 --> 00:01:31,616
of the APIs you guys can
use to take advantage


29
00:01:31,616 --> 00:01:33,096
of all these improvements
we have made.


30
00:01:34,166 --> 00:01:36,586
And finally, we would like
to leave you with some tips


31
00:01:36,656 --> 00:01:39,846
and best practices about
how to find, diagnose,


32
00:01:40,116 --> 00:01:42,916
and fix the performance
bottlenecks in your application.


33
00:01:43,446 --> 00:01:45,886
So why should you care


34
00:01:46,146 --> 00:01:48,136
about reducing latency
in your application?


35
00:01:49,346 --> 00:01:51,856
Touch input on iOS is
built around the idea


36
00:01:51,856 --> 00:01:53,386
of direct manipulation.


37
00:01:53,846 --> 00:01:57,416
This is the idea that a user
is actually touching a physical


38
00:01:57,416 --> 00:01:59,826
object with their
finger and moving it


39
00:01:59,826 --> 00:02:00,926
around in a virtual space.


40
00:02:01,956 --> 00:02:06,076
For example, if a user was
trying to move this circle


41
00:02:06,076 --> 00:02:11,076
from point A to point B,
the expected result is


42
00:02:11,076 --> 00:02:13,866
that the circle feels glued
to the end of the finger.


43
00:02:14,836 --> 00:02:16,036
You'll notice that
in this example,


44
00:02:16,306 --> 00:02:19,466
the circle tracks very
precisely and responsively


45
00:02:19,836 --> 00:02:20,736
with the user's finger.


46
00:02:22,086 --> 00:02:24,556
However, as soon as
you reduce latency,


47
00:02:24,836 --> 00:02:26,936
or the lag between
when the finger moves


48
00:02:27,346 --> 00:02:29,866
and the circle moves,
this illusion


49
00:02:29,866 --> 00:02:31,836
of direct manipulation
starts to break down.


50
00:02:31,836 --> 00:02:33,806
In this case, you can see


51
00:02:33,806 --> 00:02:36,946
that the circle is following
the finger and it doesn't feel


52
00:02:36,946 --> 00:02:38,676
like you are moving it around
with your finger anymore.


53
00:02:40,056 --> 00:02:41,736
This effect is compounded


54
00:02:41,846 --> 00:02:43,416
when the user is
moving really quickly.


55
00:02:44,066 --> 00:02:47,236
In this case, the finger gets
a substantial distance away


56
00:02:47,236 --> 00:02:49,496
from the circle, and
it no longer feels


57
00:02:49,496 --> 00:02:51,456
like the finger is
glued to the circle,


58
00:02:51,636 --> 00:02:54,766
rather the circle is now playing
catch-up with the finger.


59
00:02:55,876 --> 00:03:01,516
So this type of latency affects
iOS as a whole, from everything


60
00:03:01,516 --> 00:03:03,946
from button presses to
moving objects around,


61
00:03:04,376 --> 00:03:06,826
to scrolling anything
even a web page.


62
00:03:07,836 --> 00:03:11,106
But we have identified a couple
of applications where increases


63
00:03:11,106 --> 00:03:13,136
in latency are even
more noticeable.


64
00:03:13,796 --> 00:03:15,686
One of these types


65
00:03:15,686 --> 00:03:17,806
of applications are
drawing applications.


66
00:03:18,456 --> 00:03:21,336
Not only is the artist then
distracted by the amount


67
00:03:21,336 --> 00:03:24,896
of distance between the end of
the line and a user's finger.


68
00:03:26,236 --> 00:03:29,856
Artists often rely on
quick, responsive updates


69
00:03:29,976 --> 00:03:33,386
to their application or to
the user interface in order


70
00:03:33,386 --> 00:03:36,476
to quickly adjust their
physical behaviors in order


71
00:03:36,476 --> 00:03:38,006
to get the result
they are going for.


72
00:03:39,086 --> 00:03:41,866
In addition, latency
in applications


73
00:03:41,896 --> 00:03:43,866
like games makes the
games harder to play,


74
00:03:44,596 --> 00:03:47,156
in effect the perceived
quality of your application.


75
00:03:48,696 --> 00:03:50,396
Where does this latency
come from?


76
00:03:50,396 --> 00:03:52,176
It comes from a lot
of different places.


77
00:03:52,626 --> 00:03:57,306
In order to discuss where
it's caused, we'll discuss all


78
00:03:57,306 --> 00:03:59,506
of the different parts
of the system involved


79
00:03:59,506 --> 00:04:02,716
in handling your touches and
drawing the touches in response.


80
00:04:04,156 --> 00:04:05,816
Throughout the next
portion of the talk,


81
00:04:05,816 --> 00:04:08,506
we will be relying heavily
on these pipeline diagrams.


82
00:04:08,866 --> 00:04:09,856
So let's make sure we are all


83
00:04:09,856 --> 00:04:11,456
on the same page as
to what they mean.


84
00:04:12,306 --> 00:04:14,516
Up on the screen, you
see five different boxes.


85
00:04:15,126 --> 00:04:17,286
Each of these boxes
represents the amount


86
00:04:17,286 --> 00:04:19,666
of time a frame is shown
on the display for.


87
00:04:19,666 --> 00:04:23,386
Our products refresh
the screen at 60 hertz


88
00:04:23,616 --> 00:04:24,846
or 60 times per second.


89
00:04:25,216 --> 00:04:27,796
So the amount of time
represented by each


90
00:04:27,796 --> 00:04:32,496
of these boxes is approximately
one-sixtieth of a second.


91
00:04:32,496 --> 00:04:36,836
You may hear me refer to each of
these boxes as a display frame,


92
00:04:37,076 --> 00:04:39,236
a display interval,
or a display cycle.


93
00:04:39,616 --> 00:04:42,026
They all mean the same thing.


94
00:04:42,246 --> 00:04:44,256
Now, the vertical
lines separating each


95
00:04:44,256 --> 00:04:46,496
of these boxes is
the display refresh.


96
00:04:46,826 --> 00:04:48,946
This is the point in
time where one frame


97
00:04:48,946 --> 00:04:51,776
on the display is swapped out
with the next one to be shown.


98
00:04:52,636 --> 00:04:56,066
You will hear me refer to this
as either the display refresh


99
00:04:56,156 --> 00:04:59,126
or the v-sync, again they
mean basically the same thing.


100
00:04:59,946 --> 00:05:02,306
The display refresh
is important in iOS


101
00:05:02,606 --> 00:05:06,896
because many important system
processes are kicked off


102
00:05:06,896 --> 00:05:09,116
or triggered by this
display refresh.


103
00:05:09,446 --> 00:05:11,596
So let's actually talk
about what's going


104
00:05:11,596 --> 00:05:12,946
on inside this pipeline.


105
00:05:13,296 --> 00:05:15,946
The first stage of the
pipeline is Multi-Touch.


106
00:05:16,586 --> 00:05:20,996
This is the process where the
hardware will scan the surface


107
00:05:20,996 --> 00:05:22,846
of the display looking
for touches.


108
00:05:23,876 --> 00:05:26,176
On most of our products,
this can take less


109
00:05:26,176 --> 00:05:30,036
than the entire display frame,
but on some of our products,


110
00:05:30,036 --> 00:05:32,536
it can take up to that
entire display frame.


111
00:05:33,006 --> 00:05:34,526
In order to symbolize
that, we will fill


112
00:05:34,526 --> 00:05:36,176
in the entire box
with this green box.


113
00:05:37,076 --> 00:05:42,316
Once Multi-Touch is finished
scanning this display


114
00:05:42,966 --> 00:05:46,626
and is finished filtering
out any of the noise


115
00:05:46,736 --> 00:05:48,586
which was present
on this screen,


116
00:05:49,346 --> 00:05:53,126
your UI application's UITouch
callback will be called near the


117
00:05:53,126 --> 00:05:56,206
beginning of the next
touch frame, usually right


118
00:05:56,206 --> 00:05:57,676
after a display refresh
has occurred.


119
00:05:58,526 --> 00:06:01,906
This is the point in time where
your application should respond


120
00:06:01,906 --> 00:06:04,526
to the touch inputs and,
in a drawing application,


121
00:06:04,966 --> 00:06:07,586
maybe plot the points and
connect the dots in between.


122
00:06:08,336 --> 00:06:11,136
You may want to do any smoothing
to make the line very smooth.


123
00:06:11,136 --> 00:06:14,156
In an application that
isn't a drawing application,


124
00:06:14,466 --> 00:06:16,866
this is where you would
respond to button presses


125
00:06:16,866 --> 00:06:21,076
or key presses, maybe create
views, view controllers


126
00:06:21,136 --> 00:06:22,356
and present them to the user.


127
00:06:23,216 --> 00:06:26,036
The amount of time spent here
is variable, but can take


128
00:06:26,036 --> 00:06:27,236
up to one display frame.


129
00:06:27,516 --> 00:06:29,306
So, again, I filled
in the entire box.


130
00:06:30,856 --> 00:06:33,636
Once your application is done
responding to the touch events


131
00:06:33,666 --> 00:06:35,766
and has updated the
state accordingly,


132
00:06:36,346 --> 00:06:39,796
Core Animation will wake up
at the next display refresh


133
00:06:40,256 --> 00:06:43,836
and begin translating
your views and your layers


134
00:06:44,476 --> 00:06:47,136
into GPU commands that can
be rendered by the GPU.


135
00:06:47,216 --> 00:06:51,086
You will notice that the
GPU does not have to wait


136
00:06:51,086 --> 00:06:52,956
until the next display
refresh to begin.


137
00:06:53,186 --> 00:06:54,776
It begins immediately as soon


138
00:06:54,776 --> 00:06:57,636
as Core Animation has
given it the instructions


139
00:06:57,636 --> 00:06:59,216
that it needs to
render the frame.


140
00:07:00,016 --> 00:07:03,296
Again, the time in these
stages is variable,


141
00:07:03,896 --> 00:07:07,266
based upon how complicated the
views in your application are.


142
00:07:08,406 --> 00:07:11,046
Finally, once the GPU has
finished rendering your frame,


143
00:07:11,446 --> 00:07:13,496
that frame is then
enqueued to be displayed


144
00:07:13,886 --> 00:07:16,716
on the display once the
next display refresh occurs.


145
00:07:17,316 --> 00:07:23,156
As you can tell, between sensing
your touch on the display,


146
00:07:23,386 --> 00:07:26,106
all the way through to drawing
it, can take several frames.


147
00:07:26,316 --> 00:07:27,846
In this case, it
takes four frames.


148
00:07:28,596 --> 00:07:29,506
So it's not instant.


149
00:07:30,846 --> 00:07:32,456
In addition, this is a pipeline.


150
00:07:32,796 --> 00:07:36,386
So other touches that may
occur while your application is


151
00:07:36,386 --> 00:07:38,816
processing that previous
touch can also be happening.


152
00:07:39,456 --> 00:07:40,826
These just go through
the process


153
00:07:40,826 --> 00:07:42,816
at different points
in the pipeline.


154
00:07:43,346 --> 00:07:46,656
Let's talk about what you as
a developer have control over.


155
00:07:47,226 --> 00:07:50,506
There are no APIs to alter the
behavior of the Multi-Touch


156
00:07:50,556 --> 00:07:51,996
or the display hardware layers.


157
00:07:52,336 --> 00:07:54,186
This is handled for
you by the system.


158
00:07:55,146 --> 00:07:56,886
You exercise indirect control


159
00:07:57,156 --> 00:08:00,626
over the Core Animation render
server and the GPU based


160
00:08:00,626 --> 00:08:03,066
on how complicated the views
in your application are.


161
00:08:03,456 --> 00:08:06,616
But you have almost complete
control over your application.


162
00:08:07,186 --> 00:08:08,576
So that's where we will begin.


163
00:08:09,346 --> 00:08:12,466
As I mentioned earlier,
this is the point


164
00:08:12,466 --> 00:08:14,476
where you update the
stay of your application


165
00:08:14,636 --> 00:08:16,276
in response to the touch inputs.


166
00:08:16,916 --> 00:08:19,016
For example, in a drawing
application, you plot the points


167
00:08:19,016 --> 00:08:21,206
and connect them,
or you create views


168
00:08:21,206 --> 00:08:22,426
in response to button presses.


169
00:08:22,906 --> 00:08:25,246
This also might be where
you issue your OpenGL


170
00:08:25,246 --> 00:08:25,926
or Metal commands.


171
00:08:26,206 --> 00:08:28,606
The amount of time
spent here is variable.


172
00:08:28,976 --> 00:08:32,356
You can optimize this to take
a smaller amount of time,


173
00:08:32,395 --> 00:08:35,316
and we encourage you to do
this, but you will notice


174
00:08:35,676 --> 00:08:37,765
that when we optimize
the application,


175
00:08:38,076 --> 00:08:41,796
Core Animation does not slide in
to fill in the space left behind


176
00:08:41,796 --> 00:08:44,116
by UIKit or your application.


177
00:08:45,326 --> 00:08:47,486
This is because of how updates


178
00:08:47,486 --> 00:08:50,456
to your views have worked
historically in the past on iOS.


179
00:08:51,636 --> 00:08:53,446
When you update the state
of your views on iOS,


180
00:08:53,756 --> 00:08:56,576
you can either explicitly
commit A CATransaction


181
00:08:57,296 --> 00:08:59,906
or UIKit will implicitly
generate one for you


182
00:09:00,306 --> 00:09:02,806
if you update the views
properties with the UIMethods.


183
00:09:03,506 --> 00:09:06,576
We will represent this
CATransaction commit


184
00:09:06,576 --> 00:09:07,356
with this red dot.


185
00:09:08,816 --> 00:09:11,756
Now, the reason why Core
Animation doesn't slide


186
00:09:11,756 --> 00:09:13,436
in to fill in the time is


187
00:09:13,436 --> 00:09:14,996
because your application
is allowed


188
00:09:15,226 --> 00:09:18,316
to update its state several
time during one display frame,


189
00:09:18,476 --> 00:09:21,016
in this case, symbolized
by the second dot.


190
00:09:22,006 --> 00:09:25,096
Now, in order to reduce the
amount of redundant work or work


191
00:09:25,096 --> 00:09:26,726
that will never be
shown on the display,


192
00:09:27,166 --> 00:09:31,496
Core Animation will batch
up all of your updates


193
00:09:31,496 --> 00:09:33,726
and render it once at
the display refresh.


194
00:09:34,106 --> 00:09:37,006
So we will only render
the combined state of both


195
00:09:37,006 --> 00:09:39,576
of those Core Animation
transactions.


196
00:09:39,956 --> 00:09:44,366
Once Core Animation decides
to snapshot your view


197
00:09:44,496 --> 00:09:48,646
at the display refresh, it
will begin translating all


198
00:09:48,646 --> 00:09:51,896
of the logical views and layers
that you have created for it


199
00:09:51,896 --> 00:09:54,346
into GPU commands that can
be rendered by the GPU.


200
00:09:54,996 --> 00:09:58,366
As I mentioned earlier, the
GPU starts immediately as soon


201
00:09:58,366 --> 00:10:00,026
as it has the necessary
instructions


202
00:10:00,026 --> 00:10:00,816
from Core Animation.


203
00:10:01,276 --> 00:10:04,786
So if you optimize the amount
of time spent in Core Animation


204
00:10:04,786 --> 00:10:07,796
or in the GPU, the GPU
will fill in the space


205
00:10:07,796 --> 00:10:09,806
that was left behind it.


206
00:10:10,106 --> 00:10:12,366
The view debugger in Xcode
is a very helpful way


207
00:10:12,366 --> 00:10:15,116
to understand how complicated
your view hierarchy is


208
00:10:15,416 --> 00:10:18,636
and a great way to find
views that you can take out


209
00:10:18,636 --> 00:10:20,406
and therefore optimize
your application.


210
00:10:22,006 --> 00:10:24,976
However, we recognize
the need for views


211
00:10:24,976 --> 00:10:26,146
that are very complicated,


212
00:10:26,376 --> 00:10:28,256
that can't possibly
be represented


213
00:10:28,256 --> 00:10:29,206
in one display frame.


214
00:10:30,296 --> 00:10:33,506
So the iOS pipeline is
flexible enough to handle that.


215
00:10:34,446 --> 00:10:35,626
If your application needs


216
00:10:35,626 --> 00:10:37,186
to spend additional
time rendering views,


217
00:10:37,316 --> 00:10:39,566
we can split the Core
Animation and GPU work


218
00:10:39,616 --> 00:10:41,236
over two display frames.


219
00:10:41,856 --> 00:10:43,966
Of course, this adds an
additional frame of latency,


220
00:10:44,196 --> 00:10:47,426
but you can still get 60 frames
per second smooth animations


221
00:10:47,756 --> 00:10:50,506
everywhere in your application,
with more complicated views.


222
00:10:51,556 --> 00:10:54,176
There is no manual trigger to go


223
00:10:54,176 --> 00:10:56,586
between the faster mode
and the slower mode.


224
00:10:56,946 --> 00:11:00,256
This, again, happens for you
and is arbitrated by the system.


225
00:11:00,746 --> 00:11:03,546
So it's important that we
understand what things can


226
00:11:03,546 --> 00:11:05,076
trigger you into the faster mode


227
00:11:05,326 --> 00:11:10,406
and what things can trigger
you into the slower mode.


228
00:11:10,406 --> 00:11:13,486
The faster mode is called double
buffering, and we call it this


229
00:11:13,486 --> 00:11:16,846
because there are two buffers,
one for the GPU to draw into,


230
00:11:17,026 --> 00:11:19,336
and one for the LCD
to show to the user.


231
00:11:20,126 --> 00:11:23,036
At the display refresh,
as you will recall,


232
00:11:23,036 --> 00:11:26,116
Core Animation grabs a buffer
for it and the GPU to use,


233
00:11:26,116 --> 00:11:28,746
and it will begin outputting
GPU commands for that frame.


234
00:11:29,506 --> 00:11:32,696
Once the GPU has those commands,
the GPU will begin rendering,


235
00:11:33,176 --> 00:11:36,116
and if the render completes
before the next display refresh


236
00:11:36,116 --> 00:11:40,216
has to occur, we enqueue
that frame for display


237
00:11:40,476 --> 00:11:41,716
at the next display refresh.


238
00:11:42,386 --> 00:11:43,896
Once we reach that
display refresh,


239
00:11:44,436 --> 00:11:46,416
the frame is then
swapped onto the screen


240
00:11:46,736 --> 00:11:48,886
and we begin the process
with the next frame.


241
00:11:49,876 --> 00:11:52,846
Again, the GPU will render
and then enqueue the frame


242
00:11:52,846 --> 00:11:54,466
for display at the
next display refresh.


243
00:11:55,036 --> 00:11:56,416
Once we hit that
display refresh,


244
00:11:56,716 --> 00:11:59,576
these two frames
will swap places,


245
00:11:59,576 --> 00:12:03,076
we will reclaim the green buffer
and continue this process,


246
00:12:03,216 --> 00:12:06,406
as long as your application has
views that it wants to render.


247
00:12:07,666 --> 00:12:08,796
Now, this is all fine and good.


248
00:12:08,856 --> 00:12:11,456
We have finished our Core
Animation and our GPU work


249
00:12:11,706 --> 00:12:12,746
within one display frame.


250
00:12:13,106 --> 00:12:14,056
We have good performance.


251
00:12:14,056 --> 00:12:17,576
But what happens if you
can't do all of this?


252
00:12:18,426 --> 00:12:19,616
If you can't do it in one frame?


253
00:12:20,256 --> 00:12:22,176
Then we fall into a mode
called triple buffering.


254
00:12:22,876 --> 00:12:25,776
Again, Core Animation
will output GPU commands,


255
00:12:25,886 --> 00:12:28,866
which the GPU will then
render but in this example,


256
00:12:29,306 --> 00:12:31,756
the GPU hasn't finished
rendering the green frame


257
00:12:31,876 --> 00:12:33,906
by the time we hit
the display refresh.


258
00:12:34,706 --> 00:12:38,056
In this example, since we can't
show it yet, the blue frame has


259
00:12:38,056 --> 00:12:40,566
to be extended on the
screen for an extra frame.


260
00:12:42,096 --> 00:12:44,386
Core Animation now needs
to allocate a third buffer


261
00:12:44,386 --> 00:12:47,236
to begin work on the next
frame, and it will do


262
00:12:47,236 --> 00:12:48,856
so by creating this
third buffer.


263
00:12:49,636 --> 00:12:52,116
Then Core Animation will
start outputting GPU commands


264
00:12:52,116 --> 00:12:54,876
for it while the GPU finishes
rendering the previous frame.


265
00:12:55,896 --> 00:12:58,716
And then the previous frame
will be enqueued for display


266
00:12:58,876 --> 00:13:00,266
at the next display refresh.


267
00:13:01,386 --> 00:13:02,486
This process then repeats


268
00:13:02,876 --> 00:13:06,946
with the Core Animation render
server outputting GPU commands,


269
00:13:06,946 --> 00:13:08,606
and the GPU will
then render them.


270
00:13:09,206 --> 00:13:10,076
You get the idea.


271
00:13:10,156 --> 00:13:12,576
We swap the buffers,
reclaim the buffer,


272
00:13:12,906 --> 00:13:14,746
and then the process repeats.


273
00:13:16,896 --> 00:13:20,906
So you might be thinking, all of
these slides say Core Animation.


274
00:13:21,336 --> 00:13:22,526
What if I don't use
Core Animation?


275
00:13:22,786 --> 00:13:24,946
What if I have optimized
my application


276
00:13:25,336 --> 00:13:27,096
to use Metal or OpenGL?


277
00:13:28,086 --> 00:13:31,476
You might think instead of
your pipeline looking like this


278
00:13:31,906 --> 00:13:34,926
and getting your frame out
to the display in four frames


279
00:13:34,926 --> 00:13:37,966
of latency, that you can do
it in three frames of latency.


280
00:13:39,676 --> 00:13:42,456
Unfortunately that's
not the case.


281
00:13:42,566 --> 00:13:45,796
Under iOS 8, if you
use Metal or OpenGL,


282
00:13:46,216 --> 00:13:48,826
Core Animation still acts
an arbiter, to make sure


283
00:13:48,826 --> 00:13:51,756
that any updates you make to
any Core Animation content


284
00:13:51,756 --> 00:13:56,146
on the screen are synchronized
with any GPU, OpenGL,


285
00:13:56,146 --> 00:13:58,536
Metal updates that you
make to those layers.


286
00:13:59,556 --> 00:14:01,596
So you still have
four frames of latency


287
00:14:01,926 --> 00:14:05,866
when you use OpenGL
or Metal in iOS 8.


288
00:14:06,636 --> 00:14:11,796
So we talked about how the iOS
pipeline is flexible enough


289
00:14:11,866 --> 00:14:13,506
to handle very complicated
views,


290
00:14:13,796 --> 00:14:18,166
getting you 60 frames per second
animation but at five frames


291
00:14:18,166 --> 00:14:21,326
of latency and how you can
optimize your application


292
00:14:21,656 --> 00:14:23,676
to bring that latency
down to four frames


293
00:14:23,966 --> 00:14:25,836
by optimizing what
you are drawing.


294
00:14:26,786 --> 00:14:30,576
However, in this example,
there is no real way


295
00:14:30,576 --> 00:14:33,286
to make it any faster, because
Core Animation needs to wait


296
00:14:33,286 --> 00:14:34,556
until the display refresh


297
00:14:34,936 --> 00:14:37,386
to start generating
the GPU commands.


298
00:14:37,916 --> 00:14:42,436
In iOS 9, we are
removing that dependency.


299
00:14:43,556 --> 00:14:46,406
You can now start Core Animation
work immediately as soon


300
00:14:46,406 --> 00:14:48,186
as your application is
done updating the state


301
00:14:48,186 --> 00:14:48,886
of your application.


302
00:14:49,906 --> 00:14:51,556
In order to take
advantage of these,


303
00:14:51,556 --> 00:14:53,966
we have introduced some new APIs


304
00:14:53,966 --> 00:14:55,856
and new tricks in
the iOS system.


305
00:14:56,206 --> 00:14:57,676
To tell you a little
bit more about them,


306
00:14:57,676 --> 00:14:59,476
I would like to introduce
Jacob [applause].


307
00:15:01,186 --> 00:15:01,626
>> JACOB XIAO: Thanks, Peter.


308
00:15:02,686 --> 00:15:04,186
So I would like to tell you


309
00:15:04,466 --> 00:15:06,736
about some additions
we have made in iOS 9,


310
00:15:07,346 --> 00:15:10,886
and how you can use them to get
even lower latency in your apps.


311
00:15:11,936 --> 00:15:13,726
I will be talking about
three things today.


312
00:15:14,526 --> 00:15:17,536
First, low latency
support in Core Animation.


313
00:15:18,576 --> 00:15:22,796
Then, a new system for touch
coalescing, and finally,


314
00:15:23,156 --> 00:15:24,936
a really cool system
for touch prediction


315
00:15:25,156 --> 00:15:26,406
that we built into UIKit.


316
00:15:27,936 --> 00:15:30,736
So let's get started with low
latency in Core Animation.


317
00:15:31,356 --> 00:15:34,806
As Peter just showed
you in iOS 8,


318
00:15:35,166 --> 00:15:37,646
even with a well-optimized
app there was a limit


319
00:15:37,646 --> 00:15:39,386
to how far you could
get your latency down.


320
00:15:40,636 --> 00:15:43,406
By using low latency
Core Animation in iOS 9,


321
00:15:43,956 --> 00:15:47,026
we can combine the app's frame
with Core Animation frame,


322
00:15:47,236 --> 00:15:48,836
and this gives you
much lower latency.


323
00:15:49,786 --> 00:15:51,356
The best thing about
this feature is


324
00:15:51,356 --> 00:15:52,376
that it happens automatically.


325
00:15:52,376 --> 00:15:54,846
There are no changes you have
to make to your app other


326
00:15:54,846 --> 00:15:56,176
than optimizing your
performance.


327
00:15:57,776 --> 00:15:59,506
However, there's one
thing to keep in mind,


328
00:15:59,816 --> 00:16:02,616
which is that this low latency
mode is automatically disabled


329
00:16:02,996 --> 00:16:05,386
when you have animations
active in your app.


330
00:16:05,926 --> 00:16:09,056
This includes CA animations
and UIKit animations,


331
00:16:09,546 --> 00:16:12,036
so if you want the absolute
lowest latency in your app,


332
00:16:12,476 --> 00:16:15,316
you want to make sure to disable
those animations while touches


333
00:16:15,316 --> 00:16:21,986
are active on the display.


334
00:16:22,916 --> 00:16:26,306
Now this system also works
with Metal and OpenGL content.


335
00:16:26,976 --> 00:16:29,726
So as you saw earlier
before in iOS 8,


336
00:16:30,206 --> 00:16:31,646
we had to wait an
additional frame


337
00:16:31,826 --> 00:16:33,616
to get your GPU content
to the display.


338
00:16:33,616 --> 00:16:37,146
But with the new low
latency mode, we can now get


339
00:16:37,186 --> 00:16:39,426
that content to the display
as quickly as possible


340
00:16:39,426 --> 00:16:40,366
in the very next frame.


341
00:16:41,416 --> 00:16:43,116
This happens automatically just


342
00:16:43,116 --> 00:16:45,566
by using CAeagllayer
or CAMetalLayer.


343
00:16:45,816 --> 00:16:49,076
However, if there's one thing
to keep in mind in your app


344
00:16:49,556 --> 00:16:51,546
if you have Core Animation
content that you want


345
00:16:51,546 --> 00:16:54,196
to draw along with this
OpenGL or Metal content.


346
00:16:55,426 --> 00:16:58,626
In this case, the GPU content
will be drawn to the display


347
00:16:58,626 --> 00:17:02,266
as quickly as possible but your
Core Animation content may take


348
00:17:02,266 --> 00:17:03,816
a little longer to go through.


349
00:17:04,685 --> 00:17:08,116
And if that happens, then by
default, it's not guaranteed


350
00:17:08,376 --> 00:17:11,165
that your GPU content will
arrive in the same frame


351
00:17:11,165 --> 00:17:12,445
as your Core Animation content.


352
00:17:13,326 --> 00:17:15,915
Now this may be a problem if you
want those two to be in sync,


353
00:17:15,915 --> 00:17:17,816
and that could happen,
for example,


354
00:17:17,816 --> 00:17:20,316
if you had an OpenGL map
view, that you wanted


355
00:17:20,316 --> 00:17:22,016
to draw UIKit content on top of.


356
00:17:23,096 --> 00:17:25,935
In that case, you may want
to synchronize those updates


357
00:17:26,185 --> 00:17:28,626
in something like this,
and there's a property


358
00:17:28,626 --> 00:17:29,366
that allows you to do


359
00:17:29,366 --> 00:17:31,816
that called Presents
With Transaction.


360
00:17:32,206 --> 00:17:34,466
It's on CAeagllayer
and CAMetalLayer.


361
00:17:35,316 --> 00:17:37,536
When this is set to False,
which is the default value,


362
00:17:38,206 --> 00:17:40,426
then it will get your GPU
content to the display


363
00:17:40,426 --> 00:17:41,476
as quickly as possible.


364
00:17:42,266 --> 00:17:43,536
But when you set it to True,


365
00:17:44,076 --> 00:17:45,986
then we synchronize
your GPU content


366
00:17:46,256 --> 00:17:48,836
with the Core Animation
content so they both appear


367
00:17:48,916 --> 00:17:50,726
on the display at the same time.


368
00:17:51,296 --> 00:17:52,326
All right.


369
00:17:52,496 --> 00:17:55,256
Next, let's talk about
touch coalescing.


370
00:17:56,256 --> 00:17:57,406
But before we do, I would


371
00:17:57,406 --> 00:17:59,826
like to tell you a little
bit about the iPad Air 2.


372
00:18:01,086 --> 00:18:02,956
We introduced the
iPad Air 2 last year,


373
00:18:03,746 --> 00:18:05,936
and it has a 60-hertz
display update rate,


374
00:18:06,246 --> 00:18:09,186
which means the display
updates at 60 times per second


375
00:18:09,606 --> 00:18:10,886
like our other iOS devices.


376
00:18:11,786 --> 00:18:14,456
It also has a really cool
feature that affects touch


377
00:18:14,456 --> 00:18:16,456
and touch latency that
I'm really excited


378
00:18:16,456 --> 00:18:17,136
to announce to you today.


379
00:18:17,136 --> 00:18:21,316
And that's the fact that it has
a 120-hertz touch scan update


380
00:18:21,316 --> 00:18:21,536
rate [applause].


381
00:18:25,366 --> 00:18:25,796
It's pretty cool.


382
00:18:27,606 --> 00:18:30,006
This means that it scans for
touches at twice the rate


383
00:18:30,136 --> 00:18:31,516
of all other iOS devices.


384
00:18:31,616 --> 00:18:34,286
And this is great, because you
can get a lot more information


385
00:18:34,506 --> 00:18:35,986
about where the user's
finger is going


386
00:18:36,036 --> 00:18:37,386
as they interact
with the display.


387
00:18:38,976 --> 00:18:41,776
Let's take a look at how this
affects your app in practice.


388
00:18:42,976 --> 00:18:46,356
With the 60-hertz touch scan
rate, as the user's finger moves


389
00:18:46,356 --> 00:18:48,866
across the display, we
will periodically sample


390
00:18:48,866 --> 00:18:52,016
where that finger is and give
that information to the app.


391
00:18:53,456 --> 00:18:56,036
The same thing happens with
the 120-hertz scan rate,


392
00:18:56,456 --> 00:18:59,716
but since it's twice as fast,
you get twice as many samples,


393
00:18:59,716 --> 00:19:02,296
and this gives you a
lot more information


394
00:19:02,296 --> 00:19:09,206
about what the user is doing.


395
00:19:09,396 --> 00:19:12,196
Now, once we get those samples,
we will pass them to your app,


396
00:19:12,196 --> 00:19:15,496
and you can use those to
know what the user is trying


397
00:19:15,496 --> 00:19:16,336
to do with their touches.


398
00:19:16,806 --> 00:19:19,726
For example, in a drawing app,
you might connect them together


399
00:19:20,056 --> 00:19:22,346
to represent the drawing that
the user is trying to perform,


400
00:19:23,346 --> 00:19:26,856
and this 120-hertz information
gives you a lot more information


401
00:19:26,976 --> 00:19:29,766
that you can use to get a better
representation of their drawing.


402
00:19:30,306 --> 00:19:32,806
So now that we have
seen the benefits


403
00:19:32,806 --> 00:19:36,046
of 120-hertz touch scan
rate, let's take a look


404
00:19:36,046 --> 00:19:39,446
at how it affects the
touch to display pipeline.


405
00:19:40,026 --> 00:19:43,146
This is the 60-hertz
touch scan rate pipeline


406
00:19:43,146 --> 00:19:43,866
that we saw earlier.


407
00:19:44,706 --> 00:19:46,906
And let's focus in on
just the Multi-Touch stage


408
00:19:46,976 --> 00:19:47,636
of the pipeline.


409
00:19:49,096 --> 00:19:52,726
At 60 hertz, we get a new
touch sample every frame.


410
00:19:53,776 --> 00:19:56,906
And with 120 hertz, we'll now
get two samples every time.


411
00:19:57,786 --> 00:19:59,196
However, note that the size


412
00:19:59,196 --> 00:20:00,886
of the display frame
is still the same,


413
00:20:01,246 --> 00:20:03,816
since we have the same update
rate for the display itself.


414
00:20:03,946 --> 00:20:08,076
Now, we could take those new
touch samples and pass them


415
00:20:08,076 --> 00:20:11,316
to your app, and your app could
use that to update its drawing,


416
00:20:11,666 --> 00:20:13,826
which would update what it
showed in Core Animation


417
00:20:13,826 --> 00:20:15,066
and on to the display.


418
00:20:16,076 --> 00:20:17,346
But you will notice
that if we did,


419
00:20:17,346 --> 00:20:20,056
that your app would actually
be updating twice as often


420
00:20:20,056 --> 00:20:21,806
as the display updates,
which would lead


421
00:20:21,806 --> 00:20:23,746
to wasted work in your app.


422
00:20:24,026 --> 00:20:26,016
So we introduced the
touch coalescing system


423
00:20:26,116 --> 00:20:27,316
to get the best of both worlds.


424
00:20:28,076 --> 00:20:30,196
This allows you to get
the increased information


425
00:20:30,196 --> 00:20:32,936
from the 120-hertz
touch scan rate but not


426
00:20:32,936 --> 00:20:35,586
to have any wasted work in
your app withdrawing too much.


427
00:20:36,336 --> 00:20:38,926
Let's take a look at how
this pipeline changes


428
00:20:38,926 --> 00:20:39,666
with coalescing.


429
00:20:41,026 --> 00:20:42,756
Now we will only deliver a touch


430
00:20:42,756 --> 00:20:45,166
to your app once
per display frame,


431
00:20:45,756 --> 00:20:48,106
so when the first touch comes
in, we will deliver that to you.


432
00:20:49,036 --> 00:20:51,926
And then in the next frame,
we will deliver you the touch


433
00:20:51,926 --> 00:20:54,816
for that frame, and also
any intermediate touches


434
00:20:54,816 --> 00:20:56,916
that happened since the
last time we sent touches


435
00:20:56,916 --> 00:20:58,326
to your app.


436
00:20:58,836 --> 00:21:02,656
This repeats each time the
user makes more touches


437
00:21:02,656 --> 00:21:03,186
to the display.


438
00:21:03,686 --> 00:21:05,856
We'll give you the current
touch and any coalesce touches,


439
00:21:06,206 --> 00:21:08,476
and that continues as long
as touches are active.


440
00:21:09,056 --> 00:21:12,636
Now, the API to use these
coalesced touches is


441
00:21:12,636 --> 00:21:13,196
really simple.


442
00:21:13,926 --> 00:21:16,556
It's a new method on UIEvent
called Coalesce Touches


443
00:21:16,556 --> 00:21:17,106
For Touch.


444
00:21:18,056 --> 00:21:20,276
You pass into that method the
touch that you're looking at,


445
00:21:20,766 --> 00:21:23,496
and we'll give you back an array
of all the coalesced touches


446
00:21:23,496 --> 00:21:27,246
since the last time we delivered
that touch to your app.


447
00:21:28,116 --> 00:21:30,186
To get a better idea
of how to use this API,


448
00:21:30,186 --> 00:21:33,146
let's look at how touch handling
works in iOS in general.


449
00:21:33,746 --> 00:21:36,786
When the user first
touches the display,


450
00:21:36,786 --> 00:21:40,016
we will call Touches
Began on your app.


451
00:21:40,246 --> 00:21:43,616
As their finger moves, we will
call Touches Moved, and finally,


452
00:21:43,936 --> 00:21:45,666
as their finger is
removed from the display,


453
00:21:45,666 --> 00:21:46,856
we will call Touches Ended.


454
00:21:48,066 --> 00:21:50,016
Now, as we are talking
about these touch callbacks,


455
00:21:50,476 --> 00:21:53,016
another very important
callback is Touches Canceled.


456
00:21:54,076 --> 00:21:55,726
This gets called when
the stream of touches


457
00:21:55,726 --> 00:21:56,906
to your app is interrupted.


458
00:21:57,516 --> 00:21:59,496
For example, if the user
swipes from the bottom


459
00:21:59,636 --> 00:22:00,686
to activate Control Center.


460
00:22:02,126 --> 00:22:04,986
In that case, your app will get
some the initial touch callback,


461
00:22:04,986 --> 00:22:06,616
and we will get Touches Canceled


462
00:22:07,146 --> 00:22:09,286
when the system gesture
takes over.


463
00:22:09,916 --> 00:22:13,476
It's important to implement
this method to do any cleanup


464
00:22:13,476 --> 00:22:16,636
for things that you started in
the previous touch callbacks


465
00:22:17,056 --> 00:22:18,616
and roll back any
changes you made.


466
00:22:19,246 --> 00:22:21,376
For example, in a drawing
app, you might want


467
00:22:21,376 --> 00:22:23,176
to remove the line that
the user was drawing.


468
00:22:23,536 --> 00:22:27,016
So now that we have seen how
these touch callbacks work,


469
00:22:27,326 --> 00:22:29,376
let's see how they interact
with coalesce touches.


470
00:22:30,576 --> 00:22:32,066
The touches we deliver to all


471
00:22:32,066 --> 00:22:34,136
of those callbacks are
what we call main touches,


472
00:22:34,596 --> 00:22:38,046
and these work the same with the
120-hertz scan rate as they do


473
00:22:38,046 --> 00:22:39,186
with 60-hertz devices.


474
00:22:39,256 --> 00:22:43,756
However, with the Coalesce
Touches For Touch method,


475
00:22:43,966 --> 00:22:46,116
you can get access
to more information


476
00:22:46,116 --> 00:22:47,186
with these coalesced touches.


477
00:22:48,286 --> 00:22:51,566
The coalesced touches
not only have information


478
00:22:51,566 --> 00:22:54,966
about the intermediate touches
but they also give you a copy


479
00:22:55,176 --> 00:22:56,176
of the main touch itself.


480
00:22:56,826 --> 00:22:59,686
And the great thing about this
is that it allows you a choice.


481
00:23:00,176 --> 00:23:01,776
You can look at the main touches


482
00:23:02,126 --> 00:23:03,866
if you don't need the
increased information


483
00:23:04,376 --> 00:23:07,556
of the higher touch scan
rate in your app, or,


484
00:23:07,556 --> 00:23:09,406
if you want that
information, you can look


485
00:23:09,406 --> 00:23:11,726
at just the coalesced touches
and you don't have to worry


486
00:23:11,726 --> 00:23:12,576
about the main touches.


487
00:23:17,276 --> 00:23:21,166
So now let's revisit the touch
sequence that we saw and see how


488
00:23:21,166 --> 00:23:23,836
that works with both main
touches and coalesced touches.


489
00:23:24,776 --> 00:23:26,566
As the user's finger comes down,


490
00:23:26,566 --> 00:23:29,886
we will give your app a
main touch, and also a copy


491
00:23:29,886 --> 00:23:31,176
of that as a coalesced touch.


492
00:23:32,346 --> 00:23:33,416
Then as their finger moves,


493
00:23:33,416 --> 00:23:35,756
we will deliver you new
main touches and a set


494
00:23:35,756 --> 00:23:37,226
of coalesced touches
for each one.


495
00:23:38,066 --> 00:23:39,536
And finally, as their
finger leaves,


496
00:23:39,646 --> 00:23:41,066
we will give you
the last main touch


497
00:23:41,526 --> 00:23:42,946
and any remaining
coalesced touches.


498
00:23:43,606 --> 00:23:45,986
Now here, I have shown only one


499
00:23:45,986 --> 00:23:48,836
or two coalesced touches
for each main touch.


500
00:23:49,396 --> 00:23:50,626
But it's important
to keep in mind


501
00:23:50,626 --> 00:23:52,076
that your app can receive
a different amount.


502
00:23:53,036 --> 00:23:55,216
If your app takes a long
time to process a touch,


503
00:23:55,616 --> 00:23:57,636
then we will give you some
time to catch up and wait


504
00:23:57,636 --> 00:24:00,866
to send you new touches
until you have caught up.


505
00:24:01,106 --> 00:24:02,696
And if this happens,
then the touches


506
00:24:02,696 --> 00:24:04,256
that weren't delivered
you to will be sent


507
00:24:04,256 --> 00:24:05,886
to you later as coalesced
touches.


508
00:24:06,416 --> 00:24:08,506
So make sure that you don't
hard code any dependencies


509
00:24:08,736 --> 00:24:10,536
on the number of coalesced
touches that you receive.


510
00:24:11,226 --> 00:24:14,786
Now, there are a few
differences between the way


511
00:24:14,786 --> 00:24:16,716
that coalesced touches
behave and the way


512
00:24:16,716 --> 00:24:17,666
that main touches behave.


513
00:24:18,496 --> 00:24:20,736
One of those is related
to previous location.


514
00:24:21,776 --> 00:24:24,696
And previous location is
something that you can get


515
00:24:24,696 --> 00:24:27,406
with the method Previous
Location In View from UITouch.


516
00:24:28,336 --> 00:24:32,106
For main touches, this gives
your app the last location


517
00:24:32,106 --> 00:24:33,696
that that touch had when
it was delivered to you.


518
00:24:34,436 --> 00:24:36,676
And for coalesced touches,
it behaves very similarly.


519
00:24:36,856 --> 00:24:38,226
It gives you the location


520
00:24:38,326 --> 00:24:40,366
of the last coalesced
touch to your app.


521
00:24:41,606 --> 00:24:43,696
And this is one of the reasons
that it's really important


522
00:24:43,696 --> 00:24:45,216
to focus on just
the main touches


523
00:24:45,426 --> 00:24:46,586
or just the coalesced touches.


524
00:24:47,346 --> 00:24:49,546
That way, you won't
get any confusion


525
00:24:49,546 --> 00:24:50,616
with the previous locations.


526
00:24:51,056 --> 00:24:52,936
So it's really important
not to cross the streams.


527
00:24:54,516 --> 00:24:58,576
[ Applause ]


528
00:24:59,076 --> 00:25:00,866
Now, another difference
between main touches


529
00:25:00,866 --> 00:25:02,196
and coalesced touches is


530
00:25:02,196 --> 00:25:04,236
in how the UITouch
objects themselves behave.


531
00:25:05,666 --> 00:25:09,156
With main touches, the same
UITouch instance is reused every


532
00:25:09,156 --> 00:25:11,836
time the touch is
delivered to your app.


533
00:25:12,246 --> 00:25:14,566
This is helpful because it
allows you to differentiate


534
00:25:14,726 --> 00:25:17,606
between different touches if
the users has multiple fingers


535
00:25:17,606 --> 00:25:18,566
on the display at once.


536
00:25:19,216 --> 00:25:22,866
And for coalesced touches, this
works a little bit differently.


537
00:25:23,596 --> 00:25:26,386
There, each time we deliver a
coalesced touch to your app,


538
00:25:26,896 --> 00:25:28,476
we deliver a new
UITouch instance


539
00:25:29,486 --> 00:25:30,626
that has the new properties.


540
00:25:30,726 --> 00:25:33,696
And so you can think of
these as snapshots instead


541
00:25:33,696 --> 00:25:35,906
of the shared identity
that the main touches have.


542
00:25:35,966 --> 00:25:39,476
So now that you understand
how touch coalescing works,


543
00:25:39,616 --> 00:25:42,426
let's dig into some code for
how to use coalesced touches.


544
00:25:43,216 --> 00:25:45,106
This is some code that
you might have in an app


545
00:25:45,566 --> 00:25:48,326
that does something like drawing
and you could have something


546
00:25:48,326 --> 00:25:49,456
like this in touches moved.


547
00:25:50,466 --> 00:25:52,836
Here we are iterating through
the touches that we have,


548
00:25:53,436 --> 00:25:55,776
and we are grabbing the line
that corresponds to each touch.


549
00:25:57,066 --> 00:25:59,446
Then we are adding the
latest touch as a new sample


550
00:25:59,446 --> 00:26:00,526
onto the end of that line.


551
00:26:01,116 --> 00:26:04,786
And to add touch coalescing
support, we just need


552
00:26:04,786 --> 00:26:06,106
to add this small bit of code.


553
00:26:07,136 --> 00:26:09,956
Now, we are iterating through
all the coalesced touches


554
00:26:09,956 --> 00:26:12,516
for the given main
touch, and for each


555
00:26:12,516 --> 00:26:14,276
of those coalesced
touches, we are adding it


556
00:26:14,276 --> 00:26:15,896
for the sample to the line.


557
00:26:16,726 --> 00:26:18,616
Notice that we are only
adding the coalesced touches


558
00:26:18,616 --> 00:26:20,236
of the samples, not
the main touches.


559
00:26:21,056 --> 00:26:22,246
And that's touch coalescing.


560
00:26:22,246 --> 00:26:29,346
Now I would like to tell
you about touch prediction.


561
00:26:30,066 --> 00:26:32,396
This is a really cool system
that we have added right


562
00:26:32,396 --> 00:26:34,156
into UIKit that you can use


563
00:26:34,156 --> 00:26:36,006
to get even lower
latency in your apps.


564
00:26:37,086 --> 00:26:38,946
Now, as we deliver your app,


565
00:26:38,946 --> 00:26:42,156
new touches will also give
you a look into the future


566
00:26:42,426 --> 00:26:44,696
at what we predict that the
user's touches will be doing


567
00:26:44,776 --> 00:26:45,496
in the near future.


568
00:26:46,436 --> 00:26:49,416
And the API for this works
very similarly to the API


569
00:26:49,556 --> 00:26:50,396
for coalesced touches.


570
00:26:51,326 --> 00:26:54,026
It's another method on UIEvent
called Predicted Touches


571
00:26:54,026 --> 00:26:54,536
For Touch.


572
00:26:55,726 --> 00:26:58,016
Once again, you pass in a
main touch to this method


573
00:26:58,016 --> 00:27:00,276
and you will get back an
array of predicted touches.


574
00:27:01,526 --> 00:27:04,916
And you can use those predicted
touches to update your drawing


575
00:27:05,026 --> 00:27:07,156
or whatever else you are
doing with the user's touches,


576
00:27:07,946 --> 00:27:09,026
to get even lower latency.


577
00:27:10,556 --> 00:27:12,506
So earlier, we saw
how main touches


578
00:27:12,506 --> 00:27:13,846
and coalesced touches
are related,


579
00:27:14,696 --> 00:27:16,816
and predicted touches work
in a very similar way.


580
00:27:17,536 --> 00:27:20,466
They are another set of touches
associated with a main touch,


581
00:27:21,556 --> 00:27:25,566
and they behave as snapshots
just like coalesced touches do.


582
00:27:25,826 --> 00:27:27,986
Now, one thing that's different
about predicted touches compared


583
00:27:27,986 --> 00:27:30,006
to coalesced touches
is what happens


584
00:27:30,006 --> 00:27:31,076
when new touches come in.


585
00:27:31,976 --> 00:27:34,096
As you get a new main touch,
you will get a new set


586
00:27:34,096 --> 00:27:38,246
of predicted touches, and the
new predicted touches are the


587
00:27:38,246 --> 00:27:39,726
only thing you want to use then.


588
00:27:40,236 --> 00:27:42,536
Any previous predicted
touches are no longer useful


589
00:27:42,806 --> 00:27:44,106
since we now have information


590
00:27:44,106 --> 00:27:46,416
about where the user actually
touched during that time.


591
00:27:46,736 --> 00:27:50,126
So you generally want to throw
those old predicted touches out.


592
00:27:51,156 --> 00:27:53,446
Now, previous location
in view works similarly


593
00:27:53,446 --> 00:27:55,656
for predicted touches as it
does for other touch types.


594
00:27:56,546 --> 00:27:57,806
It points to the location


595
00:27:57,806 --> 00:28:00,526
that the previous
predicted touch had, or,


596
00:28:00,526 --> 00:28:03,346
for the first predicted touch,
it points to the last location


597
00:28:03,456 --> 00:28:05,286
that was delivered to your app.


598
00:28:05,916 --> 00:28:08,336
So you may be wondering how we
actually get these predicted


599
00:28:08,336 --> 00:28:09,676
touches, and it's pretty simple.


600
00:28:10,476 --> 00:28:12,516
We built a time machine into
every iOS device [laughter].


601
00:28:14,596 --> 00:28:15,556
That's not quite how it works.


602
00:28:16,216 --> 00:28:19,186
What we are actually doing
is looking at the touches


603
00:28:19,286 --> 00:28:21,636
that are delivered to
your app and using a set


604
00:28:21,636 --> 00:28:24,026
of highly tuned algorithms
to determine


605
00:28:24,026 --> 00:28:27,386
where the user's finger looks
like it's going at this time.


606
00:28:28,186 --> 00:28:30,826
And as we get new touch samples,
we will update our prediction


607
00:28:30,936 --> 00:28:34,006
and deliver new predicted
touches to your app.


608
00:28:34,236 --> 00:28:37,496
Now, each of those predicted
touches are complete UITouch


609
00:28:37,496 --> 00:28:39,816
objects and they have all of
their properties filled out,


610
00:28:40,126 --> 00:28:42,246
like their location
and time stamp.


611
00:28:43,156 --> 00:28:46,196
So now we can look at how those
predicted touches affect the


612
00:28:46,196 --> 00:28:47,946
pipeline that we
have been looking at.


613
00:28:48,796 --> 00:28:50,996
This is what we saw
earlier from main touches


614
00:28:51,026 --> 00:28:53,316
and coalesced touches,
and we can easily add


615
00:28:53,316 --> 00:28:54,646
in predicted touches as well.


616
00:28:56,166 --> 00:28:58,246
Each frame, as your
app gets a main touch,


617
00:28:58,346 --> 00:29:00,306
you also get a set
of predicted touches.


618
00:29:00,676 --> 00:29:04,106
And if you get main touches
and coalesced touches as well,


619
00:29:04,396 --> 00:29:06,356
then the predicted touches
are just more information


620
00:29:06,356 --> 00:29:07,836
that you have available to you.


621
00:29:08,686 --> 00:29:11,356
And this process just repeats
as new touches are delivered.


622
00:29:12,436 --> 00:29:14,936
One thing to note is
that coalesced touches


623
00:29:14,936 --> 00:29:16,506
and predicted touches
are independent.


624
00:29:16,506 --> 00:29:17,966
You can use one without
the other,


625
00:29:18,756 --> 00:29:21,356
and predicted touches are
supported on both 60-hertz


626
00:29:21,406 --> 00:29:23,686
and 120-hertz touch
scan rate devices.


627
00:29:24,346 --> 00:29:27,716
So now let's take a look at
how we can add touch prediction


628
00:29:28,056 --> 00:29:30,386
to the code that we were
taking a look at earlier.


629
00:29:30,436 --> 00:29:34,216
All you need to do is add
this small bit of code,


630
00:29:34,216 --> 00:29:38,676
and what we are doing is first
removing any previous predicted


631
00:29:38,676 --> 00:29:39,996
touches that we added
to our line.


632
00:29:40,216 --> 00:29:43,116
And this is important since we
now have the actual locations


633
00:29:43,416 --> 00:29:44,286
where those touches were.


634
00:29:44,886 --> 00:29:53,336
Then we are iterating through
the predicted touches we have.


635
00:29:54,216 --> 00:29:56,806
And for each of those predicted
touches, we are adding it


636
00:29:56,966 --> 00:29:58,696
as a sample to our line.


637
00:29:59,706 --> 00:30:01,556
But notice that we are
calling a different method here


638
00:30:01,666 --> 00:30:03,936
to add the predicted
sample as what we called


639
00:30:03,936 --> 00:30:05,266
to call the normal samples.


640
00:30:05,776 --> 00:30:08,066
This is so that we can mark
that sample as something


641
00:30:08,066 --> 00:30:09,786
that will need to be
removed the next time we go


642
00:30:09,786 --> 00:30:11,106
through this code.


643
00:30:11,676 --> 00:30:13,836
So that's touch coalescing
and touch prediction.


644
00:30:14,226 --> 00:30:16,746
Now that you have seen
all of these techniques,


645
00:30:17,066 --> 00:30:18,906
let's see what happens when
we combine them all together.


646
00:30:20,326 --> 00:30:23,536
In iOS 8, with a
well-optimized app,


647
00:30:24,136 --> 00:30:25,806
this was the touch latency
view that you could get.


648
00:30:25,806 --> 00:30:28,356
We measured the latency
as the time


649
00:30:28,356 --> 00:30:30,946
between when the touch
first comes down to


650
00:30:30,946 --> 00:30:33,436
when the display has updated
with that touch's information.


651
00:30:34,246 --> 00:30:35,836
And so you can see
that in iOS 8,


652
00:30:35,836 --> 00:30:37,536
we would have four
frames of latency.


653
00:30:38,186 --> 00:30:42,586
Now by using low latency
Core Animation and iOS 9,


654
00:30:42,876 --> 00:30:44,606
we can remove one frame
of latency from that.


655
00:30:45,656 --> 00:30:48,576
And by using touch
coalescing and running


656
00:30:48,576 --> 00:30:50,156
on a high-touch-scan-rate
device,


657
00:30:50,816 --> 00:30:52,566
you can not only get
increased information


658
00:30:52,566 --> 00:30:55,476
about the user's touch, you
can also remove a half frame


659
00:30:55,476 --> 00:30:58,936
of latency from the
beginning [applause].


660
00:30:59,046 --> 00:30:59,576
But there's more!


661
00:31:02,356 --> 00:31:05,296
By also using touch prediction
you can get information


662
00:31:05,296 --> 00:31:07,166
about approximately a
frame into the future


663
00:31:07,216 --> 00:31:08,636
of where the user's
touches are going.


664
00:31:09,186 --> 00:31:13,026
And this lets you give the user
an effective latency that's


665
00:31:13,026 --> 00:31:14,936
reduced by about a
frame more as well.


666
00:31:15,646 --> 00:31:17,466
And so altogether, in iOS 9,


667
00:31:17,466 --> 00:31:19,246
you can get down to
approximately one


668
00:31:19,246 --> 00:31:21,136
and a half frames of
latency for your users


669
00:31:21,366 --> 00:31:24,056
which is a huge improvement from
iOS 8's four frames of latency.


670
00:31:25,516 --> 00:31:31,586
[ Applause ]


671
00:31:32,086 --> 00:31:33,096
So we think this
is really great,


672
00:31:33,096 --> 00:31:35,256
and I highly encourage you
to adopt these techniques


673
00:31:35,256 --> 00:31:38,296
in your app to give your users
a great low latency experience.


674
00:31:38,766 --> 00:31:41,126
Now I would like to turn
things back over to Peter


675
00:31:41,126 --> 00:31:42,716
to tell you how to
fine-tune your app.


676
00:31:44,516 --> 00:31:48,956
[ Applause ]


677
00:31:49,456 --> 00:31:50,446
>> PETER TSOI: Thanks, Jacob.


678
00:31:50,506 --> 00:31:53,196
So now that you know about all
of the new low latency modes


679
00:31:53,546 --> 00:31:56,526
in iOS 9, we would like to tell
you how you can take advantage


680
00:31:56,526 --> 00:31:59,866
of those by fine-tuning your
applications so you can fit


681
00:31:59,866 --> 00:32:03,616
within one display frame of
time so you can get your frames


682
00:32:03,616 --> 00:32:05,316
out to the display that quickly.


683
00:32:05,726 --> 00:32:08,326
The first way to ensure


684
00:32:08,326 --> 00:32:11,346
that your application is doing
the least amount of work is


685
00:32:11,376 --> 00:32:13,326
to minimize the amount of work


686
00:32:13,606 --> 00:32:15,306
that your application
needs to do.


687
00:32:15,596 --> 00:32:18,626
By using the coalesced touches
API that Jacob just introduced


688
00:32:18,626 --> 00:32:22,426
to you, you can get the benefits
of high-fidelity touch inputs


689
00:32:22,686 --> 00:32:24,816
of the iPad Air 2
while making sure


690
00:32:24,816 --> 00:32:26,906
that your application
only renders images


691
00:32:27,096 --> 00:32:28,446
that will make it
onto the screen.


692
00:32:29,196 --> 00:32:32,176
In addition, keep in mind
that your user only cares


693
00:32:32,176 --> 00:32:35,406
about the content that they can
see on the device's display.


694
00:32:36,026 --> 00:32:40,096
Your application may do the
work to keep track of the state


695
00:32:40,246 --> 00:32:43,166
of the world outside of
the screen, but ultimately,


696
00:32:43,166 --> 00:32:46,336
you should make sure that the
rendering work is restricted


697
00:32:46,676 --> 00:32:50,096
to only the work that is
necessary to generate the image


698
00:32:50,316 --> 00:32:52,416
that ultimately shows
up on the screen.


699
00:32:53,466 --> 00:32:57,356
If you are trying to
profile your application,


700
00:32:57,526 --> 00:33:00,436
to figure out how much time
your application is spending


701
00:33:00,436 --> 00:33:03,986
on the CPU, Time Profiler
is a great way to do this.


702
00:33:04,626 --> 00:33:07,366
Time Profiler will show you how
much time your application is


703
00:33:07,366 --> 00:33:10,786
using on the CPU by sampling
it at a fixed interval.


704
00:33:11,436 --> 00:33:14,286
In this case, in Time Profiler,


705
00:33:14,286 --> 00:33:17,386
I selected a 16-millisecond
interval,


706
00:33:17,616 --> 00:33:19,716
which corresponds roughly
to one display frame.


707
00:33:20,726 --> 00:33:23,616
You can also tell
that my application


708
00:33:23,856 --> 00:33:26,516
in this case is using
only a small fraction


709
00:33:26,516 --> 00:33:27,406
of that amount of time.


710
00:33:28,066 --> 00:33:29,706
In this case, 3 milliseconds.


711
00:33:30,256 --> 00:33:33,196
Now this is all fine and good
if you are trying to measure


712
00:33:33,196 --> 00:33:36,316
and profile how you are
doing in terms of CPU work.


713
00:33:36,816 --> 00:33:37,886
What about GPU work?


714
00:33:39,196 --> 00:33:42,696
The frames per second gauge
in the GPU report available


715
00:33:42,696 --> 00:33:47,036
in the Xcode debugging session
give you a high-level view


716
00:33:47,086 --> 00:33:48,826
of your application's
GPU performance.


717
00:33:49,566 --> 00:33:50,856
In this case, you can see


718
00:33:50,856 --> 00:33:53,276
that this application is
hitting 60 frames per second,


719
00:33:53,806 --> 00:33:57,346
and it has a relatively low
amount of GPU frame time.


720
00:33:57,706 --> 00:33:59,806
In this case, just
3.8 milliseconds.


721
00:34:00,786 --> 00:34:04,506
Keep in mind, though, that this
is just a high-level overview


722
00:34:04,916 --> 00:34:06,306
of what your application
is doing.


723
00:34:06,846 --> 00:34:09,176
It doesn't give you
fine-grained information


724
00:34:09,206 --> 00:34:13,025
about individual frames that may
be causing you to drop frames.


725
00:34:14,126 --> 00:34:17,366
If you require that type of
precision, then you will want


726
00:34:17,366 --> 00:34:20,366
to turn to the new
GPU driver instrument,


727
00:34:20,766 --> 00:34:22,696
which we have introduced
in Xcode this year.


728
00:34:23,686 --> 00:34:27,166
The GPU driver instrument can
show you exactly how long the


729
00:34:27,166 --> 00:34:30,206
GPU is active for while you
are using your application.


730
00:34:30,866 --> 00:34:33,795
In this case, you can see
that the amount of time spent


731
00:34:33,795 --> 00:34:35,436
in the vertex and
fragment shaders


732
00:34:35,466 --> 00:34:38,065
of my application
is relatively small.


733
00:34:38,206 --> 00:34:41,076
In fact, it's just a small
fraction of the amount of time


734
00:34:41,426 --> 00:34:43,666
that a frame is shown
on the display for.


735
00:34:45,176 --> 00:34:48,416
Notice you only see
two colors here.


736
00:34:49,045 --> 00:34:52,076
These two colors represent
the two buffers which are used


737
00:34:52,076 --> 00:34:53,366
in the double-buffering scheme.


738
00:34:54,485 --> 00:34:58,106
If our application is spending
more time in Core Animation


739
00:34:58,106 --> 00:35:01,426
and in GPU, you will
see three colors here


740
00:35:01,426 --> 00:35:03,426
to represent the
triple buffering


741
00:35:03,426 --> 00:35:04,906
which is happening
in the system.


742
00:35:05,456 --> 00:35:10,676
We have talked a lot about
reducing latency and how


743
00:35:10,676 --> 00:35:13,406
to make your application more
responsive, but ultimately,


744
00:35:13,486 --> 00:35:17,026
building a great iOS experience
is about building a natural


745
00:35:17,026 --> 00:35:18,976
and intuitive experience
for your user


746
00:35:19,316 --> 00:35:22,966
and making your application feel
more alive is another great way


747
00:35:22,966 --> 00:35:24,506
of doing that.


748
00:35:24,506 --> 00:35:28,166
Over the last year, we thought
long and hard about each part


749
00:35:28,166 --> 00:35:29,826
of our system, and we found ways


750
00:35:29,966 --> 00:35:31,916
to make it better
and faster than ever.


751
00:35:32,706 --> 00:35:34,876
Throughout this process,
we have improved our APIs


752
00:35:35,246 --> 00:35:37,626
to give you more control
and more information


753
00:35:37,926 --> 00:35:39,056
over how the system works.


754
00:35:40,006 --> 00:35:43,276
With the new low latency
modes on OpenGL, Metal,


755
00:35:43,366 --> 00:35:46,456
and Core Animation,
you have more control


756
00:35:46,456 --> 00:35:50,026
over when your frame is shown to
the user and how it synchronizes


757
00:35:50,136 --> 00:35:51,906
with any other content
you have on the screen.


758
00:35:52,846 --> 00:35:56,366
With touch coalescing, you
can take advantage of all


759
00:35:56,366 --> 00:35:58,786
of our hardware and all of
its awesome capabilities


760
00:35:59,136 --> 00:36:00,326
to provide that to your user.


761
00:36:00,616 --> 00:36:02,996
And with touch prediction, we
are offering you a small glimpse


762
00:36:02,996 --> 00:36:05,896
into the future as to where
that touch is going to go.


763
00:36:06,876 --> 00:36:10,426
And finally, we have built
and created some great tools


764
00:36:10,426 --> 00:36:12,606
in order for you to
understand the performance


765
00:36:12,606 --> 00:36:15,036
of your application so that
you can improve upon it


766
00:36:15,166 --> 00:36:17,546
to provide an even better
experience for your users.


767
00:36:18,016 --> 00:36:21,826
We at Apple are committed
to making the experience


768
00:36:21,826 --> 00:36:24,756
of using our products
feel more alive than ever,


769
00:36:24,796 --> 00:36:27,356
and we think reducing latency
is a great way of doing that,


770
00:36:27,636 --> 00:36:29,506
and we would like to invite
you along on this journey.


771
00:36:30,106 --> 00:36:33,736
You can find more information
about the technology, tools,


772
00:36:33,736 --> 00:36:36,996
and APIs we've discussed
today at developer.apple.com.


773
00:36:36,996 --> 00:36:39,726
We would also like to
invite you to take part


774
00:36:39,726 --> 00:36:43,536
in the developer
technical conversation


775
00:36:43,956 --> 00:36:46,116
on our developer forums.


776
00:36:46,676 --> 00:36:48,656
We talked about a lot


777
00:36:48,656 --> 00:36:50,636
of different new
technologies today,


778
00:36:50,966 --> 00:36:53,716
and there have been really
great sessions both this year


779
00:36:53,716 --> 00:36:55,996
and in previous years
that go over topics


780
00:36:56,306 --> 00:36:57,616
which are related to this talk.


781
00:36:58,436 --> 00:37:00,056
For example, if you
are very interested


782
00:37:00,056 --> 00:37:03,246
in profiling the GPU
performance of your application,


783
00:37:03,696 --> 00:37:07,266
and if you are really, really,
really excited to get your hands


784
00:37:07,266 --> 00:37:10,856
on that new GPU instrument,
I would like to point you


785
00:37:10,856 --> 00:37:13,236
at the Metal Performance
Optimization Techniques talk,


786
00:37:13,516 --> 00:37:16,236
which was given earlier
today, where they talk


787
00:37:16,236 --> 00:37:20,366
about a whole bunch of different
techniques that you can use


788
00:37:20,366 --> 00:37:23,836
to optimize your GPU work, not
just if you are using Metal.


789
00:37:25,216 --> 00:37:29,236
In addition, if Time Profiler is
your jam, then you want to check


790
00:37:29,236 --> 00:37:33,046
out the new Profiling in Depth
talk, which was given yesterday,


791
00:37:33,556 --> 00:37:36,536
which goes into a deep dive
on how to use Time Profiler


792
00:37:36,586 --> 00:37:38,886
to get a great idea of what
your application is doing.


793
00:37:39,896 --> 00:37:42,176
And finally, if you guys
are really interested


794
00:37:42,176 --> 00:37:44,896
in what is happening in the
Core Animation and GPU stages


795
00:37:44,896 --> 00:37:46,596
of the pipeline we
have discussed today,


796
00:37:46,596 --> 00:37:48,836
I would like to point you
to the Advanced Graphics


797
00:37:48,836 --> 00:37:52,426
and Animation talk
from last year's WWDC.


798
00:37:52,616 --> 00:37:55,466
All of these talks and
many, many more can be found


799
00:37:55,466 --> 00:37:57,906
on our developer portal
at developer.apple.com.


800
00:37:58,716 --> 00:38:02,346
I hope you learned a lot today
and over the entire course


801
00:38:02,346 --> 00:38:05,636
of this week, and I hope
you had an enjoyable WWDC.


802
00:38:06,106 --> 00:38:06,436
Thank you.


803
00:38:07,516 --> 00:38:21,230
[ Applause ]

