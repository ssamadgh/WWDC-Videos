1
00:00:11,076 --> 00:00:12,496
>> Hello. My name is Norman.


2
00:00:12,646 --> 00:00:16,586
I'd like to give you a quick
tour on some of the details


3
00:00:16,586 --> 00:00:18,436
in what's new in SpriteKit.


4
00:00:19,316 --> 00:00:22,206
So last year we had announced
SpriteKit at a conference,


5
00:00:22,506 --> 00:00:24,536
a high performance
2D game engine


6
00:00:24,536 --> 00:00:25,946
with built-in physics support.


7
00:00:26,256 --> 00:00:28,656
We also built tools
right inside of Xcode


8
00:00:28,656 --> 00:00:31,626
to help developers improve their
game content iteration time


9
00:00:32,046 --> 00:00:35,906
like the particle editor and the
automatic [inaudible] generator.


10
00:00:36,636 --> 00:00:38,856
And this year we made
SpriteKit even better.


11
00:00:39,506 --> 00:00:42,846
We have awesome graphics
technologies like shaders,


12
00:00:43,016 --> 00:00:45,606
lightings and shadows
that help you really bring


13
00:00:45,606 --> 00:00:46,956
out the liveliness of your game.


14
00:00:47,746 --> 00:00:49,946
We also have good
simulation technologies


15
00:00:49,946 --> 00:00:52,626
like per-pixel physics
occlusion, physics field,


16
00:00:53,076 --> 00:00:54,926
universal kinematics
and constraints.


17
00:00:55,246 --> 00:00:57,746
They really allow you to
build rich user interactions.


18
00:00:59,086 --> 00:00:59,836
So that's not all.


19
00:01:00,566 --> 00:01:03,956
In Xcode 6's release we now
have a SpriteKit editor built


20
00:01:03,956 --> 00:01:07,366
into the IDE that allow
you to create game scenes


21
00:01:07,366 --> 00:01:08,556
without writing any code.


22
00:01:08,686 --> 00:01:13,106
And you can use the very same
editor to interact with any


23
00:01:13,106 --> 00:01:15,206
of the new and existing
SpriteKit features.


24
00:01:15,576 --> 00:01:16,386
So how cool is that?


25
00:01:18,936 --> 00:01:21,056
So, for the agenda for
this session we're going


26
00:01:21,056 --> 00:01:23,656
to start looking at how
to use custom shaders


27
00:01:23,726 --> 00:01:26,146
to customize the drawing
behaviors of your sprite,


28
00:01:26,766 --> 00:01:29,546
how to add lightings and
shadows to your scene


29
00:01:30,046 --> 00:01:32,316
and we really have a lot
of new physics updates I'd


30
00:01:32,316 --> 00:01:33,696
like to give you an update on.


31
00:01:34,296 --> 00:01:35,136
And the integration


32
00:01:35,136 --> 00:01:37,446
with SceneKit really
brings new possibilities


33
00:01:37,446 --> 00:01:39,016
of writing to these games.


34
00:01:39,426 --> 00:01:42,826
It also blurs the lines
between the actual 2D game


35
00:01:42,826 --> 00:01:44,186
and 3D game implementations.


36
00:01:45,196 --> 00:01:48,146
And lastly, I'm going to give
you a quick tour and demo


37
00:01:48,146 --> 00:01:51,426
of the new SpriteKit editor
and some other improvements


38
00:01:51,426 --> 00:01:53,056
in already existing APIs.


39
00:01:53,056 --> 00:01:57,746
So the first thing I want
to talk about is shaders.


40
00:01:59,076 --> 00:02:02,916
SpriteKit does a fantastic job
of extracting the lower-level,


41
00:02:02,916 --> 00:02:06,416
platform-dependent graphics
APIs away from our users.


42
00:02:06,986 --> 00:02:11,096
But from time to time there's
always a very special effect


43
00:02:11,096 --> 00:02:17,016
they want to achieve, say a
custom blur or a heat signature


44
00:02:17,016 --> 00:02:20,396
when you turn on thermal
vision, the post-effect,


45
00:02:20,596 --> 00:02:23,196
or when you build a space game
where the spaceship's hit,


46
00:02:23,366 --> 00:02:26,306
taking damage, you want to have
a custom warping effect just on,


47
00:02:26,306 --> 00:02:27,026
like, the sprite.


48
00:02:27,786 --> 00:02:30,716
The shaders become a more
relevant solution in this case


49
00:02:30,996 --> 00:02:33,406
and for this release we
do give you the ability.


50
00:02:35,126 --> 00:02:36,916
So here we have a
SpriteKit shader demo.


51
00:02:37,006 --> 00:02:39,746
We're actually just
rendering a single sprite


52
00:02:39,746 --> 00:02:43,086
without any textures but
the sprite itself is running


53
00:02:43,086 --> 00:02:43,876
on custom shaders.


54
00:02:44,266 --> 00:02:45,716
So the shader does a
lot of things here.


55
00:02:46,196 --> 00:02:47,986
Its' rendering all the
stars in the background;


56
00:02:47,986 --> 00:02:50,936
it's also drawing the grid;
also provides the warping effect


57
00:02:50,936 --> 00:02:53,366
of the grid; and also
when the touch --


58
00:02:53,456 --> 00:02:56,746
the user touches any of
the screen areas it's going


59
00:02:56,746 --> 00:02:58,176
to provide an energy effect.


60
00:02:58,686 --> 00:03:00,356
So all of these are
done in shaders.


61
00:03:00,686 --> 00:03:05,326
So to do this we're also passing
the actual touch locations


62
00:03:05,326 --> 00:03:06,786
down to the shaders as uniform.


63
00:03:06,786 --> 00:03:09,066
So in a shader, shader
knows, "Okay,


64
00:03:09,316 --> 00:03:10,566
the user just touched this area.


65
00:03:10,566 --> 00:03:12,196
Now let's render
the warping here


66
00:03:12,506 --> 00:03:15,176
and render the energy
effect associated with it."


67
00:03:15,916 --> 00:03:18,786
So let's have a look at what the
overview of a shader looks like.


68
00:03:19,276 --> 00:03:22,316
So shader helps you
really customize the way


69
00:03:22,316 --> 00:03:23,136
that sprites are drawn.


70
00:03:23,136 --> 00:03:26,896
You have 100 percent control of
how every single pixel is going


71
00:03:26,896 --> 00:03:28,086
to be output on the screen.


72
00:03:29,236 --> 00:03:32,606
The shader syntax uses
very a C-like GLSL syntax,


73
00:03:32,916 --> 00:03:36,846
a very powerful tool to have
any of the powerful effects,


74
00:03:36,846 --> 00:03:38,996
like image processing or, to --


75
00:03:38,996 --> 00:03:42,956
all the way to fast motion blurs
that's being used in 3D games.


76
00:03:43,626 --> 00:03:45,726
And whether you are
new to SpriteKit


77
00:03:45,726 --> 00:03:48,776
or existing SpriteKit users,
you can drop this custom shader


78
00:03:48,776 --> 00:03:50,946
in with just a single
line of code.


79
00:03:51,506 --> 00:03:55,756
So to use custom shaders we
create a brand new object called


80
00:03:55,756 --> 00:03:56,656
SKShaders object.


81
00:03:56,956 --> 00:04:00,406
It is essentially a
container that holds the GLSL,


82
00:04:00,406 --> 00:04:01,866
the OpenGL ES fragment shader.


83
00:04:01,866 --> 00:04:03,816
So we're following the GLSL --


84
00:04:03,876 --> 00:04:08,466
OpenGL ES 2.0 standard and once
you write a shader it can be


85
00:04:08,526 --> 00:04:10,666
deployed to both OS X and iOS.


86
00:04:11,996 --> 00:04:14,726
So here is a list of the
nodes that's being supported


87
00:04:14,726 --> 00:04:15,366
in SpriteKit.


88
00:04:15,366 --> 00:04:17,546
So SKSpriteNode supports
custom shaders


89
00:04:18,016 --> 00:04:21,435
and SKShapeNode now supports
custom shaders on both drawings,


90
00:04:21,435 --> 00:04:22,616
the stroking and filling.


91
00:04:23,366 --> 00:04:24,666
And SKEmmiterNode.


92
00:04:24,986 --> 00:04:28,696
So with the particle effect you
have a custom shader running


93
00:04:28,696 --> 00:04:30,936
on every single emitter
particles in the Scene.


94
00:04:31,466 --> 00:04:33,086
And lastly the EffectNode


95
00:04:33,086 --> 00:04:35,246
and SKScene now support
custom shaders.


96
00:04:35,546 --> 00:04:37,426
So that gives you
the powerful ability


97
00:04:37,426 --> 00:04:41,006
to not only use the CI filters
to have a full-screen effect,


98
00:04:41,306 --> 00:04:44,646
but also you can have a shader
to have any possible effect


99
00:04:44,646 --> 00:04:45,876
that you want to implement.


100
00:04:46,836 --> 00:04:49,286
So, as soon as the shader is
getting uploaded to the sprite


101
00:04:49,286 --> 00:04:53,026
and it's being run at the pixel
level, we're also passing a lot


102
00:04:53,026 --> 00:04:54,646
of building attributes
to the shader.


103
00:04:54,646 --> 00:04:57,716
So we don't have to set
up a brand-new attribute


104
00:04:57,716 --> 00:04:59,366
or uniforms and pass it in.


105
00:04:59,546 --> 00:05:01,626
So, for example, here
we're passing the u-texture


106
00:05:01,886 --> 00:05:03,926
that gives it to you as
what texture is being used


107
00:05:03,926 --> 00:05:05,806
for the current sprite
as well as,


108
00:05:05,806 --> 00:05:08,336
as well as the texture
coordinate and the size


109
00:05:08,336 --> 00:05:10,606
of the sprite that's
in pixel size.


110
00:05:12,606 --> 00:05:14,776
So how does shader
work in SpriteKit?


111
00:05:14,916 --> 00:05:20,756
Once you know about the SKShader
class now it has two possible


112
00:05:21,056 --> 00:05:22,296
attributes that you
can start on.


113
00:05:22,296 --> 00:05:23,876
The first one is
the shader source.


114
00:05:24,236 --> 00:05:26,166
You can create a shader
from two possibilities


115
00:05:26,166 --> 00:05:27,206
by attaching the source.


116
00:05:27,496 --> 00:05:29,816
One is creating the
shader from a file


117
00:05:30,186 --> 00:05:33,356
and also you can set the
shader from a string.


118
00:05:34,726 --> 00:05:37,556
And the shader itself also
has an array of uniforms.


119
00:05:37,556 --> 00:05:41,076
These are optional, but if your
shader actually requires any


120
00:05:41,076 --> 00:05:43,956
of the external parameters
that're being set in your game,


121
00:05:44,376 --> 00:05:48,156
you can use that SK uniforms
on the uniforms property.


122
00:05:48,966 --> 00:05:51,146
So now once we have
these two properties set,


123
00:05:51,606 --> 00:05:54,796
the shader is loaded
and is ready to go.


124
00:05:55,996 --> 00:05:58,116
And we have a scene
here, for example,


125
00:05:58,116 --> 00:05:59,746
a scene has three
separate sprites.


126
00:06:00,096 --> 00:06:02,416
You can assign a shader
directly to the scene.


127
00:06:02,416 --> 00:06:05,396
You can assign the shader
to any of the sprites


128
00:06:05,486 --> 00:06:08,056
and then they picked up
the effect right away


129
00:06:08,056 --> 00:06:12,066
in the next, in the next frame.


130
00:06:12,066 --> 00:06:14,916
So creating a shader will have
the new API called SKShader.


131
00:06:14,916 --> 00:06:16,576
It can create with a file.


132
00:06:16,576 --> 00:06:19,386
SKShader WithFileNamed with
passing like "blur.fsh".


133
00:06:19,476 --> 00:06:23,946
The shader will look like any
G, OpenGL fragment program


134
00:06:23,946 --> 00:06:25,056
that has a main function


135
00:06:25,506 --> 00:06:27,726
and in the return values
and the gl-FragColor.


136
00:06:28,246 --> 00:06:29,316
And if the shader needs any


137
00:06:29,316 --> 00:06:32,486
of the custom uniforms you can
just set a uniforms array here


138
00:06:32,486 --> 00:06:36,066
with creating SKUinform
uniformWithName.


139
00:06:36,066 --> 00:06:37,016
You give it a name here.


140
00:06:37,016 --> 00:06:39,146
We call it u-red,
that's a floating type


141
00:06:39,666 --> 00:06:42,196
and the next one we're
setting a u texture,


142
00:06:42,196 --> 00:06:45,516
or passing in a secondary
texture to the custom shader.


143
00:06:46,036 --> 00:06:50,516
So the supported types are
float, texture, back to 2,


144
00:06:50,516 --> 00:06:54,376
3 and 4 and matrix
2x2, 3x3 and 4x4.


145
00:06:57,186 --> 00:06:59,636
And for the full list
of the custom symbols


146
00:06:59,636 --> 00:07:00,976
that we're passing
into the shader,


147
00:07:00,976 --> 00:07:02,406
as soon as your shader
is getting run,


148
00:07:02,646 --> 00:07:03,446
here is the full list.


149
00:07:03,666 --> 00:07:07,226
So in terms of uniform, you get
direct access to the texture


150
00:07:07,226 --> 00:07:10,316
of the sprite, the
sprite size in pixels,


151
00:07:10,626 --> 00:07:13,416
the global time (in case you
need to do any of the animation


152
00:07:13,416 --> 00:07:16,736
in terms of color or shapes)
and you also have access,


153
00:07:17,006 --> 00:07:19,336
if you have a custom shader
that's running on a shape,


154
00:07:19,766 --> 00:07:21,256
to the shape path length.


155
00:07:22,296 --> 00:07:24,716
In terms of varying we're
passing the texture coordinate,


156
00:07:24,866 --> 00:07:28,366
the color mix, as well as
the distance of the path


157
00:07:29,316 --> 00:07:32,136
and we also have a very
convenient method in the shader,


158
00:07:32,136 --> 00:07:34,826
so you can call directly,
called SKDefaultShading.


159
00:07:35,056 --> 00:07:37,486
This is as if you were


160
00:07:37,486 --> 00:07:40,316
to let SpriteKit render
the current sprite


161
00:07:40,416 --> 00:07:44,406
and give me the pixel value
of the current behavior.


162
00:07:44,966 --> 00:07:47,576
So the shaders are cool.


163
00:07:47,576 --> 00:07:50,656
There's some best practices
I'd like to call out.


164
00:07:50,656 --> 00:07:54,666
So number one, I'd like to
recommend using built-in


165
00:07:54,666 --> 00:07:56,266
uniforms as much as possible.


166
00:07:56,516 --> 00:07:58,656
So we do passing a lot of
uniforms for you to use.


167
00:07:58,656 --> 00:08:00,856
That gives you a lot
of raw attributes


168
00:08:00,856 --> 00:08:03,246
of what we're doing
at the OpenGL level.


169
00:08:03,746 --> 00:08:07,346
But if you do need to access
all the same uniforms,


170
00:08:07,606 --> 00:08:08,966
please use the building one


171
00:08:08,966 --> 00:08:10,656
to minimize the amount
of redundancy.


172
00:08:11,246 --> 00:08:14,466
And also we would recommend


173
00:08:14,466 --> 00:08:17,416
to avoid changing this shader
source in the middle of a frame


174
00:08:17,416 --> 00:08:19,926
because that will force a
shader recompilation happening


175
00:08:20,006 --> 00:08:21,386
at the backend.


176
00:08:21,386 --> 00:08:25,596
And also when the shader is
being loaded and we recommend


177
00:08:25,596 --> 00:08:28,046
to loadset all the
uniforms upfront


178
00:08:29,006 --> 00:08:30,776
and you can change
uniforms that reframe,


179
00:08:30,776 --> 00:08:31,896
but that's nice and fast.


180
00:08:32,176 --> 00:08:34,746
But adding or removing
uniforms will also cause another


181
00:08:34,746 --> 00:08:35,746
shader recompilation.


182
00:08:37,885 --> 00:08:40,106
Also in terms of draw
call performance we


183
00:08:40,106 --> 00:08:44,496
like to share the same shader
instance as much as possible


184
00:08:44,496 --> 00:08:45,996
because the same shader running


185
00:08:45,996 --> 00:08:49,406
on multiple drawing instances
gets to batch together.


186
00:08:50,556 --> 00:08:53,476
And we'll recommend to
initialize the shader


187
00:08:53,476 --> 00:08:57,756
at load time and initialize the
shader using a filename rather


188
00:08:57,756 --> 00:09:01,786
than initialize shader using
string because if the shaders --


189
00:09:01,786 --> 00:09:04,566
multiple shaders are sharing
the same shader source then


190
00:09:04,566 --> 00:09:07,376
SpriteKit will pick it
up as identical shaders


191
00:09:07,376 --> 00:09:10,276
or drawbacks -- draw
call batching performance


192
00:09:10,556 --> 00:09:11,296
remain high.


193
00:09:11,636 --> 00:09:15,616
So the summary of using
custom shaders: it allows you


194
00:09:15,616 --> 00:09:18,876
to completely customize the
way sprites are being rendered


195
00:09:18,876 --> 00:09:19,436
on the screen.


196
00:09:19,716 --> 00:09:22,666
You have raw access to a
lot of building attributes


197
00:09:22,666 --> 00:09:25,326
that we're passing
down to the shader.


198
00:09:25,826 --> 00:09:27,756
And it can create an
infinite number of cool


199
00:09:27,756 --> 00:09:29,196
and unique effects
for your game.


200
00:09:29,596 --> 00:09:32,496
Next I want to talk about
lightings and shadows.


201
00:09:33,856 --> 00:09:35,726
So lightings and
shadows really bring


202
00:09:35,726 --> 00:09:37,636
out the liveliness
of your games.


203
00:09:37,636 --> 00:09:39,556
Say, if I'm building
a dungeons game,


204
00:09:39,556 --> 00:09:41,296
and walking in a
long corridor...


205
00:09:41,536 --> 00:09:44,106
All of a sudden the
area gets dark,


206
00:09:44,106 --> 00:09:46,576
and all of a sudden
I see a very dim,


207
00:09:46,576 --> 00:09:48,536
shaky light at the
end of the hallway...


208
00:09:48,536 --> 00:09:52,436
that kind of brings out
that really scary atmosphere


209
00:09:52,436 --> 00:09:54,946
and mood for the player.


210
00:09:55,646 --> 00:09:57,036
So to create a light


211
00:09:57,036 --> 00:10:00,966
in SpriteKit we introduce a
new type called SKLightNode.


212
00:10:01,966 --> 00:10:05,476
You can add it to the scene and
position it to anywhere you want


213
00:10:06,226 --> 00:10:07,246
and it can light any


214
00:10:07,246 --> 00:10:09,056
of the sprites that're
being participated


215
00:10:09,056 --> 00:10:10,066
in the current light.


216
00:10:10,686 --> 00:10:14,376
You can change the color,
shadow and falloff of the light


217
00:10:15,006 --> 00:10:19,196
and will support up to 8 lights,
like, for a single sprite.


218
00:10:20,096 --> 00:10:23,176
And the bottom line
is SKLightNode is just


219
00:10:23,176 --> 00:10:24,186
another SKNode.


220
00:10:24,736 --> 00:10:27,746
You can move it around,
turn it to another sprite


221
00:10:27,746 --> 00:10:29,806
if you want the light to
follow one of your sprites.


222
00:10:30,206 --> 00:10:34,386
You can run actions on it,
have it run follow path.


223
00:10:34,906 --> 00:10:35,926
It's really cool.


224
00:10:37,246 --> 00:10:38,206
So now let's look at some


225
00:10:38,206 --> 00:10:41,196
of the basic add
properties for SKLightNode.


226
00:10:41,336 --> 00:10:42,356
So here we have a scene.


227
00:10:42,606 --> 00:10:43,446
It's very bland.


228
00:10:43,646 --> 00:10:45,736
We add a light source
in the scene.


229
00:10:46,926 --> 00:10:48,656
Now if -- we can change
to the lightColor,


230
00:10:48,656 --> 00:10:50,596
we decide the lightColor
to be yellow,


231
00:10:50,676 --> 00:10:52,836
it adds a yellow tint
to the light color.


232
00:10:53,666 --> 00:10:56,646
And now if we set a
shadowColor to be gray...


233
00:10:57,756 --> 00:10:59,806
and now the boxes start
casting shadows...


234
00:11:01,056 --> 00:11:03,686
and lastly if we want
to see a little bit more


235
00:11:03,686 --> 00:11:05,816
out of the scene we
set the ambientColor


236
00:11:05,816 --> 00:11:08,436
to really bring the scene
up a little bit more.


237
00:11:08,926 --> 00:11:12,336
So let's look at the additional
attributes for SKLightNode.


238
00:11:12,426 --> 00:11:13,576
The number one is falloff.


239
00:11:13,966 --> 00:11:18,916
Falloff controls the radius of
the light in terms of the effect


240
00:11:19,576 --> 00:11:21,786
and we also take what
works really well


241
00:11:21,786 --> 00:11:25,116
with our physics properties
with the category of BitMasks.


242
00:11:25,666 --> 00:11:28,476
So with SpriteNode now
you have individual,


243
00:11:28,476 --> 00:11:30,936
big control of whether the
sprite is participating


244
00:11:30,936 --> 00:11:33,176
in the lighting, whether
it's casting shadows


245
00:11:33,176 --> 00:11:34,876
or whether it's receiving
shadows.


246
00:11:35,116 --> 00:11:37,546
You have fine control
of exactly how you want


247
00:11:37,546 --> 00:11:40,376
to control these 3 attributes
for each individual sprite.


248
00:11:40,906 --> 00:11:44,316
And now since we are
talking about SpriteNode,


249
00:11:44,816 --> 00:11:48,236
SpriteNode also has a brand new
property called normalTexture,


250
00:11:48,236 --> 00:11:50,186
which you can assign
normalTexture with.


251
00:11:50,706 --> 00:11:54,306
So usually normalTexture
is heavily used in 3D games


252
00:11:54,746 --> 00:11:58,176
and normalTexture uses the
pixel RGB value to describe


253
00:11:58,176 --> 00:12:00,556
where the normal vector for the
surface is pointing towards,


254
00:12:00,826 --> 00:12:03,466
so the lighting calculation
can be used upon


255
00:12:03,466 --> 00:12:04,616
with the normal vectors.


256
00:12:05,166 --> 00:12:07,136
So here we're using
the exact same formula.


257
00:12:08,026 --> 00:12:09,876
So to render the scene


258
00:12:10,596 --> 00:12:15,216
with a normal map we use the
traditional A + B = C formula,


259
00:12:15,216 --> 00:12:17,266
which means you supply
the texture --


260
00:12:17,746 --> 00:12:21,726
you supply the normalTexture
-- SpriteKit will do its magic


261
00:12:21,726 --> 00:12:25,406
and give you the result,
which is lighting up the scene


262
00:12:25,406 --> 00:12:27,866
with the bumpy service
that's being mapped.


263
00:12:28,226 --> 00:12:31,026
So here you-- as you can see
I can just set normalTexture


264
00:12:31,026 --> 00:12:34,126
directly on the SKSpriteNode
by loading it


265
00:12:34,566 --> 00:12:36,466
from the normal .png file.


266
00:12:38,156 --> 00:12:40,326
So now being SpriteKit we


267
00:12:40,326 --> 00:12:43,886
like to make our user's
life as easy as possible.


268
00:12:43,886 --> 00:12:48,876
So in addition to the A + B =
C formula we get you directly


269
00:12:48,876 --> 00:12:49,926
from A to C.


270
00:12:50,196 --> 00:12:52,426
You do not need to
supply any NormalMap.


271
00:12:52,496 --> 00:12:55,706
So, what we do is we take
the source texture image


272
00:12:56,016 --> 00:13:00,286
and perform image analyzation
on every single pixel,


273
00:13:00,286 --> 00:13:01,886
and based on the
bightness of each pixel,


274
00:13:02,236 --> 00:13:04,026
we have a multi-path algorithm


275
00:13:04,026 --> 00:13:05,986
that generate the
best normal map


276
00:13:06,336 --> 00:13:08,196
that describes the
current picture.


277
00:13:08,426 --> 00:13:12,066
So if you give us a picture
that you take from the beach,


278
00:13:12,066 --> 00:13:13,446
which is a bunch of rocks,


279
00:13:13,446 --> 00:13:16,686
and their rounded
edges are really sharp


280
00:13:16,686 --> 00:13:18,716
yet the surface remains
very smooth...


281
00:13:19,246 --> 00:13:20,466
So here it's very easy.


282
00:13:20,466 --> 00:13:21,736
It's magic one liner.


283
00:13:21,736 --> 00:13:26,286
All we need to do is just
sprite.normalTexture = generate


284
00:13:26,736 --> 00:13:29,706
a NormalMap from the
existing sprite's texture.


285
00:13:29,706 --> 00:13:30,226
[ Applause ]


286
00:13:30,226 --> 00:13:31,646
That's not all.


287
00:13:32,426 --> 00:13:36,736
There is not a solution, or
a one-size-fits-all solution.


288
00:13:37,246 --> 00:13:40,806
So, in addition we provide two
more parameters for you guys


289
00:13:40,806 --> 00:13:44,216
to change the dynamic behavior
of the GeneratingNormalMap


290
00:13:44,556 --> 00:13:46,506
in terms of smoothness, in terms


291
00:13:46,506 --> 00:13:49,596
of contrast (which is how
bumpy you want the main surface


292
00:13:49,596 --> 00:13:50,146
to be).


293
00:13:50,936 --> 00:13:51,836
And this will give --


294
00:13:51,836 --> 00:13:54,326
in combination will give you
an infinite number of looks.


295
00:13:54,326 --> 00:13:59,356
For example, our cobblestone I
just have two for loops running


296
00:13:59,356 --> 00:14:01,636
on these parameters
with 1 second delay.


297
00:14:01,636 --> 00:14:03,976
As you can see it
actually changed the look.


298
00:14:03,976 --> 00:14:06,006
You can get an infinite
number of looks out of it.


299
00:14:06,306 --> 00:14:07,086
And the best part


300
00:14:07,086 --> 00:14:10,376
about automatic NormalMap
generation is you can do this


301
00:14:10,376 --> 00:14:11,596
on dynamic content.


302
00:14:11,956 --> 00:14:15,516
If the user takes a picture
from outside and decides to put


303
00:14:15,516 --> 00:14:16,706
that in the game, guess what?


304
00:14:16,746 --> 00:14:18,696
You can light it without
any normal texture.


305
00:14:18,956 --> 00:14:20,516
We can do all of this for you.


306
00:14:21,046 --> 00:14:24,896
So to summarize lighting
and shadows,


307
00:14:25,726 --> 00:14:27,286
they are very easy to use.


308
00:14:27,376 --> 00:14:30,126
SKLightNode is just
like any SKNode.


309
00:14:30,126 --> 00:14:31,266
You can run animation on it.


310
00:14:31,266 --> 00:14:32,116
You can parent it.


311
00:14:32,386 --> 00:14:34,796
You can set up colors and
everything is a one-liner.


312
00:14:35,376 --> 00:14:38,896
Automatic normal map generation
really provides this dynamic


313
00:14:38,896 --> 00:14:39,466
look for you.


314
00:14:39,586 --> 00:14:42,816
You don't have to spend time
sitting down with artists


315
00:14:42,816 --> 00:14:45,486
and trying to figure out how
to hand-paint a normal map.


316
00:14:45,796 --> 00:14:49,266
"Oh, it's purple facing outward
or green facing to the left."


317
00:14:49,646 --> 00:14:50,926
You don't have to
do any of that.


318
00:14:50,926 --> 00:14:53,176
We take out the nitty-gritty
detail for you.


319
00:14:53,586 --> 00:14:56,386
There's some best
practices in terms


320
00:14:56,386 --> 00:14:57,826
of performance I'd
like to point out.


321
00:14:58,116 --> 00:14:59,836
It's okay to have multiple
lights in the scene


322
00:14:59,836 --> 00:15:01,536
and it runs reasonably fast.


323
00:15:01,776 --> 00:15:03,866
But if you have -- the number


324
00:15:03,866 --> 00:15:06,736
of lights that's lighting
the very same sprite


325
00:15:06,736 --> 00:15:07,556
actually matters.


326
00:15:07,836 --> 00:15:10,776
And if I have more than two
lights lighting the same sprite


327
00:15:11,156 --> 00:15:13,906
you might not be able
to stay on constant 60


328
00:15:13,906 --> 00:15:15,406
on certain iOS hardwares.


329
00:15:15,456 --> 00:15:16,776
It's just something
to point out.


330
00:15:17,226 --> 00:15:22,516
Next I'd like to point out
all the new physics features


331
00:15:22,516 --> 00:15:23,166
that we have.


332
00:15:23,286 --> 00:15:24,166
So let's look at them.


333
00:15:24,776 --> 00:15:29,526
Number 1, per-pixel physics
updates: we have constraints,


334
00:15:29,926 --> 00:15:32,996
allows to remove the boilerplate
code in your updates.


335
00:15:33,286 --> 00:15:34,986
We also have inverse kinematics:


336
00:15:34,986 --> 00:15:37,646
allow to you build
mechanical AI.


337
00:15:37,946 --> 00:15:41,216
We also have physics fields
that apply these forces,


338
00:15:41,216 --> 00:15:43,666
allow you to build the
next space game simulation.


339
00:15:44,576 --> 00:15:47,356
So let's look at the per-pixel
physics body creation.


340
00:15:48,426 --> 00:15:50,806
With the current
implementation on the left side,


341
00:15:51,276 --> 00:15:54,836
if I want to build a
gears game, I can't.


342
00:15:55,456 --> 00:15:58,486
The best thing I can do
is use bounding circles


343
00:15:58,586 --> 00:16:00,096
and create the bounding circles


344
00:16:00,096 --> 00:16:01,836
around these box,
uh, these gears.


345
00:16:01,836 --> 00:16:04,136
They don't actually
grind each other


346
00:16:04,136 --> 00:16:05,656
and the teeth don't interlock.


347
00:16:06,176 --> 00:16:08,006
Okay, maybe I can
fake it a little bit.


348
00:16:08,096 --> 00:16:10,146
I reduce the radius
of the physics bodies


349
00:16:10,146 --> 00:16:11,936
so that the teeth might overlap,


350
00:16:12,416 --> 00:16:15,096
but they still don't
touch exactly.


351
00:16:15,096 --> 00:16:19,176
And also, the angular
velocity don't transfer


352
00:16:19,176 --> 00:16:20,376
from one gear to another.


353
00:16:20,826 --> 00:16:24,316
But now with a single line of
code you can generate from --


354
00:16:24,586 --> 00:16:28,326
go from there to give
you a physics, uh,


355
00:16:28,496 --> 00:16:30,946
a pixel-based physics body.


356
00:16:31,286 --> 00:16:32,016
It's very easy.


357
00:16:32,016 --> 00:16:32,286
[ Applause ]


358
00:16:32,286 --> 00:16:34,116
So when we introspect
the source image,


359
00:16:34,466 --> 00:16:37,676
based on the alpha mask we
generate a rough shape and based


360
00:16:37,676 --> 00:16:41,126
on the shape we generate an
exact shape that's the minimal


361
00:16:41,266 --> 00:16:42,676
in order to fit the
current sprite.


362
00:16:43,336 --> 00:16:44,276
It's very accurate.


363
00:16:44,346 --> 00:16:45,956
And now, to build
the gears demo,


364
00:16:46,266 --> 00:16:49,166
you can just have a couple
one-liners, have the same code


365
00:16:49,166 --> 00:16:52,126
in there, just change from
using bounding circles


366
00:16:52,126 --> 00:16:55,576
to using image-based physics
body and you are good to go.


367
00:16:55,796 --> 00:16:57,786
And they can be pinned,
they can be transferring


368
00:16:57,786 --> 00:17:00,016
and interlocking;
it's really fun.


369
00:17:01,116 --> 00:17:02,506
So, let's look at how we do it.


370
00:17:03,066 --> 00:17:06,506
So, with the current API
to create a physics body


371
00:17:06,506 --> 00:17:09,506
with a bounding box
we use physicsBody


372
00:17:10,296 --> 00:17:14,616
and bodyWithRectangleOfSize will
give you an exact bounding box


373
00:17:14,616 --> 00:17:16,316
of the dimensions that
you have specified.


374
00:17:17,026 --> 00:17:20,616
Now, with a new API it's
the same initializer.


375
00:17:20,616 --> 00:17:21,336
Convenient.


376
00:17:21,336 --> 00:17:23,136
Instead you're just
passing the texture


377
00:17:23,376 --> 00:17:24,556
and the size of the texture.


378
00:17:24,856 --> 00:17:28,136
For example, a hammer here will
give you the exact hammer body


379
00:17:28,136 --> 00:17:29,266
that's traced with the outline.


380
00:17:29,266 --> 00:17:32,416
You no longer have to
do that yourself or try


381
00:17:32,416 --> 00:17:35,186
to build any approximation
of the physics bodies.


382
00:17:37,196 --> 00:17:38,206
Just like the automatic


383
00:17:38,206 --> 00:17:41,066
and NormalMap generation there's
not a one solution fits all.


384
00:17:41,256 --> 00:17:44,246
If you have a source
art that has a lot


385
00:17:44,246 --> 00:17:46,756
of semi-transparent
pixels we do allow you


386
00:17:46,756 --> 00:17:50,596
to specify the alpha
threshold, which defines


387
00:17:50,866 --> 00:17:53,606
which pixels are being
interpolated during the process


388
00:17:53,606 --> 00:17:55,246
as opaque or not.


389
00:17:56,116 --> 00:18:02,346
So in summary, per-pixel physics
body is very easy to create.


390
00:18:02,516 --> 00:18:03,856
They're very accurate.


391
00:18:05,236 --> 00:18:08,886
And whether you are existing
SpriteKit users or new


392
00:18:08,886 --> 00:18:13,876
to the APIs it's just a matter
of setting one line change


393
00:18:13,876 --> 00:18:17,166
in your codes to create really
accurate physics simulations.


394
00:18:18,306 --> 00:18:20,376
So again I'd like to point
out the performance tips.


395
00:18:20,986 --> 00:18:24,476
SpriteKit does a really good
job of optimizing this algorithm


396
00:18:24,526 --> 00:18:27,446
and we provide a good
balance between performance


397
00:18:27,446 --> 00:18:30,386
and accuracy, but the
texture size matters.


398
00:18:30,936 --> 00:18:35,266
So if you are passing in a
2K by 2K texture and scale it


399
00:18:35,266 --> 00:18:38,566
down to 10 percent
by rendering a 20 by,


400
00:18:38,566 --> 00:18:42,826
200 by 200 sprite we do have
to work down the whole 2K


401
00:18:42,946 --> 00:18:46,396
by 2K pixels in order to
figure out the exact shape,


402
00:18:46,916 --> 00:18:48,986
so just something
to think about.


403
00:18:49,746 --> 00:18:54,776
Next: a brand new
API, the constraints


404
00:18:54,776 --> 00:18:58,436
to help you really simplify
the game update logic.


405
00:18:59,526 --> 00:19:02,576
The constraints, the motivation
of creating constraint for us is


406
00:19:02,576 --> 00:19:05,976
to really remove the boilerplate
code in your updates.


407
00:19:05,976 --> 00:19:08,846
So, a lot of times if I
want to move a character


408
00:19:09,066 --> 00:19:10,406
but I want a health indicator


409
00:19:10,406 --> 00:19:13,736
to follow the character
that's exactly 5 pixels above,


410
00:19:13,736 --> 00:19:14,856
2 pixels behind...


411
00:19:15,576 --> 00:19:17,466
I need to put that in
the update somewhere.


412
00:19:17,466 --> 00:19:20,146
I need to have a cannon; you
want to orient the cannon


413
00:19:20,146 --> 00:19:21,446
to follow the airplane.


414
00:19:21,946 --> 00:19:25,076
Guess what, I need to add that
code in to calculate the angle


415
00:19:25,076 --> 00:19:26,596
and figure out the delta,


416
00:19:26,596 --> 00:19:29,136
translate the delta rotation
inside the translation.


417
00:19:29,336 --> 00:19:31,396
Or if the airplane wants
to land on the runway,


418
00:19:31,396 --> 00:19:32,756
I need to orient that first.


419
00:19:33,456 --> 00:19:35,956
We do all of that work
for you; we can do it


420
00:19:35,956 --> 00:19:36,906
with simple constraints.


421
00:19:39,516 --> 00:19:43,146
So now we add, because of the
constraint that's being added,


422
00:19:43,956 --> 00:19:47,456
we need to add some new
features in our update loop.


423
00:19:47,846 --> 00:19:51,016
So in the update loop, we
expand it to some new selectors.


424
00:19:51,576 --> 00:19:55,386
Number 1, right after physics
simulation now the scene starts


425
00:19:55,386 --> 00:19:56,606
kicking in the constraint.


426
00:19:56,976 --> 00:19:59,636
So constraints are not
limited to physics anymore,


427
00:19:59,636 --> 00:20:01,386
so you don't have
to worry about "Oh,


428
00:20:01,386 --> 00:20:02,976
is the character standing
on a conveyor belt?


429
00:20:03,106 --> 00:20:05,156
Is it going to be pushed


430
00:20:05,156 --> 00:20:07,526
over because the box
is right beside it?"


431
00:20:07,696 --> 00:20:09,116
Constraints will take
care of that for you.


432
00:20:09,646 --> 00:20:11,436
And right after constraint
update,


433
00:20:11,436 --> 00:20:15,066
users have another chance
of doing another update.


434
00:20:15,066 --> 00:20:18,196
We do give the user a
callback on didApplyConstraints


435
00:20:18,436 --> 00:20:21,896
so here you have a chance to do
any other last minute cleanup.


436
00:20:23,826 --> 00:20:25,766
And the basis of constraints,


437
00:20:25,906 --> 00:20:28,906
again we'll have a new object
called SKConstraint object.


438
00:20:29,036 --> 00:20:31,776
It is used to wrap around
this mathematical constraint


439
00:20:31,776 --> 00:20:33,946
on the properties of the node
that you want to animate.


440
00:20:34,696 --> 00:20:37,216
So the constraints
are then attached


441
00:20:37,216 --> 00:20:39,696
to nodes via the new
constraints array.


442
00:20:40,406 --> 00:20:42,216
And the scene will
apply the constraints


443
00:20:42,296 --> 00:20:43,676
to the attached node.


444
00:20:43,906 --> 00:20:47,006
So what kind of constraints
can it set on a node?


445
00:20:47,416 --> 00:20:51,076
You can set the constraints
on position, orientation


446
00:20:51,446 --> 00:20:53,896
and distance and you
can quickly enable


447
00:20:53,896 --> 00:20:55,426
and disable between frames.


448
00:20:56,866 --> 00:20:58,706
So for example, let's
look at a quick example


449
00:20:58,706 --> 00:21:02,246
of how the orientToNode
constraint works.


450
00:21:02,616 --> 00:21:04,166
So we just call SKConstraint


451
00:21:04,266 --> 00:21:07,856
with orientToNode
initializer and follow a node.


452
00:21:07,856 --> 00:21:10,976
So here the arrow's just
following the circle


453
00:21:10,976 --> 00:21:12,976
and then we're just
passing the circle.


454
00:21:13,146 --> 00:21:16,616
[inaudible] the SKNode and
the range of offset is 0


455
00:21:16,616 --> 00:21:19,376
and you can set, I want to
lead the circle following in


456
00:21:19,376 --> 00:21:22,196
or lagging it, you
have that possibility.


457
00:21:22,836 --> 00:21:26,526
So once the constraint is
created I just directly set


458
00:21:27,056 --> 00:21:29,186
on the arrow's constraints
property.


459
00:21:30,616 --> 00:21:33,636
Next, how do we set
position of constraint?


460
00:21:34,056 --> 00:21:37,886
So here we create a positional
range of minus 100 to 100.


461
00:21:38,646 --> 00:21:43,056
We can first set the limit
of constraint on the X axis.


462
00:21:43,056 --> 00:21:46,086
This will limit the movement
in the X direction of the node.


463
00:21:47,506 --> 00:21:49,626
Now we can also set
it on the Y direction,


464
00:21:49,626 --> 00:21:51,696
that will give a
limitation on the Y axis.


465
00:21:53,056 --> 00:21:56,896
And if you combine these two
together you are limiting the


466
00:21:56,896 --> 00:22:00,806
movement of the current
node to a 200 by 200 box;


467
00:22:01,166 --> 00:22:02,526
very, very simple to use.


468
00:22:02,816 --> 00:22:05,056
You no longer have to
write all this update code


469
00:22:05,436 --> 00:22:09,156
that will manually snap
the object back in the box.


470
00:22:09,786 --> 00:22:13,056
So in summary, it really
helps you remove a lot


471
00:22:13,056 --> 00:22:14,166
of the boilerplate code,


472
00:22:14,426 --> 00:22:16,386
making sure you just write
the code that's focused


473
00:22:16,436 --> 00:22:17,926
on building the game
you want rather


474
00:22:17,926 --> 00:22:19,706
than having to fix up things.


475
00:22:20,546 --> 00:22:23,876
And also the -- because the
constraints is the array


476
00:22:24,496 --> 00:22:30,196
that you can add the multiple
constraints into the same array


477
00:22:30,196 --> 00:22:32,466
and the order of
evaluation happens from --


478
00:22:33,116 --> 00:22:35,256
is based on the order of the
insertion into the array.


479
00:22:35,966 --> 00:22:38,646
And we also offer a lot
of varieties of constraint


480
00:22:38,646 --> 00:22:41,256
into position orientation
and distance.


481
00:22:41,726 --> 00:22:47,096
Next, I'd like to talk
about inverse kinematics.


482
00:22:47,786 --> 00:22:50,216
This is usually a very
strange word for people


483
00:22:50,756 --> 00:22:54,066
who doesn't have a mechanical
engineering degree or people


484
00:22:54,066 --> 00:22:56,706
who haven't written
an animation engine.


485
00:22:57,116 --> 00:23:01,566
So inverse kinematics allow
you to use kinematics equations


486
00:23:01,566 --> 00:23:04,326
to solve the joint parameters


487
00:23:04,486 --> 00:23:06,526
if you have a joint
hierarchy trying to reach


488
00:23:06,526 --> 00:23:08,696
for things in a 2D space.


489
00:23:09,136 --> 00:23:12,226
So here I'm trying to use
the robot arm reaching


490
00:23:12,226 --> 00:23:15,346
for where my mouse cursor is
pointing and I want to set


491
00:23:15,346 --> 00:23:18,226
up the exact behavior of
how the robot will move.


492
00:23:18,576 --> 00:23:21,176
I imagine to do that you
will update yourself and try


493
00:23:21,176 --> 00:23:22,146
to do this every frame.


494
00:23:22,146 --> 00:23:24,016
Okay, it's easy to
move the hand and now,


495
00:23:24,016 --> 00:23:26,026
what does the lower
hand is going to do?


496
00:23:26,026 --> 00:23:28,336
Followed by what the upper
hand is going to do to provide


497
00:23:28,336 --> 00:23:29,626
that realistic behavior.


498
00:23:29,886 --> 00:23:32,706
So you can do this for arms
and you can do this for legs.


499
00:23:33,076 --> 00:23:34,916
You can do it with
blend with animation.


500
00:23:36,006 --> 00:23:39,306
So number 1 of using inverse
kinematics is you need


501
00:23:39,306 --> 00:23:40,436
to have a joint hierarchy.


502
00:23:40,546 --> 00:23:41,386
So for example, if you look


503
00:23:41,386 --> 00:23:44,196
at the robot arm it's a
joint of three pieces.


504
00:23:44,496 --> 00:23:50,236
We start with the upper arm
(that's the root node) followed


505
00:23:50,236 --> 00:23:53,066
by the lower arm (which
is attached as a child


506
00:23:53,706 --> 00:23:57,136
to the upper arm) and then we'll
have the claw (which is attached


507
00:23:57,136 --> 00:23:59,216
as a child to the lower arm).


508
00:24:00,766 --> 00:24:02,236
So now each of these joints --


509
00:24:02,386 --> 00:24:06,216
to create a realistic look I
need to set up some constraint.


510
00:24:06,436 --> 00:24:10,666
For example, my arm, my elbow
probably opens at 180 degrees


511
00:24:10,706 --> 00:24:13,166
and closes at 30
and anything beyond


512
00:24:13,166 --> 00:24:14,506
that range is going to snap.


513
00:24:14,506 --> 00:24:16,616
I can't take it anymore.


514
00:24:17,176 --> 00:24:19,036
So you can set up
that constraint


515
00:24:19,036 --> 00:24:20,706
for each individual
node to create


516
00:24:20,706 --> 00:24:22,376
that really realistic behavior.


517
00:24:24,536 --> 00:24:26,976
So with SpriteKit how do
you do inverse kinematics?


518
00:24:27,466 --> 00:24:29,166
How do I set up the constraint?


519
00:24:29,166 --> 00:24:31,196
How do I set up the
parent-child hierarchy?


520
00:24:32,426 --> 00:24:33,516
You don't have to do that,


521
00:24:33,796 --> 00:24:35,746
because we use the
existing scene graph


522
00:24:35,746 --> 00:24:37,836
that already have the
parent-child relationship


523
00:24:38,176 --> 00:24:39,186
and we are good to go.


524
00:24:39,186 --> 00:24:42,476
The only thing you need to set
up is setting up the constraints


525
00:24:42,476 --> 00:24:44,806
on how each joints
open and close


526
00:24:44,916 --> 00:24:46,846
to create the realistic
look that you want


527
00:24:47,156 --> 00:24:48,586
and would provide actions


528
00:24:48,636 --> 00:24:50,606
to drive these constraints
of the chain.


529
00:24:51,496 --> 00:24:53,696
So the joint rotates
around its anchor point.


530
00:24:53,936 --> 00:24:56,446
So by default the anchor
point is at 0.5 and 0.5


531
00:24:56,446 --> 00:24:58,606
and that's not really
realistic for my shoulder.


532
00:24:58,766 --> 00:25:02,976
Probably set it to
0.5 - or, 0 and 0.5.


533
00:25:04,556 --> 00:25:07,616
So the constraint that we set is
called SKReachConstraint object.


534
00:25:07,796 --> 00:25:09,176
It simply have to
two properties;


535
00:25:09,176 --> 00:25:11,476
the lower angle limit
and upper angle limit.


536
00:25:11,926 --> 00:25:15,966
Once you have these angles
specified you can attach


537
00:25:16,226 --> 00:25:18,646
that to any of the SKNode
that's in the scene.


538
00:25:19,266 --> 00:25:21,896
And now you have a perfectly
working joint hierarchy.


539
00:25:22,376 --> 00:25:24,116
How do I drive it?


540
00:25:24,766 --> 00:25:27,256
To drive it, we provide
SKActions.


541
00:25:27,426 --> 00:25:30,926
We have two variants,
reachToNode and reachToPosition.


542
00:25:31,326 --> 00:25:33,786
So, if you want to
reach to a moving target


543
00:25:33,786 --> 00:25:35,486
or any stationary position


544
00:25:35,486 --> 00:25:37,196
within the scene
you can use either


545
00:25:37,246 --> 00:25:39,806
of the variants that's
being specified.


546
00:25:40,226 --> 00:25:44,306
So, here I have a quick
example of one-liner writing,


547
00:25:44,486 --> 00:25:47,506
running the SKAction of
reaching a constraint.


548
00:25:47,506 --> 00:25:51,856
So here we have a simple
4 -- 3 joint constraint.


549
00:25:51,856 --> 00:25:52,746
I use constraint.


550
00:25:52,846 --> 00:25:55,116
Each joint will have a
constraint of opening


551
00:25:55,116 --> 00:25:56,676
from 0 to 180 degrees.


552
00:25:57,036 --> 00:25:59,776
As you can see when the mouse
moves it actually obeys the


553
00:25:59,776 --> 00:26:02,346
constraint and tries
not to overbend and,


554
00:26:02,386 --> 00:26:04,446
but it really give you
that realistic look


555
00:26:04,766 --> 00:26:06,946
of mechanical bell
mechanical AI.


556
00:26:07,496 --> 00:26:14,406
And now we also take the same
inverse kinematics solver to 3D.


557
00:26:14,656 --> 00:26:16,376
It's much, much more interesting


558
00:26:16,376 --> 00:26:18,856
but it's also very
closely implemented just


559
00:26:18,856 --> 00:26:20,856
like this SpriteKit API.


560
00:26:20,986 --> 00:26:21,786
So you have SK --


561
00:26:21,936 --> 00:26:26,606
SCNIKConstraint and each node
has a SKConstraints array


562
00:26:26,606 --> 00:26:27,876
that you set these
constraints on.


563
00:26:28,136 --> 00:26:30,376
Also you have animation
influenceFactor.


564
00:26:30,546 --> 00:26:32,716
So here, I'll just
give you a quick demo.


565
00:26:33,186 --> 00:26:37,396
You have a 3D scene with a
3D character playing a punch


566
00:26:37,396 --> 00:26:39,696
animation, nothing,
nothing else is running.


567
00:26:40,836 --> 00:26:46,816
But now with IK running
I can blend it on top


568
00:26:46,816 --> 00:26:50,066
of the animation playback
at 60 frames per second,


569
00:26:50,426 --> 00:26:53,416
making sure the hand is always
punching at a red target.


570
00:26:53,846 --> 00:26:57,036
So now imagine the possibility
of I'm building a tennis game.


571
00:26:57,356 --> 00:26:59,606
All I now need is
two animations.


572
00:26:59,606 --> 00:27:01,886
One is the back paddle
and forward paddle,


573
00:27:02,196 --> 00:27:05,746
everything else I will let IK
take care of it so I don't have


574
00:27:05,746 --> 00:27:08,286
to build an infinite number
of animation combinations


575
00:27:08,316 --> 00:27:10,776
for the game to also
have the realistic look.


576
00:27:11,666 --> 00:27:14,836
So this really opened up
a lot of opportunities.


577
00:27:15,276 --> 00:27:18,186
So, in summary, inverse
kinematics is really easy


578
00:27:18,186 --> 00:27:18,596
to use.


579
00:27:18,596 --> 00:27:19,936
You don't even need
to set it up.


580
00:27:19,936 --> 00:27:21,876
The scene graph will
take care of it.


581
00:27:21,876 --> 00:27:24,236
And the constraints can be set


582
00:27:24,236 --> 00:27:25,786
on every single joint
that you have.


583
00:27:25,786 --> 00:27:27,866
You can control the
opening and closing angle


584
00:27:28,276 --> 00:27:31,336
and to drive these chains
you just run a single action


585
00:27:31,336 --> 00:27:34,096
one-liner and tell
the joint to reach


586
00:27:34,096 --> 00:27:35,456
out for a position or a node.


587
00:27:35,876 --> 00:27:40,236
Next, I want to talk
about physics fields.


588
00:27:41,886 --> 00:27:45,546
Now physics fields are
a type of field forces


589
00:27:45,856 --> 00:27:48,066
that apply the generated forces


590
00:27:48,406 --> 00:27:50,696
to the object that's
being part of the scene.


591
00:27:51,176 --> 00:27:54,696
So here, I'm having a space
cannon launching off cannonballs


592
00:27:55,286 --> 00:27:59,506
that interact with 2 different
radial gravity fields.


593
00:28:00,296 --> 00:28:04,016
As you can see, as the
cannonballs get closer


594
00:28:05,456 --> 00:28:09,386
to the planet the linear
acceleration gets converted


595
00:28:09,386 --> 00:28:12,776
into angular velocity and
start orbiting the planet


596
00:28:12,776 --> 00:28:13,416
or shoots out.


597
00:28:15,456 --> 00:28:16,806
So, we use the fields


598
00:28:16,806 --> 00:28:21,946
to simulate any physical field
forces and fields can interact


599
00:28:21,946 --> 00:28:23,716
with the physics bodies
that's in the region.


600
00:28:23,896 --> 00:28:25,516
And the region is the place


601
00:28:25,516 --> 00:28:27,856
where we define the
field effect areas.


602
00:28:28,516 --> 00:28:31,126
And we have a lot of different
fields that's provided


603
00:28:31,126 --> 00:28:32,096
with this release.


604
00:28:32,596 --> 00:28:33,596
There's about 10 of them.


605
00:28:34,956 --> 00:28:37,206
So, when those fields
get updated...


606
00:28:37,516 --> 00:28:40,466
So number 1, I need to have
field nodes in the scene graph.


607
00:28:40,566 --> 00:28:42,136
They are just like any SKNode.


608
00:28:42,136 --> 00:28:43,396
You can add them to a scene.


609
00:28:43,806 --> 00:28:45,626
You can run action
on them as well.


610
00:28:45,976 --> 00:28:48,396
You can parent it to
another sprite so if you want


611
00:28:48,396 --> 00:28:53,696
to have a really big cookie
planet you can add a radial


612
00:28:53,696 --> 00:28:56,456
gravity field as a child and
move that cookie planet around


613
00:28:56,456 --> 00:28:58,746
and then the field is
going to follow it.


614
00:28:58,746 --> 00:29:01,336
And if there are physics
bodies that's located


615
00:29:01,336 --> 00:29:05,056
within this region and the
bitMask matches the interaction


616
00:29:05,056 --> 00:29:05,766
will start happening.


617
00:29:05,926 --> 00:29:10,286
Now, the control fields, fields
will provide a lot of parameters


618
00:29:10,286 --> 00:29:12,556
that will allow you
to get the exact look


619
00:29:12,556 --> 00:29:14,676
and different interactions
that you want.


620
00:29:15,066 --> 00:29:16,636
You can control number
1, region.


621
00:29:16,916 --> 00:29:22,106
That's the area of effect of how
big of the area I want the field


622
00:29:22,106 --> 00:29:23,556
to interact with the user with.


623
00:29:24,376 --> 00:29:27,556
Now, the strength in combination


624
00:29:27,556 --> 00:29:30,246
of falloff controls
what's the magnitude


625
00:29:30,246 --> 00:29:31,796
of force that's being applied


626
00:29:31,796 --> 00:29:33,866
to each individual object
that's in the field.


627
00:29:34,536 --> 00:29:36,966
And minimal radius is
just a clamp radius


628
00:29:37,516 --> 00:29:40,636
and bitMask can be
used to differentiate


629
00:29:40,636 --> 00:29:43,996
which physics body you want to
interact with this field or not.


630
00:29:45,266 --> 00:29:47,016
Now, let's look at the regions.


631
00:29:47,566 --> 00:29:49,866
The SKRegions define
the area of effect


632
00:29:49,866 --> 00:29:51,216
for this particular field.


633
00:29:51,626 --> 00:29:54,926
The region defines
this area in 2D space.


634
00:29:55,276 --> 00:29:58,616
By default it is infinite and
you can create a rectangle,


635
00:29:58,616 --> 00:30:00,986
circle or even create
a region from CGPath.


636
00:30:01,396 --> 00:30:05,306
You can do a lot of complicated
operations on them like invert,


637
00:30:05,306 --> 00:30:06,976
subtract, union and intersect.


638
00:30:07,686 --> 00:30:10,476
So for example, here, I'm
if building Earth here


639
00:30:10,476 --> 00:30:13,646
and the radial gravity around
the Earth, as you can see,


640
00:30:13,646 --> 00:30:15,496
is pulling everything
towards the center.


641
00:30:15,676 --> 00:30:21,436
So, in addition to physics
bodies fields can also interact


642
00:30:21,436 --> 00:30:23,596
with SpriteKit particle effects.


643
00:30:24,226 --> 00:30:26,446
So, as long as you
set the fieldBitMask


644
00:30:26,446 --> 00:30:29,266
on the particle effects,
every single emitted object --


645
00:30:30,056 --> 00:30:31,506
particles can interact
with the field.


646
00:30:31,506 --> 00:30:32,966
So, here we have a noise field


647
00:30:32,966 --> 00:30:35,386
that apply a coherent
noise force to each


648
00:30:35,386 --> 00:30:36,486
of the emitted particles.


649
00:30:36,486 --> 00:30:39,776
Now, let's look at some


650
00:30:39,776 --> 00:30:41,876
of the basic fields
that's being provided


651
00:30:41,876 --> 00:30:44,436
so everyone can get a feeling


652
00:30:44,436 --> 00:30:47,586
of what fields are
really looking like.


653
00:30:48,286 --> 00:30:50,936
So, by default we provide the
base, linear gravity field.


654
00:30:50,936 --> 00:30:53,776
This is just to simulate
Earth's gravity in one dimension


655
00:30:53,776 --> 00:30:56,566
and you can change the direction
at any time or if you go


656
00:30:56,566 --> 00:31:00,186
up it will attract the object
at the correct location.


657
00:31:01,296 --> 00:31:03,876
And second, if I want to
simulate a space game,


658
00:31:03,876 --> 00:31:06,156
have a planetarium
gravity effect,


659
00:31:06,356 --> 00:31:10,196
we have the radial gravity
field node that you can use.


660
00:31:10,196 --> 00:31:13,196
For example, here the object
carries a linear velocity,


661
00:31:13,196 --> 00:31:14,516
but when it reaches close


662
00:31:14,516 --> 00:31:17,316
to the orbit the linear
gravity's converting


663
00:31:17,316 --> 00:31:18,806
into angular velocity


664
00:31:18,806 --> 00:31:23,676
so the object actually
orients around the planet.


665
00:31:24,176 --> 00:31:25,786
We also have a spring field.


666
00:31:25,976 --> 00:31:27,456
This is the imaginary field


667
00:31:27,456 --> 00:31:30,136
as it's imagining every
single object in the scene --


668
00:31:30,356 --> 00:31:33,276
in the field -- actually have
a spring hooked from one end


669
00:31:33,276 --> 00:31:34,396
and attached to the node.


670
00:31:34,776 --> 00:31:37,446
So, here you can see they're
being oscillated back and forth.


671
00:31:40,006 --> 00:31:41,586
And we also have noise fields


672
00:31:41,796 --> 00:31:44,836
that apply a coherent
noise force


673
00:31:45,446 --> 00:31:47,976
to every single object that's
being participated in the scene.


674
00:31:53,236 --> 00:31:55,886
And electric fields
are particularly cool.


675
00:31:56,046 --> 00:31:59,736
So, imagine each of the objects
have charges, positive charges


676
00:31:59,736 --> 00:32:04,266
and negative charges and here
we have an electric field


677
00:32:04,266 --> 00:32:06,146
that carries positive charges.


678
00:32:06,316 --> 00:32:10,676
And positive charge attracts
objects with negative charges


679
00:32:10,676 --> 00:32:14,136
and repel objects
with the same charge.


680
00:32:14,246 --> 00:32:18,726
So, here the red particles, or
red cannons actually, that...


681
00:32:18,726 --> 00:32:21,506
when they carry a positive
charge they get repelled away.


682
00:32:21,726 --> 00:32:23,856
And the green ones
carry a negative charge


683
00:32:24,086 --> 00:32:25,956
and are being attracted
and interact


684
00:32:25,956 --> 00:32:27,766
with the electric field.


685
00:32:28,516 --> 00:32:31,356
So, fields we provide
-- physics fields


686
00:32:31,356 --> 00:32:33,256
as building blocks
as like Legos.


687
00:32:33,256 --> 00:32:36,446
Feel free to interact
with them and build,


688
00:32:36,896 --> 00:32:37,836
combine them together.


689
00:32:38,106 --> 00:32:40,576
So, you can combine
them together


690
00:32:40,576 --> 00:32:43,816
to have big building blocks and
each of the fields can interact


691
00:32:43,816 --> 00:32:44,766
with different fields.


692
00:32:45,256 --> 00:32:49,166
So for example, if I want
to implement one variation


693
00:32:49,166 --> 00:32:54,426
of the Lorenz attractor I can
simply have 4 magnetic fields


694
00:32:54,426 --> 00:32:57,086
sitting right by each
other with opposite charge.


695
00:32:57,476 --> 00:33:02,156
And, what happens if I send
particles through the field?


696
00:33:02,726 --> 00:33:09,136
So, that's what it looks like
so -- which is very cool.


697
00:33:09,136 --> 00:33:10,116
[ Applause ]


698
00:33:10,116 --> 00:33:12,896
So, in summary the
fields are very fast,


699
00:33:13,186 --> 00:33:14,346
they're very efficient.


700
00:33:14,636 --> 00:33:16,506
We have a brand new
implementation for --


701
00:33:16,936 --> 00:33:18,916
and we actually have a lot of --


702
00:33:18,916 --> 00:33:21,346
spent a lot of optimization
effort on this feature.


703
00:33:21,906 --> 00:33:23,426
And you can use fields
to interact


704
00:33:23,426 --> 00:33:26,066
with either physics
bodies or particles to have


705
00:33:26,066 --> 00:33:29,346
that really fun interaction
experience for the user.


706
00:33:29,866 --> 00:33:32,956
And you can also use fields
to interact with other fields


707
00:33:32,956 --> 00:33:34,556
to have a combined effect.


708
00:33:35,486 --> 00:33:37,786
Next, I want to talk about
integration with SceneKit.


709
00:33:38,506 --> 00:33:41,066
We worked really closely
together with the SceneKit team


710
00:33:41,066 --> 00:33:43,186
to make sure we have the
best possible experience


711
00:33:43,476 --> 00:33:45,796
for bringing 3D content
into 2D games.


712
00:33:46,456 --> 00:33:47,566
So, here we have a demo.


713
00:33:47,566 --> 00:33:51,616
The spaceship is in 3D,
object that's in a 2D and same


714
00:33:51,966 --> 00:33:56,696
as the asteroid that's in
the 3D object but we'll bring


715
00:33:56,836 --> 00:34:00,556
into the 2D background.


716
00:34:01,046 --> 00:34:03,846
So, the integration
brings new possibilities


717
00:34:03,846 --> 00:34:08,676
to developing 2D games so we
can now officially include 3D


718
00:34:08,676 --> 00:34:10,156
content into SpriteKit games.


719
00:34:10,596 --> 00:34:13,116
You can control any
of the 3D objects just


720
00:34:13,116 --> 00:34:14,746
like any other SKNode.


721
00:34:14,746 --> 00:34:15,866
You can run action on it.


722
00:34:15,866 --> 00:34:16,775
You can run scale.


723
00:34:17,056 --> 00:34:20,596
You can make it follow paths or
even make any 3D manipulations.


724
00:34:22,735 --> 00:34:25,666
It's deeply integrated
of the two frameworks,


725
00:34:25,666 --> 00:34:27,196
yet it would remain
loosely coupled


726
00:34:27,196 --> 00:34:30,956
as two independent solutions
for the game developers.


727
00:34:31,266 --> 00:34:33,496
So, it is rendered very
efficiently together,


728
00:34:33,496 --> 00:34:36,196
SceneKit is rendering directly
into the OpenGL content.


729
00:34:36,196 --> 00:34:38,386
We're not passing -- we're
not rendering to texture


730
00:34:38,386 --> 00:34:40,366
and then passing texture around
between the two frameworks.


731
00:34:40,746 --> 00:34:43,045
This is a very efficient
solution.


732
00:34:43,926 --> 00:34:45,585
So, to bring 3D content


733
00:34:45,585 --> 00:34:49,226
into 2D-based games
we created SK3DNode.


734
00:34:49,516 --> 00:34:51,235
It is the toll-free
bridge allowing you


735
00:34:51,235 --> 00:34:54,096
to incorporate any 3D content
into SpriteKit-based games.


736
00:34:55,036 --> 00:34:59,536
So, once you have SK3DNode you
can attach any of the scnScenes


737
00:34:59,696 --> 00:35:03,876
to this SK3DNode in order for
it to render in this SKScene.


738
00:35:04,656 --> 00:35:07,626
And once you have the scnScene
you can set the scnScene


739
00:35:07,626 --> 00:35:11,246
property on an SK3DNode and they
will start using this SceneKit


740
00:35:11,246 --> 00:35:15,026
render in our render path.


741
00:35:15,506 --> 00:35:17,366
So, how do we create
an SK3DNode?


742
00:35:17,476 --> 00:35:19,976
And we have the initializer
create a scnNodeWith


743
00:35:19,976 --> 00:35:22,566
ViewportSize, you
specify a static size.


744
00:35:23,016 --> 00:35:25,676
You can attach any of the
scnScene, SceneKit scenes


745
00:35:25,676 --> 00:35:28,326
or SceneKit objects through
the scnScene property.


746
00:35:30,076 --> 00:35:33,576
You also have access to SCNNode,
which gives you the point


747
00:35:33,576 --> 00:35:35,046
of view of where the
default camera --


748
00:35:35,366 --> 00:35:37,836
or if there is a camera,
where is the pointer --


749
00:35:37,836 --> 00:35:39,936
where is the camera looking
at, at the current scene.


750
00:35:40,576 --> 00:35:42,656
And if the scene doesn't
have any lighting you can use


751
00:35:42,656 --> 00:35:44,056
one-liner automatic --


752
00:35:44,286 --> 00:35:46,966
autoenable DefaultLighting
that will turn on--


753
00:35:46,966 --> 00:35:48,256
add a default light to the scene


754
00:35:48,256 --> 00:35:50,026
so all the objects
are properly lit.


755
00:35:51,676 --> 00:35:54,466
So, here is a quick example,
if we want to add a 3D alien


756
00:35:54,466 --> 00:35:55,146
from a [inaudible] into SKScene,


757
00:35:55,146 --> 00:35:57,346
which is called SK3DNode
initialize


758
00:35:57,346 --> 00:35:58,276
with a default viewport.


759
00:35:58,516 --> 00:36:02,526
Load scnScene and set the scene
and add it to the SKScene.


760
00:36:02,526 --> 00:36:05,506
Now, the 3D alien object
is going to appear.


761
00:36:05,696 --> 00:36:09,346
Now, the integration
also goes both ways.


762
00:36:09,636 --> 00:36:13,026
SpriteKit now powers all the
texture needs for SceneKit


763
00:36:13,026 --> 00:36:16,256
as well as sounds so you can
use any SpriteKit texture object


764
00:36:16,326 --> 00:36:18,816
directly on SceneKit,
that including all


765
00:36:18,816 --> 00:36:20,826
of the tools we built
from the last version,


766
00:36:21,136 --> 00:36:23,676
which is the automatic
TextureAtlas generation


767
00:36:23,676 --> 00:36:25,326
within Xcode as well


768
00:36:25,326 --> 00:36:27,636
as the procedurally
generated normal map.


769
00:36:27,636 --> 00:36:30,386
So, you can automatically
generate a normal map,


770
00:36:30,746 --> 00:36:33,506
put it on any 3D object and
the effect looks really,


771
00:36:33,506 --> 00:36:33,976
really cool.


772
00:36:35,036 --> 00:36:37,376
And SpriteKit and SceneKit
also share the same audio


773
00:36:37,376 --> 00:36:38,286
playback interface.


774
00:36:38,906 --> 00:36:43,696
So, having the integration
within the 2 frameworks really,


775
00:36:43,696 --> 00:36:45,766
really add a lot of
possibilities here.


776
00:36:45,766 --> 00:36:49,126
You can have another level
of interaction with you user.


777
00:36:49,126 --> 00:36:51,726
For example, have a constant
background of 3D and all


778
00:36:51,726 --> 00:36:54,296
of the sudden you see a 3D
object flying out of the screen.


779
00:36:54,656 --> 00:36:58,756
It's actually making the user
having a third perspective


780
00:36:59,196 --> 00:37:00,376
of what a game looks like.


781
00:37:01,346 --> 00:37:03,786
Lastly, I want to
talk about tools here.


782
00:37:03,906 --> 00:37:09,006
So, for Xcode 6 we have released
a brand new SpriteKit editor.


783
00:37:10,086 --> 00:37:14,116
It is part of Xcode release and
you can use it to create any


784
00:37:14,116 --> 00:37:16,186
of the game scenes
without writing any code.


785
00:37:16,596 --> 00:37:19,246
You can also use it to interact
any of the SpriteKit features.


786
00:37:20,376 --> 00:37:24,936
In a nutshell, everything you
have seen here today can be done


787
00:37:24,936 --> 00:37:26,056
inside of SpriteKit Editor


788
00:37:26,056 --> 00:37:27,336
without writing any
lines of code.


789
00:37:27,336 --> 00:37:28,086
It forces you also...


790
00:37:28,086 --> 00:37:28,153
[ Applause ]


791
00:37:28,153 --> 00:37:28,676
Thank you!


792
00:37:28,676 --> 00:37:33,586
It also enables you to
write the data-driven model.


793
00:37:34,256 --> 00:37:37,096
Writing games usually
deals with a lot of data.


794
00:37:37,836 --> 00:37:40,486
And we want to shift
the focus from focusing


795
00:37:40,486 --> 00:37:44,266
on designing one level rather
than have a generic approach


796
00:37:44,526 --> 00:37:46,206
of data-oriented
programming model.


797
00:37:46,616 --> 00:37:49,766
So, now with SpriteKit Editor
we actually separate the game


798
00:37:49,766 --> 00:37:51,286
content from the game logic.


799
00:37:51,666 --> 00:37:54,416
So, you no longer have to
manually add a spaceship,


800
00:37:55,186 --> 00:37:58,166
set a degree at 10-10 and
launch the game, recompile it


801
00:37:58,166 --> 00:38:01,106
and launch the game and
"I'm about five pixels off.


802
00:38:01,106 --> 00:38:02,936
Maybe I'll add 5 pixels and..."


803
00:38:02,936 --> 00:38:06,056
It takes all the guessing work
out of your iteration process!


804
00:38:06,056 --> 00:38:06,296
[ Applause ]


805
00:38:06,296 --> 00:38:10,516
And we also provide
simplified game templates that's


806
00:38:10,516 --> 00:38:12,776
in both Swift and Objective-C.


807
00:38:13,376 --> 00:38:15,636
So, out of the box
you are good to go


808
00:38:15,636 --> 00:38:18,816
and have a brand new scene
created for you and ready


809
00:38:18,816 --> 00:38:20,966
for drag-and-drop and
play, create your level,


810
00:38:21,256 --> 00:38:24,126
and making sure your game
is running on day one.


811
00:38:25,266 --> 00:38:28,546
Not only can you use
SpriteKit Editor as an editor,


812
00:38:28,546 --> 00:38:30,486
you can use it as
a debugger as well.


813
00:38:31,006 --> 00:38:33,146
So, if you're in the middle
of running your scene,


814
00:38:33,146 --> 00:38:35,466
and one of your ships
becomes missing,


815
00:38:35,966 --> 00:38:38,346
you can use this one line
of code and just type


816
00:38:38,346 --> 00:38:40,956
that in a debugger,
you get an SKS file.


817
00:38:41,046 --> 00:38:43,506
And guess what, you can
load that back into Xcode


818
00:38:43,506 --> 00:38:46,576
and see what's going on for that
scene and you trace back exactly


819
00:38:46,576 --> 00:38:47,606
where the scene hierarchy is.


820
00:38:48,266 --> 00:38:49,786
So, in the case of, say...


821
00:38:49,946 --> 00:38:52,266
If the spaceship got hidden
because of the Z order,


822
00:38:52,586 --> 00:38:54,956
you can totally see
that within the Xcode.


823
00:38:55,756 --> 00:38:59,066
And if you have an existing
game that's not even written


824
00:38:59,066 --> 00:39:01,536
for data-oriented programming,
you can use the same line


825
00:39:01,536 --> 00:39:02,906
of code to serialize it out.


826
00:39:02,906 --> 00:39:07,336
And if you need to retouch
it or adding new features,


827
00:39:08,246 --> 00:39:11,296
dragging new Xcode in -- use the
editor and add new features in.


828
00:39:11,466 --> 00:39:12,306
They are ready to go.


829
00:39:12,306 --> 00:39:13,246
[ Applause ]


830
00:39:13,246 --> 00:39:14,886
So, some of the basic
features that we provide


831
00:39:14,886 --> 00:39:16,266
for the SpriteKit
Editor allow you


832
00:39:16,266 --> 00:39:18,556
to do basic object
manipulation and placement,


833
00:39:18,556 --> 00:39:21,916
they include position,
orientation and scale.


834
00:39:22,416 --> 00:39:25,646
You can set up a physics bodies,
bounding box, bounding circles


835
00:39:25,646 --> 00:39:28,286
or even the brand new
per-pixel physics set up.


836
00:39:28,686 --> 00:39:31,976
You can bring in 3D content
from [inaudible] directly


837
00:39:31,976 --> 00:39:34,446
into a 2D scene and save
it and load it in game


838
00:39:34,726 --> 00:39:36,586
and see the 3D object
and it's ready for --


839
00:39:36,856 --> 00:39:37,996
ready to be manipulated.


840
00:39:38,596 --> 00:39:40,036
And we can set up shadows


841
00:39:40,306 --> 00:39:43,586
and lighting effects,
inverse kinematics.


842
00:39:43,976 --> 00:39:46,606
You can set up an inverse
kinematic joint hierarchy right


843
00:39:46,606 --> 00:39:49,766
inside of Xcode and preview
that effect right here.


844
00:39:50,256 --> 00:39:53,066
We also provide an integrated
shader editor, allowing you


845
00:39:53,066 --> 00:39:57,356
to have a WYSIWYG effect
of editing your shaders


846
00:39:57,356 --> 00:39:58,756
and tuning your shader uniforms.


847
00:39:59,546 --> 00:40:01,436
So, I'm going to give
you a quick demo.


848
00:40:02,346 --> 00:40:05,006
So, from Monday's talk, the
"State of the Union" demo,


849
00:40:05,006 --> 00:40:06,886
hopefully you have seen
how to use SpriteKit Editor


850
00:40:06,886 --> 00:40:11,176
to create physics bodies, set
up per-pixel physics collusions


851
00:40:11,676 --> 00:40:13,936
and also interact with
field forces and 3D objects.


852
00:40:14,106 --> 00:40:17,276
So, today the topic that
I'm going to cover is how


853
00:40:17,276 --> 00:40:19,996
to use SpriteKit
Editor to set up lights


854
00:40:20,286 --> 00:40:23,066
and shadows using
inverse kinematics and how


855
00:40:23,066 --> 00:40:24,586
to use the building
shader editor


856
00:40:24,586 --> 00:40:25,976
to quickly iterate your shaders.


857
00:40:26,296 --> 00:40:27,126
So, let's have a look.


858
00:40:28,196 --> 00:40:31,606
So, here we have a brand
new lighting scene.


859
00:40:31,856 --> 00:40:35,506
So, nothing is in
here and ready to go.


860
00:40:36,006 --> 00:40:39,346
If you click in the object
library this gives you any


861
00:40:39,346 --> 00:40:41,556
existing textures that's
in a current project.


862
00:40:41,686 --> 00:40:43,306
So, if I just drag
in a cobblestone


863
00:40:44,066 --> 00:40:46,246
and I can make it
slightly bigger.


864
00:40:47,416 --> 00:40:49,576
And to see any of the
SpriteKit widgets,


865
00:40:49,676 --> 00:40:52,196
you just open the object library
and, because we're adding


866
00:40:52,196 --> 00:40:54,076
in a SpriteKit scene,
its content-sensitive.


867
00:40:54,076 --> 00:40:56,796
It knows these are the SpriteKit
objects that're relevant


868
00:40:56,796 --> 00:40:59,016
for this editing experience.


869
00:40:59,356 --> 00:41:00,596
And now let's drag a light in.


870
00:41:01,086 --> 00:41:04,056
It doesn't do quite what I want
yet, because it hasn't lit yet.


871
00:41:04,406 --> 00:41:07,706
As you can see the lighting
mask that we have on the sprite


872
00:41:07,706 --> 00:41:09,556
or on the cobblestone
is not set.


873
00:41:09,626 --> 00:41:12,586
So, here if we set it to be
1 we you see that right away,


874
00:41:13,166 --> 00:41:14,856
no code of writing, nothing.


875
00:41:15,096 --> 00:41:17,486
So, if you save this file,
load it in your scene,


876
00:41:18,016 --> 00:41:19,486
this is exactly what
you're going to get,


877
00:41:19,486 --> 00:41:22,306
because SpriteKit Editor
actually uses SpriteKit writing


878
00:41:22,306 --> 00:41:23,046
instead of Xcode.


879
00:41:24,356 --> 00:41:27,366
So, now we can move the scene
around, move the light around.


880
00:41:27,646 --> 00:41:28,676
You can see different effects.


881
00:41:29,286 --> 00:41:31,826
And now it's kind of
2D-ish and blandish.


882
00:41:32,456 --> 00:41:34,016
Maybe we can change the texture


883
00:41:34,076 --> 00:41:36,376
so we can automatically generate
a normal map on the fly.


884
00:41:36,886 --> 00:41:39,136
Say if I want to make
stone a little bit sharp,


885
00:41:39,136 --> 00:41:42,536
but also have a bit of
contrast I can do that.


886
00:41:43,166 --> 00:41:44,296
It's just two numbers.


887
00:41:44,946 --> 00:41:46,976
And if I want to
make it slightly...


888
00:41:46,976 --> 00:41:48,796
mm, maybe it's too sharp,


889
00:41:48,936 --> 00:41:52,426
it might look very
discomfort to walk on.


890
00:41:52,426 --> 00:41:54,356
So, if I want to have --


891
00:41:54,666 --> 00:41:56,926
lower that, that's
slightly more subtle look.


892
00:41:56,926 --> 00:41:59,596
And if I move that object


893
00:41:59,596 --> 00:42:02,646
around as you can see
the light, real light.


894
00:42:02,646 --> 00:42:03,386
[ Applause ]


895
00:42:03,386 --> 00:42:07,886
So, now let's go ahead and
add a stone object here.


896
00:42:08,196 --> 00:42:09,156
That's a little bit too big.


897
00:42:09,346 --> 00:42:10,356
Let's make it smaller.


898
00:42:10,996 --> 00:42:12,896
And I want the stone
to be lit as well


899
00:42:12,956 --> 00:42:14,626
so let's set the
lighting mask to be 1,


900
00:42:14,876 --> 00:42:18,286
same as the scene object, okay.


901
00:42:18,916 --> 00:42:23,106
And because we want to have
maybe a 3D look for this,


902
00:42:23,106 --> 00:42:24,996
maybe the stone will
need to cast shadows...


903
00:42:24,996 --> 00:42:28,776
we just need to set the
shadow mask on that.


904
00:42:28,776 --> 00:42:34,696
So, move it around and now
we can change some properties


905
00:42:35,006 --> 00:42:35,826
of lighting.


906
00:42:36,616 --> 00:42:38,216
So, I can change the
lighting color...


907
00:42:38,586 --> 00:42:39,716
Oh that's a little weird.


908
00:42:42,186 --> 00:42:48,066
Something normalish, warm color
is the way to go, so there.


909
00:42:48,616 --> 00:42:52,756
As soon as you hit File,
Save the scene is ready


910
00:42:52,756 --> 00:42:54,166
and you are good to go.


911
00:42:54,306 --> 00:42:59,046
You don't have to do SKLightNode
in it, add it to scene,


912
00:42:59,046 --> 00:43:00,646
position equals -- none of that.


913
00:43:01,116 --> 00:43:02,646
So, this is very cool.


914
00:43:03,486 --> 00:43:05,646
So, next I want to show
is the inverse kinematics,


915
00:43:05,756 --> 00:43:07,496
so here I have a
preassembled robot.


916
00:43:07,496 --> 00:43:09,666
I'm just going to give
you a quick overview.


917
00:43:09,916 --> 00:43:11,416
So, here I have the arm object.


918
00:43:12,516 --> 00:43:16,236
Arm is parented directly to
the scene for the upper arm.


919
00:43:17,076 --> 00:43:20,676
The lower arm is attached as
a parent for the upper arm.


920
00:43:21,416 --> 00:43:24,346
And we have the claw that
attach to the lower arm.


921
00:43:25,116 --> 00:43:28,206
So, to launch or set
up inverse kinematics


922
00:43:28,206 --> 00:43:30,956
for this robot I just need
to start simulate a scene,


923
00:43:31,676 --> 00:43:37,536
select these objects and I
can run inverse kinematics


924
00:43:37,836 --> 00:43:39,516
on the robot right
inside of the editor


925
00:43:39,866 --> 00:43:41,346
and to see how it's set up.


926
00:43:42,126 --> 00:43:44,456
And if you want, that doesn't
look quite right, maybe I need


927
00:43:44,456 --> 00:43:46,326
to set a little bit of
constraint on there.


928
00:43:46,666 --> 00:43:50,916
Maybe I need to limit to say
90 degrees to 180 degrees


929
00:43:50,946 --> 00:43:54,616
for that joint and you
can have the same effect.


930
00:43:56,676 --> 00:44:00,146
As you can see it
actually reaches back


931
00:44:00,146 --> 00:44:02,356
and it will not over-bend
that arm at the elbow.


932
00:44:03,186 --> 00:44:05,936
So, that's the inverse
kinematics, very easy to set up.


933
00:44:05,936 --> 00:44:08,216
Again, you don't have to
write any lines of code


934
00:44:08,296 --> 00:44:10,736
to see the code effect or
use any of the features here.


935
00:44:11,186 --> 00:44:13,166
Plus I want to go
over our shaders.


936
00:44:13,526 --> 00:44:15,906
To uses shaders is very easy.


937
00:44:16,956 --> 00:44:19,616
So, here from the widget
library I can just pull


938
00:44:19,616 --> 00:44:21,246
in a solid color of sprite.


939
00:44:22,366 --> 00:44:25,616
And here I happen to have a
custom shader that I can run.


940
00:44:25,726 --> 00:44:27,676
So, how do I set
a custom shader?


941
00:44:28,536 --> 00:44:30,916
SpriteKit Editor automatically
process your work space


942
00:44:30,986 --> 00:44:33,386
and figure out how many
FSH files that you have.


943
00:44:33,746 --> 00:44:34,926
So, here I have a single one.


944
00:44:35,216 --> 00:44:37,336
I set that and boom,
I'm good to go.


945
00:44:37,446 --> 00:44:37,516
So...


946
00:44:37,516 --> 00:44:38,076
[ Applause ]


947
00:44:38,076 --> 00:44:39,416
This is only half
of the equation.


948
00:44:40,256 --> 00:44:44,136
To actually -- the iteration
experience is even better.


949
00:44:45,926 --> 00:44:50,316
So, here if I want to make a
change to the shader I just call


950
00:44:50,316 --> 00:44:51,716
in the assistant editor.


951
00:44:52,326 --> 00:44:56,376
If I just click on the object
it knows which shader you used


952
00:44:56,466 --> 00:44:58,926
and it brings up the
shader source side-by-side


953
00:44:58,926 --> 00:44:59,996
and you're ready to edit.


954
00:45:00,136 --> 00:45:03,456
You're ready to make changes and
monitor your whole workspace.


955
00:45:03,876 --> 00:45:08,886
So, now if I notice the radius
of the center of the circle,


956
00:45:08,886 --> 00:45:10,066
I want to shift it a little bit.


957
00:45:10,106 --> 00:45:14,556
So, if I change it to 0.2 and
0.2 and then what happened?


958
00:45:15,156 --> 00:45:18,006
Usually you need to
rebuild your application.


959
00:45:18,356 --> 00:45:19,956
You need to rerun
the application.


960
00:45:20,546 --> 00:45:23,036
The application will upload
a new shader to the OpenGL,


961
00:45:23,036 --> 00:45:25,376
GL's driver will compile whether


962
00:45:25,606 --> 00:45:27,396
if you forget a semicolon,
guess what?


963
00:45:27,396 --> 00:45:28,546
You start that process again.


964
00:45:29,846 --> 00:45:32,276
Here you just need
to do File, Save.


965
00:45:33,386 --> 00:45:35,386
So, if I make -- Oh, it
automatically saved for me.


966
00:45:35,386 --> 00:45:37,166
So, if I change it back to 0.5,


967
00:45:37,166 --> 00:45:41,106
0.5 and file save you see
the live change right here.


968
00:45:43,336 --> 00:45:46,216
And what if I decide to
add a brand new uniforms


969
00:45:46,726 --> 00:45:47,286
to the shader?


970
00:45:47,286 --> 00:45:50,186
So, here I want to
add a speed parameter


971
00:45:50,186 --> 00:45:53,296
so I can control the
effect that I'm having here.


972
00:45:53,296 --> 00:45:55,806
So, if I save that, guess what?


973
00:45:55,806 --> 00:46:00,306
You have real OpenGL annotation
error right inside of Xcode.


974
00:46:00,626 --> 00:46:03,096
So, here because I
introduced a new uniform


975
00:46:03,466 --> 00:46:05,966
that has not been
declared so the declaration


976
00:46:05,966 --> 00:46:07,796
of current time fails at any --


977
00:46:08,066 --> 00:46:10,076
the two other places
that I referenced


978
00:46:10,406 --> 00:46:12,456
to current time will
fail as well.


979
00:46:12,716 --> 00:46:13,746
So, how do we fix that?


980
00:46:13,746 --> 00:46:17,066
Because we add this new
uniform, let's go ahead and add


981
00:46:17,066 --> 00:46:18,066
that in the dictionary.


982
00:46:19,496 --> 00:46:20,916
So, because we're calling it


983
00:46:20,916 --> 00:46:22,756
"u.speed" we make
sure the name matches,


984
00:46:22,756 --> 00:46:26,366
u.speed and has a value of 0.


985
00:46:27,116 --> 00:46:30,796
And if I change that to 1
I see the live effect right


986
00:46:30,856 --> 00:46:33,396
in the editor and
make it spin faster.


987
00:46:33,986 --> 00:46:34,776
Ooh, see there?


988
00:46:35,796 --> 00:46:36,866
OK, let's make it slower.


989
00:46:39,386 --> 00:46:42,376
So, live shader editing,
right inside of Xcode.


990
00:46:42,376 --> 00:46:42,443
[ Applause ]


991
00:46:42,443 --> 00:46:44,376
So that's the demo of
our SpriteKit Editor.


992
00:46:45,806 --> 00:46:48,696
Lastly, I want to go over
some additional improvements


993
00:46:48,696 --> 00:46:49,316
that we have done


994
00:46:49,316 --> 00:46:52,676
to the existing SpriteKit
framework APIs.


995
00:46:52,866 --> 00:46:54,936
So, for those of you who
are new to SpriteKit,


996
00:46:55,246 --> 00:46:58,266
here is the brand
new update clock


997
00:46:58,266 --> 00:46:59,666
that we have done for this year.


998
00:47:01,576 --> 00:47:04,286
As the frame starts we
start with update function.


999
00:47:04,556 --> 00:47:06,536
So, this is where you can
set up your game logic.


1000
00:47:07,806 --> 00:47:10,826
After that, scene will
start evaluating actions.


1001
00:47:12,366 --> 00:47:15,906
After the actions are evaluated
user gets a callback saying,


1002
00:47:15,906 --> 00:47:18,796
"Okay if I animate, or move
this object from A to B,


1003
00:47:19,366 --> 00:47:20,586
do I need to do anything else?"


1004
00:47:21,466 --> 00:47:24,646
After the actions,
physics kicks in and set


1005
00:47:24,646 --> 00:47:27,156
up the physics use
stepping for the frame.


1006
00:47:27,856 --> 00:47:29,746
Once physics simulation
is finished,


1007
00:47:29,886 --> 00:47:32,336
user gets another callback
with the simulated physics.


1008
00:47:32,426 --> 00:47:34,156
And this is where
you can set up, say,


1009
00:47:34,156 --> 00:47:35,626
if the player gets pushed off,


1010
00:47:36,066 --> 00:47:38,136
maybe I move back
by another 5 pixels.


1011
00:47:38,886 --> 00:47:41,466
And now with the
brand-new constraints API


1012
00:47:41,686 --> 00:47:46,116
where adding a scene will
apply constraints right


1013
00:47:46,116 --> 00:47:46,796
at this moment.


1014
00:47:47,196 --> 00:47:50,706
After constraints are being
applied user gets another


1015
00:47:50,706 --> 00:47:53,486
notification of -- with
didApplyConstraints.


1016
00:47:53,996 --> 00:47:57,656
And now we also added one more
selector for user to react


1017
00:47:57,656 --> 00:47:59,186
on called didFinishUpdate.


1018
00:47:59,436 --> 00:48:02,696
This is absolutely the last
stop before SpriteKit packages


1019
00:48:02,696 --> 00:48:05,566
everything up and send
it to the graphics GPU


1020
00:48:05,766 --> 00:48:06,426
for the current frame.


1021
00:48:06,426 --> 00:48:09,526
And SpriteKit renders
the current frame


1022
00:48:10,206 --> 00:48:12,876
and the same loop continues
60 times per second.


1023
00:48:14,436 --> 00:48:17,046
Now, SKTexture got a
little bit revamped here.


1024
00:48:17,046 --> 00:48:20,206
We introduce a new type of
texture called mutable texture.


1025
00:48:21,046 --> 00:48:23,946
You can create from data and
can be modified very efficiently


1026
00:48:23,986 --> 00:48:24,626
every frame.


1027
00:48:24,816 --> 00:48:26,786
We provide a callback
block allowing you


1028
00:48:26,786 --> 00:48:29,146
to make modifications
to the raw pointers.


1029
00:48:29,246 --> 00:48:31,516
So, here if I'm just
making changes


1030
00:48:31,516 --> 00:48:33,596
to the raw pixel data
you can set that.


1031
00:48:34,236 --> 00:48:37,856
So, if you have a really cool
CPU-based post-processing effect


1032
00:48:37,856 --> 00:48:39,706
and you want to modify
a texture,


1033
00:48:40,156 --> 00:48:41,366
you have the freedom to do that.


1034
00:48:41,626 --> 00:48:44,456
If you want to have a custom
data, you want to send it


1035
00:48:44,456 --> 00:48:48,546
to a shader as input by sending
up all the data as textures,


1036
00:48:49,036 --> 00:48:51,326
you can do that as well.


1037
00:48:51,696 --> 00:48:55,196
Also SKTextures can
generate noise textures now.


1038
00:48:55,196 --> 00:48:57,606
It generates coherent
noise that gives you --


1039
00:48:57,606 --> 00:48:59,366
or the noise vector
from a sphere.


1040
00:48:59,996 --> 00:49:01,776
So, it supports both
the noise generated


1041
00:49:01,776 --> 00:49:04,866
in the grayscale color,
grayscale or the color output.


1042
00:49:05,216 --> 00:49:08,196
If it's generated from a
noise vector we have to stay


1043
00:49:08,246 --> 00:49:09,796
in the color output space.


1044
00:49:10,236 --> 00:49:13,556
So, here, to create the noise
texture, you just call texture


1045
00:49:13,556 --> 00:49:15,586
with noise, which you can
control the smoothness,


1046
00:49:15,896 --> 00:49:19,326
as well as control the size.


1047
00:49:19,856 --> 00:49:22,716
Now, SKShapeNode also received
a lot of revamp this year.


1048
00:49:23,086 --> 00:49:25,576
So, we added convenient
constructors for common shapes.


1049
00:49:25,706 --> 00:49:29,586
They include rectangles,
circles, ellipse and splines.


1050
00:49:30,436 --> 00:49:36,116
We also allow you to set texture
and shaders for both the stroke


1051
00:49:36,256 --> 00:49:38,006
and fill for the actual shape.


1052
00:49:39,056 --> 00:49:40,696
You can use ShapeNode
to interact


1053
00:49:40,696 --> 00:49:41,886
with your physics as well.


1054
00:49:41,886 --> 00:49:46,776
If you build up this very
complex shape using ShapeNode,


1055
00:49:47,006 --> 00:49:49,206
you can just access the
path property directly


1056
00:49:49,656 --> 00:49:52,316
and then get a CG path,
send it directly to physics,


1057
00:49:52,446 --> 00:49:54,216
physics will create a
physics body for you.


1058
00:49:56,456 --> 00:50:00,606
We've also made creating pin
joints much, much easier.


1059
00:50:00,806 --> 00:50:04,696
So, with SKphysicsBody we now
have a new property called


1060
00:50:04,696 --> 00:50:04,976
"pinned".


1061
00:50:06,056 --> 00:50:10,886
To pin an object to
another object you just need


1062
00:50:10,886 --> 00:50:11,946
to set one property.


1063
00:50:12,126 --> 00:50:13,506
So, here I have a big gear.


1064
00:50:13,716 --> 00:50:14,936
I want to pin it to the board.


1065
00:50:15,376 --> 00:50:18,506
I just set the property to
yes, SpriteKit will figure


1066
00:50:18,506 --> 00:50:22,176
out all the parents of
the conversion space


1067
00:50:22,176 --> 00:50:23,926
and whether the other
object has physics body.


1068
00:50:23,926 --> 00:50:26,616
It will take care of all of
that detail for you, very cool.


1069
00:50:28,556 --> 00:50:32,606
Now, in addition to pin joint
we also make creating weld joint


1070
00:50:32,606 --> 00:50:33,696
really, really easy.


1071
00:50:34,066 --> 00:50:36,176
So, weld joint is just
the same as pin joint,


1072
00:50:36,176 --> 00:50:39,696
which means pinned equal YES,
but if it won't allow rotation


1073
00:50:40,646 --> 00:50:42,526
that means I'm welded
to my parents.


1074
00:50:42,906 --> 00:50:44,216
So, here I have a small gear


1075
00:50:44,266 --> 00:50:46,916
that will be welded
to the big gear.


1076
00:50:47,826 --> 00:50:52,646
So, we set 2 properties and the
physics is automatically set


1077
00:50:52,646 --> 00:50:53,046
up for you.


1078
00:50:54,416 --> 00:50:58,756
In addition, physics body can
now be created using compound


1079
00:50:58,756 --> 00:50:59,456
physics bodies.


1080
00:50:59,626 --> 00:51:00,666
All you need to do is just,


1081
00:51:00,666 --> 00:51:03,226
in SKPhysicsBody we'll
add a new initializer


1082
00:51:03,226 --> 00:51:04,446
called bodyWithBodies.


1083
00:51:04,446 --> 00:51:07,626
You pass in an array of the
different physics body shapes.


1084
00:51:07,776 --> 00:51:11,556
And for example, hammer here
is contained with 2 rectangles,


1085
00:51:11,826 --> 00:51:14,726
one for the top and the handle.


1086
00:51:15,896 --> 00:51:18,416
Now, SKTexture Atlas is our --


1087
00:51:19,416 --> 00:51:22,116
one of the key components
to allow users


1088
00:51:22,116 --> 00:51:24,466
to have efficient
graphics performance.


1089
00:51:24,656 --> 00:51:28,136
So, anything that's in a
texture atlas we allow OpenGL


1090
00:51:28,136 --> 00:51:29,436
to do efficient batching here.


1091
00:51:29,856 --> 00:51:32,556
So, it's now supported for
both SpriteKit and SceneKit.


1092
00:51:32,986 --> 00:51:36,366
We support both retina and
non-retina resolutions.


1093
00:51:36,526 --> 00:51:39,896
So, if you have a game and
have all the assets put


1094
00:51:39,896 --> 00:51:43,676
in one folder the Texture Atlas
generator will separate them


1095
00:51:43,676 --> 00:51:44,126
for you.


1096
00:51:44,126 --> 00:51:46,086
So, you don't have to
pay the memory overhead.


1097
00:51:46,086 --> 00:51:49,206
If you're loading the Texture
Atlas on a retina device,


1098
00:51:49,406 --> 00:51:51,736
you don't have to load
the non-retina asset.


1099
00:51:52,136 --> 00:51:56,636
It also supports the
full 32-bit pixel format


1100
00:51:57,166 --> 00:51:59,116
and also the compressed
16 format.


1101
00:52:00,116 --> 00:52:02,866
Now, one of the big
changes: we now support


1102
00:52:02,866 --> 00:52:04,676
up to 4k by 4k resolution.


1103
00:52:04,676 --> 00:52:09,066
So, it's a simple change in the
Xcode settings for your project.


1104
00:52:10,446 --> 00:52:14,726
And in addition we
support Runtime Texture


1105
00:52:14,726 --> 00:52:15,876
Atlas generation.


1106
00:52:16,706 --> 00:52:18,806
So, if you have downloadable
content, say,


1107
00:52:18,886 --> 00:52:21,296
user downloaded a new
level, everything is coming


1108
00:52:21,296 --> 00:52:25,046
in loose files, or users go take
-- go out and take some pictures


1109
00:52:25,046 --> 00:52:27,006
and decide to use that
in-game as a cube map,


1110
00:52:27,746 --> 00:52:30,316
you can just simply pass
into the SKTextureAtlas API


1111
00:52:30,316 --> 00:52:32,736
and we'll automatically
stitch it for you


1112
00:52:33,066 --> 00:52:36,676
and trim off the
transparent pixels.


1113
00:52:37,946 --> 00:52:42,676
So, in summary we really have
a lot of new features packed


1114
00:52:42,676 --> 00:52:44,266
in this year's SpriteKit
release.


1115
00:52:44,266 --> 00:52:46,076
We have a lot of cool
graphics technology


1116
00:52:46,076 --> 00:52:48,906
like custom shaders,
lighting and shadows.


1117
00:52:49,156 --> 00:52:53,676
We have really cool simulation
effects like inverse kinematics,


1118
00:52:53,876 --> 00:52:57,776
physics field, per-pixel
physics and constraints.


1119
00:52:58,706 --> 00:53:01,506
All of these features can
be done using one line,


1120
00:53:01,836 --> 00:53:04,516
or no lines at all if you
use the SpriteKit Editor.


1121
00:53:05,256 --> 00:53:08,426
So, the SpriteKit Editor is a
new edition to the Xcode family


1122
00:53:08,426 --> 00:53:09,706
and is a really,
really cool feature.


1123
00:53:09,706 --> 00:53:11,046
I highly encourage
you to use it.


1124
00:53:11,766 --> 00:53:15,036
And it's also a good learning
experience to see how any


1125
00:53:15,036 --> 00:53:18,476
of the new features interact
with each other within a scene.


1126
00:53:19,106 --> 00:53:21,046
And we can't wait to
see what you can come


1127
00:53:21,046 --> 00:53:22,196
up with all these technologies


1128
00:53:22,196 --> 00:53:24,096
and tools we provided
for this release.


1129
00:53:24,556 --> 00:53:27,766
So, with that said, if you
have any questions or feedback


1130
00:53:27,766 --> 00:53:30,976
or anything you want to see in
the future, we would like to --


1131
00:53:31,316 --> 00:53:35,206
you can feel free to contact
our Developer Evangelist Allan


1132
00:53:35,206 --> 00:53:37,956
Schaffer and Filip Iliescu


1133
00:53:38,596 --> 00:53:42,436
and we have a revamped SpriteKit
Programming Guide that's


1134
00:53:42,436 --> 00:53:43,566
on the Developer Portal.


1135
00:53:43,566 --> 00:53:45,326
So, if you want to pick
up the documentation


1136
00:53:45,326 --> 00:53:47,266
for these new features
they're already there.


1137
00:53:48,196 --> 00:53:50,566
And for the related session
right after this session is the


1138
00:53:50,566 --> 00:53:52,206
"Best Practices for
Building SpriteKit Games".


1139
00:53:52,416 --> 00:53:53,636
We're going to go into depth


1140
00:53:53,636 --> 00:53:56,176
of what are the best performance
practices and how to set


1141
00:53:56,176 --> 00:53:58,356
up a game right in order
to use these new features


1142
00:53:58,906 --> 00:54:00,936
and set up for scalability.


1143
00:54:01,386 --> 00:54:04,136
And as I said before,
we worked really closely


1144
00:54:04,136 --> 00:54:07,596
with the SceneKit team to
making sure SceneKit is also a


1145
00:54:08,206 --> 00:54:10,176
high-level 3D API
just like SpriteKit.


1146
00:54:10,256 --> 00:54:12,326
I highly encourage you to
check out the SceneKit sessions


1147
00:54:12,326 --> 00:54:14,626
for tomorrow in the same
room for two sessions.


1148
00:54:15,376 --> 00:54:17,476
And with that said,
thank you very much,


1149
00:54:17,526 --> 00:54:18,596
this is the end of the session.


1150
00:54:18,596 --> 00:54:20,976
I hope you guys have the
rest of the -- a good week.


1151
00:54:21,516 --> 00:54:24,300
[ Applause ]

