1
00:00:07,516 --> 00:00:17,500
[ Music ]


2
00:00:22,616 --> 00:00:23,686
>> Good morning.


3
00:00:29,216 --> 00:00:31,776
Welcome to Leveraging
Touch Input on iOS.


4
00:00:32,076 --> 00:00:34,286
My name is Dominik
Wagner, and I'm an engineer


5
00:00:34,286 --> 00:00:36,566
on the UIKit Team,
and I will tell you


6
00:00:36,566 --> 00:00:39,336
about how you can make the
most out of our advances


7
00:00:39,336 --> 00:00:42,016
in Multi-Touch and
of Apple Pencil.


8
00:00:42,916 --> 00:00:46,136
First, let's go over our new
and recent hardware releases.


9
00:00:46,136 --> 00:00:50,406
Since last WWDC, we
released a lot of stuff.


10
00:00:50,916 --> 00:00:54,776
For example, 3D Touch with
the iPhone 6s and 6s plus,


11
00:00:55,106 --> 00:00:57,736
which gives you access to
the force for each touch.


12
00:00:58,636 --> 00:01:00,356
I won't talk much about this,


13
00:01:00,616 --> 00:01:05,046
but you can have all the great
experience for Peek and Pop


14
00:01:05,536 --> 00:01:07,906
in the session at A Peek
at 3D Touch later today.


15
00:01:09,466 --> 00:01:11,576
We introduced faster
touch scanning beginning


16
00:01:11,576 --> 00:01:13,396
with iPad Air 2 and iPad Pro,


17
00:01:13,396 --> 00:01:15,006
giving you a temporary
resolution


18
00:01:15,006 --> 00:01:16,946
of twice the refresh
[inaudible] display.


19
00:01:18,166 --> 00:01:21,296
We also introduced Apple
Pencil for Apple iPad Pro,


20
00:01:21,786 --> 00:01:26,776
and this amazing device, thank
you, gives you precise location


21
00:01:26,856 --> 00:01:28,856
at a [inaudible] accuracy
for your drawings.


22
00:01:29,596 --> 00:01:33,136
It has an even higher temporary
resolution of 240 hertz.


23
00:01:34,926 --> 00:01:38,086
It gives you access to its
tilt and orientation, and,


24
00:01:38,086 --> 00:01:39,716
of course, all the force.


25
00:01:41,046 --> 00:01:44,866
And our algorithms team did an
amazing job of palm rejection.


26
00:01:45,236 --> 00:01:47,886
So you can rest your palm
while you are drawing


27
00:01:47,886 --> 00:01:50,346
and don't have to
think about it.


28
00:01:50,836 --> 00:01:53,706
We also released Apple
TV with the Siri remote,


29
00:01:54,926 --> 00:01:58,116
and its track mainly
drives the UIFocusEngine


30
00:01:58,116 --> 00:02:00,056
and your interactions
with Apple TV.


31
00:02:00,786 --> 00:02:03,156
But you can also access the
track pad using the Game


32
00:02:03,156 --> 00:02:07,066
Controller framework for both
acting as a Game Controller


33
00:02:07,216 --> 00:02:10,295
or also getting the absolute
position of the track pad.


34
00:02:10,866 --> 00:02:14,476
And, finally, you can
also handle the track pad


35
00:02:14,476 --> 00:02:17,976
in indirect touches in our
UIKit touch handling methods.


36
00:02:18,546 --> 00:02:20,666
I won't talk much
about this either,


37
00:02:20,666 --> 00:02:22,876
but there are the great
Apple TV tech talks,


38
00:02:23,206 --> 00:02:28,036
and there's also Game Controller
Input for Apple TV yesterday.


39
00:02:28,956 --> 00:02:30,466
What am I going to talk about?


40
00:02:30,766 --> 00:02:33,526
I'm going to talk about how
you build a drawing app.


41
00:02:34,346 --> 00:02:37,886
We will build a drawing app from
the ground up, and I will talk


42
00:02:37,886 --> 00:02:40,246
about all the new
API for Apple Pencil


43
00:02:40,246 --> 00:02:42,886
so you can access all
these great new data.


44
00:02:43,706 --> 00:02:46,536
We will talk you
through it step by step,


45
00:02:47,086 --> 00:02:51,206
and show you all the different
steps you can take depending


46
00:02:51,206 --> 00:02:54,426
on what you see,
and the sample code


47
00:02:54,426 --> 00:02:56,546
of this app is completely
available.


48
00:02:56,546 --> 00:02:59,136
So you can just relax
on the code slides


49
00:02:59,526 --> 00:03:00,936
and play with it later.


50
00:03:01,846 --> 00:03:04,176
So say hello to SpeedSketch.


51
00:03:04,176 --> 00:03:05,226
This is our sample.


52
00:03:06,626 --> 00:03:09,466
SpeedSketch is one sheet
of paper you can draw on.


53
00:03:09,466 --> 00:03:12,526
It has full support for
Apple Pencil on iPad Pro


54
00:03:13,086 --> 00:03:16,356
and 3D Touch on iPhone 6S.


55
00:03:16,486 --> 00:03:19,246
It also works on all
previous iOS devices.


56
00:03:20,556 --> 00:03:22,386
So let's first talk
about the model.


57
00:03:25,696 --> 00:03:30,976
So this is a stroke, and this
is how UIKit sees the samples.


58
00:03:31,116 --> 00:03:35,036
Each of those points is one
instance, the same instance


59
00:03:35,036 --> 00:03:36,396
of a mutable UI touch.


60
00:03:36,816 --> 00:03:39,146
You get handed down in
the touch handing methods.


61
00:03:39,756 --> 00:03:43,616
And we will model our data
as a series of strokes.


62
00:03:45,356 --> 00:03:50,986
And because of the UI touch
being a mutable representation


63
00:03:50,986 --> 00:03:54,876
of one touch sequence,
we need to copy the data


64
00:03:54,876 --> 00:03:57,626
out of this UI touch in
the touch handing methods


65
00:03:57,906 --> 00:03:59,246
into something more static.


66
00:04:01,306 --> 00:04:04,766
So we will build a stroke sample
as being the innermost element


67
00:04:04,766 --> 00:04:08,976
of our data structure, which
for now will just contain the


68
00:04:08,976 --> 00:04:11,666
location of this, of the
UI touch, but later on,


69
00:04:11,666 --> 00:04:14,186
we will fill in all the
additional data parts.


70
00:04:15,776 --> 00:04:19,526
And we will put those
samples into a stroke.


71
00:04:19,706 --> 00:04:21,516
Let's just an array
of stroke samples,


72
00:04:21,516 --> 00:04:25,106
and we have a little bit
of methods to add them.


73
00:04:25,926 --> 00:04:28,126
And because we want
to use the stroke


74
00:04:28,516 --> 00:04:33,246
as our main data capture
structure, it also has a stage.


75
00:04:34,026 --> 00:04:37,126
So it can be active while
the user is drawing, is done,


76
00:04:37,126 --> 00:04:39,396
when the user is done,
and it can be cancelled


77
00:04:39,396 --> 00:04:42,916
if a different user interaction
causes it to be cancelled.


78
00:04:42,916 --> 00:04:45,276
So we can throw it away
instead of keeping it around.


79
00:04:47,626 --> 00:04:49,996
And, lastly, we put this
into a stroke collection,


80
00:04:49,996 --> 00:04:53,686
which will just be an array of
strokes, and we will add the


81
00:04:53,686 --> 00:04:57,346
down strokes, and to make it a
complete data model for our app,


82
00:04:57,346 --> 00:05:00,226
we will have the active
stroke as an optional in this.


83
00:05:00,226 --> 00:05:02,006
So we can use the
stroke collection


84
00:05:02,006 --> 00:05:05,606
as our data model
for a complete app.


85
00:05:06,026 --> 00:05:08,536
So next up is where to
capture those strokes.


86
00:05:09,356 --> 00:05:12,276
So, essentially, you have
three places to do so.


87
00:05:12,526 --> 00:05:15,346
The first one, is a
UIGestureRecognizer,


88
00:05:15,346 --> 00:05:17,936
a custom UIGestureRecognizer
[inaudible] plus.


89
00:05:19,046 --> 00:05:23,216
The next place to look
for is a UIView subclass


90
00:05:24,126 --> 00:05:28,506
where the touch goes down, and
you can handle it all on the way


91
00:05:28,506 --> 00:05:31,346
up the responder chain,
and I want to think,


92
00:05:31,346 --> 00:05:33,266
I want you to think
about this in this order.


93
00:05:33,266 --> 00:05:36,156
If you can do a
UIGestureRecognizer,


94
00:05:36,156 --> 00:05:37,656
or a custom subclass do that.


95
00:05:38,286 --> 00:05:43,246
Second, do a UIView as close as
to the events as you can get,


96
00:05:43,246 --> 00:05:46,206
and only if you have to
go up the responder chain.


97
00:05:46,886 --> 00:05:50,186
So this is what we going to do.


98
00:05:50,746 --> 00:05:53,386
We are building a stroke
gesture recognizer accustomed


99
00:05:53,386 --> 00:05:54,246
to a subclass.


100
00:05:54,686 --> 00:05:56,886
We will target our
main view controller,


101
00:05:58,636 --> 00:06:02,736
and then in the action methods,
we will trigger a redraw


102
00:06:02,736 --> 00:06:04,096
of our view with a stroke.


103
00:06:06,006 --> 00:06:08,616
So let's start building this
gesture recognizer subclass.


104
00:06:08,616 --> 00:06:10,106
The first thing you
have to do is


105
00:06:10,146 --> 00:06:12,976
to import the
UIGestureRecognizer subclass.


106
00:06:13,336 --> 00:06:16,706
This exposes the internals of
a UIGestureRecognizer to you


107
00:06:16,956 --> 00:06:18,806
so you can do subclassing.


108
00:06:19,296 --> 00:06:22,666
Be aware, though, that these
internals should not be used


109
00:06:22,666 --> 00:06:24,696
outside of a
UIGestureRecognizer.


110
00:06:25,086 --> 00:06:29,626
For example, the state setter
is exposed if you import this,


111
00:06:29,806 --> 00:06:32,836
and you shouldn't use
it outside the subclass.


112
00:06:32,836 --> 00:06:37,516
Otherwise, the gesture system
will act in not so nice ways,


113
00:06:37,516 --> 00:06:39,366
and you will have
several issues to debug.


114
00:06:40,546 --> 00:06:43,676
So let's add our stroke
as our main data structure


115
00:06:43,676 --> 00:06:45,856
in our gesture recognizer
to capture the stroke


116
00:06:46,666 --> 00:06:48,446
and implement the
touch handing methods.


117
00:06:49,456 --> 00:06:52,376
And since we do various
similar things


118
00:06:52,376 --> 00:06:54,996
in all the four touch
handing methods,


119
00:06:54,996 --> 00:06:57,846
we will have a helper
method actually looking


120
00:06:57,846 --> 00:06:59,976
into the set of UITouches.


121
00:07:00,276 --> 00:07:04,066
Determining if we are interested
in one of those touches.


122
00:07:04,806 --> 00:07:07,926
Adding that to our data model
just by copying the location


123
00:07:08,026 --> 00:07:11,146
as a sample at the
moment, and return to us


124
00:07:11,416 --> 00:07:12,936
if you were interested in those.


125
00:07:13,226 --> 00:07:16,906
We will use this helper
method in the touchesBegan


126
00:07:16,906 --> 00:07:18,596
and set our state to begin.


127
00:07:19,486 --> 00:07:23,566
For UIGestureRecognizer, that
is unusual because the time


128
00:07:23,566 --> 00:07:27,556
between the state possible and
the state began is the time


129
00:07:27,556 --> 00:07:29,886
that different gesture
recognizers can compete


130
00:07:29,886 --> 00:07:32,326
about have, handing
this touch sequence.


131
00:07:32,756 --> 00:07:36,466
However, for our stroke, we
really want to begin immediately


132
00:07:36,466 --> 00:07:37,596
when the touch goes down.


133
00:07:37,596 --> 00:07:40,926
So this is exactly
what we want to do.


134
00:07:41,316 --> 00:07:44,586
In touchesMoved, we do the same
and switch the state to changed.


135
00:07:44,976 --> 00:07:46,596
Note that in a gesture
recognizer,


136
00:07:46,596 --> 00:07:48,916
each state change
triggers an action method,


137
00:07:48,916 --> 00:07:50,126
even if it's for the same.


138
00:07:50,126 --> 00:07:55,706
And we do the same for
touchesEnded and Cancelled.


139
00:07:56,026 --> 00:07:59,256
And, finally, we have to
reset our gesture recognizer


140
00:07:59,476 --> 00:08:02,286
and replace the previous
stroke with a new one


141
00:08:02,286 --> 00:08:03,676
so we can catch on the next one.


142
00:08:03,906 --> 00:08:06,766
And as a good citizen, we
always call super.reset.


143
00:08:06,766 --> 00:08:12,346
Let's use this in
our ViewController.


144
00:08:14,466 --> 00:08:17,746
In our viewDidLoad, we set up
our stroke gesture recognizer,


145
00:08:18,186 --> 00:08:22,506
ourselves as the target with
the action strokeUpdated,


146
00:08:22,506 --> 00:08:24,446
and then we add it
to our main view.


147
00:08:25,126 --> 00:08:29,926
And in the update callback,
we just take the stroke


148
00:08:29,926 --> 00:08:32,596
from the gesture, and
set it on our view.


149
00:08:32,596 --> 00:08:33,746
That's all for now.


150
00:08:34,535 --> 00:08:36,846
I told you about the
stroke collection before,


151
00:08:37,126 --> 00:08:39,926
but just to bring up, I
like to keep it simple.


152
00:08:41,256 --> 00:08:44,046
So let's see what this gives us.


153
00:08:45,426 --> 00:08:46,866
I always like this moment


154
00:08:46,866 --> 00:08:48,996
when the first time
something will run.


155
00:08:50,726 --> 00:08:53,976
So what you see is
this is the position


156
00:08:53,976 --> 00:08:55,846
of the pencil on the display.


157
00:08:56,486 --> 00:09:00,726
Let's have a look.


158
00:09:00,726 --> 00:09:06,656
Oh. That doesn't look good.


159
00:09:07,926 --> 00:09:08,626
What happened?


160
00:09:09,306 --> 00:09:11,766
Let's have a closer
look in slow motion.


161
00:09:13,796 --> 00:09:18,586
That's really not
what we want to do.


162
00:09:18,846 --> 00:09:20,916
So let's, what did we see?


163
00:09:20,916 --> 00:09:22,606
We have the position
of the pencil.


164
00:09:23,356 --> 00:09:25,506
We have a really,
really big distance


165
00:09:25,536 --> 00:09:27,026
to the last line we drew,


166
00:09:27,476 --> 00:09:31,376
and the lines we drew were
really long and choppy.


167
00:09:31,516 --> 00:09:33,656
That is not what I,
what I was expecting.


168
00:09:33,656 --> 00:09:36,226
We have a really good
temporary resolution.


169
00:09:36,226 --> 00:09:37,316
Why does it look this way?


170
00:09:38,216 --> 00:09:40,326
So, obviously, we
missed some events,


171
00:09:41,066 --> 00:09:43,696
and we missed some events
because of multiple reasons.


172
00:09:43,696 --> 00:09:45,866
One of them is our drawing
engine is implemented


173
00:09:45,866 --> 00:09:46,626
very naively.


174
00:09:47,086 --> 00:09:50,856
It is drawing a complete bit map
every time, and event comes in,


175
00:09:50,856 --> 00:09:55,436
and that is not quick enough to
keep up with the display rate.


176
00:09:56,216 --> 00:09:57,916
And we will talk about
this a little bit later.


177
00:09:58,556 --> 00:10:01,136
And the most, more important
thing is we did not use the new


178
00:10:01,206 --> 00:10:03,436
iOS 9 API that we have


179
00:10:03,436 --> 00:10:05,546
to actually get to
the missed events.


180
00:10:05,976 --> 00:10:08,906
And for that, I want to look a
little bit closer at a stroke.


181
00:10:08,906 --> 00:10:11,826
So let's see that again.


182
00:10:12,986 --> 00:10:18,056
Here are all the rich samples
we want to have and see.


183
00:10:18,056 --> 00:10:22,376
And in our touch handing
methods, we always get the began


184
00:10:22,376 --> 00:10:28,556
and the ended, but in
between, we get touchesMoved.


185
00:10:29,046 --> 00:10:34,636
And we don't get all of
the touchesMoved that came


186
00:10:34,636 --> 00:10:37,796
in as a sample, and
that's for reason.


187
00:10:37,796 --> 00:10:41,436
If we would deliver to you
all the touchesMoved even


188
00:10:41,436 --> 00:10:42,956
if you would block
the main thread,


189
00:10:43,366 --> 00:10:45,726
you would see something
akin to a replay


190
00:10:45,726 --> 00:10:48,266
of the touch interaction, and
if you do live interaction,


191
00:10:48,566 --> 00:10:50,076
that's not at all what you want.


192
00:10:50,226 --> 00:10:52,426
You want the most recent
position delivered to you,


193
00:10:53,026 --> 00:10:54,606
and that's what we do generally,


194
00:10:54,606 --> 00:10:56,946
and that's what we
did before OS 9.


195
00:10:56,946 --> 00:10:58,746
We actually dropped
all the other events.


196
00:10:58,746 --> 00:11:02,176
If you weren't quick
enough in the main run loop,


197
00:11:02,846 --> 00:11:06,596
then you just didn't see any of
them, but beginning with iOS 9,


198
00:11:06,596 --> 00:11:09,066
we give you access
to the previous ones.


199
00:11:09,466 --> 00:11:13,856
And the other reason is as
our digitizer is now faster


200
00:11:13,856 --> 00:11:18,786
than the display, we don't
want to give you each an event


201
00:11:18,786 --> 00:11:21,416
for each datapoint we have.


202
00:11:22,036 --> 00:11:23,976
So you do too much work.


203
00:11:23,976 --> 00:11:26,086
So we try to coalesce
them together


204
00:11:26,686 --> 00:11:30,026
into one delivery per
[inaudible] refresh.


205
00:11:32,596 --> 00:11:36,416
So what you can do
now is in the,


206
00:11:36,416 --> 00:11:38,536
using the life touch
you get in our API,


207
00:11:39,286 --> 00:11:41,996
ask for the touches you missed,


208
00:11:42,316 --> 00:11:44,826
and that includes the touch
you currently asking for.


209
00:11:44,826 --> 00:11:46,746
So you have a complete
consistent picture.


210
00:11:47,296 --> 00:11:49,526
And those touches are
called Coalesce Touches.


211
00:11:49,906 --> 00:11:52,426
And you do that for
all your touch events.


212
00:11:53,906 --> 00:11:57,936
And you do that also
for begin and ended.


213
00:11:58,916 --> 00:12:01,076
Because you have to
stay in the same area.


214
00:12:01,076 --> 00:12:03,156
Either you handle
your life touches


215
00:12:03,206 --> 00:12:04,956
or you handle the
coalesce touches.


216
00:12:05,376 --> 00:12:08,386
Because there are methods
like previous location in view


217
00:12:08,596 --> 00:12:11,626
that reference the previous
touch, and if you mix and match,


218
00:12:11,766 --> 00:12:13,256
then you into problems there.


219
00:12:14,486 --> 00:12:17,126
So now that we know how,
how we can get them,


220
00:12:17,126 --> 00:12:18,236
let's do this in code.


221
00:12:19,606 --> 00:12:23,556
The method is coalescedTouches
for touch on UIEvent,


222
00:12:23,556 --> 00:12:25,956
and you get the event in
the touch handing callbacks.


223
00:12:27,576 --> 00:12:32,436
And now that the optional
of this result is not


224
00:12:32,436 --> 00:12:34,176
because we will give you nil.


225
00:12:35,236 --> 00:12:36,926
Anytime if you only
have one touch,


226
00:12:36,926 --> 00:12:38,266
and we don't have
Coalesced Touches,


227
00:12:38,806 --> 00:12:42,696
it's because you could ask for
any UI test that is not part


228
00:12:42,696 --> 00:12:44,236
of the event, and then
you would get nil.


229
00:12:44,626 --> 00:12:47,076
You're guaranteed to
always get UI touches,


230
00:12:47,076 --> 00:12:50,126
at least the one you put in
even if we didn't coalesce more.


231
00:12:50,526 --> 00:12:54,376
So you don't have to do an
if statement around this.


232
00:12:55,116 --> 00:12:59,006
So let's use this in our code.


233
00:12:59,006 --> 00:13:01,286
In our code where we look at
the touch we're interested in,


234
00:13:01,566 --> 00:13:04,626
we did appendTouch, and all
we have to do is to loop


235
00:13:04,626 --> 00:13:07,636
over the Coalesce Touches
instead and append those.


236
00:13:08,086 --> 00:13:10,876
That gives us all the data.


237
00:13:10,876 --> 00:13:15,136
Let's have a look
at how that looks.


238
00:13:15,136 --> 00:13:17,676
Nice. Now we really
have all the data.


239
00:13:18,496 --> 00:13:20,146
Let's have a comparison.


240
00:13:20,146 --> 00:13:28,286
And, again, in slow
motion with a stop.


241
00:13:30,616 --> 00:13:32,076
So what are you seeing here?


242
00:13:32,076 --> 00:13:34,346
This is in [inaudible]
the Pencil's location


243
00:13:34,346 --> 00:13:35,596
on the glass currently.


244
00:13:36,936 --> 00:13:41,096
These are the Coalesce Touches
in gray, colored in gray.


245
00:13:41,096 --> 00:13:43,426
Now debugging drawing engine.


246
00:13:44,236 --> 00:13:45,996
The black one is also
a Coalesce Touch,


247
00:13:45,996 --> 00:13:48,086
but the one corresponding
to the live touch.


248
00:13:49,236 --> 00:13:50,776
And what you also see is


249
00:13:50,776 --> 00:13:52,836
that you see too many
Coalesce Touches.


250
00:13:53,546 --> 00:13:55,756
If our digitizer is running
at four times the speed


251
00:13:55,756 --> 00:13:56,736
of the display, you see,


252
00:13:57,166 --> 00:14:01,156
you should see an average three
gray ones among black ones.


253
00:14:01,576 --> 00:14:02,516
These are way too many.


254
00:14:04,166 --> 00:14:06,626
And we still have this
excessive gap at the end,


255
00:14:06,626 --> 00:14:10,176
which leads to lag,
visible lag for users.


256
00:14:10,176 --> 00:14:13,406
So what did we see?


257
00:14:13,846 --> 00:14:15,756
The speed is still lagging
of our drawing engine.


258
00:14:15,756 --> 00:14:19,396
We didn't address this up
to now, but UIkit helped


259
00:14:19,396 --> 00:14:20,686
by coalescing the touches,


260
00:14:20,746 --> 00:14:24,346
and the final drawing really has
all the data it needs already.


261
00:14:24,766 --> 00:14:28,096
So if you only take
one thing of the sort,


262
00:14:28,096 --> 00:14:30,306
then use Coalesce
Touches if you really want


263
00:14:30,306 --> 00:14:32,366
to have the rich
data of your Pencil.


264
00:14:32,676 --> 00:14:39,696
So what is the problem
with the drawing?


265
00:14:39,696 --> 00:14:41,576
You should not draw
on every touch event


266
00:14:42,046 --> 00:14:44,366
because the display
refresh rate is 60 hertz.


267
00:14:44,806 --> 00:14:48,136
Although we try to actually
deliver only one event per


268
00:14:48,136 --> 00:14:51,546
frame, you can draw, that
sometimes is impossible


269
00:14:51,546 --> 00:14:54,626
because if you mix
fingers and the Pencil


270
00:14:54,626 --> 00:14:56,886
or have other events coming in,


271
00:14:56,886 --> 00:14:58,226
we need to deliver
them in order.


272
00:14:58,516 --> 00:15:01,756
And so you need to be
prepared to receive more events


273
00:15:01,756 --> 00:15:04,296
than you can, than
[inaudible] refresh rate.


274
00:15:05,206 --> 00:15:07,026
And do not try to draw faster


275
00:15:07,026 --> 00:15:11,496
because this is just costing
performance and adding lag


276
00:15:11,496 --> 00:15:14,466
and doing work that doesn't even
get displayed on the screen.


277
00:15:14,816 --> 00:15:16,406
So when should you render?


278
00:15:16,586 --> 00:15:19,466
In our example, we are using
a regular [inaudible] core


279
00:15:19,466 --> 00:15:21,646
graphics, and in that case,


280
00:15:21,706 --> 00:15:24,156
you should just use setsNeeds
display on that view,


281
00:15:24,926 --> 00:15:28,316
marking that view is needing
update and giving the work to CA


282
00:15:28,316 --> 00:15:31,796
to actually call the draw method
you need to implement instead


283
00:15:31,796 --> 00:15:33,326
of your custom bit drawing.


284
00:15:34,066 --> 00:15:39,896
If you're using a GLKView or
a MetalView you can also opt


285
00:15:39,896 --> 00:15:42,546
into this behavior
instead of a steady update


286
00:15:42,986 --> 00:15:46,426
by setting the enableSetsNeeds
display property to true.


287
00:15:47,016 --> 00:15:50,626
That way those views behave in
the same way if you want to.


288
00:15:51,776 --> 00:15:54,506
If you need to draw at a
steady pace, then please draw


289
00:15:54,506 --> 00:15:57,266
at a steady pace and not
based on the events coming in,


290
00:15:57,626 --> 00:15:59,246
and you can do so
using the Metal


291
00:15:59,246 --> 00:16:03,396
and GLViews internal
mechanisms, or you can do


292
00:16:03,396 --> 00:16:06,676
so using a CADisplayLink
and calling display


293
00:16:06,676 --> 00:16:08,056
in the wake of your DisplayLink.


294
00:16:08,646 --> 00:16:10,526
What we did was we had


295
00:16:10,526 --> 00:16:14,706
in our strokes [inaudible] just
a did set on the stroke to draw


296
00:16:14,706 --> 00:16:15,956
with drawImageAndUpdate.


297
00:16:16,426 --> 00:16:18,436
This created the
[inaudible] this was bad.


298
00:16:18,916 --> 00:16:21,046
So let's just do
setsNeedsDisplay,


299
00:16:21,726 --> 00:16:25,416
and move the drawing code
into the draw method.


300
00:16:26,396 --> 00:16:29,256
If you're using a regular
UFU, you can do even better.


301
00:16:29,546 --> 00:16:33,276
You can only mark the changed
areas a setDisplayInRect


302
00:16:33,906 --> 00:16:38,366
that also needs some kind
of bookkeeping in the touch


303
00:16:38,366 --> 00:16:41,726
because your drawing might,
might be a little bit bigger


304
00:16:41,726 --> 00:16:42,846
than the changed touches,


305
00:16:42,846 --> 00:16:45,406
and the touches change
in our samples.


306
00:16:45,796 --> 00:16:48,696
You can look at the sample
code to have one example


307
00:16:48,696 --> 00:16:50,956
of how you could do this
kind of bookkeeping.


308
00:16:52,796 --> 00:16:55,926
And even further, you can
activate drawsAsynchronously


309
00:16:56,586 --> 00:16:57,636
on the layer.


310
00:16:57,906 --> 00:17:02,036
This puts all the drawing you
do in the draw rect up to CG,


311
00:17:02,036 --> 00:17:06,046
up to CA, and CA draws it
outside of the main thread


312
00:17:06,185 --> 00:17:09,185
which opens your main thread
for quicker event handling,


313
00:17:09,726 --> 00:17:13,896
and you do so by simply setting
drawsAsynchronously to true


314
00:17:13,896 --> 00:17:14,996
or your diffuse layer.


315
00:17:16,046 --> 00:17:17,976
Let's see how far this got us.


316
00:17:24,976 --> 00:17:26,366
Again in slow motion.


317
00:17:28,856 --> 00:17:33,786
So now we have the steady amount


318
00:17:33,786 --> 00:17:36,556
of Coalesce Touches
I was talking about,


319
00:17:36,556 --> 00:17:39,106
about three Coalesce
Touches and one black one.


320
00:17:39,106 --> 00:17:42,366
But we still have some lag.


321
00:17:42,606 --> 00:17:46,486
It however, it's way smaller
because now we really draw


322
00:17:46,486 --> 00:17:51,146
at the display speed, and we
just have the remaining lag.


323
00:17:51,146 --> 00:17:53,236
And how can we improve that?


324
00:17:53,956 --> 00:17:58,546
So we have a facility called
Predicted Touches since iOS 9,


325
00:17:58,886 --> 00:18:02,416
and Predicted Touches give
you a glimpse into the future.


326
00:18:02,416 --> 00:18:06,956
You use the same way as Coalesce
Touches, and you ask your event


327
00:18:06,956 --> 00:18:10,206
for the Predicted Touches for
touch, and you get an array


328
00:18:11,086 --> 00:18:13,596
of touches that are
in the future.


329
00:18:13,596 --> 00:18:17,606
And what do you do
with those touches?


330
00:18:17,606 --> 00:18:20,386
You add them to your data
structure but temporarily.


331
00:18:20,446 --> 00:18:22,326
They change on every
event callback.


332
00:18:22,606 --> 00:18:25,096
So you really have to do
them just temporarily.


333
00:18:25,956 --> 00:18:28,026
And you choose their appearance,
depending on your app.


334
00:18:28,026 --> 00:18:33,896
I highly recommend that you make
them appear like actual touches,


335
00:18:34,956 --> 00:18:39,256
and look at the result, and
only if our prediction is off


336
00:18:39,256 --> 00:18:42,056
by too much, then tone it down.


337
00:18:42,056 --> 00:18:43,486
It makes them appears tentative


338
00:18:43,846 --> 00:18:48,506
to still get the closer
look to the Pencil.


339
00:18:49,636 --> 00:18:51,206
Let's look over that in code.


340
00:18:52,346 --> 00:18:53,786
So now in our touch
setting methods,


341
00:18:53,786 --> 00:18:55,596
after you added the
Coalesce Touches,


342
00:18:55,786 --> 00:19:02,816
you add the Predicted Touches
temporarily, and you need


343
00:19:02,816 --> 00:19:06,076
to make sure that you remove
the temporary touches before.


344
00:19:07,406 --> 00:19:10,676
So I will show you a video of
how that looks with the opposite


345
00:19:10,676 --> 00:19:11,496
of what you should do.


346
00:19:11,496 --> 00:19:15,276
I will highlight the Predicted
Touches in red so we can see


347
00:19:15,576 --> 00:19:18,046
if they are good
enough for our example.


348
00:19:18,216 --> 00:19:22,976
And, again, in slow motion
because this was so quick.


349
00:19:29,856 --> 00:19:32,956
So these are the Predictive
Touches, and they get you closer


350
00:19:32,956 --> 00:19:36,806
to the actual Pencil position,
which is really, really helpful


351
00:19:36,806 --> 00:19:39,896
for perceived lag
on the display.


352
00:19:40,296 --> 00:19:42,516
And as you can see
in this example,


353
00:19:42,516 --> 00:19:43,946
this really worked out fine.


354
00:19:43,946 --> 00:19:45,246
So we will just use them


355
00:19:45,246 --> 00:19:47,666
and draw them the same way
we draw regular touches.


356
00:19:47,666 --> 00:19:50,816
So have we seen so far?


357
00:19:51,226 --> 00:19:53,976
We have seen how to collect
the input using an custom


358
00:19:53,976 --> 00:19:58,046
UIGestureRecognizer, how to
access the Coalesce Touches,


359
00:19:59,096 --> 00:20:04,786
how to make the rendering faster
and efficient, and, finally,


360
00:20:04,786 --> 00:20:05,976
how to use the Predictive
Touches.


361
00:20:06,686 --> 00:20:10,746
All of those techniques work
on, across all iOS devices.


362
00:20:10,796 --> 00:20:13,626
We used them for the Pencil
right now in our examples,


363
00:20:13,976 --> 00:20:15,416
but they work overall.


364
00:20:15,746 --> 00:20:20,456
Now let's go on to the
actual new Apple Pencil API.


365
00:20:21,426 --> 00:20:24,006
So let's begin with touch types.


366
00:20:24,856 --> 00:20:29,886
With Apple Pencil UITouch
added a new method called type,


367
00:20:30,246 --> 00:20:33,376
and UITouch type can
be one of three values.


368
00:20:34,326 --> 00:20:37,556
It can be direct, which would
be all your previous touches you


369
00:20:37,556 --> 00:20:38,566
know about.


370
00:20:39,756 --> 00:20:43,436
There's indirect only for
the Siri remote touches,


371
00:20:43,926 --> 00:20:46,836
and there's stylus
for Apple Pencil.


372
00:20:47,736 --> 00:20:52,676
And the first thing
you can access


373
00:20:52,676 --> 00:20:54,556
with Apple Pencil is
the higher precision,


374
00:20:55,026 --> 00:20:57,976
and you do so by using
precise location in view,


375
00:20:58,946 --> 00:21:01,756
and you also have the precise
previous location in view.


376
00:21:02,426 --> 00:21:05,256
You should use those whenever
you want the precise location


377
00:21:05,256 --> 00:21:06,436
for something like a drawing.


378
00:21:06,826 --> 00:21:08,236
If you want to do hit testing,


379
00:21:08,346 --> 00:21:13,046
you should still use the
previous ones called location in


380
00:21:13,046 --> 00:21:15,126
and previous location in.


381
00:21:15,266 --> 00:21:17,176
But for drawing, this
really makes a difference.


382
00:21:17,486 --> 00:21:19,036
Without the precise locations,


383
00:21:19,036 --> 00:21:22,796
you will add some staircase
patterns to your drawing,


384
00:21:22,796 --> 00:21:23,816
which you don't want to see.


385
00:21:24,626 --> 00:21:27,706
And you can ask all kind of
touches for precise location.


386
00:21:27,706 --> 00:21:30,806
You will just get
the regular one.


387
00:21:31,386 --> 00:21:33,176
Next up, there's force.


388
00:21:33,416 --> 00:21:36,216
Force is exposed as a
property called force


389
00:21:36,596 --> 00:21:38,496
and a maximum possible force.


390
00:21:38,836 --> 00:21:42,606
Those are CG floats, and they
are in the range from zero


391
00:21:42,606 --> 00:21:44,126
to the maximum possible force


392
00:21:44,656 --> 00:21:47,676
where 1.0 represents
an average touch.


393
00:21:47,676 --> 00:21:50,116
So these are not
really physical values.


394
00:21:50,386 --> 00:21:52,396
So you shouldn't do
anything that relates


395
00:21:52,396 --> 00:21:57,036
to the actual force,
but you use this value


396
00:21:57,466 --> 00:21:59,076
to affect your drawing.


397
00:21:59,076 --> 00:22:04,936
And on all previous devices
and for regular finger touches,


398
00:22:05,236 --> 00:22:06,616
it will always return zero.


399
00:22:07,206 --> 00:22:11,126
A quick note on force.


400
00:22:11,126 --> 00:22:15,256
Since we added force to
UITouch, there's one difference


401
00:22:15,256 --> 00:22:18,486
in touch handing, and that
is touchesMoved gets called


402
00:22:18,486 --> 00:22:19,106
more often.


403
00:22:19,476 --> 00:22:21,576
Because you want to
be able to discern


404
00:22:21,576 --> 00:22:23,366
if the force value changed.


405
00:22:23,786 --> 00:22:26,756
We will send you
touchesMoved now all the time.


406
00:22:26,806 --> 00:22:29,896
Previously, we were
trying very hard


407
00:22:29,896 --> 00:22:31,616
to only send you touchesMoved


408
00:22:31,616 --> 00:22:33,446
when the location
actually changed,


409
00:22:33,976 --> 00:22:36,446
and that is through
regular location,


410
00:22:36,446 --> 00:22:37,816
not even the precise location.


411
00:22:38,996 --> 00:22:40,836
And that has implications
for you.


412
00:22:41,456 --> 00:22:44,376
So, for example, we've seen
a lot of this in the wild.


413
00:22:44,376 --> 00:22:46,046
If you did in touchesMoved,


414
00:22:46,476 --> 00:22:51,786
if you just cancel a tap
willingly, that is bad.


415
00:22:51,786 --> 00:22:53,966
That doesn't work anymore.


416
00:22:53,966 --> 00:22:57,946
And what you see is that
on a, on an iPhone 6s


417
00:22:57,996 --> 00:23:00,456
or with the Pencil,
if you have to really,


418
00:23:00,456 --> 00:23:03,006
really just slightly
touch your display,


419
00:23:03,006 --> 00:23:05,726
then this is what you're running
into, and you should have a look


420
00:23:05,726 --> 00:23:07,116
at your touch handing code.


421
00:23:07,546 --> 00:23:08,346
What should you do?


422
00:23:09,046 --> 00:23:11,276
You should actually use a
UITouchGesturesRecognizer


423
00:23:11,276 --> 00:23:13,396
if you can because
it encapsulates all


424
00:23:13,396 --> 00:23:17,116
of our knowledge there, or the
least thing you have to do is


425
00:23:17,176 --> 00:23:19,636
to remember the location
where the touches began


426
00:23:19,876 --> 00:23:24,246
and only cancel it if you
moved enough distance away


427
00:23:24,246 --> 00:23:25,446
from the original location.


428
00:23:26,906 --> 00:23:30,576
So let's add our force to the
model, to our stroke sample,


429
00:23:31,156 --> 00:23:34,486
and we just do that by an
optional force variable.


430
00:23:34,646 --> 00:23:38,686
We will add all the other
things in there later, too,


431
00:23:38,686 --> 00:23:41,406
and I won't show
this slide again.


432
00:23:41,706 --> 00:23:46,566
So let's see how the force
looks in our drawing.


433
00:23:48,046 --> 00:23:49,496
Nice. What did we do?


434
00:23:50,116 --> 00:23:53,176
We just changed the
width space of the force.


435
00:23:55,126 --> 00:23:56,866
So next up is tilt.


436
00:23:57,946 --> 00:24:01,546
Apple Pencil gives you access
to its tilt towards the device,


437
00:24:01,896 --> 00:24:05,196
and this is measured in an
angle between the Pencil


438
00:24:05,196 --> 00:24:08,396
and the device which
we call altitude.


439
00:24:09,146 --> 00:24:12,546
And the altitude angle is
exposed as altitude angle.


440
00:24:12,586 --> 00:24:14,696
It's a CG float.


441
00:24:15,496 --> 00:24:18,976
It reported at angle at
a radian from the range


442
00:24:18,976 --> 00:24:21,076
from about 10 degrees
to 90 degrees.


443
00:24:21,656 --> 00:24:27,686
And that second part
is the orientation.


444
00:24:27,686 --> 00:24:32,036
The orientation is measured
[inaudible] to your device,


445
00:24:32,036 --> 00:24:35,796
and it's measured between
the positive x direction


446
00:24:36,356 --> 00:24:38,846
and the direction the
Pencil is coming from.


447
00:24:39,486 --> 00:24:42,206
And this is called azimuth.


448
00:24:43,856 --> 00:24:48,066
Together, azimuth and tilt form
the full location of the Pencil,


449
00:24:48,066 --> 00:24:50,886
and you can drive your
UI or your datapoints


450
00:24:50,886 --> 00:24:51,806
for your drawing with it.


451
00:24:52,316 --> 00:24:56,066
So azimuth is depending on
your orientation of the device.


452
00:24:56,316 --> 00:25:00,186
So you have to call a method
called azimuthAngleInIvew,


453
00:25:00,616 --> 00:25:02,486
and most of the time
you probably want


454
00:25:02,486 --> 00:25:03,986
to use a vector anyways.


455
00:25:04,196 --> 00:25:07,166
So we exposed the azimuth
unit vector in view to you


456
00:25:07,496 --> 00:25:08,916
which will be a vector pointing


457
00:25:08,916 --> 00:25:10,576
in the direction
the Pencil is coming


458
00:25:10,576 --> 00:25:15,036
from with a magnitude of one.


459
00:25:15,756 --> 00:25:16,826
Next up, force.


460
00:25:17,546 --> 00:25:20,586
So force, for the Pencil
behaves a little bit differently


461
00:25:20,586 --> 00:25:25,896
than 3D Touch force, and that is
the force is measured along the


462
00:25:25,896 --> 00:25:27,186
axis of the Pencil.


463
00:25:27,986 --> 00:25:30,486
With 3D Touch, the force
is measured on the display


464
00:25:30,486 --> 00:25:32,616
and perpendicular to
the device surface.


465
00:25:33,186 --> 00:25:36,916
That makes for some difference,
and I really urge you to try


466
00:25:36,916 --> 00:25:39,786
out if you want to
have the actual force,


467
00:25:39,946 --> 00:25:43,166
all the perpendicular
force in your drawing tools


468
00:25:43,216 --> 00:25:45,156
because it really, it
really feels different.


469
00:25:45,766 --> 00:25:48,556
Luckily, it's easy to
calculate this component,


470
00:25:49,296 --> 00:25:50,846
and here's the code for that.


471
00:25:51,506 --> 00:25:54,896
So you can get the perpendicular
force by dividing the force


472
00:25:55,056 --> 00:25:58,626
through the sign of the altitude
angle and to make sure you stay


473
00:25:58,626 --> 00:26:00,656
in the same range, you
should also clamp it


474
00:26:00,656 --> 00:26:02,276
to the maximumPossibleForce.


475
00:26:02,816 --> 00:26:07,056
And there's finally
another tidbit


476
00:26:07,276 --> 00:26:08,746
for Apple Pencil with the force.


477
00:26:08,986 --> 00:26:12,736
It's measured inside the
Pencil, and then transmitted


478
00:26:12,816 --> 00:26:16,666
over the air to the iPad, and
this is all the properties


479
00:26:16,666 --> 00:26:17,976
of over-the-air transmissions.


480
00:26:18,056 --> 00:26:20,366
That means they take
a little bit


481
00:26:20,366 --> 00:26:22,826
of time, and data can be lost.


482
00:26:23,546 --> 00:26:25,176
So instead of making you wait


483
00:26:25,176 --> 00:26:27,206
for the over-the-air
transmission of the force,


484
00:26:27,456 --> 00:26:30,296
we decided to give you
estimated properties at first


485
00:26:31,316 --> 00:26:35,316
and update them later so you
can have the best experience.


486
00:26:36,126 --> 00:26:40,876
So for that, we exposed
estimated properties on UITouch,


487
00:26:41,476 --> 00:26:43,536
which is of the type
UITouchProperties.


488
00:26:44,496 --> 00:26:51,086
So estimated properties
can have a value of force,


489
00:26:51,466 --> 00:26:53,416
which for Apple Pencil
will always be true


490
00:26:53,416 --> 00:26:55,516
for the first event you get.


491
00:26:57,906 --> 00:27:00,406
But also the azimuth


492
00:27:00,406 --> 00:27:03,776
and altitude can be
marked as estimated.


493
00:27:04,216 --> 00:27:06,216
That happens when you
come in from the sides,


494
00:27:06,216 --> 00:27:09,656
and we not hundred percent
sure what the values will be


495
00:27:09,656 --> 00:27:11,646
or if you draw very
closely to your fingers


496
00:27:11,646 --> 00:27:15,516
because our senses can't really
detect them super-accurately.


497
00:27:15,816 --> 00:27:17,866
And we tell you that
they are estimated


498
00:27:17,866 --> 00:27:19,076
so you can do something with it.


499
00:27:19,076 --> 00:27:21,006
For example, when
coming in from the sides,


500
00:27:21,386 --> 00:27:24,466
you could back fill them
with the first solid value,


501
00:27:24,506 --> 00:27:29,906
and in the sample I gave to
you, that is what I did just


502
00:27:29,906 --> 00:27:31,436
as to illustrate that point.


503
00:27:32,366 --> 00:27:34,036
And there's also the location,


504
00:27:34,036 --> 00:27:36,946
which is an estimated property
only for the Predicted Touches,


505
00:27:37,146 --> 00:27:38,426
which gives you an easy way


506
00:27:38,426 --> 00:27:40,736
to determine Predicted
Touches from regular ones.


507
00:27:43,706 --> 00:27:47,766
And for the updates, we also
have the estimated properties


508
00:27:47,766 --> 00:27:49,176
expecting updates.


509
00:27:50,296 --> 00:27:52,626
This is also of type
UITouch properties,


510
00:27:52,626 --> 00:27:54,016
and currently it's only force.


511
00:27:54,016 --> 00:27:57,076
It might be in the future also
as an azimuth altitude, but,


512
00:27:57,076 --> 00:28:00,956
currently, it's only the force
value, and if that is set,


513
00:28:01,026 --> 00:28:04,656
we will send you updates in
the future, and we will do


514
00:28:04,656 --> 00:28:07,546
so in our new responder
called touchesEstimated


515
00:28:07,546 --> 00:28:10,876
PropertiesUpdated, and we
will do so after the fact.


516
00:28:10,876 --> 00:28:13,376
So we will send you
touches when touches begin,


517
00:28:13,376 --> 00:28:15,356
and then send you updates later.


518
00:28:16,966 --> 00:28:18,126
Let's walk through this.


519
00:28:19,026 --> 00:28:20,506
So what do you do?


520
00:28:20,506 --> 00:28:22,126
[Inaudible] touches
began or moved,


521
00:28:22,126 --> 00:28:23,966
you check the
estimatedProperties


522
00:28:23,966 --> 00:28:27,806
ExpectedUpdates on your touch,
and if that is not [inaudible],


523
00:28:29,286 --> 00:28:32,616
you use the property
estimation updated [inaudible]


524
00:28:32,616 --> 00:28:35,286
on the UITouch, which is
[inaudible] and is only set


525
00:28:35,786 --> 00:28:39,786
for touches that either expect
updates or represent an update,


526
00:28:40,276 --> 00:28:43,546
and use that to store your
thing you want to update,


527
00:28:43,546 --> 00:28:46,016
your current touch
sample in a dictionary


528
00:28:46,306 --> 00:28:47,396
so you can look it up later.


529
00:28:47,396 --> 00:28:51,746
In the touchesEstimated
PropertiesUpdated, then you look


530
00:28:51,746 --> 00:28:55,996
up your sample, and using the
estimation updates of the touch,


531
00:28:55,996 --> 00:28:58,836
you get an update
just the values


532
00:28:58,836 --> 00:29:00,226
that were expecting updates.


533
00:29:01,526 --> 00:29:04,026
Note, though, that some
of the updates will arrive


534
00:29:04,086 --> 00:29:05,346
after touch has ended.


535
00:29:06,266 --> 00:29:08,326
That's a life cycle thing
you have to be aware.


536
00:29:08,326 --> 00:29:10,796
If you don't keep
your data structure


537
00:29:10,796 --> 00:29:15,396
around after touch has ended,
you will see estimated force


538
00:29:15,586 --> 00:29:20,396
at the end of your stroke,
and it will look weird.


539
00:29:20,586 --> 00:29:22,266
So let's go with that in code.


540
00:29:23,296 --> 00:29:26,196
So we have touchesEstimated
PropertiesUpdated,


541
00:29:26,196 --> 00:29:28,526
and we go through our touches.


542
00:29:29,306 --> 00:29:32,246
We look up the estimation index
because we are in this method.


543
00:29:32,246 --> 00:29:34,206
We can just implicitly
unwrap it.


544
00:29:34,936 --> 00:29:37,756
We find our sample
in the sample index.


545
00:29:37,976 --> 00:29:40,196
We update the sample,
and as I told you,


546
00:29:40,196 --> 00:29:42,626
we update only the
values in that method


547
00:29:43,026 --> 00:29:44,886
that we're expecting
updates before.


548
00:29:45,126 --> 00:29:50,946
And then we update our
stroke, and to be future-proof,


549
00:29:50,946 --> 00:29:53,666
we check if this touch
still expects updates,


550
00:29:53,826 --> 00:29:56,776
and only if it doesn't we
remove it from our set.


551
00:29:57,346 --> 00:29:58,956
So let's see this in action.


552
00:30:04,986 --> 00:30:07,406
So I tried to use
the azimuth angle


553
00:30:07,686 --> 00:30:10,236
to do a calligraphy
pen simulation.


554
00:30:11,436 --> 00:30:15,696
And now that we have all the
data we want, let's look at this


555
00:30:15,696 --> 00:30:17,486
without the debugging mode.


556
00:30:21,336 --> 00:30:22,986
Doesn't that look nice?


557
00:30:22,986 --> 00:30:27,156
And that's literally just me
connecting all the dots we got


558
00:30:27,156 --> 00:30:27,866
from the hardware.


559
00:30:27,866 --> 00:30:29,956
That is not interpolating
anything


560
00:30:29,956 --> 00:30:31,196
or doing something fancy


561
00:30:31,196 --> 00:30:32,526
like your drawing
engines [inaudible].


562
00:30:37,826 --> 00:30:39,886
So with that, let's add
some finishing touches


563
00:30:40,326 --> 00:30:41,436
to the final app.


564
00:30:41,776 --> 00:30:45,396
Up to now, we just drew
a whole screen full.


565
00:30:45,676 --> 00:30:48,586
We don't want to be
restricted to that.


566
00:30:48,586 --> 00:30:51,816
So let's support our
arbitrary canvas sizes.


567
00:30:52,146 --> 00:30:56,426
For that, we include our stroke
view into a container view,


568
00:30:56,426 --> 00:30:58,376
add a little bit of
shadow, and put them


569
00:30:58,766 --> 00:31:01,896
that into a [inaudible] draw
view, and we're done, right.


570
00:31:03,136 --> 00:31:04,266
Not quite.


571
00:31:04,516 --> 00:31:09,686
So now we have to think about
how to handle our gestures


572
00:31:10,046 --> 00:31:13,116
because the [inaudible]
recognizes now conflicts


573
00:31:13,116 --> 00:31:14,626
with our stroke gesture
recognizer.


574
00:31:15,476 --> 00:31:18,546
If we change nothing, then
we will always draw a stroke,


575
00:31:18,546 --> 00:31:19,846
and we can never scroll.


576
00:31:20,036 --> 00:31:21,066
This is not what we want.


577
00:31:21,766 --> 00:31:23,226
So one way around this is


578
00:31:23,286 --> 00:31:25,266
to disable scrolling
with Apple Pencil.


579
00:31:25,616 --> 00:31:28,266
This would be useful for
something like an annotation app


580
00:31:28,266 --> 00:31:31,376
where you would always like to
just annotate with the Pencil


581
00:31:31,646 --> 00:31:33,566
and specifically disable that.


582
00:31:33,746 --> 00:31:37,006
You can do that because
we added allow touch types


583
00:31:37,006 --> 00:31:38,406
to UIGestureRecognizer.


584
00:31:38,996 --> 00:31:44,346
UITouch types is an array of
NSNumber of the touch types,


585
00:31:44,576 --> 00:31:47,276
and it defaults to all
of the touch types.


586
00:31:47,716 --> 00:31:49,396
So what we are going to do here


587
00:31:49,396 --> 00:31:52,556
in this example is we would
get the pan GestureRecognizer


588
00:31:52,556 --> 00:31:56,686
from our scroll view, we will
set the allow touch types


589
00:31:56,686 --> 00:32:00,456
to only allow direct touches
so it only reacts to fingers,


590
00:32:01,706 --> 00:32:05,436
and we will change our stroke
recognizer to only allow stylus.


591
00:32:06,416 --> 00:32:08,606
So this obviously is
not the full picture.


592
00:32:08,606 --> 00:32:10,866
In the sample code, you
can see one implementation


593
00:32:10,866 --> 00:32:13,196
but switches dynamically
depending on the usage


594
00:32:13,466 --> 00:32:14,876
and is a little bit
more complicated,


595
00:32:15,216 --> 00:32:16,486
but it illustrates the point


596
00:32:16,486 --> 00:32:19,736
that you can restrict
your touch handling


597
00:32:19,736 --> 00:32:22,636
to either the Pencil
or regular touches.


598
00:32:23,186 --> 00:32:28,116
And one final note on this.


599
00:32:29,546 --> 00:32:32,136
There's also a new property
on UIGestureRecognizer


600
00:32:32,136 --> 00:32:34,406
that is called
requiresExclusiveTouchType,


601
00:32:35,306 --> 00:32:39,776
and although our gesture
recognizers are defaulting


602
00:32:39,776 --> 00:32:44,446
to all the touch types, if
they see one touch and begin


603
00:32:44,446 --> 00:32:47,026
to recognize, they are
stuck in that touch type.


604
00:32:47,766 --> 00:32:50,526
That is so you don't
accidentally pinch


605
00:32:50,526 --> 00:32:51,846
with a Pencil and a finger.


606
00:32:51,846 --> 00:32:55,796
This is the regularly what you
want from a UIGestureRecognizer.


607
00:32:56,026 --> 00:32:59,386
If you don't want this, you set
the requiresExclusiveTouchTest,


608
00:32:59,536 --> 00:33:03,046
type to force, and then
you can do recognition


609
00:33:03,046 --> 00:33:04,756
between fingers and the Pencil.


610
00:33:05,436 --> 00:33:08,766
So to summarize, I showed
you all the new properties


611
00:33:08,766 --> 00:33:12,646
of UITouch so you can
make out of Apple Pencil.


612
00:33:13,166 --> 00:33:16,296
I showed you how to use the
Coalesce and Predicted Touches


613
00:33:16,586 --> 00:33:20,206
to both have the richest data
available to your drawing


614
00:33:20,466 --> 00:33:22,226
and to have the least latency.


615
00:33:23,346 --> 00:33:26,316
I told you about property
estimation, why we do it,


616
00:33:26,546 --> 00:33:28,856
and how you actually
update your data to get


617
00:33:28,896 --> 00:33:34,116
to the full rich data the Pencil
provides, and I showed you how


618
00:33:34,116 --> 00:33:39,316
to adjust gestures to either
react to Pencil or finger only.


619
00:33:40,886 --> 00:33:45,336
And this is a screenshot of the
sample app that is available


620
00:33:45,336 --> 00:33:48,616
that does the nice
calligraphy pen as a default,


621
00:33:48,946 --> 00:33:50,856
and more interesting to you,


622
00:33:51,006 --> 00:33:54,096
it also has the debug mode
you have seen the videos made


623
00:33:54,096 --> 00:33:54,486
of them.


624
00:33:54,726 --> 00:33:57,326
So you can see how your
Coalesce Touches behave,


625
00:33:57,626 --> 00:34:02,046
how they are estimated at
the edges, and see the tilt


626
00:34:02,046 --> 00:34:07,106
and azimuth, and just play
around with it to see how all


627
00:34:07,106 --> 00:34:08,416
of our touch handling works.


628
00:34:09,016 --> 00:34:13,356
So the full information of
this session is available


629
00:34:14,416 --> 00:34:15,386
at this URL.


630
00:34:16,036 --> 00:34:19,335
We have controlling game
input for Apple TV yesterday


631
00:34:19,335 --> 00:34:21,156
for Siri remote handling.


632
00:34:21,686 --> 00:34:25,806
A peek at 3D Touch will show you
all the higher level interaction


633
00:34:26,076 --> 00:34:30,826
with the force in 3D Touch to a
Peek and Pop-like experiences,


634
00:34:31,295 --> 00:34:35,596
and to get, to know more about
touch-to-display latency,


635
00:34:36,076 --> 00:34:38,295
you should have a look
at advanced touch input


636
00:34:38,295 --> 00:34:39,886
on iOS from last year.


637
00:34:40,606 --> 00:34:42,606
And with that, that's it.


638
00:34:42,795 --> 00:34:43,536
Thank you very much.

