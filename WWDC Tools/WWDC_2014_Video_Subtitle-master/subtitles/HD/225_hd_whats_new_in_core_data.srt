1
00:00:00,506 --> 00:00:13,896
[ Silence ]


2
00:00:14,396 --> 00:00:18,726
>> Hello. Welcome to Session
225, What's New in Core Data.


3
00:00:19,296 --> 00:00:20,266
I am Melissa Turner.


4
00:00:20,266 --> 00:00:21,916
I am one of the engineers
who works on Core Data,


5
00:00:21,916 --> 00:00:24,196
and I'm going to be here
talking to you about sort


6
00:00:24,196 --> 00:00:26,066
of all the new stuff
that we have been doing,


7
00:00:26,576 --> 00:00:28,456
stuff that you're likely
to be interested in.


8
00:00:29,336 --> 00:00:31,486
So, what are we going
to talk about today?


9
00:00:31,666 --> 00:00:35,236
Well, first on the list, first
on the agenda is some new API,


10
00:00:36,176 --> 00:00:38,156
batch updates, and
asynchronous fetching.


11
00:00:38,546 --> 00:00:41,836
I am going to talk about the
implications of those two APIs


12
00:00:41,836 --> 00:00:43,716
for those of you have
implemented your own


13
00:00:43,716 --> 00:00:44,706
incremental stores.


14
00:00:44,886 --> 00:00:47,946
I'm going to talk about the
Core Data concurrency story.


15
00:00:48,416 --> 00:00:50,056
That's the theme
that seems to come


16
00:00:50,056 --> 00:00:51,486
up every year in
our presentations.


17
00:00:51,726 --> 00:00:54,916
I'm going to give an iCloud
update, state of affairs,


18
00:00:55,076 --> 00:00:57,416
and I'm going to talk
about what I'm sure is


19
00:00:57,416 --> 00:00:58,966
on all your minds, Swift.


20
00:01:02,396 --> 00:01:06,136
Batch updates, what are
they, why do you care?


21
00:01:07,136 --> 00:01:12,936
Well, they're a way to mass
update data in the database,


22
00:01:12,936 --> 00:01:14,986
bypassing the Managed
Object Context


23
00:01:14,986 --> 00:01:18,346
and editing the store directly.


24
00:01:18,456 --> 00:01:21,906
It's primarily centrally
intended


25
00:01:21,906 --> 00:01:24,326
for updating attribute values,


26
00:01:24,766 --> 00:01:26,556
and it's really a
performance optimization


27
00:01:26,556 --> 00:01:30,196
because if you think about how
Core Data works, up until now,


28
00:01:30,886 --> 00:01:35,546
if you wanted to edit, say
10,000, 20,000 lines in a field,


29
00:01:36,036 --> 00:01:39,166
you've gone on vacation and left
your phone behind and come back


30
00:01:39,226 --> 00:01:41,686
to discover that your coworkers
have been really, really busy,


31
00:01:41,966 --> 00:01:44,516
and you have a lot
of SCM messages.


32
00:01:44,516 --> 00:01:48,416
If you wanted to mark all of
those read in one fell swoop,


33
00:01:48,416 --> 00:01:51,216
you would have to load
all of the objects


34
00:01:51,336 --> 00:01:54,866
into the Managed Object Context,
edit them, and save them,


35
00:01:54,866 --> 00:01:59,746
and there was a problem
here, which will kind of look


36
00:01:59,746 --> 00:02:02,206
like this, which is on a
memory-constrained device,


37
00:02:02,606 --> 00:02:04,126
loading every single object


38
00:02:04,806 --> 00:02:07,596
into memory doesn't
necessarily work that well.


39
00:02:08,376 --> 00:02:10,306
Jetsam may take offense.


40
00:02:11,826 --> 00:02:15,856
So version 2 was simply that
you would do this in batches.


41
00:02:15,986 --> 00:02:20,496
You'd load a few objects,
edit them, save them.


42
00:02:21,606 --> 00:02:26,066
Load a few more objects,
edit them, save them.


43
00:02:26,306 --> 00:02:29,266
Well, there's sort of a problem
with this approach as well,


44
00:02:29,626 --> 00:02:31,146
and it kind of looks like this.


45
00:02:31,736 --> 00:02:35,256
It takes time, and
users are likely


46
00:02:35,256 --> 00:02:37,976
to encounter a progress
indicator as they wait


47
00:02:37,976 --> 00:02:40,556
for whatever set of changes
it was that you were making.


48
00:02:41,166 --> 00:02:45,086
So what we've done now is
we've added a new method


49
00:02:45,086 --> 00:02:46,796
to NSManagedObjectContext.


50
00:02:46,796 --> 00:02:48,346
It's executeRequest:error.


51
00:02:49,126 --> 00:02:51,056
It takes an
NSPersistentStoreRequest,


52
00:02:51,056 --> 00:02:53,606
some of you are probably
familiar with that class name.


53
00:02:53,606 --> 00:02:56,416
It's the base class
for NSFetchRequest


54
00:02:56,416 --> 00:02:58,136
and NSSaveChangesRequest.


55
00:02:58,136 --> 00:03:02,836
It's now the new parent class
for NSBatchUpdateRequest


56
00:03:02,836 --> 00:03:04,526
as well, and we'll talk
about that in this slide.


57
00:03:05,786 --> 00:03:08,406
ExecuteRequest returns
a PersistentStoreResult.


58
00:03:08,566 --> 00:03:09,596
That's a new class.


59
00:03:09,596 --> 00:03:12,226
It's sort of an abstract super
class intended to be the parent


60
00:03:12,226 --> 00:03:14,426
of anything that's
returned from this method.


61
00:03:14,766 --> 00:03:17,406
And we've added
NSBatchUpdateResult


62
00:03:17,406 --> 00:03:21,326
as its first child subclass
to return the results


63
00:03:21,366 --> 00:03:23,876
of a BatchUpdateRequest.


64
00:03:24,586 --> 00:03:27,526
BatchUpdateRequest itself should
look pretty familiar to those


65
00:03:27,526 --> 00:03:30,246
of you who are familiar
with FetchRequests.


66
00:03:30,246 --> 00:03:32,186
It allows you to
specify an entity;


67
00:03:32,186 --> 00:03:34,596
it's the entity whose
instances you want changed.


68
00:03:35,336 --> 00:03:37,606
It allows you to specify
the affected stores,


69
00:03:37,606 --> 00:03:40,256
one or more stores containing
data that you want to change.


70
00:03:40,866 --> 00:03:43,686
It allows you to give
a predicate specifying


71
00:03:43,686 --> 00:03:45,896
which specific instances
you're interested in changing.


72
00:03:45,896 --> 00:03:48,766
It's the same kind of predicate
you set on NSFetchRequest,


73
00:03:48,766 --> 00:03:50,586
has all the same
power and flexibility.


74
00:03:51,276 --> 00:03:52,756
You can use subqueries
if you want to.


75
00:03:53,196 --> 00:03:55,876
It allows you to specify
the properties to update.


76
00:03:56,376 --> 00:03:57,636
This is a dictionary.


77
00:03:57,636 --> 00:04:00,526
It specifies the
property as a key


78
00:04:00,526 --> 00:04:02,106
that will be either
the property name


79
00:04:02,106 --> 00:04:03,396
or the NSPropertyDescription


80
00:04:04,036 --> 00:04:07,506
and NSExpression describing
the update as a value.


81
00:04:07,506 --> 00:04:09,316
This can be a constant
value expression,


82
00:04:09,316 --> 00:04:14,486
a function expression operating
on keypads in the object graph,


83
00:04:15,166 --> 00:04:17,236
pretty much anything
that's supported as part


84
00:04:17,236 --> 00:04:19,276
of PropertiesToFetch
is supported here.


85
00:04:19,276 --> 00:04:21,745
Pretty much anything that's
either a valid left-hand side


86
00:04:21,745 --> 00:04:23,886
or a right-hand side in a
fetch predicate is going


87
00:04:23,886 --> 00:04:24,456
to valid here.


88
00:04:24,876 --> 00:04:27,676
It also allows you to
specify a result type,


89
00:04:27,826 --> 00:04:29,646
and the result type
is kind of interesting


90
00:04:29,646 --> 00:04:32,726
because you'll always get
an NSBatchUpdateResult


91
00:04:33,226 --> 00:04:35,376
from executeRequest.


92
00:04:35,776 --> 00:04:39,926
That will indicate whether, you
know, your operation succeeded


93
00:04:39,926 --> 00:04:44,066
or failed-- the existence
of the instance itself.


94
00:04:44,136 --> 00:04:50,916
But it may also have
result properties set on it.


95
00:04:50,916 --> 00:04:52,736
This result property can
be a couple of things.


96
00:04:53,326 --> 00:04:55,136
If you're just interested
in finding out whether


97
00:04:55,136 --> 00:04:58,506
or not anything changed in
the database, you can set it


98
00:04:58,506 --> 00:05:01,666
to return Account, which will
just give you the number of rows


99
00:05:01,666 --> 00:05:04,026
that were actually
changed as a result


100
00:05:04,026 --> 00:05:07,466
of that batch update
operation, or if you want,


101
00:05:07,606 --> 00:05:10,726
you can get a list of the
object IDs of the rows


102
00:05:10,726 --> 00:05:12,176
that were changed
in that operation,


103
00:05:12,676 --> 00:05:14,866
and that's interesting
for one particular reason,


104
00:05:14,866 --> 00:05:17,546
which is that because this
is a batch update operation,


105
00:05:17,786 --> 00:05:20,596
and because we're operating
directly on the store itself


106
00:05:20,596 --> 00:05:24,066
and bypassing the Manage Object
Context, none of the changes


107
00:05:24,066 --> 00:05:25,896
that are made in the
store as a result


108
00:05:25,896 --> 00:05:27,656
of that operation
will be reflected


109
00:05:27,656 --> 00:05:29,016
in the Managed Object Context


110
00:05:29,386 --> 00:05:32,596
until you call refresh
Object on those objects.


111
00:05:33,176 --> 00:05:36,386
So if you're interested in
updating your database en masse,


112
00:05:37,386 --> 00:05:40,636
setting a flag on a
particular column for example,


113
00:05:40,916 --> 00:05:42,796
and then reflecting those
changes in the UI, you're going


114
00:05:42,796 --> 00:05:46,936
to need to get the results or
the Managed Object IDs back,


115
00:05:47,086 --> 00:05:49,646
so you can tell the object,
tell the Managed Object Context


116
00:05:49,976 --> 00:05:53,406
to refresh the objects
with those IDs.


117
00:05:53,536 --> 00:05:58,336
Another implication of the way
this is set up is that, well,


118
00:05:58,336 --> 00:06:00,396
context doesn't know anything
about the changes you're making,


119
00:06:00,396 --> 00:06:03,796
so the validation
rules are not run.


120
00:06:04,306 --> 00:06:06,266
This means it is
now possible for you


121
00:06:06,266 --> 00:06:08,006
to add bad data to
your database.


122
00:06:08,216 --> 00:06:09,066
Please don't do that.


123
00:06:09,206 --> 00:06:11,496
Your customers will
not appreciate it.


124
00:06:13,066 --> 00:06:16,406
But if you do do this,
accidentally fill


125
00:06:16,406 --> 00:06:19,006
in a bad field, what it
means is that your customers,


126
00:06:19,006 --> 00:06:22,556
the next time they load that
object, edit the object, and try


127
00:06:22,556 --> 00:06:24,926
and save, are going to
get a validation failure,


128
00:06:24,926 --> 00:06:27,476
and they may be fairly
confused as to what happened,


129
00:06:27,476 --> 00:06:29,736
since that may not have
changed that actual field.


130
00:06:31,236 --> 00:06:34,286
We do update the optimistic
locking version in the database


131
00:06:34,286 --> 00:06:36,166
for all of the rows
that are changed.


132
00:06:36,586 --> 00:06:38,816
This means now that
even if you're


133
00:06:38,816 --> 00:06:41,336
in a single persistent
store coordinator


134
00:06:41,976 --> 00:06:43,636
or single managed
object context,


135
00:06:43,736 --> 00:06:45,916
single persistent store
coordinator, single instance


136
00:06:45,916 --> 00:06:48,776
of NSPersistentStore, and all
of the changes you make go


137
00:06:48,776 --> 00:06:52,576
through that setup, you can
now create a merge conflict


138
00:06:52,576 --> 00:06:54,766
with yourself as you go
down and edit the database,


139
00:06:55,346 --> 00:06:57,686
and the context doesn't know
anything about those changes.


140
00:06:57,686 --> 00:07:00,416
So you're going to need to
remember to set a merge policy


141
00:07:00,416 --> 00:07:02,256
on your Managed Object Context


142
00:07:02,256 --> 00:07:05,036
if you're using this
API because, well,


143
00:07:05,096 --> 00:07:07,466
otherwise you may confuse
the heck out of your users


144
00:07:07,466 --> 00:07:08,616
as they get save failures.


145
00:07:09,066 --> 00:07:11,586
And now I'm going to do a demo,


146
00:07:11,986 --> 00:07:16,526
show you that this
actually does really work.


147
00:07:17,346 --> 00:07:23,566
OK, what I have here is a
simulacrum of a mail system,


148
00:07:23,566 --> 00:07:27,126
since this is the case where I
most frequently see this kind


149
00:07:27,126 --> 00:07:28,156
of batch update happening.


150
00:07:28,346 --> 00:07:31,046
Got a little application
that displays, you know,


151
00:07:31,046 --> 00:07:33,246
messages coming in,
my manager asking me


152
00:07:33,246 --> 00:07:35,316
if I got my graphics ready
for the presentation.


153
00:07:35,686 --> 00:07:38,756
Managers are so demanding,
and you say no.


154
00:07:38,936 --> 00:07:39,906
This is a few days old.


155
00:07:40,206 --> 00:07:43,646
I can come through and as I edit
the, as I select these messages,


156
00:07:43,646 --> 00:07:47,276
you can see that the Read
indicator is being marked


157
00:07:47,276 --> 00:07:50,906
as well, or the Unread
indicator is being vanished.


158
00:07:51,196 --> 00:07:52,476
I'm going to come down here.


159
00:07:52,476 --> 00:07:54,416
I'm going to look at
this other mailbox,


160
00:07:55,046 --> 00:07:59,346
which contains a whole bunch of
random SCM messages that, well,


161
00:07:59,996 --> 00:08:01,946
nobody cares about, and I forgot


162
00:08:01,946 --> 00:08:03,236
to reset my database,
but oh well.


163
00:08:03,436 --> 00:08:08,916
And I can come up here and
batch mark these as Read,


164
00:08:08,916 --> 00:08:16,196
and we're going to wait, wait,
wait, wait, wait, wait, because,


165
00:08:16,196 --> 00:08:21,326
well, this mailbox
contains 200,000 messages,


166
00:08:21,436 --> 00:08:23,506
and Core Data is going to
have to load every single one


167
00:08:23,506 --> 00:08:25,086
of those, edit them,
and save them again,


168
00:08:25,086 --> 00:08:26,266
and that takes a little while.


169
00:08:26,946 --> 00:08:29,756
As a matter of fact, if
I come down here and look


170
00:08:33,876 --> 00:08:38,436
at my project, I'll find
out it took several seconds.


171
00:08:39,966 --> 00:08:41,576
Then I'm going to come down,


172
00:08:41,576 --> 00:08:44,035
this mailbox contains the
exact same set of messages


173
00:08:44,035 --> 00:08:45,456
that the previous mailbox did.


174
00:08:46,046 --> 00:08:48,736
We can come down here and
mark it as Read, New style.


175
00:08:51,186 --> 00:08:51,966
That took less than a second.


176
00:08:52,516 --> 00:08:57,926
[ Applause ]


177
00:08:58,426 --> 00:09:00,326
So yeah, we think your
developers are going to be kind


178
00:09:00,326 --> 00:09:03,206
of happy with this, and just
as, or your customers are going


179
00:09:03,206 --> 00:09:06,246
to be happy with this, and just
as sort of a frame of reference,


180
00:09:07,526 --> 00:09:11,706
this is the effective command
that I'm running in SQLite


181
00:09:12,786 --> 00:09:17,116
to make that update
happen, and you can see


182
00:09:17,116 --> 00:09:22,626
that we're pretty close to
just the raw SQL update times.


183
00:09:22,896 --> 00:09:25,926
So as I said, changes are
not reflected in the database


184
00:09:26,206 --> 00:09:29,136
when the UI updated in that
application; that was being done


185
00:09:29,136 --> 00:09:32,206
by KVO tracking that I had
updated the root property.


186
00:09:32,636 --> 00:09:34,786
I refreshed the objects
that were being displayed


187
00:09:34,786 --> 00:09:36,306
in the table because
the table view was set


188
00:09:36,306 --> 00:09:37,386
up to do lazy fetching.


189
00:09:37,906 --> 00:09:41,366
All your standard Core Data
make this app perform nice


190
00:09:41,366 --> 00:09:42,516
and responsive tricks.


191
00:09:42,996 --> 00:09:44,946
Validation rules, as
I said, are not run.


192
00:09:45,756 --> 00:09:47,116
This is kind of running
with scissors.


193
00:09:47,656 --> 00:09:49,636
Please don't hurt
yourself or anybody else.


194
00:09:50,296 --> 00:09:52,496
We update the optimistic
locking version in the database.


195
00:09:52,496 --> 00:09:55,776
I'm just repeating all of this
to reinforce it, bring it home.


196
00:09:56,026 --> 00:09:59,116
You can create merge
conflicts on yourself, so,


197
00:09:59,116 --> 00:10:00,266
you know, set a merge policy.


198
00:10:02,076 --> 00:10:03,746
So that's our first new API.


199
00:10:04,906 --> 00:10:08,586
Our second new API is
asynchronous fetching.


200
00:10:09,076 --> 00:10:09,496
What is that?


201
00:10:09,986 --> 00:10:10,716
Why do you care?


202
00:10:11,216 --> 00:10:12,946
Well this is actually
a feature that a lot


203
00:10:12,946 --> 00:10:15,096
of developers have been asking
for, for quite some time.


204
00:10:15,816 --> 00:10:19,766
It allows you to execute a fetch
in a Managed Object Context


205
00:10:19,766 --> 00:10:21,846
that will populate that
Managed Object Context


206
00:10:21,946 --> 00:10:25,656
without actually blocking
access to that context


207
00:10:25,656 --> 00:10:26,886
for the duration of the fetch.


208
00:10:28,266 --> 00:10:32,116
It's cancellable, which means
if your user loses interest


209
00:10:32,116 --> 00:10:34,146
in whatever triggers that
fetch, you can tell us


210
00:10:34,146 --> 00:10:34,836
to stop doing it,


211
00:10:34,836 --> 00:10:40,446
and it provides progress
reporting along the way.


212
00:10:40,506 --> 00:10:43,186
Little brief refresh of how
synchronous fetching works.


213
00:10:43,476 --> 00:10:48,526
You've got a Managed Object
Context, you get a FetchRequest,


214
00:10:49,916 --> 00:10:52,226
execute FetchRequest on
the Managed Object Context,


215
00:10:52,616 --> 00:10:55,256
sends the request
down to the store,


216
00:10:56,276 --> 00:10:58,716
which takes some
time, thinks about it,


217
00:11:03,226 --> 00:11:06,126
returns a response in
the shape of an NSArray,


218
00:11:07,366 --> 00:11:08,956
updates the Managed
Object Context,


219
00:11:09,256 --> 00:11:10,546
and returns the result to you.


220
00:11:12,296 --> 00:11:17,666
Well, asynchronous fetching
is a little bit different.


221
00:11:17,666 --> 00:11:20,386
It returns a future, which
is returned immediately


222
00:11:20,386 --> 00:11:22,366
from executeRequest.


223
00:11:22,636 --> 00:11:23,406
There's no waiting.


224
00:11:23,666 --> 00:11:27,466
The request specifies
a callback block


225
00:11:27,466 --> 00:11:32,626
that will be invoked whenever
the fetch finishes executing.


226
00:11:33,996 --> 00:11:37,426
If the fetch specifies
this is an NSFetchRequest,


227
00:11:37,516 --> 00:11:40,006
we'll go into more
detail in a couple slides,


228
00:11:40,646 --> 00:11:44,036
the context should be updated
as a result of the fetch.


229
00:11:44,236 --> 00:11:45,026
That will happen.


230
00:11:45,556 --> 00:11:48,956
And this means that asynchronous
fetching is only supported


231
00:11:49,266 --> 00:11:50,936
for Managed Object Context


232
00:11:50,976 --> 00:11:53,526
that are using either the
PrivateQueueConcurrencyType


233
00:11:53,526 --> 00:11:55,136
or the
NSMainQueueConcurrencyType


234
00:11:55,606 --> 00:11:59,396
because this is the only way
that we have a separate queue


235
00:11:59,396 --> 00:12:03,576
that we know has sole
access to the state


236
00:12:03,576 --> 00:12:04,806
in the Managed Object Context.


237
00:12:05,146 --> 00:12:08,306
It's not supported for the
ConfinementConcurrencyType.


238
00:12:09,856 --> 00:12:12,236
So this is sort of how
asynchronous fetching works.


239
00:12:12,546 --> 00:12:14,406
Again, you have Managed
Object Context,


240
00:12:14,406 --> 00:12:17,366
only now you have an
NSAsynchronousFetchRequest.


241
00:12:18,616 --> 00:12:20,596
Execute Request on the context,


242
00:12:21,046 --> 00:12:23,346
and the context immediately
creates


243
00:12:23,346 --> 00:12:25,236
and returns an
AsynchronousFetchResult.


244
00:12:25,716 --> 00:12:29,076
At the same time, it takes the
AsynchronousFetchRequest you


245
00:12:29,076 --> 00:12:31,376
gave us and sends it
down to the store.


246
00:12:32,156 --> 00:12:34,846
You can now continue
editing managed objects


247
00:12:34,846 --> 00:12:36,356
in that Managed Object Context.


248
00:12:36,356 --> 00:12:38,286
You can do fetches,
faults, yeah,


249
00:12:38,496 --> 00:12:40,366
all kind of work you're
going to want to do


250
00:12:40,366 --> 00:12:41,516
on your managed objects.


251
00:12:42,226 --> 00:12:44,456
And at some point, the
store will finish executing


252
00:12:44,456 --> 00:12:48,406
that request and send the
results back, update the context


253
00:12:48,406 --> 00:12:53,866
as necessary, and invoke the
callback on the NSFetch that is


254
00:12:53,866 --> 00:12:57,526
on the AsynchronousFetchRequest,
and tell you, hey,


255
00:12:57,696 --> 00:13:00,126
you have data, maybe you
should do something with it.


256
00:13:03,216 --> 00:13:06,266
So NSAsynchronousFetchRequest
is a new subclass


257
00:13:06,266 --> 00:13:07,926
of NSPersistentStoreRequest.


258
00:13:08,706 --> 00:13:11,466
As I said, it's initialized
with a fetch request,


259
00:13:11,516 --> 00:13:12,916
an instance of NSFetchRequest,


260
00:13:13,416 --> 00:13:15,436
and a completion block
should be invoked


261
00:13:15,566 --> 00:13:17,346
when the fetch is finished.


262
00:13:17,476 --> 00:13:20,456
You pass it to
executeRequest:error,


263
00:13:20,556 --> 00:13:25,216
which will return immediately
the NSAsynchronousFetchResult,


264
00:13:25,706 --> 00:13:27,106
or nil if there's
something badly,


265
00:13:27,106 --> 00:13:30,606
badly wrong with
your fetch request.


266
00:13:31,206 --> 00:13:34,326
And NSAsynchronousFetchResults
are also pretty simple classes.


267
00:13:34,916 --> 00:13:38,146
Again, it's a subclass of
NSPersistentStoreResult,


268
00:13:38,796 --> 00:13:42,046
and this will provide results
immediately on a property


269
00:13:42,236 --> 00:13:45,816
on a fetch result, or
there'll be an error on it


270
00:13:46,046 --> 00:13:49,356
after completion if for some
reason the fetch failed.


271
00:13:50,516 --> 00:13:54,046
It's returned immediately
from executeRequest:error or,


272
00:13:54,046 --> 00:13:56,146
you know, nil if
there is an issue.


273
00:13:56,746 --> 00:13:58,766
How do you set one up?


274
00:13:59,086 --> 00:13:59,746
It's pretty simple.


275
00:14:00,606 --> 00:14:03,126
Here, we're just setting up a
fetch request that does fetch


276
00:14:03,126 --> 00:14:04,656
for all instances of my entity.


277
00:14:05,106 --> 00:14:08,006
I could, if I wanted to, add a
predicate, add sort descriptors.


278
00:14:08,436 --> 00:14:10,456
All the usual goodness
is fully supported.


279
00:14:11,996 --> 00:14:14,136
Create an
NSAsynchronousFetchRequest


280
00:14:14,136 --> 00:14:16,456
with that fetch request
and a completion block.


281
00:14:16,516 --> 00:14:18,646
Completion block here
just takes an id,


282
00:14:18,646 --> 00:14:21,236
but it would normally take
an NSAsynchronousFetchResult;


283
00:14:21,456 --> 00:14:24,816
that's just a little bit
too long to put on a slide.


284
00:14:25,306 --> 00:14:27,266
Completion block checks to see


285
00:14:27,266 --> 00:14:30,846
if the result has a
final result, and if so,


286
00:14:30,846 --> 00:14:33,456
it does whatever processing
you want done as a result


287
00:14:33,456 --> 00:14:34,406
of that fetch finishing.


288
00:14:34,806 --> 00:14:36,296
Otherwise, you'll need
to handle the error.


289
00:14:37,246 --> 00:14:39,196
Once you set up the
AsynchronousFetchRequest,


290
00:14:39,196 --> 00:14:42,596
you just tell the context to
performBlock, executeRequest,


291
00:14:42,596 --> 00:14:45,316
AsynchronousFetchRequest,
and away things go.


292
00:14:45,856 --> 00:14:51,106
I said something about
it tracking progress.


293
00:14:51,106 --> 00:14:51,816
How does that work?


294
00:14:52,116 --> 00:14:54,336
It's pretty simple.


295
00:14:54,776 --> 00:14:58,536
We use NSProgress,
standard use of NSProgress.


296
00:14:58,536 --> 00:15:01,146
You create your own before
you call executeRequest.


297
00:15:02,226 --> 00:15:06,236
Core Data will notice if you
have done this and will go off


298
00:15:06,486 --> 00:15:09,096
and create nested
child NS Progresses,


299
00:15:09,096 --> 00:15:11,896
which will report their
progress to the parent.


300
00:15:12,436 --> 00:15:14,816
And this is also how
we allow cancellations.


301
00:15:14,816 --> 00:15:17,386
If you want to cancel the
request, cancel the NSProgress.


302
00:15:17,666 --> 00:15:19,956
How does the setup
for this work?


303
00:15:19,956 --> 00:15:21,286
Well, again it's pretty simple.


304
00:15:21,636 --> 00:15:23,266
Create an instance
of NSProgress,


305
00:15:23,516 --> 00:15:24,756
set the unit count to 1.


306
00:15:25,946 --> 00:15:28,646
Why do we set the unit count
to 1 as opposed to the number


307
00:15:28,646 --> 00:15:30,116
of objects we expect
to get back?


308
00:15:30,116 --> 00:15:32,276
Well, because database
operations are streams,


309
00:15:32,276 --> 00:15:35,056
and it's kind of indefinite
how many objects you're going


310
00:15:35,056 --> 00:15:35,636
to get back.


311
00:15:35,836 --> 00:15:36,786
You may get 100.


312
00:15:36,786 --> 00:15:37,796
You may get 1.


313
00:15:38,226 --> 00:15:42,336
We can't tell up front, so we
only ever say we're finished,


314
00:15:42,336 --> 00:15:43,186
or we're not finished.


315
00:15:44,016 --> 00:15:46,166
Progress become current
with pending unit count 1,


316
00:15:46,826 --> 00:15:49,416
and this is the same
context performBlock we saw


317
00:15:49,416 --> 00:15:54,446
on the last slide, progress
resignCurrent, and you're done.


318
00:15:54,446 --> 00:16:00,276
And at this point, I'm going
to bring my manager, Ben,


319
00:16:00,276 --> 00:16:02,256
up and he's going
to show you how all


320
00:16:02,256 --> 00:16:05,006
of this works in real life.


321
00:16:08,516 --> 00:16:14,596
[ Applause ]


322
00:16:15,096 --> 00:16:16,086
>> Good morning, everyone.


323
00:16:16,086 --> 00:16:18,926
My name is Ben Trumbull, and
I'm the apparently unreasonable


324
00:16:18,926 --> 00:16:20,526
manager of the Core Data team.


325
00:16:21,106 --> 00:16:25,836
So, to give you a
little demonstration


326
00:16:25,836 --> 00:16:27,396
about what we've
been working on,


327
00:16:27,536 --> 00:16:29,766
we have asynchronous fetching
and progress reporting.


328
00:16:30,086 --> 00:16:33,506
We're going to show you a little
simple app here, and in order


329
00:16:33,506 --> 00:16:35,706
to give you something that
you guys can actually witness,


330
00:16:35,706 --> 00:16:37,526
we're actually going to
need a pretty long operation


331
00:16:37,526 --> 00:16:38,866
so you can observe the progress.


332
00:16:39,206 --> 00:16:40,606
So in this case we're
going actually be working


333
00:16:40,606 --> 00:16:42,946
with database that has 10
million rows, and we're going


334
00:16:42,946 --> 00:16:45,126
to be fetching about 5
million of them into memory.


335
00:16:45,956 --> 00:16:49,226
And for the purposes
of the demo,


336
00:16:49,226 --> 00:16:51,526
the app has pre-computed
the total number


337
00:16:51,526 --> 00:16:52,776
of objects in the database.


338
00:16:53,006 --> 00:16:54,446
I don't actually
recommend doing this.


339
00:16:54,446 --> 00:16:57,366
That can actually be kind of
slow in and of itself, but,


340
00:16:57,906 --> 00:16:59,046
as Melissa had mentioned,


341
00:16:59,186 --> 00:17:01,096
database queries
are sort of streams.


342
00:17:01,096 --> 00:17:02,586
You don't really know how many
rows you're going to get back


343
00:17:02,586 --> 00:17:05,356
until you're done, and sometimes
your audience must positively


344
00:17:05,356 --> 00:17:06,465
know exactly what's going on.


345
00:17:06,796 --> 00:17:08,415
So, we've already
preflighted that.


346
00:17:08,415 --> 00:17:11,935
So, I'm going to give you
a quick demonstration here,


347
00:17:12,096 --> 00:17:14,596
and you can see in the status
bar it's counting along.


348
00:17:20,465 --> 00:17:25,506
And we've populated the last
few objects in the array


349
00:17:25,506 --> 00:17:26,425
up here in the table view.


350
00:17:26,425 --> 00:17:29,146
I have not actually just
put 5 million objects


351
00:17:29,146 --> 00:17:33,216
into a table view because
that would be pretty cool.


352
00:17:33,216 --> 00:17:35,476
And as you can see sort
of in the background there


353
00:17:35,476 --> 00:17:38,256
from the fetch request, it
actually goes by pretty quickly.


354
00:17:38,536 --> 00:17:40,416
Core Data will actually
spin up multiple cores


355
00:17:40,416 --> 00:17:41,726
if the fetch request
is long enough,


356
00:17:41,846 --> 00:17:44,176
and I've been logging some of
the KVO updates we see there.


357
00:17:44,366 --> 00:17:47,526
So then, one of the other things
we can do here is cancellation.


358
00:17:47,826 --> 00:17:48,726
It's pretty straightforward.


359
00:17:48,726 --> 00:17:50,236
So we're going to do
the same fetch again,


360
00:17:51,376 --> 00:17:54,066
and as we're going along,
we can decide to cancel it.


361
00:17:54,676 --> 00:17:57,856
And what will end up happening
is the fetch will abort,


362
00:17:57,856 --> 00:18:00,186
and Core Data will return
an NSUserCancelled Error.


363
00:18:00,186 --> 00:18:02,246
And you can see the
status bar update there,


364
00:18:02,416 --> 00:18:03,676
that we've canceled that,


365
00:18:04,126 --> 00:18:06,436
and that's pretty much
all there is to it.


366
00:18:06,636 --> 00:18:10,746
We, basically most of the
work here is going to be


367
00:18:10,746 --> 00:18:14,856
in your KVO observer for doing
something on the NSProgress,


368
00:18:14,916 --> 00:18:17,096
so in this case, I'm dispatching
back to the main thread


369
00:18:17,096 --> 00:18:18,296
to update the status bar


370
00:18:18,686 --> 00:18:20,816
and doing some throttling
of the updates.


371
00:18:21,136 --> 00:18:23,016
So you'll get progress bar
updates probably a little bit


372
00:18:23,016 --> 00:18:25,106
faster than you might
otherwise want


373
00:18:25,106 --> 00:18:28,876
if you're fetching 10 million
rows, and that's what we have.


374
00:18:30,516 --> 00:18:38,136
[ Applause ]


375
00:18:38,636 --> 00:18:39,666
>> So onward.


376
00:18:40,086 --> 00:18:41,166
Incremental stores.


377
00:18:42,086 --> 00:18:43,816
We know some of you
have implemented them.


378
00:18:43,956 --> 00:18:46,676
We've seen them out there on the
web, and that means that some


379
00:18:46,676 --> 00:18:48,196
of you are going to
have a few questions


380
00:18:48,196 --> 00:18:51,406
about how these new
APIs affect you,


381
00:18:51,496 --> 00:18:53,306
if these new APIs affect you.


382
00:18:54,626 --> 00:18:57,536
Well, they kind of do.


383
00:18:58,906 --> 00:19:02,156
If you want to just publish
your store and have it used


384
00:19:02,156 --> 00:19:05,226
by random people, your
implementation of executeRequest


385
00:19:05,226 --> 00:19:07,516
on your incremental store
is going to now need


386
00:19:07,516 --> 00:19:09,636
to handle the new Core
Data request types.


387
00:19:10,086 --> 00:19:12,426
And if you're curious, and
some of you probably are,


388
00:19:12,536 --> 00:19:15,226
saying well, does that mean
I can now implement my own


389
00:19:15,226 --> 00:19:19,186
subclasses of
NSPersistentStoreRequest


390
00:19:19,186 --> 00:19:20,556
and NSPersistentStoreResponse?


391
00:19:20,556 --> 00:19:22,596
And the answer is yes, you
can do that if you want.


392
00:19:22,756 --> 00:19:26,126
We'll talk a little bit about
that in a couple slides.


393
00:19:27,136 --> 00:19:30,216
If you don't want to support
any new request types,


394
00:19:30,826 --> 00:19:31,866
please fail gracefully.


395
00:19:32,206 --> 00:19:34,966
By this, I mean do
what seems reasonable.


396
00:19:34,966 --> 00:19:38,566
Probably you're going to want
to return an error and say,


397
00:19:38,626 --> 00:19:39,626
I don't know how to do that.


398
00:19:39,956 --> 00:19:41,826
This is why the
PersistentStoreRequest allows


399
00:19:41,826 --> 00:19:44,536
you to specify which stores
you actually want to target


400
00:19:44,956 --> 00:19:49,376
with any given
PersistentStoreRequest.


401
00:19:49,376 --> 00:19:52,386
I mean, it doesn't make sense
to send a request to a store


402
00:19:52,386 --> 00:19:54,616
that doesn't know
what to do with it.


403
00:19:55,716 --> 00:19:57,756
Whatever you do, don't
throw in an exception.


404
00:19:58,416 --> 00:19:58,976
That never ends well.


405
00:19:59,406 --> 00:20:03,036
New request types.


406
00:20:03,416 --> 00:20:06,216
You should still be using


407
00:20:06,536 --> 00:20:08,986
with your new request types
NSManagedObjectContext


408
00:20:08,986 --> 00:20:10,286
executeRequest:Error.


409
00:20:10,286 --> 00:20:12,486
This will cause the access


410
00:20:12,486 --> 00:20:14,556
to your Persistent Store
Coordinator to be serialized.


411
00:20:14,556 --> 00:20:15,626
This is kind of important


412
00:20:15,696 --> 00:20:17,686
if you want multiple
things running around,


413
00:20:18,366 --> 00:20:19,586
talking to the same coordinator.


414
00:20:19,586 --> 00:20:22,136
You'll want to do what
we've done with fetching


415
00:20:22,136 --> 00:20:24,656
and batch updates, create
a request/response pair.


416
00:20:25,416 --> 00:20:28,226
The context is going to
return an aggregated result,


417
00:20:28,226 --> 00:20:30,926
which will contain the results
of all of the individual stores


418
00:20:30,926 --> 00:20:34,816
that knew what to do
with your new subclass,


419
00:20:35,206 --> 00:20:37,216
and the default stores
aren't actually going


420
00:20:37,216 --> 00:20:39,036
to recognize custom
request types.


421
00:20:39,036 --> 00:20:44,146
So if you're using a Core Data
stack that has multiple stores,


422
00:20:44,146 --> 00:20:45,576
some of which are
defaults and some


423
00:20:45,576 --> 00:20:48,096
of which is your custom store
types, you're going to want


424
00:20:48,096 --> 00:20:51,346
to target the request being
executed, specifically


425
00:20:51,346 --> 00:20:55,566
at the stores that know
what to do with them.


426
00:20:56,296 --> 00:21:00,016
Why might you want to
add your own subclass


427
00:21:00,196 --> 00:21:02,266
of NSPersistentStoreRequest?


428
00:21:02,976 --> 00:21:06,236
One of the big things that we've
heard repeatedly is that well,


429
00:21:06,386 --> 00:21:09,876
I want to minimize requests,
minimize trips to the store.


430
00:21:09,876 --> 00:21:12,626
This is particularly
relevant in cases


431
00:21:12,626 --> 00:21:16,096
where you've got a
disjoint object graph,


432
00:21:16,096 --> 00:21:19,906
and as part of your app launch,
you want to bring in instances


433
00:21:19,906 --> 00:21:21,266
of lots of different entities.


434
00:21:21,266 --> 00:21:23,886
You don't want to have
call executeFetchRequest


435
00:21:24,156 --> 00:21:27,356
for n different parts
of your subgraphs.


436
00:21:27,556 --> 00:21:31,736
That can get expensive if you've
got 10 chunks of your graph,


437
00:21:31,736 --> 00:21:34,156
you're having to make 10
separate network calls, that a,


438
00:21:34,156 --> 00:21:38,196
takes time, and b, there may
be a lot of overhead involved


439
00:21:38,196 --> 00:21:40,676
in those calls going
across cellular networks


440
00:21:40,676 --> 00:21:42,876
that your users don't want
to waste that bandwidth.


441
00:21:43,166 --> 00:21:45,626
So that's one thing you might
want to consider implementing


442
00:21:45,626 --> 00:21:48,866
or put in a special request
for is a launch time setup.


443
00:21:49,796 --> 00:21:52,566
You may want to do
something with object refresh.


444
00:21:52,916 --> 00:21:53,796
Hi, database.


445
00:21:53,836 --> 00:21:55,166
I've got these 10 objects.


446
00:21:55,246 --> 00:21:57,746
Send me back data for
the objects that need


447
00:21:57,746 --> 00:21:59,336
to be refreshed and
only the objects


448
00:21:59,336 --> 00:22:00,506
that need to be refreshed.


449
00:22:00,506 --> 00:22:03,066
You may want to do status
checks, that kind of thing.


450
00:22:03,066 --> 00:22:04,286
That's just a few of the things


451
00:22:04,366 --> 00:22:06,366
that people have talked
about over the years.


452
00:22:06,516 --> 00:22:10,046
If you're going to do
an AsynchronousRequest,


453
00:22:10,046 --> 00:22:12,026
you want to model it pretty
much on what we've done


454
00:22:12,026 --> 00:22:13,796
with NSAsynchronousFetchRequest.


455
00:22:14,206 --> 00:22:18,476
Return a future immediately,
message that future call back


456
00:22:18,766 --> 00:22:19,946
when the request completes.


457
00:22:20,446 --> 00:22:22,236
And if you're going to
be updating context,


458
00:22:22,446 --> 00:22:25,606
as a result of whatever
you do asynchronously,


459
00:22:25,996 --> 00:22:28,646
remember to use perform
block to update the context


460
00:22:28,816 --> 00:22:29,816
because that will make sure


461
00:22:29,816 --> 00:22:36,066
that only your request updates
are happening in the context


462
00:22:36,066 --> 00:22:38,036
at any one time, will
make sure the [inaudible]


463
00:22:38,036 --> 00:22:41,846
and as an implication, yes this
does mean that if you're going


464
00:22:41,846 --> 00:22:43,376
to be implementing
your own request types,


465
00:22:44,116 --> 00:22:46,396
then your context must be
using either the private queue


466
00:22:46,396 --> 00:22:50,786
concurrency type or the
main queue concurrency type,


467
00:22:50,896 --> 00:22:52,626
which brings us to concurrency.


468
00:22:53,286 --> 00:22:56,466
And at this point, I'm
going to take a little bit


469
00:22:56,466 --> 00:23:00,796
of a winding path to get
to our new stuff and sort


470
00:23:00,796 --> 00:23:01,996
of do a retrospective


471
00:23:01,996 --> 00:23:04,116
of the evolving Core
Data concurrency story


472
00:23:04,116 --> 00:23:04,816
over the years.


473
00:23:04,816 --> 00:23:05,836
Why am I going to do this?


474
00:23:06,266 --> 00:23:10,346
Well, it has changed a number of
times, and well, if you go out


475
00:23:10,346 --> 00:23:13,496
and hit up your favorite
search engine Duck Duck Go


476
00:23:13,496 --> 00:23:18,186
and Yosemite, for example,
or iOS 8 and say, OK,


477
00:23:18,186 --> 00:23:19,676
tell me how to do
Core Data concurrency.


478
00:23:19,676 --> 00:23:21,566
You're going to get a lot
of different responses,


479
00:23:21,566 --> 00:23:23,866
and this is sort of intended to
help you filter through those


480
00:23:23,866 --> 00:23:24,596
and figure out, you know,


481
00:23:24,596 --> 00:23:28,066
what really is the best current
advice, and I'll talk about,


482
00:23:28,066 --> 00:23:30,456
you know, also the
new state of affairs.


483
00:23:31,766 --> 00:23:34,636
So, making sense of what
you see on Stack Overflow.


484
00:23:35,256 --> 00:23:39,866
In the beginning,
NSManagedObjectContext


485
00:23:39,866 --> 00:23:41,976
and NSPersistentStoreCoordinator
implemented the


486
00:23:41,976 --> 00:23:43,056
NSLocking protocol.


487
00:23:43,986 --> 00:23:45,286
And what this meant was


488
00:23:45,286 --> 00:23:48,506
that before a developer started
accessing the Managed Object


489
00:23:48,506 --> 00:23:51,856
Context, and that included
things like accessing properties


490
00:23:51,856 --> 00:23:54,866
on NSManagedObjects created by
that managed object context,


491
00:23:55,246 --> 00:23:57,076
the developer had
to lock the context.


492
00:23:57,576 --> 00:24:00,716
If they wanted to message
PersistentStoreCoordinator,


493
00:24:00,716 --> 00:24:04,596
they needed to manually lock
PersistentStoreCoordinator


494
00:24:04,596 --> 00:24:06,876
before they sent whatever
message they wanted.


495
00:24:07,316 --> 00:24:09,966
And, you know, because
this is a locking protocol,


496
00:24:09,966 --> 00:24:12,266
they are also going to need
to unlock after they're done


497
00:24:12,266 --> 00:24:14,106
with the context or
coordinator, respectively.


498
00:24:14,556 --> 00:24:19,306
And this kind of works like
this, you've got a context.


499
00:24:19,306 --> 00:24:20,206
It has an object in it.


500
00:24:20,236 --> 00:24:21,056
You want to do something.


501
00:24:21,766 --> 00:24:22,746
You lock the context.


502
00:24:23,116 --> 00:24:26,696
You make your edits,
maybe more than one.


503
00:24:28,126 --> 00:24:31,906
You save a revert,
unlock, and things go away.


504
00:24:32,666 --> 00:24:35,426
But this actually has a
couple of problems with it,


505
00:24:35,596 --> 00:24:37,206
the biggest of which
is that it's easy


506
00:24:37,206 --> 00:24:38,586
to forget a lock or unlock.


507
00:24:39,256 --> 00:24:40,896
Well, forget is probably
the wrong word.


508
00:24:41,206 --> 00:24:42,686
Occasionally something
would throw,


509
00:24:42,756 --> 00:24:45,826
you fed Core Data
a bad predicate,


510
00:24:45,826 --> 00:24:48,056
passed [inaudible] through,
the exception went straight up,


511
00:24:48,056 --> 00:24:49,476
and now you're context
is locked.


512
00:24:49,476 --> 00:24:54,836
That's kind of a bad state of
affairs because anything you try


513
00:24:54,836 --> 00:24:56,446
and do now is going
to dead lock.


514
00:24:57,736 --> 00:25:00,416
It's also kind of tricky
doing some UI programming


515
00:25:00,416 --> 00:25:01,896
because a lot of
the binding stuff


516
00:25:01,896 --> 00:25:05,006
for example doesn't really have
a place you can hook in a lock


517
00:25:05,006 --> 00:25:07,716
or unlock as you attempt to
populate your table view,


518
00:25:08,466 --> 00:25:11,886
so that really wasn't a
satisfying answer and we moved


519
00:25:11,886 --> 00:25:13,436
on to Thread Confinement.


520
00:25:14,226 --> 00:25:17,176
This is sort of the first
step of our evolution towards,


521
00:25:17,176 --> 00:25:20,066
you know, more interesting
and robust answer to how


522
00:25:20,066 --> 00:25:22,146
to do concurrency in Core Data.


523
00:25:22,146 --> 00:25:25,326
And Thread Confinement is
basically stepping back


524
00:25:25,326 --> 00:25:29,256
and saying, OK, why are
developers trying to, you know,


525
00:25:29,596 --> 00:25:31,076
edit the same context
and it turns


526
00:25:31,076 --> 00:25:32,206
out there weren't actually a lot


527
00:25:32,206 --> 00:25:33,266
of really great reasons
for that.


528
00:25:33,586 --> 00:25:36,296
So we said, OK, just
don't do that.


529
00:25:36,296 --> 00:25:39,176
A Managed Object Context
should only be edited


530
00:25:39,176 --> 00:25:40,136
from a single thread.


531
00:25:40,696 --> 00:25:43,836
The developer is making sure,
responsible for making sure


532
00:25:43,836 --> 00:25:46,516
that only one thread ever
uses Managed Object Context,


533
00:25:46,516 --> 00:25:49,416
and at this point, a lot
of us learned about things


534
00:25:49,416 --> 00:25:52,746
like thread local variables
because that was the easiest way


535
00:25:52,746 --> 00:25:56,286
to associate a context
with a thread and make sure


536
00:25:56,286 --> 00:25:58,126
that no other context
ever had access to it.


537
00:25:58,126 --> 00:26:01,746
And in this model, the
developer still had


538
00:26:01,746 --> 00:26:03,316
to lock the Coordinator
before they used it


539
00:26:03,316 --> 00:26:05,036
and this kind of
looked like this.


540
00:26:05,126 --> 00:26:05,966
You had a thread.


541
00:26:06,446 --> 00:26:07,666
That thread had a context.


542
00:26:07,716 --> 00:26:09,166
That context had objects.


543
00:26:09,766 --> 00:26:12,776
You could edit the context
as much as you want, and no,


544
00:26:12,836 --> 00:26:14,406
you don't have to lock it.


545
00:26:15,056 --> 00:26:20,616
And sort of because people do
want to do things in parallel,


546
00:26:21,006 --> 00:26:23,586
if you wanted to actually
make changes to, you know,


547
00:26:23,686 --> 00:26:25,796
other objects, you would
set up a separate thread


548
00:26:25,796 --> 00:26:28,516
that had its own context, and
if you wanted to pass data back


549
00:26:28,516 --> 00:26:31,346
and forth between these, you'd
generally do it by, well,


550
00:26:31,576 --> 00:26:33,956
passing managed object
IDs back and forth


551
00:26:33,956 --> 00:26:36,256
and having the context
refresh data from the store.


552
00:26:37,966 --> 00:26:38,906
This was kind of awkward.


553
00:26:38,906 --> 00:26:42,606
It's still a little bit
difficult to get right.


554
00:26:42,606 --> 00:26:44,286
I mean, it involved, you know,


555
00:26:44,466 --> 00:26:46,806
making sure that you didn't
accidentally message a thread


556
00:26:46,976 --> 00:26:48,536
or a context from another thread


557
00:26:48,536 --> 00:26:50,066
or fire a fault on
another thread.


558
00:26:51,546 --> 00:26:56,266
So we wanted to make working
with the context easier,


559
00:26:56,266 --> 00:26:58,226
and about this time
another group


560
00:26:58,226 --> 00:27:01,746
at Apple was inventing a really
cool technology or technology we


561
00:27:01,746 --> 00:27:04,446
at least thought was really
cool, you're probably familiar


562
00:27:04,446 --> 00:27:07,296
with it, called GCD or
[inaudible] dispatch


563
00:27:07,296 --> 00:27:08,196
if you're working
at the [inaudible].


564
00:27:08,196 --> 00:27:10,516
And we looked at
this, and we said,


565
00:27:11,516 --> 00:27:14,636
you guys are solving this
huge problem that we have.


566
00:27:14,896 --> 00:27:15,416
We like you.


567
00:27:16,686 --> 00:27:20,906
And in this case, the
context encapsulates the


568
00:27:20,906 --> 00:27:21,556
threading model.


569
00:27:21,556 --> 00:27:25,036
Basically each context
got its very own queue


570
00:27:25,346 --> 00:27:26,616
and that queue was
the only thing


571
00:27:26,616 --> 00:27:28,086
that would ever access
the internal state


572
00:27:28,086 --> 00:27:29,406
of that managed object context.


573
00:27:29,406 --> 00:27:31,446
This is called the actor
[phonetic] pattern for those


574
00:27:31,446 --> 00:27:32,776
of who are familiar
with patterns.


575
00:27:33,106 --> 00:27:35,316
There were a few
concurrency types we set


576
00:27:35,316 --> 00:27:37,266
up Private Queue
Concurrency Type,


577
00:27:37,266 --> 00:27:39,836
which says this context
has its own private queue


578
00:27:39,916 --> 00:27:41,296
and everything should
happen there.


579
00:27:41,946 --> 00:27:44,096
A Main Thread Concurrency
Type, which was used


580
00:27:44,096 --> 00:27:49,356
for operating primarily from the
UI because AppKit, as well know,


581
00:27:49,356 --> 00:27:51,926
likes to run in the main thread.


582
00:27:52,146 --> 00:27:53,806
This basically said that as long


583
00:27:53,806 --> 00:27:56,646
as whatever is happening is
happening on the main thread,


584
00:27:56,646 --> 00:27:58,236
you can message the
Managed Object Context


585
00:27:58,236 --> 00:27:59,046
as much as you want.


586
00:27:59,886 --> 00:28:03,386
And we also had the Concurrency
Thread Confinement Type,


587
00:28:04,416 --> 00:28:07,536
well that said, well, I've
got Legacy code and I want


588
00:28:07,536 --> 00:28:09,956
to continue using that
Legacy code in the same way


589
00:28:10,276 --> 00:28:13,626
that I have had it working
for however many releases.


590
00:28:13,626 --> 00:28:15,496
I don't want to have to
rewrite my application.


591
00:28:16,666 --> 00:28:18,996
Under this model, when
you wanted to do something


592
00:28:18,996 --> 00:28:21,956
with Managed Object Context,
you would pass it a block,


593
00:28:22,266 --> 00:28:24,306
tell it to performBlock
or performBlockAndWait,


594
00:28:24,306 --> 00:28:26,236
and in this model you
also no longer had


595
00:28:26,236 --> 00:28:27,776
to lock the coordinator
before use.


596
00:28:28,416 --> 00:28:30,456
I forgot I had that slide.


597
00:28:31,126 --> 00:28:33,736
That's just the concurrency
types I talked about, main,


598
00:28:33,856 --> 00:28:34,886
private, and confinement.


599
00:28:34,886 --> 00:28:37,876
And this kind of inverts
the previous order.


600
00:28:38,696 --> 00:28:42,226
We go from having a thread that
has a Managed Object Context


601
00:28:42,726 --> 00:28:45,596
to a Managed Object
Context that has a queue


602
00:28:46,036 --> 00:28:51,576
and any thread can create a work
block and dispatch that block


603
00:28:51,576 --> 00:28:54,726
over the queue for processing
or the context for processing.


604
00:28:54,726 --> 00:28:56,726
The context will do
whatever it wants to,


605
00:28:56,726 --> 00:28:59,346
update all of its internal
state, and then return


606
00:28:59,806 --> 00:29:01,026
to the calling thread.


607
00:29:01,586 --> 00:29:03,936
This actually made things a
lot neater, a lot cleaner.


608
00:29:03,936 --> 00:29:06,426
It was much easier to
talk to the context


609
00:29:06,476 --> 00:29:07,636
and get it doing things right.


610
00:29:08,516 --> 00:29:12,036
And at this point, we had
a debugging mechanism.


611
00:29:12,136 --> 00:29:13,456
It was default.


612
00:29:13,826 --> 00:29:15,026
If you launched your application


613
00:29:15,026 --> 00:29:17,676
with com.apple.CoreData
.ConcurrencyDebug 1,


614
00:29:18,046 --> 00:29:20,896
we would be very, very picky
about how you message threads,


615
00:29:20,896 --> 00:29:23,496
and we would very, very
vocally let you know


616
00:29:23,496 --> 00:29:24,486
if you had done something wrong.


617
00:29:24,486 --> 00:29:27,566
But this required
downloading a debugged version


618
00:29:27,566 --> 00:29:29,976
of the framework from ADC.


619
00:29:30,046 --> 00:29:32,516
It was-- I think
it's WWDR these days.


620
00:29:32,786 --> 00:29:36,706
It had one problem, which
is that it often got stale


621
00:29:36,706 --> 00:29:38,876
because it's hard to
push debug frameworks


622
00:29:38,876 --> 00:29:41,416
through that mechanism at the
same time we push OS updates,


623
00:29:41,416 --> 00:29:43,926
and it wasn't available
on iOS because, you know,


624
00:29:43,926 --> 00:29:46,296
iOS didn't allow you to install
new versions of frameworks.


625
00:29:46,866 --> 00:29:51,326
So that brings us to today.


626
00:29:51,516 --> 00:29:54,686
Well, the story at the context
level is exactly the same.


627
00:29:55,336 --> 00:29:56,656
Context is still an actor.


628
00:29:56,906 --> 00:29:58,566
It still has a queue.


629
00:29:58,566 --> 00:29:59,956
It still has concurrency types.


630
00:29:59,956 --> 00:30:00,976
It still has the same
concurrency types.


631
00:30:01,196 --> 00:30:06,136
You still message it
using performBlock


632
00:30:06,136 --> 00:30:07,116
and performBlockAndWait.


633
00:30:09,486 --> 00:30:11,866
We've also added
the performBlock,


634
00:30:11,866 --> 00:30:15,386
performBlockAndWait API to
NSPersistentStoreCoordinator.


635
00:30:15,586 --> 00:30:17,086
This is mostly relevant
to those of you


636
00:30:17,086 --> 00:30:19,296
who are subclassing
NSPersistentStoreCoordinator.


637
00:30:19,296 --> 00:30:21,386
You should now be
using these methods,


638
00:30:22,426 --> 00:30:24,166
which is what our
existing methods do.


639
00:30:24,166 --> 00:30:25,526
They all wrap call
through to performBlock,


640
00:30:25,526 --> 00:30:26,306
performBlockandWait.


641
00:30:27,016 --> 00:30:28,536
PersistentStoreCoordinator,
though,


642
00:30:28,536 --> 00:30:32,086
because it doesn't actually
need to be messaged directly


643
00:30:32,086 --> 00:30:35,526
by AppKit always uses
its own private queue.


644
00:30:37,496 --> 00:30:39,976
The debugging default is
now available everywhere.


645
00:30:40,876 --> 00:30:41,976
As of Yosemite,


646
00:30:42,516 --> 00:30:45,386
[ Applause ]


647
00:30:45,886 --> 00:30:49,106
As of Yosemite and iOS
8, if you launch your app


648
00:30:49,216 --> 00:30:52,506
with com.apple .CoreData
ConcurrencyDebug 1,


649
00:30:52,846 --> 00:30:55,626
we will be very, very picky
about how you do concurrency,


650
00:30:55,626 --> 00:30:57,586
and we will let you know if
you have done something wrong.


651
00:30:58,056 --> 00:30:59,676
And this is available
on iOS as well.


652
00:31:00,896 --> 00:31:03,316
No special debug version
of the framework necessary.


653
00:31:05,256 --> 00:31:07,946
Looking ahead, and this
isn't a sort of predictions,


654
00:31:07,946 --> 00:31:10,206
not promises, because
making promises is way


655
00:31:10,206 --> 00:31:11,046
above my pay grade.


656
00:31:12,276 --> 00:31:14,196
NSThreadConfinement is
pretty much obsolete.


657
00:31:14,846 --> 00:31:17,066
That includes the
confinement concurrency type.


658
00:31:17,186 --> 00:31:19,586
We saw earlier with the
asynchronous fetching


659
00:31:19,586 --> 00:31:20,896
that it just can't be supported


660
00:31:20,896 --> 00:31:24,986
in a confinement concurrency
model, so as we move forward,


661
00:31:24,986 --> 00:31:26,976
it's likely there will
be more kinds of changes


662
00:31:27,156 --> 00:31:29,176
that also only work for contexts


663
00:31:29,176 --> 00:31:30,546
that are using either
the private queue


664
00:31:30,546 --> 00:31:31,896
or main queue concurrency types.


665
00:31:32,416 --> 00:31:35,946
As a bonus API, make that
go down a little bit easier


666
00:31:36,256 --> 00:31:38,026
because debugging is
hard enough already,


667
00:31:38,216 --> 00:31:41,746
we've added a name property
to the NSManagedObjectContext


668
00:31:42,136 --> 00:31:43,556
and PersistentStoreCoordinator.


669
00:31:43,846 --> 00:31:48,216
It only applies if your actor
is using the Private Queue


670
00:31:48,216 --> 00:31:51,316
Concurrency Type, but if you
do set a name on your context


671
00:31:51,316 --> 00:31:56,516
or your coordinator, this will
be displayed in LLDB and Xcode


672
00:31:56,516 --> 00:31:58,636
when you're debugging,
so you'll be able to see


673
00:31:58,636 --> 00:32:00,466
which queues are
actually associated


674
00:32:00,556 --> 00:32:05,896
with which managed object
context in your application.


675
00:32:06,516 --> 00:32:09,906
[ Applause ]


676
00:32:10,406 --> 00:32:12,976
On to iCloud, this
is actually going


677
00:32:12,976 --> 00:32:14,946
to be a fairly short session
because most of what you need


678
00:32:14,946 --> 00:32:16,596
to know is encapsulated
on this slide.


679
00:32:18,156 --> 00:32:21,626
Internally, I'm sure you--
at the conference so far,


680
00:32:21,626 --> 00:32:23,006
I'm sure you've heard
some buzz about,


681
00:32:23,006 --> 00:32:24,406
you know, changes to iCloud.


682
00:32:25,476 --> 00:32:27,316
We are transitioning
to new infrastructure.


683
00:32:27,846 --> 00:32:30,136
You should see some
reliability improvements


684
00:32:30,136 --> 00:32:31,846
and some performance
improvements for those of you


685
00:32:31,846 --> 00:32:34,456
who are using the Core
Data with iCloud stuff,


686
00:32:34,596 --> 00:32:37,276
but all of the changes should
be completely transparent


687
00:32:37,276 --> 00:32:38,136
to developers.


688
00:32:38,136 --> 00:32:42,086
If you're using the
patterns that Nick


689
00:32:42,086 --> 00:32:43,236
and Ben showed you last year


690
00:32:43,236 --> 00:32:46,126
in their presentation,
nothing has changed.


691
00:32:46,676 --> 00:32:49,876
Your application
completely, completely,


692
00:32:51,196 --> 00:32:53,586
everything will migrate
over just transparently.


693
00:32:53,586 --> 00:32:54,486
Everything should work.


694
00:32:54,486 --> 00:32:56,886
It should just be more
reliable and faster.


695
00:32:58,516 --> 00:33:01,616
[ Applause ]


696
00:33:02,116 --> 00:33:04,436
And I do want to talk about
CloudKit since that sort


697
00:33:04,436 --> 00:33:06,976
of a new and related technology
that might be of some interest


698
00:33:06,976 --> 00:33:08,996
to you but in order to
do that, I sort of want


699
00:33:09,266 --> 00:33:13,266
to assess the full scope of
the iCloud-related technologies


700
00:33:13,266 --> 00:33:15,426
at Apple and sort of give
you some context to decide


701
00:33:15,426 --> 00:33:17,286
if it really makes sense
for your application.


702
00:33:18,496 --> 00:33:21,356
The basic iCloud technology
is the Key Value Store.


703
00:33:21,796 --> 00:33:23,906
This allows you to store
small amounts of data


704
00:33:23,906 --> 00:33:25,936
on an application-by-application
basis.


705
00:33:26,486 --> 00:33:28,936
It's great for things like
preferences or, you know,


706
00:33:29,156 --> 00:33:30,876
view state, that kind of thing.


707
00:33:31,166 --> 00:33:32,856
It's asynchronously
kept up to date


708
00:33:32,856 --> 00:33:36,996
and it has some data limit
constraints, only allows you


709
00:33:37,046 --> 00:33:39,486
to store a small amount of data.


710
00:33:40,756 --> 00:33:42,256
There's iCloud documents.


711
00:33:42,586 --> 00:33:44,586
This is probably
familiar to those of you


712
00:33:44,586 --> 00:33:46,556
who implement document-based
applications.


713
00:33:46,636 --> 00:33:50,336
It's fairly simple API,
basically replace all


714
00:33:50,336 --> 00:33:53,616
of whatever is in the cloud with
whatever I have just created.


715
00:33:54,896 --> 00:33:57,826
Mac OS X is greedy and
will automatically download


716
00:33:57,826 --> 00:33:58,936
everything that's in the cloud,


717
00:33:58,936 --> 00:34:01,836
so you've got a full offline
cache of all of your documents.


718
00:34:02,136 --> 00:34:03,926
This is good for
unstructured data


719
00:34:03,926 --> 00:34:05,366
and is tied to the file system.


720
00:34:05,506 --> 00:34:08,485
This is good if you want to
replace everything on all


721
00:34:09,295 --> 00:34:12,286
of your devices with whatever
the latest greatest state


722
00:34:12,286 --> 00:34:14,346
from one device is.


723
00:34:14,656 --> 00:34:15,956
Now we come to iCloud Core Data.


724
00:34:17,246 --> 00:34:20,876
This is good for when you want
to merge data that is created


725
00:34:20,876 --> 00:34:23,556
across multiple devices,
instead of replacing it.


726
00:34:23,815 --> 00:34:26,926
If you add a contact on machine
1, you want that to be added


727
00:34:26,985 --> 00:34:28,466
to your global cloud data store.


728
00:34:28,466 --> 00:34:30,926
You don't want it to replace
your global cloud data store.


729
00:34:31,406 --> 00:34:36,295
It's used to keep private data,
user data, structured data


730
00:34:36,545 --> 00:34:39,926
in sync across multiple devices
and it's replicated between all


731
00:34:39,926 --> 00:34:42,216
of your devices, but
it is single-user data,


732
00:34:43,036 --> 00:34:44,106
which brings us to CloudKit.


733
00:34:45,646 --> 00:34:49,565
CloudKit is the new API
in Yosemite and iOS 8.


734
00:34:50,065 --> 00:34:51,235
It's a client server model,


735
00:34:51,426 --> 00:34:53,275
which means that it
has no local store.


736
00:34:53,275 --> 00:34:55,716
If you're going to be using it,
your users are going to need


737
00:34:55,716 --> 00:34:57,816
to be connected to the
network at all times.


738
00:34:58,836 --> 00:35:01,806
It allows for predicate-based
queries, not the full power


739
00:35:01,806 --> 00:35:04,366
that Core Data gives you,
but a really substantial


740
00:35:04,366 --> 00:35:07,206
and pretty much everything
you're reasonably going


741
00:35:07,206 --> 00:35:07,636
to want to do.


742
00:35:07,636 --> 00:35:09,946
And it's application-centered
data.


743
00:35:10,126 --> 00:35:10,846
What does that mean?


744
00:35:11,046 --> 00:35:13,996
Well, the data is public
and shared by all users


745
00:35:13,996 --> 00:35:15,616
of your application or can be.


746
00:35:15,676 --> 00:35:18,516
If you want to implement
a, I don't know,


747
00:35:18,896 --> 00:35:20,366
restaurant reviewing
application,


748
00:35:20,606 --> 00:35:23,956
where all of your users can
see what everybody else thought


749
00:35:23,956 --> 00:35:24,886
about a given restaurant,


750
00:35:25,476 --> 00:35:27,936
this is probably the
technology you want to look at.


751
00:35:27,936 --> 00:35:29,736
It's good for structured
and bulk data


752
00:35:29,736 --> 00:35:31,446
and it allows for
a large data set.


753
00:35:31,446 --> 00:35:34,176
The data set will scale
proportionately with the number


754
00:35:34,176 --> 00:35:36,726
of users of your application.


755
00:35:36,726 --> 00:35:41,596
It uses iCloud accounts and has
client-directed data transfer,


756
00:35:41,856 --> 00:35:43,446
and I don't know what
either of those means.


757
00:35:43,446 --> 00:35:46,206
You should probably go watch
the video of their session.


758
00:35:46,476 --> 00:35:49,416
Somebody gave me these
slides and asked me please


759
00:35:49,596 --> 00:35:51,366
to talk to you guys about it.


760
00:35:52,836 --> 00:35:57,826
So that's the iCloud
alternatives


761
00:35:57,826 --> 00:35:59,196
that you have on our platform.


762
00:35:59,196 --> 00:36:01,726
Some of you may want to actually
go look at CloudKit, and,


763
00:36:01,836 --> 00:36:04,876
you know, do interesting
things with it, which brings us


764
00:36:04,876 --> 00:36:07,966
to the session I'm sure
all of you have wondered


765
00:36:07,966 --> 00:36:11,536
about since Monday's
announcement, which is Swift.


766
00:36:12,436 --> 00:36:15,066
You have questions, and I'm
here to give you answers.


767
00:36:18,936 --> 00:36:21,486
This is a fragment from an
email that came through one


768
00:36:21,486 --> 00:36:24,576
of my mailboxes sometime
over the last several months.


769
00:36:25,126 --> 00:36:27,016
It basically says-- well,


770
00:36:27,376 --> 00:36:30,386
the rest of the message
basically said,


771
00:36:30,666 --> 00:36:34,496
Swift is intended as a
language for Cocoa programmers.


772
00:36:35,076 --> 00:36:37,616
Cocoa is nice and
powerful and dynamic.


773
00:36:38,176 --> 00:36:41,286
Core Data is a very dynamic and
very powerful piece of Cocoa.


774
00:36:41,856 --> 00:36:46,416
Well, Swift must support
Core Data, period.


775
00:36:49,106 --> 00:36:49,656
So it does.


776
00:36:50,596 --> 00:36:53,196
You get the full power
of Core Data in Swift.


777
00:36:53,756 --> 00:36:58,956
You can create managed
object subclasses in Swift.


778
00:36:59,416 --> 00:37:00,926
I'll show you how to do
that on the next slide,


779
00:37:01,336 --> 00:37:03,716
and if it makes sense for
your application, you can mix


780
00:37:03,716 --> 00:37:07,016
and match between Core
Data and SWF files.


781
00:37:07,396 --> 00:37:10,176
It's all the same story as
they've been telling you in all


782
00:37:10,176 --> 00:37:11,936
of the other Swift
sessions and Swift labs.


783
00:37:12,606 --> 00:37:16,556
How do you create a
managed object subclass?


784
00:37:16,606 --> 00:37:19,866
Well, they're pretty much
like Objective-C, only instead


785
00:37:19,866 --> 00:37:24,116
of using @dynamic, you'll
be using @NSManaged.


786
00:37:24,156 --> 00:37:26,026
This is a Core Data
specific property


787
00:37:26,506 --> 00:37:28,326
that tells the Swift compiler


788
00:37:28,326 --> 00:37:31,156
that the Core Data runtime
is going to be responsible


789
00:37:31,156 --> 00:37:36,606
for managing the data storage
and accessors for the properties


790
00:37:36,606 --> 00:37:38,046
that you specified is at manage.


791
00:37:39,416 --> 00:37:42,666
Unfortunately, you're not
going to be able to, you know,


792
00:37:42,866 --> 00:37:45,576
create your own dynamic
mechanisms.


793
00:37:45,926 --> 00:37:47,196
Talk to the Swift
guys about that.


794
00:37:47,886 --> 00:37:51,046
The one change other than this
that you'll need to remember


795
00:37:51,046 --> 00:37:52,796
that might trip a few of
you up is that you now need


796
00:37:52,796 --> 00:37:55,146
to add the module
name in the data model


797
00:37:55,726 --> 00:38:00,026
when you specify the class
that your entity is going


798
00:38:00,026 --> 00:38:02,416
to be using, and
that's just done up here


799
00:38:02,956 --> 00:38:06,856
in the data modeling tool, where
you used to specify the class,


800
00:38:06,856 --> 00:38:09,556
now you need to specify
the fully qualified class,


801
00:38:09,946 --> 00:38:11,256
namespace.classname.


802
00:38:12,076 --> 00:38:13,726
But that's really
the only change.


803
00:38:15,996 --> 00:38:18,496
This is what an Objective-C
subclass looks like.


804
00:38:18,496 --> 00:38:20,316
You should mostly be
familiar with this


805
00:38:20,316 --> 00:38:21,246
if you're in this session.


806
00:38:21,366 --> 00:38:25,036
Import Core Data,
declare your interface,


807
00:38:25,136 --> 00:38:27,256
declare the properties,
you're done.


808
00:38:28,086 --> 00:38:29,586
But you've also got
a separate file


809
00:38:29,706 --> 00:38:31,526
and this file is actually
pretty basic looking.


810
00:38:31,866 --> 00:38:34,176
Import your header file because,
well, that's how C works.


811
00:38:34,886 --> 00:38:37,146
Declare your implementation,


812
00:38:37,146 --> 00:38:38,736
declare that Core
Data is responsible


813
00:38:38,736 --> 00:38:40,246
for these properties,
and you're done.


814
00:38:41,106 --> 00:38:43,766
Swift collapses both of
these into a single file


815
00:38:43,766 --> 00:38:45,596
that looks a lot like this.


816
00:38:46,196 --> 00:38:48,506
Small, sleek, contains all
of the same information


817
00:38:48,506 --> 00:38:52,576
that you saw in the previous
two files in one place without,


818
00:38:52,646 --> 00:38:53,916
you know, duplication of lines.


819
00:38:54,586 --> 00:39:01,376
Some things to remember about
Swift is that it uses types.


820
00:39:02,106 --> 00:39:04,406
It's very, very firm
in the beliefs


821
00:39:04,406 --> 00:39:06,826
that static typing is a
good and important thing.


822
00:39:07,226 --> 00:39:11,266
Core Data has not, does not
use types, but if you want


823
00:39:11,306 --> 00:39:14,196
to use types, and you probably
will in your Swift code,


824
00:39:14,196 --> 00:39:19,636
you probably want to be creating
your own NSManagedObject


825
00:39:19,636 --> 00:39:22,346
subclasses, custom
subclasses, so you can use


826
00:39:22,346 --> 00:39:23,856
that subclass name
as a type name.


827
00:39:24,236 --> 00:39:26,476
Otherwise, you're going to
have to use NSManagedObject


828
00:39:26,476 --> 00:39:28,296
because entity names
are not going


829
00:39:28,296 --> 00:39:30,046
to suffice as type specifiers.


830
00:39:30,426 --> 00:39:33,426
It's going to kind
of look like this,


831
00:39:34,186 --> 00:39:38,026
should be what you pretty much
expect having had a chance


832
00:39:38,026 --> 00:39:38,626
to look at Swift.


833
00:39:38,956 --> 00:39:41,456
And now I'm going to do a demo,


834
00:39:42,926 --> 00:39:47,376
talk about how things
work in Swift.


835
00:39:48,796 --> 00:39:54,546
So here we have a Swift
application or a project


836
00:39:54,736 --> 00:39:56,976
that builds an application
that looks awfully


837
00:39:56,976 --> 00:39:59,076
like the last thing I demoed.


838
00:40:00,336 --> 00:40:01,586
It's got an app delegate.


839
00:40:02,276 --> 00:40:08,516
It's got all of your standard
code, sets up IB outlets


840
00:40:08,516 --> 00:40:12,596
for your controllers, adds key
value observers, so you notice


841
00:40:12,596 --> 00:40:13,856
when things have changed,


842
00:40:13,856 --> 00:40:15,956
you can refresh contents
of controllers.


843
00:40:18,546 --> 00:40:23,116
It's got batch update
code to run batch updates.


844
00:40:24,246 --> 00:40:25,406
All the same stuff you'd expect.


845
00:40:25,706 --> 00:40:28,316
It's got a utilities class,


846
00:40:28,316 --> 00:40:32,716
and I've actually split my
Core Data stack setup off


847
00:40:32,716 --> 00:40:35,236
into utilities and
that's due to the way


848
00:40:35,236 --> 00:40:38,046
that Swift handles
variable initialization,


849
00:40:39,446 --> 00:40:43,906
either initialize
something to a simple type


850
00:40:44,196 --> 00:40:46,186
or you set up computer property.


851
00:40:46,186 --> 00:40:47,646
But if you set up
computer property,


852
00:40:48,066 --> 00:40:50,926
that gets reevaluated every time
somebody accesses the property,


853
00:40:51,326 --> 00:40:52,146
which is not what you want


854
00:40:52,146 --> 00:40:53,456
when you're setting
up a Core Data stack.


855
00:40:54,136 --> 00:40:57,006
You only want to access it once.


856
00:40:57,976 --> 00:40:59,486
I was playing around
as I built this,


857
00:40:59,486 --> 00:41:04,856
so you can see a lazy
property, deferring binding


858
00:41:04,856 --> 00:41:07,016
to managed object models data


859
00:41:07,016 --> 00:41:09,076
until you actually
try and access it.


860
00:41:09,876 --> 00:41:13,636
Computer property for Persistent
Store Coordinator sets


861
00:41:13,636 --> 00:41:14,166
up my stack.


862
00:41:15,276 --> 00:41:17,086
Computer properties
can deal with nil.


863
00:41:17,086 --> 00:41:18,466
@lazy is not happy with nil,


864
00:41:18,466 --> 00:41:20,526
so there's another
minor gotcha there.


865
00:41:20,946 --> 00:41:25,216
Here, we've got our
function that sets up


866
00:41:25,216 --> 00:41:28,266
and returns our managed
object context.


867
00:41:28,266 --> 00:41:32,486
It looks pretty familiar to
those of you who are familiar


868
00:41:32,486 --> 00:41:35,906
with Core Data, all of the
[inaudible] calls are the same.


869
00:41:36,496 --> 00:41:40,836
Our mailbox, here we've
got our message instance,


870
00:41:40,836 --> 00:41:46,746
which has a KVO observer setup,
set it up in the init method.


871
00:41:47,186 --> 00:41:49,896
Whenever the observer
gets triggered,


872
00:41:49,896 --> 00:41:53,356
we'll update our read badge.


873
00:41:53,576 --> 00:41:56,306
Messages controller does the
same thing the previous messages


874
00:41:56,306 --> 00:41:57,046
controller did.


875
00:41:57,286 --> 00:42:01,676
I'm going to build and run.


876
00:42:01,676 --> 00:42:08,776
Whew. It's a Swift
application using Core Data.


877
00:42:09,056 --> 00:42:10,536
It's actually a little
bit faster


878
00:42:10,536 --> 00:42:11,556
than the Objective-C version.


879
00:42:12,516 --> 00:42:17,576
[ Applause ]


880
00:42:18,076 --> 00:42:26,786
So, yeah, and if I come up here,
Mark as Read, whew, it's read.


881
00:42:27,746 --> 00:42:29,646
So I talked about batch updates.


882
00:42:30,046 --> 00:42:32,176
We talked about asynchronous
fetching and incremental stores


883
00:42:32,176 --> 00:42:33,246
and what that means for you,


884
00:42:33,666 --> 00:42:36,236
talked about our
concurrency changes


885
00:42:36,236 --> 00:42:39,196
and our concurrency story over
the years, gave you a sense of,


886
00:42:39,446 --> 00:42:43,386
you know, where we were, where
we wanted to be, iCloud update,


887
00:42:43,476 --> 00:42:44,346
and I talked about Swift.


888
00:42:44,426 --> 00:42:45,286
I think I've covered everything.


889
00:42:45,836 --> 00:42:47,146
This is where you get


890
00:42:47,146 --> 00:42:49,196
to see Anthony the alligator
telling you to file bugs.


891
00:42:49,606 --> 00:42:52,746
We can't fix what
we don't know about.


892
00:42:52,746 --> 00:42:55,876
We don't guarantee we'll fix
what we do know about, but,


893
00:42:55,966 --> 00:42:58,476
you know, we can't fix
what we don't know about.


894
00:42:58,986 --> 00:43:00,436
File a bug report.


895
00:43:00,436 --> 00:43:03,376
It helps if you give us steps
to reproduce, really helps


896
00:43:03,376 --> 00:43:04,286
if you give us an app.


897
00:43:04,526 --> 00:43:06,976
If you give us an app that
reproduces your problem, well,


898
00:43:07,026 --> 00:43:10,866
we fix those first because,
you know, we know what to fix.


899
00:43:10,956 --> 00:43:14,326
If you want feature requests,
enhancement requests,


900
00:43:14,326 --> 00:43:16,026
performance issues,
documentation stuff,


901
00:43:16,176 --> 00:43:17,236
all goes through Bug Reporter.


902
00:43:19,876 --> 00:43:22,546
For more information, you
can talk to Dave DeLong.


903
00:43:22,546 --> 00:43:25,156
He's our technology
evangelist, delong@apple.com,


904
00:43:25,346 --> 00:43:28,826
or you can send whatever
your feedback is


905
00:43:28,826 --> 00:43:30,496
to cocoa-feedback@apple.com.


906
00:43:30,566 --> 00:43:34,386
We have a lot of documentation
online at developer website.


907
00:43:34,386 --> 00:43:36,856
There's a programming guide,
some examples, tutorials,


908
00:43:36,856 --> 00:43:38,856
code fragments, that
kind of thing,


909
00:43:38,856 --> 00:43:41,306
and there's always the
Apple developer forums.


910
00:43:43,176 --> 00:43:45,316
Related sessions,
I mentioned this.


911
00:43:45,316 --> 00:43:46,386
There was a CloudKit session,


912
00:43:46,386 --> 00:43:49,016
Introducing CloudKit,
Tuesday at 3:15.


913
00:43:49,016 --> 00:43:50,216
If you're interested in that,


914
00:43:50,216 --> 00:43:51,616
you probably want
to watch the video.


915
00:43:52,126 --> 00:43:54,526
There's also, although it is
not appearing on this slide,


916
00:43:54,526 --> 00:43:56,956
was a What's New in
Cocoa session on Tuesday.


917
00:43:56,956 --> 00:43:58,996
You may be interested in
watching that as well,


918
00:43:59,596 --> 00:44:02,916
and welcome and thanks
for coming.


919
00:44:03,516 --> 00:44:07,850
[ Applause ]

