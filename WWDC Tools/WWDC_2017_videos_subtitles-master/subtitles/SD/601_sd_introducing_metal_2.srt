1
00:00:21,516 --> 00:00:27,906
[ Applause ]


2
00:00:28,406 --> 00:00:28,846
>> Welcome.


3
00:00:29,366 --> 00:00:30,936
We introduced the host of new


4
00:00:30,936 --> 00:00:32,496
technologies with Metal 2 to


5
00:00:32,796 --> 00:00:34,416
allow you to make better,


6
00:00:34,416 --> 00:00:36,876
faster, and more efficient


7
00:00:36,876 --> 00:00:37,646
applications.


8
00:00:38,146 --> 00:00:39,336
My name is Michal and together


9
00:00:39,336 --> 00:00:40,786
with my colleague Richard we'll


10
00:00:40,786 --> 00:00:42,696
explore three main themes today.


11
00:00:44,476 --> 00:00:46,486
With Metal 2 we are continuing


12
00:00:46,696 --> 00:00:48,576
our direction of moving the


13
00:00:48,576 --> 00:00:50,466
expensive things to happen less


14
00:00:50,466 --> 00:00:52,096
frequently and to making sure


15
00:00:52,096 --> 00:00:53,636
that the frequent things are


16
00:00:53,676 --> 00:00:55,116
really, really cheap.


17
00:00:55,596 --> 00:00:57,336
Over the years we introduced


18
00:00:57,586 --> 00:01:00,166
precompiled shaders, render


19
00:01:00,166 --> 00:01:02,226
state objects, Metal Heap last


20
00:01:02,226 --> 00:01:04,506
year all to make sure that you


21
00:01:04,506 --> 00:01:06,366
can move the costly operations


22
00:01:06,516 --> 00:01:08,726
outside of your main application


23
00:01:09,286 --> 00:01:09,386
loop.


24
00:01:10,016 --> 00:01:13,776
We gave you 10 times more draw


25
00:01:13,776 --> 00:01:15,826
calls by switching from open GL


26
00:01:16,136 --> 00:01:16,636
to Metal.


27
00:01:17,536 --> 00:01:18,926
And this year we are introducing


28
00:01:18,926 --> 00:01:21,436
our new binding API that gives


29
00:01:21,436 --> 00:01:22,796
you some more.


30
00:01:22,796 --> 00:01:24,366
And so we will talk about it a


31
00:01:24,366 --> 00:01:24,886
bit further.


32
00:01:26,376 --> 00:01:28,946
We are also putting GPU more in


33
00:01:28,946 --> 00:01:31,956
a driving seat with GPU driven


34
00:01:31,956 --> 00:01:32,796
pipelines.


35
00:01:33,356 --> 00:01:35,266
And you will be able to create


36
00:01:35,266 --> 00:01:37,906
new, novel algorithms, new


37
00:01:37,906 --> 00:01:40,256
rendering techniques, and whole


38
00:01:40,856 --> 00:01:43,216
unique experiences utilizing


39
00:01:43,216 --> 00:01:45,116
Metal 2 on modern GPUs.


40
00:01:45,486 --> 00:01:46,296
Well, speaking of the


41
00:01:46,296 --> 00:01:49,026
experiences, we have a lot of


42
00:01:49,026 --> 00:01:50,246
new features in Metal and we


43
00:01:50,246 --> 00:01:51,666
have three other sessions that I


44
00:01:51,666 --> 00:01:52,686
would love you to attend.


45
00:01:53,526 --> 00:01:56,716
VR is coming to Mac this year


46
00:01:56,716 --> 00:01:58,916
and with the new iMacs we are


47
00:01:58,916 --> 00:02:01,426
giving you really powerful GPUs.


48
00:02:01,906 --> 00:02:03,996
The external GPU is coming to


49
00:02:04,046 --> 00:02:05,586
MacBook Pro to give you the same


50
00:02:05,586 --> 00:02:05,946
power.


51
00:02:06,666 --> 00:02:09,106
And this all enables your users


52
00:02:09,455 --> 00:02:11,496
and your content creators to


53
00:02:11,496 --> 00:02:14,096
experience VR in ways not


54
00:02:14,096 --> 00:02:14,876
possible before.


55
00:02:15,506 --> 00:02:17,676
Tomorrow's session will show you


56
00:02:18,426 --> 00:02:22,076
how to use our display -- direct


57
00:02:22,076 --> 00:02:23,816
display technology -- to get


58
00:02:23,816 --> 00:02:25,936
your content to HMD quick and


59
00:02:25,936 --> 00:02:26,776
with low latency.


60
00:02:28,116 --> 00:02:29,846
You'll learn about the new Metal


61
00:02:29,846 --> 00:02:32,006
API editions for VR and our new


62
00:02:32,006 --> 00:02:33,006
Tools editions.


63
00:02:35,796 --> 00:02:38,206
Machine learning is quickly


64
00:02:38,206 --> 00:02:40,236
becoming a key feature of our


65
00:02:40,236 --> 00:02:42,016
devices in many, many


66
00:02:42,016 --> 00:02:42,906
applications.


67
00:02:42,906 --> 00:02:44,976
And with Metal 2 you can use


68
00:02:44,976 --> 00:02:47,726
Metal performance shaders to


69
00:02:47,816 --> 00:02:49,656
utilize the power of the GPU for


70
00:02:49,656 --> 00:02:53,376
machine learning on both test up


71
00:02:53,486 --> 00:02:54,466
and mobile devices.


72
00:02:55,306 --> 00:02:56,786
And you're probably staring at


73
00:02:56,846 --> 00:02:58,186
that picture behind me and


74
00:02:58,186 --> 00:02:59,436
thinking, "How's that done?"


75
00:02:59,716 --> 00:03:01,266
Well, we have a session for you


76
00:03:01,266 --> 00:03:03,706
on Thursday where you will learn


77
00:03:03,706 --> 00:03:05,346
about this and about the machine


78
00:03:05,346 --> 00:03:07,196
learning primitives -- the image


79
00:03:07,196 --> 00:03:08,736
processing primitives -- we have


80
00:03:08,976 --> 00:03:10,906
in our Metal performance


81
00:03:10,906 --> 00:03:11,446
shaders.


82
00:03:12,976 --> 00:03:15,506
Lastly, our tools have seen the


83
00:03:15,506 --> 00:03:17,506
biggest advancement yet with


84
00:03:17,506 --> 00:03:18,076
Metal 2.


85
00:03:18,196 --> 00:03:19,796
You'll be able to debug your


86
00:03:19,796 --> 00:03:20,946
applications quicker.


87
00:03:21,496 --> 00:03:23,206
You can drill down to problems


88
00:03:23,626 --> 00:03:26,736
easier and we are exposing, for


89
00:03:26,736 --> 00:03:28,156
example GPU performance


90
00:03:28,156 --> 00:03:29,816
counters, to make sure that you


91
00:03:29,816 --> 00:03:33,506
can find your hotspots and your


92
00:03:33,506 --> 00:03:36,056
application fast pass quicker.


93
00:03:37,346 --> 00:03:39,726
So I hope I got you excited


94
00:03:39,986 --> 00:03:41,886
about the few days ahead and


95
00:03:41,886 --> 00:03:44,006
let's get back to the present


96
00:03:44,006 --> 00:03:45,336
with the content of today's


97
00:03:45,336 --> 00:03:45,676
session.


98
00:03:51,286 --> 00:03:53,416
So we'll start with argument


99
00:03:53,416 --> 00:03:55,736
buffers, probably our biggest


100
00:03:55,826 --> 00:03:57,516
core framework addition this


101
00:03:57,516 --> 00:03:57,736
year.


102
00:03:58,536 --> 00:04:00,586
argument buffers provide an


103
00:04:00,586 --> 00:04:03,266
efficient new way of configuring


104
00:04:03,266 --> 00:04:05,776
which buffers, textures, and


105
00:04:06,256 --> 00:04:07,826
samplers your application can


106
00:04:07,826 --> 00:04:11,186
use freeing up considerable


107
00:04:11,186 --> 00:04:13,076
amount of CPU resources and


108
00:04:13,076 --> 00:04:14,856
actually enabling completely new


109
00:04:14,856 --> 00:04:16,206
schedules for the GPU at the


110
00:04:16,206 --> 00:04:16,916
same time.


111
00:04:19,245 --> 00:04:20,565
Then we'll talk about Raster


112
00:04:20,565 --> 00:04:22,816
Order Groups, a new fragment


113
00:04:22,816 --> 00:04:24,356
shader synchronization primitive


114
00:04:24,846 --> 00:04:26,696
that allows you to precisely


115
00:04:26,696 --> 00:04:28,396
control the order in which


116
00:04:28,616 --> 00:04:30,296
fragment shaders access common


117
00:04:30,296 --> 00:04:32,866
memory, enabling you new use


118
00:04:32,866 --> 00:04:34,566
cases for example of


119
00:04:35,126 --> 00:04:37,026
programmable blending on MacOS


120
00:04:37,076 --> 00:04:41,306
or voxelization [phonetic] order


121
00:04:41,346 --> 00:04:42,446
independent transparency.


122
00:04:43,306 --> 00:04:44,706
And then we'll switch to the


123
00:04:44,706 --> 00:04:46,496
topic of display and we talk


124
00:04:46,496 --> 00:04:48,226
about the new ProMotion Displays


125
00:04:48,226 --> 00:04:50,336
on iPads and how to best drive


126
00:04:50,336 --> 00:04:51,356
them using Metal.


127
00:04:51,356 --> 00:04:54,236
And we'll also give you a recap


128
00:04:54,286 --> 00:04:57,216
of our best practices of getting


129
00:04:57,216 --> 00:04:58,716
your content from your render


130
00:04:58,716 --> 00:05:02,446
targets to the glass as quickly


131
00:05:02,446 --> 00:05:03,886
as possible and with the least


132
00:05:03,886 --> 00:05:04,826
amount of latency.


133
00:05:05,406 --> 00:05:07,546
And finally we'll finish with a


134
00:05:07,946 --> 00:05:09,876
survey of all the other Metal


135
00:05:09,876 --> 00:05:12,156
features that we added to align


136
00:05:12,396 --> 00:05:15,276
iOS and MacOS platforms into one


137
00:05:15,626 --> 00:05:16,976
big, common Metal ecosystem.


138
00:05:22,156 --> 00:05:26,006
So the argument buffers.


139
00:05:26,366 --> 00:05:28,386
Let's look at what they are and


140
00:05:28,546 --> 00:05:29,096
how they work.


141
00:05:29,146 --> 00:05:30,636
And I will need an example for


142
00:05:30,636 --> 00:05:33,606
that so let's think of a simple


143
00:05:33,606 --> 00:05:35,996
material that those who actually


144
00:05:35,996 --> 00:05:39,276
wrote any sort of 3D render


145
00:05:39,276 --> 00:05:39,876
program would know.


146
00:05:40,296 --> 00:05:42,156
In your material you have a


147
00:05:42,156 --> 00:05:44,956
bunch of numerical constants, a


148
00:05:44,956 --> 00:05:46,066
bunch of textures -- probably


149
00:05:46,066 --> 00:05:47,246
more than two now a days --


150
00:05:47,306 --> 00:05:47,836
assembler.


151
00:05:48,516 --> 00:05:53,026
And this is what you need to


152
00:05:53,026 --> 00:05:54,556
send to the GPU to be able to


153
00:05:54,556 --> 00:05:55,886
render your primitive.


154
00:05:56,346 --> 00:05:58,396
Now the texture objects are


155
00:05:59,276 --> 00:06:00,856
interesting because they contain


156
00:06:01,006 --> 00:06:03,336
both texture properties such as


157
00:06:03,336 --> 00:06:06,456
width, height, pixel format


158
00:06:06,456 --> 00:06:08,696
perhaps, and then a pointer to a


159
00:06:08,696 --> 00:06:09,996
blob of memory which contains


160
00:06:09,996 --> 00:06:11,036
all the pretty pixels.


161
00:06:11,036 --> 00:06:13,726
Well, unfortunately we are not


162
00:06:13,726 --> 00:06:14,596
really interested in those


163
00:06:14,626 --> 00:06:15,766
pixels in this presentation.


164
00:06:15,766 --> 00:06:18,456
So off it goes and we'll only be


165
00:06:18,456 --> 00:06:20,256
talking about boring texture


166
00:06:20,256 --> 00:06:20,756
states.


167
00:06:21,986 --> 00:06:24,326
So with traditional argument


168
00:06:24,326 --> 00:06:26,396
model we allow you to put all


169
00:06:26,396 --> 00:06:28,926
the constants into a Metal


170
00:06:28,926 --> 00:06:30,046
buffer and we created this


171
00:06:30,046 --> 00:06:31,956
indirection so that it's easy


172
00:06:31,956 --> 00:06:33,676
for you to use and also it gives


173
00:06:33,676 --> 00:06:35,966
GPU the unfiltered, direct


174
00:06:35,966 --> 00:06:37,766
access to all the data.


175
00:06:38,956 --> 00:06:40,996
However, when it comes to things


176
00:06:40,996 --> 00:06:43,216
like textures or samplers you


177
00:06:43,216 --> 00:06:44,276
still need to go through quite


178
00:06:44,276 --> 00:06:46,096
about of an API and in your


179
00:06:46,096 --> 00:06:47,516
rendering loop you'll set the


180
00:06:47,516 --> 00:06:49,886
buffer, set all the textures,


181
00:06:50,506 --> 00:06:51,976
samplers, and only after that


182
00:06:51,976 --> 00:06:53,226
you can finally draw.


183
00:06:53,266 --> 00:06:55,506
And even though Metal is really


184
00:06:55,506 --> 00:06:57,506
optimized this is quite a few


185
00:06:57,506 --> 00:06:59,166
API codes and if you multiply it


186
00:06:59,166 --> 00:07:00,116
with the number of objects you


187
00:07:00,116 --> 00:07:02,596
need to render, every frame, and


188
00:07:02,596 --> 00:07:03,876
the fact that you need to do all


189
00:07:03,876 --> 00:07:05,986
this work every frame, it


190
00:07:05,986 --> 00:07:08,856
actually at some point limits


191
00:07:08,856 --> 00:07:09,966
the amount of objects that you


192
00:07:09,966 --> 00:07:13,656
can put on the screen.


193
00:07:13,656 --> 00:07:16,966
With argument buffers we decided


194
00:07:16,966 --> 00:07:18,906
that we would like to extend


195
00:07:19,316 --> 00:07:21,306
this very convenient indirection


196
00:07:21,606 --> 00:07:22,866
that we have for constants to


197
00:07:22,866 --> 00:07:23,456
everything.


198
00:07:23,456 --> 00:07:25,886
So you can actually put texture


199
00:07:25,886 --> 00:07:28,046
state, samplers, pointers to


200
00:07:28,046 --> 00:07:29,536
another buffer into an argument


201
00:07:29,536 --> 00:07:31,276
buffer and this really


202
00:07:31,276 --> 00:07:33,866
simplifies your rendering


203
00:07:33,866 --> 00:07:35,486
pipeline because -- well,


204
00:07:35,486 --> 00:07:37,786
suddenly the only thing you need


205
00:07:37,786 --> 00:07:40,226
to do is set the buffer and


206
00:07:40,936 --> 00:07:41,636
draw.


207
00:07:41,846 --> 00:07:43,146
And you probably figured out


208
00:07:43,146 --> 00:07:46,026
that with this few API calls you


209
00:07:46,026 --> 00:07:46,946
can put more objects on the


210
00:07:46,946 --> 00:07:49,816
screen, and as you'll see later,


211
00:07:50,066 --> 00:07:51,526
you can do actually even better


212
00:07:51,566 --> 00:07:53,836
with argument buffers.


213
00:07:54,476 --> 00:07:55,356
So we've done a bunch of


214
00:07:55,356 --> 00:07:58,576
benchmarks and run argument


215
00:07:58,576 --> 00:07:59,976
buffers on our devices.


216
00:08:04,246 --> 00:08:05,716
And this is for example what you


217
00:08:05,716 --> 00:08:07,436
get on iPhone 7.


218
00:08:08,026 --> 00:08:10,026
While with traditional model,


219
00:08:10,356 --> 00:08:13,506
quite unsurprisingly, the cost


220
00:08:13,506 --> 00:08:16,196
of your draw call scales, with


221
00:08:16,196 --> 00:08:17,576
the amount of resources you use


222
00:08:18,076 --> 00:08:21,846
in a draw call, with argument


223
00:08:21,846 --> 00:08:24,926
buffers the cost stays pretty


224
00:08:24,926 --> 00:08:26,566
low and almost flat.


225
00:08:26,566 --> 00:08:29,806
So this already shows that for


226
00:08:29,806 --> 00:08:31,276
example with a very simple


227
00:08:31,276 --> 00:08:33,326
shader, with just two resources,


228
00:08:33,326 --> 00:08:35,785
with texture and a buffer, or


229
00:08:35,936 --> 00:08:37,616
two textures, you're getting


230
00:08:37,616 --> 00:08:39,366
seven times the performance


231
00:08:39,366 --> 00:08:39,966
improvement.


232
00:08:39,966 --> 00:08:42,015
With eight textures or eight


233
00:08:42,015 --> 00:08:45,076
resources, however you want to


234
00:08:45,076 --> 00:08:47,116
mix it up, you are getting 18


235
00:08:47,116 --> 00:08:48,826
times performance improvement on


236
00:08:48,826 --> 00:08:50,796
iPhone 7 and it goes even better


237
00:08:50,796 --> 00:08:52,516
with 16 resources, obviously.


238
00:08:55,036 --> 00:08:57,946
So I already talked about the


239
00:08:57,946 --> 00:08:58,726
performance.


240
00:08:58,806 --> 00:09:01,146
I hinted toward a new use -- new


241
00:09:01,146 --> 00:09:01,736
use schedules.


242
00:09:01,736 --> 00:09:04,316
And we'll talk about this in a


243
00:09:04,316 --> 00:09:04,696
minute.


244
00:09:04,886 --> 00:09:06,286
And the last point -- the last


245
00:09:06,286 --> 00:09:07,986
benefit of argument buffers I


246
00:09:07,986 --> 00:09:09,446
would like to bring up is the


247
00:09:09,446 --> 00:09:10,206
ease of use.


248
00:09:10,806 --> 00:09:13,686
And it comes from the fact that


249
00:09:13,686 --> 00:09:15,376
argument buffers are ultimately


250
00:09:15,536 --> 00:09:16,516
an extension of buffers.


251
00:09:16,516 --> 00:09:17,796
So you can, for example go ahead


252
00:09:17,796 --> 00:09:19,246
and prepare them ahead of the


253
00:09:19,246 --> 00:09:20,936
time, let's say when your game


254
00:09:20,936 --> 00:09:23,246
is loading, and then don't have


255
00:09:23,296 --> 00:09:25,056
to worry about it anymore during


256
00:09:25,056 --> 00:09:26,216
your rendering loop, further


257
00:09:26,386 --> 00:09:27,676
improving your performance.


258
00:09:28,616 --> 00:09:30,186
Or you can mix them with a


259
00:09:30,186 --> 00:09:31,446
traditional binding model, for


260
00:09:31,446 --> 00:09:33,696
example even within a single


261
00:09:33,896 --> 00:09:36,206
draw call, which means that your


262
00:09:36,206 --> 00:09:38,006
adoption can be as simple as


263
00:09:38,196 --> 00:09:39,576
using our new tools to figure


264
00:09:39,576 --> 00:09:40,816
out what is your most expensive


265
00:09:41,086 --> 00:09:43,456
loop in our application and


266
00:09:43,456 --> 00:09:44,776
optimizing that and then maybe


267
00:09:44,776 --> 00:09:46,476
return to the rest in a year


268
00:09:46,736 --> 00:09:49,446
when you have time.


269
00:09:49,576 --> 00:09:52,766
And lastly, the argument buffers


270
00:09:52,766 --> 00:09:55,076
are supported across all Metal


271
00:09:55,076 --> 00:09:55,616
devices.


272
00:09:55,616 --> 00:09:57,816
So once you take this adoption


273
00:09:57,816 --> 00:09:59,196
step and you get all the


274
00:09:59,196 --> 00:10:00,786
performance you can keep using


275
00:10:00,786 --> 00:10:02,386
it on all Metal devices.


276
00:10:02,816 --> 00:10:03,906
The ease of use actually


277
00:10:03,906 --> 00:10:05,626
translates really well to the


278
00:10:05,626 --> 00:10:06,256
shaders.


279
00:10:06,256 --> 00:10:07,666
And since we will be looking at


280
00:10:07,666 --> 00:10:10,506
the shaders quite a bit during


281
00:10:10,506 --> 00:10:12,406
this section -- this is an


282
00:10:12,406 --> 00:10:14,636
example of the material I gave


283
00:10:14,636 --> 00:10:15,506
you in the beginning.


284
00:10:16,496 --> 00:10:19,096
And as you can see, the textures


285
00:10:19,096 --> 00:10:21,426
in the sampler are part of the


286
00:10:21,426 --> 00:10:23,196
structure, and that's the main


287
00:10:23,196 --> 00:10:24,576
thing to take away from this is


288
00:10:25,126 --> 00:10:28,406
that your argument buffer is


289
00:10:28,436 --> 00:10:29,806
just a structure in a shader and


290
00:10:29,806 --> 00:10:31,156
you can use all the language


291
00:10:31,516 --> 00:10:32,836
that you have at your disposal


292
00:10:32,836 --> 00:10:35,096
to make embedded structures, to


293
00:10:35,096 --> 00:10:38,686
organize your data, or use erase


294
00:10:38,686 --> 00:10:39,386
or pointers.


295
00:10:39,596 --> 00:10:40,806
It just really works.


296
00:10:42,046 --> 00:10:44,306
So let's now look at the three


297
00:10:44,596 --> 00:10:46,046
main new features of argument


298
00:10:46,046 --> 00:10:47,426
buffers, the first one being


299
00:10:47,516 --> 00:10:48,736
dynamic indexing.


300
00:10:50,106 --> 00:10:53,176
And great example of it is crowd


301
00:10:53,176 --> 00:10:53,656
rendering.


302
00:10:53,656 --> 00:10:55,886
If you played some of the recent


303
00:10:55,886 --> 00:10:57,266
Open World games you've seen


304
00:10:57,266 --> 00:11:00,516
that games try to render large


305
00:11:00,516 --> 00:11:02,336
crowds full of unique, varying


306
00:11:02,816 --> 00:11:04,856
characters in order to make


307
00:11:04,856 --> 00:11:07,376
these beautiful, immersive


308
00:11:07,436 --> 00:11:07,996
worlds.


309
00:11:08,526 --> 00:11:09,946
Well, actually that's quite a


310
00:11:09,946 --> 00:11:12,076
costly thing to do if you need


311
00:11:12,076 --> 00:11:13,556
to create so many draw calls.


312
00:11:14,906 --> 00:11:16,756
With argument buffers we already


313
00:11:16,756 --> 00:11:19,246
said that we could put all the


314
00:11:19,246 --> 00:11:20,706
properties required for let's


315
00:11:20,706 --> 00:11:21,926
say a character into a single


316
00:11:21,926 --> 00:11:23,836
argument buffer, bind it, and


317
00:11:23,836 --> 00:11:25,396
save all that performance on the


318
00:11:25,396 --> 00:11:27,516
CPU, but actually we can do


319
00:11:27,516 --> 00:11:27,796
better.


320
00:11:27,796 --> 00:11:30,076
We can for example create an


321
00:11:30,246 --> 00:11:32,026
array of argument buffers where


322
00:11:32,366 --> 00:11:35,096
each element represents single


323
00:11:35,096 --> 00:11:35,556
character.


324
00:11:36,136 --> 00:11:37,306
And then it suddenly becomes


325
00:11:37,306 --> 00:11:38,526
very, very simple because what


326
00:11:38,526 --> 00:11:40,676
you need to do is set this big


327
00:11:40,676 --> 00:11:43,836
buffer, this one API call, issue


328
00:11:43,956 --> 00:11:45,876
single instance draw call, let's


329
00:11:45,876 --> 00:11:47,476
say with 1,000 instances because


330
00:11:47,476 --> 00:11:48,956
I would like 1,000 characters on


331
00:11:48,956 --> 00:11:49,326
screen.


332
00:11:49,926 --> 00:11:51,026
That's second API call.


333
00:11:51,086 --> 00:11:53,456
And after that it's all on the


334
00:11:53,456 --> 00:11:54,006
GPU.


335
00:11:54,006 --> 00:11:55,406
In a vertex shader you use


336
00:11:55,406 --> 00:11:57,256
instance ID to pick the right


337
00:11:57,256 --> 00:12:00,756
element from the array, get the


338
00:12:00,756 --> 00:12:02,086
character, put it somewhere


339
00:12:02,086 --> 00:12:02,866
where it needs to be in the


340
00:12:02,866 --> 00:12:04,326
world, give it the right pose,


341
00:12:04,326 --> 00:12:05,486
if it's for example mid-walk


342
00:12:05,486 --> 00:12:07,596
cycle, and then in the fragment


343
00:12:07,596 --> 00:12:10,006
shader again you use the


344
00:12:10,006 --> 00:12:11,976
instance ID and pick the right


345
00:12:11,976 --> 00:12:13,336
materials, the right hair color


346
00:12:13,336 --> 00:12:14,266
to finalize the look.


347
00:12:14,546 --> 00:12:16,886
So we are suddenly getting from


348
00:12:17,406 --> 00:12:19,746
tens, hundreds, maybe thousands


349
00:12:19,746 --> 00:12:22,146
of draw calls to a single one.


350
00:12:22,426 --> 00:12:24,246
And it's faster on the CPU.


351
00:12:24,246 --> 00:12:25,256
It's faster on the GPU.


352
00:12:25,866 --> 00:12:29,296
And this is how simple it looks


353
00:12:29,296 --> 00:12:29,866
in a shader.


354
00:12:30,996 --> 00:12:32,896
Pretty much your argument buffer


355
00:12:32,896 --> 00:12:35,966
becomes an array of structures.


356
00:12:36,796 --> 00:12:39,976
You pick the right element using


357
00:12:39,976 --> 00:12:41,336
instance ID referenced within


358
00:12:41,336 --> 00:12:42,686
and you can, for example take


359
00:12:42,686 --> 00:12:44,356
the pointer and pass it to your


360
00:12:44,356 --> 00:12:45,856
helper methods or whatever you


361
00:12:45,856 --> 00:12:47,076
need to do to process data.


362
00:12:48,756 --> 00:12:51,326
The second great feature of


363
00:12:51,366 --> 00:12:53,156
argument buffers is the ability


364
00:12:53,636 --> 00:12:56,276
of the GPU to set resources.


365
00:12:56,276 --> 00:12:57,486
And we actually created an


366
00:12:57,486 --> 00:12:58,376
example for this.


367
00:12:59,316 --> 00:13:01,416
We created a particle simulation


368
00:13:01,416 --> 00:13:03,706
running completely on the GPU.


369
00:13:04,296 --> 00:13:05,866
And I'll tell you how we done


370
00:13:05,866 --> 00:13:08,046
that and we'll see the -- we'll


371
00:13:08,046 --> 00:13:09,326
see it in action later.


372
00:13:10,086 --> 00:13:11,666
So we created an array of


373
00:13:11,926 --> 00:13:13,156
argument buffers where each


374
00:13:13,196 --> 00:13:16,126
element is single particle --


375
00:13:16,126 --> 00:13:17,586
and I guess you already spotted


376
00:13:17,586 --> 00:13:18,926
a trend here.


377
00:13:19,596 --> 00:13:23,546
Our simulation kernel then


378
00:13:24,426 --> 00:13:26,526
treats and simulates one


379
00:13:26,526 --> 00:13:28,616
particle per thread, but we want


380
00:13:28,616 --> 00:13:29,806
to actually go further and we


381
00:13:29,806 --> 00:13:32,736
want it to be able to create the


382
00:13:32,736 --> 00:13:36,236
particles in the kernel as well,


383
00:13:36,236 --> 00:13:36,846
on the GPU.


384
00:13:36,846 --> 00:13:38,936
So in order to do that, and to


385
00:13:38,936 --> 00:13:41,136
give it the right materials, we


386
00:13:41,136 --> 00:13:42,856
also have argument buffer with


387
00:13:42,896 --> 00:13:44,516
all the different materials that


388
00:13:44,516 --> 00:13:45,636
we would like our particles to


389
00:13:45,636 --> 00:13:46,006
have.


390
00:13:46,736 --> 00:13:48,716
And our simulation kernel then,


391
00:13:49,216 --> 00:13:50,696
every time you do an action in


392
00:13:50,976 --> 00:13:53,646
our little demo, the simulation


393
00:13:53,646 --> 00:13:54,606
kernel looks into the


394
00:13:54,606 --> 00:13:56,906
environment and sees what's the


395
00:13:57,646 --> 00:13:59,276
correct, most appropriate


396
00:13:59,276 --> 00:13:59,736
material.


397
00:13:59,836 --> 00:14:01,426
And let's say if you are in the


398
00:14:01,426 --> 00:14:03,956
forest, we pick moss as the


399
00:14:04,116 --> 00:14:05,616
right, appropriate material for


400
00:14:05,616 --> 00:14:08,666
a rock and copy it to the


401
00:14:08,956 --> 00:14:09,966
particle itself.


402
00:14:10,746 --> 00:14:13,056
If you're on the rocks we pick


403
00:14:13,056 --> 00:14:13,936
the rock material.


404
00:14:13,936 --> 00:14:15,776
On the hill we pick grass.


405
00:14:16,656 --> 00:14:18,366
So this way everything stays on


406
00:14:18,366 --> 00:14:22,626
the GPU and it actually looks in


407
00:14:22,626 --> 00:14:23,926
the shader just as simple as I


408
00:14:24,006 --> 00:14:24,776
describe it.


409
00:14:25,166 --> 00:14:26,586
If you want to modify data on


410
00:14:26,586 --> 00:14:29,986
your GPU you bind it as a device


411
00:14:29,986 --> 00:14:31,316
buffer and start assigning


412
00:14:31,316 --> 00:14:33,696
values as you are used to, but


413
00:14:33,696 --> 00:14:34,816
also this time around you can


414
00:14:34,816 --> 00:14:36,956
copy textures or copy the whole


415
00:14:36,956 --> 00:14:38,496
structure and it's really this


416
00:14:38,496 --> 00:14:38,796
simple.


417
00:14:39,936 --> 00:14:42,166
And the last great feature I


418
00:14:42,166 --> 00:14:44,406
would like to mention is ability


419
00:14:44,406 --> 00:14:46,946
of argument buffers to reference


420
00:14:46,946 --> 00:14:47,956
another argument buffer.


421
00:14:47,956 --> 00:14:49,936
So this way you can actually go


422
00:14:49,936 --> 00:14:52,776
ahead and create a reusable and


423
00:14:52,856 --> 00:14:55,636
complex object hierarchy just as


424
00:14:55,636 --> 00:14:58,906
you are used to from C++ Swift,


425
00:14:59,126 --> 00:14:59,876
Objective-C.


426
00:15:01,696 --> 00:15:03,516
Let's say in the example of our


427
00:15:04,196 --> 00:15:06,386
renderer, if you have a ton of


428
00:15:06,386 --> 00:15:08,906
objects, but you probably have


429
00:15:09,566 --> 00:15:10,866
very few materials, so what you


430
00:15:10,866 --> 00:15:14,386
can do is reference the material


431
00:15:14,386 --> 00:15:15,696
from each object and save some


432
00:15:15,696 --> 00:15:18,166
memory or you can build your


433
00:15:18,166 --> 00:15:19,556
scene graph as a binary tree


434
00:15:19,556 --> 00:15:21,396
where actually you point to the


435
00:15:21,396 --> 00:15:25,016
objects and the tree nodes as


436
00:15:25,016 --> 00:15:26,266
you need them, as you would be


437
00:15:26,266 --> 00:15:27,356
used to from the CPU.


438
00:15:27,746 --> 00:15:29,226
And you can share this data with


439
00:15:29,226 --> 00:15:29,916
the CPU as well.


440
00:15:31,386 --> 00:15:32,676
So these are the main features.


441
00:15:32,676 --> 00:15:34,366
And let's look at the support


442
00:15:34,366 --> 00:15:34,846
matrix.


443
00:15:35,426 --> 00:15:36,856
We have two tiers.


444
00:15:37,096 --> 00:15:39,626
The tier one is supported across


445
00:15:39,626 --> 00:15:42,296
all Metal devices and you get


446
00:15:42,296 --> 00:15:43,216
the CPU performance


447
00:15:43,216 --> 00:15:43,756
improvements.


448
00:15:43,756 --> 00:15:44,696
You get the new schedule


449
00:15:44,696 --> 00:15:45,106
language.


450
00:15:45,596 --> 00:15:48,926
But because of the limitations


451
00:15:48,926 --> 00:15:52,126
of the GPUs this tier does not


452
00:15:52,706 --> 00:15:54,346
-- is not able to utilize the


453
00:15:54,846 --> 00:15:56,316
GPU driven use cases that I


454
00:15:56,316 --> 00:15:57,176
mentioned earlier.


455
00:15:57,606 --> 00:15:58,746
With tier two however you are


456
00:15:58,746 --> 00:16:00,416
getting all of this -- so you


457
00:16:00,416 --> 00:16:02,226
get all the new use cases -- and


458
00:16:02,226 --> 00:16:03,946
we are also really increasing


459
00:16:03,946 --> 00:16:05,566
the amount of resources you can


460
00:16:05,566 --> 00:16:06,006
access.


461
00:16:06,006 --> 00:16:07,236
Your shaders can access half a


462
00:16:07,286 --> 00:16:10,236
million textures and buffers to


463
00:16:10,236 --> 00:16:11,516
-- for you to do this -- do


464
00:16:11,516 --> 00:16:12,626
these new algorithms.


465
00:16:13,616 --> 00:16:15,526
While tier one is supported on


466
00:16:15,686 --> 00:16:18,346
all Metal devices, tier two is


467
00:16:18,346 --> 00:16:19,656
something you need to query for.


468
00:16:20,136 --> 00:16:22,046
But don't worry, the support is


469
00:16:22,046 --> 00:16:22,686
really wide.


470
00:16:23,386 --> 00:16:24,646
All the Macs with these three


471
00:16:24,646 --> 00:16:25,996
GPUs are tier two.


472
00:16:26,456 --> 00:16:28,276
All the new MacBook Pros, the


473
00:16:28,276 --> 00:16:29,506
latest MacBook, the last tier


474
00:16:29,506 --> 00:16:31,426
MacBooks Pros are tier two.


475
00:16:31,426 --> 00:16:32,896
So you can go ahead and have


476
00:16:32,896 --> 00:16:33,156
fun.


477
00:16:33,936 --> 00:16:35,376
Now let's look at the demo I


478
00:16:35,376 --> 00:16:35,966
promised you.


479
00:16:36,056 --> 00:16:38,946
We will be showing three videos


480
00:16:39,256 --> 00:16:41,236
with three different features.


481
00:16:41,816 --> 00:16:43,766
The real time rendered terrain,


482
00:16:43,966 --> 00:16:45,676
with material that changes


483
00:16:45,676 --> 00:16:48,176
dynamically, we place some


484
00:16:48,176 --> 00:16:50,436
vegetation by the GPU on the


485
00:16:50,436 --> 00:16:51,546
terrain to make it interesting,


486
00:16:51,946 --> 00:16:53,136
and we have all these nice


487
00:16:53,136 --> 00:16:55,906
particles that I mentioned


488
00:16:55,906 --> 00:16:56,276
before.


489
00:16:56,546 --> 00:16:59,346
So, as you see, we are painting


490
00:16:59,836 --> 00:17:01,076
high on the terrain.


491
00:17:01,076 --> 00:17:02,326
We can changing sculpting the


492
00:17:02,326 --> 00:17:03,296
terrain and the material


493
00:17:03,296 --> 00:17:04,165
actually follows.


494
00:17:04,455 --> 00:17:05,626
And this is a great thing about


495
00:17:05,626 --> 00:17:08,256
argument buffers because they


496
00:17:08,256 --> 00:17:10,796
allowed us to create a one big


497
00:17:11,496 --> 00:17:13,256
argument buffer with all the


498
00:17:13,256 --> 00:17:16,236
possible materials as layers in


499
00:17:16,236 --> 00:17:18,276
there and when we are rendering


500
00:17:18,276 --> 00:17:20,406
the terrain in a pixel shader we


501
00:17:20,406 --> 00:17:21,566
are looking at things like


502
00:17:21,906 --> 00:17:24,776
terrain height, slope, the


503
00:17:24,945 --> 00:17:27,236
amount of sun that reaches


504
00:17:27,435 --> 00:17:28,996
certain pixels, and based on


505
00:17:28,996 --> 00:17:30,806
these properties and some others


506
00:17:30,806 --> 00:17:33,696
we do decide what are the best


507
00:17:33,856 --> 00:17:35,276
and most appropriate materials


508
00:17:35,276 --> 00:17:36,306
for that given pixel.


509
00:17:36,736 --> 00:17:37,876
And this is all happening in


510
00:17:37,876 --> 00:17:40,576
real time, whereas previously we


511
00:17:40,576 --> 00:17:42,266
would have to go ahead and split


512
00:17:42,266 --> 00:17:44,176
the terrain in small pieces


513
00:17:44,586 --> 00:17:47,316
offline, analyze which pieces


514
00:17:47,316 --> 00:17:49,036
need which textures in order to


515
00:17:49,036 --> 00:17:50,516
make it as optimal as possible,


516
00:17:51,066 --> 00:17:52,986
and only then render it.


517
00:17:52,986 --> 00:17:55,216
So we are going from a


518
00:17:55,286 --> 00:17:56,366
pre-processing step, which is


519
00:17:56,366 --> 00:17:58,196
heavy and prevents real time


520
00:17:58,196 --> 00:18:00,326
modification, to something that


521
00:18:00,326 --> 00:18:02,016
is real time, without -- sorry


522
00:18:02,106 --> 00:18:04,556
-- without preprocessing and


523
00:18:04,556 --> 00:18:05,456
completely dynamic.


524
00:18:08,806 --> 00:18:11,816
And we added vegetation on it


525
00:18:12,116 --> 00:18:13,896
and as you see the vegetation is


526
00:18:13,896 --> 00:18:16,026
also context sensitive.


527
00:18:16,856 --> 00:18:18,596
You see the palm trees on the


528
00:18:18,596 --> 00:18:18,966
sand.


529
00:18:18,966 --> 00:18:20,646
You see the little tiny apple


530
00:18:20,646 --> 00:18:21,646
trees on the hills.


531
00:18:23,276 --> 00:18:25,366
And while the vegetation itself


532
00:18:25,366 --> 00:18:28,006
is fairly traditional instance


533
00:18:28,006 --> 00:18:29,646
rendering, the power of the


534
00:18:29,646 --> 00:18:32,216
argument buffers here is that it


535
00:18:32,216 --> 00:18:33,916
allows us to share the same


536
00:18:34,246 --> 00:18:35,836
terrain material with all the


537
00:18:35,836 --> 00:18:37,676
same properties and the same


538
00:18:37,676 --> 00:18:39,476
terrain analysis function


539
00:18:39,956 --> 00:18:41,306
between two completely separate


540
00:18:41,306 --> 00:18:43,276
pieces of code.


541
00:18:43,476 --> 00:18:45,076
While terrain rendering uses all


542
00:18:45,076 --> 00:18:47,156
this data to render pixels, the


543
00:18:47,156 --> 00:18:48,626
computer that places the


544
00:18:48,626 --> 00:18:50,146
geometry, the vegetation,


545
00:18:50,506 --> 00:18:51,786
actually analyzes the same


546
00:18:51,786 --> 00:18:53,606
materials to figure out what is


547
00:18:53,606 --> 00:18:56,096
the best type of tree to place


548
00:18:56,096 --> 00:18:56,856
in the given spot.


549
00:18:57,306 --> 00:18:58,446
And this is very easy because


550
00:18:58,446 --> 00:18:59,656
every time we make a change


551
00:18:59,996 --> 00:19:01,396
nothing actually changes in our


552
00:19:01,396 --> 00:19:02,526
code because we just add new


553
00:19:02,526 --> 00:19:04,346
layers or change our analysis


554
00:19:04,346 --> 00:19:06,636
function, whereas previously we


555
00:19:06,636 --> 00:19:08,346
would have to maybe juggle 70


556
00:19:08,346 --> 00:19:10,066
textures between two completely


557
00:19:10,066 --> 00:19:11,646
separate code basis in order to


558
00:19:11,646 --> 00:19:16,866
make them run in sync.


559
00:19:17,046 --> 00:19:19,236
Lastly, we have the particles.


560
00:19:19,236 --> 00:19:22,066
I hope you can see that they


561
00:19:22,066 --> 00:19:24,976
nicely get the material of the


562
00:19:24,976 --> 00:19:25,746
terrain there.


563
00:19:26,706 --> 00:19:28,436
Now what I did not mention is


564
00:19:28,436 --> 00:19:30,696
that this all is rendered with


565
00:19:30,956 --> 00:19:32,636
again a single draw call.


566
00:19:32,636 --> 00:19:34,586
We are rendering 16,000


567
00:19:34,926 --> 00:19:37,836
particles here with single draw


568
00:19:37,836 --> 00:19:39,466
call, with absolutely no


569
00:19:39,646 --> 00:19:41,416
involvement on the CPU.


570
00:19:42,236 --> 00:19:44,316
And not only do particles have


571
00:19:44,656 --> 00:19:46,146
unique materials, they actually


572
00:19:46,146 --> 00:19:47,326
have unique shapes because


573
00:19:47,606 --> 00:19:48,766
argument buffers allow --


574
00:19:48,766 --> 00:19:50,006
actually allow you to change


575
00:19:50,006 --> 00:19:51,996
your vertex buffer per draw


576
00:19:51,996 --> 00:19:52,246
call.


577
00:19:53,356 --> 00:19:55,916
This is something where if you


578
00:19:55,916 --> 00:19:58,296
try to do that without argument


579
00:19:58,296 --> 00:20:01,786
buffers, we had to create a


580
00:20:01,786 --> 00:20:04,326
complicated control hand over


581
00:20:04,326 --> 00:20:06,686
between GPU that simulates and


582
00:20:06,686 --> 00:20:07,866
the CPU that tries to come up


583
00:20:07,866 --> 00:20:09,686
with the best set of draw calls


584
00:20:09,686 --> 00:20:11,186
to represent all this variety.


585
00:20:11,606 --> 00:20:13,226
So with argument buffers this


586
00:20:13,226 --> 00:20:16,976
became just very, very simple.


587
00:20:18,176 --> 00:20:21,536
Okay, so enough pretty pictures.


588
00:20:22,146 --> 00:20:25,056
And let's wrap my portion of the


589
00:20:25,056 --> 00:20:28,236
session with a look at some APIs


590
00:20:28,236 --> 00:20:29,546
and some best practices.


591
00:20:29,836 --> 00:20:33,256
As I mentioned before, argument


592
00:20:33,256 --> 00:20:34,756
buffers are an extension of


593
00:20:34,756 --> 00:20:37,246
Metal buffers and that means all


594
00:20:37,246 --> 00:20:39,116
of our API related to buffers


595
00:20:39,116 --> 00:20:39,606
just works.


596
00:20:39,606 --> 00:20:40,776
You can go ahead and take


597
00:20:40,776 --> 00:20:42,026
argument buffer, copy it


598
00:20:42,026 --> 00:20:43,286
somewhere else; you can blitz it


599
00:20:43,286 --> 00:20:44,816
between CPU and GPU.


600
00:20:45,626 --> 00:20:47,936
And while argument buffers look


601
00:20:47,936 --> 00:20:51,096
like structures on the GPU for


602
00:20:51,096 --> 00:20:54,626
shaders, on the CPU you will use


603
00:20:54,626 --> 00:20:56,646
MTLArgumentEncoder objects to


604
00:20:56,646 --> 00:20:57,546
fill up the content.


605
00:20:58,506 --> 00:21:02,026
This abstraction allows Metal to


606
00:21:02,026 --> 00:21:04,526
create the most optimal memory


607
00:21:05,016 --> 00:21:06,496
representation for any given


608
00:21:06,496 --> 00:21:08,026
argument buffer on that specific


609
00:21:08,026 --> 00:21:09,206
GPU that you are actually


610
00:21:09,206 --> 00:21:09,536
running.


611
00:21:10,026 --> 00:21:11,326
So you get the best performance.


612
00:21:11,726 --> 00:21:13,106
It also frees you, as the


613
00:21:13,106 --> 00:21:14,526
developer, from all these


614
00:21:15,476 --> 00:21:19,776
details and worries about, for


615
00:21:19,776 --> 00:21:21,786
example how each GPU represents


616
00:21:21,926 --> 00:21:22,796
what the texture is.


617
00:21:22,796 --> 00:21:23,816
Where does it live in memory?


618
00:21:24,436 --> 00:21:26,576
All of this changes from


619
00:21:26,716 --> 00:21:28,606
platform to platform and we hide


620
00:21:28,606 --> 00:21:31,186
it between a simple interface so


621
00:21:31,186 --> 00:21:32,446
that you can write very simple


622
00:21:32,446 --> 00:21:33,656
and effective applications.


623
00:21:34,346 --> 00:21:36,936
So I hope you're not worried


624
00:21:36,936 --> 00:21:37,836
about the encoder that I


625
00:21:37,836 --> 00:21:38,196
mentioned.


626
00:21:38,196 --> 00:21:39,716
It's really, really simple to


627
00:21:39,716 --> 00:21:40,116
use.


628
00:21:41,176 --> 00:21:42,156
For example, if you want to


629
00:21:42,156 --> 00:21:43,686
create an argument encoder for


630
00:21:43,686 --> 00:21:46,216
this argument buffer all you


631
00:21:46,216 --> 00:21:49,716
need to do is get your Metal


632
00:21:49,716 --> 00:21:51,216
function that uses the argument


633
00:21:51,216 --> 00:21:53,566
buffer and ask the Metal


634
00:21:53,566 --> 00:21:55,216
function for the encoder and


635
00:21:55,216 --> 00:21:55,946
that's about this.


636
00:21:55,946 --> 00:21:57,216
This is all you needed to do.


637
00:21:57,216 --> 00:21:59,356
You get an object and you start


638
00:21:59,356 --> 00:22:01,896
using a familiar set texture or


639
00:22:02,286 --> 00:22:04,416
filling constant API that is


640
00:22:04,416 --> 00:22:05,746
very, very similar to how you've


641
00:22:05,746 --> 00:22:08,496
been using Metal with command


642
00:22:08,496 --> 00:22:08,846
encoder.


643
00:22:08,846 --> 00:22:11,746
So this also plays into what I


644
00:22:11,746 --> 00:22:14,946
said about ease of use and


645
00:22:14,946 --> 00:22:15,676
transition.


646
00:22:16,686 --> 00:22:18,566
There are multiple other ways of


647
00:22:18,566 --> 00:22:20,326
creating the encoder.


648
00:22:20,326 --> 00:22:21,616
You can go more explicit with


649
00:22:21,616 --> 00:22:22,516
the descriptor, but that's


650
00:22:22,516 --> 00:22:24,526
something you should look into


651
00:22:24,726 --> 00:22:25,866
in documentation if you need


652
00:22:25,866 --> 00:22:26,506
such thing.


653
00:22:26,706 --> 00:22:28,786
We advise you to actually go and


654
00:22:29,396 --> 00:22:30,696
get argument encoders from the


655
00:22:30,696 --> 00:22:31,206
shaders.


656
00:22:33,676 --> 00:22:36,496
Now with all those interactions,


657
00:22:36,496 --> 00:22:38,226
GPU being able to step in and


658
00:22:38,226 --> 00:22:40,266
modify the argument buffers or


659
00:22:40,866 --> 00:22:42,116
you know dynamic indexing and


660
00:22:42,116 --> 00:22:44,186
half a million textures, all


661
00:22:44,186 --> 00:22:47,346
that in a mix, it's not really


662
00:22:47,736 --> 00:22:49,196
possible for Metal to figure out


663
00:22:49,196 --> 00:22:50,296
what -- for example what


664
00:22:50,296 --> 00:22:52,046
textures or buffers do actually


665
00:22:52,046 --> 00:22:55,226
intend to use in your rendering,


666
00:22:55,226 --> 00:22:56,836
but luckily you as a developer


667
00:22:56,836 --> 00:22:58,746
have pretty good idea about


668
00:22:58,746 --> 00:22:58,956
that.


669
00:22:58,956 --> 00:23:01,106
So we ask you with argument


670
00:23:01,106 --> 00:23:02,546
buffers to be quite explicit


671
00:23:02,546 --> 00:23:02,896
about it.


672
00:23:04,096 --> 00:23:05,606
If you are using Heaps, and


673
00:23:06,476 --> 00:23:08,166
absolutely you should use Heaps


674
00:23:08,166 --> 00:23:09,726
to get the best performance out


675
00:23:09,726 --> 00:23:12,346
of your platform and the best


676
00:23:12,346 --> 00:23:13,596
way of organizing your data, the


677
00:23:14,196 --> 00:23:15,416
only thing you need to do is


678
00:23:15,416 --> 00:23:16,766
tell Metal that you intend to


679
00:23:16,766 --> 00:23:18,716
use a Heap , or multiple Heaps,


680
00:23:18,716 --> 00:23:19,646
it's up to you.


681
00:23:19,646 --> 00:23:22,176
And -- this is -- this makes


682
00:23:22,176 --> 00:23:24,026
sure that the textures are


683
00:23:24,026 --> 00:23:25,376
available for you in the


684
00:23:25,376 --> 00:23:25,966
rendering loop.


685
00:23:26,226 --> 00:23:28,896
If you want to do something more


686
00:23:28,896 --> 00:23:29,906
specific, let's say you would


687
00:23:29,906 --> 00:23:32,416
like to write to a render target


688
00:23:32,416 --> 00:23:34,386
from inside a shader, or you


689
00:23:34,386 --> 00:23:35,456
would like to read from a dev


690
00:23:35,456 --> 00:23:38,296
buffer, you use a more specific


691
00:23:38,296 --> 00:23:40,296
API and tell Metal that you


692
00:23:40,296 --> 00:23:42,306
intend to change resource and --


693
00:23:43,306 --> 00:23:44,346
with a specific way.


694
00:23:44,346 --> 00:23:45,906
And again, it's as simple as


695
00:23:45,906 --> 00:23:45,996
this.


696
00:23:45,996 --> 00:23:46,846
You don't need to do anything


697
00:23:46,846 --> 00:23:46,976
else.


698
00:23:50,336 --> 00:23:52,026
So let's start out with a couple


699
00:23:52,026 --> 00:23:52,936
of best practices.


700
00:23:52,936 --> 00:23:55,816
I think if you know Metal they


701
00:23:55,816 --> 00:23:57,906
are very, very similar to what


702
00:23:57,906 --> 00:23:59,906
we are telling you about using


703
00:23:59,906 --> 00:24:00,556
Metal buffers.


704
00:24:00,986 --> 00:24:02,416
The best way to organize your


705
00:24:02,416 --> 00:24:04,536
data is by usage pattern.


706
00:24:04,536 --> 00:24:05,686
And you probably have a ton of


707
00:24:05,686 --> 00:24:08,236
properties that do not change


708
00:24:08,516 --> 00:24:09,186
per frame.


709
00:24:09,236 --> 00:24:10,366
So put them into an argument


710
00:24:10,366 --> 00:24:11,786
buffer and share it with all the


711
00:24:11,786 --> 00:24:12,996
objects so you will save memory


712
00:24:12,996 --> 00:24:13,366
this way.


713
00:24:14,116 --> 00:24:15,906
The same -- on the same -- on


714
00:24:15,906 --> 00:24:17,586
the other hand you will probably


715
00:24:17,586 --> 00:24:19,396
have a lot of properties that


716
00:24:19,396 --> 00:24:20,926
actually do change for every


717
00:24:20,926 --> 00:24:23,326
object and you need to manage


718
00:24:23,326 --> 00:24:24,176
them every frame.


719
00:24:24,176 --> 00:24:26,776
And for these I think the best


720
00:24:26,776 --> 00:24:27,896
way is to put those into


721
00:24:27,896 --> 00:24:29,066
separate argument buffers so


722
00:24:29,066 --> 00:24:30,226
that you can double buffer it or


723
00:24:30,226 --> 00:24:31,896
whatever is your management


724
00:24:31,896 --> 00:24:34,636
scheme and you don't need to do


725
00:24:34,636 --> 00:24:36,406
all the other copies to keep all


726
00:24:36,406 --> 00:24:37,086
the data in there.


727
00:24:37,536 --> 00:24:39,016
And then you will likely have a


728
00:24:39,016 --> 00:24:41,106
ton of argument buffers that


729
00:24:41,616 --> 00:24:43,116
just don't change at all.


730
00:24:43,116 --> 00:24:44,276
Let's say the materials, or


731
00:24:44,856 --> 00:24:46,636
maybe some other properties, and


732
00:24:46,786 --> 00:24:49,126
for these just create them at


733
00:24:49,126 --> 00:24:50,126
the initialization of your


734
00:24:50,126 --> 00:24:53,636
application and keep using them.


735
00:24:53,846 --> 00:24:57,406
Similar to Metal buffers, think


736
00:24:57,406 --> 00:24:59,646
about your data locality and how


737
00:24:59,646 --> 00:25:01,396
you actually use your argument


738
00:25:01,396 --> 00:25:01,746
buffers.


739
00:25:02,076 --> 00:25:03,636
If, for example you have three


740
00:25:03,636 --> 00:25:05,906
textures that are accessed in a


741
00:25:05,906 --> 00:25:08,606
shader, one after another, then


742
00:25:09,136 --> 00:25:10,666
the best thing you can do is


743
00:25:10,666 --> 00:25:11,876
actually put those textures


744
00:25:11,876 --> 00:25:13,056
close to each other in argument


745
00:25:13,056 --> 00:25:14,406
buffers so that you maximize the


746
00:25:14,406 --> 00:25:16,296
use of GPU caches.


747
00:25:17,206 --> 00:25:17,976
And as I mentioned at the


748
00:25:17,976 --> 00:25:20,566
beginning, traditional argument


749
00:25:20,566 --> 00:25:23,536
model is not going anywhere and


750
00:25:23,536 --> 00:25:25,406
you should take advantage of it


751
00:25:25,406 --> 00:25:26,606
and mix it with the argument


752
00:25:26,606 --> 00:25:27,936
buffers whenever it's more


753
00:25:27,936 --> 00:25:28,616
convenient.


754
00:25:29,136 --> 00:25:30,456
So let's say if you need to


755
00:25:30,456 --> 00:25:32,086
change a single texture for


756
00:25:33,216 --> 00:25:35,616
every object, for example a cube


757
00:25:35,616 --> 00:25:37,446
reflection, it probably would be


758
00:25:37,446 --> 00:25:38,616
an overhead to create argument


759
00:25:38,616 --> 00:25:39,926
buffer just for that and upload


760
00:25:39,926 --> 00:25:40,726
it every frame.


761
00:25:40,726 --> 00:25:42,646
So just use the traditional


762
00:25:42,646 --> 00:25:43,356
model for this.


763
00:25:43,496 --> 00:25:46,046
That's it about argument


764
00:25:46,046 --> 00:25:46,406
buffers.


765
00:25:46,406 --> 00:25:50,086
I really hope you will adopt our


766
00:25:50,086 --> 00:25:52,356
new API and get some creative


767
00:25:52,636 --> 00:25:53,446
use cases out of it.


768
00:25:53,966 --> 00:25:57,286
And please welcome Richard, who


769
00:25:57,396 --> 00:25:58,976
will talk about the Raster Order


770
00:25:58,976 --> 00:25:59,336
Groups.


771
00:26:00,516 --> 00:26:02,436
[ Applause ]


772
00:26:02,436 --> 00:26:02,856
>> Thank you.


773
00:26:04,866 --> 00:26:06,536
Hello. So thank you Michal.


774
00:26:06,656 --> 00:26:07,606
So I'm going to take you through


775
00:26:07,606 --> 00:26:08,266
the rest of the day's


776
00:26:08,266 --> 00:26:09,836
presentation, starting with


777
00:26:09,876 --> 00:26:10,766
Raster Order Groups.


778
00:26:12,316 --> 00:26:14,016
So this is a new feature that


779
00:26:14,016 --> 00:26:16,486
gives you control over the GPU's


780
00:26:16,556 --> 00:26:17,696
thread scheduling to run


781
00:26:18,026 --> 00:26:19,516
fragment shooter threads, in


782
00:26:19,576 --> 00:26:19,916
order.


783
00:26:20,516 --> 00:26:21,926
This allows overlapping fragment


784
00:26:21,926 --> 00:26:23,096
shooter threads to communicate


785
00:26:23,156 --> 00:26:24,706
through memory, where before it


786
00:26:24,706 --> 00:26:27,226
wasn't always really possible to


787
00:26:27,226 --> 00:26:28,106
do in most cases.


788
00:26:28,486 --> 00:26:30,076
So this opens up a whole new set


789
00:26:30,076 --> 00:26:31,086
of graphics algorithms that were


790
00:26:31,086 --> 00:26:32,796
not practically achievable with


791
00:26:32,986 --> 00:26:34,036
just write only access to your


792
00:26:34,036 --> 00:26:36,026
frame buffers or onward access


793
00:26:36,026 --> 00:26:37,046
memory to device memory.


794
00:26:38,296 --> 00:26:40,826
For example, one of our key --


795
00:26:40,826 --> 00:26:41,996
one of the key applications for


796
00:26:41,996 --> 00:26:42,986
this is Order-independent


797
00:26:42,986 --> 00:26:43,756
transparency.


798
00:26:44,576 --> 00:26:45,936
We've been -- already talked a


799
00:26:45,936 --> 00:26:47,286
lot today about how to reduce


800
00:26:47,286 --> 00:26:48,426
the CP usage of your Metal


801
00:26:48,426 --> 00:26:50,186
application and this feature


802
00:26:50,186 --> 00:26:51,846
lets you build or an algorithm


803
00:26:52,306 --> 00:26:54,286
to include blending back to


804
00:26:54,286 --> 00:26:55,946
front without having to pay the


805
00:26:55,946 --> 00:26:57,356
CPU cost of triangle level


806
00:26:57,356 --> 00:26:57,726
sorting.


807
00:26:59,366 --> 00:27:00,566
There's also been lots of


808
00:27:00,566 --> 00:27:01,666
investigations into advanced


809
00:27:01,666 --> 00:27:03,006
techniques such as dual layer


810
00:27:03,226 --> 00:27:04,066
G-buffers, which can


811
00:27:04,066 --> 00:27:05,776
substantially improve post


812
00:27:05,776 --> 00:27:07,426
processing results, or using the


813
00:27:07,426 --> 00:27:08,696
GPU rasterizer to sort of


814
00:27:08,696 --> 00:27:10,026
voxelize triangle meshes.


815
00:27:10,886 --> 00:27:12,546
For both of these onward


816
00:27:12,546 --> 00:27:13,556
accesses to memory has been a


817
00:27:13,556 --> 00:27:15,156
really large barrier to


818
00:27:15,156 --> 00:27:16,356
efficient implementations.


819
00:27:17,126 --> 00:27:18,806
But probably the simplest and


820
00:27:18,806 --> 00:27:20,396
most common application for this


821
00:27:20,396 --> 00:27:21,666
feature is just implementing


822
00:27:21,666 --> 00:27:22,606
custom blend equations.


823
00:27:23,356 --> 00:27:24,916
iOS's hardware could always do


824
00:27:24,916 --> 00:27:27,176
this pretty natively, but this


825
00:27:27,176 --> 00:27:29,236
is not something that desktop


826
00:27:29,236 --> 00:27:30,896
hardware has traditionally been


827
00:27:30,896 --> 00:27:31,516
able to do.


828
00:27:32,496 --> 00:27:33,736
So I'm going to use custom


829
00:27:33,736 --> 00:27:34,816
blending as an example


830
00:27:34,816 --> 00:27:35,906
application to introduce this


831
00:27:35,906 --> 00:27:36,176
feature.


832
00:27:37,906 --> 00:27:39,916
Okay, so pretty typical case of


833
00:27:39,916 --> 00:27:41,146
triangle blending; one triangle


834
00:27:41,146 --> 00:27:41,666
over another.


835
00:27:42,596 --> 00:27:44,866
Pretty much all modern GPU APIs


836
00:27:44,906 --> 00:27:46,216
guarantee that blending happens


837
00:27:46,216 --> 00:27:47,256
in draw call order.


838
00:27:47,396 --> 00:27:48,686
It provides this nice,


839
00:27:48,756 --> 00:27:50,246
convenient illusion of serial


840
00:27:50,246 --> 00:27:50,776
execution.


841
00:27:51,626 --> 00:27:53,206
But of course what's really


842
00:27:53,206 --> 00:27:54,416
going on behind the scenes is


843
00:27:54,516 --> 00:27:55,846
GPU hardware's highly parallel.


844
00:27:55,846 --> 00:27:56,916
It's going to be running


845
00:27:56,916 --> 00:27:58,086
multiple threads concurrently.


846
00:27:58,666 --> 00:28:00,126
And only this fixed-function


847
00:28:00,126 --> 00:28:01,616
blend step at the end is going


848
00:28:01,616 --> 00:28:02,876
to be delayed until everything


849
00:28:02,876 --> 00:28:05,596
gets put back in order again.


850
00:28:05,596 --> 00:28:06,716
There's this implicit wait that


851
00:28:06,716 --> 00:28:08,726
happens before that blend step.


852
00:28:10,296 --> 00:28:12,516
Things change however if the


853
00:28:12,516 --> 00:28:13,446
ordering -- if we need to put


854
00:28:13,446 --> 00:28:14,596
things in order not at the end


855
00:28:14,596 --> 00:28:16,146
of our fragment shooter, but


856
00:28:16,246 --> 00:28:17,896
right in the middle because in


857
00:28:17,896 --> 00:28:19,996
this case triangle one wants to


858
00:28:19,996 --> 00:28:21,136
write something to memory that


859
00:28:21,136 --> 00:28:22,426
triangle two's threads want to


860
00:28:22,426 --> 00:28:22,856
read from.


861
00:28:23,076 --> 00:28:24,846
If we want triangle two to be


862
00:28:24,846 --> 00:28:26,066
able to build upon and consume


863
00:28:26,066 --> 00:28:27,856
triangle one's data we need to


864
00:28:27,856 --> 00:28:28,726
get that ordering back.


865
00:28:29,466 --> 00:28:32,196
And so that's pretty much what


866
00:28:32,196 --> 00:28:33,406
Raster Order Groups provides.


867
00:28:34,536 --> 00:28:36,856
So I'm going to jump over to a


868
00:28:37,036 --> 00:28:37,986
shader code example.


869
00:28:38,586 --> 00:28:40,946
So if I want to implement custom


870
00:28:40,946 --> 00:28:42,296
blending, an initial attempt


871
00:28:42,466 --> 00:28:43,896
that does not work is going to


872
00:28:44,076 --> 00:28:45,556
be to replace my classic


873
00:28:45,556 --> 00:28:46,526
graphics frame buffer with a


874
00:28:46,526 --> 00:28:47,826
read to write texture and


875
00:28:47,826 --> 00:28:49,536
perform all of my rendering and


876
00:28:49,536 --> 00:28:50,466
blending directly to this


877
00:28:50,466 --> 00:28:50,786
texture.


878
00:28:51,606 --> 00:28:53,806
But of course if the threads


879
00:28:53,806 --> 00:28:55,056
that I'm blending over have yet


880
00:28:55,056 --> 00:28:56,246
to execute, or concurrently


881
00:28:56,246 --> 00:28:58,896
executing, this is -- this whole


882
00:28:58,996 --> 00:29:00,426
remodify/write sequence is going


883
00:29:00,426 --> 00:29:01,426
to create a race condition.


884
00:29:02,706 --> 00:29:03,806
So how do we use Raster Order


885
00:29:03,806 --> 00:29:04,976
Groups to fix this?


886
00:29:05,136 --> 00:29:07,246
It's really, really easy.


887
00:29:08,456 --> 00:29:09,976
All I have to do is add a new


888
00:29:10,106 --> 00:29:12,826
attribute to the memory that has


889
00:29:12,826 --> 00:29:13,916
conflicting accesses.


890
00:29:14,716 --> 00:29:16,736
At this point the compiler and


891
00:29:16,736 --> 00:29:17,526
the hardware are going to


892
00:29:17,526 --> 00:29:18,706
cooperate to be able to


893
00:29:18,706 --> 00:29:20,446
implicitly take the entire range


894
00:29:20,696 --> 00:29:21,636
of [inaudible] shader that


895
00:29:21,636 --> 00:29:22,826
accesses that memory from the


896
00:29:22,826 --> 00:29:23,996
very first to the very last


897
00:29:23,996 --> 00:29:25,216
access and turn it into a


898
00:29:25,216 --> 00:29:26,196
critical section behind the


899
00:29:26,196 --> 00:29:26,666
scenes.


900
00:29:28,636 --> 00:29:29,656
You can also apply this


901
00:29:29,656 --> 00:29:31,126
attribute to normal device


902
00:29:31,126 --> 00:29:33,686
memory pointers, not just


903
00:29:34,376 --> 00:29:34,706
textures.


904
00:29:34,706 --> 00:29:37,446
So with that we get the thread


905
00:29:37,446 --> 00:29:38,366
schedule that we want.


906
00:29:39,046 --> 00:29:40,236
Thread one will proceed and


907
00:29:40,236 --> 00:29:41,946
write to memory and thread two


908
00:29:41,946 --> 00:29:43,356
is going to stop and wait until


909
00:29:43,356 --> 00:29:45,876
thread one's write's complete


910
00:29:45,876 --> 00:29:47,746
giving us basically race free


911
00:29:47,746 --> 00:29:50,266
access to this memory.


912
00:29:51,746 --> 00:29:52,916
Oh, there's one other really


913
00:29:52,916 --> 00:29:53,936
important topic and that's


914
00:29:53,936 --> 00:29:55,846
talking about which threads are


915
00:29:55,846 --> 00:29:57,096
synchronizing with each other.


916
00:29:57,536 --> 00:29:59,486
So of course GPU hardware's


917
00:29:59,486 --> 00:30:00,316
going to be running not just


918
00:30:00,316 --> 00:30:02,126
two, but tens of thousands of


919
00:30:02,126 --> 00:30:04,956
threads at the same time and in


920
00:30:05,066 --> 00:30:06,266
fact it's probably executing


921
00:30:06,266 --> 00:30:07,576
every single thread from both of


922
00:30:07,576 --> 00:30:08,956
these triangles simultaneously.


923
00:30:09,446 --> 00:30:11,876
So of all of these thousands --


924
00:30:11,876 --> 00:30:12,636
tens of thousands -- of threads,


925
00:30:12,636 --> 00:30:13,796
which one synchronizes with each


926
00:30:13,796 --> 00:30:13,996
other?


927
00:30:15,666 --> 00:30:17,626
So I've highlighted one pixel


928
00:30:17,626 --> 00:30:18,816
here because that's the answer


929
00:30:18,816 --> 00:30:19,416
to this question.


930
00:30:20,186 --> 00:30:21,706
You -- this feature only


931
00:30:21,706 --> 00:30:22,676
synchronizes against other


932
00:30:22,676 --> 00:30:23,806
threads that your current


933
00:30:23,806 --> 00:30:25,356
fragment shooter thread overlaps


934
00:30:25,356 --> 00:30:27,346
with, those other threads that


935
00:30:27,426 --> 00:30:28,936
are targeting the same frame


936
00:30:28,936 --> 00:30:30,976
buffer xy location, targeting


937
00:30:30,976 --> 00:30:32,716
the same multi-sample location,


938
00:30:33,026 --> 00:30:34,136
targeting the same render target


939
00:30:34,136 --> 00:30:34,616
index.


940
00:30:36,556 --> 00:30:37,606
If I wanted -- and it


941
00:30:37,606 --> 00:30:38,916
specifically does not provide


942
00:30:38,966 --> 00:30:40,586
any guarantees at all against --


943
00:30:40,586 --> 00:30:41,676
that you can safely access


944
00:30:41,676 --> 00:30:43,206
memory that are written by any


945
00:30:43,206 --> 00:30:44,106
neighboring pixels.


946
00:30:45,196 --> 00:30:46,646
If you do need to have these


947
00:30:46,646 --> 00:30:48,326
kind of area -- or region of


948
00:30:48,326 --> 00:30:49,566
influence -- kind of algorithms


949
00:30:49,926 --> 00:30:50,986
then you will need to go back to


950
00:30:50,986 --> 00:30:52,156
using full memory barriers


951
00:30:52,186 --> 00:30:53,566
between draw call -- or full API


952
00:30:53,566 --> 00:30:54,726
barriers between draw calls or


953
00:30:54,726 --> 00:30:55,496
render passes.


954
00:30:56,206 --> 00:30:57,676
But this comes at a much higher


955
00:30:57,676 --> 00:30:59,486
performance cost and it does not


956
00:30:59,486 --> 00:31:00,706
work in the case where you have


957
00:31:00,706 --> 00:31:02,066
triangle overlap within a single


958
00:31:02,066 --> 00:31:02,516
draw call.


959
00:31:02,816 --> 00:31:05,076
But for these common algorithms


960
00:31:05,116 --> 00:31:06,636
that you do have only need


961
00:31:06,636 --> 00:31:08,036
overlap only synchronization,


962
00:31:08,666 --> 00:31:09,806
Raster Order Groups can get the


963
00:31:09,806 --> 00:31:11,096
job done at a substantially


964
00:31:11,096 --> 00:31:12,786
lower performance cost.


965
00:31:13,576 --> 00:31:15,316
So this is a pretty actually


966
00:31:15,506 --> 00:31:16,546
easy one and that's really all


967
00:31:16,546 --> 00:31:17,226
I've got to say about it.


968
00:31:17,226 --> 00:31:19,376
Raster Order Groups lets you


969
00:31:19,376 --> 00:31:21,076
efficiently wait for overlapping


970
00:31:21,346 --> 00:31:23,876
and only overlapping threads to


971
00:31:23,876 --> 00:31:24,956
finish their access to memory,


972
00:31:25,636 --> 00:31:27,376
which enables a collection of GP


973
00:31:27,376 --> 00:31:28,566
algorithms that were previously


974
00:31:28,566 --> 00:31:29,856
just too inefficient to use


975
00:31:29,856 --> 00:31:31,116
practically in GPU hardware.


976
00:31:33,336 --> 00:31:35,596
This middle of shader thread


977
00:31:35,596 --> 00:31:36,906
summarization is a feature of


978
00:31:36,906 --> 00:31:38,386
the latest GPU hardware, so it


979
00:31:38,386 --> 00:31:39,116
is something you do need to


980
00:31:39,116 --> 00:31:40,256
check for at run time.


981
00:31:40,926 --> 00:31:42,276
In particular it's supported on


982
00:31:42,276 --> 00:31:43,726
the newest AMD Vega GPUs


983
00:31:43,726 --> 00:31:45,086
announced this week as well as


984
00:31:45,086 --> 00:31:46,186
the past couple years' worth of


985
00:31:46,186 --> 00:31:47,036
Intel GPUs.


986
00:31:49,046 --> 00:31:50,026
And that brings us on to our


987
00:31:50,026 --> 00:31:51,116
second feature and that is the


988
00:31:51,116 --> 00:31:52,746
new iPad Pro's ProMotion


989
00:31:52,746 --> 00:31:52,956
Display.


990
00:32:01,076 --> 00:32:02,316
So ProMotion, this is a


991
00:32:02,446 --> 00:32:03,836
particularly great feature for


992
00:32:03,836 --> 00:32:05,016
graphics and game developers and


993
00:32:05,016 --> 00:32:06,066
so I really want to show you


994
00:32:06,066 --> 00:32:07,456
what you can do with it.


995
00:32:07,806 --> 00:32:10,296
This is the first of a sequence


996
00:32:10,296 --> 00:32:11,436
of timeline diagrams I'm going


997
00:32:11,436 --> 00:32:13,896
to show you, showing us when the


998
00:32:13,896 --> 00:32:15,426
GPU starts and finishes


999
00:32:15,426 --> 00:32:16,746
producing a frame, and then when


1000
00:32:16,746 --> 00:32:17,896
that same frame finally gets


1001
00:32:17,896 --> 00:32:19,086
onto the glass for the user to


1002
00:32:19,086 --> 00:32:19,316
see.


1003
00:32:20,476 --> 00:32:21,946
The first and most obvious thing


1004
00:32:21,946 --> 00:32:23,186
that ProMotion does is we can


1005
00:32:23,186 --> 00:32:24,976
now render at 120 frames per


1006
00:32:24,976 --> 00:32:25,376
second.


1007
00:32:27,146 --> 00:32:28,726
This feels absolutely fantastic


1008
00:32:28,726 --> 00:32:29,736
for anything that has really


1009
00:32:29,736 --> 00:32:31,436
high speed animations, for


1010
00:32:31,436 --> 00:32:32,626
anything that's latency critical


1011
00:32:32,626 --> 00:32:33,926
such as tracking user touch or


1012
00:32:33,926 --> 00:32:34,586
pencil input.


1013
00:32:35,376 --> 00:32:37,706
And it does have some catches.


1014
00:32:37,706 --> 00:32:40,176
You of course only get half as


1015
00:32:40,176 --> 00:32:41,976
much CPU and GPU time available


1016
00:32:41,976 --> 00:32:43,426
per frame so you really have to


1017
00:32:43,426 --> 00:32:44,186
pay a lot of attention to


1018
00:32:44,186 --> 00:32:46,026
optimization and it does


1019
00:32:46,026 --> 00:32:47,106
increase overall system power


1020
00:32:47,106 --> 00:32:47,646
consumption.


1021
00:32:48,646 --> 00:32:49,376
But if you've got the right


1022
00:32:49,376 --> 00:32:51,336
content, where this matters, it


1023
00:32:51,336 --> 00:32:52,556
gets a really payoff for the


1024
00:32:52,556 --> 00:32:53,406
user experience.


1025
00:32:54,836 --> 00:32:56,396
But ProMotion goes a lot farther


1026
00:32:56,396 --> 00:32:57,926
than 120 frames per second


1027
00:32:57,926 --> 00:32:58,226
rendering.


1028
00:32:59,006 --> 00:33:01,466
It also provides much more


1029
00:33:01,466 --> 00:33:03,326
flexibility regarding when to


1030
00:33:03,326 --> 00:33:04,376
swap the next image onto the


1031
00:33:04,376 --> 00:33:04,846
glass.


1032
00:33:05,556 --> 00:33:07,606
We're not limited to just 120 or


1033
00:33:07,606 --> 00:33:09,726
30 or 60 frames per second.


1034
00:33:10,316 --> 00:33:12,646
ProMotion behaves much more


1035
00:33:12,646 --> 00:33:13,886
gracefully as your application's


1036
00:33:13,886 --> 00:33:15,276
performance moves up and down


1037
00:33:15,546 --> 00:33:16,586
compared to a fixed frame rate


1038
00:33:16,586 --> 00:33:16,996
display.


1039
00:33:18,206 --> 00:33:21,016
For example, here I have a


1040
00:33:21,056 --> 00:33:22,406
timeline diagram of a title


1041
00:33:22,406 --> 00:33:23,756
that, you know just -- is just


1042
00:33:23,756 --> 00:33:24,816
doing too much GPU work to


1043
00:33:24,816 --> 00:33:26,196
target 60 frames per second.


1044
00:33:26,346 --> 00:33:27,056
You know they're producing


1045
00:33:27,056 --> 00:33:28,736
frames every about 21


1046
00:33:28,736 --> 00:33:30,196
milliseconds or about 48 frames


1047
00:33:30,196 --> 00:33:30,686
per second.


1048
00:33:31,346 --> 00:33:33,296
The GPU is perfectly happy to do


1049
00:33:33,296 --> 00:33:35,366
that, but on the display side we


1050
00:33:35,366 --> 00:33:36,906
can only refresh once every 16


1051
00:33:36,906 --> 00:33:38,006
milliseconds and so we end up


1052
00:33:38,006 --> 00:33:38,806
with this beating pattern.


1053
00:33:38,876 --> 00:33:39,966
There's this stuttering that the


1054
00:33:39,966 --> 00:33:41,696
user feels where some frames are


1055
00:33:41,696 --> 00:33:42,746
on the glass a lot longer than


1056
00:33:42,746 --> 00:33:43,186
others.


1057
00:33:43,886 --> 00:33:46,656
And it's not nice at all.


1058
00:33:47,136 --> 00:33:48,696
And so pretty much universally


1059
00:33:48,696 --> 00:33:49,676
what applications do in this


1060
00:33:49,676 --> 00:33:50,426
case is they all have to


1061
00:33:50,426 --> 00:33:51,806
artificially constrain the frame


1062
00:33:51,806 --> 00:33:53,606
rate all the way down to 30


1063
00:33:53,606 --> 00:33:56,166
frames per second.


1064
00:33:56,166 --> 00:33:57,516
They're basically trading away


1065
00:33:57,516 --> 00:33:58,826
their peak frame rate in order


1066
00:33:58,826 --> 00:33:59,756
to get some level of


1067
00:33:59,756 --> 00:34:00,386
consistency.


1068
00:34:02,006 --> 00:34:03,966
ProMotion does much better here.


1069
00:34:04,446 --> 00:34:05,456
So if I just take the same


1070
00:34:05,456 --> 00:34:06,426
application, move it to a


1071
00:34:06,426 --> 00:34:08,956
ProMotion display, it does this


1072
00:34:08,956 --> 00:34:09,585
to our timeline.


1073
00:34:10,656 --> 00:34:11,866
We now have a refresh point


1074
00:34:11,866 --> 00:34:13,426
every four milliseconds rather


1075
00:34:13,426 --> 00:34:14,176
than every 16.


1076
00:34:15,096 --> 00:34:16,485
Our timeline gets pulled in,


1077
00:34:16,706 --> 00:34:18,116
even with the GPU doing exactly


1078
00:34:18,116 --> 00:34:19,116
the same work as before.


1079
00:34:19,735 --> 00:34:21,926
The display can now present at


1080
00:34:21,926 --> 00:34:23,456
an entirely consistent 48 frames


1081
00:34:23,456 --> 00:34:23,966
per second.


1082
00:34:24,815 --> 00:34:26,295
The user is now getting both the


1083
00:34:26,295 --> 00:34:27,956
best possible frame rate and


1084
00:34:27,956 --> 00:34:29,985
perfect consistency from frame


1085
00:34:29,985 --> 00:34:30,386
to frame.


1086
00:34:31,016 --> 00:34:31,946
This tradeoff that we had to


1087
00:34:31,946 --> 00:34:32,886
make is completely gone.


1088
00:34:34,076 --> 00:34:36,926
Furthermore -- so a second


1089
00:34:36,926 --> 00:34:38,826
example is that this time in


1090
00:34:38,826 --> 00:34:41,126
application that wanted to make


1091
00:34:41,126 --> 00:34:42,775
60 frames per second, but one


1092
00:34:42,775 --> 00:34:44,496
frame just ran a bit long and we


1093
00:34:44,496 --> 00:34:48,126
missed our deadline.


1094
00:34:48,126 --> 00:34:49,716
On a fixed frame rate display we


1095
00:34:49,716 --> 00:34:50,656
end up on the display side with


1096
00:34:50,656 --> 00:34:51,696
a pattern that looks very


1097
00:34:51,696 --> 00:34:52,956
similar to what we saw before.


1098
00:34:54,436 --> 00:34:55,626
ProMotion can fix this too.


1099
00:34:57,406 --> 00:34:58,456
So frame one's time on the


1100
00:34:58,456 --> 00:34:59,706
glass, rather than it being


1101
00:34:59,706 --> 00:35:01,166
extended by 16 milliseconds, is


1102
00:35:01,166 --> 00:35:02,486
now only extended by four.


1103
00:35:02,956 --> 00:35:04,356
The degree of stutter that the


1104
00:35:04,356 --> 00:35:06,266
user experiences is tremendously


1105
00:35:06,266 --> 00:35:08,896
reduced and then frame two and


1106
00:35:08,896 --> 00:35:11,166
three, their latency gets pulled


1107
00:35:11,166 --> 00:35:12,116
right back into where they were


1108
00:35:12,116 --> 00:35:12,626
before.


1109
00:35:13,256 --> 00:35:14,566
The system recovers right back


1110
00:35:14,566 --> 00:35:15,716
onto the timeline right away,


1111
00:35:16,166 --> 00:35:18,966
latency is improved, and your


1112
00:35:18,966 --> 00:35:20,276
application can proceed on.


1113
00:35:20,336 --> 00:35:21,136
We've just gotten right back to


1114
00:35:21,136 --> 00:35:22,586
where we wanted to be.


1115
00:35:23,246 --> 00:35:25,956
So put it all together, it just


1116
00:35:25,956 --> 00:35:27,646
makes animation just feel that


1117
00:35:27,646 --> 00:35:28,966
much more robust and solid no


1118
00:35:28,966 --> 00:35:30,616
matter what's going on.


1119
00:35:31,726 --> 00:35:33,636
So how do you actually go about


1120
00:35:33,636 --> 00:35:34,556
taking advantage of this?


1121
00:35:35,586 --> 00:35:38,406
For normal UIKit animation, such


1122
00:35:38,406 --> 00:35:39,376
as scrolling through lists or


1123
00:35:39,376 --> 00:35:41,336
views, iOS will do this entirely


1124
00:35:41,336 --> 00:35:42,356
for you out of the box.


1125
00:35:42,846 --> 00:35:44,346
It will render it 120 frames per


1126
00:35:44,346 --> 00:35:45,276
second when appropriate.


1127
00:35:45,306 --> 00:35:47,436
It will use the flexible display


1128
00:35:47,516 --> 00:35:48,296
times when appropriate.


1129
00:35:50,036 --> 00:35:51,076
Metal applications though tend


1130
00:35:51,076 --> 00:35:52,116
to be much more aware of their


1131
00:35:52,116 --> 00:35:53,306
timing and so for those we've


1132
00:35:53,306 --> 00:35:54,276
made this an opt in feature.


1133
00:35:56,116 --> 00:35:57,716
Opting in is done really easily


1134
00:35:57,716 --> 00:35:58,996
just by adding a new entry to


1135
00:35:58,996 --> 00:35:59,936
your application bundles


1136
00:35:59,936 --> 00:36:00,696
info.plist.


1137
00:36:01,476 --> 00:36:03,036
Once you do this the timing


1138
00:36:03,036 --> 00:36:04,446
behavior of our three Metal


1139
00:36:04,446 --> 00:36:06,026
presentation API changes a


1140
00:36:06,026 --> 00:36:06,366
little bit.


1141
00:36:06,366 --> 00:36:07,366
And so I'm going to walk you


1142
00:36:07,366 --> 00:36:08,676
through those three APIs and how


1143
00:36:08,676 --> 00:36:09,286
they change now.


1144
00:36:09,976 --> 00:36:11,896
So the first of our Metal


1145
00:36:11,896 --> 00:36:13,876
presentation APIs is just


1146
00:36:14,296 --> 00:36:15,906
present.


1147
00:36:16,726 --> 00:36:18,556
It's -- it says present


1148
00:36:18,556 --> 00:36:19,986
immediately; schedule my image


1149
00:36:19,986 --> 00:36:20,826
to be put on the glass at the


1150
00:36:20,826 --> 00:36:22,496
very next available refresh


1151
00:36:22,556 --> 00:36:24,136
point after the GPU finishes.


1152
00:36:25,206 --> 00:36:26,436
On fixed frame rate hardware


1153
00:36:26,436 --> 00:36:28,396
that's 16 milliseconds and on


1154
00:36:28,396 --> 00:36:29,786
iPad Pro that's now four


1155
00:36:29,786 --> 00:36:30,456
milliseconds.


1156
00:36:30,636 --> 00:36:32,696
This is the easiest API to use


1157
00:36:32,696 --> 00:36:33,556
because it takes no runs.


1158
00:36:33,556 --> 00:36:34,876
So it's the API that most of the


1159
00:36:34,876 --> 00:36:35,806
people in this room are already


1160
00:36:35,806 --> 00:36:36,126
using.


1161
00:36:37,246 --> 00:36:38,376
It's also the API that gives you


1162
00:36:38,376 --> 00:36:39,886
the lowest latency access to the


1163
00:36:39,886 --> 00:36:40,286
display.


1164
00:36:41,386 --> 00:36:43,066
It works identically on both our


1165
00:36:43,066 --> 00:36:44,426
fixed frame rate and ProMotion


1166
00:36:44,426 --> 00:36:46,466
hardware, but once you opt in it


1167
00:36:46,466 --> 00:36:47,466
starts working with much, much


1168
00:36:47,466 --> 00:36:47,976
better granularity.


1169
00:36:51,476 --> 00:36:52,936
The second of our Metal


1170
00:36:52,936 --> 00:36:54,826
presentation APIs is present


1171
00:36:54,826 --> 00:36:55,866
with minimum duration.


1172
00:36:56,666 --> 00:36:59,066
So this one says; whenever this


1173
00:36:59,066 --> 00:37:00,596
image lands on the glass, keep


1174
00:37:00,596 --> 00:37:01,666
it there for a certain fixed


1175
00:37:01,666 --> 00:37:02,306
amount of time.


1176
00:37:02,876 --> 00:37:03,776
So if my image lands on the


1177
00:37:03,776 --> 00:37:04,796
glass here, it's going to stay


1178
00:37:04,796 --> 00:37:05,956
for 33 milliseconds.


1179
00:37:05,956 --> 00:37:08,006
And if my start time shifts so


1180
00:37:08,006 --> 00:37:08,726
does the end time.


1181
00:37:09,406 --> 00:37:10,946
This is the API you'd use if you


1182
00:37:10,946 --> 00:37:12,216
want perfect consistency in


1183
00:37:12,216 --> 00:37:13,626
frame rate from frame to frame.


1184
00:37:14,246 --> 00:37:15,976
This is particularly useful in


1185
00:37:15,976 --> 00:37:17,446
30 frames per seconds -- on 60


1186
00:37:17,686 --> 00:37:19,236
rate per seconds displays,


1187
00:37:19,236 --> 00:37:20,156
although it's also sometimes


1188
00:37:20,156 --> 00:37:21,276
useful on ProMotion as well.


1189
00:37:22,246 --> 00:37:24,536
But our third presentation


1190
00:37:24,536 --> 00:37:25,746
varying is the most interesting


1191
00:37:25,746 --> 00:37:26,216
by far.


1192
00:37:26,406 --> 00:37:28,246
It's present at a specific time


1193
00:37:28,566 --> 00:37:30,316
and it does exactly what it


1194
00:37:30,316 --> 00:37:30,826
sounds like.


1195
00:37:31,566 --> 00:37:32,936
If the GPU's done well before


1196
00:37:32,936 --> 00:37:34,256
the designated time, the display


1197
00:37:34,256 --> 00:37:34,666
will wait.


1198
00:37:35,426 --> 00:37:36,386
If the GPU runs over your


1199
00:37:36,386 --> 00:37:37,796
deadline the display will pick


1200
00:37:37,796 --> 00:37:39,436
it up at the very next available


1201
00:37:39,436 --> 00:37:40,366
point afterwards.


1202
00:37:41,516 --> 00:37:44,086
This is the key API to use if


1203
00:37:44,086 --> 00:37:45,206
you want to build fully custom


1204
00:37:45,206 --> 00:37:46,426
animation and timing loops.


1205
00:37:47,116 --> 00:37:48,866
This API to present and time,


1206
00:37:48,946 --> 00:37:50,486
combined with ProMotion display


1207
00:37:50,926 --> 00:37:52,116
basically lets you leave behind


1208
00:37:52,116 --> 00:37:53,276
the concept of a fixed frame


1209
00:37:53,276 --> 00:37:54,526
rate entirely and render your


1210
00:37:54,526 --> 00:37:56,036
content exactly for the time the


1211
00:37:56,036 --> 00:37:57,026
user is going to see it.


1212
00:37:57,836 --> 00:37:59,126
If you want to keep your Metal


1213
00:37:59,126 --> 00:38:00,346
view perfectly in synch with


1214
00:38:00,346 --> 00:38:01,246
something else happening on the


1215
00:38:01,246 --> 00:38:03,206
system, such as audio, or if you


1216
00:38:03,206 --> 00:38:04,066
want to basically provide the


1217
00:38:04,066 --> 00:38:05,296
appearance of zero latency at


1218
00:38:05,296 --> 00:38:06,436
all and be able to forward


1219
00:38:06,436 --> 00:38:07,606
project your animation for


1220
00:38:07,606 --> 00:38:09,006
exactly when the user's going to


1221
00:38:09,006 --> 00:38:10,866
see your content this is what


1222
00:38:10,866 --> 00:38:11,676
lets you do that.


1223
00:38:13,096 --> 00:38:13,946
Now of course the trick is


1224
00:38:13,946 --> 00:38:15,156
implementing that project next


1225
00:38:15,156 --> 00:38:15,726
display time.


1226
00:38:15,726 --> 00:38:16,426
That's your function.


1227
00:38:17,456 --> 00:38:18,596
To make that work you do need


1228
00:38:18,596 --> 00:38:19,816
some feedback from the system to


1229
00:38:19,816 --> 00:38:20,976
help you determine what your


1230
00:38:20,976 --> 00:38:21,996
actual performance is.


1231
00:38:22,026 --> 00:38:23,186
And so we've added that as well.


1232
00:38:24,226 --> 00:38:26,796
So a Metal drawable object is a


1233
00:38:26,796 --> 00:38:27,986
transient object that tracks the


1234
00:38:27,986 --> 00:38:29,326
lifetime of one image you've


1235
00:38:29,326 --> 00:38:30,576
rendered all the way through the


1236
00:38:30,576 --> 00:38:31,256
display system.


1237
00:38:31,566 --> 00:38:34,736
It can now be queried for the


1238
00:38:34,736 --> 00:38:36,256
specific time that frame lands


1239
00:38:36,256 --> 00:38:37,446
on the glass and you can also


1240
00:38:37,446 --> 00:38:38,176
get a call back when that


1241
00:38:38,176 --> 00:38:38,706
happens.


1242
00:38:39,736 --> 00:38:41,296
So now you can know when your


1243
00:38:41,296 --> 00:38:42,536
image is landing on the glass,


1244
00:38:42,906 --> 00:38:44,486
when they're being removed, and


1245
00:38:44,486 --> 00:38:45,526
you have the key signal to know


1246
00:38:45,526 --> 00:38:47,186
when you are or are not making


1247
00:38:47,186 --> 00:38:48,236
the designated timing that you


1248
00:38:48,236 --> 00:38:49,716
intended and are giving you the


1249
00:38:49,716 --> 00:38:50,976
signal to adjust for future


1250
00:38:50,976 --> 00:38:51,526
frames.


1251
00:38:54,006 --> 00:38:55,976
So that's the story of ProMotion


1252
00:38:55,976 --> 00:38:57,106
and what you need to do to make


1253
00:38:57,106 --> 00:38:58,126
use of it on the future -- on


1254
00:38:58,126 --> 00:38:59,156
these new iPad Pros.


1255
00:38:59,766 --> 00:39:01,396
It's incredibly easy to get more


1256
00:39:01,396 --> 00:39:02,536
consistent and higher frame


1257
00:39:02,536 --> 00:39:05,086
rates with almost no code


1258
00:39:05,086 --> 00:39:06,326
changing at all in most


1259
00:39:06,326 --> 00:39:07,066
applications.


1260
00:39:08,496 --> 00:39:10,136
From there it gives you a menu


1261
00:39:10,136 --> 00:39:11,436
of options to decide what


1262
00:39:11,436 --> 00:39:12,586
display time model is going to


1263
00:39:12,586 --> 00:39:13,736
best benefit your particular


1264
00:39:13,736 --> 00:39:13,956
app.


1265
00:39:14,806 --> 00:39:16,186
A really, really fast paced


1266
00:39:16,256 --> 00:39:18,046
Twitch arcade game or something


1267
00:39:18,046 --> 00:39:19,816
tracking touch or pencil input


1268
00:39:19,816 --> 00:39:21,116
probably wants to go for 120


1269
00:39:21,116 --> 00:39:21,866
frames per second.


1270
00:39:22,476 --> 00:39:24,206
A really high end rendering


1271
00:39:24,206 --> 00:39:25,596
title might want to stick with


1272
00:39:25,656 --> 00:39:26,986
30 or 60 frames per second or


1273
00:39:26,986 --> 00:39:28,006
somewhere in between and just


1274
00:39:28,006 --> 00:39:30,286
enjoy the consistency benefits.


1275
00:39:30,966 --> 00:39:32,086
And applications that want to


1276
00:39:32,086 --> 00:39:32,996
really take control of their


1277
00:39:32,996 --> 00:39:34,336
timing loop have entirely new


1278
00:39:34,336 --> 00:39:35,376
capabilities here as well.


1279
00:39:36,136 --> 00:39:37,786
But regardless of what your app


1280
00:39:37,786 --> 00:39:39,796
actually is, ProMotion gives you


1281
00:39:39,796 --> 00:39:41,016
this powerful new tool to


1282
00:39:41,016 --> 00:39:42,286
support its specific animation


1283
00:39:42,286 --> 00:39:42,556
needs.


1284
00:39:42,556 --> 00:39:45,136
So that's ProMotion.


1285
00:39:45,846 --> 00:39:48,676
So moving on, I have a different


1286
00:39:48,766 --> 00:39:50,176
display topic to talk about and


1287
00:39:50,176 --> 00:39:51,106
that is a feature we're calling


1288
00:39:51,106 --> 00:39:52,146
Direct 2 Display.


1289
00:39:54,076 --> 00:39:56,036
So the story of what happens


1290
00:39:56,036 --> 00:39:57,866
after your GPU finishes


1291
00:39:57,866 --> 00:39:59,136
rendering your content and the


1292
00:39:59,136 --> 00:40:00,256
display is actually a little bit


1293
00:40:00,256 --> 00:40:00,896
more complicated.


1294
00:40:00,966 --> 00:40:02,716
And then your image can take two


1295
00:40:02,716 --> 00:40:04,666
paths to the display; GPU


1296
00:40:04,666 --> 00:40:06,856
composition and direct to


1297
00:40:07,956 --> 00:40:08,146
display.


1298
00:40:08,266 --> 00:40:10,086
The first of those is a -- your


1299
00:40:10,086 --> 00:40:11,776
typical user interface scenario


1300
00:40:12,366 --> 00:40:13,306
where I've got a collection of


1301
00:40:13,306 --> 00:40:14,916
views or layers or windows and


1302
00:40:14,916 --> 00:40:17,256
the like and at this point the


1303
00:40:17,256 --> 00:40:18,206
system is going to take all of


1304
00:40:18,206 --> 00:40:18,966
these and composite them


1305
00:40:18,966 --> 00:40:19,326
together.


1306
00:40:19,466 --> 00:40:20,596
It's going to scale any content


1307
00:40:20,596 --> 00:40:21,236
to fit the display.


1308
00:40:21,236 --> 00:40:21,736
It's going to perform


1309
00:40:21,736 --> 00:40:22,626
color/space conversion.


1310
00:40:22,626 --> 00:40:23,576
It's going to perform -- apply


1311
00:40:23,576 --> 00:40:24,606
any core image filters or


1312
00:40:24,606 --> 00:40:25,886
blending and it's going to


1313
00:40:25,886 --> 00:40:27,346
produce the one, final combined


1314
00:40:27,346 --> 00:40:28,466
image that the user sees.


1315
00:40:30,606 --> 00:40:32,266
This is really, really critical


1316
00:40:32,266 --> 00:40:33,496
abstraction for full-featured


1317
00:40:33,496 --> 00:40:34,406
user interfaces.


1318
00:40:35,896 --> 00:40:37,846
But it's also all done on the


1319
00:40:37,846 --> 00:40:39,006
GPU and it takes some time and


1320
00:40:39,006 --> 00:40:39,536
memory there.


1321
00:40:40,266 --> 00:40:41,576
And if we're basically building,


1322
00:40:41,576 --> 00:40:42,476
you know a full-screen


1323
00:40:42,476 --> 00:40:43,886
application, you know it's a


1324
00:40:43,886 --> 00:40:44,956
little bit overkill for that.


1325
00:40:45,426 --> 00:40:46,136
And so that's where direct


1326
00:40:46,136 --> 00:40:47,936
display mode comes in.


1327
00:40:48,086 --> 00:40:49,066
If none of these operations are


1328
00:40:49,066 --> 00:40:51,326
actually required, we can point


1329
00:40:51,326 --> 00:40:52,766
the display hardware directly at


1330
00:40:52,806 --> 00:40:54,046
the memory you just rendered to


1331
00:40:54,416 --> 00:40:55,686
and so without any middleman at


1332
00:40:55,686 --> 00:40:55,816
all.


1333
00:40:56,716 --> 00:40:58,856
So how do you enable this?


1334
00:40:59,236 --> 00:41:01,026
It turns out there is no single


1335
00:41:01,026 --> 00:41:02,546
turn it on API for direct to


1336
00:41:02,546 --> 00:41:02,966
display.


1337
00:41:03,736 --> 00:41:05,396
This mode is really an omission


1338
00:41:05,396 --> 00:41:06,626
of anything that requires the


1339
00:41:06,626 --> 00:41:07,986
GPU compositer to intervene.


1340
00:41:08,656 --> 00:41:10,216
When the compositer takes a look


1341
00:41:10,216 --> 00:41:11,426
at the set-up of your scene and


1342
00:41:11,426 --> 00:41:12,856
says there's nothing it needs to


1343
00:41:12,856 --> 00:41:14,736
do here it will just step out of


1344
00:41:15,406 --> 00:41:16,296
the way.


1345
00:41:16,296 --> 00:41:18,006
So how can you set up your scene


1346
00:41:18,006 --> 00:41:20,556
to get the compositer to step


1347
00:41:20,556 --> 00:41:22,396
out of the way?


1348
00:41:22,476 --> 00:41:23,526
So this is pretty


1349
00:41:23,526 --> 00:41:24,746
straightforward, an intuitive


1350
00:41:24,796 --> 00:41:25,996
feel of, does my content need


1351
00:41:25,996 --> 00:41:26,936
any kind of nontrurial


1352
00:41:26,936 --> 00:41:27,676
[phonetic] processing is a


1353
00:41:27,676 --> 00:41:29,166
pretty good intuitive start.


1354
00:41:29,896 --> 00:41:30,976
But more specifically you do


1355
00:41:30,976 --> 00:41:31,986
want your layer to be opaque.


1356
00:41:32,556 --> 00:41:33,586
I don't want to be blending over


1357
00:41:33,586 --> 00:41:33,936
anything.


1358
00:41:34,246 --> 00:41:36,446
We don't want to apply anything


1359
00:41:36,446 --> 00:41:37,546
that requires that core


1360
00:41:37,546 --> 00:41:38,496
animation or the window server


1361
00:41:38,766 --> 00:41:39,776
modify our pixels.


1362
00:41:39,776 --> 00:41:40,676
We don't want to put on rounded


1363
00:41:40,676 --> 00:41:42,236
corners in our view or masking


1364
00:41:42,236 --> 00:41:44,206
or filters or the like.


1365
00:41:45,496 --> 00:41:46,726
We do want to be full-screen.


1366
00:41:47,076 --> 00:41:49,326
If your content does not


1367
00:41:49,326 --> 00:41:51,086
actually match the aspect ratio


1368
00:41:51,086 --> 00:41:52,266
of the display it is okay to put


1369
00:41:52,266 --> 00:41:53,726
a full-screen, opaque, black


1370
00:41:53,726 --> 00:41:55,166
background layer to sort of give


1371
00:41:55,166 --> 00:41:56,226
a black bar kind of effect.


1372
00:41:56,226 --> 00:41:57,046
But in the end we want to


1373
00:41:57,046 --> 00:41:58,346
basically obscure everything.


1374
00:42:01,286 --> 00:42:02,486
We do want to pick render


1375
00:42:02,486 --> 00:42:03,466
resolutions that match the


1376
00:42:03,466 --> 00:42:04,136
native panel.


1377
00:42:05,016 --> 00:42:06,246
So this is actually a little bit


1378
00:42:06,246 --> 00:42:07,446
tricky because all of our --


1379
00:42:07,446 --> 00:42:08,896
both on macOS and iOS we ship


1380
00:42:08,896 --> 00:42:10,396
hardware that has a virtual


1381
00:42:10,396 --> 00:42:12,336
desktop modes or resolution


1382
00:42:12,336 --> 00:42:13,526
modes that are larger than the


1383
00:42:13,526 --> 00:42:14,496
actual physical panel.


1384
00:42:14,596 --> 00:42:16,036
And the last thing we want to do


1385
00:42:16,036 --> 00:42:17,216
is spend time rendering too many


1386
00:42:17,216 --> 00:42:18,446
pixels only to have to spend


1387
00:42:18,446 --> 00:42:19,586
time on the GPU to scale it all


1388
00:42:19,586 --> 00:42:19,976
back down again.


1389
00:42:24,296 --> 00:42:25,676
And finally, you want to pick a


1390
00:42:25,676 --> 00:42:26,806
color, space, and pixel format


1391
00:42:26,806 --> 00:42:27,876
that the display hardware is


1392
00:42:27,876 --> 00:42:29,016
happy to read from directly.


1393
00:42:29,896 --> 00:42:30,956
And so this one, there's any


1394
00:42:30,956 --> 00:42:32,046
infinite number of combinations


1395
00:42:32,046 --> 00:42:33,816
here so I want to help out by


1396
00:42:33,816 --> 00:42:34,486
giving you a little bit of a


1397
00:42:34,486 --> 00:42:35,816
white list of some particularly


1398
00:42:35,816 --> 00:42:36,746
common and efficient


1399
00:42:36,746 --> 00:42:37,416
combinations.


1400
00:42:39,766 --> 00:42:41,426
So right on the top is our good


1401
00:42:41,426 --> 00:42:44,406
old friend; SRGB8888.


1402
00:42:44,406 --> 00:42:45,326
This is pretty much the


1403
00:42:45,326 --> 00:42:46,816
universal pixel format that most


1404
00:42:46,816 --> 00:42:48,636
applications use and all


1405
00:42:48,636 --> 00:42:50,446
hardware is happy to read.


1406
00:42:50,446 --> 00:42:51,606
And so for most people that's


1407
00:42:51,606 --> 00:42:52,026
all they need.


1408
00:42:53,496 --> 00:42:55,706
But we've been shipping wide


1409
00:42:55,706 --> 00:42:57,926
color gamut P3 displays on both


1410
00:42:57,926 --> 00:43:00,686
our macOS and iOS hardware and


1411
00:43:00,936 --> 00:43:02,076
if your application does want to


1412
00:43:02,076 --> 00:43:03,596
start making use of this ability


1413
00:43:03,596 --> 00:43:04,756
to represent more colors, you


1414
00:43:04,756 --> 00:43:05,836
need to pay a bit more


1415
00:43:05,836 --> 00:43:06,226
attention.


1416
00:43:06,226 --> 00:43:09,496
In both the -- the concepts are


1417
00:43:09,496 --> 00:43:10,916
the same between iOS and macOS,


1418
00:43:10,916 --> 00:43:11,826
although the details differ a


1419
00:43:11,826 --> 00:43:13,146
little bit.


1420
00:43:13,146 --> 00:43:14,516
In both cases we do want to


1421
00:43:14,516 --> 00:43:15,676
render to attend the pixel


1422
00:43:17,096 --> 00:43:19,936
format, but note that if you


1423
00:43:19,936 --> 00:43:21,396
render P3 content onto a P3


1424
00:43:21,396 --> 00:43:23,116
display that's fine, but if you


1425
00:43:23,116 --> 00:43:25,516
render P3 content onto an SRGB


1426
00:43:25,516 --> 00:43:27,996
display the system -- the GP


1427
00:43:27,996 --> 00:43:29,096
compositer might have to get


1428
00:43:29,096 --> 00:43:30,156
involved to crush the color


1429
00:43:30,156 --> 00:43:31,256
space back down to fit the


1430
00:43:31,256 --> 00:43:31,646
display.


1431
00:43:32,536 --> 00:43:34,036
And so this is -- P3 is not


1432
00:43:34,036 --> 00:43:34,646
something you want to do


1433
00:43:34,646 --> 00:43:35,826
universally, all the time.


1434
00:43:35,936 --> 00:43:37,006
you do want to take a look at


1435
00:43:37,056 --> 00:43:39,286
the current display and make


1436
00:43:39,286 --> 00:43:40,446
this a conditional thing.


1437
00:43:40,816 --> 00:43:43,186
So finally, for completeness I'm


1438
00:43:43,186 --> 00:43:44,556
also going to list RGBA float


1439
00:43:44,556 --> 00:43:45,696
16, which is sort of the


1440
00:43:45,696 --> 00:43:47,946
universal, wide gamut, high


1441
00:43:47,946 --> 00:43:49,236
dynamic range pixel format.


1442
00:43:49,786 --> 00:43:51,916
Although, in -- I do -- it's


1443
00:43:51,916 --> 00:43:53,096
also necessary for MacOS's


1444
00:43:53,096 --> 00:43:54,286
extended data range feature.


1445
00:43:55,026 --> 00:43:55,906
Although it is worth noting that


1446
00:43:55,906 --> 00:43:57,306
it does require GPU compositing


1447
00:43:57,306 --> 00:43:57,976
in all cases.


1448
00:44:01,486 --> 00:44:02,396
So I mentioned, you do want to


1449
00:44:02,396 --> 00:44:03,606
be a little bit conditional if


1450
00:44:03,606 --> 00:44:04,536
you write an application that's


1451
00:44:04,536 --> 00:44:05,416
wide color aware.


1452
00:44:06,206 --> 00:44:07,576
Fortunately, both UIKit and


1453
00:44:07,616 --> 00:44:08,606
AppKit provide really convenient


1454
00:44:08,606 --> 00:44:08,976
APIs to check that.


1455
00:44:13,086 --> 00:44:14,616
So the last step is, how do you


1456
00:44:14,616 --> 00:44:15,886
know if you're actually on the


1457
00:44:15,886 --> 00:44:17,476
directed display path?


1458
00:44:17,476 --> 00:44:18,506
So this is a screen shot of our


1459
00:44:18,506 --> 00:44:19,796
Metal system trace tool and


1460
00:44:19,796 --> 00:44:20,396
instruments.


1461
00:44:20,646 --> 00:44:23,186
And Metal system trace is pretty


1462
00:44:23,186 --> 00:44:24,836
much a developer tool that will


1463
00:44:24,836 --> 00:44:26,486
give you a live timeline of the


1464
00:44:26,486 --> 00:44:27,706
CPU and the GPU in the display.


1465
00:44:28,046 --> 00:44:29,936
Pretty much a real-world version


1466
00:44:29,936 --> 00:44:30,826
of the diagrams I've been


1467
00:44:30,826 --> 00:44:31,466
showing you in this


1468
00:44:31,466 --> 00:44:32,066
presentation.


1469
00:44:33,226 --> 00:44:35,046
So in this case, I want to


1470
00:44:35,046 --> 00:44:36,416
highlight my three frames that


1471
00:44:36,416 --> 00:44:36,846
I've rendered.


1472
00:44:37,376 --> 00:44:38,936
The color-time intervals are my


1473
00:44:38,936 --> 00:44:39,946
own application's rendering.


1474
00:44:41,126 --> 00:44:42,556
And the gray time intervals are


1475
00:44:42,556 --> 00:44:44,276
some other processes in the GPU.


1476
00:44:45,546 --> 00:44:46,636
I can get more details down at


1477
00:44:46,636 --> 00:44:47,506
the bottom of the window or I


1478
00:44:47,506 --> 00:44:48,136
can see it's coming from


1479
00:44:48,136 --> 00:44:50,666
backboard D, our iOS composition


1480
00:44:50,666 --> 00:44:51,236
process.


1481
00:44:51,426 --> 00:44:52,436
So this is the case where my


1482
00:44:52,436 --> 00:44:53,506
application is going down the


1483
00:44:53,506 --> 00:44:55,766
GPU compositing path.


1484
00:44:55,766 --> 00:44:56,726
Going back and revisiting some


1485
00:44:56,726 --> 00:44:58,996
of our best practices can remove


1486
00:44:58,996 --> 00:45:00,316
that from the picture and now I


1487
00:45:00,316 --> 00:45:01,946
can rerun my Metal system trace


1488
00:45:02,386 --> 00:45:03,806
and see that I have a timeline


1489
00:45:03,806 --> 00:45:05,456
where, you know I've got the GPU


1490
00:45:05,546 --> 00:45:06,446
completely and entirely to


1491
00:45:06,446 --> 00:45:06,936
myself.


1492
00:45:10,156 --> 00:45:11,846
So that's it for direct to


1493
00:45:11,976 --> 00:45:12,586
display.


1494
00:45:12,586 --> 00:45:13,916
Our system compositors can make


1495
00:45:13,916 --> 00:45:15,206
a lot of magic happen behind the


1496
00:45:15,206 --> 00:45:16,576
scenes to make full-featured


1497
00:45:16,576 --> 00:45:18,446
user interfaces possible, but


1498
00:45:18,446 --> 00:45:19,536
that can come at a performance


1499
00:45:19,536 --> 00:45:20,806
cost because they use the GPU to


1500
00:45:20,806 --> 00:45:21,256
do it.


1501
00:45:22,216 --> 00:45:23,286
By being a little bit aware of


1502
00:45:23,286 --> 00:45:23,866
what you're asking the


1503
00:45:23,866 --> 00:45:25,366
compositer to do, or more


1504
00:45:25,366 --> 00:45:26,726
importantly by not asking what


1505
00:45:26,726 --> 00:45:28,016
you're not asking the compositer


1506
00:45:28,016 --> 00:45:29,876
to do, it can get out of the way


1507
00:45:29,876 --> 00:45:31,646
without using the GPU, returning


1508
00:45:31,646 --> 00:45:32,586
some of that time to you.


1509
00:45:33,326 --> 00:45:35,356
Direct to display is supported


1510
00:45:35,356 --> 00:45:36,876
on iOS and Tos and always has


1511
00:45:36,876 --> 00:45:38,886
been and its support is new to


1512
00:45:38,886 --> 00:45:40,476
macOS High Sierra for Metal


1513
00:45:40,476 --> 00:45:40,966
applications.


1514
00:45:45,196 --> 00:45:46,366
So with that I want to touch on


1515
00:45:46,366 --> 00:45:47,956
our last topic of the day and


1516
00:45:47,956 --> 00:45:50,396
that's everything else.


1517
00:45:50,446 --> 00:45:51,546
There's a lot more that we've


1518
00:45:51,546 --> 00:45:52,656
added to the core frameworks and


1519
00:45:52,656 --> 00:45:53,846
sheeting language for Metal 2.


1520
00:45:53,906 --> 00:45:55,136
And so I'm not going to dive


1521
00:45:55,136 --> 00:45:56,056
deep into any of these things,


1522
00:45:56,056 --> 00:45:56,716
but I do want to give you a


1523
00:45:56,716 --> 00:45:57,006
survey.


1524
00:45:57,006 --> 00:46:00,076
So right off the bat we've added


1525
00:46:00,366 --> 00:46:01,766
some new APIs to be able to


1526
00:46:01,766 --> 00:46:03,746
query how much GPU memory's


1527
00:46:03,746 --> 00:46:05,146
being allocated for each buffer,


1528
00:46:05,146 --> 00:46:06,276
for each texture, for each Heap.


1529
00:46:06,566 --> 00:46:08,816
This actually takes into account


1530
00:46:08,816 --> 00:46:09,406
things that just generally


1531
00:46:09,406 --> 00:46:10,496
happen behind the scenes, like


1532
00:46:10,496 --> 00:46:12,326
alignment and various padding.


1533
00:46:12,986 --> 00:46:13,826
So this can give you a more


1534
00:46:13,826 --> 00:46:15,186
accurate view of how much GPU


1535
00:46:15,186 --> 00:46:16,416
memory you're actually using.


1536
00:46:16,416 --> 00:46:19,296
We also have a roll-up query on


1537
00:46:19,296 --> 00:46:21,836
the Metal device, which is the


1538
00:46:21,836 --> 00:46:23,596
entire GPU memory usage for your


1539
00:46:23,596 --> 00:46:24,606
entire process.


1540
00:46:24,936 --> 00:46:26,546
And this is particularly notable


1541
00:46:26,546 --> 00:46:28,436
because that also counts all of


1542
00:46:28,436 --> 00:46:29,446
the memory that the driver needs


1543
00:46:29,446 --> 00:46:30,786
to allocate that's not otherwise


1544
00:46:30,786 --> 00:46:32,986
visible to you; things like


1545
00:46:32,986 --> 00:46:34,506
memory to put shader code in or


1546
00:46:34,506 --> 00:46:35,516
command buffers or anything


1547
00:46:35,516 --> 00:46:35,906
else.


1548
00:46:36,396 --> 00:46:37,346
So this can give you where


1549
00:46:37,346 --> 00:46:38,326
you're at relative -- you know


1550
00:46:38,376 --> 00:46:39,406
everything all in compared to


1551
00:46:39,406 --> 00:46:39,976
your memory usage target.


1552
00:46:43,566 --> 00:46:44,496
We have a couple compute


1553
00:46:44,496 --> 00:46:45,416
oriented additions.


1554
00:46:45,866 --> 00:46:47,076
The first of those is that we've


1555
00:46:47,076 --> 00:46:48,106
added a set of shading language


1556
00:46:48,106 --> 00:46:49,466
functions to help -- to allow


1557
00:46:49,466 --> 00:46:50,656
you to transfer data directly


1558
00:46:50,656 --> 00:46:51,806
between threads in a SIMD group.


1559
00:46:52,026 --> 00:46:54,126
If you're not familiar; GPU


1560
00:46:54,126 --> 00:46:55,356
hardware typically gains an


1561
00:46:55,576 --> 00:46:57,436
individual vertex fragment and


1562
00:46:57,436 --> 00:46:59,426
compute shader thread into SIMD


1563
00:46:59,426 --> 00:47:00,586
groups and executes them


1564
00:47:00,586 --> 00:47:01,816
together for greater efficiency.


1565
00:47:02,366 --> 00:47:04,096
This are also called wayfrencer


1566
00:47:04,096 --> 00:47:04,576
[phonetic] warps.


1567
00:47:05,596 --> 00:47:07,216
Within a group these threads do


1568
00:47:07,216 --> 00:47:08,336
have some ability to directly


1569
00:47:08,336 --> 00:47:09,586
communicate without having to


1570
00:47:09,586 --> 00:47:10,626
load and store through memory.


1571
00:47:11,236 --> 00:47:12,956
They can read values directly


1572
00:47:12,956 --> 00:47:14,046
out of one thread's register and


1573
00:47:14,046 --> 00:47:14,926
write them to another thread's


1574
00:47:14,926 --> 00:47:15,496
register.


1575
00:47:15,626 --> 00:47:16,346
And that's what these new


1576
00:47:16,346 --> 00:47:17,336
standard library functions


1577
00:47:17,336 --> 00:47:17,636
allow.


1578
00:47:18,626 --> 00:47:21,346
So in this case broadcast means


1579
00:47:21,346 --> 00:47:22,576
I can read a data directly --


1580
00:47:22,686 --> 00:47:24,056
read a field directly out of


1581
00:47:24,056 --> 00:47:25,356
thread zero's registers and


1582
00:47:25,356 --> 00:47:26,236
write it directly into the


1583
00:47:26,236 --> 00:47:27,696
registers of 16 other threads


1584
00:47:27,696 --> 00:47:28,626
that happen to be part of this


1585
00:47:28,626 --> 00:47:28,856
group.


1586
00:47:33,046 --> 00:47:34,436
Our second compute addition is


1587
00:47:34,436 --> 00:47:35,606
to give you more flexibility in


1588
00:47:35,606 --> 00:47:36,906
how big your thread groups are.


1589
00:47:37,786 --> 00:47:39,396
So for example if I have a pixel


1590
00:47:39,396 --> 00:47:40,376
bird here that I want to run


1591
00:47:40,376 --> 00:47:41,746
some pretty classic image


1592
00:47:41,746 --> 00:47:44,696
processing kernel over, but then


1593
00:47:44,696 --> 00:47:45,766
I've written my compute kernel


1594
00:47:45,766 --> 00:47:47,486
such that I'm using four by four


1595
00:47:47,486 --> 00:47:48,336
thread groups everywhere.


1596
00:47:49,736 --> 00:47:50,766
Well, this leads to some


1597
00:47:50,766 --> 00:47:52,076
problems because I've got -- if


1598
00:47:52,076 --> 00:47:53,546
my image is not a nice multiple


1599
00:47:53,546 --> 00:47:54,886
of my thread group size I've got


1600
00:47:54,886 --> 00:47:55,896
a bunch of stray threads on the


1601
00:47:55,896 --> 00:47:56,226
side.


1602
00:47:56,886 --> 00:47:59,596
I mean this means that I've got


1603
00:47:59,596 --> 00:48:01,556
to dive into those and say when


1604
00:48:01,556 --> 00:48:02,376
I actually write my code.


1605
00:48:02,376 --> 00:48:03,296
I have to be defensive.


1606
00:48:03,296 --> 00:48:04,156
Am I out of bounds?


1607
00:48:04,156 --> 00:48:04,986
I have to handle it in some


1608
00:48:04,986 --> 00:48:05,566
special way.


1609
00:48:05,566 --> 00:48:06,976
It's doable but annoying.


1610
00:48:07,806 --> 00:48:08,746
It also means that we're just


1611
00:48:08,746 --> 00:48:09,966
wasting GPU cycles.


1612
00:48:11,096 --> 00:48:12,726
So non-uniform thread group


1613
00:48:12,726 --> 00:48:14,366
sizes, unless you declare what


1614
00:48:14,366 --> 00:48:15,306
dimensions you want to run your


1615
00:48:15,306 --> 00:48:16,726
kernel over, without being


1616
00:48:16,726 --> 00:48:17,956
multiple thread group sizes.


1617
00:48:18,556 --> 00:48:19,986
So the hard working, smaller


1618
00:48:19,986 --> 00:48:21,596
thread groups along the edges of


1619
00:48:21,596 --> 00:48:23,366
my grid, in order to say -- in


1620
00:48:23,366 --> 00:48:24,296
order to just shave off that


1621
00:48:24,296 --> 00:48:25,836
unnecessary work it both


1622
00:48:25,936 --> 00:48:28,286
improves GPU performance and


1623
00:48:28,286 --> 00:48:29,586
just makes your kernels easier


1624
00:48:29,586 --> 00:48:29,856
to write.


1625
00:48:34,066 --> 00:48:35,046
We've added support for a view


1626
00:48:35,046 --> 00:48:35,716
port arrays.


1627
00:48:35,956 --> 00:48:37,576
You can now configure up to 16


1628
00:48:37,576 --> 00:48:39,226
simultaneous view ports and your


1629
00:48:39,226 --> 00:48:40,966
vertex shader can select, per


1630
00:48:40,966 --> 00:48:42,596
triangle, which view port that


1631
00:48:42,596 --> 00:48:43,746
triangle gets presented into.


1632
00:48:44,446 --> 00:48:45,426
I'm not going to go further into


1633
00:48:45,426 --> 00:48:46,086
this because it will be


1634
00:48:46,086 --> 00:48:47,856
discussed in detail tomorrow in


1635
00:48:47,856 --> 00:48:49,006
the VR with Metal 2 session.


1636
00:48:49,376 --> 00:48:50,746
It is particularly valuable for


1637
00:48:50,746 --> 00:48:51,446
efficiently rendering to the


1638
00:48:51,446 --> 00:48:51,976
left and right eyes.


1639
00:48:56,496 --> 00:48:57,306
We've added the ability to


1640
00:48:57,306 --> 00:48:58,946
choose where each pixel your


1641
00:48:58,946 --> 00:48:59,906
multi-sample locations are


1642
00:48:59,906 --> 00:49:00,426
supported.


1643
00:49:01,026 --> 00:49:02,606
This lets you do a few


1644
00:49:02,606 --> 00:49:04,186
interesting things including


1645
00:49:04,186 --> 00:49:05,196
maybe toggling your sample


1646
00:49:05,196 --> 00:49:07,086
positions every other frame and


1647
00:49:07,086 --> 00:49:07,796
giving you some new -- you know


1648
00:49:07,796 --> 00:49:08,856
valuable input into some


1649
00:49:08,856 --> 00:49:09,696
temporal anti-aliasing


1650
00:49:09,696 --> 00:49:09,976
algorithms.


1651
00:49:15,546 --> 00:49:17,036
In the vein of trying to keep --


1652
00:49:17,096 --> 00:49:18,556
of working to bring our


1653
00:49:18,556 --> 00:49:19,586
platforms up to date to have


1654
00:49:19,636 --> 00:49:20,646
them have the same feature set


1655
00:49:20,646 --> 00:49:21,686
wherever possible, we've brought


1656
00:49:21,686 --> 00:49:23,186
resource Heaps, shipped last


1657
00:49:23,186 --> 00:49:25,416
year in iOS 10 to macOS High


1658
00:49:25,416 --> 00:49:26,196
Sierra this year.


1659
00:49:26,466 --> 00:49:28,646
So I'm going to actually do a


1660
00:49:28,646 --> 00:49:29,756
little bit of a refresher on


1661
00:49:29,756 --> 00:49:32,026
this because good use of your


1662
00:49:32,026 --> 00:49:33,716
Heaps is really important to


1663
00:49:33,716 --> 00:49:34,646
getting the most out of argument


1664
00:49:34,646 --> 00:49:35,066
buffers.


1665
00:49:36,436 --> 00:49:37,816
So Heaps are of course where I


1666
00:49:37,816 --> 00:49:38,716
can allocate a big slab of


1667
00:49:38,716 --> 00:49:40,616
memory up front rather than


1668
00:49:40,616 --> 00:49:42,246
going to the kernel to -- I want


1669
00:49:42,346 --> 00:49:43,756
memory for texture a, and I want


1670
00:49:43,756 --> 00:49:44,876
memory for texture b and so


1671
00:49:44,876 --> 00:49:45,246
forth.


1672
00:49:45,656 --> 00:49:46,716
I can go to the kernel and get


1673
00:49:46,716 --> 00:49:48,866
memory right up front and of


1674
00:49:48,866 --> 00:49:50,196
course put textures -- you know


1675
00:49:50,226 --> 00:49:51,386
add and remove textures and


1676
00:49:51,386 --> 00:49:52,736
buffers to -- without having to


1677
00:49:52,806 --> 00:49:55,226
go back to the system.


1678
00:49:55,296 --> 00:49:56,586
This has a few advantages.


1679
00:49:56,776 --> 00:49:58,036
It means that I can bind


1680
00:49:58,036 --> 00:49:58,946
everything in that Heap much


1681
00:49:58,946 --> 00:49:59,556
more efficiently.


1682
00:49:59,736 --> 00:50:00,496
There's much less software


1683
00:50:00,496 --> 00:50:00,856
overhead.


1684
00:50:01,616 --> 00:50:02,766
It means that we can oftentimes


1685
00:50:02,766 --> 00:50:03,716
pack that memory a little bit


1686
00:50:03,756 --> 00:50:04,306
closer together.


1687
00:50:04,306 --> 00:50:05,376
We can save some padding and


1688
00:50:05,376 --> 00:50:06,906
alignment, save you a little bit


1689
00:50:07,396 --> 00:50:08,546
of memory.


1690
00:50:08,686 --> 00:50:09,946
It means when we delete memory


1691
00:50:10,256 --> 00:50:11,646
we don't give memory back to the


1692
00:50:11,646 --> 00:50:12,056
system.


1693
00:50:12,356 --> 00:50:13,116
That could be good or bad.


1694
00:50:13,826 --> 00:50:15,496
It means when we allocate new


1695
00:50:15,496 --> 00:50:16,356
memory -- when we allocate a new


1696
00:50:16,356 --> 00:50:17,486
texture it means we don't have


1697
00:50:17,486 --> 00:50:18,526
to go back to the system and get


1698
00:50:18,526 --> 00:50:18,976
new memory.


1699
00:50:22,306 --> 00:50:23,226
It also means that you can


1700
00:50:23,226 --> 00:50:24,746
choose to alias these textures


1701
00:50:24,746 --> 00:50:25,296
with each other.


1702
00:50:26,086 --> 00:50:27,436
If I have -- you typically


1703
00:50:27,436 --> 00:50:29,286
render targets or intermediate


1704
00:50:29,286 --> 00:50:30,956
render targets between different


1705
00:50:30,956 --> 00:50:32,486
passes in my render graph.


1706
00:50:32,906 --> 00:50:34,006
It means that if I have two


1707
00:50:34,006 --> 00:50:34,716
different intermediates that


1708
00:50:34,716 --> 00:50:36,456
just don't have to exist at the


1709
00:50:36,456 --> 00:50:37,796
same point in time I can alias


1710
00:50:37,796 --> 00:50:38,756
them over each other and I can


1711
00:50:38,756 --> 00:50:43,236
save tons of memory like this.


1712
00:50:43,926 --> 00:50:45,906
So that's it for a quick survey


1713
00:50:46,686 --> 00:50:47,736
of Heaps.


1714
00:50:47,816 --> 00:50:50,026
We've added linear textures from


1715
00:50:50,206 --> 00:50:51,886
iOS to macOS.


1716
00:50:52,126 --> 00:50:53,196
Linear textures allows you to


1717
00:50:53,196 --> 00:50:54,976
create a texture directly from a


1718
00:50:54,976 --> 00:50:56,566
Metal buffer without any copies


1719
00:50:56,616 --> 00:50:57,046
at all.


1720
00:50:59,136 --> 00:51:00,106
We've extended our function


1721
00:51:00,106 --> 00:51:01,556
constant feature a little bit.


1722
00:51:01,556 --> 00:51:02,586
A quick refresher, function


1723
00:51:02,586 --> 00:51:03,486
constants allow you to


1724
00:51:03,486 --> 00:51:04,716
specialize by codes.


1725
00:51:04,936 --> 00:51:05,756
When you've done all your front


1726
00:51:05,756 --> 00:51:07,296
end compilation offline you can


1727
00:51:07,296 --> 00:51:08,466
then tweak and customize your


1728
00:51:08,466 --> 00:51:09,716
uber shader bi-code a little bit


1729
00:51:09,936 --> 00:51:11,126
before actual generating final


1730
00:51:11,126 --> 00:51:11,686
machine code.


1731
00:51:12,546 --> 00:51:13,876
If you have a classic uber


1732
00:51:13,876 --> 00:51:14,986
shader this can save you the


1733
00:51:14,986 --> 00:51:16,036
cost of having to re-run the


1734
00:51:16,036 --> 00:51:17,666
compiler front end for every


1735
00:51:17,666 --> 00:51:18,556
single permutation.


1736
00:51:19,636 --> 00:51:20,846
So we've made this a bit more


1737
00:51:20,846 --> 00:51:22,376
flexible and added a few more


1738
00:51:22,376 --> 00:51:24,966
cases where you can use these


1739
00:51:25,076 --> 00:51:26,116
specialized arguments.


1740
00:51:27,876 --> 00:51:28,926
We've added some extra vertex


1741
00:51:28,926 --> 00:51:29,616
array formats.


1742
00:51:29,656 --> 00:51:31,026
We had some missing one and two


1743
00:51:31,026 --> 00:51:32,226
component vertex formats.


1744
00:51:32,596 --> 00:51:34,176
And we've also added BGRA vertex


1745
00:51:34,176 --> 00:51:34,746
formats.


1746
00:51:37,406 --> 00:51:38,446
We've brought iOS surface


1747
00:51:38,446 --> 00:51:40,146
texture support from macOS to


1748
00:51:40,256 --> 00:51:40,676
iOS.


1749
00:51:40,676 --> 00:51:42,546
And we've also brought dual


1750
00:51:42,546 --> 00:51:43,986
sourced blending to iOS as well,


1751
00:51:44,276 --> 00:51:46,496
also particularly useful in some


1752
00:51:46,496 --> 00:51:47,756
deferred shading scenarios.


1753
00:51:48,256 --> 00:51:52,586
So that's -- brings us to the


1754
00:51:52,586 --> 00:51:55,886
end of introducing Metal 2.


1755
00:51:55,886 --> 00:51:57,416
My colleague, Michal, started


1756
00:51:57,416 --> 00:51:58,806
with giving you a little bit of


1757
00:51:58,806 --> 00:52:00,096
an overview of the overall scope


1758
00:52:00,096 --> 00:52:00,636
of Metal 2.


1759
00:52:00,956 --> 00:52:03,496
From VR to external GPUs, to


1760
00:52:03,886 --> 00:52:05,036
machine learning, and to new


1761
00:52:05,036 --> 00:52:06,716
developer tools and performance


1762
00:52:07,126 --> 00:52:07,866
analysis.


1763
00:52:07,866 --> 00:52:08,816
Of that, the pieces that we


1764
00:52:08,816 --> 00:52:10,766
really covered today are our


1765
00:52:10,766 --> 00:52:12,286
next big push toward reducing


1766
00:52:12,406 --> 00:52:13,756
CPU overhead using argument


1767
00:52:13,756 --> 00:52:14,216
buffers.


1768
00:52:14,836 --> 00:52:16,326
Argument buffers also unlock the


1769
00:52:16,326 --> 00:52:17,686
ability for the GPU to start


1770
00:52:17,746 --> 00:52:18,786
taking a little bit of its own


1771
00:52:18,786 --> 00:52:19,696
destiny when it comes to


1772
00:52:19,696 --> 00:52:20,956
configuring shader arguments,


1773
00:52:20,956 --> 00:52:22,356
which is one less reason to take


1774
00:52:22,356 --> 00:52:24,506
back to the CPU.


1775
00:52:25,416 --> 00:52:27,146
Raster Order Groups let us start


1776
00:52:27,146 --> 00:52:28,496
using the rasterizer for things


1777
00:52:28,496 --> 00:52:30,016
beyond basic in order blending.


1778
00:52:31,186 --> 00:52:32,306
We can now start taking


1779
00:52:32,306 --> 00:52:33,896
advantage of the latest hardware


1780
00:52:33,896 --> 00:52:36,386
capabilities to do, you know,


1781
00:52:36,386 --> 00:52:38,226
vox slice triangle meshes or set


1782
00:52:38,426 --> 00:52:40,146
transparency blending either in


1783
00:52:40,146 --> 00:52:41,056
order or independent.


1784
00:52:41,126 --> 00:52:42,046
They're both -- it makes them


1785
00:52:42,046 --> 00:52:42,646
both possible.


1786
00:52:43,836 --> 00:52:46,496
For the new iPad Pros, ProMotion


1787
00:52:46,496 --> 00:52:47,556
gives you very fine grained


1788
00:52:47,556 --> 00:52:48,956
control over exactly how your


1789
00:52:48,956 --> 00:52:50,056
animations are presented to the


1790
00:52:50,056 --> 00:52:51,716
user, giving you the ability to


1791
00:52:51,716 --> 00:52:53,486
get both peak frame rates and


1792
00:52:53,486 --> 00:52:54,566
the lowest possible latency.


1793
00:52:54,966 --> 00:52:57,566
Direct to display provides you a


1794
00:52:57,566 --> 00:52:58,946
path to reclaim a little bit of


1795
00:52:58,946 --> 00:53:00,266
GPU performance from the system


1796
00:53:00,366 --> 00:53:01,536
by being aware of what our


1797
00:53:01,536 --> 00:53:02,976
compositors do on your behalf.


1798
00:53:06,156 --> 00:53:07,366
So you'll be able to find the


1799
00:53:07,366 --> 00:53:08,256
video and the slides for this


1800
00:53:08,256 --> 00:53:11,046
session on the WWDC2017 website.


1801
00:53:11,696 --> 00:53:14,926
We have three other sessions on


1802
00:53:14,926 --> 00:53:15,826
Metal 2 this year.


1803
00:53:16,426 --> 00:53:18,366
In particular, tomorrow


1804
00:53:18,366 --> 00:53:19,276
afternoon we're going to have a


1805
00:53:19,276 --> 00:53:20,446
session dedicated to VR and


1806
00:53:20,446 --> 00:53:20,966
Metal 2.


1807
00:53:21,136 --> 00:53:22,716
This is going to go deep into


1808
00:53:22,716 --> 00:53:24,536
what your application needs to


1809
00:53:24,536 --> 00:53:26,286
do and a conceptual overview of


1810
00:53:26,286 --> 00:53:28,256
how to do VR rendering, dive


1811
00:53:28,256 --> 00:53:29,886
into specifically how to do VR


1812
00:53:29,886 --> 00:53:31,936
with the combination of Metal 2


1813
00:53:31,936 --> 00:53:33,756
and the Steam VR toolkit.


1814
00:53:33,756 --> 00:53:35,916
It's also going to go into using


1815
00:53:35,916 --> 00:53:37,156
Metal with external GPU


1816
00:53:37,156 --> 00:53:37,576
hardware.


1817
00:53:39,496 --> 00:53:40,806
On Thursday we have a


1818
00:53:40,946 --> 00:53:42,116
doubleheader starting with Metal


1819
00:53:42,116 --> 00:53:43,506
2 optimization and debugging.


1820
00:53:44,216 --> 00:53:45,536
This is going to go into what's


1821
00:53:45,536 --> 00:53:46,556
new in our developer and


1822
00:53:46,556 --> 00:53:47,936
performance tools and all the


1823
00:53:47,936 --> 00:53:49,166
new workflows that enables to


1824
00:53:49,166 --> 00:53:49,916
help you build the best


1825
00:53:49,916 --> 00:53:50,906
applications possible.


1826
00:53:51,116 --> 00:53:52,646
And it's going to be followed up


1827
00:53:52,646 --> 00:53:54,166
right after that with using


1828
00:53:54,166 --> 00:53:55,106
Metal 2 for compute.


1829
00:53:55,946 --> 00:53:56,946
And that's going to really have


1830
00:53:56,946 --> 00:53:58,726
a big focus this year on using


1831
00:53:58,726 --> 00:54:00,036
the GPU for machine learning


1832
00:54:00,036 --> 00:54:00,746
applications.


1833
00:54:00,746 --> 00:54:01,776
We've added a whole lot this


1834
00:54:01,776 --> 00:54:03,636
year and we want to show you


1835
00:54:03,636 --> 00:54:05,576
everything we've done.


1836
00:54:07,036 --> 00:54:08,226
I want to point you to a couple


1837
00:54:08,226 --> 00:54:10,036
of last year's WWDC sessions.


1838
00:54:11,116 --> 00:54:12,456
The first, What's New in Metal


1839
00:54:12,456 --> 00:54:14,026
Part One is where we did a deep


1840
00:54:14,026 --> 00:54:15,616
dive on resource Heaps.


1841
00:54:16,026 --> 00:54:16,976
And instead if you're looking to


1842
00:54:16,976 --> 00:54:17,856
get the best performance out of


1843
00:54:17,856 --> 00:54:19,666
argument buffers, argument


1844
00:54:19,666 --> 00:54:20,766
buffers and Heaps were built to


1845
00:54:20,766 --> 00:54:22,546
go together and so I highly


1846
00:54:22,546 --> 00:54:23,666
encourage you to go check out


1847
00:54:23,666 --> 00:54:26,156
the video and really -- and, you


1848
00:54:26,266 --> 00:54:28,256
know basically plan your


1849
00:54:28,256 --> 00:54:29,156
application around both of those


1850
00:54:29,156 --> 00:54:29,516
together.


1851
00:54:29,586 --> 00:54:31,066
They cover that in a lot more


1852
00:54:31,066 --> 00:54:32,366
detail than we did here today.


1853
00:54:33,886 --> 00:54:35,846
Second, if the conversation


1854
00:54:35,846 --> 00:54:37,906
about direct to display and wide


1855
00:54:37,906 --> 00:54:39,266
gamut and wide color interested


1856
00:54:39,266 --> 00:54:40,826
you we have a whole session that


1857
00:54:40,826 --> 00:54:41,746
really goes deep into the


1858
00:54:41,746 --> 00:54:42,896
concepts and the specifics


1859
00:54:42,896 --> 00:54:43,896
behind that, we also talked


1860
00:54:43,896 --> 00:54:44,486
about last year.


1861
00:54:45,516 --> 00:54:47,476
With that I think we'll wrap it


1862
00:54:47,476 --> 00:54:47,596
up.


1863
00:54:47,596 --> 00:54:48,686
I thank you for all attending


1864
00:54:48,686 --> 00:54:49,396
and I hope you enjoy the


1865
00:54:49,396 --> 00:54:50,066
remainder of your week.


1866
00:54:50,066 --> 00:54:50,976
So thank you.


1867
00:54:51,516 --> 00:54:55,500
[ Applause ]

