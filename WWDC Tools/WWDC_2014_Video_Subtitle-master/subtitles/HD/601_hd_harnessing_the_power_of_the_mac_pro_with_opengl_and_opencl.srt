1
00:00:00,506 --> 00:00:12,456
[ Music ]


2
00:00:12,956 --> 00:00:15,296
>> Good morning and
welcome to the session.


3
00:00:15,966 --> 00:00:18,886
My name is Abe Stephens,
and I'm an engineer


4
00:00:18,886 --> 00:00:22,156
in the GPU Frameworks Team
at Apple, and this morning,


5
00:00:22,156 --> 00:00:24,686
I'm going to tell you
about how to take advantage


6
00:00:24,686 --> 00:00:27,396
of the New Mac Pro Workstation,


7
00:00:27,396 --> 00:00:29,856
which is a really
exciting platform to work


8
00:00:29,856 --> 00:00:34,176
with for graphics and
compute applications.


9
00:00:34,176 --> 00:00:39,146
We're going to talk a
little bit about the Mac Pro


10
00:00:39,146 --> 00:00:42,016
and the hardware
that it contains


11
00:00:42,016 --> 00:00:44,596
and the hardware
that's available


12
00:00:44,676 --> 00:00:45,706
for you as a programmer.


13
00:00:46,216 --> 00:00:49,516
Then we're going to take a
look at some of the graphics


14
00:00:49,586 --> 00:00:54,456
and general purpose GPU
compute APIs that you'll use


15
00:00:54,456 --> 00:00:57,206
to program on this computer.


16
00:00:57,946 --> 00:01:01,006
And then, at the end of the
talk, we're going to take a look


17
00:01:01,006 --> 00:01:03,976
at some common patterns
that you might follow


18
00:01:03,976 --> 00:01:07,116
when you're writing an
application to take advantage


19
00:01:07,116 --> 00:01:09,726
of the hardware that's
available in this configuration.


20
00:01:09,726 --> 00:01:16,066
So let's take a look at-let's
take a look at the Mac Pro.


21
00:01:16,476 --> 00:01:19,616
And as you can see here, this
is actually the Mac Pro tower


22
00:01:19,616 --> 00:01:23,156
and the new desktop.


23
00:01:23,156 --> 00:01:27,306
And the tower's actually
eight times larger


24
00:01:27,306 --> 00:01:31,356
than the new workstation
and it actually is only


25
00:01:31,356 --> 00:01:32,886
about four times heavier.


26
00:01:32,886 --> 00:01:36,516
And so there's a lot
of hardware packed


27
00:01:36,516 --> 00:01:37,866
into a very small package.


28
00:01:38,106 --> 00:01:40,956
And if you're an application
developer, you know,


29
00:01:40,956 --> 00:01:44,786
this means that someone can
have a very powerful workstation


30
00:01:44,786 --> 00:01:47,706
sitting on their desk
that you can - you know,


31
00:01:47,706 --> 00:01:52,546
that can run a pretty
high-performance application


32
00:01:52,926 --> 00:01:54,636
and in a much smaller
form factor


33
00:01:54,666 --> 00:01:58,316
than the tower, the
tower system.


34
00:01:58,726 --> 00:02:02,266
If we take a look at this
computer in some detail,


35
00:02:02,606 --> 00:02:05,596
probably the most exciting thing
as a graphics programmer is


36
00:02:05,596 --> 00:02:09,816
that the Mac Pro has two
GPUs in every configuration.


37
00:02:10,256 --> 00:02:12,966
And these are two
identical devices.


38
00:02:12,966 --> 00:02:15,656
So, in the tower Mac Pro,


39
00:02:16,116 --> 00:02:18,986
you could-a customer could
configure this system


40
00:02:18,986 --> 00:02:22,296
to have multiple GPUs and
there are actually cases


41
00:02:22,296 --> 00:02:26,816
in that system where you might
end up with two different GPUs


42
00:02:26,816 --> 00:02:30,106
that were from different
vendors.


43
00:02:30,476 --> 00:02:32,826
In the new Mac Pro, you always -


44
00:02:32,826 --> 00:02:35,806
your application will always
have two identical GPUs


45
00:02:35,806 --> 00:02:37,296
available to use.


46
00:02:37,796 --> 00:02:41,056
And as we'll see in a little
while, that's - you know,


47
00:02:41,156 --> 00:02:42,996
that's kind of an
advantage because it means


48
00:02:42,996 --> 00:02:45,156
that you don't have to or
your application doesn't have


49
00:02:45,156 --> 00:02:49,566
to have a lot of logic to query
and find out if the capabilities


50
00:02:49,566 --> 00:02:51,886
of the available
GPUs are different.


51
00:02:51,886 --> 00:02:53,716
You can write to
a single platform.


52
00:02:54,076 --> 00:02:57,056
And then there are some very
specific things that you can do


53
00:02:57,056 --> 00:02:59,076
to distinguish the two devices.


54
00:02:59,456 --> 00:03:03,526
In this configuration, one of
the GPUs is directly connected


55
00:03:03,526 --> 00:03:06,236
to the display hardware,
and the other GPU isn't.


56
00:03:06,596 --> 00:03:07,956
And so there's some
specific things


57
00:03:07,956 --> 00:03:10,296
that your application
can do that you can write


58
00:03:10,296 --> 00:03:13,036
into your application to
take advantage of that


59
00:03:13,216 --> 00:03:17,076
and to make sure that when you
are sending work, graphics work,


60
00:03:17,076 --> 00:03:19,506
or compute work to
one of the GPUs,


61
00:03:19,506 --> 00:03:22,536
you know which one is
connected to the display.


62
00:03:23,236 --> 00:03:29,196
So inside this configuration,
the GPUs have


63
00:03:29,196 --> 00:03:32,716
about two thousand
stream processors.


64
00:03:32,716 --> 00:03:36,126
That's important if
you're working with OpenCL


65
00:03:36,126 --> 00:03:38,716
to do general purpose
GPU compute work.


66
00:03:39,066 --> 00:03:42,066
The configuration that
we'll be looking at today


67
00:03:42,066 --> 00:03:45,446
when we show a demo later on
has six gigabytes of memory


68
00:03:45,496 --> 00:03:49,186
and 3.5 teraflops peak.


69
00:03:49,446 --> 00:03:51,366
And so it's a very
capable package


70
00:03:51,366 --> 00:03:54,706
for graphics and
for GPU compute.


71
00:03:55,536 --> 00:04:01,666
So now I'd like to explain some
of the APIs that you can use


72
00:04:01,666 --> 00:04:05,276
to program this configuration.


73
00:04:05,656 --> 00:04:08,806
And if you're - if you've
worked with Apple Graphics


74
00:04:08,806 --> 00:04:11,996
or Compute before, these
will be familiar to you.


75
00:04:12,196 --> 00:04:16,976
Actually, you've probably used
OpenCL and OpenGL on - say,


76
00:04:16,976 --> 00:04:21,326
an ordinary laptop or on a
single GPU system in the past.


77
00:04:21,326 --> 00:04:25,576
Maybe you've even worked with a
tower Mac Pro and done multi-GPU


78
00:04:25,576 --> 00:04:26,966
or multi-display programming.


79
00:04:27,476 --> 00:04:29,956
What I'm going to talk
about in this session is,


80
00:04:30,566 --> 00:04:33,606
the parts of those APIs that
you have to pay attention to


81
00:04:33,606 --> 00:04:35,906
and that you have to
use when you are setting


82
00:04:35,906 --> 00:04:39,066
up an application to use
this Mac Pro configuration,


83
00:04:39,066 --> 00:04:41,656
because it's a little
bit different than some


84
00:04:41,736 --> 00:04:44,756
of the other configurations
that have been available


85
00:04:44,756 --> 00:04:47,686
in the Mac platform in the past.


86
00:04:48,036 --> 00:04:50,666
Okay, so let's take a look
at the Software Stack.


87
00:04:51,536 --> 00:04:54,716
So on top of the Software
Stack, is your application.


88
00:04:54,716 --> 00:04:57,956
So this is your code
that you've implemented


89
00:04:57,956 --> 00:05:00,076
and this might be a
graphics application


90
00:05:00,076 --> 00:05:02,166
that does some type
of 3D rendering.


91
00:05:02,166 --> 00:05:04,716
It could be an application
that's doing say,


92
00:05:04,716 --> 00:05:07,976
image processing or video
processing using OpenCL


93
00:05:08,246 --> 00:05:10,476
or GPU - for GPU compute.


94
00:05:10,686 --> 00:05:12,536
Maybe your application
does a little bit of OpenCL


95
00:05:12,576 --> 00:05:15,616
and a little bit of OpenGL to
fully take advantage of the GPU.


96
00:05:16,456 --> 00:05:20,276
Anyway, the first sort of
level of GPU programming


97
00:05:20,276 --> 00:05:23,616
that you might have in
your app is some Cocoa code


98
00:05:23,616 --> 00:05:29,506
that is using an
NSOpenGLView or a CAOpenGLLayer.


99
00:05:29,966 --> 00:05:35,106
And I'm going to show you
how to configure this level


100
00:05:35,106 --> 00:05:39,496
of the software to correctly set
up or to set up your application


101
00:05:39,806 --> 00:05:42,176
to take advantage of the
two GPUs in the Mac Pro


102
00:05:42,176 --> 00:05:43,196
in the most efficient way.


103
00:05:43,236 --> 00:05:46,446
And then on top of
the next sort of level


104
00:05:46,446 --> 00:05:50,036
on this stack are a
number of lower level APIs.


105
00:05:50,856 --> 00:05:54,016
The CGL API is something
that you may be familiar


106
00:05:54,016 --> 00:05:56,766
with in the Mac from
other systems.


107
00:05:57,026 --> 00:06:01,606
It's a lower level API that you
can use to configure the GPU


108
00:06:01,606 --> 00:06:04,526
and to find out information
about the displays


109
00:06:04,656 --> 00:06:07,356
and the hardware
that's in the system.


110
00:06:07,766 --> 00:06:10,236
Then, the few other
sort of programming APIs


111
00:06:10,236 --> 00:06:14,206
that you're quite familiar
with, OpenCL and OpenGL,


112
00:06:14,206 --> 00:06:19,336
which are the APIs that you'll
end up writing a lot of the code


113
00:06:19,336 --> 00:06:24,576
that dispatches work to the GPU
and also the kernels and shaders


114
00:06:24,576 --> 00:06:26,926
that are executed
on the GPU itself.


115
00:06:26,926 --> 00:06:31,416
And then of course,
underneath OpenCL and OpenGL,


116
00:06:31,416 --> 00:06:32,496
there's some graphics drivers.


117
00:06:32,766 --> 00:06:34,676
And these graphics
drivers are handling things


118
00:06:34,676 --> 00:06:38,256
like allocating memory on
the devices and moving memory


119
00:06:38,836 --> 00:06:40,436
between the host and the device.


120
00:06:40,436 --> 00:06:44,766
And we'll look at certain
parts of the driver that end


121
00:06:44,846 --> 00:06:47,286
up performing some of the
standard movement for us


122
00:06:47,286 --> 00:06:50,216
and we'll try to understand
exactly how this will impact the


123
00:06:50,216 --> 00:06:51,676
way that we design applications.


124
00:06:52,406 --> 00:06:54,646
So now I'm going to
talk about OpenCL


125
00:06:54,646 --> 00:06:57,146
and OpenGL in some detail.


126
00:06:57,146 --> 00:07:01,056
And most of the programming that
we'll see in a little while,


127
00:07:01,186 --> 00:07:04,316
is going to focus on
this level of the stack.


128
00:07:04,396 --> 00:07:06,786
The CGL, OpenCL and
OpenGL layer.


129
00:07:07,606 --> 00:07:11,156
So, on the Mac Pro,
we support OpenGL.


130
00:07:11,356 --> 00:07:15,336
It's our accelerated
3D rendering API.


131
00:07:15,436 --> 00:07:20,896
And we support OpenGL 4.1
Core Profile and the shaders


132
00:07:20,896 --> 00:07:23,786
that you write that are
executed on the GPU are written


133
00:07:23,786 --> 00:07:25,466
in a language called GLSL.


134
00:07:25,466 --> 00:07:28,956
And we support version 4.10.


135
00:07:29,396 --> 00:07:32,616
And, OpenCL is the data
parallel programming API


136
00:07:32,806 --> 00:07:34,576
that the Mac Pro supports.


137
00:07:35,386 --> 00:07:41,116
And it is-the version that
is supported is OpenCL 1.2


138
00:07:41,116 --> 00:07:42,416
with a number of extensions.


139
00:07:42,876 --> 00:07:49,346
So the Mac Pro has a pretty
advanced AMD graphics card, er,


140
00:07:49,346 --> 00:07:50,676
a pair of AMD graphics cards.


141
00:07:51,016 --> 00:07:53,166
And there are a couple
extensions that are supported,


142
00:07:53,166 --> 00:07:56,666
so on the Mac Pro you
can use double precision.


143
00:07:57,136 --> 00:07:59,626
And there's actually an
extension that allows you


144
00:07:59,626 --> 00:08:03,536
to set the priority of
the OpenCL command queues


145
00:08:03,536 --> 00:08:07,236
that are used when you
enqueue work onto the GPU.


146
00:08:07,236 --> 00:08:09,726
And so for example,
on this configuration,


147
00:08:09,726 --> 00:08:13,566
you can set up a work or
an OpenCL command queue


148
00:08:13,656 --> 00:08:16,346
for background priority work.


149
00:08:16,716 --> 00:08:19,086
Say, for example, if you
are performing an operation


150
00:08:19,086 --> 00:08:23,176
that isn't related to the
GUI and can be performed


151
00:08:23,426 --> 00:08:26,096
at a lower priority, maybe
you're applying some type


152
00:08:26,096 --> 00:08:30,426
of final render to an image
processing application,


153
00:08:30,426 --> 00:08:33,436
you can send that work off
to a lower priority queue.


154
00:08:33,966 --> 00:08:39,116
And then a if higher priority
work comes to the GPU,


155
00:08:39,416 --> 00:08:42,996
that work won't interfere-or
the lower priority work won't


156
00:08:42,996 --> 00:08:48,016
interfere, say, with rendering
work that was being used


157
00:08:48,016 --> 00:08:49,356
to display the GUI
in the system.


158
00:08:50,076 --> 00:08:56,116
And so, if you take advantage of
these extensions, you can work


159
00:08:56,116 --> 00:08:59,896
around some of the
challenges that we'll talk


160
00:08:59,896 --> 00:09:00,906
about in a little while.


161
00:09:01,626 --> 00:09:10,126
Okay, so when you have this
computer and the GPUs that are


162
00:09:10,126 --> 00:09:15,266
in it, you can do a couple
different things actually.


163
00:09:15,266 --> 00:09:18,596
You can take advantage
of this second device.


164
00:09:18,996 --> 00:09:21,826
One thing that you can do is
you can take, say, the OpenCL,


165
00:09:22,216 --> 00:09:26,026
the compute portion of your
application and simply run


166
00:09:26,026 --> 00:09:29,246
that compute portion
on the second device,


167
00:09:29,246 --> 00:09:32,566
and let the primary GPU
be continued to be used


168
00:09:32,636 --> 00:09:37,956
for GUI rendering and for
maybe OpenGL 3D graphics.


169
00:09:38,516 --> 00:09:42,346
And this is actually
a relatively easy type


170
00:09:42,346 --> 00:09:43,416
of operation to perform.


171
00:09:43,416 --> 00:09:47,616
You can sort of offload
compute work to the second GPU.


172
00:09:47,616 --> 00:09:50,106
This is kind of similar to
if you took an application


173
00:09:50,106 --> 00:09:52,246
to where you were, say, running
most of your compute work


174
00:09:52,246 --> 00:09:55,946
on the CPU and you decided
to move some of that work


175
00:09:55,946 --> 00:09:58,326
from the CPU off
to a GPU in OpenCL,


176
00:09:58,656 --> 00:10:00,446
we would perform
the same operation.


177
00:10:00,446 --> 00:10:01,526
We'd take that compute work


178
00:10:01,526 --> 00:10:03,466
and just move it to
the secondary GPU.


179
00:10:04,126 --> 00:10:09,216
Another common design or another
common task that you might use


180
00:10:09,216 --> 00:10:11,526
for the Mac Pro is to
perform off-screen rendering


181
00:10:11,526 --> 00:10:11,976
on the second GPU.


182
00:10:12,206 --> 00:10:17,506
So, if you were going to
do some type OpenGL work,


183
00:10:17,986 --> 00:10:21,366
and that the results of that
work don't necessarily have


184
00:10:21,366 --> 00:10:25,596
to be displayed, every single
frame, that's a great candidate


185
00:10:25,596 --> 00:10:28,646
for moving to the
secondary GPU as well.


186
00:10:28,826 --> 00:10:30,186
And we'll take a
look at an example


187
00:10:30,186 --> 00:10:31,596
of that in a little while.


188
00:10:32,776 --> 00:10:35,856
So let me tell you about how
to set up your application


189
00:10:35,856 --> 00:10:40,646
to use this configuration and
to take advantage of both GPUs.


190
00:10:40,646 --> 00:10:43,606
And it's important to know that,


191
00:10:44,286 --> 00:10:46,646
if you have an application
that's running on a Mac


192
00:10:46,946 --> 00:10:50,086
and using OpenCL and
OpenGL, it will run just fine


193
00:10:50,316 --> 00:10:52,826
on the new Mac Pro, but
there are a couple things


194
00:10:52,826 --> 00:10:54,026
that you can do to make sure


195
00:10:54,026 --> 00:10:57,466
that it's using one
GPU or the other.


196
00:10:57,946 --> 00:11:01,576
And also a couple things
that you can do to make sure


197
00:11:01,576 --> 00:11:04,486
that if it's possible, you
can divide your application


198
00:11:04,486 --> 00:11:08,636
into pieces and run one piece
of the work on the first GPU


199
00:11:08,636 --> 00:11:10,396
and the other piece of
the work on the second GPU


200
00:11:10,666 --> 00:11:11,876
with a small number of changes.


201
00:11:11,876 --> 00:11:16,066
So to get started with
modifying the application,


202
00:11:16,066 --> 00:11:18,866
there are a number or steps
that you can go through.


203
00:11:18,866 --> 00:11:19,776
There are four steps.


204
00:11:20,776 --> 00:11:23,216
There's creating the
context that you're using.


205
00:11:23,686 --> 00:11:26,636
This is either the
OpenCL context


206
00:11:26,636 --> 00:11:28,856
or the OpenGL context
in a specific way.


207
00:11:28,886 --> 00:11:32,306
And if you follow
this procedure,


208
00:11:32,706 --> 00:11:36,226
the runtime in the system
will be able to do a lot


209
00:11:36,286 --> 00:11:38,186
of the tasks associated
with moving data


210
00:11:38,186 --> 00:11:41,676
between the two devices and
between the host automatically.


211
00:11:42,246 --> 00:11:48,496
Then, your application
should identify what happens


212
00:11:48,646 --> 00:11:51,946
or actually it should identify
which device is the primary GPU


213
00:11:51,946 --> 00:11:53,346
and which is the secondary GPU.


214
00:11:53,346 --> 00:11:55,746
Then once you've
figured that out,


215
00:11:55,786 --> 00:11:58,986
you can dispatch work
in a particular way.


216
00:11:58,986 --> 00:12:00,176
And I'll show you
how to do that.


217
00:12:00,296 --> 00:12:03,356
The way that you select
the GPU and send work


218
00:12:03,356 --> 00:12:06,956
to it is a little bit
different in OpenCL and OpenGL.


219
00:12:06,956 --> 00:12:10,916
And then after you've done
that, you can synchronize data


220
00:12:11,286 --> 00:12:14,286
between the two devices
or offload data


221
00:12:14,286 --> 00:12:18,226
from the secondary GPU to
the host's main memory.


222
00:12:19,146 --> 00:12:22,696
So, let's take a look
now at context creation.


223
00:12:23,276 --> 00:12:28,626
And it turns out that this
process is, it's similar


224
00:12:28,626 --> 00:12:30,326
in OpenCL and OpenGL,


225
00:12:30,326 --> 00:12:33,096
but there's some specific
terminology that I'd like to go


226
00:12:33,096 --> 00:12:37,116
over that I think will make the
process a little bit more clear.


227
00:12:38,206 --> 00:12:43,776
So before we showed the
Software Stack, now we're going


228
00:12:43,776 --> 00:12:48,496
to concentrate on the
graphics APIs in the stack.


229
00:12:48,526 --> 00:12:54,196
So, OpenGL is our graphics
API and, like I said before,


230
00:12:54,396 --> 00:12:56,926
CGL is this API that we use.


231
00:12:56,926 --> 00:12:59,306
It's a Mac platform API.


232
00:12:59,876 --> 00:13:03,056
And we use it to set
up our OpenGL context


233
00:13:03,286 --> 00:13:05,886
and to select devices
in the system and figure


234
00:13:05,886 --> 00:13:09,266
out get some information
about the hardware that's


235
00:13:09,266 --> 00:13:11,146
in the system, the
devices and the renderers.


236
00:13:11,516 --> 00:13:16,276
And we also have OpenCL, and
it turns out that, in OpenCL,


237
00:13:16,276 --> 00:13:20,466
a lot of the operations that we
were going to perform in CGL,


238
00:13:20,466 --> 00:13:22,356
about learning about displays


239
00:13:22,356 --> 00:13:26,006
and devices are actually
included in that OpenCL API.


240
00:13:26,306 --> 00:13:29,916
And so as I walk through this,
I'm going to show you an example


241
00:13:29,916 --> 00:13:35,006
of how to perform an operation
using the graphics APIs,


242
00:13:35,216 --> 00:13:36,606
OpenGL and CGL.


243
00:13:36,606 --> 00:13:38,026
And then I'll also show you how


244
00:13:38,026 --> 00:13:40,456
to perform the same
operation using OpenCL.


245
00:13:41,106 --> 00:13:42,236
And in most cases,


246
00:13:42,266 --> 00:13:45,506
we're performing very
similar tasks or operations.


247
00:13:45,506 --> 00:13:51,266
We're just using two
different APIs to do that.


248
00:13:51,486 --> 00:13:53,466
Okay, so the first
thing to think


249
00:13:53,466 --> 00:13:57,906
about in OpenGL is the notion
of a piece of hardware.


250
00:13:58,286 --> 00:14:01,656
And in OpenGL, there
are a certain number


251
00:14:01,656 --> 00:14:03,046
of renderers in the system.


252
00:14:03,566 --> 00:14:06,566
And each renderer is
assigned a render ID number.


253
00:14:07,266 --> 00:14:11,746
So for example, in the Mac Pro,
there's going to be one renderer


254
00:14:11,746 --> 00:14:15,476
for each of the GPUs, and then
there will also be a software


255
00:14:15,476 --> 00:14:17,966
fallback renderer that's
available on all Macs


256
00:14:18,386 --> 00:14:22,506
that the system can
use if, for example,


257
00:14:22,506 --> 00:14:24,166
if you were on a configuration


258
00:14:24,166 --> 00:14:28,326
that didn't have hardware
support for a certain feature,


259
00:14:28,326 --> 00:14:32,176
the system might fall back
to this software renderer.


260
00:14:32,326 --> 00:14:34,956
And so, if you look at the
render IDs in the system,


261
00:14:34,956 --> 00:14:40,706
you'd see two render IDs for the
two discreet GPUs, and then one


262
00:14:41,006 --> 00:14:45,686
for the software renderer GPU.


263
00:14:46,356 --> 00:14:49,966
So when you start to
set up an OpenGL context


264
00:14:50,376 --> 00:14:55,366
and an OpenGL application, you
have to figure out how to select


265
00:14:55,366 --> 00:14:56,826
between all of these
different renderers


266
00:14:56,826 --> 00:14:58,476
and these different
render IDs in the system.


267
00:14:58,786 --> 00:15:03,076
And in OpenGL, you do that
by putting together a list


268
00:15:03,076 --> 00:15:03,906
of attributes.


269
00:15:04,166 --> 00:15:05,906
These are called pixel
format attributes.


270
00:15:06,016 --> 00:15:09,746
And these are things like, does
the renderer you're looking


271
00:15:09,826 --> 00:15:11,246
for support double buffering?


272
00:15:11,716 --> 00:15:15,946
Does it support a
certain color format


273
00:15:16,056 --> 00:15:17,976
or a certain depth format?


274
00:15:17,976 --> 00:15:21,416
Does it support Core profile
or legacy profile OpenGL?


275
00:15:21,776 --> 00:15:24,336
Anyway, you put together
this list of attributes


276
00:15:24,716 --> 00:15:29,516
and one important attribute for
setting up an OpenGL application


277
00:15:29,516 --> 00:15:32,986
on the new Mac Pro is the
offline renderers attribute.


278
00:15:33,296 --> 00:15:36,616
Now, the Mac Pro
has two GPUs and one


279
00:15:36,616 --> 00:15:38,806
of those GPUs is
always connected


280
00:15:38,976 --> 00:15:41,776
to the display hardware
that's in the Mac Pro.


281
00:15:41,986 --> 00:15:43,066
The other GPU isn't.


282
00:15:43,566 --> 00:15:46,816
And the terminology for
this on the Mac platform is


283
00:15:46,816 --> 00:15:50,426
that the display connected
GPU is considered "online",


284
00:15:50,906 --> 00:15:53,216
and the GPU that's not connected


285
00:15:53,266 --> 00:15:55,676
to the display is
considered "offline".


286
00:15:56,026 --> 00:15:59,896
Now, it turns out that you
know, both GPUs are powered up


287
00:15:59,896 --> 00:16:03,316
and both can perform rendering
and compute operations,


288
00:16:03,366 --> 00:16:05,936
but the terminology is that
the one that's connected


289
00:16:05,936 --> 00:16:08,286
to the display hardware
is "online",


290
00:16:08,596 --> 00:16:09,836
and the other one's "offline".


291
00:16:10,016 --> 00:16:13,886
So we when we put together a
pixel format attribute list,


292
00:16:14,336 --> 00:16:17,026
we add an attribute
that says that we want


293
00:16:17,066 --> 00:16:20,136
to include offline renderers.


294
00:16:20,416 --> 00:16:24,436
And then, when we send
that into the system


295
00:16:24,436 --> 00:16:27,496
and we call the Choose
Pixel Format API routine,


296
00:16:27,636 --> 00:16:29,996
and we'll look at that in a
second at what that looks like.


297
00:16:30,396 --> 00:16:32,816
We're going to get back
a list of the renderers


298
00:16:33,106 --> 00:16:34,756
of all the renderers
in the system.


299
00:16:34,756 --> 00:16:38,276
In this case, we're going to
get both GPUs - the online GPU


300
00:16:38,276 --> 00:16:42,066
and the offline GPU and
then the software renderer.


301
00:16:42,066 --> 00:16:45,746
Now, the next step in this
context creation process is


302
00:16:45,976 --> 00:16:47,496
to actually create the context.


303
00:16:47,496 --> 00:16:50,776
And this is really just
a container that points


304
00:16:50,776 --> 00:16:53,916
to these renderers and
associates state with them.


305
00:16:53,916 --> 00:16:56,006
So there's a lot of
state in the OpenGL API


306
00:16:56,006 --> 00:17:00,196
and that state is associated
with this context object.


307
00:17:00,946 --> 00:17:06,836
Now, once we have a context,
we need a way for that context


308
00:17:06,925 --> 00:17:09,476
to refer back to the renderers.


309
00:17:09,536 --> 00:17:11,086
And this is actually
a difference


310
00:17:11,086 --> 00:17:12,876
between OpenCL and OpenGL.


311
00:17:13,296 --> 00:17:19,406
In OpenGL, the context assigns
virtual screen numbers to each


312
00:17:19,406 --> 00:17:21,136
of the renderers that
are in the system.


313
00:17:21,496 --> 00:17:23,986
And so here we have a
context with three renderers,


314
00:17:23,986 --> 00:17:27,705
and we have virtual screen
numbers, zero through two.


315
00:17:28,415 --> 00:17:31,776
Now, the last piece of
terminology I want to go


316
00:17:31,776 --> 00:17:34,286
over in OpenGL before
we start talking


317
00:17:34,286 --> 00:17:37,556
about OpenCL, is
the share group.


318
00:17:37,916 --> 00:17:41,286
If you have a context,
now remember,


319
00:17:41,286 --> 00:17:42,946
a context is that
state container.


320
00:17:43,396 --> 00:17:46,846
If you have a context, and
you want to set some state


321
00:17:46,846 --> 00:17:49,736
and create some objects
and then maybe you decide


322
00:17:49,736 --> 00:17:53,116
that you need another thread
to do some OpenGL work


323
00:17:53,396 --> 00:17:55,436
and maybe it's going to have
slightly different state,


324
00:17:55,786 --> 00:17:59,346
you can create another
context that has the same set


325
00:17:59,346 --> 00:18:03,676
of renderers in it
and can share objects,


326
00:18:04,506 --> 00:18:05,766
serve buffers and textures.


327
00:18:06,126 --> 00:18:09,386
And you would obtain a share
group from the first context


328
00:18:09,386 --> 00:18:12,886
and use that to create
or to communicate


329
00:18:12,886 --> 00:18:14,046
with a second context.


330
00:18:14,386 --> 00:18:17,436
So a share group in
OpenGL terminology


331
00:18:17,836 --> 00:18:20,696
and CGL terminology
is this entity


332
00:18:20,696 --> 00:18:24,966
that lets you bridge
two OpenGL contexts.


333
00:18:25,266 --> 00:18:28,156
And that's important because,
as we'll see in a second,


334
00:18:28,486 --> 00:18:32,556
we can also use that share
group to communicate its objects


335
00:18:32,556 --> 00:18:35,546
and state between
OpenGL and OpenCL.


336
00:18:36,136 --> 00:18:40,876
Okay, so let's look at what
the equivalent operations


337
00:18:41,006 --> 00:18:44,486
and components are
of the OpenCL API.


338
00:18:44,656 --> 00:18:50,286
Now, OpenCL has device IDs which
are kind of like renderers.


339
00:18:50,286 --> 00:18:56,006
A CL context object, that's
a lot like that GL context,


340
00:18:56,006 --> 00:18:59,256
and then a command queue, which
as it turns out is a little bit


341
00:18:59,256 --> 00:19:00,316
like the virtual screen.


342
00:19:00,316 --> 00:19:01,586
We use it in a similar way.


343
00:19:02,166 --> 00:19:04,906
The API is presented in a
slightly different fashion,


344
00:19:04,906 --> 00:19:07,216
but these operations
are very similar.


345
00:19:07,216 --> 00:19:11,626
Now, our CL context is
something-it's a lot


346
00:19:11,626 --> 00:19:13,856
like a GL context.


347
00:19:14,206 --> 00:19:18,586
It turns out, when we
set up our CL context,


348
00:19:18,586 --> 00:19:21,066
we actually are going to set
it up using, in some cases,


349
00:19:21,366 --> 00:19:24,306
a share group that we
obtain from a GL context.


350
00:19:24,306 --> 00:19:26,766
And I'll show you what that
looks like in just a moment.


351
00:19:27,586 --> 00:19:30,926
Okay so, now that I've
described the terminology,


352
00:19:30,926 --> 00:19:33,346
and remember the, you know,
the term-there's a lot


353
00:19:33,346 --> 00:19:36,956
of terminology in OpenGL
and there's some terminology


354
00:19:36,956 --> 00:19:40,546
in OpenCL, but the two
APIs are performing very


355
00:19:40,546 --> 00:19:41,556
similar operations.


356
00:19:41,836 --> 00:19:44,116
Let's take a look at the
API that you have to use


357
00:19:44,476 --> 00:19:48,206
when you set up, when you start
to set up your application


358
00:19:48,206 --> 00:19:51,876
for working on the Mac Pro
with OpenCL and OpenGL.


359
00:19:51,876 --> 00:19:53,186
So, let's say that we're


360
00:19:53,186 --> 00:19:57,306
in an application that's using
an NSOpenGLView in Cocoa.


361
00:19:58,106 --> 00:20:02,216
Now, I'm going to create
an NSOpenGLView and I'd


362
00:20:02,216 --> 00:20:03,746
like to use the Core profile.


363
00:20:04,246 --> 00:20:06,956
So I'd like to use the
newest features in OpenGL.


364
00:20:07,046 --> 00:20:09,096
And so I'd like to make sure


365
00:20:09,096 --> 00:20:12,406
that I get a Core
profile OpenGL context.


366
00:20:12,636 --> 00:20:15,796
And in order to do that
with an NSOpenGLView,


367
00:20:15,796 --> 00:20:21,226
I have to implement my
own NSOpenGLView class


368
00:20:21,276 --> 00:20:24,406
that is derived from
the Cocoa base class.


369
00:20:24,826 --> 00:20:29,066
And then I would
implement my own version


370
00:20:29,176 --> 00:20:32,566
of the initWithFrame
method and in that function,


371
00:20:32,566 --> 00:20:35,486
I'm going to set up my
pixel formal attribute list.


372
00:20:36,096 --> 00:20:38,166
And as you can see
here, at the top,


373
00:20:38,586 --> 00:20:43,036
I included the Core
profile attribute and then


374
00:20:43,086 --> 00:20:45,246
at the very bottom-and
this is the important piece


375
00:20:45,246 --> 00:20:48,876
for the Mac Pro-at the bottom,
I also said that I wanted


376
00:20:48,876 --> 00:20:50,376
to allow offline renderers.


377
00:20:50,376 --> 00:20:54,856
And now when I create a GL
context using this pixel format


378
00:20:54,856 --> 00:20:59,336
attribute list by passing it up
to the super class, when I go


379
00:20:59,336 --> 00:21:03,086
and do that, I'll get a context
object initialize that has all


380
00:21:03,086 --> 00:21:04,336
of the devices in the system.


381
00:21:04,666 --> 00:21:07,316
And that's really
the important part.


382
00:21:07,426 --> 00:21:09,746
Okay, let's see how
to do that in OpenCL.


383
00:21:09,746 --> 00:21:14,476
Well, if you're in an
ordinary OpenCL application,


384
00:21:14,476 --> 00:21:16,956
that's an application
that is just going


385
00:21:16,956 --> 00:21:20,536
to do some OpenCL programming,
it's not going to do anything


386
00:21:20,866 --> 00:21:24,106
where there is sharing
between OpenCL and OpenGL.


387
00:21:24,106 --> 00:21:27,636
The easiest way to get a context
that has all the GPU devices


388
00:21:27,706 --> 00:21:30,066
in it, is just to create
a context with a type.


389
00:21:30,796 --> 00:21:33,776
So here, I'm calling
clCreateContextWithType


390
00:21:33,776 --> 00:21:36,806
and I'm asking for CL Type GPU.


391
00:21:37,026 --> 00:21:39,606
That's going to give me a
CL context that contains all


392
00:21:39,606 --> 00:21:40,776
of the GPUs in the system.


393
00:21:41,436 --> 00:21:43,916
On the Mac Pro, that means
that I'm going to get a context


394
00:21:43,916 --> 00:21:47,826
that has two device IDs, one
for each of the discreet GPUs.


395
00:21:47,996 --> 00:21:50,766
Now, if we were in an
application that was going


396
00:21:50,766 --> 00:21:53,096
to do some OpenCL
and some OpenGL,


397
00:21:53,426 --> 00:21:55,616
and those operations were going
to interact with each other,


398
00:21:56,066 --> 00:21:59,156
I'd want to create a context
in a slightly different way.


399
00:21:59,916 --> 00:22:03,136
So here what I'm doing,
is I've created already


400
00:22:03,336 --> 00:22:09,276
in my previous slide, I
set up my NSOpenGLView.


401
00:22:09,616 --> 00:22:12,906
And then I would obtain
the context object


402
00:22:12,906 --> 00:22:15,216
from that NSOpenGLView.


403
00:22:15,416 --> 00:22:18,116
And then you can see here,
I'm using the CGL API


404
00:22:18,766 --> 00:22:24,526
to get the share group that is
associated with that GL context.


405
00:22:25,086 --> 00:22:27,616
Then I take the share group,
remember the share group is


406
00:22:27,616 --> 00:22:32,736
that entity that we use to
create a pair of contexts


407
00:22:32,736 --> 00:22:35,736
that operate on the same objects
and use the same devices.


408
00:22:36,496 --> 00:22:39,916
I use that share group
now with clCreateContext


409
00:22:40,416 --> 00:22:44,656
and another property list
to create a CL context


410
00:22:44,656 --> 00:22:47,216
that contains the
same devices that were


411
00:22:47,216 --> 00:22:49,726
in that original GL context.


412
00:22:49,726 --> 00:22:51,026
And now what I'm going
to do is I'm going to end


413
00:22:51,026 --> 00:22:54,476
up with my CL context here, C,


414
00:22:54,736 --> 00:22:57,336
that contains all the
GPUs in the Mac Pro.


415
00:22:57,336 --> 00:22:58,756
And that's really
the important part.


416
00:22:58,756 --> 00:23:02,856
It's very important that
I always create a context


417
00:23:02,986 --> 00:23:06,806
in either API or in this case,
I've created a GL context


418
00:23:06,806 --> 00:23:08,116
and then a CL context


419
00:23:08,836 --> 00:23:11,626
that contains all the
devices in the system.


420
00:23:12,106 --> 00:23:14,806
Okay, so now that
I've done this,


421
00:23:14,806 --> 00:23:18,366
now that I have this very
versatile and flexible context,


422
00:23:18,636 --> 00:23:22,416
the next step is to take a
look inside it and figure


423
00:23:22,416 --> 00:23:25,886
out which device
corresponds to the primary GPU


424
00:23:25,886 --> 00:23:28,476
and which device corresponds
to the secondary GPU.


425
00:23:28,936 --> 00:23:32,086
And so that's important
because, if I'm doing a task


426
00:23:32,156 --> 00:23:34,866
that is going to be, the
results of which are going


427
00:23:34,866 --> 00:23:36,836
to be displayed on the screen,
it might make sense for me


428
00:23:36,836 --> 00:23:39,466
to use the primary GPU first


429
00:23:40,086 --> 00:23:42,286
because it's directly
connected to display hardware.


430
00:23:42,486 --> 00:23:46,156
And then maybe if I have a task
that isn't related to the GUI


431
00:23:46,156 --> 00:23:49,616
or isn't related to the display,
I might want to always send


432
00:23:49,616 --> 00:23:51,846
that task to the secondary GPU.


433
00:23:52,296 --> 00:23:56,166
So if I look at the OpenCL
API and the OpenGL API,


434
00:23:56,866 --> 00:23:58,896
it turns out there are a
number of different queries


435
00:23:58,896 --> 00:24:01,946
that I can make, but
since the two devices


436
00:24:01,946 --> 00:24:04,556
in the Mac Pro are identical,
all of those queries,


437
00:24:04,556 --> 00:24:06,276
all those CL device
info queries,


438
00:24:06,546 --> 00:24:08,636
are going to return
exactly the same information


439
00:24:08,636 --> 00:24:09,666
for both devices.


440
00:24:10,196 --> 00:24:12,726
In order to distinguish
the two devices,


441
00:24:12,726 --> 00:24:13,976
we have to do something
different.


442
00:24:14,746 --> 00:24:17,856
So what we're trying to do
here, is we'd like to figure


443
00:24:17,856 --> 00:24:22,656
out which GPU is the online
one-that's the primary GPU-and


444
00:24:22,656 --> 00:24:25,536
which GPU is the offline one,
that's the secondary GPU.


445
00:24:25,536 --> 00:24:27,196
And then we're going
to try to figure


446
00:24:27,196 --> 00:24:29,086
out what its virtual
screen number is


447
00:24:29,086 --> 00:24:33,156
if we're doing OpenGL work, or
what the CL device ID is for it


448
00:24:33,156 --> 00:24:35,506
if we're doing OpenCL work.


449
00:24:36,616 --> 00:24:39,006
Okay, so let's walk
through some code here.


450
00:24:39,486 --> 00:24:41,896
This is the process that
you go through to decide


451
00:24:42,286 --> 00:24:45,336
which GPU is the primary
GPU or the secondary GPU.


452
00:24:46,246 --> 00:24:48,606
In this particular example,
I'm going to be looking


453
00:24:48,606 --> 00:24:49,996
for the secondary GPU.


454
00:24:49,996 --> 00:24:52,316
So I'm going to go through
a bunch of steps here


455
00:24:52,756 --> 00:24:55,876
where I issue some queries
against the system to figure


456
00:24:55,876 --> 00:24:58,616
out which GPU is
the offline GPU.


457
00:24:59,076 --> 00:25:04,096
So the first thing that I do
is I iterate the renderers


458
00:25:04,096 --> 00:25:04,726
in the system.


459
00:25:05,096 --> 00:25:09,656
I obtain these using this
CGLQueryRendererInfo call.


460
00:25:10,076 --> 00:25:14,356
I iterate over all of the
renderers and I ask the system,


461
00:25:14,846 --> 00:25:16,646
"Is the renderer
online or offline?"


462
00:25:17,026 --> 00:25:21,436
So this will actually tell
me, once I get past this step,


463
00:25:21,436 --> 00:25:25,746
I'll know if I have that GPU
that's connected to display


464
00:25:25,836 --> 00:25:29,136
and that's online, or
the one that's offline.


465
00:25:29,136 --> 00:25:31,286
Of course, as I mentioned
earlier,


466
00:25:31,456 --> 00:25:33,136
there are some other
renderers in the system.


467
00:25:33,136 --> 00:25:36,536
There's the software renderer
and I have to make sure


468
00:25:36,536 --> 00:25:40,746
that I am able to distinguish
between the offline GPU


469
00:25:40,746 --> 00:25:41,896
and the software
renderer and so,


470
00:25:42,156 --> 00:25:43,296
we'll do that in just a second.


471
00:25:43,336 --> 00:25:46,836
So, if I find the GPU that's
offline, I then check to see


472
00:25:46,836 --> 00:25:49,156
if it supports accelerated
compute.


473
00:25:49,156 --> 00:25:51,366
This is basically saying,
does it support OpenCL?


474
00:25:51,926 --> 00:25:57,546
And now, in the Mac, the OpenCL
API actually does have a CPU


475
00:25:57,546 --> 00:26:00,816
device, but it's presented
to the system differently


476
00:26:00,816 --> 00:26:02,926
than the software renderer.


477
00:26:02,926 --> 00:26:05,536
Those are two separate
entities within the system.


478
00:26:05,956 --> 00:26:09,936
And so if I obtained-if
I've sort of iterated


479
00:26:09,936 --> 00:26:14,506
over the render ID for
the software renderer,


480
00:26:14,506 --> 00:26:16,946
it wouldn't match this
accelerated compute query.


481
00:26:16,946 --> 00:26:18,456
And so I'd be able
to distinguish


482
00:26:18,456 --> 00:26:21,236
between it by making this check.


483
00:26:21,506 --> 00:26:23,626
And then, if I get
past that step,


484
00:26:23,626 --> 00:26:28,596
I'm going to issue another query
here using CGLDescribeRenderer


485
00:26:28,966 --> 00:26:30,916
and I'm going to ask
for the renderer ID.


486
00:26:30,916 --> 00:26:36,166
So I started by getting
a renderer info object.


487
00:26:36,466 --> 00:26:39,956
I then walked over
all of the renderers


488
00:26:39,956 --> 00:26:41,126
that were in the object.


489
00:26:41,126 --> 00:26:44,676
And then filtered them using
a number of other queries,


490
00:26:45,276 --> 00:26:48,686
and eventually ended up querying
them for their render ID number.


491
00:26:49,106 --> 00:26:54,376
And in this case, I found the
secondary GPU, its renderer ID


492
00:26:54,376 --> 00:26:56,836
and I'm going to write that
or store that to a value.


493
00:26:56,896 --> 00:26:59,276
And we'll use that
in a little while.


494
00:26:59,706 --> 00:27:05,096
So now I have a renderer ID
but in order to actually select


495
00:27:05,506 --> 00:27:08,446
or send work to a
GPU in the system,


496
00:27:08,786 --> 00:27:10,716
I need to know its virtual
screen number because,


497
00:27:10,716 --> 00:27:14,896
if you recall, the virtual
screen number is how the context


498
00:27:14,896 --> 00:27:19,306
refers to the different
renderers that it contains.


499
00:27:19,666 --> 00:27:22,036
And so here what I'm going
to do is I actually have


500
00:27:22,066 --> 00:27:25,096
to have a context in order to
have virtual screen numbers.


501
00:27:25,636 --> 00:27:32,286
So I'll get a context from my
NSOpenGLView and then I'll check


502
00:27:32,286 --> 00:27:37,016
to see for each virtual
screen in the context,


503
00:27:37,016 --> 00:27:40,636
I'll check for its number
and also its render ID.


504
00:27:40,636 --> 00:27:42,916
So here I am, getting the number


505
00:27:42,916 --> 00:27:44,596
of virtual screens
that are available.


506
00:27:45,706 --> 00:27:49,376
And then the next step is to
walk over those virtual screens,


507
00:27:49,686 --> 00:27:54,846
make them current, and then ask
for the renderer ID associated


508
00:27:54,846 --> 00:27:56,016
with each virtual screen.


509
00:27:56,526 --> 00:27:58,946
So I've iterated over
all the virtual screens,


510
00:27:59,306 --> 00:28:02,176
gotten their render IDs
and then matched those


511
00:28:02,176 --> 00:28:04,036
with the renderer ID
that I'm looking for,


512
00:28:04,246 --> 00:28:08,036
and that tells me the virtual
screen number that corresponds


513
00:28:08,036 --> 00:28:10,266
to that particular GPU.


514
00:28:12,606 --> 00:28:14,296
Okay, so it's important


515
00:28:14,296 --> 00:28:16,596
to always check virtual
screen numbers.


516
00:28:16,596 --> 00:28:20,136
So in the example that we
just looked at, when I walked


517
00:28:20,136 --> 00:28:22,236
through that and actually
executed that code,


518
00:28:22,556 --> 00:28:25,776
it turned out that the primary
GPU was actually virtual


519
00:28:25,776 --> 00:28:26,976
screen one.


520
00:28:27,386 --> 00:28:30,676
And so if I had just
assumed that you know,


521
00:28:30,676 --> 00:28:32,216
virtual screen zero
would be the primary


522
00:28:32,216 --> 00:28:34,006
because primary comes
before secondary,


523
00:28:34,006 --> 00:28:35,406
I would have been wrong
and I might have ended


524
00:28:35,926 --> 00:28:37,966
up rendering all of my work


525
00:28:38,046 --> 00:28:42,736
on say the secondary GPU
instead of the primary GPU.


526
00:28:42,926 --> 00:28:45,256
And so our - and so the
Mac is very flexible.


527
00:28:45,256 --> 00:28:46,666
It actually can handle
this case.


528
00:28:47,016 --> 00:28:51,166
It's just not as efficient as,
say, rendering all that 3D work


529
00:28:51,166 --> 00:28:55,326
to the primary GPU and then
displaying it immediately.


530
00:28:55,326 --> 00:28:58,566
Okay, so that's how
you do it in OpenGL.


531
00:28:59,076 --> 00:29:01,886
Let's take a look at how
to do the same operation


532
00:29:01,886 --> 00:29:05,206
of the same set of
operations in OpenCL.


533
00:29:05,296 --> 00:29:08,436
So, in OpenCL, I would have
gone through the process.


534
00:29:08,436 --> 00:29:11,096
I would have started
with the CGL API and gone


535
00:29:11,096 --> 00:29:14,116
through the process of
figuring out which render ID


536
00:29:14,116 --> 00:29:18,086
in the system is the secondary
GPU which - and if I had sort


537
00:29:18,086 --> 00:29:20,446
of flipped that process
around, I could have determined


538
00:29:20,446 --> 00:29:21,936
which one was the primary GPU.


539
00:29:22,476 --> 00:29:26,246
Now I have to go from a
renderer ID that I obtained


540
00:29:26,246 --> 00:29:28,816
from CGL to a CL device ID.


541
00:29:29,396 --> 00:29:34,066
And in Yosemite, there's
an API that we can use


542
00:29:34,066 --> 00:29:38,166
that will convert a CL device
ID directly to a renderer ID


543
00:29:38,166 --> 00:29:42,336
and that function is
CGLGetDeviceFromGLRenderer.


544
00:29:42,756 --> 00:29:47,516
I pass in the renderer ID and
it gives me back a CL device ID.


545
00:29:47,896 --> 00:29:52,756
Then I can use that CL device
ID to create a command queue


546
00:29:52,816 --> 00:29:56,726
and dispatch work
directly to that GPU.


547
00:29:56,726 --> 00:30:00,236
And so instead of having to
do a query for virtual screens


548
00:30:00,626 --> 00:30:04,006
in the OpenCL API, I can
just create a command queue


549
00:30:04,006 --> 00:30:07,676
and then use that command queue
to directly dispatch work,


550
00:30:07,676 --> 00:30:10,976
in this case, to
that secondary GPU.


551
00:30:12,236 --> 00:30:15,196
Okay, so the next stop
is dispatching work.


552
00:30:16,476 --> 00:30:21,856
So in OpenGL, the
context - the GL context -


553
00:30:22,926 --> 00:30:25,016
refers to the renderer
or interacts


554
00:30:25,016 --> 00:30:28,476
with the renderer via this
virtual screen number.


555
00:30:29,046 --> 00:30:32,396
And to do - to set the virtual
screen, we saw an example


556
00:30:32,396 --> 00:30:35,596
of this earlier, if I'm going
to set up some draw calls,


557
00:30:35,596 --> 00:30:38,456
I'm going to issue some draw
calls to one of the devices,


558
00:30:39,146 --> 00:30:42,156
the first thing I have to do
is make sure that the context


559
00:30:42,216 --> 00:30:44,206
that I created is
the current context.


560
00:30:44,606 --> 00:30:47,066
So I'll call
CGLSetCurrentContext.


561
00:30:47,566 --> 00:30:50,286
And pass in the context that
I'm entrusted in working with.


562
00:30:50,936 --> 00:30:53,876
Then once that context is set,


563
00:30:54,236 --> 00:30:56,736
I can set the virtual
screen number and,


564
00:30:56,816 --> 00:30:59,496
like I said a couple slides
ago, it's really important


565
00:30:59,496 --> 00:31:01,836
and I can't emphasize
this enough, to make sure


566
00:31:01,836 --> 00:31:04,206
that you know which
virtual screen corresponds


567
00:31:04,206 --> 00:31:06,666
to the primary GPU and the
secondary GPU as opposed


568
00:31:06,756 --> 00:31:09,746
to just assuming
that the first one


569
00:31:09,746 --> 00:31:14,126
or the second one is always
the primary or the secondary.


570
00:31:14,406 --> 00:31:19,006
Anyway, I can call
CGLSetVirtualScreen and pass


571
00:31:19,006 --> 00:31:20,036
in the number that I want.


572
00:31:20,096 --> 00:31:26,326
And then issue my bind calls
and my draw calls in OpenGL.


573
00:31:26,816 --> 00:31:32,906
In OpenCL, instead of having
to set a virtual screen,


574
00:31:33,146 --> 00:31:34,356
I just use a command queue.


575
00:31:34,356 --> 00:31:36,786
And so here, I'm
not setting state.


576
00:31:36,786 --> 00:31:38,776
Instead what I'm doing is
I'm creating an object,


577
00:31:39,106 --> 00:31:42,956
this queue object, and then
using that queue object


578
00:31:42,956 --> 00:31:45,346
to enqueue work to
a particular device.


579
00:31:45,816 --> 00:31:48,406
And so there are no
bind calls in OpenCL.


580
00:31:48,406 --> 00:31:51,476
Here I'm just creating
a number of objects.


581
00:31:51,516 --> 00:31:52,896
There was already a kernel here.


582
00:31:53,146 --> 00:31:54,606
I set some arguments on it.


583
00:31:54,876 --> 00:31:58,506
I have a command queue that I've
created based on the device ID


584
00:31:58,506 --> 00:32:01,736
that I looked up using the
process that we just described.


585
00:32:02,136 --> 00:32:05,816
And I can queue work
to that GPU.


586
00:32:07,926 --> 00:32:12,516
Okay, now that I've created a
context that has two GPUs in it,


587
00:32:12,836 --> 00:32:16,866
then identified the primary
GPU and the secondary GPU,


588
00:32:17,536 --> 00:32:22,316
dispatched work using a virtual
screen or a CL command queue,


589
00:32:23,096 --> 00:32:27,566
the last step is to get results
or to get the data off the GPU


590
00:32:27,566 --> 00:32:30,926
that I've selected and to
use it in my application.


591
00:32:30,926 --> 00:32:34,066
And of course, in an OpenGL
application, you might -


592
00:32:34,266 --> 00:32:37,466
you know, the results might
be displayed on a primary GPU.


593
00:32:37,466 --> 00:32:41,726
In an OpenCL application, if
you were doing CL-GL sharing,


594
00:32:42,226 --> 00:32:45,606
you might end up sending the
results from the secondary GPU


595
00:32:45,606 --> 00:32:47,876
to the primary GPU in
order to render them,


596
00:32:47,936 --> 00:32:51,826
or you might download the
results from the secondary GPU


597
00:32:51,826 --> 00:32:54,486
to host memory if you
were working on something


598
00:32:54,486 --> 00:32:57,806
that wasn't related to
rendering or to display.


599
00:32:58,706 --> 00:33:01,956
And either of those
things are possible.


600
00:33:01,956 --> 00:33:03,596
Either of those techniques
are possible.


601
00:33:04,086 --> 00:33:08,896
So if you're in a CL-GL sharing
case, there are a couple things


602
00:33:08,896 --> 00:33:11,086
that you have to do that
we'll look at in a second,


603
00:33:11,526 --> 00:33:13,776
but the runtime is going to
do most of the work for you.


604
00:33:14,546 --> 00:33:16,696
If you follow a specific
procedure,


605
00:33:17,326 --> 00:33:21,096
after you've dispatched the
work to the - to one GPU,


606
00:33:21,366 --> 00:33:24,956
when you start using that work
on the second GPU, the runtime


607
00:33:25,126 --> 00:33:28,116
and the driver will take
care of moving the data


608
00:33:28,546 --> 00:33:29,816
between the two devices.


609
00:33:30,226 --> 00:33:32,936
And well actually, this is a
great advantage because it means


610
00:33:32,936 --> 00:33:35,636
that we can very
easily take advantage


611
00:33:35,636 --> 00:33:37,846
of using the secondary
GPU in our application,


612
00:33:37,916 --> 00:33:40,286
but we have to follow
certain rules to make sure


613
00:33:40,286 --> 00:33:43,166
that the system will behave
in an efficient manner


614
00:33:43,586 --> 00:33:45,406
when we move data
between the two devices.


615
00:33:46,486 --> 00:33:50,976
So let's take a look at what
to do when we're switching work


616
00:33:50,976 --> 00:33:53,626
between - from one
GPU to another.


617
00:33:53,626 --> 00:33:56,076
So, let's say that we were going


618
00:33:56,076 --> 00:33:59,146
to do some OpenGL work
on the secondary GPU.


619
00:33:59,146 --> 00:34:02,376
So we'd call SetVirtualScreen
and we'd pass


620
00:34:02,376 --> 00:34:04,156
in the secondary virtual screen.


621
00:34:04,826 --> 00:34:07,736
And then we would bind some
objects, maybe some textures


622
00:34:07,736 --> 00:34:11,746
that we're going to work
with, and do some drawing.


623
00:34:12,005 --> 00:34:15,126
And then we would call
glFlushRenderAPPLE()


624
00:34:15,295 --> 00:34:18,126
and that's going to -
that's going to cause all


625
00:34:18,126 --> 00:34:21,376
of that GL work to be submitted
to the device, and it's going


626
00:34:21,376 --> 00:34:23,545
to push all of that
work off to the GPU


627
00:34:23,545 --> 00:34:27,406
and the GPU will
start working on it.


628
00:34:27,666 --> 00:34:30,106
At some point in the
future, we're going to want


629
00:34:30,106 --> 00:34:32,646
to use the results
that we had computed.


630
00:34:32,646 --> 00:34:35,065
Maybe we are rendering
into an FBL or something.


631
00:34:35,485 --> 00:34:38,446
We want to use those
results on the primary GPU.


632
00:34:38,446 --> 00:34:41,866
And so, we're going to
call CGLSetVirtualScreen,


633
00:34:42,196 --> 00:34:45,656
pass in the primary GPU's
virtual screen number,


634
00:34:46,485 --> 00:34:51,025
and then start working with
the data on the primary GPU.


635
00:34:51,346 --> 00:34:54,976
Now, in this case, there
is a single OpenGL context.


636
00:34:55,606 --> 00:34:57,646
And because there was a
single OpenGL context,


637
00:34:57,926 --> 00:35:01,576
it wasn't necessary for
me to change the state


638
00:35:01,576 --> 00:35:05,106
or to re-bind the objects
that we are working with.


639
00:35:05,496 --> 00:35:06,906
That state was already set.


640
00:35:06,906 --> 00:35:10,076
I simply changed
the virtual screen


641
00:35:10,386 --> 00:35:14,386
and continued using the
objects - the GL objects -


642
00:35:14,426 --> 00:35:15,856
that I was working
with previously.


643
00:35:16,466 --> 00:35:20,086
And that allows me to -
that allows the runtime,


644
00:35:20,486 --> 00:35:24,446
that SetVirtualScreen call,
allows the runtime to realize


645
00:35:24,446 --> 00:35:26,616
that I'm going to start
sending work to the other GPU.


646
00:35:26,616 --> 00:35:30,266
And it will take care of
synchronizing the data


647
00:35:30,266 --> 00:35:34,426
that I wrote to you on the
other device over to the device


648
00:35:34,476 --> 00:35:38,086
that I'm going to start using
when I issue the next draw call.


649
00:35:38,396 --> 00:35:40,836
Okay, so let's take
a look at what


650
00:35:40,836 --> 00:35:43,226
that looks like in a schematic.


651
00:35:43,226 --> 00:35:45,726
So I've taken some graphics work


652
00:35:45,816 --> 00:35:47,856
and I've issued a
bunch of Draw calls.


653
00:35:48,176 --> 00:35:51,016
On the secondary GPU, I
call glFlushRenderAPPLE()


654
00:35:51,436 --> 00:35:54,746
and the runtime pushes all
of that work onto the device.


655
00:35:54,746 --> 00:35:59,726
Now, if the runtime was going
to issue any more commands,


656
00:36:00,206 --> 00:36:03,106
like for example, if the
runtime decided that it had


657
00:36:03,106 --> 00:36:04,496
to issue a page off command,


658
00:36:04,916 --> 00:36:08,386
that page off command would
be sitting behind all the work


659
00:36:08,696 --> 00:36:10,716
that I'd previously
flushed to the device.


660
00:36:10,806 --> 00:36:12,156
And that's exactly
what happened.


661
00:36:12,156 --> 00:36:15,816
So when the primary GPU or
when the runtime detects


662
00:36:15,816 --> 00:36:20,216
that CGLSetVirtualScreen call
going to the primary GPU,


663
00:36:21,126 --> 00:36:26,246
it in turn will page the data
from - or page off the data


664
00:36:26,316 --> 00:36:27,586
from the secondary GPU,


665
00:36:27,866 --> 00:36:32,526
after those previously flushed
commands have been executed


666
00:36:32,676 --> 00:36:35,106
and then page it on
to the primary GPU


667
00:36:35,536 --> 00:36:40,946
so that I can then execute my
draw calls and continue working


668
00:36:40,946 --> 00:36:43,106
with the data on
the primary GPU.


669
00:36:43,886 --> 00:36:48,726
So, the movement of the data,
takes place automatically


670
00:36:49,236 --> 00:36:53,056
and as a programmer, I've made
sure that that data movement is


671
00:36:53,166 --> 00:36:58,496
in the right order or it
takes place after the commands


672
00:36:58,496 --> 00:37:01,636
that I used to create the data
by calling glFlushRenderAPPLE().


673
00:37:03,926 --> 00:37:07,226
Okay, so in OpenCL, it's
a little bit different.


674
00:37:07,766 --> 00:37:09,576
In OpenCL, we have
command queues instead


675
00:37:09,576 --> 00:37:11,336
of virtual screens,
and we're going


676
00:37:11,336 --> 00:37:13,126
to do something that's
very similar.


677
00:37:13,126 --> 00:37:16,716
We're going to enqueue
work using a command queue


678
00:37:16,716 --> 00:37:18,426
that we created in
the primary GPU


679
00:37:19,026 --> 00:37:22,146
and then flush it
using just clFlush.


680
00:37:23,026 --> 00:37:27,176
That will cause that queue to
start working or that device


681
00:37:27,436 --> 00:37:31,586
to start working on the data, on
the commands that we enqueued.


682
00:37:31,586 --> 00:37:36,406
And then when I enqueue
work to the secondary queue,


683
00:37:37,636 --> 00:37:41,546
once that work gets to the
head of the command queue,


684
00:37:41,906 --> 00:37:46,076
the system will execute a
similar page-off operation


685
00:37:46,406 --> 00:37:50,936
that in this case is going to be
guaranteed to be behind the work


686
00:37:50,936 --> 00:37:52,666
that was sent to
the primary queue.


687
00:37:52,996 --> 00:37:56,446
And so we'll see a similar
type of behavior as we saw


688
00:37:56,816 --> 00:38:02,296
in the GL case where I made sure
that that page-off would arrive


689
00:38:02,296 --> 00:38:07,056
at the GPU, after it had already
started working on the producer


690
00:38:07,416 --> 00:38:11,096
or the operations that
were producing the data.


691
00:38:11,856 --> 00:38:17,256
So, on Mac, you have heard of a
pattern called Flush and Bind.


692
00:38:17,696 --> 00:38:22,656
And this is a pattern
of APIs that is used


693
00:38:22,656 --> 00:38:26,986
in multiple GPU situations and
in instances where there is more


694
00:38:26,986 --> 00:38:29,966
than one OpenGL context.


695
00:38:30,236 --> 00:38:32,416
It's also used in a situation


696
00:38:32,416 --> 00:38:37,516
where you have an OpenGL context
that's, say, producing the data


697
00:38:37,516 --> 00:38:39,956
and an OpenCL context
that's consuming the data.


698
00:38:39,956 --> 00:38:44,826
So, any instance where on Mac
you have two different contexts,


699
00:38:45,166 --> 00:38:46,776
you have to use Flush and Bind.


700
00:38:47,026 --> 00:38:49,466
And what that means
is that when you -


701
00:38:49,466 --> 00:38:51,796
after you queue the work
that's doing the production,


702
00:38:52,046 --> 00:38:53,966
that's producing the texture


703
00:38:53,966 --> 00:38:57,596
or maybe it's producing some
geometry, after you enqueue


704
00:38:57,596 --> 00:39:00,826
that work, you always have to
make sure that you flush it.


705
00:39:01,066 --> 00:39:02,326
You flush that command queue


706
00:39:02,326 --> 00:39:05,186
or you flush before
switching virtual screens.


707
00:39:06,376 --> 00:39:09,916
And then after that, when
you switch to the other API


708
00:39:09,916 --> 00:39:12,926
or to the other context,
you have to make sure


709
00:39:12,926 --> 00:39:17,216
that you rebind any
objects that were modified,


710
00:39:17,686 --> 00:39:19,576
in this case, by OpenCL.


711
00:39:20,236 --> 00:39:23,996
So in the single instance
that we looked at before,


712
00:39:23,996 --> 00:39:27,466
when we were - just had one
OpenGL context, we could flush


713
00:39:27,466 --> 00:39:33,016
and then immediately use the
objects on the other device.


714
00:39:33,466 --> 00:39:37,236
In an instance where there
are either two OpenGL contexts


715
00:39:37,556 --> 00:39:40,786
or there's an OpenGL context
and an OpenCL context,


716
00:39:41,136 --> 00:39:42,466
we have to use Flush and Bind.


717
00:39:42,466 --> 00:39:45,346
We have to flush like we
did before, but then we have


718
00:39:45,346 --> 00:39:49,116
to rebind those objects once
we switch to the other device.


719
00:39:50,196 --> 00:39:53,866
So if you follow these steps,
the runtime will take care


720
00:39:53,866 --> 00:39:58,616
of moving this data between the
two GPUs for you as you work


721
00:39:58,616 --> 00:39:59,976
on the data in those
two different places.


722
00:40:00,116 --> 00:40:02,906
And the reason that the
runtime's able to do this,


723
00:40:02,906 --> 00:40:06,786
is that you've created a context
that contains all the devices


724
00:40:06,896 --> 00:40:10,526
in the system, and so that the
runtime and the driver are able


725
00:40:10,526 --> 00:40:14,916
to track enough state to perform
these operations for you.


726
00:40:14,916 --> 00:40:16,976
And so it's very
important to emphasize


727
00:40:17,456 --> 00:40:21,836
that when you create a
context, always create a context


728
00:40:21,836 --> 00:40:23,826
that contains all the
devices in the system,


729
00:40:23,826 --> 00:40:25,556
all of the GPU devices
in the system.


730
00:40:26,036 --> 00:40:30,086
There are some other design
patterns that you might follow.


731
00:40:30,086 --> 00:40:33,786
For example, you might create
or be tempted to create a, say,


732
00:40:33,976 --> 00:40:37,676
a set of objects, a
context, a command queue,


733
00:40:37,876 --> 00:40:39,996
a whole stack of objects.


734
00:40:40,366 --> 00:40:42,766
One stack per device
in the system.


735
00:40:43,506 --> 00:40:47,646
But on Mac, really the
best thing to do is


736
00:40:47,646 --> 00:40:50,636
to always create a - the context
to contain all of the devices


737
00:40:50,636 --> 00:40:52,166
in the system, even
if you're, say,


738
00:40:52,506 --> 00:40:53,856
on a different configuration,


739
00:40:53,856 --> 00:40:55,286
only going to use
one of the devices.


740
00:40:55,726 --> 00:40:58,706
If you do this, it
will be very easy


741
00:40:58,706 --> 00:41:01,476
when you move your
application onto the Mac Pro


742
00:41:01,626 --> 00:41:05,916
to start using two GPUs
because the application


743
00:41:06,286 --> 00:41:09,276
and the structure of the
program has already been written


744
00:41:09,276 --> 00:41:12,896
to handle a context that
contains both devices.


745
00:41:12,896 --> 00:41:16,366
It makes it a lot easier
to migrate to the system


746
00:41:16,786 --> 00:41:22,726
and allows the runtime to take
advantage or allows the runtime


747
00:41:22,726 --> 00:41:26,376
to move objects between
the two GPUs for you.


748
00:41:27,916 --> 00:41:32,686
Okay, so now that I've
showed you how to program


749
00:41:32,686 --> 00:41:38,676
or the API that's involved in
programming for the Mac Pro,


750
00:41:39,146 --> 00:41:41,206
I'd like to show you some
programming patterns.


751
00:41:41,326 --> 00:41:45,106
And what I'm going to focus on
here is what the system does,


752
00:41:45,106 --> 00:41:46,746
or what the system's
doing on your behalf,


753
00:41:47,566 --> 00:41:50,736
when you perform
different tasks on the GPU.


754
00:41:50,736 --> 00:41:54,286
So, what I'm going to start
with is an example of an offline


755
00:41:54,286 --> 00:41:59,056
or an offload task where you
have some kind of operation


756
00:41:59,486 --> 00:42:04,016
that isn't related to
display, and you're going


757
00:42:04,086 --> 00:42:07,576
to perform this operation
on the secondary GPU.


758
00:42:07,906 --> 00:42:11,036
And so, I've called this -
I call this an offline task.


759
00:42:11,446 --> 00:42:14,706
And you might have an offline
task in your application


760
00:42:15,266 --> 00:42:18,056
if it's something that
- say it's something


761
00:42:18,056 --> 00:42:21,836
that you apply once or one
- sort of one set of time.


762
00:42:22,256 --> 00:42:25,236
So for example, you have an
image processing application


763
00:42:25,236 --> 00:42:28,806
and the user goes to the Edit
menu and they select a filter


764
00:42:29,286 --> 00:42:32,456
and they change some filter
parameters and click Apply,


765
00:42:33,076 --> 00:42:36,286
that might be a great offline
task because you're not going


766
00:42:36,286 --> 00:42:40,876
to perform the bulk of the
work, of the bulk of that say,


767
00:42:40,876 --> 00:42:44,326
OpenCL compute work until
the user clicks Apply.


768
00:42:44,746 --> 00:42:46,746
Then you're going to perform
a large amount of work


769
00:42:46,866 --> 00:42:49,216
on some input data,
on some giant image.


770
00:42:49,716 --> 00:42:53,496
And then once you're done,
you're going to say save


771
00:42:53,496 --> 00:42:56,636
that image off to main memory
or maybe you're going to save


772
00:42:56,636 --> 00:42:59,026
that image off to disk.


773
00:42:59,516 --> 00:43:03,196
And that operation is
a discrete operation.


774
00:43:03,196 --> 00:43:04,586
It takes a long time.


775
00:43:05,096 --> 00:43:08,196
If you were to run it
on say the main thread,


776
00:43:08,196 --> 00:43:12,416
it might cause the GUI
to respond more slowly.


777
00:43:12,766 --> 00:43:17,936
And it's something that is -
it's something that's separate


778
00:43:17,936 --> 00:43:22,216
from the main sort of, GUI
loop of the application.


779
00:43:23,216 --> 00:43:25,026
So let's take a look
at what that -


780
00:43:25,026 --> 00:43:26,126
what I'm talking about here.


781
00:43:26,126 --> 00:43:30,936
So I have some OpenCL
work in green,


782
00:43:30,936 --> 00:43:34,966
and this OpenCL work is
going to apply my operation.


783
00:43:34,966 --> 00:43:36,766
And it might take a long time.


784
00:43:36,766 --> 00:43:40,286
And then I'm going to first have
some OpenGL work that's going


785
00:43:40,286 --> 00:43:42,346
on that's related to my GUI.


786
00:43:42,346 --> 00:43:45,876
And my application actually
may be using OpenGL in the GPU


787
00:43:45,876 --> 00:43:49,336
if I'm using a - if I'm using
certain parts of the UI,


788
00:43:50,226 --> 00:43:52,716
even if my application
itself doesn't use OpenGL.


789
00:43:53,536 --> 00:43:56,326
Now, what this looks like
is, it has a lot of -


790
00:43:56,326 --> 00:43:57,966
we might have a lot
of sort of short


791
00:43:58,216 --> 00:44:01,836
or inexpensive OpenGL
operations being performed.


792
00:44:01,836 --> 00:44:04,286
And then we have this
giant compute operation.


793
00:44:04,526 --> 00:44:10,646
And of course, if I then have
some more GUI-related OpenGL


794
00:44:10,646 --> 00:44:12,786
work coming through,
what's going to happen is,


795
00:44:12,786 --> 00:44:14,896
I'm going to - you know,
my system's going to lag.


796
00:44:14,896 --> 00:44:18,966
I might end up with some
sort of progress problem


797
00:44:18,966 --> 00:44:20,696
or maybe I'll even
get a beachball,


798
00:44:21,106 --> 00:44:25,196
if this OpenCL program
or this part


799
00:44:25,326 --> 00:44:27,726
of my OpenCL application
takes too long.


800
00:44:27,966 --> 00:44:29,966
And so what we're going to do is
we're really just going to take


801
00:44:29,966 --> 00:44:31,336
that green box, the Open -


802
00:44:31,336 --> 00:44:34,316
the expensive OpenCL compute
operation, and we're just going


803
00:44:34,316 --> 00:44:35,846
to move it over to
the secondary GPU.


804
00:44:36,016 --> 00:44:38,136
And if we've set
up our application


805
00:44:38,466 --> 00:44:44,086
so that we have both
devices in our context,


806
00:44:44,556 --> 00:44:50,706
and we followed the API that we
just described, it's very easy


807
00:44:50,706 --> 00:44:52,646
to perform this offload task


808
00:44:52,946 --> 00:44:56,226
and move an offline operation
off to the secondary GPU.


809
00:44:56,556 --> 00:44:57,696
So here's what this looks like.


810
00:44:57,856 --> 00:44:59,066
It's very straightforward.


811
00:44:59,196 --> 00:45:00,716
I have an application here.


812
00:45:01,036 --> 00:45:03,326
The user went into my -
or the user is going to go


813
00:45:03,326 --> 00:45:05,626
into my Edit menu and
select Apply Effect.


814
00:45:06,016 --> 00:45:07,856
I end up in an action here.


815
00:45:08,176 --> 00:45:12,496
And I have a kernel that I'm
executing iteratively a large


816
00:45:12,496 --> 00:45:13,366
number of times.


817
00:45:13,706 --> 00:45:16,286
This makes the application
a little bit slower.


818
00:45:16,466 --> 00:45:18,976
And I'm doing this right
now in the primary queue,


819
00:45:19,306 --> 00:45:21,196
and all I'm going to do
is make sure that I've set


820
00:45:21,196 --> 00:45:24,196
up the secondary queue and
just send that operation off


821
00:45:24,196 --> 00:45:25,206
to the secondary queue.


822
00:45:25,206 --> 00:45:28,316
And now, at some
point in the future,


823
00:45:28,316 --> 00:45:32,606
after these operations are
finished, the existing code


824
00:45:32,606 --> 00:45:37,046
in my application to move
the data off the GPU and back


825
00:45:37,516 --> 00:45:41,006
to disk will just move that
data, those memory objects,


826
00:45:42,176 --> 00:45:46,146
off the other GPU
instead of the primary GPU


827
00:45:46,146 --> 00:45:47,526
that I was previously using.


828
00:45:48,376 --> 00:45:51,966
Another pattern that you might
end up following is an instance


829
00:45:51,966 --> 00:45:55,486
where you're going to perform
graphics work on both GPUs.


830
00:45:56,026 --> 00:45:59,106
And once you've divided the
work, the rendering work,


831
00:45:59,146 --> 00:46:00,356
between the two devices,


832
00:46:00,906 --> 00:46:03,886
the window server actually
will take care of copying data


833
00:46:04,526 --> 00:46:08,196
from the secondary GPU to
the primary GPU for display.


834
00:46:08,246 --> 00:46:10,346
So I'm going to show
you what this looks like


835
00:46:10,346 --> 00:46:11,306
and what happens here.


836
00:46:11,726 --> 00:46:15,236
And actually in a second,
I'll show an example


837
00:46:15,626 --> 00:46:18,476
where we perform these
kinds of operations


838
00:46:18,476 --> 00:46:20,306
in an actual application.


839
00:46:20,956 --> 00:46:25,596
So, here I have an application's
app thread, and it's going


840
00:46:25,596 --> 00:46:28,916
to perform a - it's
going to select a -


841
00:46:28,946 --> 00:46:30,086
make the context current.


842
00:46:30,506 --> 00:46:34,136
It will set the virtual
screen to the primary.


843
00:46:34,136 --> 00:46:35,996
It's going to call the drawScene
method and that's going


844
00:46:35,996 --> 00:46:38,216
to do a lot of OpenGL work.


845
00:46:38,676 --> 00:46:41,216
And then I'm going to
call glFlushRenderAPPLE


846
00:46:41,956 --> 00:46:47,566
and maybe I call flushBuffer
to put the work on the screen.


847
00:46:47,566 --> 00:46:50,166
And now I'm going to do the
same thing on the secondary GPU


848
00:46:50,916 --> 00:46:52,396
and also call flushBuffer.


849
00:46:52,396 --> 00:46:56,386
In this example, I might
have two separate parts


850
00:46:56,386 --> 00:47:00,046
of my application and I'm going
to render one part on one GPU


851
00:47:00,046 --> 00:47:02,136
and the other part
on the other GPU.


852
00:47:02,806 --> 00:47:06,846
Now, what happens here, if
I look at the operations


853
00:47:06,846 --> 00:47:09,146
that are being performed,
at some point and time,


854
00:47:09,566 --> 00:47:15,096
both of these GPUs are
going to get flush commands


855
00:47:15,216 --> 00:47:17,206
and then flushBuffer commands.


856
00:47:17,626 --> 00:47:21,216
And the window server is going
to wake up and it's going


857
00:47:21,216 --> 00:47:26,036
to realize as it's getting
ready to composite the image


858
00:47:26,086 --> 00:47:28,666
for the next frame, that some


859
00:47:28,666 --> 00:47:31,236
of the data it needs is
on the secondary GPU.


860
00:47:31,236 --> 00:47:34,296
And so it's going to actually
perform a very similar operation


861
00:47:34,296 --> 00:47:37,106
to what we saw a little
while ago with the page-off.


862
00:47:37,106 --> 00:47:39,226
It's going to realize
that that -


863
00:47:39,226 --> 00:47:43,586
the data's on the other device,
send a page off request for it


864
00:47:43,586 --> 00:47:46,926
to the device, move the
data back, then page it


865
00:47:46,926 --> 00:47:49,696
on to the primary GPU
performance composite,


866
00:47:49,956 --> 00:47:52,296
and then display the image.


867
00:47:52,656 --> 00:47:54,536
And so, there's a
period of time here


868
00:47:54,536 --> 00:47:58,766
where the window server has
gotten involved for display


869
00:47:59,206 --> 00:48:03,406
and it's going to end up
executing that page-off


870
00:48:03,406 --> 00:48:06,006
and then the secondary GPU
is free to continue working


871
00:48:06,006 --> 00:48:07,676
on more graphics work.


872
00:48:07,676 --> 00:48:10,816
But the primary GPU is
going to have to end


873
00:48:10,816 --> 00:48:16,856
up copying the data back on, and
then rendering the composite.


874
00:48:16,856 --> 00:48:20,136
And so there's a certain
amount of overhead


875
00:48:20,136 --> 00:48:22,796
that your application
has to be aware


876
00:48:22,796 --> 00:48:26,466
of when you're performing
work on both devices.


877
00:48:26,526 --> 00:48:29,206
But the system, if
you follow this API,


878
00:48:29,416 --> 00:48:32,066
the system will handle
this for you


879
00:48:32,416 --> 00:48:36,966
and your application will
be able to use both devices.


880
00:48:38,136 --> 00:48:41,886
Okay, so the challenge here,
when we're taking an application


881
00:48:41,886 --> 00:48:44,816
and modifying it to
use this configuration,


882
00:48:45,206 --> 00:48:47,186
is really that we have to
divide our work somehow.


883
00:48:47,506 --> 00:48:51,236
We might divide it by taking
a task that isn't related


884
00:48:51,236 --> 00:48:53,556
to display and moving
it to the secondary GPU


885
00:48:53,556 --> 00:49:00,146
or maybe we can parallelize the
work between the two devices


886
00:49:00,146 --> 00:49:03,686
in such a way that the
overhead is not a problem.


887
00:49:04,236 --> 00:49:05,926
And we have to always be aware


888
00:49:05,926 --> 00:49:08,726
that there is one device that's
connected to the display,


889
00:49:08,726 --> 00:49:09,796
and the other device that isn't.


890
00:49:10,276 --> 00:49:11,866
And so that can be a
source of overhead,


891
00:49:13,086 --> 00:49:17,336
especially if the data is -
especially if the data has


892
00:49:17,336 --> 00:49:19,416
to be moved back and
forth very frequently.


893
00:49:20,336 --> 00:49:23,726
So, I'd like to take
a second here and talk


894
00:49:23,726 --> 00:49:25,176
about some other situations


895
00:49:25,506 --> 00:49:28,046
that involve multiple
GPUs on our platform.


896
00:49:28,386 --> 00:49:33,076
So the - probably the most
common multi-GPU situation is a


897
00:49:33,076 --> 00:49:36,236
laptop that has two
GPUs: a discrete GPU


898
00:49:36,236 --> 00:49:37,406
and an integrated GPU.


899
00:49:37,656 --> 00:49:41,276
And it's important to
remember that although the APIs


900
00:49:41,276 --> 00:49:43,956
that you use when you
modify an application


901
00:49:43,956 --> 00:49:46,796
to support automatic graphics
switching are similar,


902
00:49:47,156 --> 00:49:49,946
the way that you use those
APIs is a little bit different.


903
00:49:50,366 --> 00:49:54,826
And so, if you are interested
in supporting both GPUs


904
00:49:54,826 --> 00:49:57,116
in a laptop, be sure
to take a look


905
00:49:57,116 --> 00:49:58,806
at the automatic graphics
switching feature.


906
00:49:59,596 --> 00:50:06,456
Also, the tower Mac Pro
configuration is still available


907
00:50:06,516 --> 00:50:07,956
or is still out there.


908
00:50:07,996 --> 00:50:09,976
And is - your application
may run on it.


909
00:50:10,866 --> 00:50:14,306
And it is something that can
support multiple displays


910
00:50:14,306 --> 00:50:17,726
connected to multiple GPUs, and
there's a lot of infrastructure


911
00:50:17,726 --> 00:50:20,856
in Mac graphics for
handling instances


912
00:50:20,856 --> 00:50:24,356
where an application moves
from one GPU to another,


913
00:50:24,706 --> 00:50:28,656
based on the display
that's connected to the GPU.


914
00:50:28,976 --> 00:50:31,986
And that uses a different set
of APIs and callback mechanisms.


915
00:50:31,986 --> 00:50:34,106
And so, if you're working
or if you're concerned


916
00:50:34,106 --> 00:50:35,686
about that situation,
you should take a look


917
00:50:35,686 --> 00:50:36,716
at that documentation.


918
00:50:37,256 --> 00:50:39,216
So let's look at a complete
example of everything


919
00:50:39,216 --> 00:50:41,226
that you have to do
in an application.


920
00:50:41,706 --> 00:50:43,856
The first step of course
was to create a context


921
00:50:43,856 --> 00:50:45,516
that contains all the GPUs.


922
00:50:46,246 --> 00:50:53,636
The second is to check and see
if you have an offline device.


923
00:50:54,046 --> 00:50:58,176
So if you're on a Mac Pro,
you should have a single -


924
00:50:58,566 --> 00:51:00,396
basically you should have
one device that's online


925
00:51:00,666 --> 00:51:02,016
and one device that's offline.


926
00:51:02,446 --> 00:51:06,346
Then check to see if you have
two identical - in this case,


927
00:51:06,346 --> 00:51:07,656
I'm looking for device names.


928
00:51:08,096 --> 00:51:11,176
And if I fail any of these
checks, it might mean that I'm


929
00:51:11,176 --> 00:51:12,506
in one of those other
situations.


930
00:51:12,506 --> 00:51:15,146
I might be in an instance
where I have a laptop


931
00:51:15,146 --> 00:51:18,256
that has an integrated
and discrete GPU


932
00:51:18,256 --> 00:51:21,326
that are different devices,
or maybe I'm in an instance


933
00:51:21,326 --> 00:51:26,346
where I have a tower Mac Pro
and I have two different -


934
00:51:27,396 --> 00:51:31,706
two displays connected
to two different GPUs.


935
00:51:31,706 --> 00:51:35,576
Once I've determined that I'm
on a Mac Pro, a new Mac Pro,


936
00:51:36,106 --> 00:51:38,636
then I have to be
concerned about dividing work


937
00:51:38,666 --> 00:51:41,396
between the GPU and then
synchronizing the results.


938
00:51:41,396 --> 00:51:48,746
So, if I fail that first check,
I'm going to go and take a look


939
00:51:48,746 --> 00:51:53,636
at supporting multiple displays.


940
00:51:53,636 --> 00:51:56,016
And if I - if the second
check doesn't work out,


941
00:51:56,076 --> 00:51:58,256
then I might have
to be concerned


942
00:51:58,256 --> 00:51:59,606
about automatic graphics
switching.


943
00:52:00,776 --> 00:52:04,486
Okay, so let me show you
a multi-GPU example now.


944
00:52:04,786 --> 00:52:09,936
And this is a - this demo is a
system that's performing some


945
00:52:09,936 --> 00:52:13,066
OpenCL work and some
OpenGL work.


946
00:52:13,736 --> 00:52:18,356
And we're performing the
OpenGL work on the primary GPU,


947
00:52:18,826 --> 00:52:23,276
and the OpenCL work in the
demo mode that we'll see


948
00:52:23,276 --> 00:52:25,856
in a just a second, is
going to be performed on -


949
00:52:26,206 --> 00:52:29,706
partially on the primary GPU and
then also on the secondary GPU.


950
00:52:30,406 --> 00:52:31,696
So when I launch
this application,


951
00:52:31,696 --> 00:52:33,746
this is performing
a physics simulation


952
00:52:34,206 --> 00:52:37,996
where there's a particle system
that's being rendered in OpenGL


953
00:52:38,366 --> 00:52:41,126
and it's being simulated
in OpenCL.


954
00:52:41,296 --> 00:52:43,986
And right now, we have a
large number of particles.


955
00:52:44,616 --> 00:52:46,566
We're performing the
physics simulation


956
00:52:46,566 --> 00:52:47,916
and we're using one GPU.


957
00:52:48,216 --> 00:52:50,156
And we're getting about
15 frames per second.


958
00:52:50,156 --> 00:52:56,836
We have a - this is a relatively
fluid animation but it turns


959
00:52:56,836 --> 00:52:59,566
out we can do much
better if we go over here


960
00:52:59,566 --> 00:53:02,616
and reconfigure the
demo to use two GPUs.


961
00:53:02,616 --> 00:53:05,116
And here you can
see that we're doing


962
00:53:05,116 --> 00:53:07,786
about 30 frames per second,
maybe a little bit more


963
00:53:07,786 --> 00:53:10,556
than 30 frames per second,
and we were able to accomplish


964
00:53:10,556 --> 00:53:15,006
that by working through our
application and making sure


965
00:53:15,006 --> 00:53:17,376
that we enable the application


966
00:53:17,376 --> 00:53:19,886
to move data between
the two GPUs.


967
00:53:20,236 --> 00:53:22,446
And then we found a way
of dividing the data


968
00:53:22,676 --> 00:53:27,416
and the computation in
such a way that the speedup


969
00:53:27,416 --> 00:53:32,286
that we obtained from
dividing our work and executing


970
00:53:32,456 --> 00:53:34,356
with twice the amount
of GPU capability,


971
00:53:34,846 --> 00:53:38,346
that speedup was a lot greater
than the overhead of having


972
00:53:38,346 --> 00:53:40,486
to move a small amount
of data back


973
00:53:40,546 --> 00:53:42,326
to the primary GPU for display.


974
00:53:43,226 --> 00:53:45,436
So here actually we're -
I guess towards the end,


975
00:53:45,436 --> 00:53:46,796
we're getting even faster


976
00:53:46,796 --> 00:53:51,326
than the very beginning
of the simulation.


977
00:53:52,056 --> 00:53:55,896
So this is a relatively
simple example.


978
00:53:56,016 --> 00:53:57,206
Let's see if I can restart here.


979
00:53:57,606 --> 00:53:59,906
This is a simple example.


980
00:54:00,896 --> 00:54:03,726
And without a huge
amount of effort,


981
00:54:03,726 --> 00:54:06,626
we're able to divide our
application into pieces


982
00:54:06,696 --> 00:54:11,486
and then execute the
compute part on both devices


983
00:54:11,486 --> 00:54:13,546
and obtain a significant
speedup.


984
00:54:14,516 --> 00:54:25,946
[ Silence ]


985
00:54:26,446 --> 00:54:30,916
Okay, so in the demo what
we saw was an application


986
00:54:30,916 --> 00:54:34,656
that we had modified
to move between


987
00:54:35,676 --> 00:54:39,036
or to take an application
and perform some of the work


988
00:54:39,356 --> 00:54:43,286
on one GPU and a lot of the
work on the secondary GPU.


989
00:54:43,286 --> 00:54:46,296
And we saw that that produced
a pretty significant speedup.


990
00:54:46,296 --> 00:54:50,256
There are a lot of other
applications that can benefit


991
00:54:50,256 --> 00:54:52,526
from working on this
configuration and I hope


992
00:54:52,596 --> 00:54:56,016
that using this API
and understanding some


993
00:54:56,016 --> 00:54:59,146
of the terminology and the way


994
00:54:59,146 --> 00:55:01,686
that the system behaves will
help you port applications


995
00:55:02,116 --> 00:55:03,546
to this configuration.


996
00:55:04,186 --> 00:55:07,786
For more information about
using OpenCL and OpenGL


997
00:55:07,786 --> 00:55:12,666
in the Mac Pro, please talk
to the WWDR representatives.


998
00:55:12,926 --> 00:55:15,826
Thank you very much for
attending this session


999
00:55:15,866 --> 00:55:17,816
and please let us know
how we can help you.


1000
00:55:18,016 --> 00:55:20,016
[ Applause ]


1001
00:55:20,016 --> 00:55:30,186
[ Silence ]

