1
00:00:23,306 --> 00:00:24,016
>> ALI OZER: Good afternoon.


2
00:00:24,306 --> 00:00:25,946
Welcome to What's New in Cocoa.


3
00:00:30,546 --> 00:00:31,696
My name is Ali Ozer.


4
00:00:32,326 --> 00:00:36,266
I'll be talking to you about
what's new in Cocoa this year.


5
00:00:36,656 --> 00:00:39,796
Three areas: Swiftificaiton,
AppKit, and Foundation.


6
00:00:41,016 --> 00:00:43,826
We have a lot of
material, so let's dive in.


7
00:00:44,516 --> 00:00:48,606
Swiftification refers to the
API enhancements we have done


8
00:00:48,606 --> 00:00:52,946
across our frameworks
in support of Swift.


9
00:00:53,176 --> 00:00:56,606
The changes also improve our
Objective-C APIs as well.


10
00:00:57,156 --> 00:01:00,566
As you know, Swift
provides features


11
00:01:00,566 --> 00:01:02,426
to express APIs more precisely.


12
00:01:02,836 --> 00:01:05,366
For instance, you can
indicate this is an array.


13
00:01:05,366 --> 00:01:07,216
The Subviews property
is an array


14
00:01:07,216 --> 00:01:09,186
of NSView, not just an array.


15
00:01:09,866 --> 00:01:12,036
You can indicate that a
method such as System Font


16
00:01:12,036 --> 00:01:15,156
Of Size returns an NSFont
and will never return nil.


17
00:01:16,096 --> 00:01:18,246
In methods such as
Image For Resource,


18
00:01:18,246 --> 00:01:20,996
an NSBundle may return
nil because it is declared


19
00:01:20,996 --> 00:01:22,246
as an optional NSImage.


20
00:01:24,256 --> 00:01:27,096
We enable these features
in Objective-C as well


21
00:01:27,096 --> 00:01:28,466
with nullability in generics.


22
00:01:28,926 --> 00:01:31,506
So I'm going to talk about
these two areas briefly,


23
00:01:31,766 --> 00:01:33,946
and then also a few
other changes we made


24
00:01:34,186 --> 00:01:38,466
to make our Objective-C
and Swift APIs better.


25
00:01:38,666 --> 00:01:41,386
We applied these in APIs
of many our frameworks,


26
00:01:41,386 --> 00:01:44,606
not just AppKit and Foundation.


27
00:01:45,086 --> 00:01:48,096
By doing this we not only do
better exposure of the APIs


28
00:01:48,096 --> 00:01:51,906
in Swift but also
make the APIs clearer


29
00:01:52,096 --> 00:01:54,176
and also provide compile
time type-checking


30
00:01:54,176 --> 00:01:57,506
which is very important,
of course.


31
00:01:57,656 --> 00:02:00,896
Nullability is whether
values can or cannot be nil.


32
00:02:01,516 --> 00:02:06,146
If you use Swift with
X v10 or iOS 8 SDKs,


33
00:02:06,146 --> 00:02:09,985
you know the Swift APIs already
have the proper nullability


34
00:02:09,985 --> 00:02:11,446
and optional declarations
on them.


35
00:02:11,706 --> 00:02:15,186
We have managed that with
handcrafted side data,


36
00:02:15,226 --> 00:02:15,916
side files.


37
00:02:16,436 --> 00:02:19,886
In X v11 and iOS 9, we bring
this ability to Objective-C,


38
00:02:20,086 --> 00:02:22,766
and we have several new keywords
we've added to Objective-C.


39
00:02:23,446 --> 00:02:27,666
Nonnull indicates never nil,
Nullable indicates can be nil,


40
00:02:28,166 --> 00:02:31,726
Null Resettable indicates that
a property can be set to nil


41
00:02:31,726 --> 00:02:33,176
but won't ever return nil.


42
00:02:33,316 --> 00:02:36,036
We'll have an example
in a second.


43
00:02:36,036 --> 00:02:38,706
Last and least, we
have Null Unspecified,


44
00:02:38,706 --> 00:02:39,836
meaning not specified.


45
00:02:40,186 --> 00:02:43,146
This is used for
deprecated stuff or stuff


46
00:02:43,146 --> 00:02:47,636
that has not yet been audited.


47
00:02:47,686 --> 00:02:51,306
Since nonnull is the
majority of cases in our API,


48
00:02:51,556 --> 00:02:53,256
we also have these
two declarations:


49
00:02:53,256 --> 00:02:54,866
Assume Nonnull Begin and End,


50
00:02:54,866 --> 00:02:56,556
which we wrap our
header files with.


51
00:02:57,056 --> 00:02:59,506
With this, the nonnull
declarations are no


52
00:02:59,506 --> 00:03:00,216
longer needed.


53
00:03:00,696 --> 00:03:03,206
Nonnull is unnecessary


54
00:03:03,206 --> 00:03:05,066
and we have the other
declarators on our APIs.


55
00:03:05,066 --> 00:03:08,026
We recommend you use
these in your header files


56
00:03:08,266 --> 00:03:10,586
if you have a lot of
header files of your own.


57
00:03:11,656 --> 00:03:15,256
Let's look at some examples
of how these affect our APIs.


58
00:03:15,756 --> 00:03:18,276
You can see the Color
property on NSColorWell.


59
00:03:18,696 --> 00:03:22,096
We have not put any declaration
on it, which means it is nonnull


60
00:03:22,506 --> 00:03:25,566
and comes across in Swift
as a non-optional value.


61
00:03:25,616 --> 00:03:26,496
The Color property.


62
00:03:27,056 --> 00:03:29,336
The Image property of
NSImageView, on the other hand,


63
00:03:29,336 --> 00:03:33,806
is nullable which means that
it can be set to nil and comes


64
00:03:33,806 --> 00:03:36,376
across in Swift as
an optional value.


65
00:03:36,796 --> 00:03:39,636
And finally the Font property
of NSMenu is declarated


66
00:03:39,636 --> 00:03:42,616
as null resettable,
and this comes


67
00:03:42,616 --> 00:03:44,236
as implicitly unwrapped
optional.


68
00:03:44,956 --> 00:03:48,176
In this case what this means is
we can set this value to nil,


69
00:03:48,176 --> 00:03:49,706
but it will never return nil.


70
00:03:50,236 --> 00:03:53,706
What NSMenu does is if you ever
set it to nil, it goes back


71
00:03:53,756 --> 00:03:56,776
to the default font that it
would have had for the system.


72
00:03:56,816 --> 00:03:58,666
So it never will return nil.


73
00:04:00,176 --> 00:04:03,016
With nullability, you may
see some build time warnings.


74
00:04:03,756 --> 00:04:04,866
Let me show you an example.


75
00:04:05,186 --> 00:04:07,926
If you have code like this that
was setting the Color property


76
00:04:07,926 --> 00:04:11,156
of a ColorWell to nil,
the compiler will now warn


77
00:04:11,456 --> 00:04:13,156
because we declared
this to be nonnull.


78
00:04:13,726 --> 00:04:16,856
This is a good thing because it
turns out if you had the code


79
00:04:16,856 --> 00:04:19,546
and it was being run, it
would have raised a parameter


80
00:04:19,546 --> 00:04:20,456
assertion anyway.


81
00:04:20,866 --> 00:04:22,926
This is kind of things that
now you'll get warnings


82
00:04:22,926 --> 00:04:23,906
about from the compiler.


83
00:04:23,906 --> 00:04:24,446
That's great.


84
00:04:26,106 --> 00:04:31,146
As you probably know, in general
nil is not a valid object value


85
00:04:31,146 --> 00:04:32,796
in our APIs.


86
00:04:32,796 --> 00:04:36,146
NSString, NSArray, NSDictionary,
et cetera have easy


87
00:04:36,146 --> 00:04:40,916
to express empty values
and APIs that accept


88
00:04:40,916 --> 00:04:44,016
or return nils should
document what nil means


89
00:04:44,016 --> 00:04:45,206
as an exceptional case.


90
00:04:45,576 --> 00:04:47,736
I'll give you several
examples from our APIs.


91
00:04:48,326 --> 00:04:51,476
If you set the background color
of an NSTextView object to nil,


92
00:04:51,616 --> 00:04:53,126
it means don't draw
the background.


93
00:04:53,936 --> 00:04:55,486
A nil locale in many of our APIs


94
00:04:55,486 --> 00:04:58,696
that take locale
means nonlocalized.


95
00:04:58,696 --> 00:04:59,976
So you can specify a locale,


96
00:04:59,976 --> 00:05:02,696
but if you specify nil
it means nonlocalized.


97
00:05:03,286 --> 00:05:07,336
Let's talk about generics.


98
00:05:08,666 --> 00:05:12,366
Generics as you have
heard is lightweight type


99
00:05:12,366 --> 00:05:16,326
parameterization that we
added to Objective-C and great


100
00:05:16,646 --> 00:05:19,726
for specifying types of
elements in collections.


101
00:05:21,076 --> 00:05:23,116
Here is an example
of NSSearchField.


102
00:05:23,486 --> 00:05:24,916
The Recent Search property


103
00:05:24,916 --> 00:05:28,456
of NSSearchField is
declared like this in X v10.


104
00:05:28,456 --> 00:05:31,666
The name Recent Searches
is not superclear.


105
00:05:31,666 --> 00:05:33,126
What does this contain?


106
00:05:33,126 --> 00:05:34,716
Strings? URLs?


107
00:05:34,716 --> 00:05:35,916
Some search objects?


108
00:05:36,386 --> 00:05:39,926
In X v11 SDK, we
can clarify this.


109
00:05:39,976 --> 00:05:41,996
It is an array of NSString.


110
00:05:42,376 --> 00:05:45,516
And the Swift declaration goes
from an array of any object


111
00:05:45,766 --> 00:05:47,266
to an array of string as well.


112
00:05:47,836 --> 00:05:53,196
The way we have done this, we
have taken NSArray in Foundation


113
00:05:53,516 --> 00:05:56,256
and added the Object Type
parameter to it, like so.


114
00:05:56,256 --> 00:05:59,406
We have applied this object
type to all of the APIs,


115
00:05:59,886 --> 00:06:02,826
appropriate APIs, which
used to take or return ID,


116
00:06:02,826 --> 00:06:06,146
such as object at index,
contains object, and so on.


117
00:06:06,536 --> 00:06:09,916
There is many other APIs
this applies to in NSArray.


118
00:06:10,236 --> 00:06:13,866
With this, the code we
had with Recent Searches,


119
00:06:14,486 --> 00:06:15,806
let's say you had
a code like this,


120
00:06:16,266 --> 00:06:19,006
Recent Searches contains
object, some URL,


121
00:06:19,936 --> 00:06:21,196
we are passing in NSURL.


122
00:06:21,476 --> 00:06:24,536
The compiler now will warn
you that you're passing URL


123
00:06:25,126 --> 00:06:27,336
into a method that expects
an array of strings.


124
00:06:27,676 --> 00:06:30,246
The great thing here is this
code would have never failed


125
00:06:30,246 --> 00:06:32,696
or crashed because that
URL never would have been


126
00:06:32,696 --> 00:06:33,316
found before.


127
00:06:33,386 --> 00:06:36,496
The compiler is telling you of
a potential bug in the code.


128
00:06:38,166 --> 00:06:40,926
We have added generic support in
Foundation not only to NSArray


129
00:06:40,926 --> 00:06:43,996
but to all the other collections
as well, including NSEnumerator,


130
00:06:43,996 --> 00:06:48,106
which strictly speaking is not
even a collection, of course.


131
00:06:48,556 --> 00:06:50,486
You can apply this to
non-collections as well.


132
00:06:51,066 --> 00:06:55,266
Now with generics you can use
them as well, you can use them


133
00:06:55,316 --> 00:06:57,446
in variable declarations
in your own classes.


134
00:06:57,886 --> 00:07:00,876
If you are taking the result of
Recent Searches and assigning it


135
00:07:00,936 --> 00:07:04,716
to a property of your own,
you can go ahead and declarate


136
00:07:04,766 --> 00:07:07,866
that to be NSArray of NSString,
and that will allow the type


137
00:07:07,946 --> 00:07:09,536
to propagate through
your own code.


138
00:07:10,656 --> 00:07:12,116
You can declarate your
own properties in APIs.


139
00:07:12,116 --> 00:07:14,476
Here is an array of files.


140
00:07:14,476 --> 00:07:15,306
What are they?


141
00:07:15,306 --> 00:07:16,396
Strings or URLs?


142
00:07:16,906 --> 00:07:17,946
You can be clear.


143
00:07:17,946 --> 00:07:21,346
You can apply generics to
your custom collections


144
00:07:21,346 --> 00:07:23,686
if you have any or even
to your custom categories


145
00:07:23,686 --> 00:07:24,816
on foundation collections.


146
00:07:25,536 --> 00:07:28,216
For instance, here is
a category on NSArray.


147
00:07:29,076 --> 00:07:32,296
You can go in and add it, just
right there in your own code.


148
00:07:32,296 --> 00:07:34,736
These generics work
with categories as well.


149
00:07:35,346 --> 00:07:43,166
Now kindof is another feature
we have added to Objective-C.


150
00:07:43,636 --> 00:07:46,216
Let's give you motivation
as to why we need this.


151
00:07:46,656 --> 00:07:48,316
Here's what the subviews
declaration looked


152
00:07:48,316 --> 00:07:49,026
like in X v10.


153
00:07:49,896 --> 00:07:54,766
Here is what we did our first
attempt in applying generics.


154
00:07:55,456 --> 00:07:58,136
Subviews was changed
to NSArray of NSView.


155
00:07:58,806 --> 00:08:02,546
Then we had code like this,
where we assign an element


156
00:08:02,546 --> 00:08:04,116
out of this array into NSButton.


157
00:08:04,966 --> 00:08:07,206
Turns out that this
concerns the compiler,


158
00:08:07,746 --> 00:08:10,986
the compiler is always looking
out for us, always concerned.


159
00:08:11,456 --> 00:08:12,476
It generates a warning.


160
00:08:12,946 --> 00:08:15,606
Why? Because we're assigning
something that's explicitly


161
00:08:15,606 --> 00:08:18,626
declared to be an NSView
to a subclass of NSView,


162
00:08:18,816 --> 00:08:20,816
and the compiler is
right in being concerned.


163
00:08:21,326 --> 00:08:23,736
However, this is a kind
of code we use a lot,


164
00:08:23,736 --> 00:08:25,046
and it is often valid.


165
00:08:25,636 --> 00:08:28,586
So we added this kindof keyword
and changed the declaration


166
00:08:28,846 --> 00:08:33,486
of the subviews property to
be NSArray of kindof NSViews.


167
00:08:33,916 --> 00:08:35,145
What this says is --


168
00:08:36,515 --> 00:08:39,655
[Applause]


169
00:08:40,155 --> 00:08:40,895
>> ALI OZER: Thank you.


170
00:08:41,606 --> 00:08:45,976
Thank you for overlooking
the under bars there!


171
00:08:45,976 --> 00:08:48,096
What this says, it is okay
for the caller to be able


172
00:08:48,096 --> 00:08:50,826
to access the elements
of the array as instances


173
00:08:50,826 --> 00:08:54,086
of the specified class or
instances of a subclass as well.


174
00:08:54,826 --> 00:08:56,946
So this is now -- this works.


175
00:08:57,616 --> 00:09:02,826
Note that kindof is a compile
time facility like most


176
00:09:02,826 --> 00:09:04,206
of the things I have
talked about here.


177
00:09:04,676 --> 00:09:07,356
There is no runtime
code changes,


178
00:09:08,396 --> 00:09:11,196
there is no runtime check
for the type, for instance.


179
00:09:11,586 --> 00:09:14,066
There are cases where we
want the caller to think


180
00:09:14,066 --> 00:09:16,936
about what the elements
are before accessing them.


181
00:09:17,396 --> 00:09:20,526
So we're going to use
these sparingly in our APIs


182
00:09:20,526 --> 00:09:22,166
and we recommend
you do the same.


183
00:09:22,396 --> 00:09:24,466
They should be used when
it is safe for the caller


184
00:09:24,466 --> 00:09:25,566
to make that assumption.


185
00:09:25,896 --> 00:09:27,486
If you want the caller
to think twice


186
00:09:27,486 --> 00:09:29,816
or maybe do some runtime
query, don't use the kindof.


187
00:09:30,236 --> 00:09:32,346
An example is this
Representations method


188
00:09:32,346 --> 00:09:33,136
on NSImage.


189
00:09:33,866 --> 00:09:35,886
It returns an array
of NSImage reps,


190
00:09:36,066 --> 00:09:40,086
which are often subclassed,
almost always subclassed.


191
00:09:40,536 --> 00:09:42,136
However, we have
not used kindof here


192
00:09:42,136 --> 00:09:44,626
because the kindof
representations you get back


193
00:09:45,096 --> 00:09:47,686
isn't always predictable
and it might, in fact,


194
00:09:47,686 --> 00:09:50,406
change during the runtime
of an application or in fact


195
00:09:50,406 --> 00:09:52,216
between releases of the OS.


196
00:09:52,216 --> 00:09:54,576
It is better for the
caller to be more alert here


197
00:09:54,576 --> 00:09:55,866
and do some runtime checks.


198
00:09:56,386 --> 00:10:01,026
Let me talk about
error handling.


199
00:10:01,026 --> 00:10:03,906
As you heard yesterday, Swift
2 brings an amazing error


200
00:10:03,906 --> 00:10:06,326
handling facility.


201
00:10:08,226 --> 00:10:11,336
What that means is for a method
like this on NSData write


202
00:10:11,436 --> 00:10:15,426
to URL options error, it now
looks like this in Swift.


203
00:10:15,426 --> 00:10:18,206
The Boolean return value goes
away, it is now implicit.


204
00:10:18,566 --> 00:10:21,426
And the error, the by
reference NSError parameter,


205
00:10:21,726 --> 00:10:24,516
also goes away because it is
captured in the throw statement.


206
00:10:24,946 --> 00:10:28,486
Here is a kindof code you
write to deal with this.


207
00:10:28,486 --> 00:10:30,066
As you can see in
the catch phrase,


208
00:10:30,066 --> 00:10:32,986
you can capture the error,
it is either available


209
00:10:32,986 --> 00:10:34,886
for you automatically
or you can declare it.


210
00:10:34,886 --> 00:10:36,816
And you can declare
different catch statements,


211
00:10:36,816 --> 00:10:37,576
of course, as well.


212
00:10:38,066 --> 00:10:40,536
It is great, straightforward.


213
00:10:40,536 --> 00:10:41,876
Now, one thing.


214
00:10:42,056 --> 00:10:45,206
Note that despite the
terminology here, throw, try,


215
00:10:45,206 --> 00:10:47,516
catch, et cetera, these
are not exceptions


216
00:10:47,516 --> 00:10:48,606
in the Objective-C sense.


217
00:10:48,996 --> 00:10:50,606
We're not raising
exceptions here.


218
00:10:50,606 --> 00:10:53,796
We're actually returning
errors and unwinding properly


219
00:10:53,796 --> 00:10:58,116
through the stack just like, you
know, what we do with NSErrors.


220
00:10:58,816 --> 00:11:01,356
In fact, NSError
guidelines apply


221
00:11:01,446 --> 00:11:03,696
to the Swift error handling.


222
00:11:03,806 --> 00:11:08,056
Use NSErrors and Swift error
handling for runtime errors,


223
00:11:08,056 --> 00:11:10,656
errors that you expect to
present to the user or handle


224
00:11:10,656 --> 00:11:12,996
at runtime, such as file
not found and so forth.


225
00:11:12,996 --> 00:11:16,576
We continue to use
exceptions or Swift assertions


226
00:11:16,576 --> 00:11:20,266
for programming errors such
as array index out of bounds.


227
00:11:20,406 --> 00:11:22,736
The last category, of
course, are the kind of errors


228
00:11:22,736 --> 00:11:26,176
that are not expected
to be captured.


229
00:11:26,176 --> 00:11:28,386
One more Swiftification
item is naming cleanup.


230
00:11:29,186 --> 00:11:32,406
As you might be away, we
still have a lot of enum names


231
00:11:32,406 --> 00:11:35,896
from a long time ago where
we use a common suffix rather


232
00:11:35,896 --> 00:11:38,566
than common prefix, and we have
renamed them in some cases,


233
00:11:38,566 --> 00:11:40,576
not all, to have
a common prefix,


234
00:11:40,576 --> 00:11:41,766
which means that they come


235
00:11:41,766 --> 00:11:43,416
across in Swift with
a better name.


236
00:11:43,416 --> 00:11:45,466
Instead of dot left
text alignment it comes


237
00:11:45,466 --> 00:11:46,616
across as dot.left.


238
00:11:46,976 --> 00:11:48,476
There are many more
examples of this.


239
00:11:49,066 --> 00:11:51,446
Note that in many cases we
haven't actually deprecated the


240
00:11:51,446 --> 00:11:54,496
old names, so your sources
will continue to compile,


241
00:11:54,496 --> 00:11:56,896
but you can switch to the new
names as you rewrite your code.


242
00:11:57,386 --> 00:12:01,646
And there is many more of these.


243
00:12:01,676 --> 00:12:03,146
With that, let's
switch to AppKit.


244
00:12:04,576 --> 00:12:06,246
There are many AppKit
topics I would love


245
00:12:06,246 --> 00:12:09,356
to talk about, I'll
talk about some.


246
00:12:09,826 --> 00:12:13,666
One note here: from this point
on i'm going to show APIs


247
00:12:13,666 --> 00:12:16,426
and code samples
mostly in Swift.


248
00:12:16,596 --> 00:12:18,626
Even if you're not
comfortable yet in Swift,


249
00:12:19,086 --> 00:12:21,476
don't worry because no
code I show will be all


250
00:12:21,476 --> 00:12:22,256
that complicated.


251
00:12:22,736 --> 00:12:23,916
After all, I'm just a manager.


252
00:12:24,476 --> 00:12:25,506
It is important to note --


253
00:12:26,016 --> 00:12:27,126
[Laughter]


254
00:12:27,126 --> 00:12:27,766
>> ALI OZER: It is
important to note


255
00:12:27,766 --> 00:12:29,806
that these APIs are
all available


256
00:12:29,806 --> 00:12:31,226
in Objective-C and Swift.


257
00:12:31,536 --> 00:12:33,256
So we're not showing you
anything that works only


258
00:12:33,256 --> 00:12:34,426
for Objective-C or Swift.


259
00:12:34,426 --> 00:12:37,086
It is available for whatever
language you're using.


260
00:12:37,616 --> 00:12:43,686
As you know, the new Force
Touch trackpad brings pressure


261
00:12:43,686 --> 00:12:46,716
sensitivity as well
as haptic feedback.


262
00:12:46,806 --> 00:12:49,696
opening up interesting
possibilities for applications.


263
00:12:49,696 --> 00:12:53,486
Let's look at some use cases.


264
00:12:53,486 --> 00:12:56,956
Here, for instance, by applying
Force Click on some text,


265
00:12:56,956 --> 00:12:59,796
you can do lookup or you
can automatically create a


266
00:12:59,796 --> 00:13:00,426
calendar event.


267
00:13:01,626 --> 00:13:03,686
In this case, by
applying a pressure


268
00:13:03,686 --> 00:13:05,816
to the fast-forward button,
you can cause the movie


269
00:13:05,816 --> 00:13:07,936
to fast-forward even faster.


270
00:13:08,496 --> 00:13:13,006
Here you can apply pressure
to draw thin or thick strokes


271
00:13:13,246 --> 00:13:16,446
when you're signing your name
or doing drawing in markup.


272
00:13:17,336 --> 00:13:20,996
Finally, in this case, as you
move objects around in a program


273
00:13:20,996 --> 00:13:23,936
like Xcode's Interface
Builder or in a drawing program


274
00:13:24,316 --> 00:13:27,576
as objects go into alignment
you will get haptic feedback.


275
00:13:28,306 --> 00:13:32,666
Now some of the Force Touch APIs
made an appearance in X v10.3,


276
00:13:32,666 --> 00:13:34,796
some of you may have seen those.


277
00:13:35,146 --> 00:13:37,376
First, we have accelerator
controls APIs.


278
00:13:38,246 --> 00:13:40,956
These APIs interpret variable
pressure and are useful


279
00:13:40,956 --> 00:13:43,746
for creating the likes of
the fast-forward buttons


280
00:13:43,746 --> 00:13:45,746
or zoom buttons in an
application like Maps.


281
00:13:46,146 --> 00:13:48,476
You can set accelerator
controls on NSButton


282
00:13:48,476 --> 00:13:49,616
in NSSegmentedControl.


283
00:13:50,236 --> 00:13:51,726
If you want to do more
sophisticated things


284
00:13:51,726 --> 00:13:55,266
with pressure, we give you
an event, a new event type


285
00:13:55,316 --> 00:13:57,716
for pressure with the
corresponding methods


286
00:13:57,956 --> 00:14:00,276
on NSResponder and
gesture recognizer as well,


287
00:14:00,376 --> 00:14:01,656
Pressure Change With event.


288
00:14:01,656 --> 00:14:03,406
You can interpreter
pressure events yourself.


289
00:14:04,376 --> 00:14:08,286
In X v11, we introduced
several new classes.


290
00:14:08,286 --> 00:14:10,106
One is pressure configuration
class.


291
00:14:10,526 --> 00:14:12,526
You set the pressure
configuration of a view


292
00:14:12,526 --> 00:14:13,746
or gesture recognizer


293
00:14:14,026 --> 00:14:16,406
to indicate how the
trackpad should react.


294
00:14:16,916 --> 00:14:18,976
In general, the haptic
feedback provided


295
00:14:18,976 --> 00:14:20,296
to the user will be dependent


296
00:14:20,296 --> 00:14:22,466
on the pressure configuration
you specified.


297
00:14:22,976 --> 00:14:26,106
We have two other classes,
haptic feedback manager


298
00:14:26,106 --> 00:14:28,416
and alignment feedback
filter, allowing you


299
00:14:28,416 --> 00:14:34,896
to customize the kind of haptic
feedback you give to the user.


300
00:14:34,896 --> 00:14:38,356
Many of you may have
used spring loading.


301
00:14:38,736 --> 00:14:42,026
That's when you start a
drag, and when you hover


302
00:14:42,026 --> 00:14:44,656
over a destination the
destination opens up for you.


303
00:14:44,816 --> 00:14:46,226
You probably use this in Finder.


304
00:14:46,686 --> 00:14:48,876
With Force Click, we now have it


305
00:14:48,936 --> 00:14:52,706
such that you can also do
spring loading immediately just


306
00:14:52,706 --> 00:14:54,346
by force clicking
on the destination.


307
00:14:55,136 --> 00:14:59,536
We have a new API for making
spring loading even easier.


308
00:14:59,536 --> 00:15:02,776
This is just a simple Boolean
property, spring loaded


309
00:15:02,776 --> 00:15:04,916
on NSButton and
NSSegmentedControl,


310
00:15:05,286 --> 00:15:08,416
and the action will be sent
on hover or on Force Click.


311
00:15:08,606 --> 00:15:09,586
Very straightforward.


312
00:15:09,936 --> 00:15:15,326
If this doesn't quite meet your
needs, we have a new protocol,


313
00:15:15,426 --> 00:15:17,336
NSSpringLoadingDestination,
which allows you


314
00:15:17,336 --> 00:15:19,526
to do spring loading on
arbitrary destinations.


315
00:15:20,036 --> 00:15:24,086
For example, the Finder example
would be appropriate for this.


316
00:15:24,276 --> 00:15:26,906
Swipe to delete, you're
familiar with this,


317
00:15:26,906 --> 00:15:29,656
you saw it yesterday
likely in the keynote


318
00:15:29,956 --> 00:15:33,316
and you may be familiar with
it from iOS, you can swipe left


319
00:15:33,316 --> 00:15:37,956
or right in a table view such
as the messages list in Mail


320
00:15:38,026 --> 00:15:40,936
to mark messages as unread,
or delete them, and so on.


321
00:15:41,236 --> 00:15:43,246
We now have API for
this also in El Capitan.


322
00:15:43,826 --> 00:15:44,816
It is a delegate method


323
00:15:44,876 --> 00:15:47,056
on NSTableView, Row
Actions for Row.


324
00:15:47,556 --> 00:15:50,686
You simply return an array
of NSTableView row action,


325
00:15:51,066 --> 00:15:56,796
and these instances of the class
simply declares how the items,


326
00:15:56,856 --> 00:15:59,266
the row should be drawn
and what should happen


327
00:15:59,266 --> 00:16:01,656
when the user selects that
action via this block,


328
00:16:01,746 --> 00:16:04,486
this handler block at the end.


329
00:16:04,486 --> 00:16:05,836
I sort of breezed
through the topics.


330
00:16:06,236 --> 00:16:09,026
There is a talk, Adopting
New Rrackpad Features,


331
00:16:09,026 --> 00:16:11,826
Thursday morning at 10:00
a.m. that you can catch


332
00:16:11,826 --> 00:16:14,406
that will give you more
detail on these topics.


333
00:16:15,586 --> 00:16:18,176
Full screen, you heard
about this yesterday.


334
00:16:18,306 --> 00:16:21,626
Full screen enables you to
remove distractions and focus


335
00:16:21,626 --> 00:16:24,216
on one task, as you
can see here.


336
00:16:24,486 --> 00:16:28,986
Now with split view full screen,
you can focus on one task


337
00:16:29,036 --> 00:16:30,786
but possibily bring
in another window.


338
00:16:30,866 --> 00:16:34,026
For instance, here you are using
Xcode and you brought up Safari


339
00:16:34,026 --> 00:16:36,686
to look at some documentation
or some forums.


340
00:16:36,996 --> 00:16:38,976
You can imagine bringing
up messages next to Xcode


341
00:16:38,976 --> 00:16:42,036
because you want to chat
with a buddy about a piece


342
00:16:42,036 --> 00:16:42,816
of code you're writing.


343
00:16:43,696 --> 00:16:45,986
This is called tiling, when
the windows are brought


344
00:16:46,526 --> 00:16:47,536
into split view.


345
00:16:48,656 --> 00:16:51,436
Tiling is automatic
for many windows.


346
00:16:52,866 --> 00:16:55,156
Resizable windows are
automatically eligible


347
00:16:55,156 --> 00:16:55,736
for tiling.


348
00:16:55,736 --> 00:16:57,056
This means your applications,


349
00:16:57,056 --> 00:16:58,386
the windows in your
applications,


350
00:16:58,386 --> 00:17:01,416
will automatically be candidates
for being tiled in full screen


351
00:17:01,416 --> 00:17:02,776
without any changes
on your part.


352
00:17:03,146 --> 00:17:05,386
Whether they're full
screen-capable or not already.


353
00:17:06,086 --> 00:17:09,146
However, there is API for opting
windows in and out of tiling,


354
00:17:09,246 --> 00:17:12,146
and it's part of this NSWindow
collection behavior options


355
00:17:12,146 --> 00:17:12,896
on NSWindow.


356
00:17:13,715 --> 00:17:15,675
For instance, you may
have a nonresizable window


357
00:17:15,675 --> 00:17:17,226
that you think should
be tillable.


358
00:17:17,695 --> 00:17:19,976
You can use the Allowd
Tiling option.


359
00:17:20,126 --> 00:17:22,156
Or you have an antisocial window


360
00:17:22,156 --> 00:17:23,586
that just doesn't
want to be tiled.


361
00:17:23,695 --> 00:17:25,236
You can set Disallows Tiling.


362
00:17:25,415 --> 00:17:28,236
I don't know an example
of that, but it is there.


363
00:17:28,636 --> 00:17:31,756
These joined full
screen primary settings


364
00:17:31,756 --> 00:17:34,226
that we had here
already in X v7.


365
00:17:34,286 --> 00:17:37,086
It is important to note that the
full-screen primary is the way


366
00:17:37,086 --> 00:17:41,356
that you specify a window
should go into full screen.


367
00:17:41,726 --> 00:17:44,106
Note that this is still
very much an opt-in setting


368
00:17:44,706 --> 00:17:47,666
because we want you to think
about how your windows behave


369
00:17:47,806 --> 00:17:50,006
in the vast screen
space of full screen,


370
00:17:50,346 --> 00:17:53,146
so that is still an opt-in
thing where you think


371
00:17:53,146 --> 00:17:55,216
about how your window
should act in full screen.


372
00:17:55,216 --> 00:17:59,306
That one you still opt into.


373
00:18:00,246 --> 00:18:03,186
You can also set these of course
in Xcode's attributes inspector


374
00:18:03,186 --> 00:18:04,866
as well, both the tiling


375
00:18:04,866 --> 00:18:07,916
and whether a window
becomes full screen or not.


376
00:18:07,916 --> 00:18:10,206
I said that tiling is
automatic for many windows,


377
00:18:10,486 --> 00:18:12,216
but AppKit does check to see,


378
00:18:12,216 --> 00:18:14,806
make sure that windows can
coexist in the same screen.


379
00:18:15,186 --> 00:18:17,016
Imagine you have a
relatively small screen


380
00:18:17,016 --> 00:18:20,786
and two fairly large windows,
when you try to tile them,


381
00:18:20,856 --> 00:18:23,036
if the windows cannot
be resized small enough,


382
00:18:23,036 --> 00:18:24,906
AppKit will not allow
them to be tiled.


383
00:18:24,906 --> 00:18:29,236
I want you to think about how
your windows can resize small


384
00:18:29,236 --> 00:18:31,876
enough, how they can be
flexible enough to fit


385
00:18:31,876 --> 00:18:35,576
into the smaller area
of tiled split view.


386
00:18:36,146 --> 00:18:39,086
To help achieve this,
we have some APIs.


387
00:18:39,256 --> 00:18:41,846
For instance, split view item
now has sidebar behavior,


388
00:18:42,146 --> 00:18:44,766
where the sidebar gets
smaller and collapses


389
00:18:44,806 --> 00:18:47,136
and can be brought
back up as an overlay,


390
00:18:47,576 --> 00:18:48,986
and also has proper vibrancy.


391
00:18:49,816 --> 00:18:53,296
NSStackView automatic detaching
of hidden views allows you


392
00:18:53,296 --> 00:18:56,106
to create NSToolbar-like
experiences


393
00:18:56,106 --> 00:18:58,396
for your custom views
where the items,


394
00:18:58,396 --> 00:19:00,216
as they're dropped off the edge,


395
00:19:00,346 --> 00:19:03,096
can be put into a
menu, and so on.


396
00:19:03,646 --> 00:19:04,446
And many more.


397
00:19:04,666 --> 00:19:05,746
You can hear about these


398
00:19:05,746 --> 00:19:07,876
in Improving the
Full-Screen Window Experience,


399
00:19:07,876 --> 00:19:09,066
which is Thursday afternoon.


400
00:19:11,246 --> 00:19:14,626
Auto Layout, as you know,
this is very important,


401
00:19:14,626 --> 00:19:16,756
we have made some
significant changes,


402
00:19:16,756 --> 00:19:19,616
significant improvements
in Auto Layout as well.


403
00:19:19,946 --> 00:19:21,166
First is stack view.


404
00:19:22,416 --> 00:19:25,276
Stack view is a very
important class.


405
00:19:25,536 --> 00:19:28,356
It should be the first-stop
shop for your Auto Layout needs.


406
00:19:28,356 --> 00:19:30,026
If you can get done what
you have to get done


407
00:19:30,026 --> 00:19:31,176
within a stack view rather


408
00:19:31,176 --> 00:19:33,206
than using constraints
directly, do it.


409
00:19:33,206 --> 00:19:36,406
It is a high level of
abstraction, very powerful.


410
00:19:36,856 --> 00:19:39,896
First good news about stack view
is it is now on iOS as well,


411
00:19:39,896 --> 00:19:43,196
as UI stack view, with
equal pretty much APIs.


412
00:19:43,196 --> 00:19:46,196
This goes along with
our constant attempt


413
00:19:46,196 --> 00:19:49,096
of bringing parity
between our platforms,


414
00:19:49,136 --> 00:19:50,456
and this is one of
those examples.


415
00:19:50,846 --> 00:19:52,796
Secondly, it is now
even better than ever.


416
00:19:52,836 --> 00:19:55,486
I already mentioned the
detaching functionality.


417
00:19:55,936 --> 00:19:58,086
There is also new options
for view distribution


418
00:19:58,086 --> 00:19:59,596
with this property
called distribution.


419
00:20:01,206 --> 00:20:03,276
One value in here
is gravity areas,


420
00:20:03,276 --> 00:20:07,426
which is the option you had
in stack view from day one


421
00:20:07,516 --> 00:20:09,386
when we introduced it in X v9.


422
00:20:09,386 --> 00:20:11,296
We have added other settings,


423
00:20:11,296 --> 00:20:12,606
and rather than explaining
these,


424
00:20:12,836 --> 00:20:14,556
I will show you a quick video.


425
00:20:14,556 --> 00:20:18,476
There are six stack views here
configured with these settings.


426
00:20:18,516 --> 00:20:21,036
I will resize the
window, larger,


427
00:20:21,036 --> 00:20:22,526
smaller, back larger again.


428
00:20:22,726 --> 00:20:25,286
As you can see, you get
some powerful functionality,


429
00:20:25,346 --> 00:20:27,926
such as ability to have
equal sizes, equal spacing,


430
00:20:27,926 --> 00:20:30,666
and so on that hopefully
will fit your needs.


431
00:20:30,666 --> 00:20:34,346
The stack views can be
nested in arbitrary ways


432
00:20:34,416 --> 00:20:36,346
to give you powerful layouts.


433
00:20:36,946 --> 00:20:40,146
NSLayoutAnchor is a new
class providing a concise


434
00:20:40,366 --> 00:20:42,636
representation of an
edge or dimension.


435
00:20:43,046 --> 00:20:44,376
Let's say you have
two views and you want


436
00:20:44,376 --> 00:20:45,696
to create a constraint
between them.


437
00:20:46,326 --> 00:20:47,866
This is code that you would
have had to have write.


438
00:20:48,546 --> 00:20:51,926
With layout anchors, here is
the code that you can write.


439
00:20:52,506 --> 00:20:55,426
Note that these two items here
are basically layout anchors


440
00:20:55,426 --> 00:20:58,286
referring to those
edges of those views,


441
00:20:58,666 --> 00:21:00,776
and this is not only
shorter, sweeter,


442
00:21:00,776 --> 00:21:04,026
it is also giving you more
compile time type-checking.


443
00:21:04,026 --> 00:21:04,476
It is great.


444
00:21:05,516 --> 00:21:10,076
[Applause]


445
00:21:10,576 --> 00:21:12,836
>> ALI OZER: NSLayoutGuide
is another new class.


446
00:21:12,836 --> 00:21:15,826
If you ever find yourself
doing this sort of stuff,


447
00:21:15,886 --> 00:21:20,596
creating dummy views to do
things like equal spacing


448
00:21:20,596 --> 00:21:24,126
between views, you can now
instead create layout guides.


449
00:21:24,126 --> 00:21:27,256
It's a lightweight object that
takes the place of a view,


450
00:21:27,256 --> 00:21:29,826
but it is much lighter
weight so it can participate


451
00:21:29,826 --> 00:21:31,806
in Auto Layout without
creating views.


452
00:21:33,306 --> 00:21:35,846
Collection view has been
with us for a while.


453
00:21:36,306 --> 00:21:39,666
As you know, UICollectionView
was also introduced a few


454
00:21:39,766 --> 00:21:41,356
releases ago.


455
00:21:41,786 --> 00:21:44,426
With X v11, we brought
NSCollectionView to parity


456
00:21:44,426 --> 00:21:47,686
with the iOS version while still
maintaining important features


457
00:21:47,686 --> 00:21:50,226
for the desktop, such as drag
and drop and bulk selection.


458
00:21:50,816 --> 00:21:53,356
So here are some of the features
in the new collection view.


459
00:21:53,816 --> 00:21:56,346
Features such as
heterogeneous items,


460
00:21:56,346 --> 00:21:58,386
optional grouping,
customizable layout.


461
00:21:58,846 --> 00:22:01,696
Let me show you a quick video
of a sample application here.


462
00:22:01,696 --> 00:22:03,556
There is a bunch of
images being displayed.


463
00:22:03,556 --> 00:22:08,396
I will first group by group with
headers and footers and use some


464
00:22:08,396 --> 00:22:10,506
of the custom layouts
provided by the app.


465
00:22:11,726 --> 00:22:15,006
You see this app in action and
learn about the features and how


466
00:22:15,006 --> 00:22:17,206
to apply them in your own
applications in What's New


467
00:22:17,206 --> 00:22:20,216
in Collection View, that's
Thursday afternoon at 4:30.


468
00:22:22,436 --> 00:22:23,876
We have some great
changes in text.


469
00:22:24,166 --> 00:22:25,936
First is the new system UI font.


470
00:22:26,246 --> 00:22:30,456
Here is what the new system
font looks like, San Francisco.


471
00:22:30,456 --> 00:22:35,136
As you know, it is the same
font on iOS and watchOS as well.


472
00:22:35,826 --> 00:22:39,156
This font is automatic
for applications.


473
00:22:39,156 --> 00:22:41,976
When you run your application
in X v11 on El Capitan,


474
00:22:41,976 --> 00:22:42,926
you will get this font.


475
00:22:43,006 --> 00:22:44,816
But it's possible that
you are doing something


476
00:22:44,816 --> 00:22:45,516
that prevents this.


477
00:22:46,026 --> 00:22:49,586
If you see this font, it
was introduced in X v10,


478
00:22:49,806 --> 00:22:53,596
there is something going on,
check it to see what you need


479
00:22:53,596 --> 00:22:55,786
to do to make sure you're
using San Francisco.


480
00:22:56,446 --> 00:23:00,356
If you're using this font, this
is one we introduced in X v0,


481
00:23:00,356 --> 00:23:02,506
more of that is going on.


482
00:23:02,976 --> 00:23:05,896
Finally, if you're
using this font --


483
00:23:06,066 --> 00:23:08,066
[Laughter]


484
00:23:08,116 --> 00:23:09,566
>> ALI OZER: You have
a lot of work to do.


485
00:23:09,806 --> 00:23:10,396
Hang in there.


486
00:23:11,496 --> 00:23:13,826
This was the font we
stopped using in Mac OS 9.


487
00:23:13,826 --> 00:23:18,386
Here are the APIs in
NSFont that you can use


488
00:23:18,386 --> 00:23:20,736
to make sure you're using
the latest system font,


489
00:23:21,126 --> 00:23:22,846
system font of size and so on.


490
00:23:22,846 --> 00:23:25,926
These fonts, these
APIs, they have been


491
00:23:25,926 --> 00:23:27,096
with us for a long time.


492
00:23:27,676 --> 00:23:32,196
You can set the system fonts via
the Xcode attributes inspector.


493
00:23:32,726 --> 00:23:34,776
Fairly straightforward
There is a pop-up,


494
00:23:34,826 --> 00:23:36,766
you choose the appropriate
system font


495
00:23:36,766 --> 00:23:37,646
for your application.


496
00:23:39,456 --> 00:23:41,916
We do have new API for a system
font at different weights.


497
00:23:42,476 --> 00:23:45,956
If your designers are asking
you to use different weights,


498
00:23:46,416 --> 00:23:49,056
you can now do that with a
system font with this API,


499
00:23:49,266 --> 00:23:51,346
system font of size and weight.


500
00:23:52,016 --> 00:23:54,656
There is nine different
weights predefined,


501
00:23:54,706 --> 00:23:56,406
I'm showing you only
three of them,


502
00:23:56,616 --> 00:23:58,026
ranging from ultralight
to black.


503
00:23:58,476 --> 00:24:00,626
The regular setting is
what you get by default


504
00:24:00,626 --> 00:24:01,806
for system font of size.


505
00:24:02,676 --> 00:24:06,916
We have another API, mono space
system font of size weight.


506
00:24:07,496 --> 00:24:08,936
Let me show you why
you need this.


507
00:24:09,996 --> 00:24:14,286
If you call the system font
of size API in an application


508
00:24:14,286 --> 00:24:16,646
that is linked against X v11 SDK


509
00:24:16,646 --> 00:24:19,096
and you draw some digits,
here is what you see.


510
00:24:19,616 --> 00:24:24,036
Those of you with eagle eyes
for fonts may note, wow,


511
00:24:24,126 --> 00:24:26,516
those digits are
not fixed pitched,


512
00:24:26,516 --> 00:24:27,476
they're different widths.


513
00:24:28,066 --> 00:24:31,076
This is shocking because
traditionally system fonts have


514
00:24:31,076 --> 00:24:33,476
always had digits that
are the same width.


515
00:24:33,946 --> 00:24:39,466
That's to make sure that tabular
data appears organized or UIs


516
00:24:39,466 --> 00:24:43,306
with changing numbers
in text doesn't jiggle


517
00:24:43,306 --> 00:24:44,676
as the numbers are changing.


518
00:24:45,526 --> 00:24:47,236
But now, if your app is linked


519
00:24:47,236 --> 00:24:50,636
against X v11 you will get this
system font with the fonts.


520
00:24:50,846 --> 00:24:53,246
If you have to have
fixed pitched fonts,


521
00:24:53,366 --> 00:24:56,816
that's when you use this
API, this will give up digits


522
00:24:56,896 --> 00:24:59,266
that are equal widths.


523
00:24:59,746 --> 00:25:02,776
Typographically not as pleasing,
but it will get the job done.


524
00:25:03,216 --> 00:25:05,496
The changes are drastic.


525
00:25:05,776 --> 00:25:08,796
Here is the proportional, and
here is the fixed widths ones.


526
00:25:09,006 --> 00:25:10,086
It is a tool for you.


527
00:25:10,716 --> 00:25:13,826
You can hear more about
this and more about the APIs


528
00:25:13,826 --> 00:25:15,416
in Introducing New System Fonts,


529
00:25:15,416 --> 00:25:18,856
which is Friday afternoon
at 2:30.


530
00:25:19,196 --> 00:25:23,136
I also mentioned new APIs, there
is new APIs in the tech system.


531
00:25:23,476 --> 00:25:26,916
These bring new functionality
and parity with TextKit and iOS,


532
00:25:27,426 --> 00:25:28,556
there is a lot of items here.


533
00:25:28,556 --> 00:25:30,736
I'm just going to cover
two, three of them.


534
00:25:31,136 --> 00:25:32,526
First is exclusion paths.


535
00:25:33,126 --> 00:25:36,276
This is the ability to
easily put paths so you can


536
00:25:36,276 --> 00:25:38,736
to wrap text around objects
such as this butterfly,


537
00:25:38,796 --> 00:25:41,476
it is straightforward.


538
00:25:42,196 --> 00:25:44,926
Another one is two properties
on text field: maximum number


539
00:25:44,926 --> 00:25:48,116
of lines, which is great
especially with Auto Layout,


540
00:25:48,526 --> 00:25:53,976
or allows default tightening
for truncation, which allows you


541
00:25:53,976 --> 00:25:55,466
to specify if the contents


542
00:25:55,466 --> 00:25:59,016
of the text field should be
tightened before it actually


543
00:25:59,016 --> 00:25:59,716
gets truncated.


544
00:25:59,786 --> 00:26:02,546
There was a way to control this,
before but now it is controlled


545
00:26:02,546 --> 00:26:03,766
with this one Boolean property.


546
00:26:05,226 --> 00:26:07,646
There are many more changes,
these are some highlights.


547
00:26:07,646 --> 00:26:11,836
So last thing I want to talk


548
00:26:11,836 --> 00:26:14,656
about in the AppKit
section is visual atomicity.


549
00:26:15,276 --> 00:26:17,676
You may wonder, what
is visual atomicity?


550
00:26:18,386 --> 00:26:19,106
A mountain?


551
00:26:19,106 --> 00:26:22,316
What does it have to
do with Half Dome?


552
00:26:22,346 --> 00:26:25,096
I'll show you a short clip
demonstrating what I mean


553
00:26:25,096 --> 00:26:28,426
by visual atomicity or
lack of visual atomicity.


554
00:26:28,746 --> 00:26:30,566
You see the Open
panel come up twice.


555
00:26:31,406 --> 00:26:33,086
First time, okay, not great.


556
00:26:33,776 --> 00:26:41,276
Second time, judge for yourself.


557
00:26:42,526 --> 00:26:44,936
Unless you blinked, you
saw what I'm talking about.


558
00:26:45,206 --> 00:26:46,726
Let's show you in slow motion.


559
00:26:47,226 --> 00:26:49,466
Shadow. Parts of the panel.


560
00:26:49,566 --> 00:26:50,356
Rest of the panel.


561
00:26:50,796 --> 00:26:53,796
This is the Open panel
running in Yosemite.


562
00:26:54,686 --> 00:26:57,136
Open panel is a rough
case because it is drawn


563
00:26:57,136 --> 00:27:00,136
by multiple processes,
but that's not an excuse.


564
00:27:00,456 --> 00:27:03,316
A UI like this should
appear to the user as coming


565
00:27:03,316 --> 00:27:05,976
up in one step, one
frame, it shouldn't go


566
00:27:05,976 --> 00:27:08,876
through a few visual
steps like that.


567
00:27:09,576 --> 00:27:11,236
That's what we mean
by visual atomicity,


568
00:27:11,236 --> 00:27:14,436
achieving that one
single-step drawing when needed.


569
00:27:15,256 --> 00:27:18,796
Those of you who had to
[undecipherable] windows, views,


570
00:27:19,086 --> 00:27:21,626
also Core Animation
layers explicitly,


571
00:27:21,626 --> 00:27:24,176
you know that achieving
visual atomicity is not always


572
00:27:24,176 --> 00:27:25,076
that straightforward.


573
00:27:26,546 --> 00:27:28,766
There are a number of APIs,
you don't have to read


574
00:27:28,766 --> 00:27:30,216
through the list,
there is no quiz.


575
00:27:30,676 --> 00:27:32,896
There are a number of
APIs that do the job,


576
00:27:32,956 --> 00:27:36,366
but they don't necessarily
work well together.


577
00:27:36,366 --> 00:27:41,636
In X v11, we fixed it up so that
you can achieve visual atomicity


578
00:27:41,636 --> 00:27:42,966
with NSAnimationContext.


579
00:27:44,786 --> 00:27:47,856
You can call Begin Grouping or
End Grouping or its equivalent,


580
00:27:47,856 --> 00:27:50,146
Run Animation Group,
around a bunch


581
00:27:50,146 --> 00:27:53,506
of independent drawing you're
doing, such as you see here.


582
00:27:53,566 --> 00:27:56,946
This should give you
visual atomicity.


583
00:27:56,946 --> 00:28:00,876
Beyond this, we discourage the
use of Disable Screen Updates


584
00:28:00,876 --> 00:28:01,946
and Enable Screen Updates


585
00:28:01,946 --> 00:28:04,046
and Disable Screen
Updates until Flush.


586
00:28:04,486 --> 00:28:07,506
They're not deprecated, but
they are not recommended anymore


587
00:28:07,816 --> 00:28:12,956
and should not be necessary.


588
00:28:12,956 --> 00:28:15,376
With that, we can
move on to Foundation.


589
00:28:15,996 --> 00:28:18,286
There is a lot of things to talk
about in Foundation as well.


590
00:28:19,696 --> 00:28:20,876
First one is undo manager.


591
00:28:21,846 --> 00:28:25,636
Those of you who used undo
manager from Swift know


592
00:28:25,636 --> 00:28:28,506
that undo manager APIs is
not a perfect fit in Swift.


593
00:28:29,216 --> 00:28:30,666
This is what the APIs look like.


594
00:28:30,966 --> 00:28:34,506
The first has a selector, and
it only works in some cases.


595
00:28:34,506 --> 00:28:36,166
The second one has
an indication.


596
00:28:36,546 --> 00:28:39,646
NSIndication in Objective-C
is of course awesome,


597
00:28:39,886 --> 00:28:42,976
but it doesn't know about all
of the fancier types in Swift.


598
00:28:43,576 --> 00:28:45,966
So we're adding block-based
undo.


599
00:28:46,926 --> 00:28:48,666
This is how it looks
in Objective-C,


600
00:28:48,666 --> 00:28:50,086
and this is how it
looks in Swift.


601
00:28:50,586 --> 00:28:52,626
As you will see, there
is a target argument


602
00:28:52,916 --> 00:28:55,196
and also a block, which
is basically the code


603
00:28:55,196 --> 00:28:57,946
to be executed to undo
the action you just did.


604
00:28:59,126 --> 00:29:01,836
Separate argument for the
target means you don't have


605
00:29:01,886 --> 00:29:03,526
to reference the
target in the block,


606
00:29:03,526 --> 00:29:05,236
which avoids retain cycles.


607
00:29:05,706 --> 00:29:07,486
And there is also a
use of generic type


608
00:29:07,486 --> 00:29:09,616
in the Swift declaration, and
I'll tell you how it works.


609
00:29:10,296 --> 00:29:11,286
Here is an example.


610
00:29:11,626 --> 00:29:13,146
You have a class
named Colorful Shape,


611
00:29:13,726 --> 00:29:15,346
it's got a property named Color,


612
00:29:17,106 --> 00:29:20,066
we add a Did Set property
observer to this property.


613
00:29:20,426 --> 00:29:23,376
This is just one of the ways
you can do undo, you can undo


614
00:29:23,376 --> 00:29:24,926
in other ways as well,
but here we're doing it


615
00:29:24,926 --> 00:29:26,066
in the Did Set property.


616
00:29:26,066 --> 00:29:28,626
This is the call to
register undo with target,


617
00:29:29,386 --> 00:29:32,756
and here is actually the code to
be executed to undo the action


618
00:29:32,826 --> 00:29:33,616
that I might be doing.


619
00:29:34,476 --> 00:29:38,696
Note that thanks to the use of
generics in the register undo


620
00:29:38,696 --> 00:29:41,496
at target, this all works


621
00:29:41,546 --> 00:29:43,676
and the target is
automatically recognized


622
00:29:43,676 --> 00:29:46,316
as a colorful shape thanks to
the reference to self there


623
00:29:46,316 --> 00:29:48,136
in the register undo column.


624
00:29:48,136 --> 00:29:52,066
You don't have to cast the
target to colorful shape.


625
00:29:53,036 --> 00:29:55,156
NSCoder now has error handling.


626
00:29:55,656 --> 00:29:58,756
Those of you who have used
NSCoders like NSKeyedArchiver


627
00:29:58,756 --> 00:30:02,946
or so on, you know there is no
error arguments to those things.


628
00:30:02,946 --> 00:30:04,646
We have added explicit
error handling.


629
00:30:05,406 --> 00:30:08,456
Methods such as these, Decode
Object for Key and Decode Object


630
00:30:08,726 --> 00:30:11,186
of Classes for Key,
now have versions


631
00:30:11,186 --> 00:30:13,836
that actually return errors,
throw errors in Swift.


632
00:30:14,276 --> 00:30:16,476
They're named Decode
Top Level Object for Key


633
00:30:16,476 --> 00:30:18,486
and Decode Top Level
Object of Classes for Key.


634
00:30:18,886 --> 00:30:21,876
Note that they have
throws declaration,


635
00:30:21,876 --> 00:30:23,296
which means that
they return an error.


636
00:30:23,636 --> 00:30:25,976
And note that they
return an optional object


637
00:30:26,006 --> 00:30:29,056
because a nil return is actually
a valid return out of these,


638
00:30:29,056 --> 00:30:31,396
it just indicates that the
object was not in the archive.


639
00:30:33,216 --> 00:30:36,176
Note that these are named
Decode Top Level Object for Key,


640
00:30:36,176 --> 00:30:39,356
and we intend for this to
be used at the top levels


641
00:30:39,356 --> 00:30:41,216
when you're unarchiving
your root objects.


642
00:30:41,496 --> 00:30:44,366
We don't intend these to be
called in your implementations


643
00:30:44,366 --> 00:30:45,276
of [unintelligible] coder.


644
00:30:46,726 --> 00:30:48,666
Also note that these are not
the only the two methods we have


645
00:30:48,666 --> 00:30:51,026
here; we have another two or
three to go along with all


646
00:30:51,026 --> 00:30:55,526
of the decode object type
methods we have currently.


647
00:30:56,176 --> 00:30:59,666
NSError now has a value
provider, let me model this.


648
00:31:00,256 --> 00:31:04,486
This is a simple way you may
be creating an NSError object.


649
00:31:04,486 --> 00:31:06,696
It's pretty simple,
straightforward, however,


650
00:31:06,696 --> 00:31:08,226
note that it's not
user presentable.


651
00:31:08,576 --> 00:31:10,506
If this were ever to
be shown to the user,


652
00:31:10,506 --> 00:31:11,596
this is what they'll see.


653
00:31:12,176 --> 00:31:16,286
Not good. This is really what
you would like them to see


654
00:31:16,286 --> 00:31:17,966
if this was ever
presented to the user.


655
00:31:18,246 --> 00:31:20,466
Even if you don't ever present
this to the user, you know,


656
00:31:20,466 --> 00:31:22,576
in the debugger something like
this would be helpful too,


657
00:31:22,576 --> 00:31:24,326
as opposed to getting error 42.


658
00:31:25,266 --> 00:31:28,366
So the code that you write
for this looks like this.


659
00:31:29,386 --> 00:31:33,536
So you specify the values for
various keys, and if you want it


660
00:31:33,536 --> 00:31:36,246
to be user presentable you
would also localize them.


661
00:31:36,856 --> 00:31:38,396
So you know, it is
a bunch of code,


662
00:31:38,926 --> 00:31:40,996
you can create methods
here forever.


663
00:31:41,186 --> 00:31:44,206
The code isn't the problem,
writing code, it is our job,


664
00:31:44,206 --> 00:31:46,296
right, we're paid for it,
that's not the problem.


665
00:31:46,616 --> 00:31:48,896
The problem is that all this
is happening at the time


666
00:31:48,896 --> 00:31:51,956
that errors are being
created even if the consumer


667
00:31:51,956 --> 00:31:53,746
of the error does
nothing with the error.


668
00:31:53,746 --> 00:31:55,806
So it is, performance-wise,
wasteful.


669
00:31:56,436 --> 00:31:58,796
So we've added this
ability to create


670
00:31:58,796 --> 00:32:01,076
and return desired
values on demand.


671
00:32:02,296 --> 00:32:05,646
We have this method, set
user info value provider


672
00:32:05,646 --> 00:32:07,236
for domain provider.


673
00:32:07,476 --> 00:32:11,186
You basically specify a
domain you created for NSError


674
00:32:11,186 --> 00:32:13,966
in your application and provide
a provider, which is a block


675
00:32:13,966 --> 00:32:17,206
that returns values
for any keys missing


676
00:32:17,206 --> 00:32:18,296
in the user info dictionary.


677
00:32:18,296 --> 00:32:20,256
So it will be invoked
on demand lazily.


678
00:32:20,586 --> 00:32:24,206
You can go back to using this
nice, shortened piece of code


679
00:32:24,206 --> 00:32:28,086
for generating errors, and
the user information will be


680
00:32:29,036 --> 00:32:31,036
filled dynamically.


681
00:32:31,096 --> 00:32:32,806
You may be familiar
with NSProgress.


682
00:32:32,966 --> 00:32:35,276
It is an object for
reporting progress


683
00:32:35,276 --> 00:32:36,716
and it has a great feature


684
00:32:36,716 --> 00:32:41,736
where it will implicitly compose
progress from across a hierarchy


685
00:32:41,736 --> 00:32:43,616
of operations and
it will present


686
00:32:43,616 --> 00:32:45,656
that to the user as
one single number.


687
00:32:46,126 --> 00:32:47,976
It is pretty good,
but it is implicit.


688
00:32:48,676 --> 00:32:52,196
As being implicit,
it has some issues


689
00:32:52,196 --> 00:32:53,196
that you may have run into.


690
00:32:53,546 --> 00:32:55,616
We're introducing
an explicit mode


691
00:32:55,616 --> 00:32:57,106
for managing progress reporting.


692
00:32:57,766 --> 00:33:00,436
This has two pieces:
one is APIs to add


693
00:33:00,436 --> 00:33:03,456
and remove child progress
objects directly to a hierarchy


694
00:33:03,456 --> 00:33:06,486
of progress objects and
the second is this protocol


695
00:33:06,486 --> 00:33:09,426
which lets you declare the
progress on an object directly.


696
00:33:09,866 --> 00:33:12,086
For instance, if you have
a subclass of NSOperation,


697
00:33:12,086 --> 00:33:16,466
which does some one-shot
operation, you know, it starts


698
00:33:16,466 --> 00:33:19,526
and ends, it is a good candidate
for this progress property.


699
00:33:19,846 --> 00:33:23,266
It allows it to opt in to
explicit progress reporting.


700
00:33:24,426 --> 00:33:27,056
NSProgress now also has
the ability to resume.


701
00:33:27,436 --> 00:33:30,476
It had the ability to pause,
we have added the second part.


702
00:33:32,066 --> 00:33:34,876
NSNotificationCenter
now has the ability


703
00:33:34,876 --> 00:33:37,466
to automatically unregister
the allocated observers.


704
00:33:39,516 --> 00:33:43,176
[Applause]


705
00:33:43,676 --> 00:33:45,056
>> ALI OZER: Here is the kind
of code you would have had


706
00:33:45,056 --> 00:33:47,476
to have write to add
yourself as an observer,


707
00:33:47,476 --> 00:33:48,406
and here is the code you write


708
00:33:48,406 --> 00:33:49,686
to remove yourself
as an observer.


709
00:33:49,946 --> 00:33:51,546
You can call this
code if you want


710
00:33:51,546 --> 00:33:53,356
to remove yourself
as an observer.


711
00:33:53,876 --> 00:33:57,286
If you don't, and freed, you'll
automatically be unregistered.


712
00:33:57,356 --> 00:33:59,316
That's pretty great.


713
00:34:01,406 --> 00:34:05,966
So here is the class whose name
Toby did not dare say yesterday


714
00:34:05,966 --> 00:34:09,576
in the State of the Union,
NSFirstNameComponentsFormatter.


715
00:34:09,996 --> 00:34:13,106
The rule is, if it is not
long enough to be wrapped


716
00:34:13,106 --> 00:34:15,085
on a slide title,
it is not too long.


717
00:34:15,246 --> 00:34:17,306
So,
NSFirstNameComponentsFomatter.


718
00:34:18,146 --> 00:34:20,666
It allows proper localized
formatting of names.


719
00:34:20,936 --> 00:34:23,616
This joins other
formatters we have added


720
00:34:23,616 --> 00:34:26,656
over the last few years such
as date components formatter,


721
00:34:27,045 --> 00:34:29,356
byte count formatter,
length formatter, and so on.


722
00:34:30,606 --> 00:34:34,196
It also provides styles for
a number of different forms.


723
00:34:34,346 --> 00:34:35,815
Let me give you a quick example.


724
00:34:36,306 --> 00:34:39,666
You create a person named
Components Object, it has parts


725
00:34:39,666 --> 00:34:42,295
of name, you specify the
parts of name you have,


726
00:34:42,466 --> 00:34:44,976
there is many more, let's say
here we're specifying three


727
00:34:44,976 --> 00:34:45,235
of them.


728
00:34:46,726 --> 00:34:49,376
Then you create a person in
componenst formatter and ask


729
00:34:49,376 --> 00:34:50,606
for it to be formatted.


730
00:34:51,196 --> 00:34:54,226
Depending on the kind
of style that you give,


731
00:34:54,226 --> 00:34:56,436
you get different forms
of the name, like long,


732
00:34:56,466 --> 00:34:58,286
default, short, and so on.


733
00:34:58,696 --> 00:35:01,856
Note that if you ask for short,
but in some other language,


734
00:35:01,856 --> 00:35:05,576
you may get a totally different
form of the name depending


735
00:35:05,576 --> 00:35:07,426
on rules of localization
for that language.


736
00:35:07,426 --> 00:35:09,146
Don't make assumptions
about the kind


737
00:35:09,146 --> 00:35:11,126
of names you will get
back from this API.


738
00:35:11,916 --> 00:35:14,256
The purpose of this API,
one of the main purposes is


739
00:35:14,256 --> 00:35:16,276
to isolate you from complexities


740
00:35:16,276 --> 00:35:18,336
of writing world-ready
applications.


741
00:35:19,316 --> 00:35:22,516
NSString has new APIs to
help you write world-ready


742
00:35:22,516 --> 00:35:24,196
internationalizable
applications.


743
00:35:24,636 --> 00:35:27,486
There is facility for
conditional quotation,


744
00:35:27,776 --> 00:35:31,556
whether a technical term, for
instance, should be surrounded


745
00:35:31,816 --> 00:35:34,406
by quotes, for which rules
change in different languages.


746
00:35:34,766 --> 00:35:37,236
Simpler localized case
changing and searching APIs,


747
00:35:38,106 --> 00:35:41,306
transliteration APIs, which
previously were in CFString,


748
00:35:41,306 --> 00:35:44,296
now they're in NSString,
and also facilities


749
00:35:44,296 --> 00:35:47,276
for adaptive strings
for UI presentation.


750
00:35:47,606 --> 00:35:51,406
You can provide multiple forms,
multiple lengths of the string


751
00:35:51,406 --> 00:35:54,716
in your strings files and have
the right one chosen depending


752
00:35:54,716 --> 00:35:58,026
on how much space you have
in your UI to display it.


753
00:35:58,136 --> 00:36:00,936
You can hear about the person
name components formatter


754
00:36:01,286 --> 00:36:03,836
and all of these facilities
and more in What's New


755
00:36:03,836 --> 00:36:05,736
in Internationalization,
which is Friday morning


756
00:36:05,736 --> 00:36:10,066
at 9:00 a.m. Let me talk
about thermal state.


757
00:36:10,066 --> 00:36:15,156
These are APIs introduced in X
v10.3, which was the same time


758
00:36:15,156 --> 00:36:18,146
as our sexy new MacBook
which, of course,


759
00:36:18,146 --> 00:36:20,286
as you may know doesn't
have any fans


760
00:36:20,396 --> 00:36:23,256
and in fact is a good
case study for this API.


761
00:36:23,896 --> 00:36:27,646
Note that although this API was
introduced at the same time,


762
00:36:27,866 --> 00:36:30,816
it works on our other machines


763
00:36:30,816 --> 00:36:32,396
and is generally
available and functional.


764
00:36:32,396 --> 00:36:33,936
It's not just for
the MacBook only.


765
00:36:34,806 --> 00:36:37,896
This API is captured
with a property,


766
00:36:37,896 --> 00:36:40,026
a thermal state property
on NSProcessInfo.


767
00:36:40,456 --> 00:36:43,196
It has four values: nominal,
fair, serious, critical.


768
00:36:43,586 --> 00:36:46,836
There is a notification you can
get whenever the value changes.


769
00:36:48,496 --> 00:36:51,476
Note that serious, that's
when the fans are going


770
00:36:51,476 --> 00:36:53,796
at maximum speed if
your machine had fans,


771
00:36:54,246 --> 00:36:56,876
imagine what's happening
if you don't have fans.


772
00:36:57,196 --> 00:36:59,586
Serious is typically when
you want to take some action.


773
00:36:59,586 --> 00:37:02,376
For instance, let's say
you're doing custom animation


774
00:37:03,386 --> 00:37:05,306
at 60 FIPS, this a time to think


775
00:37:05,306 --> 00:37:07,346
about reducing your
animation to 30 FIPS.


776
00:37:07,846 --> 00:37:11,056
That's what NSScrollView
will do for you automatically


777
00:37:11,056 --> 00:37:12,856
so you don't have to worry
about NSScrollView case.


778
00:37:13,196 --> 00:37:15,156
Let's say you're using
high-quality textures


779
00:37:15,156 --> 00:37:17,696
in the application and you
get a serious thermal state,


780
00:37:18,176 --> 00:37:21,116
time to drop to maybe
lower-quality textures.


781
00:37:22,166 --> 00:37:25,296
This API is great for cases when
you need it, but it is important


782
00:37:25,296 --> 00:37:28,726
to note that this API is
reactive and not proactive.


783
00:37:28,726 --> 00:37:32,046
It is the kind of API where the
system calls you to tell you


784
00:37:32,046 --> 00:37:35,146
of trouble and you have to
take action, and, of course,


785
00:37:35,146 --> 00:37:36,966
the action you take
is not adding more


786
00:37:36,966 --> 00:37:38,056
to the load on the system.


787
00:37:38,696 --> 00:37:40,956
We have a lot of other
APIs which are proactive


788
00:37:40,956 --> 00:37:43,666
that we have introduced
over the last few releases.


789
00:37:44,386 --> 00:37:46,976
These are the kind of APIs
where you tell the system


790
00:37:46,976 --> 00:37:51,756
about what you're doing, and the
system optimizes your activities


791
00:37:51,756 --> 00:37:55,666
and tasks based on whatever
happens to be going on.


792
00:37:56,046 --> 00:37:58,046
For instance, tolerance
on timers,


793
00:37:58,396 --> 00:38:01,936
process info activity
APIs, doing downloads


794
00:38:01,936 --> 00:38:03,786
in the background
with NSURLSession,


795
00:38:03,846 --> 00:38:06,526
setting quality service, so on.


796
00:38:07,476 --> 00:38:10,826
These APIs allow not only
energy efficient behavior,


797
00:38:10,826 --> 00:38:13,156
but they also enable
proper thermal behavior.


798
00:38:13,156 --> 00:38:17,496
They enable longer battery
life and make your system coo,


799
00:38:17,856 --> 00:38:19,826
figuratively and
literally as well.


800
00:38:22,386 --> 00:38:26,326
Last, core data, quick mention
here since I'm short on time.


801
00:38:26,696 --> 00:38:29,136
A lot of great features in
core data, unique constraints


802
00:38:29,136 --> 00:38:31,796
and batch deletion and many
other API enhancements,


803
00:38:32,046 --> 00:38:33,106
that's all I'll say.


804
00:38:34,176 --> 00:38:35,746
Of course, it wouldn't
be a what's new talk


805
00:38:35,746 --> 00:38:38,106
if I don't leave a lot
of things on the floor.


806
00:38:38,436 --> 00:38:40,646
These are many other topics
I just didn't get around to,


807
00:38:40,646 --> 00:38:42,746
you can read about them
hopefully in the release notes.


808
00:38:43,176 --> 00:38:45,656
This is not even including
amazing new technologies


809
00:38:45,716 --> 00:38:48,086
such as Metal or
GameplayKit as well.


810
00:38:48,686 --> 00:38:53,366
In summary, we have a lot
of general API improvements


811
00:38:53,366 --> 00:38:55,246
across the board
for Swiftification.


812
00:38:55,246 --> 00:38:57,956
In addition, we have a lot of
great features and enhancements.


813
00:38:58,666 --> 00:39:03,466
Look at the material, think
about how to adopt them,


814
00:39:03,466 --> 00:39:07,266
and come see us at the labs
if you have any questions.


815
00:39:07,736 --> 00:39:10,426
For more information,
here are the pointers.


816
00:39:10,806 --> 00:39:13,006
The AppKit and Foundation
release notes are available


817
00:39:13,006 --> 00:39:16,176
at developer.apple.com.osx.


818
00:39:16,236 --> 00:39:19,516
The release notes are for the
seed, so it's a good source.


819
00:39:20,086 --> 00:39:21,506
Thank you for joining me today.


820
00:39:21,506 --> 00:39:22,856
Have a great rest
of the conference.


821
00:39:23,516 --> 00:39:28,500
[Applause]

