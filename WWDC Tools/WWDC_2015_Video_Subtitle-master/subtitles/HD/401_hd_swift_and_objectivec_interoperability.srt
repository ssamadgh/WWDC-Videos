1
00:00:25,406 --> 00:00:26,386
>> JORDAN ROSE: Good
afternoon, everyone.


2
00:00:26,986 --> 00:00:27,956
My name is Jordan Rose.


3
00:00:28,516 --> 00:00:33,306
[Applause]


4
00:00:33,806 --> 00:00:34,006
>> JORDAN ROSE: Wow.


5
00:00:34,006 --> 00:00:34,266
Thank you.


6
00:00:34,266 --> 00:00:35,316
I haven't even done
anything yet.


7
00:00:36,346 --> 00:00:37,246
My name is Jordan Rose.


8
00:00:37,246 --> 00:00:39,446
Joining me later will be
my colleague, Doug Gregor.


9
00:00:39,536 --> 00:00:41,926
We are here to talk to you about
the language changes we made


10
00:00:41,926 --> 00:00:44,606
in both Swift and
Objective-C over the last year,


11
00:00:45,006 --> 00:00:47,516
especially in the areas
of interoperability.


12
00:00:48,166 --> 00:00:51,746
And this is important because
all Objective-C APIs are


13
00:00:51,746 --> 00:00:52,936
available in Swift.


14
00:00:53,726 --> 00:00:56,116
And in Xcode 7 we
made it even easier


15
00:00:56,116 --> 00:00:57,606
to see how this mapping works.


16
00:00:57,716 --> 00:00:59,676
Go to any Objective-C header


17
00:01:00,076 --> 00:01:02,506
and choose the 'show
related items' button


18
00:01:02,686 --> 00:01:03,766
in the top-left corner.


19
00:01:04,256 --> 00:01:06,296
This will bring down a
menu of related items,


20
00:01:06,356 --> 00:01:09,066
one of which is 'generated
interface.'


21
00:01:09,846 --> 00:01:12,796
And this will show you the
Swift mapping for that header.


22
00:01:13,966 --> 00:01:15,956
This is the exact
same view that you got


23
00:01:16,056 --> 00:01:19,446
in Xcode 6 using the 'jump
to definition' feature,


24
00:01:19,766 --> 00:01:22,726
but now you can get it easily
from any header in your target.


25
00:01:22,726 --> 00:01:26,266
So we are going to be
talking about a variety


26
00:01:26,266 --> 00:01:29,126
of improvements today that we
have made to Swift for working


27
00:01:29,126 --> 00:01:31,086
with Objective-C, and
that we have been making


28
00:01:31,086 --> 00:01:32,346
to Objective-C itself.


29
00:01:32,446 --> 00:01:35,496
We will start off with some
of the basic features working


30
00:01:35,496 --> 00:01:38,296
between Swift and
Objective-C, and at the details


31
00:01:38,296 --> 00:01:40,716
of the new error-handling
feature and how that works


32
00:01:40,716 --> 00:01:41,976
across the language boundaries.


33
00:01:42,386 --> 00:01:43,406
After that, we are going to talk


34
00:01:43,406 --> 00:01:44,946
about the three major
improvements we've made


35
00:01:44,946 --> 00:01:47,936
to Objective-C in the last
year, nullability annotations,


36
00:01:48,046 --> 00:01:50,556
lightweight generics,
and kindof types.


37
00:01:52,206 --> 00:01:53,866
Let's start on the
Swift side of things.


38
00:01:54,536 --> 00:01:56,346
We just saw how easy it is


39
00:01:56,346 --> 00:01:58,876
to get the Objective-C
APIs into Swift.


40
00:01:58,956 --> 00:02:01,626
But a lot of people come
up with the question,


41
00:02:01,976 --> 00:02:05,126
when is my Swift
exposed to Objective-C?


42
00:02:06,456 --> 00:02:08,276
And so, let's go over
the rules for this.


43
00:02:09,925 --> 00:02:12,506
If you have a class that's
a subclass of NSObject,


44
00:02:12,976 --> 00:02:14,406
then by default, its methods


45
00:02:14,406 --> 00:02:16,686
and properties are
exposed to Objective-C.


46
00:02:17,266 --> 00:02:20,046
In this case, we have a class
MyController that's a subclass


47
00:02:20,046 --> 00:02:21,256
of UIViewController.


48
00:02:21,616 --> 00:02:23,826
That's indirectly a
subclass of NSObject,


49
00:02:24,196 --> 00:02:28,126
so this refresh method will
be exposed to Objective-C.


50
00:02:29,356 --> 00:02:32,446
However, if you mark
that method as private,


51
00:02:33,106 --> 00:02:35,696
that means it's only supposed to
be visible to the current file.


52
00:02:36,246 --> 00:02:39,286
So in this case, Swift
will not expose the method


53
00:02:39,286 --> 00:02:41,036
to Objective-C by default.


54
00:02:42,076 --> 00:02:44,416
Additionally, if you
are only using --


55
00:02:44,546 --> 00:02:46,746
if you are using some kind
of Swift-only feature,


56
00:02:47,056 --> 00:02:49,776
like this unusual return
type here, then, again,


57
00:02:50,206 --> 00:02:52,696
there's no way to expose
this method to Objective-C


58
00:02:52,806 --> 00:02:55,756
and Swift won't even try.


59
00:02:55,956 --> 00:03:00,116
Finally, if you are not
a subclass of NSObject


60
00:03:00,546 --> 00:03:03,416
but simply conforming to
an Objective-C protocol,


61
00:03:03,966 --> 00:03:05,736
then you have to take
extra care to make sure


62
00:03:05,736 --> 00:03:08,146
that your methods actually
satisfy the requirements


63
00:03:08,146 --> 00:03:08,846
of the protocol.


64
00:03:09,266 --> 00:03:11,506
And in Xcode 7, you will
get a warning for this.


65
00:03:12,116 --> 00:03:16,036
In this case, 'web view did
start load' is non-objc,


66
00:03:16,296 --> 00:03:18,456
and so it cannot
satisfy the requirements


67
00:03:18,686 --> 00:03:20,826
of the 'UI web view
delegate protocol.'


68
00:03:21,446 --> 00:03:24,086
So that covers the defaults.


69
00:03:24,756 --> 00:03:26,196
What happens when you
want to change those


70
00:03:26,536 --> 00:03:27,656
from that default behavior?


71
00:03:28,756 --> 00:03:31,276
So let's go back to that
version of MyController here


72
00:03:31,276 --> 00:03:33,636
with the refresh method,
and I want to expose it


73
00:03:33,636 --> 00:03:36,306
to Objective-C, but
it really depends --


74
00:03:36,446 --> 00:03:39,476
what I want to do next really
depends on what I need to do


75
00:03:39,476 --> 00:03:40,616
with this refresh method.


76
00:03:41,286 --> 00:03:45,166
So, if I'm going to make this,
say, something that I want


77
00:03:45,166 --> 00:03:48,046
to use an interface builder
or maybe it's a property


78
00:03:48,046 --> 00:03:49,046
that I want to use
from Core data,


79
00:03:49,546 --> 00:03:51,336
we have dedicated
attributes for these,


80
00:03:51,406 --> 00:03:53,746
and adding that attribute
is all you need to do.


81
00:03:54,236 --> 00:03:56,976
So, if you use the IBAction
attribute as shown here,


82
00:03:58,466 --> 00:03:59,426
that's all you need to do


83
00:03:59,426 --> 00:04:01,676
to make this refresh
method a valid action


84
00:04:01,676 --> 00:04:02,626
in interface builder.


85
00:04:04,196 --> 00:04:06,546
Similarly, if you are
looking to use a property


86
00:04:06,746 --> 00:04:09,006
with foundations key
value observing system,


87
00:04:09,196 --> 00:04:11,366
or Cocoa bindings, all you need


88
00:04:11,366 --> 00:04:13,736
to do is add the
dynamic modifier.


89
00:04:14,196 --> 00:04:15,906
This tells Swift that
the implementation


90
00:04:15,906 --> 00:04:18,666
of this property might
be replaced at run time


91
00:04:18,896 --> 00:04:20,636
by the key value
observing system.


92
00:04:22,036 --> 00:04:24,996
But if you really just want
to expose a particular method


93
00:04:24,996 --> 00:04:26,656
or property to Objective-C,


94
00:04:27,006 --> 00:04:31,516
you can always just use the
plain-old at-objc modifier,


95
00:04:31,516 --> 00:04:36,436
or objc attribute -- sorry --
and this will expose a method


96
00:04:36,436 --> 00:04:37,956
or objective to Objective-C


97
00:04:38,176 --> 00:04:39,776
without any additional
semantics.


98
00:04:40,066 --> 00:04:44,156
The objc attribute is also
useful for one other thing,


99
00:04:44,426 --> 00:04:46,996
which is to figure out why
something is not visible


100
00:04:46,996 --> 00:04:48,896
in Objective-C when you
thought it would be.


101
00:04:49,406 --> 00:04:52,176
So if I tried to apply this to
that other version of Refresh


102
00:04:52,176 --> 00:04:54,046
that has the unusual
result type here,


103
00:04:54,046 --> 00:04:57,376
then I will get an error message
saying this 'method cannot be


104
00:04:57,376 --> 00:05:00,216
marked at-objc because
its result type cannot be


105
00:05:00,216 --> 00:05:03,006
represented in Objective-C.'


106
00:05:03,246 --> 00:05:06,766
All of these rules are covered
in the 'Using Swift with Cocoa


107
00:05:06,766 --> 00:05:09,566
and Objective-C' guide,
which is available online


108
00:05:09,656 --> 00:05:12,546
at developer.apple.com/Swift.


109
00:05:13,736 --> 00:05:16,536
So now we've covered the
defaults, and we've covered what


110
00:05:16,536 --> 00:05:19,006
to do when you want to
override those defaults


111
00:05:19,456 --> 00:05:21,306
to make things more ObjC.


112
00:05:21,306 --> 00:05:23,526
But what if you have
the opposite problem?


113
00:05:25,006 --> 00:05:27,526
Let's look at this class
here: calculator controller.


114
00:05:28,086 --> 00:05:30,606
It has two methods named
'perform operation.'


115
00:05:31,216 --> 00:05:32,876
One of them takes
one kind of closure


116
00:05:33,026 --> 00:05:34,666
and the other takes a
different kind of closure.


117
00:05:35,626 --> 00:05:36,316
That's fine.


118
00:05:36,566 --> 00:05:39,256
Swift is able to differentiate
these methods purely based


119
00:05:39,256 --> 00:05:40,286
on their argument types.


120
00:05:41,086 --> 00:05:42,706
But Objective-C doesn't
work like this.


121
00:05:42,926 --> 00:05:45,426
In Objective-C, methods
are only differentiated


122
00:05:45,426 --> 00:05:47,246
by name, not by type.


123
00:05:48,636 --> 00:05:51,306
And so in this case, Swift
knows this might be an issue


124
00:05:51,306 --> 00:05:52,806
and it will give you
an error message.


125
00:05:54,006 --> 00:05:55,046
Now, you have always been able


126
00:05:55,046 --> 00:05:58,966
to fix this using the selector
form of the ObjC attribute.


127
00:05:59,476 --> 00:06:02,936
So if I write this code, then
I've renamed the bottom method


128
00:06:03,006 --> 00:06:05,456
to 'perform binary operation,


129
00:06:05,866 --> 00:06:07,986
when I'm accessing
it from Objective-C.


130
00:06:08,646 --> 00:06:11,536
The top method is still
named 'perform operation.'


131
00:06:12,236 --> 00:06:16,636
In Xcode 7, we've added another
option for solving this problem,


132
00:06:16,876 --> 00:06:18,636
which is the non-ObjC attribute.


133
00:06:19,176 --> 00:06:20,346
As you might have expected,


134
00:06:20,606 --> 00:06:23,606
this will take something that's
normally exposed to Objective-C


135
00:06:23,826 --> 00:06:26,606
and prevent it from
being exposed as such.


136
00:06:27,036 --> 00:06:29,806
You can apply the non-ObjC
attribute to any method,


137
00:06:30,086 --> 00:06:32,496
property, subscript,
or initializer.


138
00:06:33,126 --> 00:06:37,366
So that's a fair amount about
Objective-C and methods,


139
00:06:37,706 --> 00:06:39,506
but how about something
lower level.


140
00:06:40,656 --> 00:06:41,666
Let's talk about C.


141
00:06:42,286 --> 00:06:45,486
So there are a few people in
this room that are really happy


142
00:06:45,486 --> 00:06:47,176
that we have a slide
called function pointers.


143
00:06:49,636 --> 00:06:52,736
[Laughter] A function pointer
is what C uses for callbacks.


144
00:06:53,416 --> 00:06:55,876
That means they are
kind of like closures,


145
00:06:56,406 --> 00:06:58,676
but they can't carry any
additional state with them.


146
00:06:59,336 --> 00:07:00,466
What do I mean by that?


147
00:07:01,466 --> 00:07:03,086
Let's say I'm in
Swift and I'm trying


148
00:07:03,086 --> 00:07:05,516
to call this C function,
funopen.


149
00:07:05,766 --> 00:07:07,416
It takes a lot of arguments.


150
00:07:07,416 --> 00:07:08,686
You don't have to know
what they all are.


151
00:07:09,116 --> 00:07:10,136
One of them is a callback.


152
00:07:11,176 --> 00:07:14,376
In this callback, I'm trying
to use self to do something.


153
00:07:14,986 --> 00:07:18,296
Now, self is not an
argument to this closure.


154
00:07:18,886 --> 00:07:20,686
So it has to be stored
away somewhere


155
00:07:20,686 --> 00:07:22,176
for the closure to access later.


156
00:07:23,106 --> 00:07:25,486
That's what we mean by a
closure carrying state.


157
00:07:25,956 --> 00:07:29,136
So when you try to use this
closure, with this API,


158
00:07:29,546 --> 00:07:32,156
you get an error message.


159
00:07:32,306 --> 00:07:36,476
Now, in Swift 1.2, C function
pointers weren't very useful.


160
00:07:36,946 --> 00:07:39,366
You had this C type that
is shown on the top,


161
00:07:39,566 --> 00:07:43,306
and it came into Swift as this
opaque, C function pointer type.


162
00:07:43,626 --> 00:07:47,526
You could pass it around but you
couldn't do much else with it.


163
00:07:47,716 --> 00:07:50,976
In Swift 2.0, we've just
made these a special kind


164
00:07:50,976 --> 00:07:53,606
of closure marked with the
convention-C attribute.


165
00:07:54,006 --> 00:07:55,456
You can create these in Swift,


166
00:07:55,666 --> 00:07:57,676
pass them around,
and even call them.


167
00:07:58,116 --> 00:08:00,226
Which means there's a
whole family of C APIs


168
00:08:00,506 --> 00:08:02,386
that you can now
access directly in Swift


169
00:08:02,496 --> 00:08:03,526
that you couldn't before.


170
00:08:05,516 --> 00:08:10,666
[Applause]


171
00:08:11,166 --> 00:08:11,986
>> JORDAN ROSE: So
those are just two


172
00:08:11,986 --> 00:08:14,516
of the little things we have
done to enhance the bridge


173
00:08:14,516 --> 00:08:17,466
from Swift and to
C and Objective-C.


174
00:08:18,476 --> 00:08:20,726
But there's also some
big-name features this year


175
00:08:20,726 --> 00:08:22,226
that have had some
really big impacts


176
00:08:22,226 --> 00:08:23,386
on this language bridging.


177
00:08:24,576 --> 00:08:26,666
The most important, of
course, being error handling.


178
00:08:28,176 --> 00:08:29,466
Now, if you haven't really heard


179
00:08:29,466 --> 00:08:33,275
about the error handling model
yet, essentially we took a lot


180
00:08:33,275 --> 00:08:37,496
of lessons from Cocoa's
NSError paradigm and the rules


181
00:08:37,496 --> 00:08:39,155
and the conventions
that surrounded that,


182
00:08:39,696 --> 00:08:41,416
and used what we
learned from that


183
00:08:41,686 --> 00:08:43,096
to make a new language feature,


184
00:08:43,186 --> 00:08:45,256
represented by the
'throws' keyword.


185
00:08:46,106 --> 00:08:48,486
This was covered in a lot of
depth in this morning's talk


186
00:08:48,486 --> 00:08:49,486
"What's New In Swift."


187
00:08:50,126 --> 00:08:53,276
Which was -- which you -- if
you didn't make it to that,


188
00:08:53,276 --> 00:08:55,586
I strongly suggest you
check it out later on,


189
00:08:55,586 --> 00:08:58,606
to find out really how all this
error handling stuff works.


190
00:08:59,126 --> 00:09:04,266
But what I want to focus on now
is specifics about this going


191
00:09:04,266 --> 00:09:05,766
between the two languages.


192
00:09:06,526 --> 00:09:08,136
And one thing I want
you to understand is


193
00:09:08,136 --> 00:09:11,176
that this isn't just a mapping
from Objective-C into Swift.


194
00:09:11,576 --> 00:09:15,766
It's also how Swift APIs get
exposed back to Objective-C.


195
00:09:16,426 --> 00:09:18,296
So this mapping is
bidirectional.


196
00:09:18,866 --> 00:09:22,316
Let's take a closer look
at the return types here.


197
00:09:23,076 --> 00:09:26,236
In Objective-C, the
error conventions say


198
00:09:26,476 --> 00:09:30,536
that returning a nil value
represents a failure case.


199
00:09:31,326 --> 00:09:33,876
That's when this 'out
error' parameter is going


200
00:09:33,876 --> 00:09:34,836
to be populated.


201
00:09:36,056 --> 00:09:38,496
In Swift, however,
that's entirely covered


202
00:09:38,496 --> 00:09:41,656
by the error handling model, and
so the return type you will see


203
00:09:41,656 --> 00:09:45,666
in Swift is a non-optional
object type.


204
00:09:46,726 --> 00:09:48,486
Similarly in Objective-C,


205
00:09:48,486 --> 00:09:50,586
you can also have a
Boolean return value


206
00:09:51,046 --> 00:09:53,036
where the no case
is the failure case.


207
00:09:53,536 --> 00:09:56,726
Again, that's entirely
covered by the Swift model


208
00:09:57,006 --> 00:09:59,296
and so the return type
you will get will be void.


209
00:09:59,946 --> 00:10:04,026
Now, on both of these examples,
I have shown that these methods


210
00:10:04,026 --> 00:10:06,096
in Objective-C have
multiple parameters,


211
00:10:06,096 --> 00:10:07,956
only one of which is
the error parameter,


212
00:10:08,516 --> 00:10:11,046
but there are also cases where
methods only have one parameter


213
00:10:11,256 --> 00:10:12,126
and you will get something


214
00:10:12,126 --> 00:10:15,406
like 'check resource is
researchable and return error.'


215
00:10:16,216 --> 00:10:18,806
As you can see in Swift,
since we already know


216
00:10:18,806 --> 00:10:20,376
that the method can
return an error


217
00:10:20,696 --> 00:10:22,066
from that 'throws' keyword,


218
00:10:22,306 --> 00:10:24,066
we will chop off
those last three words


219
00:10:24,096 --> 00:10:25,466
for you, just for you!


220
00:10:27,776 --> 00:10:30,756
[Laughter] Now, all of
this is about what happens


221
00:10:30,756 --> 00:10:33,586
when you have the
NSError-star-star type,


222
00:10:33,586 --> 00:10:35,696
when you are using
the really basic form


223
00:10:35,696 --> 00:10:37,706
of the NSError conventions.


224
00:10:38,116 --> 00:10:39,406
What happens in other cases?


225
00:10:39,986 --> 00:10:42,276
Well, we just keep things as is.


226
00:10:42,636 --> 00:10:45,596
If you have an NSError in
Objective-C, it will come


227
00:10:45,596 --> 00:10:48,326
into Swift usually as an
optional NSError reference


228
00:10:48,616 --> 00:10:50,366
and you can handle
it as appropriate


229
00:10:50,366 --> 00:10:52,076
for whatever API you are using.


230
00:10:53,146 --> 00:10:57,006
Remember that NSError conforms
to Swift's error type protocol,


231
00:10:57,006 --> 00:10:58,206
so you can also use it


232
00:10:58,206 --> 00:11:00,316
with Swift's own error
handling mechanisms.


233
00:11:00,316 --> 00:11:05,786
All of this shows that Swift
is well equipped to deal


234
00:11:05,786 --> 00:11:08,026
with all the errors
coming from Objective-C.


235
00:11:09,206 --> 00:11:12,086
But what if I call a
method from Objective-C,


236
00:11:12,846 --> 00:11:15,936
and it's a Swift method
that produces a Swift error?


237
00:11:16,626 --> 00:11:19,696
Now, of course, we
need this to work.


238
00:11:19,926 --> 00:11:21,326
Let's find out how it works.


239
00:11:22,656 --> 00:11:24,936
Here I have a type
named 'request error.'


240
00:11:25,256 --> 00:11:28,416
It's a new type I'm defining
using Swift's error system.


241
00:11:28,606 --> 00:11:31,616
It conforms to the error type
protocol, and in this case,


242
00:11:31,616 --> 00:11:35,526
it's an enum that only has
one possible enum case.


243
00:11:36,726 --> 00:11:39,466
I can use this error in
a method very easily.


244
00:11:39,996 --> 00:11:42,256
Here I'm defining a
'send request' method.


245
00:11:42,556 --> 00:11:45,236
I mark it with the
'throws' keyword to indicate


246
00:11:45,236 --> 00:11:48,436
that it can fail, and then
I actually use the 'throw'


247
00:11:48,436 --> 00:11:50,926
statement when I hit
that failure condition.


248
00:11:51,506 --> 00:11:55,246
Now, if I try to call this
method from Objective-C,


249
00:11:55,246 --> 00:11:56,416
it ought to just work.


250
00:11:56,836 --> 00:11:58,646
Let's see what that looks like.


251
00:11:59,836 --> 00:12:02,086
The first thing to
notice is that the name


252
00:12:02,086 --> 00:12:03,436
of the method has changed.


253
00:12:03,756 --> 00:12:05,296
Instead of just 'send request,


254
00:12:05,526 --> 00:12:07,706
we now have 'send
request error.'


255
00:12:08,416 --> 00:12:09,676
The name that you
would have used


256
00:12:09,676 --> 00:12:12,256
if you had written this method
in Objective-C to begin with.


257
00:12:13,326 --> 00:12:17,106
Additionally, we're just using
a plain-old NSError type,


258
00:12:17,146 --> 00:12:19,476
from foundation here,
even though the error


259
00:12:19,476 --> 00:12:21,296
that we produced
came from Swift.


260
00:12:22,226 --> 00:12:25,526
And what's more, that error
type actually contains


261
00:12:25,526 --> 00:12:26,806
useful information.


262
00:12:27,156 --> 00:12:30,126
If we print the domain and
code that go with this error,


263
00:12:30,376 --> 00:12:33,866
we will see that it turns out
to be the type and the raw value


264
00:12:33,866 --> 00:12:36,086
of the enum case
that we saw before.


265
00:12:36,086 --> 00:12:40,446
Now, there's one more nice
thing that's going on here.


266
00:12:41,016 --> 00:12:43,656
I marked this enum with
the ObjC attribute.


267
00:12:44,276 --> 00:12:46,946
This is a feature we
added in Xcode 6.3.


268
00:12:47,276 --> 00:12:50,006
If you mark an enum
with the ObjC attribute,


269
00:12:50,486 --> 00:12:52,996
then it will get printed
into your generated header.


270
00:12:53,616 --> 00:12:56,246
The header that exposes
the Objective-C side


271
00:12:56,476 --> 00:12:57,626
of your Swift classes.


272
00:12:59,566 --> 00:13:01,826
In Xcode -- sorry -- in Xcode 7,


273
00:13:02,186 --> 00:13:04,146
we've added one more
little nice feature here.


274
00:13:04,646 --> 00:13:07,516
This is an enum that conforms
to the error type protocol,


275
00:13:08,126 --> 00:13:11,596
so we'll also generate a string
constant representing the


276
00:13:11,596 --> 00:13:12,396
error domain.


277
00:13:13,026 --> 00:13:16,796
Now, all of this is great
for errors you have defined


278
00:13:16,796 --> 00:13:19,926
in Swift, and you probably
want to run out and use this


279
00:13:19,926 --> 00:13:23,126
for your own classes, but
then the errors that come back


280
00:13:23,126 --> 00:13:25,826
from Cocoa and the
rest of the SDKs start


281
00:13:25,826 --> 00:13:28,436
to feel a little lacking.


282
00:13:28,566 --> 00:13:30,286
And, don't worry, we have
got you covered there too.


283
00:13:30,286 --> 00:13:33,066
So if you were at the
presentation earlier today,


284
00:13:33,126 --> 00:13:34,986
you might have seen
this preflight method


285
00:13:35,346 --> 00:13:38,176
which is checking that
a resource is reachable


286
00:13:38,176 --> 00:13:40,396
and then catching some
various error cases.


287
00:13:41,146 --> 00:13:43,166
Now one of the error
cases here is listed


288
00:13:43,166 --> 00:13:46,286
as 'NSURLError, file
does not exist.'


289
00:13:47,116 --> 00:13:49,086
That's an error that
comes from Cocoa.


290
00:13:49,706 --> 00:13:52,186
Why is that showing up,
using the Swift notation?


291
00:13:53,376 --> 00:13:56,126
Well, we have taken the most
common error types throughout


292
00:13:56,126 --> 00:13:58,946
our SDKs and made it so
that you can use them


293
00:13:58,946 --> 00:14:00,786
with Swift's own catch syntax.


294
00:14:01,506 --> 00:14:03,336
So there's are all sorts
of errors you can use here.


295
00:14:03,336 --> 00:14:05,936
And the general idea that you
should take away from this,


296
00:14:06,366 --> 00:14:09,166
is that errors should feel
like NSError when you're


297
00:14:09,166 --> 00:14:11,946
in Objective-C, and they
should feel like Swift errors


298
00:14:12,006 --> 00:14:12,916
when you are in Swift.


299
00:14:13,256 --> 00:14:14,206
Things should just work.


300
00:14:14,696 --> 00:14:18,566
So that's just some of the
enhancements we've made to Swift


301
00:14:18,656 --> 00:14:21,446
in the area of interoperability
over the last year.


302
00:14:21,986 --> 00:14:23,466
So to talk about the
enhancements we've made


303
00:14:23,466 --> 00:14:24,976
in the Objective-C
side of the world,


304
00:14:25,016 --> 00:14:26,416
I would like to hand
it over to Doug.


305
00:14:27,516 --> 00:14:33,586
[Applause]


306
00:14:34,086 --> 00:14:34,266
>> DOUG GREGOR: Thank you.


307
00:14:34,266 --> 00:14:34,936
Thank you, Jordan.


308
00:14:35,956 --> 00:14:37,336
So today I would like to talk


309
00:14:37,336 --> 00:14:40,906
about three new Objective-C
features we've added this year.


310
00:14:41,716 --> 00:14:42,586
These features can be used


311
00:14:42,586 --> 00:14:44,196
to make your Objective-C
code better,


312
00:14:44,196 --> 00:14:47,006
your Objective-C APIs better,
make them reflect better


313
00:14:47,006 --> 00:14:50,576
into Swift, and improve static
type safety in your Objective-C.


314
00:14:50,766 --> 00:14:52,126
The first thing we
are going to talk


315
00:14:52,126 --> 00:14:54,516
about is nullability
for Objective-C.


316
00:14:55,836 --> 00:14:58,626
So take a look at this
bit of Objective-C code.


317
00:14:59,696 --> 00:15:00,616
Lots of pointers here.


318
00:15:01,286 --> 00:15:02,616
Which one of these can be nil?


319
00:15:04,296 --> 00:15:05,356
The code doesn't tell you.


320
00:15:06,476 --> 00:15:07,936
If you go read the
documentation,


321
00:15:07,936 --> 00:15:10,716
maybe it will tell you if
you are feeling lucky today.


322
00:15:11,936 --> 00:15:13,406
You could go write some tests


323
00:15:13,406 --> 00:15:16,676
and see what you think it
behaves like or maybe guess,


324
00:15:16,676 --> 00:15:18,176
but that's not really good.


325
00:15:18,176 --> 00:15:19,716
There's really missing
information here.


326
00:15:20,696 --> 00:15:22,336
When we introduced
Swift last year,


327
00:15:22,646 --> 00:15:25,606
this lack of information
became much more apparent


328
00:15:26,246 --> 00:15:28,566
in these implicitly
unwrapped optionals,


329
00:15:29,266 --> 00:15:30,836
which essentially
means we don't know


330
00:15:30,836 --> 00:15:32,176
if it can be nil
on the Swift side.


331
00:15:34,116 --> 00:15:35,456
So we weren't too
thrilled with this,


332
00:15:35,976 --> 00:15:39,176
and so after releasing
Swift 1.0, we went


333
00:15:39,376 --> 00:15:41,996
and audited a couple
thousand pointers


334
00:15:41,996 --> 00:15:46,376
within our own core
frameworks to tell the compiler


335
00:15:46,756 --> 00:15:48,326
which of these pointers
can be nil.


336
00:15:48,776 --> 00:15:51,726
And the interfaces after this
audit got much, much cleaner.


337
00:15:52,366 --> 00:15:54,876
Now, we are only
using optional types


338
00:15:54,986 --> 00:15:57,296
where nil is actually
something you have to deal with,


339
00:15:58,076 --> 00:15:59,516
and everything else
is non-optional.


340
00:16:00,836 --> 00:16:02,726
This is still not
that wonderful,


341
00:16:02,726 --> 00:16:04,986
because this knowledge is
baked into the compiler.


342
00:16:04,986 --> 00:16:06,136
It's not something you can do.


343
00:16:06,936 --> 00:16:10,766
So with Xcode 6.3, we introduced
nullability qualifiers


344
00:16:10,766 --> 00:16:11,596
for Objective-C.


345
00:16:13,056 --> 00:16:15,056
So a nullability qualifier
is something you can add


346
00:16:15,306 --> 00:16:17,006
to a C/Objective-C pointer


347
00:16:17,586 --> 00:16:19,366
to state whether it
accepts nil or not.


348
00:16:19,466 --> 00:16:23,426
Of course, this better
communicates what your API


349
00:16:23,426 --> 00:16:24,276
actually does.


350
00:16:24,486 --> 00:16:25,556
Does it accept nil?


351
00:16:25,556 --> 00:16:26,856
Does that make sense for it?


352
00:16:27,686 --> 00:16:29,926
It helps our tools do
better static checking


353
00:16:29,926 --> 00:16:32,026
to catch bugs before they
manifest at run time,


354
00:16:32,646 --> 00:16:35,426
and it makes the Swift
experience so much better


355
00:16:35,646 --> 00:16:37,066
with your Objective-C APIs!


356
00:16:37,626 --> 00:16:41,616
Now, there are three
nullability qualifiers.


357
00:16:42,486 --> 00:16:45,206
Nullable, which indicates
that the pointer may be null.


358
00:16:46,366 --> 00:16:48,256
This, of course, maps
into a Swift optional.


359
00:16:49,366 --> 00:16:50,406
And then there's non-null.


360
00:16:50,806 --> 00:16:55,546
So this indicates that null or
nil is not a meaningful value.


361
00:16:57,326 --> 00:16:59,876
Now, for a non-null pointer,
it could end up being nil


362
00:17:00,616 --> 00:17:01,916
in an Objective-C program.


363
00:17:02,116 --> 00:17:05,026
Maybe it comes because we
messaged nil at some point


364
00:17:05,026 --> 00:17:06,286
and the nil propagated through


365
00:17:07,165 --> 00:17:08,705
and maybe this has
worked in the past.


366
00:17:08,986 --> 00:17:11,705
The compiler is not going to
change the way it generates code


367
00:17:11,705 --> 00:17:13,246
because of a non-null
annotation.


368
00:17:13,556 --> 00:17:16,175
But this indicates the
intent of the API author


369
00:17:16,175 --> 00:17:17,756
that nil does not
make sense here.


370
00:17:18,316 --> 00:17:22,996
We also have a third qualifier,
and that is null-unspecified.


371
00:17:23,866 --> 00:17:26,695
This is for cases where
neither nullable nor non-null is


372
00:17:26,695 --> 00:17:29,736
actually the right thing,
and we map these into Swift


373
00:17:29,736 --> 00:17:32,776
as the same implicitly
unwrapped optional you would get


374
00:17:32,936 --> 00:17:34,856
if we knew nothing about
the pointer whatsoever.


375
00:17:35,396 --> 00:17:37,816
And the most important thing


376
00:17:37,876 --> 00:17:40,506
about nullability qualifiers
is we've rolled them


377
00:17:40,506 --> 00:17:42,066
out throughout our SDKs.


378
00:17:43,356 --> 00:17:44,786
Alright, so instead of
just covering a couple


379
00:17:44,866 --> 00:17:45,846
of core frameworks,


380
00:17:45,886 --> 00:17:47,816
we've covered the
majority of the SDKs.


381
00:17:47,816 --> 00:17:51,726
So this gives a much, much
better Swift experience


382
00:17:52,036 --> 00:17:54,086
with true optionals where
they actually matter


383
00:17:54,236 --> 00:17:55,776
and non-optionals
everywhere else.


384
00:17:56,866 --> 00:17:59,226
For your Objective-C code, it
means you are going to start


385
00:17:59,226 --> 00:18:01,116
to see new warnings for places


386
00:18:01,116 --> 00:18:02,926
where you have been
misusing APIs.


387
00:18:03,586 --> 00:18:06,246
So, here, for example, you see a
warning that you've passed null


388
00:18:06,246 --> 00:18:09,436
or nil to a method that
did not expect it here.


389
00:18:09,436 --> 00:18:11,106
It is not part of
the API contract.


390
00:18:12,116 --> 00:18:14,536
Now maybe passing a
nil has worked before;


391
00:18:14,976 --> 00:18:16,346
it may continue to work.


392
00:18:16,826 --> 00:18:18,226
But you should heed
these warnings,


393
00:18:18,266 --> 00:18:20,166
because the API author
has told you,


394
00:18:20,346 --> 00:18:22,816
you should not pass nil
here, it's good to be careful


395
00:18:22,816 --> 00:18:26,346
because it may change
in the future.


396
00:18:26,526 --> 00:18:27,636
Now, let's say you want


397
00:18:27,636 --> 00:18:29,876
to add nullability
qualifiers to your own headers.


398
00:18:30,206 --> 00:18:32,996
The place to start is
with an audited region.


399
00:18:33,656 --> 00:18:36,236
So, these are described by
'NS-assume non-null begin,


400
00:18:36,566 --> 00:18:37,876
'NS-assume non-null end;


401
00:18:38,516 --> 00:18:41,126
bracket your header
with these macros.


402
00:18:42,116 --> 00:18:44,036
What this does is it
allows the compiler


403
00:18:44,036 --> 00:18:46,896
to make default assumptions
about pointers


404
00:18:46,896 --> 00:18:48,526
that are not otherwise
annotated.


405
00:18:49,146 --> 00:18:51,656
So, if you have a single
level pointer, that's going


406
00:18:51,656 --> 00:18:54,426
to be assumed non-null,
because what we've found is


407
00:18:54,426 --> 00:18:57,736
that nil is not a meaningful
value for most of our APIs.


408
00:18:58,256 --> 00:19:01,506
The other interesting
special case here is


409
00:19:01,506 --> 00:19:03,166
NSError-star-star parameters.


410
00:19:03,166 --> 00:19:06,216
Where you're doing error
handling in Objective-C,


411
00:19:06,386 --> 00:19:08,446
these are assumed to be
nullable at both levels,


412
00:19:08,446 --> 00:19:11,226
because that's the way you
work with them for nullability.


413
00:19:12,726 --> 00:19:15,036
Now the defaults are good, they
should cover most of the cases,


414
00:19:15,546 --> 00:19:18,276
but that means you have to
annotate the exceptional cases.


415
00:19:18,646 --> 00:19:22,026
So here we are marking the super
view property as being nullable,


416
00:19:22,026 --> 00:19:24,696
because, of course, not
every view has a super view.


417
00:19:24,836 --> 00:19:25,806
Nil has meaning there.


418
00:19:27,076 --> 00:19:29,536
Hit test with event has
a nullable parameter.


419
00:19:30,186 --> 00:19:32,936
You don't have to pass in an
event to do hit testing and,


420
00:19:32,936 --> 00:19:35,246
of course, the result
is nullable


421
00:19:35,246 --> 00:19:36,516
because nil has meaning there.


422
00:19:36,516 --> 00:19:39,976
It means we didn't hit anything.


423
00:19:40,066 --> 00:19:42,386
Now, this is where
null-unspecified comes up.


424
00:19:43,056 --> 00:19:44,306
Say you are auditing a header.


425
00:19:45,426 --> 00:19:49,596
You run into some really weird
implementation that's been


426
00:19:49,596 --> 00:19:50,526
around forever.


427
00:19:50,906 --> 00:19:52,646
You have no idea what
it does with nil.


428
00:19:53,206 --> 00:19:54,636
It hasn't been documented.


429
00:19:55,206 --> 00:19:57,806
Maybe it's doing something
really, really interesting


430
00:19:57,806 --> 00:20:00,396
with messaging nil that may or
may not work and the only guy


431
00:20:00,396 --> 00:20:02,236
that can answer it
retired five years ago.


432
00:20:03,726 --> 00:20:05,356
Great place to use
null unspecified.


433
00:20:06,046 --> 00:20:07,626
Just mark it as null
unspecified.


434
00:20:07,856 --> 00:20:11,556
This means, 'I thought about it,
I couldn't come to an answer.'


435
00:20:11,876 --> 00:20:15,246
The best thing to do is keep it
implicitly unwrapped optional


436
00:20:15,246 --> 00:20:18,686
in Swift, keep it
null-unspecified here.


437
00:20:18,686 --> 00:20:20,256
You can always come
back to it later.


438
00:20:20,336 --> 00:20:21,496
So when auditing,
you really want


439
00:20:21,496 --> 00:20:23,626
to get some good breadth early


440
00:20:23,846 --> 00:20:26,326
to make your APIs much,
much better, faster.


441
00:20:28,296 --> 00:20:31,896
Now, when you go down to C,


442
00:20:31,976 --> 00:20:33,616
things get a little
bit more murky.


443
00:20:34,446 --> 00:20:36,846
So we have all of the same
qualifiers but they need


444
00:20:36,846 --> 00:20:38,626
to be preceded by the
double-underscore.


445
00:20:39,856 --> 00:20:42,876
Now, these double-underscored
keywords, those qualifiers,


446
00:20:42,876 --> 00:20:45,176
can be used on any
pointer, anywhere.


447
00:20:45,746 --> 00:20:50,226
The important rule here is that
the qualifier goes to the right


448
00:20:51,326 --> 00:20:54,216
of the pointer it applies
to, the same place that const


449
00:20:54,216 --> 00:20:56,486
or volatile would go to,
to apply to that pointer.


450
00:20:57,766 --> 00:21:00,816
This is particularly important
for multilevel pointers


451
00:21:00,956 --> 00:21:02,786
like this values parameter here


452
00:21:03,376 --> 00:21:07,366
where the outer pointer is
nullable, because you can pass


453
00:21:07,366 --> 00:21:10,446
in nil to this parameter so
long as num-values is also zero.


454
00:21:12,196 --> 00:21:15,916
The inner pointer is non-null,
because when you are passing


455
00:21:15,916 --> 00:21:19,886
in an array of values, all of
those values must be non-null


456
00:21:19,886 --> 00:21:20,976
to work with CF array.


457
00:21:21,586 --> 00:21:26,606
That's all we're going to
talk about with nullability.


458
00:21:27,436 --> 00:21:29,316
We've pushed it throughout
our SDKs this year,


459
00:21:29,316 --> 00:21:30,856
so you get a much
better experience


460
00:21:30,856 --> 00:21:32,566
in both Objective-C and Swift.


461
00:21:33,016 --> 00:21:35,366
We highly recommend
that you use it


462
00:21:35,366 --> 00:21:38,276
to improve your own
Objective-C APIs, particularly


463
00:21:38,276 --> 00:21:39,986
for a much better
Swift experience.


464
00:21:40,106 --> 00:21:44,286
Alright, let's come on
to the next feature.


465
00:21:44,676 --> 00:21:47,596
This is a big one.


466
00:21:47,596 --> 00:21:49,016
Lightweight generics
for Objective-C.


467
00:21:49,626 --> 00:21:52,336
Now, the origin of this feature,


468
00:21:52,706 --> 00:21:54,566
it's actually fairly
easy to motivate.


469
00:21:55,016 --> 00:21:55,666
Collections.


470
00:21:56,996 --> 00:21:59,696
Here we have this
NSArray of subviews.


471
00:22:00,226 --> 00:22:02,406
What's in the array?


472
00:22:03,246 --> 00:22:04,636
We don't say what's
in the array.


473
00:22:05,056 --> 00:22:08,176
We bring this into Swift and
you say, ah, it's an array


474
00:22:08,176 --> 00:22:09,466
of any object, of course.


475
00:22:09,566 --> 00:22:11,476
That still tells me
absolutely nothing.


476
00:22:12,126 --> 00:22:14,556
I have to cast a lot.


477
00:22:14,556 --> 00:22:15,216
That's what it tells me.


478
00:22:15,896 --> 00:22:19,976
So we have had, of
course, this common request


479
00:22:19,976 --> 00:22:21,476
for typed collections.


480
00:22:22,246 --> 00:22:25,096
Because people really want to
say I have an array of views.


481
00:22:25,466 --> 00:22:27,416
I have a dictionary that
maps from string keys


482
00:22:27,416 --> 00:22:29,576
over to the images
associated with those keys.


483
00:22:30,536 --> 00:22:32,986
This has been probably been the
most highly requested feature


484
00:22:32,986 --> 00:22:34,996
for the last decade
of Objective-C.


485
00:22:35,666 --> 00:22:37,386
So, now we are finally
rolling it


486
00:22:37,386 --> 00:22:39,656
out with lightweight
generics for Objective-C.


487
00:22:40,276 --> 00:22:42,656
So this is a general language
feature that can be used


488
00:22:42,656 --> 00:22:44,966
to improve the expressivity
of your APIs;


489
00:22:45,806 --> 00:22:48,836
it makes collections
way easier to use now


490
00:22:48,836 --> 00:22:51,956
that we have all the static type
safety of typed collections.


491
00:22:52,486 --> 00:22:54,366
Let's take a look.


492
00:22:55,546 --> 00:22:57,296
So here's our subviews
property again.


493
00:22:58,546 --> 00:23:00,596
To make this an array
of UI-views,


494
00:23:01,096 --> 00:23:04,896
we just place UI-view-star, so
UIV pointer, in angle brackets.


495
00:23:05,086 --> 00:23:06,556
Same syntax you have seen.


496
00:23:06,556 --> 00:23:06,886
Whoops, sorry.


497
00:23:07,516 --> 00:23:14,566
[Applause]


498
00:23:15,066 --> 00:23:18,056
The same syntax you have
seen from Swift and C++


499
00:23:18,056 --> 00:23:20,376
and C-Sharp, et cetera,
et cetera.


500
00:23:20,796 --> 00:23:21,976
Yes, we are completely aware


501
00:23:21,976 --> 00:23:24,056
that angle brackets are
quote protocol qualifiers.


502
00:23:24,266 --> 00:23:28,536
Don't worry, we've got it.


503
00:23:28,536 --> 00:23:31,956
So this introduces more type
information into Objective-C.


504
00:23:32,056 --> 00:23:33,886
Of course, this reflects
into Swift


505
00:23:33,886 --> 00:23:36,036
as much more beautiful
type information.


506
00:23:36,476 --> 00:23:38,486
But really I want to talk
about the Objective-C effect


507
00:23:38,576 --> 00:23:41,276
because this is a really
useful feature for Objective-C.


508
00:23:41,766 --> 00:23:43,706
Because let's talk
about type safety.


509
00:23:44,176 --> 00:23:46,686
Here's an example.


510
00:23:47,236 --> 00:23:51,106
So I'm taking the path
components of any URL, NSURL.


511
00:23:51,106 --> 00:23:53,506
And I'm putting it
into an array of URLs.


512
00:23:54,036 --> 00:23:56,506
That almost seems reasonable
if I didn't know this API


513
00:23:56,506 --> 00:23:59,826
and it would be a while before
I got the run time error,


514
00:23:59,826 --> 00:24:02,136
the unrecognized selector
that points out that no,


515
00:24:02,136 --> 00:24:04,636
I'm completely wrong in my
usage of path components.


516
00:24:05,406 --> 00:24:07,156
With type collections
and, of course,


517
00:24:07,226 --> 00:24:09,366
us rolling out type
collections throughout our SDKs,


518
00:24:09,366 --> 00:24:12,696
now you get a warning to tell
you just what you did wrong


519
00:24:13,006 --> 00:24:16,336
at the point where it happens.


520
00:24:16,496 --> 00:24:19,726
Many other cases here say I'm
building up immutable array


521
00:24:19,796 --> 00:24:24,496
of NS strings and I foolishly go
and add something to that array


522
00:24:24,726 --> 00:24:27,886
without turning it into
a string first, okay,


523
00:24:28,056 --> 00:24:29,816
the compiler is going
to tell me, no,


524
00:24:29,816 --> 00:24:31,276
you can't put an NS number


525
00:24:31,276 --> 00:24:33,076
into this NS mutable
array of strings.


526
00:24:33,326 --> 00:24:34,476
It doesn't make sense.


527
00:24:34,986 --> 00:24:38,566
Now, the compiler actually
has fairly deep knowledge


528
00:24:39,066 --> 00:24:42,226
of the semantics here of
the Cocoa collections.


529
00:24:42,896 --> 00:24:46,336
So let's take this example
here, we have an array of views,


530
00:24:46,956 --> 00:24:48,156
we have an array of responders.


531
00:24:48,206 --> 00:24:49,856
We assign from the array
of views to the array


532
00:24:49,856 --> 00:24:54,286
of responders, okay every
view is a responder.


533
00:24:54,286 --> 00:24:55,266
This seems fine.


534
00:24:55,846 --> 00:24:56,366
It is okay.


535
00:24:57,026 --> 00:25:00,886
Let's do the same thing
with the mutable variant.


536
00:25:02,336 --> 00:25:05,986
So we take the stored mutable
array of views and assign it


537
00:25:05,986 --> 00:25:09,456
over to the stored mutable
array of responders.


538
00:25:09,936 --> 00:25:11,866
There's a trap here.


539
00:25:12,676 --> 00:25:14,176
The trap, of course,
is I can go ahead


540
00:25:14,176 --> 00:25:17,936
and mutate my stored
responders, put something


541
00:25:17,936 --> 00:25:20,316
in there that's a
responder but not a view.


542
00:25:21,836 --> 00:25:24,376
Now, something later on is
getting very, very confused


543
00:25:24,436 --> 00:25:25,936
that the array of
views it's looking


544
00:25:25,936 --> 00:25:28,506
at has a view controller
in it, not a view.


545
00:25:29,946 --> 00:25:31,346
Compiler understands
this is as well.


546
00:25:31,396 --> 00:25:33,946
It will complain at the point
of initialization, here,


547
00:25:34,146 --> 00:25:37,136
that while it's perfectly safe
to do this kind of assignment


548
00:25:37,356 --> 00:25:40,776
with immutable arrays
because they don't change


549
00:25:40,776 --> 00:25:43,196
from underneath you,
it is not safe to do


550
00:25:43,296 --> 00:25:44,346
with the mutable variants.


551
00:25:44,796 --> 00:25:49,006
Alright. You have
actually seen all you need


552
00:25:49,006 --> 00:25:50,666
to use lightweight generics


553
00:25:50,666 --> 00:25:53,136
and typed collections
throughout your applications.


554
00:25:53,496 --> 00:25:55,646
But let's take a look
at how we use this


555
00:25:55,646 --> 00:25:57,116
within Foundation itself,


556
00:25:58,446 --> 00:26:00,346
to actually create
typed collections.


557
00:26:00,466 --> 00:26:02,226
Because the feature
here is generics.


558
00:26:02,826 --> 00:26:04,416
Typed collections is one
of the outcomes of it.


559
00:26:04,736 --> 00:26:07,196
So here we have NSArray as
you are used to seeing it.


560
00:26:08,436 --> 00:26:09,666
Now we are going
to parameterize it,


561
00:26:09,766 --> 00:26:13,756
based on the object type
that's stored in the NSArray,


562
00:26:14,636 --> 00:26:16,106
again, using angle brackets.


563
00:26:16,106 --> 00:26:17,316
We are just introducing
a name here.


564
00:26:18,056 --> 00:26:20,536
We can use that name throughout
the interface, so, of course,


565
00:26:20,536 --> 00:26:23,406
object at index, returns
something of the object type.


566
00:26:23,406 --> 00:26:26,306
If we go ahead and add
other methods here.


567
00:26:27,066 --> 00:26:29,526
When you initialize with
objects the array you get in,


568
00:26:29,526 --> 00:26:32,036
the C-array, contains objects.


569
00:26:32,976 --> 00:26:34,176
Use array by adding object.


570
00:26:34,176 --> 00:26:36,526
You put in a new object, you
get an NSArray of objects.


571
00:26:36,526 --> 00:26:38,456
So it composes very,
very, very nicely.


572
00:26:39,416 --> 00:26:42,446
Of course this also works for
categories and extensions.


573
00:26:43,276 --> 00:26:46,406
Here we have an NSDictionary
category, parameterized


574
00:26:46,406 --> 00:26:49,206
on key type and the object
type, and we have gone ahead


575
00:26:49,206 --> 00:26:52,066
and added object for key
here, takes in a key type,


576
00:26:52,366 --> 00:26:55,336
returns a nullable object
type because, of course,


577
00:26:55,666 --> 00:26:57,566
nil matters here
and we want to have


578
00:26:57,566 --> 00:27:00,326
that information in our APIs.


579
00:27:00,526 --> 00:27:04,116
Now, of course, there are
existing categories defined


580
00:27:04,116 --> 00:27:07,706
on NSDictionary, NSArray, and so
on, you may have some yourself.


581
00:27:08,096 --> 00:27:09,916
Those will continue to
work as they always have.


582
00:27:10,336 --> 00:27:12,966
They cannot access the
type parameters in any way,


583
00:27:13,826 --> 00:27:15,986
but they also won't
change behavior at all,


584
00:27:15,986 --> 00:27:17,666
they will continue working
as they always have.


585
00:27:19,206 --> 00:27:21,976
That brings me to
backward compatibility.


586
00:27:23,236 --> 00:27:26,006
So the entire lightweight
generics feature is based


587
00:27:26,076 --> 00:27:27,276
on a type erasure model.


588
00:27:27,696 --> 00:27:29,266
Which means that
the compiler has all


589
00:27:29,266 --> 00:27:32,036
of this rich static type
information but it erases


590
00:27:32,036 --> 00:27:34,126
that information
when generating code.


591
00:27:34,986 --> 00:27:37,296
There's huge benefits
here for Objective-C,


592
00:27:37,616 --> 00:27:39,576
that we did not have
to make any changes


593
00:27:39,576 --> 00:27:43,306
to the Objective-C run time
to make this feature work.


594
00:27:43,986 --> 00:27:46,086
That means we are able
to roll out generics


595
00:27:46,086 --> 00:27:48,416
in type collections, you
can adopt them in all


596
00:27:48,416 --> 00:27:52,206
of your applications and it
does not affect your ability


597
00:27:52,206 --> 00:27:54,376
to deploy back to
existing operating systems.


598
00:27:55,516 --> 00:28:02,546
[Applause]


599
00:28:03,046 --> 00:28:04,836
>> DOUG GREGOR: And if it wasn't
obvious from that description,


600
00:28:04,836 --> 00:28:06,366
of course, we are also not going


601
00:28:06,366 --> 00:28:08,476
to change cogeneration
in any way.


602
00:28:08,476 --> 00:28:11,186
We are not adding runtime
checking to Objective-C


603
00:28:11,186 --> 00:28:13,166
that doesn't make
sense in Objective-C.


604
00:28:13,876 --> 00:28:16,136
We just maintain full
binary compatibility.


605
00:28:16,136 --> 00:28:19,306
So adopt this feature, enjoy
the warnings preventing you


606
00:28:19,306 --> 00:28:20,616
from making horrible mistakes.


607
00:28:21,956 --> 00:28:27,966
And you can adopt it
very, very, very...


608
00:28:28,516 --> 00:28:30,676
hmm gradually, I guess
is the best term here.


609
00:28:31,386 --> 00:28:33,266
So in addition to
binary compatibility,


610
00:28:33,336 --> 00:28:35,296
we want to provide
source compatibility,


611
00:28:35,626 --> 00:28:37,546
because we have rolled this
feature out through our SDKs.


612
00:28:37,546 --> 00:28:40,786
We don't want you to have to
update all of your source code


613
00:28:40,786 --> 00:28:42,346
to use these things everywhere.


614
00:28:42,656 --> 00:28:44,096
We want you to gradually
adopt it.


615
00:28:44,176 --> 00:28:45,576
Use it where it makes
sense for you.


616
00:28:46,076 --> 00:28:47,906
And so we provided these
implicit conversions


617
00:28:47,906 --> 00:28:49,506
in the language that allow you


618
00:28:49,506 --> 00:28:52,126
to add type arguments
or take them away.


619
00:28:52,856 --> 00:28:56,126
Okay? Again, there's no run
time cost to doing this.


620
00:28:56,526 --> 00:28:57,616
But it lets you get in and get


621
00:28:57,616 --> 00:28:59,506
out of the generic
system as you need.


622
00:28:59,806 --> 00:29:01,846
So all of your new code can
be written with generics


623
00:29:01,936 --> 00:29:03,316
and if you don't want
to touch your old code,


624
00:29:03,576 --> 00:29:04,436
that's perfectly line.


625
00:29:04,516 --> 00:29:07,256
It's not going to change.


626
00:29:07,406 --> 00:29:07,726
All right.


627
00:29:08,086 --> 00:29:12,586
We have one last feature to talk
about, this one's kind of cool.


628
00:29:12,836 --> 00:29:16,716
So kindof types.


629
00:29:17,236 --> 00:29:19,686
Actually, came out of our
work on lightweight generics.


630
00:29:20,366 --> 00:29:22,276
And so we started
with, of course,


631
00:29:22,946 --> 00:29:25,606
using the untyped
collection here for subviews,


632
00:29:26,196 --> 00:29:28,916
and there's code that
may go grab a view


633
00:29:28,916 --> 00:29:30,346
and send some message to it.


634
00:29:31,186 --> 00:29:32,056
This code is fine.


635
00:29:32,236 --> 00:29:32,946
It works today.


636
00:29:34,546 --> 00:29:36,996
We went ahead and did these
annotations to say, okay,


637
00:29:36,996 --> 00:29:41,506
subviews contains UI views
and now we get some warnings.


638
00:29:43,676 --> 00:29:46,006
The compiler is completely
justified


639
00:29:46,006 --> 00:29:46,996
in giving this warning.


640
00:29:48,076 --> 00:29:51,866
It knows now that the
first subview is a UI view.


641
00:29:52,906 --> 00:29:56,476
It can't know that you
know it's a UI button


642
00:29:56,776 --> 00:29:58,356
that would actually
respond to this selector.


643
00:29:59,486 --> 00:30:02,846
And so while the
compiler is right,


644
00:30:03,286 --> 00:30:05,056
it's not necessarily useful


645
00:30:05,056 --> 00:30:07,056
to be producing warnings
on all of this code.


646
00:30:07,056 --> 00:30:09,716
You get a raft of warnings
most of which would be benign


647
00:30:09,716 --> 00:30:11,556
and you would be
adding casts everywhere.


648
00:30:12,606 --> 00:30:14,696
This really forced
us to consider ID


649
00:30:14,796 --> 00:30:17,286
and how it's used
as an API contract.


650
00:30:18,616 --> 00:30:20,386
And so let's make this a
little simpler example.


651
00:30:20,386 --> 00:30:23,316
Let's talk about NSApp,
which is this global in Cocoa


652
00:30:23,316 --> 00:30:26,006
that gives you access to
your NSApplication instance.


653
00:30:26,916 --> 00:30:32,786
Now, what this really means
is NSApp is a subclass


654
00:30:32,976 --> 00:30:34,036
of NSApplication.


655
00:30:34,036 --> 00:30:35,906
But we couldn't describe
that to the type system.


656
00:30:36,796 --> 00:30:40,586
With kindof types, we can say
this exactly in Objective-C.


657
00:30:41,066 --> 00:30:43,946
What does this mean?


658
00:30:44,936 --> 00:30:47,246
This means NSApp is some
kind of application.


659
00:30:47,586 --> 00:30:51,866
So we are going to give it
some limited behavior, like ID.


660
00:30:53,256 --> 00:30:56,716
So I have my NSApp, of course
I can convert it to an NSObject


661
00:30:56,936 --> 00:30:59,686
because every NSApplication
is an NSObject.


662
00:31:00,466 --> 00:31:02,746
The important part here,
the ID-like behavior,


663
00:31:02,996 --> 00:31:05,666
is the implicit downcast
from NSApplication


664
00:31:06,026 --> 00:31:07,796
to your MyApplication subclass.


665
00:31:08,286 --> 00:31:09,836
That's good.


666
00:31:10,016 --> 00:31:12,346
We want that behavior
because that's how NSApp has


667
00:31:12,346 --> 00:31:13,056
always worked.


668
00:31:13,706 --> 00:31:16,326
Now, what we won't allow
is some silly cross-cast.


669
00:31:16,426 --> 00:31:19,496
You tried to use
NSApp in a string?


670
00:31:19,496 --> 00:31:21,816
Well, that's not an
NSApplication and never can be.


671
00:31:22,236 --> 00:31:23,396
So you can produce
a warning there.


672
00:31:23,976 --> 00:31:27,356
Of course, coming with
this is the notion


673
00:31:27,356 --> 00:31:30,836
that you can message NSApp and
get all of the methods that are


674
00:31:31,006 --> 00:31:32,016
in NSApplication,


675
00:31:32,016 --> 00:31:33,916
its superclasses,
and its subclasses.


676
00:31:34,436 --> 00:31:37,306
Now, with kindof types
we actually found


677
00:31:37,306 --> 00:31:39,366
that this is much
more useful than ID.


678
00:31:39,686 --> 00:31:43,526
Because it gives you more type
information in the API contract


679
00:31:43,956 --> 00:31:46,626
which is great for both
Swift and Objective-C.


680
00:31:47,156 --> 00:31:49,226
So here we have this
NS tableview method,


681
00:31:49,416 --> 00:31:51,116
you have column,
row, makeIfNecessary.


682
00:31:51,606 --> 00:31:52,776
It's always returned to ID,


683
00:31:52,776 --> 00:31:54,716
because that implicit
downcasting behavior


684
00:31:54,716 --> 00:31:55,426
is important.


685
00:31:56,316 --> 00:31:59,396
Well, now we can rewrite
it as a kindof NSview.


686
00:31:59,396 --> 00:32:03,846
So returning some kind of
NSView, and on the Swift side,


687
00:32:04,176 --> 00:32:06,466
ah, now we are returning
an optional NSView.


688
00:32:06,836 --> 00:32:09,206
That's the right API for Swift


689
00:32:09,586 --> 00:32:11,476
and it works beautifully
in Objective-C.


690
00:32:12,386 --> 00:32:13,936
Let's bring it back to
our original example


691
00:32:13,936 --> 00:32:15,076
with lightweight generics.


692
00:32:15,606 --> 00:32:20,876
Here we were with our subviews
stated as an NSArray of UIViews.


693
00:32:21,196 --> 00:32:25,336
Well, now we can state that it's
an NSArray of kinds of UI views.


694
00:32:25,956 --> 00:32:28,006
So we get the stronger
API contract


695
00:32:28,006 --> 00:32:29,196
in Objective-C and Swift.


696
00:32:29,196 --> 00:32:32,976
It's far easier to tell
what this property is,


697
00:32:34,296 --> 00:32:37,486
but you don't cause any spurious
warnings because you still have


698
00:32:37,486 --> 00:32:40,606
that nice, implicit
downcasting behavior from ID.


699
00:32:41,916 --> 00:32:46,116
Hopefully this leads
you to a question.


700
00:32:46,186 --> 00:32:49,816
Should I even use ID in an API?


701
00:32:50,046 --> 00:32:52,596
Over the years we have
actually been rolling out a lot


702
00:32:52,596 --> 00:32:56,286
of features that give more
specific type information


703
00:32:56,286 --> 00:32:59,056
than ID for various
important scenarios.


704
00:33:00,056 --> 00:33:01,866
And the same year
we introduced Arc,


705
00:33:01,866 --> 00:33:03,136
we introduced instance type,


706
00:33:04,126 --> 00:33:06,506
which says that the method you
are calling returns something


707
00:33:06,506 --> 00:33:08,446
of the same dynamic
type as self.


708
00:33:09,676 --> 00:33:11,766
This year we are
introducing type collections


709
00:33:11,766 --> 00:33:14,176
that eliminate tons
of uses of ID.


710
00:33:14,596 --> 00:33:17,526
From our own APIs we have been
rolling out these features and,


711
00:33:17,526 --> 00:33:19,776
of course, from your APIs
when you adopt this feature.


712
00:33:21,096 --> 00:33:24,666
We now have kindof X to
talk about any subclass of X


713
00:33:24,666 --> 00:33:26,066
with implicit downcasting.


714
00:33:26,616 --> 00:33:29,346
So you can keep your
code working,


715
00:33:29,486 --> 00:33:31,846
at least all the actually
working code that's not doing


716
00:33:31,846 --> 00:33:35,896
weird things, but have a better
API contract, and, of course,


717
00:33:35,936 --> 00:33:38,096
protocols have been in
Objective-C for a very,


718
00:33:38,096 --> 00:33:41,906
very long time and using ID of
some protocol is a great way


719
00:33:41,906 --> 00:33:43,466
to say I don't care
what the class type is.


720
00:33:43,466 --> 00:33:44,986
It just has to conform
to this protocol.


721
00:33:45,586 --> 00:33:49,696
So there's one major
class of uses for ID.


722
00:33:50,136 --> 00:33:51,256
And that's when you really,


723
00:33:51,256 --> 00:33:53,866
really do mean an
object of any type.


724
00:33:54,246 --> 00:33:56,586
And there's no static type
information that could make


725
00:33:56,586 --> 00:33:57,626
that statement better.


726
00:33:58,606 --> 00:34:02,786
So, a canonical example here
is the user info dictionary.


727
00:34:03,156 --> 00:34:07,886
You have string keys and
you have ID for the values.


728
00:34:08,666 --> 00:34:09,766
It's completely reasonable


729
00:34:09,766 --> 00:34:12,315
because the different keys
will have different types


730
00:34:12,315 --> 00:34:14,505
in those values and it's
something you can only


731
00:34:14,505 --> 00:34:15,525
determine dynamically.


732
00:34:16,085 --> 00:34:20,456
Let's wrap things up.


733
00:34:20,985 --> 00:34:24,866
So, we have big improvements
for both Swift and Objective-C.


734
00:34:25,025 --> 00:34:27,496
These languages are
codesigned and coevolved


735
00:34:27,835 --> 00:34:29,576
to work together beautifully.


736
00:34:30,136 --> 00:34:34,295
And Xcode and the tools
supporting it will help you move


737
00:34:34,295 --> 00:34:37,976
between the two languages, the
best way for your workflow.


738
00:34:39,346 --> 00:34:41,996
We have rolled out a lot of
great features for Objective-C.


739
00:34:41,996 --> 00:34:44,126
We highly recommend you
modernize your usage


740
00:34:44,126 --> 00:34:44,916
of Objective-C.


741
00:34:45,525 --> 00:34:48,246
These new language features
give you much better APIs,


742
00:34:48,246 --> 00:34:50,766
and you will see this in
our APIs and in yours,


743
00:34:50,766 --> 00:34:53,065
and give you far
better type safety


744
00:34:53,106 --> 00:34:55,196
to catch bugs before
they manifest


745
00:34:55,196 --> 00:34:57,386
as the dreaded unrecognized
selector at runtime.


746
00:34:57,386 --> 00:35:01,526
And using these features can
really make your Objective-C


747
00:35:01,526 --> 00:35:03,226
interfaces beautiful in Swift,


748
00:35:03,376 --> 00:35:07,186
so you have the best Swift
experience with your own code.


749
00:35:07,796 --> 00:35:12,596
For more information, please
contact our Evangelist,


750
00:35:12,706 --> 00:35:15,166
Stefan Lesser, check
out the documentation,


751
00:35:15,166 --> 00:35:16,536
or talk to us in
the forum online.


752
00:35:17,136 --> 00:35:19,826
There's a bunch of
related sessions talking


753
00:35:19,826 --> 00:35:21,386
about what's new
in Swift and Cocoa.


754
00:35:21,846 --> 00:35:23,716
Lots of great Swift
sessions here.


755
00:35:24,386 --> 00:35:24,976
Thank you very much.


756
00:35:25,516 --> 00:35:39,370
[Applause]

