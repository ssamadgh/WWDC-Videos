1
00:00:07,516 --> 00:00:17,500
[ Music ]


2
00:00:21,516 --> 00:00:28,466
[ Applause ]


3
00:00:28,966 --> 00:00:31,946
>> Good afternoon and welcome
to debugging tips and tricks.


4
00:00:32,665 --> 00:00:34,926
It warms my heart to see
this many people turn


5
00:00:34,926 --> 00:00:36,416
out for this topic.


6
00:00:36,726 --> 00:00:37,966
It's near and dear to my heart.


7
00:00:38,526 --> 00:00:39,446
My name is Kate Stone


8
00:00:39,446 --> 00:00:41,386
and I manage the core
team that's responsible


9
00:00:41,386 --> 00:00:43,266
for debugging technology
here at Apple.


10
00:00:43,796 --> 00:00:45,236
So again it's really exciting.


11
00:00:45,476 --> 00:00:47,876
I hope we'll be able to bring
up a number of engineers


12
00:00:47,876 --> 00:00:51,176
from my team to tell you
things that might be novel


13
00:00:51,176 --> 00:00:54,596
if you're just starting but
also tips that might be new


14
00:00:54,596 --> 00:00:56,846
to you even if you've been
debugging on our platforms


15
00:00:56,846 --> 00:00:58,406
for the last ten years.


16
00:00:58,736 --> 00:01:02,126
It really is a deep area and
we've got a lot of great content


17
00:01:02,126 --> 00:01:03,256
for you so let's get started.


18
00:01:05,006 --> 00:01:08,406
Specifically we should note
that LLDB is the technology


19
00:01:08,406 --> 00:01:09,296
that I'm talking about.


20
00:01:09,536 --> 00:01:11,616
If you've used Xcode for
debugging, you may not be aware


21
00:01:11,616 --> 00:01:14,966
that behind the scenes there's
this technology called LLDB,


22
00:01:14,966 --> 00:01:16,876
the low level debugger,
providing all


23
00:01:16,876 --> 00:01:19,476
of the core technology,
and it's not just


24
00:01:19,476 --> 00:01:21,466
in Xcode it's everywhere
you need it.


25
00:01:21,786 --> 00:01:24,346
But of course one of the more
common places you'll encounter


26
00:01:24,686 --> 00:01:27,126
it is in Xcode in
the debug console.


27
00:01:27,916 --> 00:01:30,846
Xcode hosts that console as
part of your debugging area,


28
00:01:32,006 --> 00:01:33,636
and you'll see of course
the variables viewed


29
00:01:33,636 --> 00:01:37,186
but also this LLDB console and
that's a lot of what we're going


30
00:01:37,186 --> 00:01:38,466
to be talking about here today.


31
00:01:38,976 --> 00:01:40,746
That prompted and
the wonderful things


32
00:01:40,746 --> 00:01:42,276
that you can do from
that prompt.


33
00:01:44,966 --> 00:01:48,786
Of course that area contains
normally not just LLDB's prompt


34
00:01:48,786 --> 00:01:50,436
and allow to interact
with the debugger


35
00:01:50,756 --> 00:01:52,786
but it also contains
your application's output


36
00:01:52,926 --> 00:01:54,336
and allows you to
type input to it


37
00:01:54,616 --> 00:01:56,076
for console based applications.


38
00:01:56,906 --> 00:01:58,726
That may not be the
most convenient way


39
00:01:58,726 --> 00:02:00,396
in case your application
takes advantage


40
00:02:00,396 --> 00:02:03,816
of other console features like
moving the cursor or colors,


41
00:02:03,816 --> 00:02:05,846
other ANSI cursor
manipulation features.


42
00:02:05,846 --> 00:02:09,346
So there's a new option
in Xcode 8 that allows you


43
00:02:09,346 --> 00:02:10,996
to use a standalone terminal


44
00:02:11,156 --> 00:02:13,856
for your application
while LLDB remains


45
00:02:14,016 --> 00:02:15,416
in Xcode and it's simple.


46
00:02:16,036 --> 00:02:18,976
Bring up the scheme options
and in the options tab


47
00:02:18,976 --> 00:02:21,666
at the very bottom you'll see
this new console that allows you


48
00:02:21,666 --> 00:02:23,906
to switch from the
default to use Xcode


49
00:02:24,676 --> 00:02:25,866
to use terminal instead.


50
00:02:25,866 --> 00:02:28,476
And then when you run you'll
get a separate terminal


51
00:02:28,536 --> 00:02:30,906
for your application's input
and output separate from Xcode.


52
00:02:31,516 --> 00:02:37,546
[ Applause ]


53
00:02:38,046 --> 00:02:40,536
For the remainder of the talk
we'll be really focused on LLDB.


54
00:02:40,586 --> 00:02:43,196
So if you're interested in
other Xcode specific features,


55
00:02:43,596 --> 00:02:45,416
definitely check out the
two talks noted here.


56
00:02:45,576 --> 00:02:46,866
Of course they've past by now


57
00:02:47,136 --> 00:02:48,916
but the videos are there
and waiting for you.


58
00:02:50,786 --> 00:02:53,456
You should also note that
LLDB is not just part of Xcode


59
00:02:53,746 --> 00:02:57,126
but the Swift REPL
is in fact LLDB.


60
00:02:57,566 --> 00:03:00,006
When you bring up the Swift REPL
and start interacting with it,


61
00:03:00,246 --> 00:03:02,756
you're interacting inside a
debugging environment already


62
00:03:02,986 --> 00:03:03,646
so that the power


63
00:03:03,646 --> 00:03:05,726
of the debugger is there
any time you need it.


64
00:03:06,076 --> 00:03:07,796
In fact every command
that we tell you


65
00:03:07,796 --> 00:03:10,416
about here you can use directly
from within the REPL just


66
00:03:10,416 --> 00:03:12,766
by prefixing it with a
colon from the REPL prompt.


67
00:03:13,226 --> 00:03:16,016
So colon followed by command
will issue the command directly


68
00:03:16,046 --> 00:03:16,926
to LLDB.


69
00:03:17,766 --> 00:03:19,686
So let's say I'm at
the Swift REPL prompt.


70
00:03:20,216 --> 00:03:22,866
At this point I'm interested
in looking up some information


71
00:03:22,866 --> 00:03:25,656
on a type and of course I
could bring up Xcode and look


72
00:03:25,656 --> 00:03:28,766
at the help, but right from the
prompt here I could go ahead


73
00:03:28,766 --> 00:03:31,416
and simply say colon
type lookup comparable.


74
00:03:31,556 --> 00:03:33,966
And I'll have looked up this
protocol and found out that


75
00:03:33,966 --> 00:03:35,976
in fact it derives
from another protocol


76
00:03:35,976 --> 00:03:37,546
and adds the following
four functions.


77
00:03:38,366 --> 00:03:39,826
If you're familiar
with type lookup,


78
00:03:39,826 --> 00:03:42,086
it's a great feature
you use it all the time


79
00:03:42,086 --> 00:03:43,896
but you may not be
aware of the fact


80
00:03:43,946 --> 00:03:46,416
that despite the name type
lookup it can actually be used


81
00:03:46,416 --> 00:03:48,016
to lookup a wider
range of things.


82
00:03:48,046 --> 00:03:50,846
I can actually lookup functions
to get the complete signature


83
00:03:51,356 --> 00:03:55,166
or even lookup entire modules,
and of course this a lot


84
00:03:55,166 --> 00:03:57,246
of content as it will
be the full declaration


85
00:03:57,246 --> 00:03:58,876
of every type in that module.


86
00:03:59,166 --> 00:04:00,216
We've abbreviated it here.


87
00:04:02,136 --> 00:04:04,386
So the REPL is fantastic
for these kinds


88
00:04:04,386 --> 00:04:08,896
of additional commands but
it's also useful if you want


89
00:04:08,896 --> 00:04:11,546
to interact with the code
you're writing in the REPL.


90
00:04:11,906 --> 00:04:13,426
Let's say I write a
simple function here.


91
00:04:14,296 --> 00:04:16,786
I've written a function,
I'd like to stop when I'm


92
00:04:16,826 --> 00:04:19,375
in the function and find out
what's going on at a given line,


93
00:04:19,646 --> 00:04:22,416
so I can issue the breakpoint
command by prefixing it


94
00:04:22,416 --> 00:04:25,406
with a colon, colon b 2, I
set a breakpoint at line two


95
00:04:25,406 --> 00:04:28,606
and when I call this function,
execution stops as I'd expect.


96
00:04:29,226 --> 00:04:32,376
And because execution has
stopped it switches immediately


97
00:04:32,376 --> 00:04:35,506
to the LLDB prompt and from the
LLDB prompt I can issue other


98
00:04:35,576 --> 00:04:39,156
LLDB commands to interact with
and explore my application.


99
00:04:39,456 --> 00:04:42,116
And the REPL will also do
this automatically if you run


100
00:04:42,116 --> 00:04:43,776
into an overflow
condition or other things


101
00:04:43,776 --> 00:04:45,476
that would normally
terminate your application


102
00:04:45,586 --> 00:04:47,226
so that you can take
advantage of the full power


103
00:04:47,226 --> 00:04:49,146
of the debugger directly
from the Swift REPL.


104
00:04:49,546 --> 00:04:51,816
You should also note
that you can switch


105
00:04:51,866 --> 00:04:53,526
between the two prompts
at any time.


106
00:04:53,836 --> 00:04:57,056
If you're at the REPL prompt
a colon on its own followed


107
00:04:57,056 --> 00:04:59,536
by enter will bring
up the LLDB prompt,


108
00:04:59,996 --> 00:05:02,566
and the command REPL will
switch back to the REPL prompt


109
00:05:02,786 --> 00:05:05,016
so you can use the two
interchangeably at any time.


110
00:05:05,546 --> 00:05:07,226
The REPL has slightly
different characteristics


111
00:05:07,316 --> 00:05:09,506
and may even be desirable
within a debugging session


112
00:05:09,506 --> 00:05:10,726
where you're debugging
Swift code.


113
00:05:12,636 --> 00:05:13,536
So that's great.


114
00:05:14,086 --> 00:05:17,156
It's a couple of the key ways a
lot of people interact with LLDB


115
00:05:17,216 --> 00:05:20,206
but LLDB is also a
standalone command line tool


116
00:05:20,606 --> 00:05:23,716
and that's fantastic if I'm a
remote shell into a machine,


117
00:05:23,716 --> 00:05:25,856
I have a very slow
connection, I really want


118
00:05:25,906 --> 00:05:28,736
to use typical benefits
of a command line tool.


119
00:05:29,086 --> 00:05:31,196
But it's also useful
under other circumstances.


120
00:05:31,286 --> 00:05:33,306
You might want to use it
for example if you're going


121
00:05:33,306 --> 00:05:34,826
to automate debugging tasks.


122
00:05:35,146 --> 00:05:38,276
I want to setup my debugger the
same way every time I start it,


123
00:05:38,616 --> 00:05:42,516
so I might go ahead and provide
a file containing a whole bunch


124
00:05:42,546 --> 00:05:44,216
of LLDB commands to
configure things.


125
00:05:44,536 --> 00:05:49,606
LLDB -- source followed by
a file name will invoke LLDB


126
00:05:49,746 --> 00:05:51,276
and source all of those commands


127
00:05:51,276 --> 00:05:53,336
to setup my debug session
just the way I want it.


128
00:05:53,336 --> 00:05:56,246
If you don't want to go
through the trouble of setting


129
00:05:56,246 --> 00:05:59,846
up a file, you can invoke LLDB
and provide commands directly


130
00:05:59,846 --> 00:06:04,566
on the command line; -- one-line
will be followed by command


131
00:06:04,566 --> 00:06:06,656
and that will be issued
as soon as I start LLDB,


132
00:06:06,656 --> 00:06:09,166
and if I want additional
commands,


133
00:06:09,436 --> 00:06:11,076
I can just repeat
the option here


134
00:06:11,076 --> 00:06:14,106
in its abbreviated form -o
followed by another command


135
00:06:14,346 --> 00:06:15,406
as many times as I like.


136
00:06:16,116 --> 00:06:17,266
So it can be really trivial


137
00:06:17,266 --> 00:06:20,476
to setup LLDB just the way I
want it in an automated script.


138
00:06:20,986 --> 00:06:24,056
And of course this is especially
valuable in a situation


139
00:06:24,326 --> 00:06:27,406
where I have an application
that fails only one


140
00:06:27,406 --> 00:06:28,636
out of a hundred times.


141
00:06:28,636 --> 00:06:30,226
It's a race condition, I'd


142
00:06:30,226 --> 00:06:32,906
like to run the same debugging
sequence over and over again


143
00:06:33,146 --> 00:06:34,706
and we have a special
option for that as well.


144
00:06:35,756 --> 00:06:38,836
LLDB -- batch starts
a batch mode.


145
00:06:39,086 --> 00:06:41,676
It will execute the instructions
that I provided either


146
00:06:41,676 --> 00:06:43,806
from one line or
sourced from file


147
00:06:44,446 --> 00:06:47,286
and presuming my application
completes normally it will


148
00:06:47,286 --> 00:06:48,036
then exit.


149
00:06:49,026 --> 00:06:51,436
If my application
crashes, it will stop right


150
00:06:51,436 --> 00:06:53,836
at the LLDB prompt where I
can investigate the problem.


151
00:06:54,616 --> 00:06:56,366
And of course just
by wrapping this


152
00:06:56,726 --> 00:06:59,376
with a few other shell commands
I can repeat that series


153
00:06:59,376 --> 00:07:01,706
of actions ad infinitum
or at least


154
00:07:01,856 --> 00:07:03,756
until my application
crashes and I'm ready


155
00:07:03,756 --> 00:07:04,926
to investigate the problem.


156
00:07:07,146 --> 00:07:09,376
LLDB has a wide range
of options.


157
00:07:09,656 --> 00:07:10,706
If you haven't looked at LLDB --


158
00:07:10,706 --> 00:07:13,106
help before, I'd encourage
you to have a look.


159
00:07:13,156 --> 00:07:15,036
It describes these
options and many more.


160
00:07:16,956 --> 00:07:20,686
I'm going to introduce one
really interesting concept here


161
00:07:20,686 --> 00:07:24,276
for us as a team that's actually
probably the least important


162
00:07:24,276 --> 00:07:25,536
thing in this entire talk.


163
00:07:25,536 --> 00:07:27,786
So if you've going to forget
one slide, please start


164
00:07:27,786 --> 00:07:31,326
with this one because
it's largely transparent.


165
00:07:31,516 --> 00:07:32,986
You shouldn't really
notice the effects


166
00:07:33,046 --> 00:07:34,736
but there are some
subtle aspects of it


167
00:07:34,736 --> 00:07:35,866
that I want to introduce.


168
00:07:36,156 --> 00:07:38,496
Starting with Xcode 8, LLDB runs


169
00:07:38,496 --> 00:07:40,916
in a completely separate
process from Xcode.


170
00:07:41,226 --> 00:07:42,516
It's totally transparent to you.


171
00:07:42,616 --> 00:07:45,406
You start debugging the way
you normally did and what


172
00:07:45,406 --> 00:07:48,346
that allows us to do is support
multiple different versions


173
00:07:48,696 --> 00:07:49,416
of the debugger.


174
00:07:50,316 --> 00:07:51,746
It's selected for
you automatically,


175
00:07:52,066 --> 00:07:55,566
so if I go to debug Swift 3
I get the latest debugger,


176
00:07:55,566 --> 00:07:56,906
I get all of the
features that we're going


177
00:07:56,906 --> 00:07:58,166
to introduce in this session.


178
00:07:58,416 --> 00:08:01,736
And in fact if I'm using
pure C++ or Objective C,


179
00:08:02,036 --> 00:08:03,036
the same thing is true.


180
00:08:03,036 --> 00:08:04,916
I get the latest
debugger with all


181
00:08:04,916 --> 00:08:06,196
of the features we'll
talk about here.


182
00:08:07,276 --> 00:08:09,516
On the other hand, if
I'm debugging Swift 2.3,


183
00:08:09,716 --> 00:08:12,326
I'm going to wind up with the
debugger that's essentially what


184
00:08:12,326 --> 00:08:16,276
we shipped earlier this
year with Xcode 7.3.1.


185
00:08:16,786 --> 00:08:18,706
That means some of the newer
commands won't be available,


186
00:08:18,916 --> 00:08:22,056
but we have the full support
of the debugger from the era


187
00:08:22,056 --> 00:08:23,866
of the Swift compiler.


188
00:08:24,916 --> 00:08:27,876
But most importantly
perhaps if you're part


189
00:08:27,876 --> 00:08:30,136
of our open source
community, you'll be able


190
00:08:30,136 --> 00:08:32,456
to debug using the
version of the debugger


191
00:08:32,456 --> 00:08:35,246
that matches the open source
Swift that you're using.


192
00:08:35,525 --> 00:08:38,566
So if you download a snapshot of
our work in progress or indeed


193
00:08:38,566 --> 00:08:40,186
if your start adding
to it yourself,


194
00:08:40,596 --> 00:08:42,706
you will have a debugger
that's immediately available


195
00:08:42,916 --> 00:08:44,496
and you can actually
use that concurrently


196
00:08:44,606 --> 00:08:48,516
with debugging other programs
written in Swift 3 or Swift 2.3


197
00:08:48,796 --> 00:08:50,636
and everything is
completely transparent.


198
00:08:52,156 --> 00:08:55,886
There is one additional benefit
here which is that if LLDB gets


199
00:08:55,886 --> 00:08:58,906
into a situation where it cannot
proceed and it needs to shut


200
00:08:58,906 --> 00:09:00,036
down the debugging session,


201
00:09:00,306 --> 00:09:01,686
the debug session
will be terminated,


202
00:09:01,886 --> 00:09:05,086
LLDB can exit gracefully,
and Xcode will stay running.


203
00:09:09,166 --> 00:09:12,726
To talk about what you can
do with LLDB a powerful tool


204
00:09:12,726 --> 00:09:15,406
that it is and how you can
customize your experience,


205
00:09:15,406 --> 00:09:18,266
I'm going to invite up one of
my engineers Enrico Granata.


206
00:09:19,516 --> 00:09:24,866
[ Applause ]


207
00:09:25,366 --> 00:09:26,046
>> Thank you, Kate.


208
00:09:26,046 --> 00:09:26,586
Hi, everyone.


209
00:09:27,366 --> 00:09:28,576
One of my favorite things


210
00:09:28,576 --> 00:09:32,146
about LLDB is how customizable
of a debugger it is.


211
00:09:32,666 --> 00:09:35,486
It's not only great fun
to work in the technology


212
00:09:35,486 --> 00:09:38,836
that enables this, but it's
also an amazing way for you


213
00:09:38,836 --> 00:09:41,356
to be more productive in
debugging your applications,


214
00:09:41,716 --> 00:09:45,366
and LLDB offers a
great many entry points


215
00:09:45,366 --> 00:09:46,246
for you to customize it.


216
00:09:46,876 --> 00:09:49,776
You can start with command
aliases and then work your way


217
00:09:49,776 --> 00:09:52,976
to custom commands or
custom data formatters


218
00:09:53,296 --> 00:09:56,226
and in Xcode 8 we have
one new extension point


219
00:09:56,226 --> 00:09:58,486
for you; stepping actions.


220
00:09:59,106 --> 00:10:02,676
The way to think about
stepping actions is do you


221
00:10:02,676 --> 00:10:04,366
like what the next command does?


222
00:10:04,516 --> 00:10:06,106
Do you like what the
step command does?


223
00:10:06,356 --> 00:10:09,376
But do you find yourself
wanting to tweak its behavior


224
00:10:09,376 --> 00:10:11,566
in just one or two little
ways here and there?


225
00:10:11,996 --> 00:10:14,566
With stepping actions
you can actually do that.


226
00:10:15,756 --> 00:10:20,016
But the simplest way to
get LLDB, to customize LLDB


227
00:10:20,016 --> 00:10:23,876
to suit your needs is to create
a command alias which is a way


228
00:10:24,096 --> 00:10:26,026
to take a piece of
debugger syntax


229
00:10:26,066 --> 00:10:27,606
for something you frequently do


230
00:10:27,836 --> 00:10:30,536
and attach a shorter
piece of syntax to it.


231
00:10:31,086 --> 00:10:36,386
And now in Xcode 8 we also
let you attach help text to it


232
00:10:36,716 --> 00:10:38,956
so that for your own purposes


233
00:10:39,136 --> 00:10:41,566
or for whoever you
share those aliases


234
00:10:41,566 --> 00:10:44,096
with you can remember
what the alias is up to.


235
00:10:44,776 --> 00:10:45,706
Let's see an example.


236
00:10:46,576 --> 00:10:48,846
First of all, to create
an alias you start


237
00:10:48,846 --> 00:10:50,376
with the command alias command.


238
00:10:50,906 --> 00:10:55,456
Then as I said you can pass
help text to it, you provide us


239
00:10:55,496 --> 00:10:59,376
with a short syntax, and then
you give us the full debugger


240
00:10:59,376 --> 00:11:00,676
command you want to replace.


241
00:11:01,176 --> 00:11:05,646
And now shell is just as normal
a debugger command as any


242
00:11:05,646 --> 00:11:07,326
of the ones we built into it.


243
00:11:07,626 --> 00:11:10,196
You can for instance say
help shell and it will


244
00:11:10,196 --> 00:11:13,596
so you help text including
that which you provided to us.


245
00:11:14,316 --> 00:11:16,356
And for those situations


246
00:11:16,356 --> 00:11:20,396
where debugging becomes a little
gnarly and you tend to forget


247
00:11:20,436 --> 00:11:23,816
who you are as you pursue your
bugs, you can ask the debugger


248
00:11:23,816 --> 00:11:26,806
to remind you your identity
and it will tell you


249
00:11:26,806 --> 00:11:28,656
that it looks like I'm Enrico.


250
00:11:28,916 --> 00:11:33,146
And that's great but if you want
to do something more advanced


251
00:11:33,206 --> 00:11:35,486
than simply attach a new
name to an existing command,


252
00:11:35,926 --> 00:11:37,966
we also vend you a Python API.


253
00:11:38,596 --> 00:11:40,436
It's a fairly extensive
option model


254
00:11:40,436 --> 00:11:43,006
that lets you band the
debugger to your will.


255
00:11:43,946 --> 00:11:46,346
Getting started is
easier than ever.


256
00:11:46,766 --> 00:11:50,266
We've talked about this at great
length in previous WWDC sessions


257
00:11:50,336 --> 00:11:51,686
which you can find online.


258
00:11:52,296 --> 00:11:54,826
We have a website with
documentation and examples


259
00:11:54,826 --> 00:11:59,366
to look at and if you
just search for it online,


260
00:11:59,646 --> 00:12:01,746
there's a community that's
doing wonderful things


261
00:12:01,746 --> 00:12:03,056
around scripting LLDB.


262
00:12:03,266 --> 00:12:05,406
Let me give you a quick example.


263
00:12:06,086 --> 00:12:07,766
Let's say that I want a command


264
00:12:07,896 --> 00:12:11,676
that lets me retrieve the return
value for the last function


265
00:12:11,676 --> 00:12:13,676
that I exited out
of while debugging.


266
00:12:14,616 --> 00:12:15,746
Couple caveats here.


267
00:12:16,286 --> 00:12:19,526
This command will work
only if you finish your way


268
00:12:19,526 --> 00:12:23,196
out of a function and don't
execute any stepping actions


269
00:12:23,196 --> 00:12:23,876
right after.


270
00:12:24,176 --> 00:12:26,386
You can type expressions,
you can look at variables,


271
00:12:26,826 --> 00:12:28,656
just don't step around
and this will work.


272
00:12:29,016 --> 00:12:30,416
Let's look at an
example real quick.


273
00:12:31,076 --> 00:12:34,776
First of all, you import a
file that contains that command


274
00:12:35,266 --> 00:12:37,766
and then as I said
finish out of the function


275
00:12:38,066 --> 00:12:40,456
and the return values is
right there for you to see.


276
00:12:40,716 --> 00:12:41,836
Okay, that's great.


277
00:12:41,836 --> 00:12:44,446
That happens by default, no
need for customization here.


278
00:12:44,776 --> 00:12:48,196
But what if I type
backtrace for example


279
00:12:48,556 --> 00:12:51,226
and that's quite a
verbose backtrace


280
00:12:51,366 --> 00:12:53,696
and now I don't remember
where the return value is.


281
00:12:54,056 --> 00:12:56,616
Okay, I could go up in the
terminal and try to dig it up


282
00:12:56,996 --> 00:13:01,046
but luckily enough we actually
made a command that will tell us


283
00:13:01,046 --> 00:13:05,486
about it, and here that return
value is again for us to see.


284
00:13:06,816 --> 00:13:09,616
This is all it takes
to make that happen.


285
00:13:09,926 --> 00:13:12,126
And by the way don't
really worry about reading


286
00:13:12,126 --> 00:13:15,146
that slide now, it will just be
online waiting for you later.


287
00:13:16,266 --> 00:13:19,576
On the other hand, you see
that it is slide of text


288
00:13:19,916 --> 00:13:23,376
and now you can type your shell
alias, you can type the text,


289
00:13:23,756 --> 00:13:25,676
and you'll find yourself
typing this


290
00:13:25,676 --> 00:13:27,746
because they're awesome every
time you start debugging


291
00:13:27,926 --> 00:13:29,746
and you'll type them
again and again and again


292
00:13:29,946 --> 00:13:31,366
until you're a literal
typing monkey


293
00:13:31,366 --> 00:13:32,936
and all you're actually
doing is typing these


294
00:13:32,936 --> 00:13:34,286
debugger customizations.


295
00:13:34,956 --> 00:13:36,886
Nope. I say no to that.


296
00:13:37,226 --> 00:13:40,446
I say save yourselves
from repetitive typing.


297
00:13:41,006 --> 00:13:41,976
There's no need to do that.


298
00:13:42,146 --> 00:13:44,166
LLDB has an initialization file.


299
00:13:44,646 --> 00:13:48,526
It's called .llbdinit and
it sits in your home folder.


300
00:13:49,476 --> 00:13:50,496
And if you need LLDB


301
00:13:50,496 --> 00:13:53,236
to do something special
something different


302
00:13:53,236 --> 00:13:56,506
when launched under Xcode
versus under the terminal,


303
00:13:57,736 --> 00:14:01,776
there's a .llbdinit -Xcode
file that will be preferred


304
00:14:02,126 --> 00:14:04,516
when launched in the
debugger under Xcode.


305
00:14:05,356 --> 00:14:06,156
One more trick.


306
00:14:06,756 --> 00:14:09,736
If you have Python commands that
you need at debugger start up,


307
00:14:10,096 --> 00:14:12,856
don't try to type
them in .llbdinit.


308
00:14:13,196 --> 00:14:17,206
Put them in a .py file and
then source the .py file


309
00:14:17,576 --> 00:14:21,106
that in LLDB init with
command script import.


310
00:14:23,276 --> 00:14:26,176
Those of you that have used LLDB


311
00:14:26,176 --> 00:14:28,926
for a while are probably
fairly familiar


312
00:14:28,926 --> 00:14:30,616
with the p and po commands.


313
00:14:31,316 --> 00:14:34,396
These are great commands,
they're great ways to look


314
00:14:34,396 --> 00:14:37,626
at data because they
are full expressions.


315
00:14:38,156 --> 00:14:39,626
They have the entire power


316
00:14:39,626 --> 00:14:42,556
of the language you're writing
your application in available


317
00:14:42,556 --> 00:14:44,056
for you at the debugger console.


318
00:14:44,146 --> 00:14:47,146
On the other hand,
with great power comes


319
00:14:47,176 --> 00:14:48,296
great responsibility.


320
00:14:49,236 --> 00:14:52,576
These commands run coding
your target process.


321
00:14:52,796 --> 00:14:55,336
They have potential
to cause side effects


322
00:14:55,746 --> 00:14:59,006
and also sometimes
it's just not possible


323
00:14:59,006 --> 00:15:00,566
to run the code you
want at the point


324
00:15:00,566 --> 00:15:01,756
where you're currently stopped.


325
00:15:01,986 --> 00:15:07,536
And if p runs code once, po
will actually run code twice


326
00:15:07,966 --> 00:15:10,606
because not only does it
evaluate the expression you


327
00:15:10,606 --> 00:15:14,506
provide it also uses
it also evaluates code


328
00:15:14,626 --> 00:15:17,256
to print the customization
to show your type


329
00:15:17,546 --> 00:15:21,746
in a way that's customizable
by type authors which is great


330
00:15:22,206 --> 00:15:25,206
if the type author customized
the display for their type


331
00:15:25,506 --> 00:15:27,076
in exactly the way you want it.


332
00:15:27,746 --> 00:15:28,996
If you're not that lucky,


333
00:15:29,336 --> 00:15:31,526
the p command provides
an alternative viewpoint


334
00:15:31,526 --> 00:15:33,776
of variables that may be
closer to what you want.


335
00:15:34,516 --> 00:15:36,706
And also po is also a command


336
00:15:36,706 --> 00:15:39,486
that runs again twice
coding your target process


337
00:15:39,666 --> 00:15:41,606
with all the potential
for side effects.


338
00:15:42,716 --> 00:15:45,716
If that scares you, we have
another command to look


339
00:15:45,716 --> 00:15:48,086
at variables; frame variable.


340
00:15:48,566 --> 00:15:50,376
This is a very predictable
command,


341
00:15:50,586 --> 00:15:52,366
it will not run any code.


342
00:15:53,016 --> 00:15:55,176
On the other hand,
because it doesn't have


343
00:15:55,176 --> 00:15:56,416
that code running ability,


344
00:15:56,786 --> 00:15:59,856
the syntax it offers is
also extremely limited.


345
00:16:00,526 --> 00:16:04,026
And that's quite a few ways
to look at data already


346
00:16:04,516 --> 00:16:08,886
but spoiler alert, in
Xcode 8 we have more.


347
00:16:09,586 --> 00:16:15,876
Two new ones parray and
poarray, and yes you're right.


348
00:16:16,016 --> 00:16:17,656
They sound a lot like p and po


349
00:16:17,956 --> 00:16:20,336
but they do something
special for arrays.


350
00:16:21,496 --> 00:16:23,286
What do they do especially
for arrays?


351
00:16:24,056 --> 00:16:29,316
Well, if you have used
NS array in Objective C


352
00:16:29,586 --> 00:16:33,196
or Swift arrays you're
used to the safe container


353
00:16:33,196 --> 00:16:35,766
that knows how many
things it contains.


354
00:16:36,366 --> 00:16:38,076
C pointers don't do that.


355
00:16:38,376 --> 00:16:40,856
C pointers don't come with a
kind of batteries included.


356
00:16:41,086 --> 00:16:44,426
They don't know how many
elements they point to and so


357
00:16:44,606 --> 00:16:49,326
when we print a C pointer like
this example in the debugger all


358
00:16:49,326 --> 00:16:51,596
that we're told is
the pointer value.


359
00:16:52,526 --> 00:16:54,576
But now we know that this
points to a bunch of elements


360
00:16:54,776 --> 00:16:56,726
so we can start printing
the first one,


361
00:16:57,196 --> 00:17:00,446
printing the second one and we
keep going and now we're back


362
00:17:00,446 --> 00:17:03,236
to the little typing monkey
situation which we don't like.


363
00:17:04,925 --> 00:17:10,296
Well, in Xcode 8 you can say
parray, number of elements,


364
00:17:10,586 --> 00:17:13,846
pointer and it will
expand for you that pointer


365
00:17:13,886 --> 00:17:16,976
as if it was an array of the
element count you specified.


366
00:17:17,516 --> 00:17:19,675
[ Applause ]


367
00:17:20,175 --> 00:17:20,506
Thank you.


368
00:17:20,506 --> 00:17:21,056
Thank you.


369
00:17:22,465 --> 00:17:25,175
That's already nice
but why do I have


370
00:17:25,226 --> 00:17:26,796
to guess at the element count?


371
00:17:27,566 --> 00:17:28,616
It's right there.


372
00:17:28,766 --> 00:17:29,966
We have the count right there.


373
00:17:30,296 --> 00:17:35,066
What I really want is being able
to type parray count dataset.


374
00:17:36,546 --> 00:17:37,716
I almost can.


375
00:17:37,716 --> 00:17:40,906
All I have to do is
put count in backticks.


376
00:17:41,506 --> 00:17:45,186
That backtick is a general
LLDB syntax facility


377
00:17:45,516 --> 00:17:48,106
which lets you take an
expression, evaluate it


378
00:17:48,336 --> 00:17:50,086
and replace the value
of that expression


379
00:17:50,086 --> 00:17:52,006
in the command before
executing it.


380
00:17:52,736 --> 00:17:55,316
And now I've got my
full array shown.


381
00:17:57,516 --> 00:18:01,226
[ Applause ]


382
00:18:01,726 --> 00:18:02,206
Thank you.


383
00:18:02,236 --> 00:18:04,556
Pretty much the same
thing works for po.


384
00:18:04,556 --> 00:18:08,016
poarray, number of
elements, pointer


385
00:18:08,016 --> 00:18:10,876
and I get po style
descriptions of objects.


386
00:18:11,926 --> 00:18:15,356
On that same topic of po,
I'm sure that those of you


387
00:18:15,356 --> 00:18:19,066
that could write Objective C
code, quite a few I'm sure,


388
00:18:19,066 --> 00:18:22,266
have actually done something
just like that probably


389
00:18:22,266 --> 00:18:24,006
without even thinking about it.


390
00:18:24,346 --> 00:18:27,646
You take po, you say po followed
by a number that you happen


391
00:18:27,646 --> 00:18:29,046
to know is a pointer value


392
00:18:29,266 --> 00:18:30,956
and you get a pretty
description back.


393
00:18:31,816 --> 00:18:34,146
And you try doing the
same thing in Swift


394
00:18:34,696 --> 00:18:35,906
and all you get back
is a number.


395
00:18:36,256 --> 00:18:37,796
Why? What's going on?


396
00:18:38,786 --> 00:18:42,176
Well, I'm sure you've heard
this quite a few times


397
00:18:42,176 --> 00:18:43,836
but I'll say it one more time.


398
00:18:44,186 --> 00:18:46,826
Swift is a type safer
language than Objective C.


399
00:18:47,266 --> 00:18:50,236
We can't assume that numbers
are arbitrarily objects


400
00:18:50,236 --> 00:18:53,306
because not all Swift objects
have a pointer value connected


401
00:18:53,306 --> 00:18:53,646
to them.


402
00:18:54,056 --> 00:18:57,456
So when we say po a number
we'll show you the number.


403
00:18:58,506 --> 00:19:00,226
Okay, that's great but come


404
00:19:00,226 --> 00:19:02,146
on I know there's an
object there just show it


405
00:19:02,146 --> 00:19:02,876
to me already.


406
00:19:03,406 --> 00:19:04,806
There's a way to do that.


407
00:19:06,686 --> 00:19:07,956
There it is.


408
00:19:08,156 --> 00:19:10,456
It looks like a lot of words,
I know it looks like a lot


409
00:19:10,456 --> 00:19:13,026
of words but it's actually
just follow me for a second.


410
00:19:13,356 --> 00:19:15,296
Expr -O just means po.


411
00:19:15,586 --> 00:19:20,156
If you're at the LLDB
console and you say help po,


412
00:19:20,156 --> 00:19:24,486
what it will tell you is that
it's an alias for expr -O.


413
00:19:25,166 --> 00:19:28,826
So all we're actually
saying here is po this thing


414
00:19:28,916 --> 00:19:31,876
as if we were in
Objective C code and with


415
00:19:31,876 --> 00:19:35,076
that we actually get the
pretty description we wanted.


416
00:19:35,576 --> 00:19:37,436
And that's great.


417
00:19:38,406 --> 00:19:42,486
On a topic related to actually
inspecting memory addresses


418
00:19:42,486 --> 00:19:46,506
and trying to make sense of
them, low level debugging.


419
00:19:47,576 --> 00:19:50,186
If you remember one
thing and only one thing


420
00:19:50,186 --> 00:19:54,396
about low level debugging is
to stay very far away from it.


421
00:19:54,546 --> 00:19:54,976
Don't do it.


422
00:19:55,516 --> 00:19:58,996
[ Laughter ]


423
00:19:59,496 --> 00:20:03,166
Unfortunately, sometimes
you just really have to.


424
00:20:03,996 --> 00:20:06,216
Maybe you're debugging
something that only happens


425
00:20:06,336 --> 00:20:08,816
in optimized code in the
release build of your app.


426
00:20:08,996 --> 00:20:10,286
That happens to me sometimes.


427
00:20:11,346 --> 00:20:13,846
Or you're debugging
third party code


428
00:20:13,846 --> 00:20:15,706
for which you have
no debug information.


429
00:20:16,656 --> 00:20:18,126
If any of that applies to you,


430
00:20:18,936 --> 00:20:21,226
follow me as we sail
past the Pillars


431
00:20:21,226 --> 00:20:23,006
of Hercules on this journey.


432
00:20:24,176 --> 00:20:27,956
But please know that on
this journey you proceed


433
00:20:27,956 --> 00:20:28,966
at your own risk.


434
00:20:30,196 --> 00:20:36,086
It starts just like this; I
had a gentleman last year walk


435
00:20:36,086 --> 00:20:39,486
up to me in the lab with his
laptop showing me Xcode just


436
00:20:39,486 --> 00:20:43,206
in that state, crashed in
Objc msgSend of all places.


437
00:20:43,876 --> 00:20:45,096
And he tells me a story.


438
00:20:45,486 --> 00:20:48,906
I have my app and it's
under store and it's great


439
00:20:49,326 --> 00:20:52,036
but then my framework vendor
says, hey I have a new version


440
00:20:52,036 --> 00:20:54,576
of my frame, just
update, it will be okay.


441
00:20:54,916 --> 00:20:56,746
And I did update,
I listened to him,


442
00:20:56,746 --> 00:20:58,236
and now my app crashes
on launch.


443
00:20:58,296 --> 00:20:59,786
What do I do, please help me.


444
00:21:00,486 --> 00:21:02,956
And so we sat down
and I told him well,


445
00:21:03,146 --> 00:21:04,896
we know pretty much nothing here


446
00:21:04,896 --> 00:21:07,736
but one thing we can
do is let's start


447
00:21:07,736 --> 00:21:09,676
by reading machine registers.


448
00:21:10,686 --> 00:21:14,116
LLDB offers a facility to
do that and it lets you look


449
00:21:14,116 --> 00:21:16,826
at all the registers, only
a few of the registers


450
00:21:17,176 --> 00:21:19,296
and it even lets you
play custom formatting.


451
00:21:20,026 --> 00:21:20,886
What does it look like?


452
00:21:21,886 --> 00:21:25,536
You say register read and
you get your register values,


453
00:21:26,236 --> 00:21:28,056
and that's a lot of registers.


454
00:21:28,056 --> 00:21:30,166
And why do I even care about
all those weird numbers


455
00:21:30,166 --> 00:21:32,236
and the words on the screen?


456
00:21:32,686 --> 00:21:36,756
Well, you do care because
often arguments are passed


457
00:21:37,026 --> 00:21:37,946
in registers.


458
00:21:38,896 --> 00:21:41,386
Okay, that's fun, but that
was a lot of registers.


459
00:21:41,456 --> 00:21:43,646
How do I know which ones
actually matter to me?


460
00:21:44,266 --> 00:21:48,006
That is a question for your
platform's application binary


461
00:21:48,006 --> 00:21:51,066
interface ABI, the colon
convention gives you


462
00:21:51,066 --> 00:21:51,696
those rules.


463
00:21:52,556 --> 00:21:54,186
But LLDB also exposes


464
00:21:54,186 --> 00:21:58,816
to you convenient pseudo
registers named $arg1, $arg2,


465
00:21:58,816 --> 00:22:01,356
and so on which in the case


466
00:22:01,356 --> 00:22:03,946
in which your arguments are
actually of simple scaler


467
00:22:04,196 --> 00:22:07,306
or pointer types
actually mapped one to one


468
00:22:07,306 --> 00:22:09,256
between the registers
and the arguments.


469
00:22:10,096 --> 00:22:13,706
Similar convenience is available
in the C family expression.


470
00:22:14,476 --> 00:22:17,406
So for example, if
I have a function


471
00:22:17,406 --> 00:22:20,196
that takes these three
arguments and I call it,


472
00:22:20,906 --> 00:22:23,576
those arguments will
actually map one to one


473
00:22:23,846 --> 00:22:26,326
to $arg1, $arg2, and $arg3.


474
00:22:27,716 --> 00:22:30,206
Okay, so that applies
to our example.


475
00:22:30,346 --> 00:22:33,996
We're in Objc msgSend, we
start by reading arguments.


476
00:22:34,606 --> 00:22:37,636
The first argument is
the pointer 0 X 4 D 2,


477
00:22:37,786 --> 00:22:39,766
the second argument
is the selector string


478
00:22:39,766 --> 00:22:40,716
by appending string.


479
00:22:41,446 --> 00:22:45,036
We happen to know that Objc
msgSends first argument is the


480
00:22:45,036 --> 00:22:46,506
object we're trying to message


481
00:22:46,756 --> 00:22:49,176
and the second argument is the
selector we're trying to send,


482
00:22:50,206 --> 00:22:53,466
and we can also use the memory
read command to check what's


483
00:22:53,466 --> 00:22:55,386
up with the object
that we're messaging.


484
00:22:55,836 --> 00:22:57,696
It turns out that's
a bad object.


485
00:22:58,826 --> 00:23:04,396
What is happening is that
we're calling this selector


486
00:23:04,466 --> 00:23:05,396
on a bad object.


487
00:23:06,156 --> 00:23:09,046
How did we get there?


488
00:23:09,266 --> 00:23:12,526
Well, we're in Objc
msgSend, we're crashed,


489
00:23:13,056 --> 00:23:16,246
something called Objc msgSend,
something called the thing


490
00:23:16,246 --> 00:23:19,986
that called it and so on and so
forth until we get all the way


491
00:23:19,986 --> 00:23:21,776
to the entry point
of our application.


492
00:23:22,666 --> 00:23:28,106
In LLDB we call the frames from
frame 0 the youngest all the way


493
00:23:28,106 --> 00:23:32,806
to frame N the oldest and if
you want to move around frames,


494
00:23:33,176 --> 00:23:36,466
you can use the up command
to go back to an older frame


495
00:23:36,516 --> 00:23:38,666
on the stack and
the down command


496
00:23:38,956 --> 00:23:40,556
to go back to a younger frame.


497
00:23:42,056 --> 00:23:45,936
Another thing worth knowing
is the disassemble command


498
00:23:46,266 --> 00:23:48,866
which lets you look at the
disassembly for a function.


499
00:23:49,346 --> 00:23:50,856
You can do that for
the current function,


500
00:23:50,856 --> 00:23:54,896
for an arbitrary frame, for an
address, for a function by name,


501
00:23:55,196 --> 00:23:57,346
you can customize the way
that disassembly shows


502
00:23:57,816 --> 00:24:00,176
and in some cases
it makes debugging


503
00:24:00,486 --> 00:24:03,066
where you do have source code
and debug info but you want


504
00:24:03,066 --> 00:24:04,636
to compare those instructions


505
00:24:04,636 --> 00:24:07,226
to machine instructions
you can also ask LLDB


506
00:24:07,226 --> 00:24:10,676
to always show you always
show you disassembly along


507
00:24:10,676 --> 00:24:11,396
with source code.


508
00:24:12,136 --> 00:24:17,126
So in our case, we crashed there
and we can see that the thing


509
00:24:17,126 --> 00:24:18,896
that called our function
is an application


510
00:24:18,896 --> 00:24:19,716
that did finish launching.


511
00:24:20,106 --> 00:24:22,116
So let's go there real quick
and take a look at what


512
00:24:22,226 --> 00:24:26,256
that function is doing.


513
00:24:26,766 --> 00:24:29,196
That function is
calling this initializer


514
00:24:29,196 --> 00:24:31,526
that our framework vendor
told us, yes totally code


515
00:24:31,526 --> 00:24:33,246
that initializer,
getGlobalToken.


516
00:24:33,696 --> 00:24:36,756
It's moving some stuff around
and then it's making the call


517
00:24:36,756 --> 00:24:39,486
to Objc msgSend that
will crash us.


518
00:24:40,586 --> 00:24:42,476
So we can step around
machine code


519
00:24:42,476 --> 00:24:44,946
and see what these calls
are actually doing.


520
00:24:45,296 --> 00:24:48,676
First of all we step over
the getGlobalToken call


521
00:24:48,676 --> 00:24:52,126
and then I'm going to
cheat for a second here.


522
00:24:52,466 --> 00:24:56,926
I happen to know that the
register called rax contains the


523
00:24:56,926 --> 00:25:00,576
return value of that
function and if I read it,


524
00:25:01,636 --> 00:25:03,466
that's just the bad
pointer value.


525
00:25:03,986 --> 00:25:05,126
Interesting.


526
00:25:05,546 --> 00:25:07,596
Let's step around a
couple more times.


527
00:25:08,276 --> 00:25:10,686
No, that isn't changing
it, that isn't changing it.


528
00:25:11,296 --> 00:25:14,686
All we're doing is taking
that pointer value as is


529
00:25:14,976 --> 00:25:19,596
and moving it into rdi and
then calling into Objc msgSend.


530
00:25:20,186 --> 00:25:21,736
I wonder if that's connected?


531
00:25:22,386 --> 00:25:27,416
If I reg read $arg1 at this
point right before entering Objc


532
00:25:27,416 --> 00:25:32,376
msgSend, rdi the
bad pointer value.


533
00:25:33,686 --> 00:25:35,246
What have we proven
to ourselves?


534
00:25:35,496 --> 00:25:38,536
We've proven to ourselves that
the getGlobalToken function


535
00:25:38,846 --> 00:25:40,576
that our framework
vendor was so excited


536
00:25:40,576 --> 00:25:43,746
to get us calling actually
returned to us a bad object


537
00:25:44,126 --> 00:25:47,066
and upon trying to send a
message to that bad object,


538
00:25:47,426 --> 00:25:50,406
big surprise, our
application ended up crashing.


539
00:25:51,396 --> 00:25:53,886
And on that note of patting
ourselves on the back


540
00:25:53,886 --> 00:25:56,896
for conclusively proving
our case, I want to hand it


541
00:25:56,896 --> 00:25:59,026
over to Sean Callanan
to tell you all


542
00:25:59,026 --> 00:26:01,046
about the great new features
in the expression parser.


543
00:26:01,316 --> 00:26:01,846
Thank you.


544
00:26:02,516 --> 00:26:07,546
[ Applause ]


545
00:26:08,046 --> 00:26:08,726
>> Isn't that magic?


546
00:26:09,276 --> 00:26:10,236
It feels like magic.


547
00:26:10,376 --> 00:26:13,616
Your program is just
storing its data as numbers,


548
00:26:14,116 --> 00:26:19,026
arrays of numbers and yet you
can use LLDB this powerful tool


549
00:26:19,536 --> 00:26:24,436
to represent that data in
the way you think about it.


550
00:26:25,306 --> 00:26:30,106
Sometimes though it's not
quite as easy as just looking


551
00:26:30,106 --> 00:26:32,766
at a number and figuring
out what the data is.


552
00:26:33,936 --> 00:26:36,336
Sometimes you need
the expression parser.


553
00:26:36,906 --> 00:26:38,726
Now, Enrico has already
shown you


554
00:26:38,816 --> 00:26:40,516
where the expression parser fits


555
00:26:40,516 --> 00:26:42,246
in in the general
command syntax,


556
00:26:42,686 --> 00:26:44,226
but there's a lot
that it can do.


557
00:26:45,656 --> 00:26:49,706
The expression parse's job is to
work together with your program


558
00:26:49,796 --> 00:26:54,896
and the SDK and get from
where you're currently stopped


559
00:26:55,946 --> 00:27:02,186
through some contortions to get
at the data you want to the data


560
00:27:02,186 --> 00:27:03,996
that you're actually
trying to inspect.


561
00:27:05,636 --> 00:27:09,066
Now, I said we work
with your program


562
00:27:09,066 --> 00:27:10,566
and we work with the SDK.


563
00:27:11,826 --> 00:27:15,696
Working with the SDK hasn't
always been easy in LLDB


564
00:27:15,786 --> 00:27:17,586
if you remember from
previous years.


565
00:27:18,816 --> 00:27:20,566
So for example if
you were stopped


566
00:27:20,566 --> 00:27:23,356
in an Objective C
program and you tried


567
00:27:23,356 --> 00:27:28,146
to get the program's undo
manager, you probably


568
00:27:28,856 --> 00:27:31,866
at least once or twice
got an annoying error.


569
00:27:33,056 --> 00:27:36,776
It wasn't at all relevant to
what you were trying to do


570
00:27:36,776 --> 00:27:39,086
and it was really puzzling.


571
00:27:39,736 --> 00:27:41,366
But last year we told
you there's a way


572
00:27:41,366 --> 00:27:42,166
to get out of this.


573
00:27:44,416 --> 00:27:51,456
If you just manually
import AppKit then you're


574
00:27:51,456 --> 00:27:52,596
expression works.


575
00:27:53,406 --> 00:27:55,766
All right, but why
did I have to do that?


576
00:27:55,946 --> 00:27:57,126
It's already there.


577
00:27:58,546 --> 00:27:59,476
I hear you cry.


578
00:28:00,516 --> 00:28:02,596
[ Laughter ]


579
00:28:03,096 --> 00:28:05,196
You're not the only ones.


580
00:28:05,196 --> 00:28:09,336
So this year we thought what
can we do to make this better,


581
00:28:10,326 --> 00:28:11,496
and it was pretty obvious.


582
00:28:12,346 --> 00:28:15,886
We looked at which modules the
current source file imports


583
00:28:16,226 --> 00:28:18,346
and we import them
for you automatically.


584
00:28:18,626 --> 00:28:20,866
No more of that manual
importing business.


585
00:28:21,516 --> 00:28:26,546
[ Applause ]


586
00:28:27,046 --> 00:28:30,546
Cool. So we're getting out
of your way more efficiently.


587
00:28:30,946 --> 00:28:34,346
That's great, but this is
supposed to be a powerful tool.


588
00:28:34,886 --> 00:28:38,176
Let me tell you about
some of the great things


589
00:28:38,406 --> 00:28:40,286
that you can do with it.


590
00:28:40,756 --> 00:28:44,046
Now, sometimes these
conveniences might get


591
00:28:44,046 --> 00:28:44,556
in your way.


592
00:28:44,586 --> 00:28:45,916
You're actually trying


593
00:28:46,016 --> 00:28:48,316
to manually import
the things you want.


594
00:28:49,336 --> 00:28:52,216
There's a feature, a
setting that you can use


595
00:28:52,256 --> 00:28:54,976
to disable this automatic
importing


596
00:28:55,096 --> 00:28:58,066
and get back the feature
the way it was last year.


597
00:28:59,046 --> 00:29:02,396
We think you're going to like
it though so it's by default on.


598
00:29:02,796 --> 00:29:05,656
Great. Now let's
talk more generally


599
00:29:05,656 --> 00:29:07,866
about using the expression
parser effectively


600
00:29:08,526 --> 00:29:10,026
by reusing code.


601
00:29:10,626 --> 00:29:14,536
Now, the most simple case


602
00:29:14,536 --> 00:29:16,776
of reusing code is
reusing variables.


603
00:29:17,836 --> 00:29:22,146
Now remember I said you might
need to do multistep expressions


604
00:29:22,676 --> 00:29:25,466
to get to the data that you
actually want from the place


605
00:29:25,466 --> 00:29:26,446
where you currently are.


606
00:29:27,786 --> 00:29:30,116
In Swift you can do
something as simple


607
00:29:30,806 --> 00:29:33,696
as defining a temporary
variable and using it.


608
00:29:35,196 --> 00:29:36,096
This just works.


609
00:29:36,226 --> 00:29:37,976
It's as if you typed
it in your own program.


610
00:29:39,396 --> 00:29:42,396
Now what might be
counterintuitive is what happens


611
00:29:42,636 --> 00:29:43,696
if you try to use it again.


612
00:29:44,896 --> 00:29:47,236
Then we say, what's
that variable name?


613
00:29:49,216 --> 00:29:52,446
Well, actually we intended
it to work this way.


614
00:29:53,096 --> 00:29:57,056
The reason is you might
step around, you might stop


615
00:29:57,056 --> 00:30:00,326
in different places, maybe
later you're in a place


616
00:30:00,326 --> 00:30:02,596
where you're program
actually defined an A.


617
00:30:02,936 --> 00:30:04,386
Do we want the A you used


618
00:30:04,386 --> 00:30:06,286
as a temporary valuable
to get in your way?


619
00:30:07,256 --> 00:30:14,626
Probably not, but there
is a way out of this.


620
00:30:14,706 --> 00:30:17,936
The affordance we
setup to make sure


621
00:30:17,936 --> 00:30:19,736
that your variables don't escape


622
00:30:19,736 --> 00:30:22,366
in that way is we actually
setup a local context.


623
00:30:22,366 --> 00:30:25,626
It's as if you actually put a
set of braces in your program,


624
00:30:26,046 --> 00:30:30,376
put the let A in there and the
print, but if you want the A


625
00:30:30,376 --> 00:30:34,356
to break out, all you have to
do is give it a special name,


626
00:30:34,876 --> 00:30:36,346
a name with a dollar sign.


627
00:30:37,176 --> 00:30:39,206
That means that it
will never collide


628
00:30:39,246 --> 00:30:43,656
with your own program's names
and it means that it will live


629
00:30:44,236 --> 00:30:45,856
as long as your debug
session does.


630
00:30:47,176 --> 00:30:49,716
Awesome. What else can
you do with this tool?


631
00:30:49,716 --> 00:30:51,746
It turns out quite a lot.


632
00:30:52,386 --> 00:30:55,616
Now in Swift ever
since day one with LLDB


633
00:30:55,616 --> 00:30:58,546
and Swift you've been able to do
the same trick with functions.


634
00:30:59,696 --> 00:31:02,886
Now when you did that
you probably wanted


635
00:31:02,886 --> 00:31:05,756
to use multiline
expression modes and in fact


636
00:31:05,756 --> 00:31:07,956
if you typed the expression
command and pressed enter,


637
00:31:08,276 --> 00:31:10,386
you're immediately going
to get a multiline editor


638
00:31:10,646 --> 00:31:12,866
where you can type
in your function.


639
00:31:13,726 --> 00:31:19,446
If you define your function then
you can simply reuse it again


640
00:31:19,446 --> 00:31:20,526
remembering the dollar sign.


641
00:31:22,106 --> 00:31:24,876
Now, those of you who
tried this in Swift


642
00:31:24,876 --> 00:31:27,976
and said that's awesome might
have tried it in Objective C


643
00:31:29,746 --> 00:31:32,406
and it wasn't so great.


644
00:31:34,156 --> 00:31:36,286
Function definition
isn't allowed here.


645
00:31:36,716 --> 00:31:38,986
Come on these LLDB guys
always get in my way.


646
00:31:39,486 --> 00:31:39,886
All right.


647
00:31:40,146 --> 00:31:43,896
Well, turns out we
like this feature too,


648
00:31:43,896 --> 00:31:45,566
we think it's awesome,
we want it to be better.


649
00:31:46,786 --> 00:31:49,936
But we can't just make
it magically work.


650
00:31:50,436 --> 00:31:54,246
The reason is remember
we're stopped in your code.


651
00:31:54,706 --> 00:31:57,736
We want to act like we're
inside your function.


652
00:31:58,726 --> 00:32:01,746
If you're in Swift you can
define nested functions,


653
00:32:01,746 --> 00:32:03,886
it's no big deal, the
compiler will love it.


654
00:32:03,886 --> 00:32:06,256
It won't love the dollar
sign you can take that out


655
00:32:06,626 --> 00:32:08,156
but the rest it's fine with.


656
00:32:09,056 --> 00:32:09,926
This is totally legal.


657
00:32:11,746 --> 00:32:16,356
In C, C++ and Objective C though
trying to make a nested function


658
00:32:16,356 --> 00:32:18,986
like that, that's no good
the compiler is going


659
00:32:18,986 --> 00:32:22,136
to yell at you.


660
00:32:22,356 --> 00:32:23,936
Well, the way you get


661
00:32:23,936 --> 00:32:28,716
around that is using the
top level expression mode.


662
00:32:29,506 --> 00:32:31,496
That's an extension of
the expression command


663
00:32:31,926 --> 00:32:33,986
that makes it break completely


664
00:32:33,986 --> 00:32:36,166
out of the current
function you're stopped in


665
00:32:36,206 --> 00:32:39,566
and just define global
code whether it's functions


666
00:32:39,566 --> 00:32:41,306
or variables or what you will.


667
00:32:42,206 --> 00:32:43,606
Now you can define your function


668
00:32:43,606 --> 00:32:45,306
and use it just the
way you would expect.


669
00:32:46,416 --> 00:32:47,116
All right.


670
00:32:48,586 --> 00:32:51,746
Now the functions aren't
the only reusable things you


671
00:32:51,746 --> 00:32:52,326
can define.


672
00:32:52,326 --> 00:32:53,696
I've already talked
about variables.


673
00:32:54,066 --> 00:32:56,806
You can define closures too,
they're kind of a merger


674
00:32:56,806 --> 00:32:58,126
of variables and code.


675
00:32:59,236 --> 00:33:01,506
In Swift you can define
a closure and use it.


676
00:33:03,006 --> 00:33:06,236
New in Xcode this year
you can do the same thing


677
00:33:06,236 --> 00:33:07,026
in Objective C.


678
00:33:07,636 --> 00:33:12,236
Blocks can be defined and
reused and for those of you


679
00:33:12,236 --> 00:33:14,116
who are diehard C++ fans,


680
00:33:14,546 --> 00:33:16,716
you can do the exact
same thing with lambdas.


681
00:33:17,286 --> 00:33:22,006
Now, what can you do
with these blocks?


682
00:33:22,006 --> 00:33:23,156
What's special about them.


683
00:33:23,456 --> 00:33:25,926
Well, you can pass them off
to functions for example.


684
00:33:26,846 --> 00:33:27,906
Sometimes you might need


685
00:33:27,906 --> 00:33:30,596
to manually run something
on a certain queue.


686
00:33:31,906 --> 00:33:32,636
That works.


687
00:33:33,086 --> 00:33:35,436
You can send stuff for
example to a global queue


688
00:33:35,806 --> 00:33:37,156
and the block will simply run.


689
00:33:38,656 --> 00:33:43,096
Now, sometimes it
gets a little annoying


690
00:33:43,526 --> 00:33:46,636
because these complex
expressions result


691
00:33:46,636 --> 00:33:49,346
in much more likelihood
of typos.


692
00:33:50,646 --> 00:33:54,456
Now, what's the difference
quickly without looking back


693
00:33:54,536 --> 00:33:57,636
to the previous slide between
this expression and the one


694
00:33:57,636 --> 00:33:58,666
from the previous slide?


695
00:33:59,556 --> 00:34:00,336
You probably missed it.


696
00:34:00,776 --> 00:34:02,156
The compiler sure didn't.


697
00:34:03,046 --> 00:34:06,256
It will yell at you about
the missing semicolon


698
00:34:06,866 --> 00:34:09,206
but there's a better way.


699
00:34:09,656 --> 00:34:11,556
If you were to type this
into the source editor,


700
00:34:12,406 --> 00:34:14,576
we would have told you,
hey you probably missed a


701
00:34:14,576 --> 00:34:15,386
semicolon here.


702
00:34:15,386 --> 00:34:18,306
Did you mean to put it in?


703
00:34:18,306 --> 00:34:21,726
Well, it turns out LLDB
can do the same thing,


704
00:34:22,056 --> 00:34:25,436
and we can do one better by
just automatically putting


705
00:34:25,436 --> 00:34:26,956
in the semicolon
that was missing,


706
00:34:27,335 --> 00:34:28,386
running your expression.


707
00:34:28,976 --> 00:34:30,266
This is called fixit.


708
00:34:30,266 --> 00:34:32,436
It's been in clang for a while


709
00:34:32,726 --> 00:34:34,806
and LLDB now applies
the same thing.


710
00:34:36,886 --> 00:34:38,496
Swift has fixit too.


711
00:34:39,716 --> 00:34:42,826
In Swift you're less likely
to run into semicolon problems


712
00:34:43,166 --> 00:34:45,426
but boy those exclamation
points are annoying.


713
00:34:46,516 --> 00:34:48,656
[ Laughter ]


714
00:34:49,156 --> 00:34:54,025
Yeah. Well, they are as valuable
as they are in your own code


715
00:34:54,025 --> 00:34:55,176
for you to understand it,


716
00:34:55,306 --> 00:34:57,306
when you're debugging you
just want them the heck


717
00:34:57,306 --> 00:35:00,786
out of your way, and
believe me we do too.


718
00:35:01,756 --> 00:35:04,876
So if you try to use something
without unwrapping it,


719
00:35:06,126 --> 00:35:08,076
we just apply the fixit
and unwrap it for you.


720
00:35:09,306 --> 00:35:12,016
Now, there may be
one or two people


721
00:35:12,186 --> 00:35:14,556
who say I don't want
debugger touching my code.


722
00:35:15,146 --> 00:35:20,986
Now, for those people I
have had those evenings too,


723
00:35:21,776 --> 00:35:26,136
and we have settings that will
turn off the entire autoapply


724
00:35:26,136 --> 00:35:28,716
fixit feature and
if you just don't


725
00:35:28,716 --> 00:35:31,116
like the debugger
acting smug and pointing


726
00:35:31,116 --> 00:35:33,736
out every little thing in your
code that it's fixing for you,


727
00:35:34,176 --> 00:35:36,226
then you can turn just
that part off too.


728
00:35:37,956 --> 00:35:38,376
All right.


729
00:35:39,516 --> 00:35:44,156
[ Applause ]


730
00:35:44,656 --> 00:35:45,176
Thanks. All right.


731
00:35:45,916 --> 00:35:49,246
Great. That's a nice convenience
feature but let me finish


732
00:35:49,246 --> 00:35:53,696
up with just one more thing that
you can define that's reusable.


733
00:35:53,696 --> 00:35:56,866
You can define your own types.


734
00:35:57,966 --> 00:36:00,726
In Swift for example you can
enter a multiline expression


735
00:36:00,926 --> 00:36:05,146
that defines a class and
when you try to instantiate


736
00:36:05,146 --> 00:36:08,196
that class indeed it
shows up just the way


737
00:36:08,576 --> 00:36:11,006
as if you had defined the
class in your own program.


738
00:36:12,336 --> 00:36:18,026
In the same way in C++, you can
define a class and reuse it.


739
00:36:18,916 --> 00:36:24,256
Now let me show you an example
of taking all these concepts


740
00:36:24,306 --> 00:36:28,336
and using them in
your own program.


741
00:36:28,496 --> 00:36:31,666
Often especially in your
programs that interact


742
00:36:31,666 --> 00:36:34,566
with web APIs you get a lot
of data back and you want


743
00:36:34,566 --> 00:36:36,446
to filter it especially
when you're debugging.


744
00:36:37,736 --> 00:36:41,826
The way you filter data
especially say in NS array is


745
00:36:41,826 --> 00:36:43,076
by defining a predicate.


746
00:36:44,526 --> 00:36:48,356
Now in the expression parser you
can define custom predicates.


747
00:36:49,176 --> 00:36:52,266
In this case we're
taking writing a block


748
00:36:52,726 --> 00:36:56,266
that takes the result
strings from the web server


749
00:36:56,996 --> 00:36:59,146
and filters them to find strings


750
00:36:59,176 --> 00:37:01,046
that have the text
error in them.


751
00:37:01,836 --> 00:37:02,986
Probably useful for debugging.


752
00:37:04,256 --> 00:37:08,526
Now if you simply take
an array full of data


753
00:37:08,526 --> 00:37:12,416
from your web server and you
apply the predicate to it,


754
00:37:12,666 --> 00:37:14,696
you can get right
down to the message


755
00:37:14,696 --> 00:37:17,356
that you actually cared about.


756
00:37:18,426 --> 00:37:18,816
All right.


757
00:37:19,186 --> 00:37:22,166
Now you've hopefully seen how
powerful the expression parser


758
00:37:22,166 --> 00:37:24,806
can be for you, I'd like to
turn things over to Jim Ingham


759
00:37:25,136 --> 00:37:26,816
to show you more
powerful features of LLDB.


760
00:37:27,516 --> 00:37:31,886
[ Applause ]


761
00:37:32,386 --> 00:37:32,936
>> Thank you, Sean.


762
00:37:33,416 --> 00:37:36,416
So, so far we've sort of
inverted the natural order


763
00:37:36,416 --> 00:37:39,586
of things and told you
how to look at the state


764
00:37:39,586 --> 00:37:42,116
of your program when you're
stopped but we haven't


765
00:37:42,116 --> 00:37:43,886
yet told you how you
would actually get


766
00:37:43,886 --> 00:37:44,996
to such interesting points.


767
00:37:44,996 --> 00:37:46,666
So that's with what I'm going
to tell you a little bit about.


768
00:37:46,926 --> 00:37:49,646
Of course breakpoints
are the natural way


769
00:37:49,876 --> 00:37:51,956
that you would stop
your program.


770
00:37:51,956 --> 00:37:54,896
So I want to talk a little
bit about how you might think


771
00:37:54,896 --> 00:37:59,586
about breakpoints naively as the
place where I stop my program


772
00:37:59,806 --> 00:38:01,886
but that's actually not
how they're implemented


773
00:38:01,886 --> 00:38:04,356
or how LLDB thinks about them.


774
00:38:04,356 --> 00:38:07,196
To LLDB a breakpoint
is really is search


775
00:38:07,466 --> 00:38:10,936
through your program space
for interesting places to stop


776
00:38:10,936 --> 00:38:13,366
or many different kinds of
searches as it turns out.


777
00:38:13,706 --> 00:38:16,496
So breakpoints are
really search criteria


778
00:38:16,866 --> 00:38:20,896
and what the individual
locations where your stop,


779
00:38:20,896 --> 00:38:22,876
what you thought of
naively a breakpoint,


780
00:38:23,186 --> 00:38:25,136
we call breakpoint locations.


781
00:38:25,466 --> 00:38:27,616
So to make this a little more
concrete, let me tie this


782
00:38:27,666 --> 00:38:31,966
to Xcode's breakpoints because
after all Xcode under the covers


783
00:38:31,966 --> 00:38:33,596
when it debugs is LLDB


784
00:38:33,596 --> 00:38:37,176
so all the Xcode breakpoints
must be LLDB breakpoints.


785
00:38:37,416 --> 00:38:41,576
So for instance when you click
in the source gutter in Xcode,


786
00:38:41,756 --> 00:38:45,016
what you're really doing is
running this command in LLDB,


787
00:38:45,016 --> 00:38:46,496
some breakpoint setting command.


788
00:38:46,976 --> 00:38:49,606
Similarly when you make a
symbolic breakpoint you're


789
00:38:49,606 --> 00:38:52,286
running a by name
breakpoint setting.


790
00:38:52,506 --> 00:38:55,136
So I want to give
you a little sense


791
00:38:55,136 --> 00:38:58,726
that these are really
searches by showing you cases


792
00:38:58,726 --> 00:39:02,906
in which you would end up
naturally with multiple results


793
00:39:02,906 --> 00:39:05,786
from what you thought of as
a simple unitary breakpoint


794
00:39:05,786 --> 00:39:08,446
setting, so the first example


795
00:39:08,446 --> 00:39:10,656
that I'll show you is
symbolic breakpoints.


796
00:39:10,926 --> 00:39:12,846
So here's an example
where you want


797
00:39:12,846 --> 00:39:14,356
to just set a breakpoint
on main.


798
00:39:14,356 --> 00:39:15,896
That should be a simple
thing to do, right?


799
00:39:16,236 --> 00:39:18,866
But then it says, no
I have 19 locations.


800
00:39:18,866 --> 00:39:20,546
Well, while did you
end up with 19?


801
00:39:20,926 --> 00:39:23,376
Do the break list
command to see the results


802
00:39:23,376 --> 00:39:25,406
of your breakpoint
setting and what you see is


803
00:39:25,406 --> 00:39:30,226
that the breakpoint name
search is actually a loose name


804
00:39:30,226 --> 00:39:34,436
matching search, so for instance
it picked up the selector names


805
00:39:34,436 --> 00:39:36,486
within a class and
that's actually convenient


806
00:39:36,486 --> 00:39:39,386
in many cases because like
if you're debugging in C++


807
00:39:39,386 --> 00:39:42,836
and you have a name space, and a
name space inside, and a class,


808
00:39:42,836 --> 00:39:45,076
and a method, you don't
want to have to type all


809
00:39:45,076 --> 00:39:49,036
of the full path to that but
on the other hand it does mean


810
00:39:49,036 --> 00:39:52,006
that the search is perhaps wider
than you intended it to be.


811
00:39:52,616 --> 00:39:54,976
We provide many different
kinds of searches


812
00:39:54,976 --> 00:39:57,746
so of course we provide a
slightly more strict search


813
00:39:57,966 --> 00:40:01,486
which is the full name
search that forces the name


814
00:40:01,486 --> 00:40:05,306
to match the entire name of the
symbol that you're specifying.


815
00:40:05,726 --> 00:40:07,866
We tried that but even
that didn't work right.


816
00:40:08,156 --> 00:40:10,806
Well, for some reason somebody
decided their library has


817
00:40:10,806 --> 00:40:13,516
to have a function called main
in it, no idea why but it does.


818
00:40:13,916 --> 00:40:17,816
So you can even specify
further by limiting your search


819
00:40:17,816 --> 00:40:21,976
to a particular shared
library with the shlib option.


820
00:40:21,976 --> 00:40:24,276
So then finally then you
get the breakpoint you want.


821
00:40:24,716 --> 00:40:26,286
I'm going to give you
one other instance not


822
00:40:26,286 --> 00:40:27,616
because I don't think
you believe me


823
00:40:27,616 --> 00:40:30,206
but because this one actually
comes up in Swift fairly often


824
00:40:30,416 --> 00:40:32,116
with file and line breakpoints


825
00:40:32,406 --> 00:40:34,156
because Swift has
this nice feature


826
00:40:34,306 --> 00:40:38,436
that you can call a
function that uses a closure


827
00:40:38,566 --> 00:40:42,806
and define the closure simply by
continuing with a curly bracket


828
00:40:42,806 --> 00:40:45,016
and then on with the
body of the closure.


829
00:40:45,206 --> 00:40:47,526
But then if you try to set
a breakpoint on that line,


830
00:40:47,696 --> 00:40:50,756
what you're going to find out
is you have two stop points.


831
00:40:50,756 --> 00:40:51,656
Why do you have that?


832
00:40:52,106 --> 00:40:54,696
When you look it's actually
fairly straightforward, right?


833
00:40:54,886 --> 00:40:58,676
That source line actually
contributed a little bit of code


834
00:40:58,676 --> 00:41:01,796
to the closure function and
you see we have a breakpoint


835
00:41:01,796 --> 00:41:03,666
location on the closure
function,


836
00:41:03,906 --> 00:41:07,486
but it also was the invoking
site for that function


837
00:41:07,776 --> 00:41:11,726
and so you also have a
location for that invoking site.


838
00:41:12,226 --> 00:41:16,836
So anyway that's for that so now
having given you a few examples,


839
00:41:17,056 --> 00:41:19,806
let me give you the general
form of the command and then go


840
00:41:19,806 --> 00:41:22,846
on to some more interesting
uses of it.


841
00:41:23,416 --> 00:41:25,746
So the breakpoint set
command works as follows:


842
00:41:25,746 --> 00:41:28,686
You say break set and then
there are some options


843
00:41:28,686 --> 00:41:31,076
which specify the type


844
00:41:31,076 --> 00:41:33,846
and that's really
specifying the kind


845
00:41:33,846 --> 00:41:34,826
of search that you're doing.


846
00:41:34,826 --> 00:41:37,086
Is it a file and line
search, a symbol name search


847
00:41:37,086 --> 00:41:37,986
or so on and so forth?


848
00:41:38,286 --> 00:41:41,436
And the values for that
type option will be the data


849
00:41:41,546 --> 00:41:45,336
for the search and then there
are other kinds of options


850
00:41:45,636 --> 00:41:48,046
like ignore count,
condition and so on.


851
00:41:48,246 --> 00:41:51,026
The way to think about those
options is they don't specify


852
00:41:51,286 --> 00:41:54,306
where to break, they
specify whether to break.


853
00:41:54,576 --> 00:41:59,876
So that's the whether can be
modified after the fact but the


854
00:41:59,876 --> 00:42:02,026
where can't because we've
already done the search


855
00:42:02,026 --> 00:42:03,586
and you would just
set a new breakpoint


856
00:42:03,586 --> 00:42:04,466
if you wanted to do that.


857
00:42:04,836 --> 00:42:07,556
So let's talk a little bit about
these breakpoint location things


858
00:42:07,556 --> 00:42:09,736
which are the places where
you're going to stop.


859
00:42:09,736 --> 00:42:11,766
They are the individual
search results,


860
00:42:12,036 --> 00:42:14,416
they always have some
address which is the address


861
00:42:14,416 --> 00:42:16,746
at which your program
is going to halt.


862
00:42:17,116 --> 00:42:19,576
When you look at them
they're specified


863
00:42:19,576 --> 00:42:21,546
by the generating
breakpoint's number


864
00:42:21,716 --> 00:42:24,416
and a location number
written separated by a dot.


865
00:42:24,416 --> 00:42:27,666
So if you actually notice
when you're debugging in Xcode


866
00:42:27,666 --> 00:42:30,126
and you stop at one of your
breakpoints and you look


867
00:42:30,126 --> 00:42:33,746
at the little PC ribbon, the PC
ribbon will have the stop reason


868
00:42:33,746 --> 00:42:36,186
on the far right and
it will say breakpoint,


869
00:42:36,186 --> 00:42:37,766
but it always says 2.1.


870
00:42:37,766 --> 00:42:39,416
It never said breakpoint 2


871
00:42:39,596 --> 00:42:42,066
because you only ever
really stop at locations


872
00:42:42,366 --> 00:42:44,316
so 1.1, 1.2 or whatever.


873
00:42:44,636 --> 00:42:48,686
By the way, the locations
and breakpoints are sort


874
00:42:48,686 --> 00:42:50,366
of symmetrical with
respect to all


875
00:42:50,366 --> 00:42:52,606
of these other options
that I talked about.


876
00:42:52,826 --> 00:42:55,836
They all take the same sort of
generic options like commands


877
00:42:55,836 --> 00:42:57,076
and conditions and so forth,


878
00:42:57,396 --> 00:43:00,766
and you can specify a
command condition whatever


879
00:43:00,766 --> 00:43:03,486
on a breakpoint and then it
will work for all the locations


880
00:43:03,696 --> 00:43:06,936
but you can also override
for a particular location one


881
00:43:06,936 --> 00:43:08,906
of the commands or
conditions just by setting it


882
00:43:08,906 --> 00:43:10,826
on the location instead.


883
00:43:11,206 --> 00:43:13,556
One other little convenience,


884
00:43:14,076 --> 00:43:17,116
oftentimes if you have a
breakpoint that's generated a


885
00:43:17,116 --> 00:43:18,966
bunch of locations,
you want five of them,


886
00:43:18,966 --> 00:43:21,226
you don't want five of
them so you disable them


887
00:43:21,416 --> 00:43:22,946
which you can do independently,


888
00:43:23,266 --> 00:43:26,216
but then if you you don't want
any of them to hit you want


889
00:43:26,216 --> 00:43:28,316
to be able to disable the whole
breakpoint which you can do


890
00:43:28,316 --> 00:43:29,616
by disabling the breakpoint.


891
00:43:29,796 --> 00:43:32,766
But it turns out that doesn't
change the enable disable state


892
00:43:32,766 --> 00:43:35,906
of it locations so then you
can just turn it back on again


893
00:43:36,126 --> 00:43:39,206
and all of the location state
will be as you would expect.


894
00:43:39,666 --> 00:43:40,666
So that's just a little thing.


895
00:43:40,906 --> 00:43:42,416
So now that you've
seen a little bit,


896
00:43:42,586 --> 00:43:45,356
the notion of how breakpoints
are thought of in LLDB,


897
00:43:45,356 --> 00:43:48,736
let me show you a couple
of more powerful types


898
00:43:48,736 --> 00:43:50,476
of breakpoints that
LLDB provides.


899
00:43:50,726 --> 00:43:53,046
So again these are
searches for places to stop.


900
00:43:53,156 --> 00:43:55,586
What kinds of searches
are we going to do?


901
00:43:55,686 --> 00:43:57,406
It's just what name spaces


902
00:43:57,406 --> 00:43:59,366
in your program might
be interesting.


903
00:43:59,576 --> 00:44:02,276
It turns out all of the
name spaces are name spaces


904
00:44:02,276 --> 00:44:04,336
of stringy things because
they're all like names


905
00:44:04,336 --> 00:44:08,486
of functions or whatever, so we
always use regular expressions


906
00:44:08,656 --> 00:44:10,976
as the way to express
the search patterns.


907
00:44:11,196 --> 00:44:12,686
So if you know regular
expressions,


908
00:44:12,686 --> 00:44:13,916
this will make you feel lovely,


909
00:44:14,196 --> 00:44:16,056
and if you don't
regular expressions,


910
00:44:16,376 --> 00:44:19,096
I would have said a couple
years ago look for somebody


911
00:44:19,126 --> 00:44:21,536
in your office that
has books with animals


912
00:44:21,536 --> 00:44:23,506
on them although
nowadays if you're looking


913
00:44:23,506 --> 00:44:25,326
for somebody old you
probably should just look


914
00:44:25,326 --> 00:44:26,876
for somebody who
has books at all.


915
00:44:27,516 --> 00:44:29,516
[ Laughter ]


916
00:44:30,516 --> 00:44:32,546
[ Applause ]


917
00:44:33,046 --> 00:44:35,476
So anyway, so we provide
two kinds of searches,


918
00:44:35,476 --> 00:44:38,886
one is fairly obvious which
is a search over the names


919
00:44:38,886 --> 00:44:42,106
of functions in your program
so this is the option for that,


920
00:44:42,366 --> 00:44:44,116
and one that might be
slightly less obvious


921
00:44:44,116 --> 00:44:45,996
but I'll convince you
is interesting I hope


922
00:44:45,996 --> 00:44:49,576
as we go along, are sourced
text search breakpoints.


923
00:44:49,966 --> 00:44:51,456
And this is the option
for those.


924
00:44:51,946 --> 00:44:54,826
Okay, so let's give you the
first one this is function name


925
00:44:54,826 --> 00:44:55,996
pattern matching breakpoints


926
00:44:55,996 --> 00:44:57,496
and I'll just show
you some examples.


927
00:44:57,806 --> 00:44:59,636
So suppose somebody has
given you a new class


928
00:45:00,216 --> 00:45:02,706
and you don't know what it does,
you want to see how it works,


929
00:45:02,926 --> 00:45:04,326
so what you want to
do really is break


930
00:45:04,326 --> 00:45:07,636
on all the methods implemented
by that class which you could do


931
00:45:07,636 --> 00:45:10,266
by going through the source
file in Xcode and clicking


932
00:45:10,266 --> 00:45:11,296
on the beginning of all of them


933
00:45:11,296 --> 00:45:13,086
but that would quickly
get tedious.


934
00:45:13,456 --> 00:45:15,236
And by the way, you
don't want to stop


935
00:45:15,236 --> 00:45:16,476
on the parent or
subclass whatever.


936
00:45:16,806 --> 00:45:18,956
What would be better
would be to try to cons


937
00:45:18,956 --> 00:45:20,116
up a regular expression


938
00:45:20,116 --> 00:45:23,796
which matches all the
functions in a given class.


939
00:45:24,046 --> 00:45:26,756
So in Swift this is an
appropriate regular expression


940
00:45:27,066 --> 00:45:29,546
or in Objective C this is an
appropriate regular expression.


941
00:45:29,726 --> 00:45:32,406
So then you would have
breakpoints on all


942
00:45:32,406 --> 00:45:34,456
of those then you could run your
program and then you could go


943
00:45:34,456 --> 00:45:35,526
through and see what's going on.


944
00:45:35,526 --> 00:45:38,066
And remember because you can
disable individual locations,


945
00:45:38,336 --> 00:45:40,726
when you do this
kind of experiment,


946
00:45:40,846 --> 00:45:43,606
you find that you hit one of
them, you know what it does,


947
00:45:43,606 --> 00:45:45,456
you're uninterested in that
one so you just disable


948
00:45:45,456 --> 00:45:47,366
that location then
you keep going.


949
00:45:47,366 --> 00:45:49,666
The second one you figure out
disable so on and so forth.


950
00:45:50,006 --> 00:45:52,126
So that's kind of a nice
way to explore new code.


951
00:45:52,286 --> 00:45:54,556
An even more radical version


952
00:45:54,556 --> 00:45:56,306
of the same thing is somebody
is giving you a whole shared


953
00:45:56,306 --> 00:45:57,876
library that does some stuff.


954
00:45:57,936 --> 00:45:59,676
You want to just see
what stuff it does


955
00:45:59,676 --> 00:46:03,016
when it's running then set a
regular expression breakpoint,


956
00:46:03,016 --> 00:46:04,926
I'm using the short
- r form here


957
00:46:05,246 --> 00:46:07,876
and the regular expression
matches everything,


958
00:46:07,876 --> 00:46:10,216
that's what .star
does, and then limit it


959
00:46:10,216 --> 00:46:12,516
to the library you're
interested in.


960
00:46:12,516 --> 00:46:15,706
Combining this with breakpoint
commands can often be a really


961
00:46:15,706 --> 00:46:18,526
nice way just to sort of
get a quick and dirty trace


962
00:46:18,526 --> 00:46:21,786
of execution through this
library, you could backtrace


963
00:46:21,786 --> 00:46:24,376
and maybe print the
locals and then continue


964
00:46:24,376 --> 00:46:27,436
and you'll just run your
program and get a tape output


965
00:46:27,436 --> 00:46:29,686
of the execution
through that library.


966
00:46:30,316 --> 00:46:31,846
Of course it slows
down execution


967
00:46:31,846 --> 00:46:33,446
but you know whatever
sometimes you pay.


968
00:46:33,956 --> 00:46:37,626
And then the other trick
again is as you find ones


969
00:46:37,626 --> 00:46:39,336
that you don't care about,
you can disable them.


970
00:46:39,676 --> 00:46:41,636
So let me talk about
the other kind


971
00:46:41,826 --> 00:46:43,966
of pattern matching in source.


972
00:46:44,386 --> 00:46:47,946
So the point here is that
there are some constructs


973
00:46:47,946 --> 00:46:49,596
that are really obvious
when you're looking


974
00:46:49,596 --> 00:46:52,466
at your source text but
figuring out how to get to them


975
00:46:52,466 --> 00:46:55,166
in the generated code
is really not obvious.


976
00:46:55,406 --> 00:46:57,436
So an example of this is macros


977
00:46:57,696 --> 00:47:00,086
which generally just
get substituted as text


978
00:47:00,086 --> 00:47:02,996
into your program and then
sort of vanish, but you know


979
00:47:02,996 --> 00:47:04,516
where they're inserted
in your code


980
00:47:04,516 --> 00:47:06,176
because they're the things
with capital letters.


981
00:47:06,446 --> 00:47:09,356
So you want to do a search
maybe for all capital letters


982
00:47:09,356 --> 00:47:11,236
or for the particular
macros you care about.


983
00:47:11,536 --> 00:47:13,886
But you can even be
more creative than that


984
00:47:13,886 --> 00:47:16,426
so for instance I
want to know anywhere


985
00:47:16,426 --> 00:47:19,496
that a particular field
is gotten from a pointer


986
00:47:19,836 --> 00:47:22,406
which is something that in
source text I can see obviously


987
00:47:22,406 --> 00:47:23,956
because it's going
to look like that


988
00:47:24,246 --> 00:47:27,006
but in generated code
finding those places would be


989
00:47:27,006 --> 00:47:27,736
quite difficult.


990
00:47:27,736 --> 00:47:31,416
So that's another instance
where using the pattern matching


991
00:47:31,416 --> 00:47:34,276
in your source can allow
you to find constructs


992
00:47:34,276 --> 00:47:36,576
that you might not be
able to find otherwise.


993
00:47:36,926 --> 00:47:42,696
Then another use of this is to
sort of make topic groupings


994
00:47:42,806 --> 00:47:45,046
that you can set
breakpoints on just


995
00:47:45,206 --> 00:47:47,556
by inserting patterns
artificially


996
00:47:47,556 --> 00:47:50,816
into your source code like
as comments saying break here


997
00:47:50,816 --> 00:47:53,016
or break here when
you're interested


998
00:47:53,016 --> 00:47:55,596
in inspecting this
particular subsection


999
00:47:55,596 --> 00:47:57,226
of my program's functionality


1000
00:47:57,526 --> 00:48:00,126
and then using these source
regular expression breakpoints


1001
00:48:00,216 --> 00:48:01,066
to catch it.


1002
00:48:01,476 --> 00:48:05,416
So here's how the source
breakpoint matching


1003
00:48:05,416 --> 00:48:06,126
command works.


1004
00:48:06,406 --> 00:48:09,236
There's source regular
expression is the option,


1005
00:48:09,456 --> 00:48:12,136
the data you're providing for
this search is the pattern,


1006
00:48:12,366 --> 00:48:16,256
and then you can limit it to
one file, you can limit it


1007
00:48:16,256 --> 00:48:19,956
to multiple files by just
providing the -f option multiple


1008
00:48:19,956 --> 00:48:23,296
times and there's also a flag
to search all your source files.


1009
00:48:24,106 --> 00:48:27,716
So let me just give you an
example to whet your appetite.


1010
00:48:27,996 --> 00:48:30,966
Suppose I had like a complex
function like a state machine


1011
00:48:31,136 --> 00:48:33,346
which is computing stuff
and then it's running


1012
00:48:33,346 --> 00:48:34,616
from many different places


1013
00:48:34,616 --> 00:48:36,756
in some horrible huge case
statement or something


1014
00:48:36,756 --> 00:48:40,526
like that, and I'm interested
in finding out when it's going


1015
00:48:40,526 --> 00:48:43,356
to return null but I'd like
to know what was the case


1016
00:48:43,666 --> 00:48:47,586
in this particular run through
at which it returned null,


1017
00:48:47,816 --> 00:48:49,666
and that's a hard thing
to figure out to do


1018
00:48:49,666 --> 00:48:51,556
because you can stop
after the function returns


1019
00:48:51,556 --> 00:48:52,656
and check whether it's null.


1020
00:48:52,856 --> 00:48:55,936
You can go click on all the
places where it returns null


1021
00:48:55,936 --> 00:48:59,726
but you might miss one or you
can just look for the pattern.


1022
00:49:00,176 --> 00:49:02,546
There's one other
convenience that we offer you


1023
00:49:02,546 --> 00:49:05,136
in the source regular
expression breakpoint type


1024
00:49:05,136 --> 00:49:08,206
which is you can specify not
only a file but you can limit it


1025
00:49:08,206 --> 00:49:09,866
to a particular function so in


1026
00:49:09,866 --> 00:49:11,326
that case I'd do
something like this.


1027
00:49:11,546 --> 00:49:14,796
I'd break my pattern
would be return


1028
00:49:14,796 --> 00:49:17,556
and then I'm doing showing
that I know regular expressions


1029
00:49:17,556 --> 00:49:20,946
because I'm showing off, space
star is any number of spaces


1030
00:49:21,126 --> 00:49:24,246
and then my null pointer I limit
it to a function and I limit it


1031
00:49:24,246 --> 00:49:27,466
to a file I'm interested in and
then I can find out as I run


1032
00:49:27,466 --> 00:49:29,896
through exactly where
I've returned null


1033
00:49:29,896 --> 00:49:31,036
in this particular usage.


1034
00:49:32,286 --> 00:49:34,296
So it's worthwhile
talking about a couple


1035
00:49:34,296 --> 00:49:37,646
of extra breakpoint options that
you might not have heard about.


1036
00:49:37,846 --> 00:49:41,116
One of them is along
the lines of the where


1037
00:49:41,116 --> 00:49:44,906
or the filter kind that's
useful now that we have Swift


1038
00:49:44,906 --> 00:49:49,216
and Objective C together in
programs which is the ability


1039
00:49:49,216 --> 00:49:51,186
to specify a language
for a breakpoint.


1040
00:49:51,186 --> 00:49:54,176
So for instance, there are a
lot of count methods everywhere


1041
00:49:54,176 --> 00:49:55,796
in the world and if
you set a breakpoint


1042
00:49:55,796 --> 00:49:58,306
on the name count you're
going to set it on a bunch


1043
00:49:58,306 --> 00:50:00,546
of Swift code but you're also
going to set it on a bunch


1044
00:50:00,546 --> 00:50:02,356
of Objective C methods
and you don't care


1045
00:50:02,356 --> 00:50:05,136
about the Objective C methods,
you only want the Swift ones,


1046
00:50:05,476 --> 00:50:08,126
then you can just
specify the language Swift


1047
00:50:08,126 --> 00:50:09,826
and it won't set a
breakpoint on any


1048
00:50:09,826 --> 00:50:11,716
of the Objective C names
that happen to match.


1049
00:50:11,786 --> 00:50:15,426
So that's just a useful little
convenience and yeah, right.


1050
00:50:15,656 --> 00:50:19,516
And one other option that's
sometimes useful is being able


1051
00:50:19,626 --> 00:50:22,716
to narrow your search
to a particular thread.


1052
00:50:22,966 --> 00:50:25,836
So you've got some code that's
being called and a bunch


1053
00:50:25,836 --> 00:50:27,856
of different threads, it's like
a kernel or something like that


1054
00:50:27,996 --> 00:50:31,126
but you've starting working
on the execution in one thread


1055
00:50:31,126 --> 00:50:33,756
and you don't want your
breakpoints that you're using


1056
00:50:33,756 --> 00:50:35,526
for the investigation
to take you off


1057
00:50:35,526 --> 00:50:37,696
onto other threads,
it's fairly simple.


1058
00:50:37,946 --> 00:50:41,926
There's a thread ID option and
there's one that you can do


1059
00:50:41,926 --> 00:50:43,406
by thread name which you set


1060
00:50:43,406 --> 00:50:45,986
with this pthread
set name np call.


1061
00:50:45,986 --> 00:50:48,966
That one is convenient because
if you name a thread then


1062
00:50:48,966 --> 00:50:51,246
that persists over
many debugging sessions


1063
00:50:51,246 --> 00:50:53,616
where of course the thread ID
is going to change every time,


1064
00:50:54,036 --> 00:50:57,976
and you can even restrict it
to code that's being serviced


1065
00:50:57,976 --> 00:50:59,596
on a particular queue by name.


1066
00:51:01,076 --> 00:51:02,846
One other thing that
you might note is


1067
00:51:02,846 --> 00:51:06,116
that you can add all these
options to existing breakpoints


1068
00:51:06,286 --> 00:51:08,976
and particularly that's
useful if you've set file


1069
00:51:08,976 --> 00:51:11,726
and line breakpoint
in Xcode in the gutter


1070
00:51:11,726 --> 00:51:14,526
but then you decide you want to
like for instance limit that one


1071
00:51:14,526 --> 00:51:16,716
to a particular thread and
you can change all these


1072
00:51:16,716 --> 00:51:18,786
after the fact, the
command is break modify,


1073
00:51:19,096 --> 00:51:20,076
and the other useful thing


1074
00:51:20,076 --> 00:51:22,846
in this slide is showing
you how you specify them


1075
00:51:23,136 --> 00:51:26,606
because you can specify
either by breakpoint,


1076
00:51:26,996 --> 00:51:28,616
by breakpoint location number


1077
00:51:28,696 --> 00:51:31,316
and there's also a little
syntax to specify ranges.


1078
00:51:33,296 --> 00:51:35,106
That's that.


1079
00:51:35,316 --> 00:51:38,436
So now you've come up with
all these clever breakpoints


1080
00:51:38,636 --> 00:51:41,626
that you want but you run into
a little road block which is


1081
00:51:41,626 --> 00:51:42,926
that it turns out Xcode


1082
00:51:42,926 --> 00:51:45,066
at present only persists
breakpoints


1083
00:51:45,066 --> 00:51:48,686
that it knows you set and so
the ones that you've managed


1084
00:51:48,686 --> 00:51:51,206
to write in by hand
it won't know about.


1085
00:51:51,446 --> 00:51:53,016
So how do you make them persist?


1086
00:51:53,316 --> 00:51:56,556
The first way is what Enrico
told you about if you want it


1087
00:51:56,556 --> 00:51:58,786
to hold for all projects,
you just put it


1088
00:51:58,786 --> 00:52:01,046
in your LLDB init file
and then you're done.


1089
00:52:01,336 --> 00:52:03,506
But if you want to make
project specific ones,


1090
00:52:03,506 --> 00:52:05,326
here's a cute little
trick that you can use


1091
00:52:05,546 --> 00:52:08,656
to get the breakpoints
loaded every time you debug


1092
00:52:08,656 --> 00:52:09,866
that particular project.


1093
00:52:10,186 --> 00:52:13,216
What you do is make an
Xcode stored breakpoint,


1094
00:52:13,466 --> 00:52:15,406
preferably something that's
going to get hit early


1095
00:52:15,406 --> 00:52:16,966
on in your program execution,


1096
00:52:17,186 --> 00:52:18,466
and then you put
your breakpoints


1097
00:52:18,466 --> 00:52:19,706
as commands in that one.


1098
00:52:19,706 --> 00:52:23,326
So you know if you're a main
executable for instance,


1099
00:52:23,326 --> 00:52:25,116
main is a very convenient place


1100
00:52:25,116 --> 00:52:26,786
so you would make a
symbolic breakpoint


1101
00:52:27,156 --> 00:52:29,626
and then you would put main in


1102
00:52:29,836 --> 00:52:32,906
and then you would remember
the slide a while ago now


1103
00:52:32,906 --> 00:52:34,776
where I told you about our
little trouble with main,


1104
00:52:34,976 --> 00:52:37,086
so you would specify
the shared library,


1105
00:52:37,476 --> 00:52:39,466
then you would add an action


1106
00:52:39,466 --> 00:52:42,016
which is a debugger command
action and then don't type


1107
00:52:42,016 --> 00:52:44,466
in all of the breakpoints
in one in one in one here


1108
00:52:44,466 --> 00:52:45,906
because that's just
going to get tedious.


1109
00:52:46,156 --> 00:52:48,806
It's much easier to put
the commands in a file


1110
00:52:48,946 --> 00:52:51,276
and then use LLDB's
command source command


1111
00:52:51,276 --> 00:52:54,166
to load those commands in,
load those breakpoints in


1112
00:52:54,436 --> 00:52:55,236
and then finally


1113
00:52:55,236 --> 00:52:57,556
if you autocontinue then just
every time you run you will


1114
00:52:57,556 --> 00:53:00,396
automatically have all of
those breakpoints set for you.


1115
00:53:01,106 --> 00:53:05,416
So I want to show you one other
little convenience we've added


1116
00:53:05,826 --> 00:53:09,076
to overcome one particularly
annoying problem that you get


1117
00:53:09,386 --> 00:53:13,896
in modern languages which
is when you're trying


1118
00:53:13,896 --> 00:53:16,276
to step you're trying
to step into something


1119
00:53:16,496 --> 00:53:19,906
but the problem is that in
most modern languages most


1120
00:53:19,906 --> 00:53:23,146
of the variable access is
now done either as properties


1121
00:53:23,146 --> 00:53:25,956
or through accessor
functions or whatever so that


1122
00:53:26,166 --> 00:53:29,906
and they're generally that's not
the code you're trying to debug.


1123
00:53:30,286 --> 00:53:32,246
So you end up in a scenario


1124
00:53:32,246 --> 00:53:34,826
like this you know I'm
here I'm trying to get


1125
00:53:34,826 --> 00:53:35,916
into this function,
do something.


1126
00:53:35,916 --> 00:53:36,906
I want to step in there.


1127
00:53:37,106 --> 00:53:41,136
So I try that I step and I
don't end up there because one


1128
00:53:41,136 --> 00:53:43,826
of the arguments that I was
passing was an accessor function


1129
00:53:43,826 --> 00:53:44,956
so I ended up in the accessor.


1130
00:53:44,996 --> 00:53:47,356
I don't want to be there because
it's not very interesting


1131
00:53:47,576 --> 00:53:49,146
so what I'm going end
up doing is finishing


1132
00:53:49,146 --> 00:53:50,296
out and stepping back.


1133
00:53:50,436 --> 00:53:52,956
So is there any way that we can
make that slightly more easy?


1134
00:53:53,146 --> 00:53:55,816
And it turns out that we've
added something called targeted


1135
00:53:55,816 --> 00:53:59,136
stepping so the option
is the step in target


1136
00:53:59,136 --> 00:54:01,806
that you would say by
saying step and what I want


1137
00:54:01,806 --> 00:54:04,346
to do is I want you to step
but I only want you to stop


1138
00:54:04,346 --> 00:54:05,636
in this particular place,


1139
00:54:05,636 --> 00:54:07,276
that's what you're
expressing with this.


1140
00:54:07,676 --> 00:54:10,356
So let's try that in this
case and what we'll find is


1141
00:54:10,356 --> 00:54:12,246
that it almost but
doesn't quite work


1142
00:54:12,376 --> 00:54:13,946
and the reason it
doesn't quite work is


1143
00:54:13,946 --> 00:54:16,286
because though we didn't
end up in the accessor,


1144
00:54:16,436 --> 00:54:19,966
we ended up on the next source
line instead of in our function.


1145
00:54:19,966 --> 00:54:21,406
And that makes sense
when you think about it


1146
00:54:21,406 --> 00:54:24,156
because actually stepping is
source line by source line


1147
00:54:24,306 --> 00:54:25,976
and that was the multiline call.


1148
00:54:26,046 --> 00:54:29,786
So we've also added the
ability to specify the end range


1149
00:54:29,786 --> 00:54:31,186
of the stepping operation


1150
00:54:31,386 --> 00:54:33,056
by saying what the
end line number is


1151
00:54:33,216 --> 00:54:35,566
or even more conveniently
you can say just step


1152
00:54:35,566 --> 00:54:38,756
through this block and get me
in to do something I don't care.


1153
00:54:38,996 --> 00:54:40,596
And there's even
an alias for that


1154
00:54:40,596 --> 00:54:43,376
which is sif step in function.


1155
00:54:43,676 --> 00:54:46,406
So then what you would do
is you would be sitting here


1156
00:54:46,406 --> 00:54:49,256
and you would say step in
function and then you'd land


1157
00:54:49,256 --> 00:54:51,006
in the right place or if you
didn't I wouldn't have put it


1158
00:54:51,006 --> 00:54:51,526
on the slide.


1159
00:54:52,386 --> 00:54:54,616
So that I want to conclude
with a couple little bits


1160
00:54:54,616 --> 00:54:56,036
of troubleshooting information.


1161
00:54:56,346 --> 00:54:58,926
One piece of information
you often need


1162
00:54:58,926 --> 00:55:02,446
to know is what is actually
in my running program.


1163
00:55:02,636 --> 00:55:05,366
For instance maybe I built
the release and debug versions


1164
00:55:05,546 --> 00:55:07,716
and I want to know which
one I'm actually using


1165
00:55:07,976 --> 00:55:10,116
or somebody gave me a
library with a dSYM.


1166
00:55:10,116 --> 00:55:11,556
Did the dSYM get read in?


1167
00:55:11,876 --> 00:55:13,356
So the command that inquiries


1168
00:55:13,566 --> 00:55:15,956
about that information is
the image list command.


1169
00:55:15,956 --> 00:55:18,016
You can either give
it a module name


1170
00:55:18,016 --> 00:55:19,356
in which case it will
tell you information


1171
00:55:19,356 --> 00:55:21,636
about just one module
loaded into your program


1172
00:55:21,636 --> 00:55:26,656
or for amusement's sake you can
give no options you'll show all


1173
00:55:26,656 --> 00:55:28,256
of them which is
sometimes eye opening.


1174
00:55:28,536 --> 00:55:32,216
So here's an example just
to see how it's used.


1175
00:55:32,536 --> 00:55:37,466
I say image list example
and I see here is the path


1176
00:55:37,466 --> 00:55:39,096
to the binary so for
instance if I wanted


1177
00:55:39,096 --> 00:55:41,476
to check whether I was
using the debug build, yeah,


1178
00:55:41,476 --> 00:55:43,436
okay it does look like
I'm using the debug build


1179
00:55:43,706 --> 00:55:45,706
and if there is a
dSYM available,


1180
00:55:45,706 --> 00:55:47,636
it will always be
listed after the binary


1181
00:55:47,636 --> 00:55:49,686
so in this case I see
I did get my binary.


1182
00:55:50,066 --> 00:55:53,376
I want to tell you one thing
about Swift debug information.


1183
00:55:53,486 --> 00:55:56,306
I put on this slide the why
but I'm not actually going


1184
00:55:56,306 --> 00:55:57,966
to tell you the why because
we're running a little short


1185
00:55:57,966 --> 00:56:01,956
of time, but I'll tell you
the TLDR because I'm going


1186
00:56:01,956 --> 00:56:03,416
through too fast
for you to read.


1187
00:56:03,416 --> 00:56:06,986
The TLDR is that because of
the way Swift and LLDB work


1188
00:56:06,986 --> 00:56:09,956
with one another all the
Swift code that you have


1189
00:56:09,956 --> 00:56:13,236
that has debug information
has to have been built locally


1190
00:56:13,446 --> 00:56:16,726
so copying binaries from other
people doesn't currently work


1191
00:56:16,726 --> 00:56:17,426
and stuff like that.


1192
00:56:17,426 --> 00:56:18,386
You have to have made sure


1193
00:56:18,386 --> 00:56:21,626
that everything has been built
locally and with the compiler


1194
00:56:21,816 --> 00:56:23,426
that goes along with
the debugger


1195
00:56:23,426 --> 00:56:24,586
that you're currently using.


1196
00:56:25,436 --> 00:56:29,216
I want to say this is one
little convenience we've offered


1197
00:56:29,216 --> 00:56:31,896
and so Enrico's rule of
optimized code debugging


1198
00:56:31,896 --> 00:56:35,186
as we saw earlier is don't do
it if you don't have to and then


1199
00:56:35,336 --> 00:56:40,416
since most software developers
are rational actors you can


1200
00:56:40,416 --> 00:56:42,936
write a corollary to that
which is that most people


1201
00:56:42,936 --> 00:56:45,866
who debug optimized code
actually do it by accident.


1202
00:56:46,206 --> 00:56:48,576
So now LLDB will tell you


1203
00:56:48,736 --> 00:56:51,966
that a file was compiled
optimized when you stop in it.


1204
00:56:51,966 --> 00:56:54,436
It will only tell
you once per library


1205
00:56:54,606 --> 00:56:56,006
and you'll get a little
message like this.


1206
00:56:56,006 --> 00:56:58,346
And then you run quickly
to your build settings


1207
00:56:58,556 --> 00:57:00,826
and change them back.


1208
00:57:00,956 --> 00:57:03,266
One other new feature
that was added


1209
00:57:03,266 --> 00:57:05,836
to clang a while ago was
this notion of modules.


1210
00:57:06,076 --> 00:57:09,536
So modules are a way to
allow the compiler to look


1211
00:57:09,536 --> 00:57:11,946
at all the headers that
are the header environment


1212
00:57:11,946 --> 00:57:16,766
for your program, compile
them, parse them up once


1213
00:57:17,036 --> 00:57:19,646
and then reuse that
for all the compiles.


1214
00:57:19,906 --> 00:57:22,426
So then we thought well why
can't we also do the same thing


1215
00:57:22,426 --> 00:57:24,116
for the debug information?


1216
00:57:24,116 --> 00:57:28,366
Why don't we allow that parsed
form of the type information


1217
00:57:28,366 --> 00:57:34,136
to be also done once and then
shared amongst all the .o files


1218
00:57:34,136 --> 00:57:35,386
that you have debug information?


1219
00:57:35,386 --> 00:57:38,086
So that's called clang
module debug feature.


1220
00:57:38,086 --> 00:57:40,786
We can also use PCH
files by the way.


1221
00:57:40,966 --> 00:57:44,756
The setting in Xcode is
clang module debugging


1222
00:57:44,756 --> 00:57:46,906
and here's the flag for
some reason I put that in.


1223
00:57:47,176 --> 00:57:51,086
This is great because again like
with the compiler this speeds


1224
00:57:51,086 --> 00:57:53,816
up the generation of the debug
information, it will speed


1225
00:57:53,816 --> 00:57:58,266
up your compile times but it has
one caveat, and that caveat is


1226
00:57:58,266 --> 00:58:00,326
that or actually one major one.


1227
00:58:00,326 --> 00:58:03,696
So that caveat is that now
your debugging is depending


1228
00:58:03,696 --> 00:58:06,226
on your .o files but also
on something that's sitting


1229
00:58:06,226 --> 00:58:07,706
in some cache somewhere.


1230
00:58:08,096 --> 00:58:11,526
So normally that's not a
problem everything is in place


1231
00:58:11,686 --> 00:58:15,296
but when you go to ship
your library or application


1232
00:58:15,296 --> 00:58:17,536
to somebody else, how
is that going to work?


1233
00:58:17,536 --> 00:58:19,356
Well, if it's an application


1234
00:58:19,356 --> 00:58:23,426
or a framework then you just
run dsymutil like you already do


1235
00:58:23,426 --> 00:58:24,436
and it does the right job,


1236
00:58:24,436 --> 00:58:26,506
it gathers everything
together and that all works.


1237
00:58:26,806 --> 00:58:30,326
But remember that dsymutil
only works on linked products,


1238
00:58:30,326 --> 00:58:32,086
it doesn't work on .o files.


1239
00:58:32,306 --> 00:58:35,836
So if you are shipping static
archives with debug information,


1240
00:58:36,076 --> 00:58:38,676
then you must turn off
this G module's feature


1241
00:58:38,676 --> 00:58:42,026
or you will ship broken debug
information to your clients.


1242
00:58:42,076 --> 00:58:44,616
And also by the way, if you're
running out of disk space


1243
00:58:44,616 --> 00:58:47,076
and you delete your module
cache, now you're not going


1244
00:58:47,076 --> 00:58:48,186
to be able to debug anymore.


1245
00:58:48,786 --> 00:58:51,356
So that's the only down
side to that feature.


1246
00:58:52,056 --> 00:58:55,406
So with that let me tell
you what you've seen.


1247
00:58:56,006 --> 00:58:59,196
We hope that you see that LLDB
is an extremely customizable


1248
00:58:59,196 --> 00:59:03,136
debugger providing you many
ways to look at your data


1249
00:59:03,136 --> 00:59:06,246
that expressions actually
give you much more power


1250
00:59:06,246 --> 00:59:08,966
for investigation and I
thought Sean's example was great


1251
00:59:08,966 --> 00:59:11,396
of how you actually
live go through


1252
00:59:11,396 --> 00:59:14,236
and find what you're interested
in in a complex array,


1253
00:59:14,656 --> 00:59:17,416
that we have more
breakpoint types than you know


1254
00:59:17,416 --> 00:59:21,506
of in your Xcode and that
you can actually get yourself


1255
00:59:21,506 --> 00:59:23,346
into super deep trouble
with more


1256
00:59:23,346 --> 00:59:24,586
than source level debugging,


1257
00:59:24,586 --> 00:59:27,716
and in general we hope we
provide you a rich set of tools


1258
00:59:27,716 --> 00:59:28,786
for exploring your code.


1259
00:59:29,086 --> 00:59:32,036
And here are a couple
of the previous sessions


1260
00:59:32,036 --> 00:59:33,426
that might have interesting
information.


1261
00:59:33,586 --> 00:59:36,246
There were a couple of sessions
earlier on which you didn't see


1262
00:59:36,476 --> 00:59:39,326
or did see but anyway they
are available on slides.


1263
00:59:39,416 --> 00:59:40,786
And with that thank
you and I hope


1264
00:59:40,786 --> 00:59:42,976
that you enjoy the little tiny
bit that remains of your WWDC.


1265
00:59:43,016 --> 00:59:45,000
[ Applause ]

