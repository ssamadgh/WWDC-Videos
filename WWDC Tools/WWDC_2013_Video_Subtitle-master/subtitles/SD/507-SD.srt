1
00:00:00,506 --> 00:00:09,896
[Silence]


2
00:00:10,396 --> 00:00:11,406
>> [Applause] Welcome, hello.


3
00:00:15,056 --> 00:00:16,226
So I'm Chris Niederauer.


4
00:00:16,346 --> 00:00:20,826
I work on the GPU Software
Team and I'm here to talk today


5
00:00:20,826 --> 00:00:23,396
about what's new
in OpenGL for OS X.


6
00:00:25,816 --> 00:00:28,866
So during this talk I'm
going to go into some


7
00:00:28,866 --> 00:00:30,196
of the feature support update.


8
00:00:30,196 --> 00:00:32,366
What's new in OS X
Mavericks in particular.


9
00:00:33,226 --> 00:00:36,056
And then after that I'm
going to go into a few


10
00:00:36,056 --> 00:00:38,926
of the key features that we
think you're probably going


11
00:00:38,926 --> 00:00:40,686
to want to be using
in your applications.


12
00:00:41,416 --> 00:00:44,686
After that we're going to
talk about using Compute


13
00:00:44,686 --> 00:00:46,466
with OpenGL using OpenCL.


14
00:00:47,216 --> 00:00:50,756
And then finally towards the
end I'm going to do a quick run


15
00:00:50,756 --> 00:00:52,586
through -- trying to
get your applications


16
00:00:53,166 --> 00:00:55,826
into OpenGL Core Profile so
that you can take advantage


17
00:00:55,826 --> 00:00:58,246
of all these new features.


18
00:00:59,676 --> 00:01:02,356
So let's start with
the features.


19
00:01:03,446 --> 00:01:08,086
In OpenGL as of Lion we've
had support for Core Profile


20
00:01:08,446 --> 00:01:11,576
and this has a bunch of features
that are pretty much guaranteed


21
00:01:11,576 --> 00:01:14,756
if you ask for [inaudible] Core
Profile; frameBuffer Objects,


22
00:01:14,756 --> 00:01:16,586
vertex array objects, the usual.


23
00:01:17,016 --> 00:01:22,066
New in Mavericks; we've got a
whole bunch of new extensions


24
00:01:22,066 --> 00:01:26,846
like texture swizzle, sampler
objects, texture storage


25
00:01:27,276 --> 00:01:31,276
and then additionally on
modern GPUs we have support


26
00:01:31,276 --> 00:01:36,256
for tessellation shaders and all
the other OpenGL 4.1 features


27
00:01:36,306 --> 00:01:37,516
plus a little bit more.


28
00:01:38,436 --> 00:01:40,996
So that's an update
on where we are.


29
00:01:40,996 --> 00:01:44,906
And so these are some of the
features I'm going to go into.


30
00:01:45,416 --> 00:01:47,266
Explain how you can
get your applications


31
00:01:47,326 --> 00:01:50,026
to take advantage
of these features.


32
00:01:50,026 --> 00:01:56,376
So let's start with probably
the big new feature on --


33
00:01:56,456 --> 00:01:58,346
in Mavericks; tessellation
shaders.


34
00:02:00,376 --> 00:02:05,046
So what tessellation shaders do
is they allow you to use a GPU


35
00:02:05,046 --> 00:02:11,226
in order to generate geometry
to a specific how course,


36
00:02:11,226 --> 00:02:13,906
how fine you want your geometry
to be and you generate it


37
00:02:13,906 --> 00:02:17,036
on the fly where you need
it to be, where you want


38
00:02:17,036 --> 00:02:18,086
to spend your Vertices.


39
00:02:18,846 --> 00:02:20,066
Let's see.


40
00:02:20,216 --> 00:02:24,256
Define using shaders
and the benefits.


41
00:02:24,256 --> 00:02:27,876
It allows you to dynamically
increase your polygon density.


42
00:02:28,276 --> 00:02:30,196
So you're able to decrease
your vertex bandwidth


43
00:02:30,196 --> 00:02:32,056
because you're only
uploading a course mesh.


44
00:02:32,566 --> 00:02:35,946
And then you get to decide
how to refine that mesh.


45
00:02:36,726 --> 00:02:39,096
And it's used often for
displacement mapping,


46
00:02:39,096 --> 00:02:42,556
terrain rendering,
high-order surfaces like NERPS.


47
00:02:43,266 --> 00:02:45,706
And it's available
on the modern GPUs,


48
00:02:45,736 --> 00:02:47,036
so all the hardware
we ship today.


49
00:02:47,036 --> 00:02:51,386
If you -- so you'll
need to make sure


50
00:02:51,386 --> 00:02:54,176
to check the extension
stream using glGetStringi


51
00:02:54,976 --> 00:02:57,726
for ARB underscore
tessellation underscore shader.


52
00:02:57,996 --> 00:03:00,746
So we have here an
application that's been --


53
00:03:00,826 --> 00:03:03,666
is out on the Mac which
is called Unigine Heaven


54
00:03:04,406 --> 00:03:08,986
and actually it's been updated
to be able to take advantage


55
00:03:08,986 --> 00:03:10,086
of tessellation shaders.


56
00:03:10,796 --> 00:03:12,996
So we sort of before and after.


57
00:03:13,696 --> 00:03:16,456
We have the stairs are
just a flat polygon there


58
00:03:16,456 --> 00:03:18,386
and then the dragon's neck.


59
00:03:19,086 --> 00:03:21,136
There's little points where
there should be spikes


60
00:03:21,196 --> 00:03:22,346
but there's no spikes there.


61
00:03:23,056 --> 00:03:27,666
With tessellation shaders you
see how it generates geometry,


62
00:03:27,666 --> 00:03:30,796
it uses displacement map, it
creates spikes on the dragon


63
00:03:30,796 --> 00:03:34,276
and the stairs suddenly
become actually stair shaped.


64
00:03:35,046 --> 00:03:39,646
So to get a little bit into --


65
00:03:39,646 --> 00:03:42,216
I'm going to describe how
tessellation shaders work.


66
00:03:42,646 --> 00:03:44,796
So I also want to give
this example screenshot


67
00:03:45,286 --> 00:03:49,106
where you can see that the
application is choosing


68
00:03:49,106 --> 00:03:52,516
to dynamically tessellate
this geometry based


69
00:03:52,516 --> 00:03:54,026
on the distance to the camera.


70
00:03:54,476 --> 00:03:56,346
So you're using the
vertex bandwidth only


71
00:03:56,346 --> 00:03:57,506
where you need to, you know,


72
00:03:57,506 --> 00:03:59,546
only where you think
this thing needs it.


73
00:03:59,546 --> 00:04:02,236
So closer objects you'll
probably tessellate a lot more


74
00:04:02,236 --> 00:04:06,416
than objects in the distance.


75
00:04:06,806 --> 00:04:11,476
So we start with a new
type called a patch.


76
00:04:11,916 --> 00:04:13,346
And we set up our patches --


77
00:04:13,346 --> 00:04:15,926
we say how many vertices there
are going to be in each patch.


78
00:04:16,286 --> 00:04:19,666
So in this case with a triangle
patch we have 3 vertices


79
00:04:20,586 --> 00:04:23,206
and then when we draw
-- we call DrawArrays.


80
00:04:23,736 --> 00:04:27,586
So in the shaders there's
two parts to the shader.


81
00:04:27,926 --> 00:04:30,266
The first part of the
shader we're going


82
00:04:30,316 --> 00:04:32,816
to control how tessellated
we want it to be.


83
00:04:33,206 --> 00:04:37,646
So first in our control
shader we're going


84
00:04:37,646 --> 00:04:42,106
to be setting the outer levels
and we get to pick per side


85
00:04:42,166 --> 00:04:45,196
of this triangle how
tessellated we want it to be.


86
00:04:45,526 --> 00:04:46,596
And so we see in the --


87
00:04:46,596 --> 00:04:49,366
on the left side of the triangle
we did a little bit more


88
00:04:49,366 --> 00:04:51,966
tessellation there than we did
on the bottom and the right.


89
00:04:52,736 --> 00:04:56,536
Additionally you get to control
the inner levels tessellation.


90
00:04:57,666 --> 00:04:59,466
So we're adding some
geometry there.


91
00:04:59,826 --> 00:05:06,726
And then once we have these --
this data output it gets output


92
00:05:06,726 --> 00:05:12,436
to an evaluation shader
and that shader gets a --


93
00:05:12,436 --> 00:05:14,996
the control points that you
originally got and we evaluate


94
00:05:14,996 --> 00:05:16,556
where those positions should be.


95
00:05:16,816 --> 00:05:19,536
So we have test coordinates
and in this case


96
00:05:19,536 --> 00:05:24,996
because we had a triangle we
have three different TessCoords


97
00:05:24,996 --> 00:05:27,986
and you can see how it's
very centric and each


98
00:05:27,986 --> 00:05:32,326
of those is weighted towards
the original control points.


99
00:05:33,406 --> 00:05:36,756
And so using this is our
evaluation shader we can now


100
00:05:37,006 --> 00:05:39,456
figure out where those
points should be and push it


101
00:05:39,456 --> 00:05:42,636
out with displacement --
with a displacement map


102
00:05:42,636 --> 00:05:44,206
or do whatever you
want at that point.


103
00:05:44,766 --> 00:05:50,346
So the OpenGL 4 Pipeline;
you're probably aware


104
00:05:50,346 --> 00:05:52,416
of what it looks like before.


105
00:05:52,416 --> 00:05:55,666
We have vertex shaders on
the left, fragment shaders


106
00:05:55,666 --> 00:05:57,866
on the right and
then tessellation


107
00:05:57,866 --> 00:05:59,816
and geometry shaders
are both optional.


108
00:06:00,096 --> 00:06:02,186
So tessellation fits
right in the middle there


109
00:06:02,546 --> 00:06:07,656
and it's actually made out
of two different shaders


110
00:06:07,816 --> 00:06:10,006
that are -- that I will go into.


111
00:06:10,076 --> 00:06:12,466
So as I was saying
there's a control shader


112
00:06:12,466 --> 00:06:13,926
and an evaluation
shader so you get


113
00:06:13,926 --> 00:06:17,736
to control how tessellated it is
and then you evaluate where each


114
00:06:17,776 --> 00:06:19,906
of those vertices should be put.


115
00:06:20,646 --> 00:06:22,936
So the control shader.


116
00:06:24,026 --> 00:06:29,566
It takes as inputs the
control points from the patches


117
00:06:30,216 --> 00:06:34,826
and then basically the
array of control points


118
00:06:34,906 --> 00:06:37,896
and the original patches.


119
00:06:38,076 --> 00:06:43,066
And the outputs is setting how
tessellated we should tessellate


120
00:06:43,066 --> 00:06:47,796
each of the edges and then we
also have inner tessellation


121
00:06:47,796 --> 00:06:48,956
levels, as well.


122
00:06:49,836 --> 00:06:52,806
And a tip for when
you do have patches


123
00:06:52,806 --> 00:06:53,876
that are touching each other.


124
00:06:54,136 --> 00:06:56,986
You want to make sure that
you have the same amount


125
00:06:56,986 --> 00:06:59,896
of tessellation on
those touching edges.


126
00:06:59,896 --> 00:07:05,136
So let's get onto looking
at an actual control shader


127
00:07:05,926 --> 00:07:07,586
with this triangle example.


128
00:07:08,036 --> 00:07:11,576
We have -- we set up the
layout with the vertices saying


129
00:07:11,576 --> 00:07:14,696
that there's three
control points per patch,


130
00:07:15,296 --> 00:07:18,046
and we're going to have
our input vertex position


131
00:07:18,686 --> 00:07:21,076
from the original patch
points and we're going


132
00:07:21,076 --> 00:07:22,596
to output control positions.


133
00:07:23,726 --> 00:07:26,656
So first for every
input we're going


134
00:07:26,656 --> 00:07:29,746
to copy the vertex position
to the control position.


135
00:07:30,386 --> 00:07:34,396
And then additionally once
per patch this InvocationID --


136
00:07:35,126 --> 00:07:39,476
once per patch we're checking
for only doing this once.


137
00:07:39,966 --> 00:07:43,016
We're going to calculate what
those tessellation outer levels


138
00:07:43,016 --> 00:07:43,486
should be.


139
00:07:43,486 --> 00:07:44,506
What the TessCoords --


140
00:07:45,086 --> 00:07:47,266
and it will generate
TessCoords from there.


141
00:07:48,016 --> 00:07:51,516
And then the evaluation shader.


142
00:07:52,706 --> 00:07:56,156
That takes and evaluates
where the output


143
00:07:56,276 --> 00:07:59,086
from the control shader
should be within --


144
00:07:59,306 --> 00:08:02,786
to pass on to the
geometry or fragment stage.


145
00:08:03,576 --> 00:08:05,316
So it takes the original patch


146
00:08:05,626 --> 00:08:07,946
and the tessellation coordinates
sort of waning towards each


147
00:08:08,006 --> 00:08:10,596
of those original
patch coordinates.


148
00:08:10,726 --> 00:08:15,006
And then it outputs; your
position, your TexCoordinates


149
00:08:15,216 --> 00:08:17,586
and any other attributes
that you may have.


150
00:08:18,756 --> 00:08:23,596
So here is an example with a
triangle evaluation shader.


151
00:08:24,106 --> 00:08:29,606
We're specifying how
the -- oops, let's see.


152
00:08:30,596 --> 00:08:34,376
We've got the controls as input


153
00:08:34,376 --> 00:08:36,716
and we've also got a model
view protection matrix.


154
00:08:37,166 --> 00:08:39,895
And basically we're
treating the TessCoords --


155
00:08:39,895 --> 00:08:41,246
we have three TessCoord inputs


156
00:08:41,546 --> 00:08:43,416
which are barycentric
weights towards each


157
00:08:43,416 --> 00:08:44,886
of those original
control points.


158
00:08:45,246 --> 00:08:46,446
And so we're multiplying --


159
00:08:46,446 --> 00:08:51,346
doing a barycentric multiply
here to get the output


160
00:08:51,346 --> 00:08:52,426
of where those should be.


161
00:08:52,426 --> 00:08:56,196
So doing just this simple
math here gets us the evenly


162
00:08:56,196 --> 00:08:59,286
distributed points as we
specified in our control shader.


163
00:09:00,116 --> 00:09:02,666
And then after we've
done that we can --


164
00:09:02,666 --> 00:09:05,936
here was have a model view
projection matrix multiplying


165
00:09:05,936 --> 00:09:09,186
by our position that
we calculated passed


166
00:09:09,406 --> 00:09:12,456
into a custom function which
is doing our displacement.


167
00:09:13,046 --> 00:09:16,826
So we started with our
triangle patch just three


168
00:09:16,826 --> 00:09:17,606
points originally.


169
00:09:18,396 --> 00:09:19,976
We controlled how
tessellated it was,


170
00:09:20,056 --> 00:09:23,956
and then we evaluated exactly
where those positions should be


171
00:09:24,326 --> 00:09:26,696
to pass on to the
fragment shader.


172
00:09:27,896 --> 00:09:31,886
The quad -- just as a further
example, with the quad --


173
00:09:32,476 --> 00:09:33,806
the control shader
is very similar


174
00:09:33,806 --> 00:09:35,256
to what the triangle except


175
00:09:35,256 --> 00:09:37,676
for this time we're
specifying the vertices as four.


176
00:09:37,676 --> 00:09:40,876
We also set patch
parameter I for the number


177
00:09:40,876 --> 00:09:42,236
of control points to be four.


178
00:09:43,036 --> 00:09:44,926
And then similarly we're passing


179
00:09:44,926 --> 00:09:47,276
through the original
vertex position


180
00:09:47,276 --> 00:09:48,666
for the new control positions


181
00:09:49,726 --> 00:09:53,676
and then calculating
our tessellation levels.


182
00:09:53,786 --> 00:09:57,596
And in this case we have more
inner levels and outer levels


183
00:09:57,596 --> 00:10:00,336
to calculate because we
have four sides to the quad


184
00:10:00,746 --> 00:10:04,396
and additionally for the inner
levels we're controlling how


185
00:10:04,396 --> 00:10:06,666
split should it be
horizontally and vertically.


186
00:10:06,806 --> 00:10:12,216
Then in the evaluation shader
taking the control points


187
00:10:12,216 --> 00:10:13,796
in again, there's four
of them this time,


188
00:10:14,446 --> 00:10:17,536
and because we have a
quad we're actually able


189
00:10:17,536 --> 00:10:19,016
to treat those barycentric
weights


190
00:10:19,016 --> 00:10:22,796
as just UV coordinates
basically within our quad.


191
00:10:23,496 --> 00:10:25,976
So we just -- we're just doing
a simple mix here to figure


192
00:10:25,976 --> 00:10:28,566
out what those positions should
be for each of the points.


193
00:10:28,866 --> 00:10:32,646
And then again we pass
that calculated position


194
00:10:32,876 --> 00:10:38,686
into the custom displacement
map to get our position out.


195
00:10:39,276 --> 00:10:43,766
So with our quad we started
with just the four points.


196
00:10:44,286 --> 00:10:48,106
We tessellated it and
then evaluated where each


197
00:10:48,106 --> 00:10:51,176
of those places should be.


198
00:10:51,346 --> 00:10:55,306
So in summary tessellation
shader allows you to add detail


199
00:10:55,306 --> 00:10:58,596
where you need it in your
scene and you can start


200
00:10:58,596 --> 00:11:00,606
with triangles, quads,
arbitrary geometry.


201
00:11:00,606 --> 00:11:02,016
Even like isolines.


202
00:11:02,596 --> 00:11:05,726
And generates this
data on the GPU instead


203
00:11:05,726 --> 00:11:06,846
of you having to submit it.


204
00:11:06,846 --> 00:11:09,586
So you have a low
resolution model potentially


205
00:11:09,586 --> 00:11:12,216
that you are able
to only tessellate


206
00:11:12,256 --> 00:11:14,176
as the model gets
closer to the camera,


207
00:11:14,886 --> 00:11:18,716
or just too simply add
displacement or extra geometry


208
00:11:19,026 --> 00:11:22,026
to make a character
realistic in your scenes.


209
00:11:22,386 --> 00:11:26,296
And so again it's available on
modern hardware so you'll need


210
00:11:26,296 --> 00:11:29,066
to check for the existence
of tessellation shader


211
00:11:29,636 --> 00:11:34,066
with GetStringi, and be sure
to match your outer patches


212
00:11:34,066 --> 00:11:36,356
because otherwise
you may have cracks


213
00:11:36,356 --> 00:11:41,716
in between your touching
patches.


214
00:11:41,886 --> 00:11:45,146
So also another feature I
want to go over is instancing.


215
00:11:46,376 --> 00:11:52,826
And instancing is allowing
you to draw many instances


216
00:11:53,146 --> 00:11:56,276
of an object with only
a single draw call.


217
00:11:56,806 --> 00:11:59,246
And it's a big performance boost


218
00:11:59,246 --> 00:12:02,196
because each draw call does
take a little bit of overhead


219
00:12:02,716 --> 00:12:04,346
in order to get that to the GPU.


220
00:12:04,346 --> 00:12:06,616
So instead we're just
passing it all down at once


221
00:12:06,616 --> 00:12:13,076
and allowing the GPU to do that
work as a single draw call.


222
00:12:13,706 --> 00:12:17,226
And so each of these
instances can have their own


223
00:12:17,226 --> 00:12:18,436
unique parameters.


224
00:12:19,186 --> 00:12:23,736
So the offset of a one
instance from another, colors,


225
00:12:24,236 --> 00:12:28,186
skeletal attributes and
you define all these


226
00:12:28,186 --> 00:12:29,156
in external buffers.


227
00:12:30,226 --> 00:12:32,146
And this is actually
-- when you ask


228
00:12:32,146 --> 00:12:35,376
for a Core Profile
you're guaranteed on OS X


229
00:12:35,376 --> 00:12:38,816
that you have support
for this extension.


230
00:12:39,426 --> 00:12:42,206
And there's two forms
of instancing.


231
00:12:43,556 --> 00:12:46,696
There's instanced arrays
using ARB underscore instanced


232
00:12:46,696 --> 00:12:48,256
underscore arrays where
you get to have a divisor


233
00:12:48,256 --> 00:12:51,586
that says how often your
attributes should be submitted


234
00:12:51,586 --> 00:12:52,186
per vertex.


235
00:12:52,186 --> 00:12:55,426
So as opposed to having
-- per instance, sorry.


236
00:12:55,936 --> 00:12:58,216
So if you wanted to
submit an attribute


237
00:12:58,546 --> 00:13:01,296
for every one instance you
would pass a vertex [inaudible]


238
00:13:01,296 --> 00:13:02,346
divisor of one.


239
00:13:02,506 --> 00:13:06,896
If you wanted to have a
different attribute every two


240
00:13:06,896 --> 00:13:10,146
instances, two and so forth.


241
00:13:10,146 --> 00:13:15,036
Also draw instanced provides
a variable shader instance ID.


242
00:13:15,256 --> 00:13:18,096
So in your draw call from
your vertex or fragment --


243
00:13:18,096 --> 00:13:22,256
from your vertex shader you
can decide what you can see,


244
00:13:22,256 --> 00:13:23,656
which instance ID you are in.


245
00:13:23,716 --> 00:13:27,646
So you can tell -- do
an offset into a buffer


246
00:13:27,646 --> 00:13:29,566
for instance based
in an instance ID.


247
00:13:30,096 --> 00:13:32,496
And I'll go into a little bit --


248
00:13:32,496 --> 00:13:34,976
some examples of doing
that in a short bit.


249
00:13:36,066 --> 00:13:38,946
But I'm not actually going to go
into this too deeply right now


250
00:13:38,946 --> 00:13:42,426
because we actually
announced support for both


251
00:13:42,426 --> 00:13:44,546
of these features in iOS 7.


252
00:13:45,146 --> 00:13:48,556
And Dan my colleague
gave a talk this morning;


253
00:13:49,236 --> 00:13:53,146
Advanced is OpenGL ES where he
went into depth in instancing.


254
00:13:56,176 --> 00:13:58,606
So that was instancing.


255
00:13:59,116 --> 00:14:01,556
Let's go on to how
we pass up some data


256
00:14:01,556 --> 00:14:04,006
like uniform buffer
objects is one way


257
00:14:04,006 --> 00:14:06,386
to get some data
up to the shaders.


258
00:14:07,296 --> 00:14:09,506
And basically it's
a buffer object


259
00:14:09,506 --> 00:14:10,806
to store your uniform data.


260
00:14:11,106 --> 00:14:13,836
It's faster than
using glUniform.


261
00:14:14,696 --> 00:14:17,736
You can share a single uniform
buffer object among different


262
00:14:17,736 --> 00:14:21,286
GLSL shaders and you can
quickly switch between sets.


263
00:14:21,286 --> 00:14:24,946
If you have some prebaked sets
you can just choose on the fly


264
00:14:24,946 --> 00:14:26,066
which one you're using.


265
00:14:27,066 --> 00:14:30,176
And additionally because
it's a buffer object


266
00:14:30,396 --> 00:14:33,866
as all buffer objects you can
generate your data on the GPU


267
00:14:34,376 --> 00:14:39,756
and use the output from that
in your UBO, in the shader


268
00:14:39,756 --> 00:14:40,996
without having to
do a read back.


269
00:14:42,556 --> 00:14:46,256
And it's used for skinning
character animation, instancing,


270
00:14:46,256 --> 00:14:48,656
pretty much it's whatever
you want to use it for.


271
00:14:49,146 --> 00:14:52,836
So we have a shader
example here.


272
00:14:53,296 --> 00:14:59,196
And what a UBO is, is it's
basically a uniform buffer


273
00:14:59,196 --> 00:15:05,006
object is a CSTRUCK like layout
defined interface where we're --


274
00:15:05,006 --> 00:15:07,926
we have here of the
layout one standard 140


275
00:15:07,966 --> 00:15:12,886
which is the defining --
which defines how our vectors


276
00:15:12,886 --> 00:15:15,876
and variables are packed.


277
00:15:15,876 --> 00:15:18,366
And we've called
this uniform MyUBO.


278
00:15:18,366 --> 00:15:24,166
And so this MyUBO which we named
MyBlock underneath we're able


279
00:15:24,446 --> 00:15:27,916
to access that from
our shader similar


280
00:15:27,916 --> 00:15:30,026
to how the CSTRUCK would work.


281
00:15:31,356 --> 00:15:32,526
Pretty straight forward.


282
00:15:33,876 --> 00:15:35,026
And for setting that up


283
00:15:35,026 --> 00:15:38,896
in the API we would have
just created a buffer object


284
00:15:38,896 --> 00:15:42,526
of type uniform buffer,
set up the size of that


285
00:15:43,016 --> 00:15:45,126
and then we have to
get the location.


286
00:15:45,126 --> 00:15:47,926
Instead of the get uniform
location we're getting uniform


287
00:15:47,926 --> 00:15:51,866
block index for this UBO
structure and of type MyUBO.


288
00:15:51,966 --> 00:15:55,066
And then we just bind that
to one of our binding indexes


289
00:15:55,066 --> 00:16:00,296
that we have for making -- for
knowing how to provide that data


290
00:16:00,606 --> 00:16:04,776
to the proper UBO in the shader.


291
00:16:05,016 --> 00:16:10,996
So in summary you can upload all
of your uniform values at once.


292
00:16:11,096 --> 00:16:14,266
The -- however you want to make
sure that you're making sure


293
00:16:14,636 --> 00:16:20,956
that you're not modifying
your UBOs every single time.


294
00:16:20,956 --> 00:16:24,096
So if you have for
instance some variables


295
00:16:24,096 --> 00:16:26,406
that you're updating
a lot more often


296
00:16:26,406 --> 00:16:29,846
than other variables you should
split those into two UBOs.


297
00:16:29,846 --> 00:16:31,396
So one of your UBOs
may be static,


298
00:16:31,836 --> 00:16:33,816
and another may be
updated once a frame.


299
00:16:34,466 --> 00:16:38,536
And then additionally
if you are trying


300
00:16:38,536 --> 00:16:41,246
to modify the data
even more often


301
00:16:41,246 --> 00:16:43,926
than that you could
orphan your buffer objects


302
00:16:43,926 --> 00:16:45,556
by calling buffer data
with a null pointer,


303
00:16:46,576 --> 00:16:47,896
or you could just double buffer,


304
00:16:47,896 --> 00:16:50,826
or triple buffer etcetera your
UBOs to ensure that you're able


305
00:16:50,826 --> 00:16:52,426
to pass data to the GPU


306
00:16:52,706 --> 00:16:55,516
and still modify something
one the CPU to pass


307
00:16:55,516 --> 00:16:58,426
that for the next call
that the GPU will execute.


308
00:16:59,646 --> 00:17:03,896
And one key point I want to
make note of is that each


309
00:17:03,896 --> 00:17:08,806
of the UBOs are limited
to a size of about 64KB.


310
00:17:10,925 --> 00:17:14,486
So as an alternative to
UBOs there's also texture


311
00:17:14,486 --> 00:17:15,256
buffer objects.


312
00:17:16,336 --> 00:17:20,406
And texture buffer objects is
a buffer object that allows you


313
00:17:20,406 --> 00:17:24,336
to store a 1D array
of data as texels.


314
00:17:25,296 --> 00:17:29,266
And again like all buffer
objects it gives you


315
00:17:29,706 --> 00:17:36,536
to GPU generated data and beyond
UBOs it also gives you access


316
00:17:36,656 --> 00:17:38,476
to a large amount of
data within a shader.


317
00:17:38,986 --> 00:17:40,616
So you can have a
very large UBO.


318
00:17:41,516 --> 00:17:43,836
And additionally it uses --


319
00:17:43,836 --> 00:17:46,136
it takes advantage of
the GPUs texture cache.


320
00:17:47,066 --> 00:17:51,676
So just like TBOs -- just
like UBOs, TBOs are also used


321
00:17:51,676 --> 00:17:54,816
for skinning, character
animation, instancing,


322
00:17:55,436 --> 00:17:57,696
whatever you want to be
using it with really.


323
00:17:58,806 --> 00:18:01,396
And here's an example
shader that's using TBO.


324
00:18:01,506 --> 00:18:04,386
So we basically have
a new sampler type.


325
00:18:04,786 --> 00:18:06,056
Here we have samplerBuffer.


326
00:18:06,486 --> 00:18:09,166
There's also like
isampleBuffer, usampleBuffer.


327
00:18:09,856 --> 00:18:13,086
And we're naming our texture
buffer object reference myTBO.


328
00:18:14,086 --> 00:18:17,036
And it's as simple as just
doing a texelFetch from it.


329
00:18:17,796 --> 00:18:20,456
Passing our offset into there.


330
00:18:20,766 --> 00:18:25,526
And since this really is just
raw data I modified the shader


331
00:18:25,526 --> 00:18:28,556
now to read back four
values from texelFetch


332
00:18:28,976 --> 00:18:35,146
and a result I'm able to with
a single texture sampler --


333
00:18:35,146 --> 00:18:37,386
texture object I'm able


334
00:18:37,386 --> 00:18:38,846
to actually read
back the equivalent


335
00:18:38,846 --> 00:18:40,046
of what would have had to do


336
00:18:40,046 --> 00:18:41,686
with four vertex
attributes before.


337
00:18:42,426 --> 00:18:46,286
So in the API to set this


338
00:18:46,286 --> 00:18:48,826
up we're just making again
a texture buffer object,


339
00:18:48,826 --> 00:18:51,546
a buffer object as
you normally would.


340
00:18:52,506 --> 00:18:57,616
And then setting it up similar
to a texture where we're going


341
00:18:57,686 --> 00:19:00,226
to attach that buffer object


342
00:19:00,376 --> 00:19:05,766
to the texture object using Tex
buffer and we're specifying here


343
00:19:06,276 --> 00:19:08,026
that it's a type RGBA32F.


344
00:19:08,886 --> 00:19:13,576
But you can use whatever format
you want that's supported


345
00:19:13,576 --> 00:19:14,236
by textures.


346
00:19:14,236 --> 00:19:17,266
And then finally we do get
the uniform location for it


347
00:19:17,266 --> 00:19:21,866
and send it just like a
texture sampler would be set up.


348
00:19:22,066 --> 00:19:24,466
So it gives you access
to a lot more data


349
00:19:25,266 --> 00:19:30,826
than you would have gotten
64MB or more with a UBO.


350
00:19:31,596 --> 00:19:35,446
And it's very useful
for instancing


351
00:19:35,446 --> 00:19:37,336
where you do have a lot of
data that you need to pass


352
00:19:37,396 --> 00:19:38,716
down that you may
not have been able


353
00:19:38,846 --> 00:19:41,066
to have enough vertex
attributes for


354
00:19:41,626 --> 00:19:45,446
or any complicated
things like that.


355
00:19:45,506 --> 00:19:48,646
And again just like
UBOs and buffer objects


356
00:19:48,646 --> 00:19:50,696
in general try not to use --


357
00:19:51,006 --> 00:19:53,626
try not to modify a TBO
while it's being used


358
00:19:53,626 --> 00:19:54,896
to draw on the GPU.


359
00:19:55,226 --> 00:19:58,546
So again double buffering,
orphaning that --


360
00:19:58,546 --> 00:20:02,796
those TBOs will help you ensure
you're not stalling your CPU


361
00:20:02,796 --> 00:20:04,476
waiting for the GPU
to complete its work.


362
00:20:06,536 --> 00:20:11,286
So another feature that's new
in Mavericks is draw indirect.


363
00:20:12,756 --> 00:20:16,026
And draw indirect allows
you to specify the arguments


364
00:20:16,026 --> 00:20:18,896
to your draw calls
from a buffer object.


365
00:20:19,396 --> 00:20:22,996
So for instance normally a
draw raise will take a count


366
00:20:22,996 --> 00:20:24,846
and then there's
draw raise instance


367
00:20:24,886 --> 00:20:26,296
where you have an instanceCount.


368
00:20:26,816 --> 00:20:29,026
And you also specify
first, baseVertex.


369
00:20:29,536 --> 00:20:31,116
I'll show you an
example in a second.


370
00:20:31,966 --> 00:20:34,106
So when you've generated
data for instance


371
00:20:34,156 --> 00:20:36,156
with OpenCL no longer
do you need


372
00:20:36,156 --> 00:20:39,406
to know how many vertices
you may have generated there.


373
00:20:39,766 --> 00:20:44,766
So in those cases you'll be
able to find the buffer object


374
00:20:44,766 --> 00:20:48,366
as a draw underscore indirect
buffer and avoid that round trip


375
00:20:48,956 --> 00:20:52,706
of having to otherwise read back
what those variables should have


376
00:20:52,706 --> 00:20:55,686
been that you were going to
pass into your draw call.


377
00:20:56,026 --> 00:20:58,426
And this is similar to
tessellation shaders.


378
00:20:58,426 --> 00:21:03,166
It's available on all
modern hardware and it's --


379
00:21:03,166 --> 00:21:04,866
so check for the
extension string


380
00:21:04,866 --> 00:21:08,246
with glGetStringi using GL
underscore ARB underscore draw


381
00:21:08,246 --> 00:21:10,116
underscore indirect.


382
00:21:10,546 --> 00:21:13,126
So here's an example of
using DrawArrays Indirect.


383
00:21:14,096 --> 00:21:15,306
First I've got a comment


384
00:21:15,306 --> 00:21:19,546
at the top showing the general
structure of what I need


385
00:21:19,546 --> 00:21:22,496
to be outputting into this
buffer object in order to ensure


386
00:21:22,496 --> 00:21:25,766
that the GPU is able to know
what those arguments are.


387
00:21:26,076 --> 00:21:27,196
So we're going to match this.


388
00:21:27,196 --> 00:21:30,016
It's got a count, and
instanceCount and a first


389
00:21:30,016 --> 00:21:32,106
because we're going to be
calling DrawArrays instance


390
00:21:32,696 --> 00:21:37,236
and then finally a
reservedMustBeZero variable


391
00:21:37,326 --> 00:21:38,236
after that.


392
00:21:39,096 --> 00:21:42,406
So we would -- so first we
generate our data with OpenCL


393
00:21:42,566 --> 00:21:45,086
and write into our
indirect buffer object.


394
00:21:45,486 --> 00:21:49,056
And then in OpenGL
we're going to bind


395
00:21:49,056 --> 00:21:52,206
to that indirect buffer object
and then we're always going


396
00:21:52,206 --> 00:21:55,326
to setup all our vertex
attribute pointers and --


397
00:21:56,006 --> 00:21:58,766
with our BindVertexArray call.


398
00:21:58,766 --> 00:22:01,766
And then finally just
call draw indirect.


399
00:22:01,766 --> 00:22:02,806
And it still takes a mode


400
00:22:03,976 --> 00:22:07,476
so you're still saying GL
underscore TRIANGLES, glPoints,


401
00:22:07,476 --> 00:22:09,036
whatever you're using.


402
00:22:09,366 --> 00:22:11,906
And then the indirect
offset -- you take --


403
00:22:11,906 --> 00:22:15,286
you pass in an offset of
your indirect buffer object.


404
00:22:15,286 --> 00:22:17,306
So where you put
that data, the count,


405
00:22:17,436 --> 00:22:21,496
the instanceCount,
and the first.


406
00:22:21,926 --> 00:22:23,316
DrawElements, very similar.


407
00:22:23,736 --> 00:22:25,466
I've highlighted
what's different here.


408
00:22:25,466 --> 00:22:27,826
We've got a firstIndex
instead of a first


409
00:22:27,826 --> 00:22:31,346
and then additionally we have
a baseVertex offset for each


410
00:22:31,346 --> 00:22:34,116
of the elements in
your element array.


411
00:22:34,776 --> 00:22:40,616
And then -- so we've created our
data using OpenCL and OpenGL.


412
00:22:40,616 --> 00:22:42,286
We then bind that --


413
00:22:42,286 --> 00:22:45,366
the location of that
indirect buffer,


414
00:22:46,006 --> 00:22:49,036
what buffer we were
writing into.


415
00:22:49,666 --> 00:22:51,426
Again we bind the
vertex array objects


416
00:22:51,426 --> 00:22:53,296
so we have all the
vertex attributes setup


417
00:22:53,636 --> 00:22:56,826
and then we are additionally
going to have


418
00:22:56,976 --> 00:22:58,676
to set our buffer point


419
00:22:58,966 --> 00:23:01,676
for where the elements
are going to read out of.


420
00:23:02,196 --> 00:23:03,656
So we're also doing
that binding.


421
00:23:04,126 --> 00:23:09,076
And then finally we call
DrawElementsIndirect and this --


422
00:23:09,246 --> 00:23:11,646
instead of passing down
the node, the counts,


423
00:23:12,456 --> 00:23:15,836
and the instanceCount
and the baseVertex


424
00:23:16,346 --> 00:23:18,156
and firstIndex that's
all being read


425
00:23:18,156 --> 00:23:20,006
out of your indirect
buffer object.


426
00:23:20,606 --> 00:23:22,606
And instead we only have
to pass down the mode


427
00:23:22,606 --> 00:23:24,236
like GL underscore
TRIANGLES again


428
00:23:24,736 --> 00:23:27,846
and the element type
saying that our elements


429
00:23:28,206 --> 00:23:31,916
in the element array buffer
are type unsigned int,


430
00:23:32,136 --> 00:23:35,856
unsigned short, whatever you
may want to be using there.


431
00:23:36,526 --> 00:23:40,116
So let's go over just
a few more extensions.


432
00:23:41,036 --> 00:23:43,896
We've got some new
extensions here.


433
00:23:43,896 --> 00:23:46,636
Separate shader objects
available


434
00:23:46,636 --> 00:23:48,216
on all hardware on Mavericks.


435
00:23:48,596 --> 00:23:51,846
It enables you to mix and
match your GLSL shaders.


436
00:23:52,196 --> 00:23:54,186
So if you have one vertex
shader that you're using


437
00:23:54,186 --> 00:23:58,026
with five fragment shaders no
longer do you have to recompile


438
00:23:58,026 --> 00:24:01,546
that vertex shader five
times to be used with the --


439
00:24:01,546 --> 00:24:06,616
you don't have to link --
you can link really quickly.


440
00:24:06,616 --> 00:24:08,476
You don't have to redo that work


441
00:24:08,476 --> 00:24:11,396
for that vertex shader five
times in order to use it


442
00:24:11,396 --> 00:24:12,706
with five fragment shaders.


443
00:24:12,706 --> 00:24:16,386
Instead you just create that
program once and then link it


444
00:24:16,386 --> 00:24:18,576
with all five of those
shaders pretty easily.


445
00:24:19,126 --> 00:24:22,476
Additionally we've
got ES2 compatibility


446
00:24:22,886 --> 00:24:26,886
and this is probably interesting
if you have an iOS application


447
00:24:26,886 --> 00:24:28,146
that you're trying
to port to OS X.


448
00:24:28,886 --> 00:24:33,226
It allows you to use version
100 of GLSL on the desktop.


449
00:24:33,726 --> 00:24:36,406
So on OS X.


450
00:24:36,656 --> 00:24:38,956
However, you are limited
to the functionality


451
00:24:38,956 --> 00:24:41,456
that GLSL 100 specifies.


452
00:24:41,456 --> 00:24:43,936
So you aren't able for
instance to take advantage


453
00:24:43,936 --> 00:24:45,216
of tessellation shaders


454
00:24:45,556 --> 00:24:48,766
if you'll be using
this version of GLSL.


455
00:24:50,306 --> 00:24:54,846
Another nifty new extension in
Mavericks is NV Texture Barrier


456
00:24:55,206 --> 00:24:57,646
and it allows you to
bind the same textures,


457
00:24:57,646 --> 00:25:00,166
both the rendered target
and the texture source.


458
00:25:00,616 --> 00:25:02,406
So now if you have --


459
00:25:02,966 --> 00:25:06,436
it's similar to Apple Frame
Buffer Shader Fetch --


460
00:25:06,796 --> 00:25:08,696
Shader Frame Buffer Fetch on iOS


461
00:25:09,176 --> 00:25:10,726
where you can do
programmable blending there.


462
00:25:10,996 --> 00:25:14,376
However, this is limited to
cases where there is no overlap


463
00:25:14,416 --> 00:25:17,076
between a single draw call
where your depth complexity


464
00:25:17,076 --> 00:25:18,016
of your scenes is one.


465
00:25:18,576 --> 00:25:21,076
So basically it saves
you a little bit of vRAM


466
00:25:21,716 --> 00:25:25,246
and not having to create a copy
of your texture if you're trying


467
00:25:25,306 --> 00:25:28,456
to do ping pong back and forth
between two buffer objects.


468
00:25:28,736 --> 00:25:31,006
You might be able to
update your application


469
00:25:31,456 --> 00:25:33,256
to just render right
back into itself


470
00:25:33,826 --> 00:25:37,426
and use itself as
a texture source.


471
00:25:37,426 --> 00:25:39,516
And then additionally
we actually added


472
00:25:39,516 --> 00:25:44,036
in 10.8.3 our texture swizzle,
and this is a heavy extension


473
00:25:44,076 --> 00:25:47,926
for supporting older
applications


474
00:25:47,926 --> 00:25:49,196
which might have
been using a format


475
00:25:49,196 --> 00:25:50,286
like GL underscore LUMINANCE.


476
00:25:50,776 --> 00:25:53,416
And so instead of having to
modify all of your shaders


477
00:25:53,416 --> 00:25:55,666
to be able to take in RGBA data


478
00:25:55,666 --> 00:25:58,896
and LUMINANCE data you
can specify up front


479
00:25:58,896 --> 00:26:00,336
that LUNINANCE should
be interpreted


480
00:26:00,336 --> 00:26:02,766
as red, red, red one.


481
00:26:03,566 --> 00:26:06,396
Or LUMINANCE Alpha would
be red, red, red, green;


482
00:26:06,446 --> 00:26:09,336
a red green texture passing
out and trying to pretend


483
00:26:09,336 --> 00:26:10,376
that it's LUMINANCE Alpha.


484
00:26:11,086 --> 00:26:15,956
So those are the
features that --


485
00:26:15,956 --> 00:26:18,876
some of the features in
Mavericks that I wanted to go


486
00:26:18,876 --> 00:26:23,456
over and now I wanted
to go into using OpenCL


487
00:26:24,166 --> 00:26:30,116
as a compute for with Open GL.


488
00:26:30,616 --> 00:26:35,596
So OpenGL and OpenCL on our
platform were created together


489
00:26:35,596 --> 00:26:40,246
and use the same infrastructure
in order to talk to the GPUs.


490
00:26:40,246 --> 00:26:44,336
And as a result of that
cooperation you're able


491
00:26:44,336 --> 00:26:47,546
to be able to share things
like buffers, objects,


492
00:26:47,916 --> 00:26:51,536
textures between
OpenGL and OpenCL.


493
00:26:51,866 --> 00:26:55,166
There's no need for any reading
back data and then put it back


494
00:26:55,166 --> 00:26:57,456
up just to switch between APIs.


495
00:26:57,976 --> 00:27:00,356
It's a very simple integration
into your render loop


496
00:27:00,446 --> 00:27:04,786
and I'm going to go
into that right now.


497
00:27:05,006 --> 00:27:08,096
So some of the use
cases for Compute.


498
00:27:08,516 --> 00:27:12,146
We may use OpenCL here,
for instance, to generate


499
00:27:12,146 --> 00:27:13,486
or modify geometry data.


500
00:27:13,486 --> 00:27:17,986
So I'm going to go into
generating a tea pot in OpenCL


501
00:27:17,986 --> 00:27:19,646
and drawing that in OpenGL.


502
00:27:20,646 --> 00:27:24,826
Also I got to go in after that
to post-processing an image


503
00:27:24,826 --> 00:27:29,406
that you may have generated with
OpenGL and then displaying that.


504
00:27:31,386 --> 00:27:33,836
So first starting out
with filling up the VBO


505
00:27:33,836 --> 00:27:36,236
with vertex data using OpenCL,


506
00:27:36,636 --> 00:27:37,836
and then rendering
that with OpenGL.


507
00:27:37,836 --> 00:27:43,136
We're going to have our one time
setup of setting up our OpenGL


508
00:27:43,136 --> 00:27:45,376
and OpenCL context to share.


509
00:27:45,876 --> 00:27:49,076
And then we create that
vertex buffer object in OpenGL


510
00:27:49,626 --> 00:27:52,986
and we'll specify that we can
share that object in OpenCL


511
00:27:52,986 --> 00:27:54,116
in order to fill it in there.


512
00:27:54,266 --> 00:27:59,416
And then every frame enqueue our
CL command in order to create


513
00:27:59,416 --> 00:28:02,456
that -- the data that
goes into that VBO.


514
00:28:02,806 --> 00:28:09,106
Then after that we'll flush the
CL enqueued commands in order


515
00:28:09,106 --> 00:28:11,766
to ensure that when we
use that data with OpenGL


516
00:28:11,766 --> 00:28:15,836
that it's now been pushed
to the GPU to be filled


517
00:28:15,836 --> 00:28:18,536
in so it won't -- so
you're not using your --


518
00:28:19,396 --> 00:28:21,556
you're not using data that
has not yet been specified.


519
00:28:22,526 --> 00:28:24,966
So after that's been done
you just draw it with OpenGL.


520
00:28:24,966 --> 00:28:29,946
So let's start out looking
a little bit closer at that.


521
00:28:30,376 --> 00:28:33,186
So first we're going to
create our OpenGL context


522
00:28:33,736 --> 00:28:38,726
and we're setting up the
pixel format for NSOpenGL


523
00:28:39,606 --> 00:28:43,856
and here we're adding a new
PFA, pixel format attribute


524
00:28:43,856 --> 00:28:47,396
of
NSOpenGLPFAAcceleratedCompute.


525
00:28:47,466 --> 00:28:51,276
And that specifies that I
want to have an OpenGL context


526
00:28:51,276 --> 00:28:57,046
that is capable of accessing the
GPUs that have OpenCL support.


527
00:28:58,996 --> 00:29:00,786
Then after I've created our --


528
00:29:00,976 --> 00:29:04,916
my context I'm going to get the
share group from that context


529
00:29:06,006 --> 00:29:09,376
and with that share group I
can use the CL APIs in order


530
00:29:09,456 --> 00:29:16,256
to get the -- in order to get
the matching CL device IDs


531
00:29:16,816 --> 00:29:20,956
that will match up with my
OpenGL virtual screen list


532
00:29:21,436 --> 00:29:23,976
and so I'll be able to share
between these two contexts.


533
00:29:25,086 --> 00:29:28,896
And then I'll create my
context from that CL device list


534
00:29:30,036 --> 00:29:33,076
and then back in OpenGL
we're going to be creating --


535
00:29:33,226 --> 00:29:36,776
or creating a vertex buffer
object here to be able to fill


536
00:29:36,776 --> 00:29:42,826
in and fill in with the tea pot.


537
00:29:42,826 --> 00:29:48,076
Specify the size, we're going
to flush that to the GPU


538
00:29:49,006 --> 00:29:52,146
and then we just use this API
[inaudible] from GL buffer,


539
00:29:52,466 --> 00:29:55,846
and now we have a CL mem object
that points exactly to where


540
00:29:56,116 --> 00:29:58,486
that VBO in OpenGL is.


541
00:29:59,176 --> 00:30:00,246
So that's a onetime set up.


542
00:30:00,246 --> 00:30:04,746
And then every time we're going
to be drawing you can check


543
00:30:04,746 --> 00:30:07,456
for the CL/GL DEVICE underscore


544
00:30:07,456 --> 00:30:11,116
FOR underscore CURRENT
underscore VS underscore APPLE,


545
00:30:11,116 --> 00:30:11,726
didn't quite fit there.


546
00:30:11,726 --> 00:30:14,276
So by using -- by looking
that up you can look


547
00:30:14,276 --> 00:30:17,696
at what virtual screen
OpenGL is currently using


548
00:30:18,526 --> 00:30:20,236
in order to do its rendering.


549
00:30:20,766 --> 00:30:24,206
So if you do have say
multiple GPUs in your system


550
00:30:24,536 --> 00:30:29,186
in this case I'm using this
query in order to check


551
00:30:29,496 --> 00:30:33,206
which GPU OpenGL is on and
I'm having OpenCL follow it


552
00:30:33,756 --> 00:30:36,536
so that it can do its
computations and not have


553
00:30:36,576 --> 00:30:40,216
to copy back to the
other GPU any of the data


554
00:30:40,216 --> 00:30:41,276
that I'm going to
be creating here.


555
00:30:41,976 --> 00:30:45,956
so I've not picked the CL device
ID that I want to submit my data


556
00:30:45,956 --> 00:30:50,266
to and I enqueue a OpenCL kernel


557
00:30:51,396 --> 00:30:54,566
and this OpenCL kernel will
be generating our vertex data


558
00:30:54,566 --> 00:30:57,966
that we're going to then
consume with OpenGL.


559
00:30:59,676 --> 00:31:03,976
So after that's been done
we flush that to the GPU.


560
00:31:04,046 --> 00:31:05,946
The GPU starts creating
this data for us,


561
00:31:06,786 --> 00:31:09,106
and I have a barrier
here just to say


562
00:31:09,106 --> 00:31:11,676
that if you are doing some
more complicated things,


563
00:31:12,216 --> 00:31:16,846
if you're doing some threading
and doing things in OpenGL


564
00:31:16,846 --> 00:31:19,586
and OpenCL that may
not be interacting


565
00:31:19,586 --> 00:31:23,156
with each other you can continue
doing some of that work in the


566
00:31:23,696 --> 00:31:26,386
in between time but
you need to make sure


567
00:31:26,386 --> 00:31:29,436
that this flush here
is done before we try


568
00:31:29,436 --> 00:31:30,546
to use that data in OpenGL.


569
00:31:30,546 --> 00:31:34,486
So we're using here the new
function GL DrawElements


570
00:31:34,486 --> 00:31:39,206
and Direct and that allowed
us to draw this tea pot


571
00:31:39,626 --> 00:31:42,226
without even knowing how
many vertices were in remodel


572
00:31:42,516 --> 00:31:46,416
and so that's how you get
a vertex buffer object


573
00:31:46,616 --> 00:31:47,316
from OpenCL.


574
00:31:48,946 --> 00:31:50,366
So the opposite is also true --


575
00:31:50,366 --> 00:31:52,646
or not the opposite
but the other side


576
00:31:52,706 --> 00:31:57,966
of the pipeline you can do image
processing and well with OpenCL.


577
00:31:58,746 --> 00:32:03,606
So for this case we have
similar onetime setup.


578
00:32:03,606 --> 00:32:05,096
We're going to setup
OpenGL and OpenCL


579
00:32:05,096 --> 00:32:06,476
to share just like
we did before.


580
00:32:07,206 --> 00:32:09,746
However this time, we're going
to create a texture object


581
00:32:09,746 --> 00:32:12,396
and share that between
OpenGL and OpenCL.


582
00:32:13,546 --> 00:32:16,786
And so every time --
every frame that we want


583
00:32:16,786 --> 00:32:20,176
to do this post-processing will
draw that texture using OpenGL,


584
00:32:20,976 --> 00:32:23,536
flush OpenGL's command buffer


585
00:32:23,916 --> 00:32:27,886
to the GPU calling
glFlushRenderApple and then,


586
00:32:28,406 --> 00:32:31,276
in OpenCL we can
enqueue the commands


587
00:32:31,406 --> 00:32:33,426
to process that texture.


588
00:32:34,336 --> 00:32:36,916
And then finally if you
want to display that back


589
00:32:36,916 --> 00:32:39,916
on the screen you're going
to flush the OpenCL commands


590
00:32:40,596 --> 00:32:43,456
and then you can blip or
swap back to the screen.


591
00:32:44,276 --> 00:32:50,856
So here we're again, picking
a pixel format that has access


592
00:32:50,966 --> 00:32:54,746
to the GPUs which have Compute
capabilities with OpenCL.


593
00:32:56,236 --> 00:32:58,836
We get the share group
form which we're going


594
00:32:58,926 --> 00:33:03,576
to get CL device IDs that match
up with the OpenGL context


595
00:33:03,576 --> 00:33:07,326
that we've created and
then we'll create a context


596
00:33:07,326 --> 00:33:07,716
from that.


597
00:33:09,066 --> 00:33:11,776
And this time we have a texture
that we're going to be sharing


598
00:33:12,206 --> 00:33:14,676
with OpenCL so we'll
bind to that texture,


599
00:33:15,106 --> 00:33:17,926
setup how big it is to
store using techImage 2D.


600
00:33:19,426 --> 00:33:21,476
And then FlushRenderApple --


601
00:33:22,056 --> 00:33:25,966
and after which you can
create a CL meme object


602
00:33:25,966 --> 00:33:27,096
from that GL texture.


603
00:33:27,826 --> 00:33:32,256
So now every frame
we're going to be doing


604
00:33:32,256 --> 00:33:33,606
or normal drawing in OpenGL.


605
00:33:33,606 --> 00:33:36,616
We'll render to the
texture say DrawElements


606
00:33:37,066 --> 00:33:39,096
and other OpenGL draw calls.


607
00:33:40,366 --> 00:33:45,296
We'll then flush that data to
the GPU to start processing it.


608
00:33:45,606 --> 00:33:46,906
We happen to be drawing
the tea pot


609
00:33:46,906 --> 00:33:48,456
that we've already
done with OpenCL here.


610
00:33:49,776 --> 00:33:51,146
Again the barrier.


611
00:33:51,346 --> 00:33:54,286
So after that FlushRenderApple
and only


612
00:33:54,286 --> 00:33:56,616
after that FlushRenderApple
should you start doing your work


613
00:33:56,616 --> 00:34:00,816
in OpenCL that depends on
the results of the draw calls


614
00:34:01,226 --> 00:34:03,246
that were modifying that
texture that we're sharing.


615
00:34:04,196 --> 00:34:05,926
So here again we're
going to check


616
00:34:06,306 --> 00:34:09,235
which virtual screen
OpenGL is on,


617
00:34:09,235 --> 00:34:11,386
and match the CL
device ID there.


618
00:34:11,386 --> 00:34:14,906
So OpenCL is generating
the data on the same GPU


619
00:34:14,906 --> 00:34:19,376
that OpenGL created
that data in.


620
00:34:20,096 --> 00:34:24,826
And then we're going to enqueue
our post-process kernel there


621
00:34:25,196 --> 00:34:29,926
and do our calculations such as
like edge detection or blurring.


622
00:34:30,826 --> 00:34:34,536
And then finally if we
want to pass that data back


623
00:34:34,536 --> 00:34:37,826
to GL we're going to flush
that results using CLFlush


624
00:34:38,966 --> 00:34:42,326
and in OpenGL we'll then be able
to just bind to that texture


625
00:34:42,876 --> 00:34:46,085
and blip it to the
screen if we want to.


626
00:34:47,315 --> 00:34:52,746
So that's passing data back and
forth between OpenGL and OpenCL.


627
00:34:52,906 --> 00:34:55,126
You get best of both worlds.


628
00:34:55,126 --> 00:34:59,036
You a graphics API with
full Compute capabilities


629
00:34:59,336 --> 00:35:05,066
and just sharing in between
with very little cost.


630
00:35:05,066 --> 00:35:08,536
And it's -- additionally
wanted to reiterate


631
00:35:08,536 --> 00:35:11,016
that if you are creating data
but you don't know how big it is


632
00:35:11,456 --> 00:35:14,966
for vertex geometry then
it's great for using


633
00:35:14,966 --> 00:35:17,436
with ARB underscore Draw
underscore Indirect.


634
00:35:18,456 --> 00:35:22,246
And after this talk
we're going to be talking


635
00:35:22,246 --> 00:35:24,716
about OpenCL actually
and how to use


636
00:35:24,716 --> 00:35:28,566
that a little bit more
explicitly and even going


637
00:35:28,566 --> 00:35:31,166
into some OpenGL/OpenCL
sharing there, as well.


638
00:35:31,676 --> 00:35:34,506
So if you're not familiar with
OpenCL yet and you are hoping


639
00:35:34,506 --> 00:35:37,896
to do Compute in your projects
I recommend you stay right


640
00:35:37,896 --> 00:35:40,386
after for that talk.


641
00:35:40,986 --> 00:35:47,486
So we've gone over Compute
so let's now talk about how


642
00:35:47,486 --> 00:35:51,486
to get your context into
Core Profile in order


643
00:35:51,486 --> 00:35:53,326
to take advantage of
all these new features


644
00:35:53,326 --> 00:35:57,876
that we're supporting
in Mavericks.


645
00:35:57,996 --> 00:36:02,826
So first to start out OpenGL
Core Profile is a profile


646
00:36:02,826 --> 00:36:05,726
that gives you access to
the latest GPU features.


647
00:36:06,366 --> 00:36:10,116
The API -- I don't
know if you're familiar


648
00:36:10,406 --> 00:36:12,306
with OpenGL ES2 versus
OpenGL ES1.


649
00:36:12,566 --> 00:36:16,246
It's very akin to that
transition where the -- we --


650
00:36:16,246 --> 00:36:20,676
the API was trimmed down to be
streamlined and high-performance


651
00:36:20,986 --> 00:36:25,186
and it's more in tune with
how the GPU actually works.


652
00:36:25,326 --> 00:36:28,036
So there's no matrix
math or things


653
00:36:28,036 --> 00:36:30,026
that the GPU wouldn't
have actually been doing


654
00:36:30,026 --> 00:36:30,866
in the first place.


655
00:36:31,496 --> 00:36:33,166
And it gives you
the full control


656
00:36:33,166 --> 00:36:34,666
over the rendering pipeline


657
00:36:34,776 --> 00:36:37,176
so we're specifying
everything as shaders.


658
00:36:37,846 --> 00:36:42,596
And similar -- I was saying it's
similar to OpenGL ES2 actually


659
00:36:42,596 --> 00:36:45,796
so much so that it's pretty
easy to port back and forth


660
00:36:45,796 --> 00:36:49,166
between OpenGL ES2 and
OpenGL Core Profile.


661
00:36:49,646 --> 00:36:54,986
So let's go over conceptual
overview of what you're going


662
00:36:54,986 --> 00:36:57,266
to need to do in your
applications in order


663
00:36:57,266 --> 00:37:00,076
to get them working
with Core Profile.


664
00:37:00,256 --> 00:37:03,126
And many of these are actually
things that you want to do


665
00:37:03,126 --> 00:37:06,026
to your application even
if you're not trying


666
00:37:06,066 --> 00:37:07,646
to get it in Core Profile.


667
00:37:07,696 --> 00:37:09,346
If you're not doing it
for the reason of going


668
00:37:09,346 --> 00:37:12,116
into Core Profile it's
at least an enhancement


669
00:37:12,116 --> 00:37:15,416
to your application to take --
to switch over to these new ways


670
00:37:15,716 --> 00:37:19,026
of doing your existing
applications.


671
00:37:19,346 --> 00:37:24,106
So for instance a media mode
vertex drawing should be


672
00:37:24,106 --> 00:37:26,016
replaced with using
vertex array objects


673
00:37:26,016 --> 00:37:27,226
and vertex buffer objects.


674
00:37:27,226 --> 00:37:29,436
And there's obvious
increase in performance


675
00:37:29,436 --> 00:37:31,576
by just switching
your application


676
00:37:31,576 --> 00:37:34,786
to use vertex buffer
objects instead of having


677
00:37:34,786 --> 00:37:37,606
to provide the data each
frame, every single time


678
00:37:37,606 --> 00:37:39,796
that you're drawing with it.


679
00:37:39,986 --> 00:37:44,106
Fixed function state gets
replaced with GLSL shaders.


680
00:37:44,626 --> 00:37:48,406
So you're going to have
to specify vertex shader


681
00:37:48,406 --> 00:37:50,396
and a fragment shader,
and then optionally


682
00:37:50,396 --> 00:37:53,766
as well the tessellation
shaders and geometry shaders.


683
00:37:54,206 --> 00:37:58,626
And the matrix math is now
no longer part of OpenGL.


684
00:37:59,166 --> 00:38:01,456
So you do have to provide
your own custom matrix math.


685
00:38:02,646 --> 00:38:07,126
And then older shaders which are
in say 110 or 120, version 110,


686
00:38:07,126 --> 00:38:11,276
120 need to be updated
to version 150 or above.


687
00:38:11,826 --> 00:38:16,376
However, on our platform


688
00:38:16,376 --> 00:38:19,666
in Mountain Lion we also
introduced support for GL Kit,


689
00:38:20,206 --> 00:38:22,696
and GL Kit actually
solves a couple


690
00:38:22,696 --> 00:38:24,656
of these transition steps.


691
00:38:25,056 --> 00:38:27,026
You're still going to have
to update your application


692
00:38:27,026 --> 00:38:29,106
to take advantage of
vertex array objects


693
00:38:29,106 --> 00:38:30,426
and vertex buffer objects.


694
00:38:30,906 --> 00:38:34,026
But for your fixed function
state, for your application


695
00:38:34,026 --> 00:38:35,746
that you made but are
just trying to get to work


696
00:38:35,746 --> 00:38:39,836
in Core Profile you can
use GLKBaseEffect in order


697
00:38:39,836 --> 00:38:43,366
to achieve the same affects that
you would have been trying to do


698
00:38:43,366 --> 00:38:45,926
with your lighting and so forth.


699
00:38:45,926 --> 00:38:50,486
And your Legacy OpenGL
application.


700
00:38:51,066 --> 00:38:55,076
And then additionally the
matrix math that I said was gone


701
00:38:55,076 --> 00:38:59,056
in OpenGL is now fully
replaced by math libraries


702
00:38:59,056 --> 00:39:00,356
that GLK Math provides.


703
00:39:00,356 --> 00:39:07,116
So let's talk about creating
that Core Profile Context.


704
00:39:07,566 --> 00:39:10,226
So all we do is in our
pixel format attribute lists


705
00:39:10,226 --> 00:39:15,036
that we're going to use to
create our context from we pass


706
00:39:15,036 --> 00:39:18,986
in an NSOpenGLPFA,
OpenGL profile.


707
00:39:19,316 --> 00:39:23,116
And in this attribute
list we're passing


708
00:39:23,116 --> 00:39:25,696
down NSOpenGLProfile3
underscore 2Core.


709
00:39:25,856 --> 00:39:30,116
And this gets you access to all
the new features of OpenGL 4.1.


710
00:39:30,276 --> 00:39:33,756
And OpenGL 4.1 is fully
backwards compatible


711
00:39:33,756 --> 00:39:35,536
with OpenGL 3.2.


712
00:39:35,786 --> 00:39:38,826
So that's how -- why
picking this enables you


713
00:39:38,826 --> 00:39:40,486
to take advantage of
all those new features.


714
00:39:40,866 --> 00:39:45,376
And so now that we've picked
that pixel format we're going


715
00:39:45,376 --> 00:39:49,746
to create our context from that.


716
00:39:49,986 --> 00:39:55,996
So to go over briefly how to get
your application switched over,


717
00:39:56,526 --> 00:39:58,846
what you're looking for and
what you're replacing it


718
00:39:59,286 --> 00:39:59,386
with [laughter].


719
00:39:59,646 --> 00:40:02,496
Basically saying you need
to cash all your vertex data


720
00:40:02,946 --> 00:40:03,946
in vertex buffer objects.


721
00:40:05,836 --> 00:40:09,166
And additionally
you're going to need


722
00:40:09,366 --> 00:40:13,796
to encapsulate those objects
into vertex array objects


723
00:40:13,796 --> 00:40:17,036
that point where all the
attributes are coming


724
00:40:17,036 --> 00:40:18,066
from for your shaders.


725
00:40:18,736 --> 00:40:20,726
So we have code on the left


726
00:40:20,726 --> 00:40:22,416
which is what would have
been in your application.


727
00:40:22,876 --> 00:40:27,126
So glBegin, GL underscore
TRIANGLES, glEnd or glCallList


728
00:40:27,126 --> 00:40:29,296
with display lists
and Core Profile


729
00:40:29,296 --> 00:40:33,146
on the right we now can
change all those calls


730
00:40:33,146 --> 00:40:36,066
to just two calls we
call glBindVertexArray,


731
00:40:36,066 --> 00:40:39,466
and then glDrawArrays
or glDrawElements if you


732
00:40:39,466 --> 00:40:41,446
so choose to use elements.


733
00:40:42,346 --> 00:40:47,256
glBitmap, glDrawPixels are
subsumed by uploading a texture.


734
00:40:48,306 --> 00:40:51,536
So glTexSubImage in this case
and then we can just draw


735
00:40:51,536 --> 00:40:54,446
with that or call BitFramBuffer
to do something similar


736
00:40:54,446 --> 00:40:56,146
to what it would have done --


737
00:40:56,146 --> 00:40:58,896
what it would have been
doing anyways for you


738
00:40:58,896 --> 00:41:00,296
in the Legacy profile.


739
00:41:01,326 --> 00:41:06,546
And additionally, the
pointers that used to exist


740
00:41:06,546 --> 00:41:08,876
for VertexPointer,
TexCoordPointer,


741
00:41:08,926 --> 00:41:11,216
ColorPointer those
are all subsumed


742
00:41:11,996 --> 00:41:14,206
by generic VertexAtribPointers.


743
00:41:14,596 --> 00:41:16,896
So instead we're going to
call VertexAtribPointer


744
00:41:17,336 --> 00:41:22,096
and then we bind each of our
pointer -- attributes by name.


745
00:41:23,046 --> 00:41:27,016
So we have like myVerts in this
example and myglShellShader.


746
00:41:27,016 --> 00:41:30,806
I would have had to input
myVerts and I can bind


747
00:41:31,096 --> 00:41:34,286
that attribute using
BindAttribLocation.


748
00:41:35,676 --> 00:41:38,546
And then finally
glEnableClientState no longer


749
00:41:38,626 --> 00:41:43,296
takes -- because we're no longer
dealing with those color arrays,


750
00:41:43,296 --> 00:41:44,546
normal arrays and so forth.


751
00:41:44,946 --> 00:41:48,876
Instead we're just enabling the
VertexAttribArray by the index


752
00:41:48,996 --> 00:41:52,046
that it's being passed up
to the gl shell shader with.


753
00:41:53,526 --> 00:41:59,006
For your math portions, for
matrix math just use GLKMath.


754
00:41:59,886 --> 00:42:04,886
It's got the ability to replace
all the built in transformations


755
00:42:05,346 --> 00:42:08,596
that OpenGL would
have provided for you.


756
00:42:08,596 --> 00:42:11,936
And of course you can use
your own matrix math library


757
00:42:11,936 --> 00:42:12,656
if you already have it


758
00:42:12,736 --> 00:42:15,186
but if you don't this is
not a bad place to start.


759
00:42:16,096 --> 00:42:18,546
So we've got for instance
our translate, rotate,


760
00:42:18,546 --> 00:42:20,336
and scale functions
have been replaced


761
00:42:20,336 --> 00:42:27,106
by GLKMatrix4MakeTranslate,
Rotate, Scale.


762
00:42:27,706 --> 00:42:31,726
And the first function there
GLKMatrix4MakeTranslate is


763
00:42:31,726 --> 00:42:34,726
actually equivalent to -- the
make there means it's equivalent


764
00:42:34,726 --> 00:42:38,106
to calling glLoadIdentity
followed by glTranslate.


765
00:42:39,746 --> 00:42:45,076
Additionally perspective we can
call GLKMatrix4MakePerspective.


766
00:42:45,076 --> 00:42:47,686
Similarly that's a
glLoadIdentiy followed


767
00:42:47,686 --> 00:42:51,226
by what gluPerspective
would have done.


768
00:42:51,696 --> 00:42:55,516
And the GLKMath also
provides you with MatrixStacks


769
00:42:55,586 --> 00:42:57,196
so you can push and
pop your stacks.


770
00:42:57,846 --> 00:43:00,466
But when you've actually
finally gotten your value


771
00:43:00,466 --> 00:43:03,726
out of your matrix, no longer
are you going to use LoadMatrix


772
00:43:03,726 --> 00:43:07,916
to pass your data up
to your GLSL shaders.


773
00:43:08,446 --> 00:43:11,176
But you're going to upload
those as generic uniforms.


774
00:43:11,176 --> 00:43:16,526
So you use glUniformMatrix4fv
in that case.


775
00:43:16,726 --> 00:43:19,796
So here is a list of some
of the functions in GLKMath.


776
00:43:20,246 --> 00:43:21,736
I hope you brought
your binoculars.


777
00:43:22,236 --> 00:43:25,836
But it's basically -- I want
to say it provides everything


778
00:43:25,836 --> 00:43:29,306
that you need for Core
Profile in order to do --


779
00:43:29,556 --> 00:43:31,976
for all your OpenGL
Core Profile needs.


780
00:43:31,976 --> 00:43:34,146
It even has support
for quatrains.


781
00:43:34,766 --> 00:43:40,166
So now on to the next
part of your application


782
00:43:40,166 --> 00:43:41,056
that you need to update.


783
00:43:41,336 --> 00:43:44,176
The fixed-function state that
you may have in your app.


784
00:43:44,726 --> 00:43:47,936
Let's talk about using
GLKBaseEffects and GL Kit


785
00:43:47,936 --> 00:43:49,746
in order to update
your application


786
00:43:50,196 --> 00:43:51,486
to work with Core Profile.


787
00:43:52,516 --> 00:43:54,686
So you would have had
fixed-function in the lighting,


788
00:43:55,386 --> 00:43:58,566
fixed-function materials,
fixed-function texturing.


789
00:43:59,036 --> 00:44:00,726
That's no longer available.


790
00:44:01,006 --> 00:44:03,306
Instead we're passing
everything up as shaders


791
00:44:03,616 --> 00:44:06,176
and then GLKEffect provides
you with base shaders


792
00:44:06,586 --> 00:44:10,446
that you can treat similarly


793
00:44:10,446 --> 00:44:12,246
to how your code
may have interacted


794
00:44:12,646 --> 00:44:15,006
with your Legacy OpenGL context.


795
00:44:16,636 --> 00:44:20,156
So here we have our lights that
we're passing up for instance.


796
00:44:20,156 --> 00:44:22,376
We can pass up a
position, diffuse,


797
00:44:22,376 --> 00:44:24,996
specular values for our lights.


798
00:44:25,576 --> 00:44:28,386
Instead with the GLKBaseEffect
we're just setting the


799
00:44:28,386 --> 00:44:30,186
light0.position, diffuse color


800
00:44:30,186 --> 00:44:32,296
and specular color
as you would expect.


801
00:44:32,736 --> 00:44:33,646
Pretty straight forward.


802
00:44:34,276 --> 00:44:37,506
Additionally you can go
enable it with an enabled bit


803
00:44:38,056 --> 00:44:39,926
and then we even have materials.


804
00:44:40,586 --> 00:44:42,796
So it's a very close correlation


805
00:44:42,856 --> 00:44:50,436
to how you would have been using
fixed-function state before.


806
00:44:50,796 --> 00:44:55,186
So afterwards -- some of you
may already have some shaders


807
00:44:55,186 --> 00:44:58,956
already written using
GLSL 110 and --


808
00:44:58,956 --> 00:45:02,006
or 120 and there's some slight
differences in getting it


809
00:45:02,006 --> 00:45:08,486
to work with 140,
150, 330 and 410.


810
00:45:09,796 --> 00:45:11,726
So again, I was already saying


811
00:45:11,726 --> 00:45:17,146
that we've got our client
state enables are now switched


812
00:45:17,186 --> 00:45:18,726
to generic attributes.


813
00:45:19,026 --> 00:45:21,966
So we're just going to be
enabling our index here


814
00:45:22,206 --> 00:45:24,036
of our attributes
that we're passing in.


815
00:45:24,566 --> 00:45:28,356
Matrices; we're no longer
loading those matrices


816
00:45:28,356 --> 00:45:29,776
as a built in matrix


817
00:45:29,866 --> 00:45:36,236
like glModelViewProjectionMatrix
and so forth.


818
00:45:36,386 --> 00:45:38,076
They're instead going
to be generic uniforms


819
00:45:38,076 --> 00:45:40,556
that we pass into our shaders.


820
00:45:40,556 --> 00:45:43,416
And so we're going
to be uploading those


821
00:45:43,416 --> 00:45:44,926
with glUniformMatrix4fv.


822
00:45:44,926 --> 00:45:49,126
Additionally some of the current
state that you would have set


823
00:45:49,126 --> 00:45:55,686
like glColor4fv you can set
those either using similarly


824
00:45:55,686 --> 00:46:01,626
glVertexAttrib4fv for constant
values or glUniform4fv as well


825
00:46:01,626 --> 00:46:05,346
for values that are not
changing very often.


826
00:46:05,996 --> 00:46:10,186
And then additionally all the
pointer calls get replaced


827
00:46:10,186 --> 00:46:14,246
with a generic
VertexAttribPointer call.


828
00:46:14,446 --> 00:46:18,796
So looking at the actually GLSL
language itself there's some


829
00:46:18,796 --> 00:46:22,596
slight differences
here where the ins


830
00:46:22,596 --> 00:46:25,846
and outs are now very
explicit in GLSL 150.


831
00:46:26,456 --> 00:46:28,376
And then additionally
for the frag- --


832
00:46:28,586 --> 00:46:31,486
similarly to how the
built-ins are removed


833
00:46:31,486 --> 00:46:34,196
for like the fixed-functions
state


834
00:46:34,196 --> 00:46:39,936
and so forth the frag data
output is replaced with an


835
00:46:39,936 --> 00:46:42,956
out that will be where
we're going to be writing


836
00:46:42,956 --> 00:46:45,916
to which tells us which
one of our draw buffers


837
00:46:45,916 --> 00:46:47,856
to provide a result to.


838
00:46:48,446 --> 00:46:50,396
So we have up here
the attributes


839
00:46:50,676 --> 00:46:53,016
that would have been
attributes in GLSL 110.


840
00:46:53,366 --> 00:46:56,396
In 150 those become in because
the attributes are going


841
00:46:56,396 --> 00:46:59,066
into your vertex shader
so that we're just passing


842
00:46:59,066 --> 00:47:00,526
in vec4 data here.


843
00:47:00,526 --> 00:47:03,516
And then our varying's
that we would have produced


844
00:47:03,556 --> 00:47:06,296
with our vertex shader
and then consumed


845
00:47:06,296 --> 00:47:09,286
with our fragment shader are
no longer called varying's.


846
00:47:09,416 --> 00:47:13,536
They're more explicitly named
out from the vertex shader


847
00:47:13,536 --> 00:47:15,356
and in in the fragment shader.


848
00:47:15,776 --> 00:47:19,516
So our texCoordinates for
instance we're outputting


849
00:47:19,516 --> 00:47:21,796
that from the vertex shader here


850
00:47:21,796 --> 00:47:24,256
and then inputting
it to the fragment.


851
00:47:24,806 --> 00:47:28,766
And then finally as I was
mentioning just a moment again


852
00:47:29,026 --> 00:47:31,426
-- ago, gl underscore
FragColor is replaced


853
00:47:32,266 --> 00:47:35,446
with a binding of your choice.


854
00:47:35,776 --> 00:47:40,436
So we've made an out to vec4
here called myColor and prior


855
00:47:40,526 --> 00:47:43,676
to linking our GLSL
program I made sure


856
00:47:43,676 --> 00:47:46,626
to BindFragDataLocation
for the --


857
00:47:46,876 --> 00:47:50,836
for myColor so that I'm
specifying it to be writing


858
00:47:50,886 --> 00:47:53,236
to the [inaudible]
for zero with myColor.


859
00:47:56,396 --> 00:47:59,426
Some additional changes
we've got


860
00:48:00,376 --> 00:48:03,406
in GLSL version 150 over 110.


861
00:48:03,646 --> 00:48:05,746
Now the GLSL version
is also required.


862
00:48:05,796 --> 00:48:09,266
So 110 would have been implicit
which version you were using.


863
00:48:09,626 --> 00:48:12,426
However, in Core Profile you're
required to say version --


864
00:48:12,426 --> 00:48:16,986
#version 150, 330 or 410
at the top of your shaders.


865
00:48:17,756 --> 00:48:20,526
And then some examples
here of the built ins


866
00:48:20,526 --> 00:48:23,196
that have been removed; gl
underscore Vertex, Normal,


867
00:48:23,226 --> 00:48:28,156
MultiTexCoord are replaced
with your own generic uniforms


868
00:48:28,516 --> 00:48:30,336
or vertex attributes here.


869
00:48:31,176 --> 00:48:35,226
vertPos, inNormal, texCoord
that we've named ourselves


870
00:48:35,286 --> 00:48:37,706
and upload as vertex attributes.


871
00:48:37,706 --> 00:48:42,046
And then additionally some
of the uniform variables


872
00:48:42,046 --> 00:48:43,706
like our
ModelViewProjectionMatrix


873
00:48:44,146 --> 00:48:47,956
and the gl underscore
NormalMatrix we could --


874
00:48:48,136 --> 00:48:50,146
we upload those as
glUniforms here.


875
00:48:50,786 --> 00:48:55,136
And then finally small
change; texture2D,


876
00:48:55,136 --> 00:48:58,136
texture3D are replaced by
just a simple texture call.


877
00:48:58,456 --> 00:49:00,416
And the sampler type
overloads how


878
00:49:00,416 --> 00:49:04,986
that texture call
should be sampled from.


879
00:49:04,986 --> 00:49:09,196
So now that we've got our GLSL
shaders pretty much working


880
00:49:09,196 --> 00:49:12,046
with Core Profile let's
go over a little bit more


881
00:49:12,046 --> 00:49:13,326
of the other API
differences here.


882
00:49:13,566 --> 00:49:18,886
We've got of course different
headers in OpenGL3 and so


883
00:49:18,886 --> 00:49:23,546
if you can modify your
code to only include gl3.h


884
00:49:23,546 --> 00:49:28,046
and gl3ext.h you can assure that
your code is building cleanly


885
00:49:28,496 --> 00:49:30,766
and as a result that
you're not calling any calls


886
00:49:30,766 --> 00:49:34,196
that may have been
removed from Core Profile.


887
00:49:34,536 --> 00:49:39,706
And if you are for instance to
call glCallList in Core Profile


888
00:49:39,706 --> 00:49:41,026
that would throw an invalid up.


889
00:49:41,586 --> 00:49:46,516
And so instead of having
to figure out at runtime


890
00:49:46,516 --> 00:49:50,196
where you may have errors
just getting rid of the gl.h


891
00:49:50,196 --> 00:49:52,676
and glext.h in your
file can allow you


892
00:49:52,676 --> 00:49:54,196
to at compile time know


893
00:49:54,196 --> 00:49:57,486
which functionality is
-- needs to be replaced.


894
00:49:58,916 --> 00:50:02,736
Additionally getting extension
strings is slightly different.


895
00:50:03,326 --> 00:50:05,806
Instead of getting one huge
string like you would have


896
00:50:05,806 --> 00:50:10,326
in Legacy Profile it's now
split up into an index string


897
00:50:10,796 --> 00:50:13,876
where you have to get the number
of extensions that are available


898
00:50:14,236 --> 00:50:17,786
and you go through that
loop, and can get each


899
00:50:17,786 --> 00:50:19,216
of the extensions one by one.


900
00:50:20,326 --> 00:50:26,556
And then finally APPLEFence
is replaced by Sync objects.


901
00:50:26,906 --> 00:50:29,126
So say that FenceAPPLE
becomes glFenceSync,


902
00:50:29,996 --> 00:50:34,816
glTestFenceAPPLE gets replaces
with glWaitSync and then some


903
00:50:34,816 --> 00:50:36,766
of the functionality --
some of the functions


904
00:50:37,126 --> 00:50:38,816
like VertexArray
objects are replaced


905
00:50:38,816 --> 00:50:39,926
by the Core equivalents.


906
00:50:39,956 --> 00:50:42,866
So you'll call glVertexArrays
instead


907
00:50:42,866 --> 00:50:45,546
of glGenVertexArraysAPPLE
and so forth.


908
00:50:47,316 --> 00:50:52,066
So of course a lot of you
may have somewhat larger


909
00:50:52,066 --> 00:50:56,106
applications where you can't
just go and switch immediately


910
00:50:56,106 --> 00:50:58,136
from Legacy to Core
Profile context.


911
00:50:58,526 --> 00:51:02,446
For you guys I'm suggesting
a more piecemeal approach.


912
00:51:03,156 --> 00:51:09,126
So really you can do any of
these operations by themselves


913
00:51:09,126 --> 00:51:12,396
and not affect the
rest of your code.


914
00:51:12,716 --> 00:51:15,836
So while still staying on
Legacy Profile we're going


915
00:51:15,836 --> 00:51:19,216
to switch our application
first to wherever we have some


916
00:51:19,216 --> 00:51:21,056
of the older draw calls.


917
00:51:21,426 --> 00:51:24,736
We can replace them with drawing
with vertex buffer objects


918
00:51:24,736 --> 00:51:25,856
and vertex array objects.


919
00:51:26,256 --> 00:51:29,316
And this can be done
to multiple pieces


920
00:51:29,516 --> 00:51:32,396
of code at your own timing.


921
00:51:33,376 --> 00:51:35,656
And you don't need to
switch to Core Profile


922
00:51:35,946 --> 00:51:39,646
to start using vertex arrays
and vertex buffer objects.


923
00:51:40,696 --> 00:51:43,646
Secondly replacing the math.


924
00:51:44,386 --> 00:51:50,856
You can actually use GLKMath
with Legacy OpenGL context.


925
00:51:51,286 --> 00:51:54,586
And it's because it
doesn't really have a --


926
00:51:54,586 --> 00:51:56,436
its profile agnostic.


927
00:51:56,676 --> 00:51:58,076
It just gives you back raw data.


928
00:51:58,756 --> 00:52:04,056
So with that raw data instead
of calling gluPerspective


929
00:52:04,056 --> 00:52:09,156
for instance with the projection
matrix instead I would have my


930
00:52:09,156 --> 00:52:11,676
projection matrix
as just a variable


931
00:52:11,796 --> 00:52:16,326
that I've calculated
on using GLKMath.


932
00:52:17,396 --> 00:52:21,386
And then for instance on
the CPU I may then multiply


933
00:52:21,386 --> 00:52:23,986
that by the ModelViewMatrix
as well


934
00:52:24,066 --> 00:52:25,836
to get my
ModelViewProjectionMatrix


935
00:52:26,266 --> 00:52:27,706
and then once I have
that result --


936
00:52:27,706 --> 00:52:29,546
because I don't need to do


937
00:52:29,546 --> 00:52:31,776
that multiple every single
time in the vertex shader.


938
00:52:32,396 --> 00:52:36,626
I would pass that result in
as a -- just using LoadMatrix.


939
00:52:37,726 --> 00:52:42,846
And so using LoadMatrix
you can pass in those --


940
00:52:43,336 --> 00:52:44,726
the original matrices.


941
00:52:44,726 --> 00:52:53,576
Then for updating your existing
shaders; if you have 110,


942
00:52:54,306 --> 00:52:58,716
150 you can already move your --


943
00:52:58,716 --> 00:53:02,906
while staying in 110 you
can keep your attributes


944
00:53:02,906 --> 00:53:06,836
and replace them with generic
attributes, use uniforms for any


945
00:53:06,836 --> 00:53:10,816
of the built-ins and
by doing so you --


946
00:53:10,816 --> 00:53:17,486
you're getting rid of your
dependency on the built-ins


947
00:53:17,486 --> 00:53:18,926
that were very specific.


948
00:53:19,186 --> 00:53:22,516
Because you can use the
generic attributes with Legacy


949
00:53:22,516 --> 00:53:23,716
and Core Profile alike.


950
00:53:23,916 --> 00:53:26,716
And then additionally EXT
underscore gpu underscore


951
00:53:26,716 --> 00:53:28,536
shader4 enables you
to have your outs --


952
00:53:28,896 --> 00:53:32,826
your out color specified
usingBindFragDataLocation just


953
00:53:32,826 --> 00:53:33,776
like in Core Profile.


954
00:53:34,296 --> 00:53:37,936
So in doing this we can
create our shaders in a way


955
00:53:37,936 --> 00:53:40,886
that even using say
#define to define


956
00:53:40,886 --> 00:53:47,286
in the vertex shader attributes
to end and varying's to out.


957
00:53:47,286 --> 00:53:53,036
And do those #defines such that
you could easily switch your


958
00:53:53,036 --> 00:53:55,916
shaders from 110 to 150
when you do make the switch


959
00:53:55,916 --> 00:53:56,596
to Core Profile.


960
00:53:57,156 --> 00:54:01,136
And then finally for places


961
00:54:01,136 --> 00:54:06,296
where you may have
fixed-function use right now you


962
00:54:06,296 --> 00:54:12,256
will have to make -- you can
make those into GLSL 110 shaders


963
00:54:12,816 --> 00:54:15,426
and do similar things
to what you were doing


964
00:54:15,536 --> 00:54:17,776
with your existing
shaders just before.


965
00:54:18,446 --> 00:54:22,176
And GLKEffects unfortunately
depends on Core Profile.


966
00:54:22,476 --> 00:54:25,166
So this -- to do this
piecemeal you will have


967
00:54:25,256 --> 00:54:28,656
to be replacing your
fixed-function with shaders.


968
00:54:29,536 --> 00:54:34,226
And so you can do any of these
steps above, but one at a time


969
00:54:34,276 --> 00:54:36,816
and check that when
you touch this one file


970
00:54:36,816 --> 00:54:39,266
and replace vertex buffer
objects and vertex array objects


971
00:54:39,266 --> 00:54:42,936
that we're getting the expected
result just like we used to get.


972
00:54:42,936 --> 00:54:46,396
And so we're able to debug our
application on a more piece


973
00:54:46,396 --> 00:54:53,196
by piece basis and not doing
one big switch all at once.


974
00:54:53,196 --> 00:54:56,176
So after you've made all
these changes you switch


975
00:54:56,176 --> 00:54:59,176
to Core Profile by
specifying Core Profile


976
00:54:59,176 --> 00:55:00,436
in your pixel format attribute


977
00:55:01,006 --> 00:55:04,016
and then update your shader
versions ideally with --


978
00:55:04,016 --> 00:55:09,266
by replacing those #defines
with in, outs and so forth.


979
00:55:09,856 --> 00:55:15,476
And just a tip for large code
bases where you may have a bunch


980
00:55:15,476 --> 00:55:20,116
of code that's using
Legacy, OpenGL context calls.


981
00:55:20,766 --> 00:55:25,786
You do a Grep for some of the
streams and tokens that you have


982
00:55:25,836 --> 00:55:30,016
that are referencing like
glBegin, glEnd, glLight


983
00:55:30,756 --> 00:55:34,916
and using that Grep and just
doing a line count you can track


984
00:55:35,426 --> 00:55:38,336
how many lines of code you have
left to switch to Core Profile


985
00:55:38,756 --> 00:55:42,236
and track over time
that adoption.


986
00:55:42,966 --> 00:55:49,376
So to summarize what we went
over today we went over a bunch


987
00:55:49,376 --> 00:55:53,726
of new features in Mavericks and
just how to get access to those


988
00:55:53,726 --> 00:55:55,066
by using the Core Profile.


989
00:55:55,066 --> 00:55:58,616
I also wanted to throw
in a little mention


990
00:55:58,616 --> 00:56:00,236
about OpenGL Profiler here.


991
00:56:00,736 --> 00:56:04,816
It allows you to break on
OpenGL errors for instance


992
00:56:05,076 --> 00:56:07,456
which is very useful for
when doing a transition


993
00:56:07,456 --> 00:56:08,306
to Core Profile.


994
00:56:08,906 --> 00:56:12,186
And so you no longer have to
take glGetError in your code


995
00:56:12,186 --> 00:56:14,386
between every single
place to find out what


996
00:56:14,386 --> 00:56:15,596
where that error's coming from.


997
00:56:16,076 --> 00:56:17,526
And you should never
have glGetError


998
00:56:17,526 --> 00:56:21,126
in shipping code
anyways for release mode.


999
00:56:21,486 --> 00:56:25,966
So instead you can just use
OpenGL Profiler and break


1000
00:56:25,966 --> 00:56:28,736
on GL error as the
screenshot there shows.


1001
00:56:29,656 --> 00:56:33,876
And so finally we did go
over how to use OpenCl


1002
00:56:34,296 --> 00:56:37,476
and OpenGL together in
order to do computes


1003
00:56:37,476 --> 00:56:39,016
and solve your computes needs.


1004
00:56:39,796 --> 00:56:47,316
So if you have any questions
Alan Schafer our Graphics


1005
00:56:47,316 --> 00:56:48,896
and Games Technology Evangelist.


1006
00:56:48,986 --> 00:56:51,196
We've got some great
documentation


1007
00:56:51,676 --> 00:56:54,996
at developer.apple.com/opengl
and then


1008
00:56:54,996 --> 00:56:56,606
of course you can
interact with each other


1009
00:56:56,986 --> 00:57:00,776
at devforums.apple.com.


1010
00:57:00,836 --> 00:57:04,806
And so the related sessions to
this, we had again this morning.


1011
00:57:05,406 --> 00:57:09,246
Dan went over OpenGL ES and
some of the advances there


1012
00:57:09,456 --> 00:57:13,006
such as instancing which is
now available with iOS 7.


1013
00:57:14,056 --> 00:57:18,276
And then Working with OpenCL
as I mentioned earlier is right


1014
00:57:18,276 --> 00:57:20,476
after this talk so stay
put if you're interested


1015
00:57:20,476 --> 00:57:21,986
in learning about using OpenCL.


1016
00:57:23,336 --> 00:57:24,416
So thank you very much.


1017
00:57:25,016 --> 00:57:27,016
[Applause]


1018
00:57:27,016 --> 00:57:32,386
[Silence]

