1
00:00:20,486 --> 00:00:21,196
>> TROY STEPHENS:
Thank you for coming.


2
00:00:22,396 --> 00:00:26,596
Welcome to Session 225, What's
New in NSCollectionView.


3
00:00:27,096 --> 00:00:29,296
My name's Troy Stephens,
I'm a Software Engineer


4
00:00:29,346 --> 00:00:32,116
on the AppKit team and
I'm delighted to get


5
00:00:32,116 --> 00:00:35,626
to answer this question for
you today, what's new indeed.


6
00:00:36,046 --> 00:00:36,886
Let's find out.


7
00:00:38,226 --> 00:00:42,316
NSCollectionView has been around
for a while on OS X since 10.5,


8
00:00:42,316 --> 00:00:46,156
and it provides a handy way
to display a grid of items


9
00:00:46,156 --> 00:00:48,056
in the user interface,
for example here,


10
00:00:48,346 --> 00:00:51,666
in the Screen Saver Pref
panel, we have a grid


11
00:00:51,666 --> 00:00:53,226
of items representing
the different screen


12
00:00:53,226 --> 00:00:54,046
savers available.


13
00:00:54,356 --> 00:00:56,286
CollectionView is good at
this, displaying a grid


14
00:00:56,286 --> 00:00:57,766
of identically sized items,


15
00:00:58,076 --> 00:01:01,336
you give CollectionView an
item prototype, which consists


16
00:01:01,406 --> 00:01:04,025
of basically, a view
subtree of your own design,


17
00:01:04,316 --> 00:01:06,506
and an associated
ViewController that manages it.


18
00:01:07,056 --> 00:01:12,166
CollectionViewclones that item
prototype, to populate itself


19
00:01:12,166 --> 00:01:14,836
with items that represent
your model objects.


20
00:01:15,916 --> 00:01:18,826
CollectionView supports
selection, drag and drop,


21
00:01:18,826 --> 00:01:20,286
animated re-layout, all around,


22
00:01:20,286 --> 00:01:21,936
it is a very handy
class to have around.


23
00:01:22,846 --> 00:01:25,106
Now enter UICollectionView
on iOS,


24
00:01:25,676 --> 00:01:29,156
a cousin to NSCollectionView
that is also very versatile.


25
00:01:29,156 --> 00:01:31,926
We see it here in
the World Clocks part


26
00:01:31,926 --> 00:01:34,506
of the iPad Clocks app.


27
00:01:37,056 --> 00:01:39,336
UI CollectionView,
like its name implies,


28
00:01:39,336 --> 00:01:41,646
is useful for displaying
collections of items,


29
00:01:41,646 --> 00:01:44,186
where each item, once
again, is represented


30
00:01:44,186 --> 00:01:46,856
by a view subtree that's
completely of your own design,


31
00:01:46,856 --> 00:01:49,386
usually, these are loaded from
a nib, withUICollectionView.


32
00:01:50,646 --> 00:01:53,306
And UICollectionView
supports mixing item types,


33
00:01:53,306 --> 00:01:55,866
you can have different nibs,
prototypes for different items,


34
00:01:55,866 --> 00:01:57,106
you're not stuck with just one.


35
00:01:58,926 --> 00:02:01,846
UICollectionView supports
optional header views,


36
00:02:01,886 --> 00:02:04,596
and footer views surrounding
your items, and bracketing them.


37
00:02:05,156 --> 00:02:07,566
This is especially useful
when used in conjunction


38
00:02:07,566 --> 00:02:10,586
with the ability to group your
items into sections if you wish.


39
00:02:10,586 --> 00:02:13,176
Each section can have a
header, and a footer view.


40
00:02:15,326 --> 00:02:18,246
Layout is very flexible
and customizable,


41
00:02:18,246 --> 00:02:21,286
there is a default flow
layout that handles about 90%


42
00:02:21,286 --> 00:02:22,986
of your needs and is
very customizable,


43
00:02:22,986 --> 00:02:26,376
you can tune its parameters to
usually get something close,


44
00:02:26,376 --> 00:02:27,396
at least, to what you want.


45
00:02:28,296 --> 00:02:31,336
UICollectionView is
also open to arbitrary,


46
00:02:31,596 --> 00:02:33,116
developer-definable layouts.


47
00:02:33,156 --> 00:02:35,166
Any kind of layout algorithm
that you can implement,


48
00:02:35,386 --> 00:02:36,866
UICollectionView can use,


49
00:02:36,866 --> 00:02:38,886
to apply to the items
that it shows.


50
00:02:40,666 --> 00:02:43,066
Importantly, UICollectionView
is scalable.


51
00:02:43,506 --> 00:02:46,086
It has smart behaviors in
it, so that it can scale


52
00:02:46,086 --> 00:02:49,166
to potentially large numbers
of items, and it is smart


53
00:02:49,166 --> 00:02:52,716
about just instantiating the
items for model objects in view,


54
00:02:52,996 --> 00:02:55,906
and recycling or reusing items
that have scrolled out of view


55
00:02:55,906 --> 00:02:57,386
to represent other model objects


56
00:02:57,386 --> 00:02:58,696
that have been scrolled
into view.


57
00:02:58,736 --> 00:02:59,556
That's very handy.


58
00:03:01,446 --> 00:03:04,946
Like everything else on iOS,
UICollectionView was designed


59
00:03:04,946 --> 00:03:06,976
from the beginning to
always operate layer-backed,


60
00:03:07,346 --> 00:03:09,516
which gives it the ability
to present very fluid,


61
00:03:09,516 --> 00:03:11,536
high-frame-rate animation,
as the items


62
00:03:11,536 --> 00:03:14,006
in the Collection View move
around, and come and go,


63
00:03:14,176 --> 00:03:16,166
it can give you have a
very nice, animated effect.


64
00:03:16,966 --> 00:03:18,746
With all of these
great features,


65
00:03:19,136 --> 00:03:22,206
and an API that developers have
already become familiar with,


66
00:03:22,696 --> 00:03:26,266
and wide adoption and
use through iOS apps,


67
00:03:26,266 --> 00:03:29,506
we thought that UICollectionView
would therefore form an


68
00:03:29,566 --> 00:03:31,346
excellent basis for the new


69
00:03:31,346 --> 00:03:33,226
and greatly-improved
NSCollectionView


70
00:03:33,226 --> 00:03:35,106
that we're introducing
in El Capitan.


71
00:03:36,136 --> 00:03:38,816
This new NSCollectionView
inherits all


72
00:03:38,816 --> 00:03:41,316
of the scalability
behaviors of UICollectionView.


73
00:03:42,026 --> 00:03:44,756
It knows how to instantiate
items only as needed,


74
00:03:45,126 --> 00:03:47,156
just keeps a few of them
around, a little more


75
00:03:47,156 --> 00:03:51,376
than what's visible and is able
to reuse or recycle items rather


76
00:03:51,376 --> 00:03:52,336
than reinstantiate them.


77
00:03:52,336 --> 00:03:54,986
That saves some overhead, you
can group items in sections,


78
00:03:55,386 --> 00:03:57,316
you can give those sections
header, and footer views,


79
00:03:57,316 --> 00:03:59,256
if you want, put
anything you want in them.


80
00:04:00,266 --> 00:04:02,316
Layout is completely
customizable,


81
00:04:02,316 --> 00:04:05,856
so NSCollectionView is no longer
hard-wired to think I'm a grid.


82
00:04:06,116 --> 00:04:09,496
You can plug any kind of
layout you want into it.


83
00:04:09,866 --> 00:04:13,436
We can handle items that are of
variable sizes, the items can be


84
00:04:13,436 --> 00:04:15,356
of all different types,
you can mix and match,


85
00:04:15,616 --> 00:04:17,786
and Flow Layout especially
is capable


86
00:04:17,786 --> 00:04:19,625
of handling that
very gracefully.


87
00:04:21,296 --> 00:04:23,686
Appearance, as before, it
is completely customizable,


88
00:04:23,686 --> 00:04:25,906
you can define your
Item View subtrees


89
00:04:25,946 --> 00:04:27,186
to look however you want.


90
00:04:28,076 --> 00:04:31,016
The CollectionView is your blank
canvas, to use however you want.


91
00:04:31,616 --> 00:04:34,496
You have control
over animations.


92
00:04:34,496 --> 00:04:37,226
When animations are performed,
and with what durations.


93
00:04:37,546 --> 00:04:38,466
We'll see how to do that.


94
00:04:39,426 --> 00:04:42,326
Of course, not content to
just port UICollectionViews


95
00:04:42,326 --> 00:04:44,036
capabilities to OS X, we wanted


96
00:04:44,036 --> 00:04:46,816
to make the new NSCollectionView
feel really right


97
00:04:46,816 --> 00:04:48,066
at home on the desktop.


98
00:04:48,306 --> 00:04:50,016
One of the important
technologies we deal


99
00:04:50,016 --> 00:04:51,756
with on the desktop
is drag and drop


100
00:04:51,756 --> 00:04:54,126
which NSCollectionView
has supported all along,


101
00:04:54,496 --> 00:04:57,396
but as part of bringing
UICollectionView Layout API


102
00:04:58,036 --> 00:05:02,136
to the desktop, we have
augmented the API with a couple


103
00:05:02,136 --> 00:05:03,816
of new methods we'll
talk about at the end,


104
00:05:04,116 --> 00:05:05,896
that basically enable
any layout,


105
00:05:06,146 --> 00:05:10,766
including your own custom
layouts, to perform hit-testing


106
00:05:10,766 --> 00:05:13,026
to identify drop
target candidates.


107
00:05:13,156 --> 00:05:14,386
We'll look at how
to do that later.


108
00:05:15,006 --> 00:05:18,936
Any custom layout of your own
design can support Drag-and-Drop


109
00:05:19,286 --> 00:05:20,316
like a first class layout.


110
00:05:21,046 --> 00:05:24,066
Rubber Band Drag Select, you
use that to drag across items,


111
00:05:24,066 --> 00:05:25,836
and select groups
of items in bulk,


112
00:05:26,666 --> 00:05:28,526
that's fully supported
as before.


113
00:05:28,876 --> 00:05:30,686
We have modified the selection


114
00:05:30,686 --> 00:05:33,106
and highlight notification
methods, the delegate methods,


115
00:05:33,106 --> 00:05:37,156
that handle those occurrences,
to be able to handle selection


116
00:05:37,156 --> 00:05:39,186
and highlighting of items in
bulk because that's something


117
00:05:39,186 --> 00:05:41,196
that tends to happen a lot
more on the desktop, you know,


118
00:05:41,196 --> 00:05:44,216
you tend to do a Select All
operation or a Deselect All,


119
00:05:44,356 --> 00:05:45,466
or a big Range Select.


120
00:05:45,466 --> 00:05:47,586
We wanted to be able to
handle those very efficiently.


121
00:05:47,796 --> 00:05:49,956
There is slight adjustments
to the APIs.


122
00:05:50,786 --> 00:05:54,076
As before, however, items
are still represented using


123
00:05:54,076 --> 00:05:55,646
ViewControllers on the desktop.


124
00:05:55,646 --> 00:05:58,106
We think this provides a
great opportunity for you


125
00:05:58,106 --> 00:06:00,596
to compartmentalize
your code neatly,


126
00:06:00,876 --> 00:06:03,496
and have your controller code
separate from your view code.


127
00:06:04,086 --> 00:06:05,486
Better code organization.


128
00:06:06,806 --> 00:06:09,406
One last nice little touch
we added, is the ability


129
00:06:09,406 --> 00:06:10,566
for CollectionView


130
00:06:10,566 --> 00:06:12,766
to automatically find the
appropriate nibs to use


131
00:06:12,766 --> 00:06:14,716
for items, if you just
follow naming conventions,


132
00:06:14,916 --> 00:06:17,536
if you name the nib
identical to the identifier


133
00:06:17,536 --> 00:06:18,966
of the item type
you're requesting


134
00:06:18,966 --> 00:06:20,506
from the CollectionView,
you don't even have


135
00:06:20,546 --> 00:06:24,216
to register your item nibs with
the CollectionView anymore.


136
00:06:24,306 --> 00:06:27,386
It saves you a little
work, a little bit of code.


137
00:06:27,596 --> 00:06:29,226
So our goals for
today, I wanted this


138
00:06:29,226 --> 00:06:31,796
to be a really hands-on session,
I want you to walk away ready


139
00:06:31,796 --> 00:06:32,916
to use the new CollectionView.


140
00:06:33,196 --> 00:06:37,296
We'll look at how to wire up one
of these new NSCollectionViews,


141
00:06:37,296 --> 00:06:40,996
where we're using the new
API on 10.11, along the way,


142
00:06:41,296 --> 00:06:44,516
we'll learn what's different
on OS X versus on iOS,


143
00:06:44,516 --> 00:06:46,216
and we'll have a
little something


144
00:06:46,216 --> 00:06:47,426
for everybody here I think.


145
00:06:47,676 --> 00:06:49,806
Whether you're a
veteran iOS developer,


146
00:06:50,156 --> 00:06:52,306
maybe bringing companion
apps over to OS X,


147
00:06:52,306 --> 00:06:54,896
you have used UI CollectionView,
you're familiar with the API,


148
00:06:55,426 --> 00:06:57,916
you want to port that knowledge
over, maybe some code over,


149
00:06:57,966 --> 00:07:00,236
we'll have information
useful to you.


150
00:07:01,266 --> 00:07:03,266
Maybe you're an OS
X developer working


151
00:07:03,296 --> 00:07:05,606
with NSCollectionView
already, and you want


152
00:07:05,606 --> 00:07:08,296
to learn the new API
paradigms and how to do that.


153
00:07:08,296 --> 00:07:09,666
We'll have enough
of an introduction


154
00:07:09,666 --> 00:07:12,316
into the UICollectionView
APIs to get you started.


155
00:07:13,596 --> 00:07:16,396
But even if you've not worked
with either before we're going


156
00:07:16,396 --> 00:07:18,856
to have enough introduction,
and enough nuts and bolts


157
00:07:18,856 --> 00:07:21,816
and a code sample, to go
along with today's session


158
00:07:21,816 --> 00:07:24,726
that you can study, to learn how
to get up and running quickly


159
00:07:24,726 --> 00:07:25,716
with the new CollectionView.


160
00:07:26,606 --> 00:07:29,466
We'll start with a quick
overview of the concepts,


161
00:07:29,466 --> 00:07:31,886
the basic concepts that we need
to understand about the new API


162
00:07:31,886 --> 00:07:34,986
and then we'll dive into nuts
and bolts of how the API works,


163
00:07:34,986 --> 00:07:37,266
which methods are important,
what to use, and we'll wrap


164
00:07:37,266 --> 00:07:38,396
up with a quick conclusion.


165
00:07:38,856 --> 00:07:40,116
First with that overview.


166
00:07:40,916 --> 00:07:44,946
In the old model of using
CollectionView, NSCollectionView


167
00:07:44,946 --> 00:07:46,686
on OS X 10.10 and earlier,


168
00:07:47,206 --> 00:07:48,986
you would wire your
CollectionView's content


169
00:07:48,986 --> 00:07:51,156
property to an array
or array controller


170
00:07:51,156 --> 00:07:53,626
that references your model
objects, that's how you wire


171
00:07:53,626 --> 00:07:55,996
up your model, and you
provide an item prototype,


172
00:07:56,116 --> 00:07:59,296
that's an NSCollectionView item,
a subclass of ViewControllers,


173
00:07:59,296 --> 00:08:00,536
you have basically
got a ViewController,


174
00:08:00,826 --> 00:08:03,596
and an associated view subtree,
and this is what's going


175
00:08:03,596 --> 00:08:05,716
to get cloned to populate
your CollectionView.


176
00:08:06,396 --> 00:08:08,546
Lastly, yourCollectionView
might have a delegate,


177
00:08:08,546 --> 00:08:09,956
if you want to support
Drag-and-Drop,


178
00:08:10,286 --> 00:08:12,066
that's your delegate's
responsibility,


179
00:08:12,346 --> 00:08:15,226
so you would wire up
a delegate for that.


180
00:08:15,546 --> 00:08:17,776
With the new API, a few of
these things have changed.


181
00:08:17,776 --> 00:08:20,786
Instead of providing a content
array, what you are going


182
00:08:20,786 --> 00:08:24,256
to do now on El Capitan,
is wire up a data source.


183
00:08:24,486 --> 00:08:27,446
The data source protocol for
CollectionView is very simple,


184
00:08:27,446 --> 00:08:29,656
as in iOS there are only
two required methods,


185
00:08:29,846 --> 00:08:32,056
it's very quick and easy
as you will see to wire


186
00:08:32,056 --> 00:08:33,686
up your model to CollectionView.


187
00:08:34,926 --> 00:08:36,546
You still have a
delegate, as before,


188
00:08:36,616 --> 00:08:39,496
but now the delegate has the
opportunity to participate


189
00:08:39,496 --> 00:08:41,376
in selection and
highlighting of items.


190
00:08:41,376 --> 00:08:42,775
We'll talk about
that in detail later.


191
00:08:43,226 --> 00:08:46,526
Instead of an item prototype
you now typically provide a nib


192
00:08:46,526 --> 00:08:49,386
file, that hasyour
example item in it,


193
00:08:49,386 --> 00:08:51,016
and it's associatedview subtree.


194
00:08:51,276 --> 00:08:53,646
You're not limited to just one
of these, as I said, you can mix


195
00:08:53,646 --> 00:08:54,956
and match different
types of items,


196
00:08:54,956 --> 00:08:57,286
you can have multiple nib files,
one for for each type of item


197
00:08:57,596 --> 00:09:00,406
and the view trees can be
completely different for these.


198
00:09:00,896 --> 00:09:03,176
Last but not least,
very importantly,


199
00:09:03,756 --> 00:09:06,606
we have taken the layout
functionality and factored it


200
00:09:06,606 --> 00:09:08,896
out of CollectionView so
it is no longer hard wired.


201
00:09:08,896 --> 00:09:11,536
We now have a very
modular model, like on iOS,


202
00:09:12,216 --> 00:09:14,086
so you can take your
existing CollectionView,


203
00:09:14,416 --> 00:09:16,716
unplug the layout that's
currently connected to it,


204
00:09:16,956 --> 00:09:20,556
plug in a different layout, and
suddenly your items are laid


205
00:09:20,556 --> 00:09:23,246
out with different sizes using
a completely different layout


206
00:09:23,246 --> 00:09:26,536
algorithm, and these layouts
are completely interchangeable,


207
00:09:26,536 --> 00:09:28,666
nd you can even make the
change to a different layout


208
00:09:28,886 --> 00:09:31,146
in an animated-transition
kind of way.


209
00:09:31,186 --> 00:09:34,066
very easily, as ourcode
sample does.


210
00:09:34,736 --> 00:09:37,996
For customizing layout, your
layout can also delegate


211
00:09:37,996 --> 00:09:39,456
to your CollectionViews
delegate.


212
00:09:39,456 --> 00:09:42,016
You can implement certain
optional methods to allow you


213
00:09:42,016 --> 00:09:43,886
to make per-item
layout adjustments.


214
00:09:43,886 --> 00:09:45,826
You don't even necessarily
have to subclass,


215
00:09:46,096 --> 00:09:47,216
if you want a custom layout.


216
00:09:48,036 --> 00:09:49,836
We'll take a quick look
at the layout classes.


217
00:09:49,836 --> 00:09:52,076
These arevery similar but
not identical, on iOS.


218
00:09:52,076 --> 00:09:54,616
As on iOS,
NSCollectionViewLayout,


219
00:09:54,616 --> 00:09:57,556
his is the base class that
defines the common behavior,


220
00:09:57,556 --> 00:09:59,396
the API interface
for all layouts.


221
00:10:00,446 --> 00:10:03,396
NSCollectionViewGridLayout
is new and unique to OS X


222
00:10:03,396 --> 00:10:06,686
and its job is basically
encapsulate NSCollectionView's


223
00:10:06,686 --> 00:10:09,756
existing, sort of stretchy
grid layout algoritm,


224
00:10:09,956 --> 00:10:12,296
in case you want to use
it with the new APIs.


225
00:10:12,296 --> 00:10:15,636
It gives you a stretchy
grid, where it tries


226
00:10:15,636 --> 00:10:19,836
to make all items the same
size, but they're limited to min


227
00:10:19,836 --> 00:10:21,136
and max sizes, and it tries


228
00:10:21,186 --> 00:10:23,896
to basically fill its visible
area as much as possible.


229
00:10:24,456 --> 00:10:26,306
Sometimes useful,
but this is sort


230
00:10:26,306 --> 00:10:27,666
of a legacy layout right now.


231
00:10:27,716 --> 00:10:30,446
It doesn't yet support sections
or header or footer views


232
00:10:30,756 --> 00:10:33,216
and FlowLayout is
generally much more flexible.


233
00:10:34,036 --> 00:10:35,846
We usually recommend that
you you start with that.


234
00:10:35,846 --> 00:10:38,266
NSCollectionViewFlowLayout
is basically identical


235
00:10:38,496 --> 00:10:41,776
to UICollectionViewFlowLayout
on iOS, it's a very powerful,


236
00:10:41,776 --> 00:10:45,326
general layout algorithm,
and the algorithm is much


237
00:10:45,326 --> 00:10:49,636
like flowing text fragments
or CSS boxes in flow,


238
00:10:49,636 --> 00:10:51,406
if you've dealt with
either of those problems.


239
00:10:51,596 --> 00:10:53,906
Basically, you can have
variable item sizes,


240
00:10:54,136 --> 00:10:56,416
and the layout algorithm
canhandle that nicely.


241
00:10:56,696 --> 00:10:59,626
It willrack up items
into rows or columns,


242
00:10:59,626 --> 00:11:01,576
depending which orientation
you give it.


243
00:11:01,996 --> 00:11:03,656
When it fills up
a row or column,


244
00:11:03,656 --> 00:11:05,716
it'll wrap to a new
one and continue on.


245
00:11:06,116 --> 00:11:08,986
FlowLayout supports
sections with optional header


246
00:11:08,986 --> 00:11:11,306
and footer views, and it
is generally very powerful


247
00:11:11,306 --> 00:11:13,706
and customizable, so even
if you do need to subclass,


248
00:11:15,026 --> 00:11:17,266
usually you'll want to start
with FlowLayout, and subclass


249
00:11:17,266 --> 00:11:18,596
from there to get what you want.


250
00:11:18,596 --> 00:11:21,986
You're always free to subclass
NSCollectionViewLayout,


251
00:11:22,646 --> 00:11:24,406
to get a completely
custom layout.


252
00:11:24,486 --> 00:11:28,186
Our sample code todaydoes
just that.


253
00:11:28,396 --> 00:11:32,146
Layout attributes objects aren't
always immediately intuitive


254
00:11:32,146 --> 00:11:34,326
to those who look at
them for the first time.


255
00:11:34,326 --> 00:11:36,676
This is a concept -- the
same concept as on iOS,


256
00:11:37,206 --> 00:11:39,456
and once you understand what it
is, it really is very simple.


257
00:11:40,276 --> 00:11:42,946
Imagine that you can
take a view's frame


258
00:11:43,246 --> 00:11:44,916
and other assorted properties


259
00:11:44,916 --> 00:11:47,306
and encapsulate them
separately from the view.


260
00:11:47,306 --> 00:11:49,846
That's what LayoutAttributes'
job is.


261
00:11:49,846 --> 00:11:51,746
You have an instance
of these frames,


262
00:11:51,746 --> 00:11:53,026
the most obvious one , right?


263
00:11:53,026 --> 00:11:56,496
you need to know the
position and size of an item,


264
00:11:56,766 --> 00:11:59,376
but there are other ancillary
attributes, such as Alpha value,


265
00:11:59,376 --> 00:12:03,036
Opacity in other words, Zindex
for back-to-front sort order,


266
00:12:03,976 --> 00:12:05,536
and whether the view
is hidden or not,


267
00:12:05,536 --> 00:12:07,586
which can also be
considered layout state.


268
00:12:07,586 --> 00:12:09,426
You're taking state,
and snapshotting it,


269
00:12:09,646 --> 00:12:13,666
what this enables the new APIs
to do, is to reason about items


270
00:12:13,916 --> 00:12:15,846
that are not currently
instantiated.


271
00:12:15,846 --> 00:12:18,446
Remember, we're just lazily
instantiating items on demand.


272
00:12:19,146 --> 00:12:21,526
We end up creating these,
and passing them around,


273
00:12:21,526 --> 00:12:23,066
these layout attributes
instances,


274
00:12:23,286 --> 00:12:26,316
that's what the Layout APIs
deal with, they pass them around


275
00:12:26,536 --> 00:12:29,066
and then eventually they end
up getting applied to items


276
00:12:29,066 --> 00:12:30,246
or views at layout time.


277
00:12:30,396 --> 00:12:33,406
Applied in the sense of
setting an animation target


278
00:12:33,406 --> 00:12:35,066
for a transition to a new state.


279
00:12:35,426 --> 00:12:36,496
That's all they are really.


280
00:12:37,036 --> 00:12:40,986
You can group items, that's
pretty straightforward,


281
00:12:40,986 --> 00:12:43,136
you can break your items
up into groups now,


282
00:12:43,336 --> 00:12:47,116
each group can potentially
have a header above it,


283
00:12:47,116 --> 00:12:49,746
and a footer below it, or
this also works sideways,


284
00:12:49,746 --> 00:12:51,446
ifyou're doing that orientation.


285
00:12:52,246 --> 00:12:54,556
The header, and footer,
together with the items


286
00:12:54,556 --> 00:12:56,226
that they bracket,
constitute a section,


287
00:12:56,226 --> 00:12:58,066
our first section
here is section 0.


288
00:12:58,376 --> 00:13:01,826
The items within that section
are numbered 0, 1, 2, so on.


289
00:13:02,506 --> 00:13:04,166
This is exactly the
same as on iOS.


290
00:13:04,626 --> 00:13:06,516
The next section can have
a header, a footer view,


291
00:13:06,936 --> 00:13:09,176
together with the items,
now we've got section 1


292
00:13:09,176 --> 00:13:12,216
and the items in that
section are again numbered 0,


293
00:13:12,306 --> 00:13:13,806
1, 2, and so forth.


294
00:13:14,526 --> 00:13:17,736
So clearly we have a need for a
different way to address items.


295
00:13:17,736 --> 00:13:19,996
We're going to start addressing
items like we do on iOS.


296
00:13:19,996 --> 00:13:21,826
We need to know not
only the item index,


297
00:13:22,176 --> 00:13:23,356
but the section index.


298
00:13:23,736 --> 00:13:26,506
This has consequences for
existing APIs, and accounts


299
00:13:26,506 --> 00:13:28,826
for a lot of the API
changes that you will see.


300
00:13:29,346 --> 00:13:31,296
For example, the
ItemAtIndex method,


301
00:13:31,296 --> 00:13:33,656
which takes a single-integer
index,


302
00:13:33,656 --> 00:13:36,326
is no longer sufficient.Now
that we have sections,


303
00:13:36,326 --> 00:13:37,736
we need to know the
section number too.


304
00:13:38,186 --> 00:13:41,346
So APIs like this are now
soft-deprecated in favor of ones


305
00:13:41,386 --> 00:13:43,306
that take index paths.


306
00:13:43,306 --> 00:13:46,016
And NSIndexPath is just
an existing value type


307
00:13:46,016 --> 00:13:49,286
that lets us very conveniently
encapsulate a section index,


308
00:13:49,286 --> 00:13:52,306
and an item index, together
in an object, a value object


309
00:13:52,506 --> 00:13:54,926
that we can pass around,
throw into collections, so on.


310
00:13:55,266 --> 00:13:57,696
A lot of the API changes you
will see actually are just


311
00:13:57,696 --> 00:13:59,806
accountfor this simple
transition away


312
00:13:59,806 --> 00:14:01,096
from single item indices.


313
00:14:01,416 --> 00:14:03,176
You can still use the old APIs


314
00:14:03,406 --> 00:14:05,626
if you have a single-section
CollectionView,


315
00:14:05,626 --> 00:14:08,536
which is the default, but if
you might be using sections,


316
00:14:08,806 --> 00:14:12,516
we encourage you to
use the new APIs.


317
00:14:12,686 --> 00:14:14,586
We're obviously starting
to get into nuts and bolts,


318
00:14:14,586 --> 00:14:18,616
we'll embrace that, and get down
to looking at our example code.


319
00:14:18,616 --> 00:14:20,906
The example today is
CocoaSlideCollection,


320
00:14:20,906 --> 00:14:22,426
and it's basically
an image browser


321
00:14:22,646 --> 00:14:25,696
that uses a CollectionView
to present a folder


322
00:14:25,696 --> 00:14:28,206
of ImageFiles for
you to look at.


323
00:14:28,816 --> 00:14:30,456
For each ImageFile
in the folder,


324
00:14:30,456 --> 00:14:34,156
we show a thumbnail image
and assorted image info.


325
00:14:34,716 --> 00:14:40,106
We position these using the
Flow layout that comes stock


326
00:14:40,106 --> 00:14:42,016
on the system, and our
own custom layouts,


327
00:14:42,016 --> 00:14:43,076
that you will see
how to implement.


328
00:14:43,596 --> 00:14:46,556
We're going to suppose that each


329
00:14:46,556 --> 00:14:49,036
of our Image Files can have
tags associated with it


330
00:14:49,036 --> 00:14:51,026
and we're going to
use that as an excuse


331
00:14:51,026 --> 00:14:53,186
to show off the ability to
have sections with headers


332
00:14:53,186 --> 00:14:57,916
and footers, we're going to be
able togroup our items by tag.


333
00:14:57,916 --> 00:15:00,456
We'll also support
selection and Drag-and-Drop


334
00:15:00,456 --> 00:15:03,536
of our items using the APIs
that we'll discuss today.


335
00:15:04,636 --> 00:15:06,556
To break this down into
parts, we'll break it


336
00:15:06,556 --> 00:15:09,406
down into six parts, so we
can do this step by step.


337
00:15:09,686 --> 00:15:11,646
First, of course, we want
to make items appear.


338
00:15:11,646 --> 00:15:12,586
That's always nice.


339
00:15:12,586 --> 00:15:13,536
That's the big hurdle.


340
00:15:13,806 --> 00:15:16,146
When you get stuff to show
up, you can get more advanced.


341
00:15:16,146 --> 00:15:17,246
We'll do that quickly.


342
00:15:17,826 --> 00:15:20,146
Thenwe'll look at grouping
those items into sections.


343
00:15:20,976 --> 00:15:23,056
Next we want to look
at how do we handle it


344
00:15:23,056 --> 00:15:25,616
when the model changes,
the ImageFiles come and go,


345
00:15:25,616 --> 00:15:27,026
how do we update
our CollectionView.


346
00:15:27,026 --> 00:15:28,426
We'll see how to
do that properly.


347
00:15:28,426 --> 00:15:30,716
We'll look at handling
selection, and highlighting,


348
00:15:30,716 --> 00:15:33,666
of the semantics of that,
handling Drag-and-Drop and last


349
00:15:33,666 --> 00:15:35,646
but not least, the really
fun part, we'll look at how


350
00:15:35,646 --> 00:15:37,326
to make custom layouts
of ourown.


351
00:15:37,746 --> 00:15:40,926
First, making items appear,
back to our model here.


352
00:15:40,926 --> 00:15:42,286
This is the new API again.


353
00:15:42,966 --> 00:15:44,486
We need to provide a data source


354
00:15:44,616 --> 00:15:46,526
that implements those
two required methods.


355
00:15:47,366 --> 00:15:50,246
We'll need to provide an
item nib, simple enough.


356
00:15:50,356 --> 00:15:51,906
Then a CollectionView layout.


357
00:15:53,146 --> 00:15:56,246
The two required methods are
simply give the CollectionView


358
00:15:56,246 --> 00:15:59,316
the ability to ask how many
items are in this section,


359
00:15:59,316 --> 00:16:01,486
by default we have one
section, it is going to pass 0


360
00:16:01,486 --> 00:16:03,706
for the section index, it'll
just return the number of items.


361
00:16:04,276 --> 00:16:06,386
The second method's
responsibility,


362
00:16:06,386 --> 00:16:09,136
is to actually instantiate
items,


363
00:16:09,136 --> 00:16:11,866
or it could be actually
reusing the recycled items


364
00:16:11,866 --> 00:16:14,446
under the hood, with help
from the CollectionView


365
00:16:14,446 --> 00:16:15,816
and return them back
to the CollectionView.


366
00:16:16,376 --> 00:16:20,516
In CocoaSlideCollection
our basic model object


367
00:16:20,516 --> 00:16:22,066
to understand is the ImageFile.


368
00:16:22,796 --> 00:16:26,686
An ImageFile basically
references a URL of an ImageFile


369
00:16:26,686 --> 00:16:28,646
that we found on disk in
the folder we're scanning,


370
00:16:28,646 --> 00:16:30,606
that includes the file name
that we're displaying at the top


371
00:16:30,606 --> 00:16:32,956
of the slide, the file's type


372
00:16:33,016 --> 00:16:35,796
which we displayed a
user-readable description of,


373
00:16:36,096 --> 00:16:38,126
the pixel dimensions
of the original image,


374
00:16:39,056 --> 00:16:40,706
then a thumbnail, of course.


375
00:16:41,196 --> 00:16:44,866
You will see those
around in the source code.


376
00:16:45,306 --> 00:16:48,136
An image collection owns
an array of ImageFiles,


377
00:16:48,136 --> 00:16:51,386
An image collection also
owns an array of tags,


378
00:16:51,386 --> 00:16:53,596
each of which owns an array
of ImageFiles that have


379
00:16:53,596 --> 00:16:56,716
that tag applied, and there is
an untagged ImageFiles array


380
00:16:56,716 --> 00:16:57,136
as well.


381
00:16:57,946 --> 00:17:00,176
First we'll look at
making items appear.


382
00:17:00,176 --> 00:17:01,516
We'll go over to the
demo machine here.


383
00:17:02,746 --> 00:17:05,215
Let's get this up and running.


384
00:17:05,386 --> 00:17:06,796
We'll open our Xcode project.


385
00:17:09,256 --> 00:17:12,836
Things are, you know,
mostly ready to go,


386
00:17:12,836 --> 00:17:14,566
but we have no CollectionView
in our window.


387
00:17:14,566 --> 00:17:15,636
That's going to be a problem.


388
00:17:15,636 --> 00:17:17,695
We'll look at how to
actually get a CollectionView.


389
00:17:19,536 --> 00:17:23,066
So going into our
Resources group here.


390
00:17:23,066 --> 00:17:25,996
We have a BrowserWindow nib
that holds our main window.


391
00:17:27,086 --> 00:17:29,186
Let's look at that.


392
00:17:29,456 --> 00:17:35,326
We'll go in the library here,
and search for a CollectionView.


393
00:17:35,776 --> 00:17:42,346
We'll drag it out.


394
00:17:42,646 --> 00:17:44,256
We'll size it to
fill our window.


395
00:17:45,766 --> 00:17:46,956
Apply constraints to it.


396
00:17:47,066 --> 00:17:53,736
That's going to be our main
document view for this window.


397
00:17:53,736 --> 00:17:57,866
Okay. Now what we did, what we
actually got when we dragged


398
00:17:57,866 --> 00:17:59,656
out a CollectionView,
this is a lot like working


399
00:17:59,746 --> 00:18:02,436
with a Table View
or Outline View,


400
00:18:02,816 --> 00:18:04,716
you're actually getting
a CollectionView embedded


401
00:18:04,716 --> 00:18:06,466
in a scroll view unlike on iOS.


402
00:18:06,656 --> 00:18:09,466
Scroll view is a separate
thing that's composed


403
00:18:09,466 --> 00:18:11,046
with a document view
that you want to scroll,


404
00:18:11,046 --> 00:18:12,596
you don't inherit the
scrolling behavior,


405
00:18:12,596 --> 00:18:13,786
it is done through composition.


406
00:18:14,996 --> 00:18:15,906
We have a scroll view.


407
00:18:15,996 --> 00:18:18,686
I said that the new
CollectionView is designed


408
00:18:18,686 --> 00:18:20,596
to run layer-backs, we're
going to go over here


409
00:18:20,596 --> 00:18:24,106
to our inspector, and we'll set
the [indecipherable] property


410
00:18:24,106 --> 00:18:26,416
on the scroll view to
ensure layer-backing.


411
00:18:27,126 --> 00:18:29,666
Now, we'll drill down to
the CollectionView itself,


412
00:18:29,666 --> 00:18:32,586
which is the scroll
view's document view.


413
00:18:32,586 --> 00:18:35,056
We have a new properties
inspector here in Xcode 7


414
00:18:35,056 --> 00:18:36,706
that supports some of
the new capabilities.


415
00:18:36,706 --> 00:18:39,406
We choose a layout we
want to use, such as Flow,


416
00:18:39,406 --> 00:18:40,726
and even set its properties.


417
00:18:41,116 --> 00:18:42,536
In this sample app
we're actually going


418
00:18:42,536 --> 00:18:44,326
to switch programmatically
between the layouts,


419
00:18:44,326 --> 00:18:46,546
so we don't really need the one
with we unarchived from the nib,


420
00:18:46,956 --> 00:18:48,156
but we can set that there.


421
00:18:48,486 --> 00:18:52,086
You can do fun, simple things,
like set the background color,


422
00:18:52,346 --> 00:18:59,296
as soon as I find
the color panel.


423
00:18:59,536 --> 00:19:00,976
The more interesting thing,
is that you have to hook


424
00:19:00,976 --> 00:19:02,126
up that data source, right?


425
00:19:02,956 --> 00:19:08,286
So, our file's owner in
this project is an instance


426
00:19:08,426 --> 00:19:10,626
of APL Browser Window
Controller.


427
00:19:10,696 --> 00:19:12,466
We have a window controller
that manages the window,


428
00:19:12,466 --> 00:19:14,466
that's also going tp be our
data source, and our delegate


429
00:19:14,466 --> 00:19:15,386
for our CollectionView.


430
00:19:15,386 --> 00:19:18,836
We'll wire that up here
from the CollectionView


431
00:19:18,996 --> 00:19:20,066
to the file's owner, it's going


432
00:19:20,066 --> 00:19:21,686
to be the CollectionView's
data source.


433
00:19:21,816 --> 00:19:24,596
It will be its delegate too, to
so we can handle Drag-and-Drop,


434
00:19:25,056 --> 00:19:27,246
we'll wire from the file's owner
back to the CollectionView,


435
00:19:27,246 --> 00:19:30,066
we have an ImageCollectionView
outlet that we've defined


436
00:19:30,066 --> 00:19:32,056
to make it easier to
find our CollectionView.


437
00:19:33,486 --> 00:19:36,416
That's basically what we
need to do in our nibs.


438
00:19:36,776 --> 00:19:39,296
We have also got a slide
nib that we created.


439
00:19:39,836 --> 00:19:43,686
It holds basically a container
view that's referenced


440
00:19:43,686 --> 00:19:48,046
by a slide, our slide class
is a subclass of collection,


441
00:19:48,046 --> 00:19:49,216
NSCollectionViewItems.


442
00:19:49,216 --> 00:19:51,916
We've subclassed so we can
add some functionality there,


443
00:19:51,916 --> 00:19:53,716
our own custom controller
functionality,


444
00:19:54,226 --> 00:19:56,856
the root view is just a
container that will be sized


445
00:19:57,116 --> 00:19:58,976
by the CollectionView's
layout algorithm.


446
00:19:59,456 --> 00:20:00,796
Then, we have controls,


447
00:20:00,796 --> 00:20:06,506
text fields that have autolayout
constraints set on them,


448
00:20:06,506 --> 00:20:07,756
relative to their containers.


449
00:20:07,756 --> 00:20:11,046
The layout will set the frame of
the item, the item's root view,


450
00:20:11,276 --> 00:20:13,816
and the rest will all be done
by autolayout internally.


451
00:20:14,296 --> 00:20:16,466
I have also used bindings


452
00:20:16,526 --> 00:20:21,076
to basically connect the
value displayed by each


453
00:20:21,076 --> 00:20:25,186
of these text fields, through
the slides-represented object.


454
00:20:25,186 --> 00:20:27,746
Remember a slide is a
CollectionView item,


455
00:20:28,116 --> 00:20:29,236
therefore it is a
ViewController,


456
00:20:29,236 --> 00:20:30,946
ViewController has a
represented object.


457
00:20:30,946 --> 00:20:32,786
That's where we're going
to connect our item


458
00:20:33,096 --> 00:20:34,816
to the model object
it represents,


459
00:20:34,816 --> 00:20:36,196
to the ImageFile instance.


460
00:20:36,626 --> 00:20:38,596
We can access properties
of that instance.


461
00:20:39,036 --> 00:20:41,466
All we really are going to
need to do is wire our item


462
00:20:41,466 --> 00:20:44,676
up to the represented object,
i.e. its ImageFile, and then all


463
00:20:44,676 --> 00:20:46,186
of these controls
will just populate,


464
00:20:46,186 --> 00:20:47,976
including the image
view over here.


465
00:20:48,696 --> 00:20:52,836
Because we're using a separate
nib file for the modern API


466
00:20:53,046 --> 00:20:55,876
for CollectionView, we're
going to prune some stuff


467
00:20:55,936 --> 00:20:58,516
that Xcode put in
here by default still.


468
00:20:58,816 --> 00:21:01,566
Our image CollectionView
still has an item prototype.


469
00:21:02,516 --> 00:21:03,546
We want to get rid of that.


470
00:21:03,546 --> 00:21:04,336
Let's unwire it.


471
00:21:05,626 --> 00:21:07,176
That will interfere
with what we're doing.


472
00:21:07,466 --> 00:21:08,856
We'll delete the item prototype,


473
00:21:08,856 --> 00:21:10,736
we'll delete the views
associated with it.


474
00:21:10,736 --> 00:21:11,596
We don't need those.


475
00:21:12,096 --> 00:21:14,056
We can build and
we're almost okay.


476
00:21:14,686 --> 00:21:16,656
If we look in the warnings
here, we see a reminder,


477
00:21:16,656 --> 00:21:19,616
we didn't implement the
required data source methods,


478
00:21:19,616 --> 00:21:21,586
there are just two of them, so
let's go do that real quick.


479
00:21:22,646 --> 00:21:24,166
We'll go to Browser
Window Controller.


480
00:21:24,796 --> 00:21:28,866
Look here, where the data
source methods should be.


481
00:21:28,926 --> 00:21:34,476
Fortunately I typed
some in advance.


482
00:21:34,476 --> 00:21:39,606
We'll just drag in.


483
00:21:39,996 --> 00:21:42,026
For a non-section CollectionView
this is very simple,


484
00:21:42,026 --> 00:21:44,686
we implement CollectionView,
number of items in section


485
00:21:44,686 --> 00:21:46,776
by default, the CollectionView
assumes one section,


486
00:21:47,066 --> 00:21:48,866
we return the count
of ImageFiles


487
00:21:49,146 --> 00:21:51,766
in our image collection,
and the other thing we need


488
00:21:51,766 --> 00:21:53,566
to do is make items on demand.


489
00:21:53,626 --> 00:21:55,826
The CollectionView will
send us CollectionView Item


490
00:21:55,826 --> 00:21:57,566
For Represented Object
At Index Path.


491
00:21:58,206 --> 00:21:59,826
The important thing here
is that we're calling back


492
00:21:59,896 --> 00:22:01,416
to the CollectionView,
and saying make item


493
00:22:01,416 --> 00:22:03,616
with identifier, which
is a little misleading,


494
00:22:03,616 --> 00:22:05,186
make really means
make or give me


495
00:22:05,186 --> 00:22:08,866
than existing one you can
recycle for index path.


496
00:22:08,866 --> 00:22:10,836
We just pass in the index
path that we were given,


497
00:22:10,836 --> 00:22:11,986
that identifies the item.


498
00:22:12,876 --> 00:22:15,646
As I said, we want to wire up
the items represented objects,


499
00:22:15,646 --> 00:22:18,096
so we can find the corresponding
properties to display just


500
00:22:18,096 --> 00:22:19,156
for that item instance.


501
00:22:19,156 --> 00:22:22,406
We've got a little method
here that we factored out,


502
00:22:22,406 --> 00:22:24,526
ImageFile At Index
Path, that lets us dig


503
00:22:24,526 --> 00:22:25,956
into our data model real simply,


504
00:22:25,956 --> 00:22:28,876
and find the corresponding
ImageFile instance.


505
00:22:29,316 --> 00:22:31,346
That's all we need to
do, return the item back


506
00:22:31,466 --> 00:22:32,336
to the CollectionView.


507
00:22:33,076 --> 00:22:35,526
If we're feeling brave maybe
we can build and run this,


508
00:22:35,526 --> 00:22:36,826
and see if it actually works.


509
00:22:37,266 --> 00:22:39,226
So, we're going to come
up with -- there you go.


510
00:22:39,226 --> 00:22:40,996
By default we have
a window pointing


511
00:22:40,996 --> 00:22:43,866
at library desktop pictures,
and it scans that folder.


512
00:22:43,866 --> 00:22:46,086
It looks for the ImageFiles


513
00:22:46,126 --> 00:22:48,036
and presents them using
CollectionView items


514
00:22:48,036 --> 00:22:50,606
and we scroll through here, the
items that were out of view,


515
00:22:50,606 --> 00:22:53,766
are actually being instantiated
on demand, or even recycled


516
00:22:53,766 --> 00:22:56,256
from items that just
scrolled off the top.


517
00:22:57,006 --> 00:22:59,356
You can resize, the
layout reflows


518
00:23:00,486 --> 00:23:02,496
and we get a lot
of stuff for free.


519
00:23:02,496 --> 00:23:04,516
This is, I call it the
wrapped layout here,


520
00:23:04,616 --> 00:23:06,996
it is a simple subclass
of the Flow layout,


521
00:23:07,536 --> 00:23:09,986
then we have some custom layouts
that we have implemented, -


522
00:23:11,286 --> 00:23:12,876
we can layout - these
are implemented


523
00:23:12,876 --> 00:23:16,306
by plugging a different layout
object into the CollectionView.


524
00:23:17,276 --> 00:23:19,616
We have got group by tag here,


525
00:23:19,616 --> 00:23:21,816
but that doesn't
really do anything yet.


526
00:23:21,816 --> 00:23:23,706
Let's go back to the slides


527
00:23:23,756 --> 00:23:26,516
and see what it takes
to get that working.


528
00:23:28,016 --> 00:23:29,516
[Applause]


529
00:23:29,516 --> 00:23:30,716
Thank you.


530
00:23:33,806 --> 00:23:37,656
>> That's always a good start,
to get the first demo running.


531
00:23:37,656 --> 00:23:40,426
Now we want to group the
ImageFiles by tag, not satisfied


532
00:23:40,426 --> 00:23:42,046
to display them in one
section, we want to see


533
00:23:42,046 --> 00:23:43,646
which ones correspond
to which tags.


534
00:23:44,156 --> 00:23:47,666
What we're going to do, for
each tag we have an array


535
00:23:47,666 --> 00:23:48,736
of ImageFiles.


536
00:23:49,126 --> 00:23:51,166
That are implicitly
ordered in some way,


537
00:23:51,166 --> 00:23:52,986
and we want to show
them in that order.


538
00:23:53,586 --> 00:23:56,676
An ImageFile may have many
tags, meaning we'll show it


539
00:23:56,676 --> 00:23:57,796
in more than one section.


540
00:23:57,796 --> 00:23:58,386
That's fine.


541
00:23:58,956 --> 00:24:02,116
We also may have ImageFiles that
don't appear in any section.


542
00:24:02,116 --> 00:24:04,486
We are going to have an
untagged ImageFile section,


543
00:24:04,486 --> 00:24:05,986
one additional section
at the end.


544
00:24:05,986 --> 00:24:07,116
Where we show all
of the ImageFiles


545
00:24:07,116 --> 00:24:09,116
with that have no tag.


546
00:24:09,116 --> 00:24:11,456
We'll give each of our sections
a header and footer view,


547
00:24:11,456 --> 00:24:13,186
because we want to show
off that we can do that.


548
00:24:13,836 --> 00:24:15,506
Show you how to do it.


549
00:24:15,856 --> 00:24:19,286
As with item types, the
instantiation process for header


550
00:24:19,286 --> 00:24:21,036
and footer views, you'll
see, is very similar.


551
00:24:21,646 --> 00:24:27,166
A header or footer is in general
considered what CollectionView


552
00:24:27,166 --> 00:24:30,616
calls a supplementary view,
it doesn't represent an item,


553
00:24:30,616 --> 00:24:32,156
but [is] something
that sort of augments,


554
00:24:32,156 --> 00:24:35,216
or brackets the display of items
such as a header or footer.


555
00:24:36,396 --> 00:24:38,976
We're going to implement
the data source as optional,


556
00:24:38,976 --> 00:24:41,676
CollectionView, View For
Supplementary Element OF Kind,


557
00:24:41,676 --> 00:24:43,866
that is a fancy way of asking,
in our case, for a header


558
00:24:43,866 --> 00:24:46,526
or footer, with a
given index path.


559
00:24:47,116 --> 00:24:51,826
We'll go back to the
demo machine for that.


560
00:24:52,756 --> 00:24:54,986
We'll hook this up real quick.


561
00:24:56,396 --> 00:24:59,036
We'll need to take our
existing data source methods


562
00:25:00,786 --> 00:25:03,086
and replace them with slightly
more sophisticated ones,


563
00:25:03,086 --> 00:25:04,716
that understand how to
deal with sectioning.


564
00:25:05,286 --> 00:25:07,856
Here they are.


565
00:25:08,236 --> 00:25:09,466
We'll go through them briefly.


566
00:25:10,026 --> 00:25:12,216
Now we need to be able to tell
the CollectionView how many


567
00:25:12,216 --> 00:25:14,106
sections there are in it.


568
00:25:14,396 --> 00:25:16,566
If our GroupByTag
check box is checked,


569
00:25:16,566 --> 00:25:18,066
which with will set
the property,


570
00:25:18,346 --> 00:25:21,116
we just return the count
of the number of tags


571
00:25:21,146 --> 00:25:22,116
in the image collection.


572
00:25:22,466 --> 00:25:23,576
Plus one because we want


573
00:25:23,576 --> 00:25:26,976
that extra untagged
ImageFiles collection section,


574
00:25:26,976 --> 00:25:28,006
sorry, at the end.


575
00:25:29,256 --> 00:25:29,826
Simple enough.


576
00:25:30,946 --> 00:25:33,656
Reporting the number
much items in a section,


577
00:25:33,786 --> 00:25:36,206
again it is a little different
if we're grouping by tag,


578
00:25:36,516 --> 00:25:39,766
basically we want to say if
the section corresponds to one


579
00:25:39,766 --> 00:25:41,996
of our tags in our collection,
we'll return the count


580
00:25:41,996 --> 00:25:44,296
of the number of
ImageFiles in the tag


581
00:25:44,296 --> 00:25:45,816
that corresponds
to that section.


582
00:25:46,586 --> 00:25:49,066
If we're in the special
untagged ImageFile section


583
00:25:49,066 --> 00:25:50,266
at the end we'll
return the count


584
00:25:50,266 --> 00:25:51,816
of untagged ImageFiles,
and so on.


585
00:25:51,816 --> 00:25:53,146
It's pretty straightforward.


586
00:25:54,726 --> 00:25:57,126
We'll look at Item


587
00:25:57,126 --> 00:26:01,266
For Represented Object
At Index Path.


588
00:26:01,266 --> 00:26:04,046
This is the same implementation
as before, it is able to be


589
00:26:04,046 --> 00:26:07,916
because I factored out this
ImageFile At Index Path method


590
00:26:08,106 --> 00:26:11,866
for my own use which, actually,
this one is not suitable


591
00:26:11,866 --> 00:26:15,976
because it looks at the item
index and not the section index.


592
00:26:15,976 --> 00:26:17,986
We'll replace it with
a smarter version


593
00:26:19,426 --> 00:26:27,776
that knows we might
want to group by tag.


594
00:26:27,876 --> 00:26:31,566
If we're grouping by tag, again,
if the section corresponds


595
00:26:31,566 --> 00:26:35,876
to one of our tags, we'll
find the ImageFile in the list


596
00:26:35,876 --> 00:26:39,016
of ImageFiles for that tag,
according to the item index,


597
00:26:39,606 --> 00:26:42,156
and the section index that tells
us which tag we're dealing with.


598
00:26:43,076 --> 00:26:45,596
Let's try building
and running now.


599
00:26:46,196 --> 00:26:49,106
We can check group by tag here


600
00:26:49,686 --> 00:26:52,046
and now we have our
items grouped by tag


601
00:26:53,126 --> 00:26:56,436
and we get the same flow
and re-layout as before,


602
00:26:56,486 --> 00:26:58,046
and if we zoom in we can see.


603
00:26:58,116 --> 00:27:01,186
This is our header view
which we defined in a nib,


604
00:27:01,186 --> 00:27:04,076
it is basically a container,
gives us a light gray background


605
00:27:04,076 --> 00:27:06,076
and has a text field,
you can put any kind


606
00:27:06,076 --> 00:27:08,476
of controls you want
in here in these,


607
00:27:08,856 --> 00:27:11,366
this is our footer view here,
this is sort of a darker gray,


608
00:27:11,576 --> 00:27:13,566
telling us - we have
put a text field


609
00:27:13,566 --> 00:27:15,766
in telling us how many
ImageFiles are in the group.


610
00:27:16,306 --> 00:27:18,386
That's really all it takes
to implement sections,


611
00:27:18,436 --> 00:27:20,686
it is basically the
same as on iOS.


612
00:27:21,356 --> 00:27:24,426
the one thing that I elided
here, oh, two things I elided,


613
00:27:25,076 --> 00:27:28,846
are the creation of the
supplementary views, the.


614
00:27:28,846 --> 00:27:30,986
headers or footers, there
is a bit of code here,


615
00:27:30,986 --> 00:27:33,146
but basically it is
really very parallel.


616
00:27:33,376 --> 00:27:35,406
The main point of interest
is where we call back


617
00:27:35,406 --> 00:27:38,526
to the CollectionView and say,
make Supplementary Element View,


618
00:27:38,816 --> 00:27:41,466
sorry, Make Supplementary
Element View of kind,


619
00:27:41,496 --> 00:27:42,896
the Flow layout defines,


620
00:27:43,146 --> 00:27:45,486
are section header,
and section footer.


621
00:27:45,486 --> 00:27:46,866
It will be one of those.


622
00:27:47,196 --> 00:27:49,326
We know when it is
section header we'll look


623
00:27:49,326 --> 00:27:50,846
for header.nib, we're
going to look


624
00:27:50,846 --> 00:27:52,256
for footer.nib if
it is the footer.


625
00:27:52,626 --> 00:27:54,396
We pass that in as
an identifier.


626
00:27:54,826 --> 00:27:57,206
Once we've got our view,
we're getting a view,


627
00:27:57,206 --> 00:27:58,706
and not a ViewController
this time.


628
00:28:00,206 --> 00:28:03,376
We can find and set up
the value for TextField,


629
00:28:03,376 --> 00:28:05,846
do whatever we want, and return
it back to the CollectionView.


630
00:28:06,276 --> 00:28:08,686
Last thing we need to do is
implement these delegate methods


631
00:28:08,686 --> 00:28:12,106
the Layout uses to figure
out what's the proper size,


632
00:28:12,366 --> 00:28:15,216
basically the height to display
the header at, and the height


633
00:28:15,246 --> 00:28:16,236
to display the footer at.


634
00:28:16,236 --> 00:28:18,216
We have NSIs in each case,


635
00:28:18,936 --> 00:28:21,216
and since we have a
vertically-scrolling flow


636
00:28:21,216 --> 00:28:24,176
layout, only the height matters,
the width will just get clipped


637
00:28:24,176 --> 00:28:25,996
to the width of the scroll view.


638
00:28:27,036 --> 00:28:29,436
We had to do that to
make sure that ourheaders


639
00:28:29,476 --> 00:28:30,946
and footers showed up.


640
00:28:31,626 --> 00:28:32,146
That's it.


641
00:28:34,306 --> 00:28:36,766
Now we can move on to updating
when our model changes.


642
00:28:37,076 --> 00:28:40,066
So ImageFiles will come
and go in the folder,


643
00:28:40,226 --> 00:28:41,636
we need to tell the
CollectionView


644
00:28:41,636 --> 00:28:44,376
when our model changes so that
we can update what it is showing


645
00:28:44,376 --> 00:28:44,846
the user.


646
00:28:45,956 --> 00:28:49,116
This is done very similarly to
the way that this is handled


647
00:28:49,516 --> 00:28:52,816
with Outline View on OS X.


648
00:28:52,816 --> 00:28:54,956
Basically, these are
the four operations:


649
00:28:55,296 --> 00:28:59,236
Items can be inserted,
deleted, an item can be moved


650
00:28:59,236 --> 00:29:01,746
from one place to another,
or an item can be reloaded


651
00:29:01,746 --> 00:29:03,526
which basically means
it is still there


652
00:29:03,526 --> 00:29:06,676
but the properties have changed,
you need to redisplay it,


653
00:29:06,676 --> 00:29:09,176
you need to regather
properties from it.


654
00:29:09,446 --> 00:29:11,156
It turns out that
these operations apply


655
00:29:11,156 --> 00:29:12,676
to sections as well as items.


656
00:29:12,676 --> 00:29:15,256
This is the same as on iOS
for those who are familiar.


657
00:29:15,676 --> 00:29:18,956
You can insert, delete, move,
and reload sections as well.


658
00:29:20,796 --> 00:29:23,636
Similar approach to view-based
outline view as I mentioned,


659
00:29:23,636 --> 00:29:26,146
which basically means any
time the model changes,


660
00:29:26,356 --> 00:29:29,306
it is the responsibility of your
data source or some other part


661
00:29:29,306 --> 00:29:30,696
of your code that
deals with the model,


662
00:29:30,906 --> 00:29:32,306
to notify the CollectionView,


663
00:29:32,566 --> 00:29:35,126
describing exactly the
changes that were made.


664
00:29:35,126 --> 00:29:37,806
I inserted items at
these index paths.


665
00:29:37,806 --> 00:29:40,836
I removed items here, so
that it can will keep up,


666
00:29:40,836 --> 00:29:42,046
staying in sync with the model.


667
00:29:42,606 --> 00:29:44,066
If you do it right,
it is very simple.


668
00:29:45,426 --> 00:29:48,146
By default, any changes you
notify the CollectionView of,


669
00:29:48,196 --> 00:29:50,916
will appear instantly but you
can easily get an animated


670
00:29:50,916 --> 00:29:53,796
change, by messaging through
the CollectionView's animator,


671
00:29:53,796 --> 00:29:56,636
this is a general proxy
object that views have,


672
00:29:56,836 --> 00:29:59,676
that you can message through,
to request an animated change,


673
00:29:59,676 --> 00:30:01,856
usually when setting a
property in this case


674
00:30:02,116 --> 00:30:03,446
when notifying the
CollectionView


675
00:30:03,786 --> 00:30:05,006
that items have been inserted.


676
00:30:05,416 --> 00:30:08,066
That's what we do in our example
and that's why we see items come


677
00:30:08,066 --> 00:30:09,356
and go in animated way.


678
00:30:09,356 --> 00:30:12,126
Items are inserted, other
items move out of the way


679
00:30:12,536 --> 00:30:13,566
in an animated fashion.


680
00:30:14,126 --> 00:30:16,696
In our example,
CocoaSlideCollection we're going


681
00:30:16,696 --> 00:30:18,836
to watch our ImageFolder
for changes,


682
00:30:19,606 --> 00:30:21,806
when changes occur
we're going to notify--


683
00:30:21,976 --> 00:30:23,336
first we immediate
to update the model


684
00:30:23,336 --> 00:30:24,776
and then we notify
the CollectionView,


685
00:30:24,776 --> 00:30:27,306
after we changed the model,
what we did to the model.


686
00:30:28,806 --> 00:30:32,966
ImageFiles may come and
go, they may be changed,


687
00:30:33,176 --> 00:30:35,326
these are the types of updates
that we'll need to handle.


688
00:30:35,326 --> 00:30:38,216
We are going to use
a little feature,


689
00:30:38,256 --> 00:30:40,336
a foundation feature
called Key-ValueObserving,


690
00:30:40,336 --> 00:30:43,046
which basically gives you
a way to observe properties


691
00:30:43,046 --> 00:30:45,796
of objects, and be
notified automatically,


692
00:30:45,956 --> 00:30:48,576
so that you can then react
in whatever way you need to,


693
00:30:48,626 --> 00:30:51,536
our example uses KVO
throughout for this.


694
00:30:51,536 --> 00:30:53,776
Let's go back to the
demo machine real quick.


695
00:30:54,546 --> 00:30:56,876
I have this already
working here.


696
00:30:58,466 --> 00:31:01,426
We'll run our example
first, to see what it does.


697
00:31:01,976 --> 00:31:04,406
Instead of looking at the
desktop pictures folder,


698
00:31:04,916 --> 00:31:09,276
I'm going to open this vacation
pictures folder, on my desktop.


699
00:31:09,886 --> 00:31:14,836
Let's suppose that I have taken
some pictures on vacation,


700
00:31:16,076 --> 00:31:17,176
gone to some neat places.


701
00:31:17,286 --> 00:31:20,016
I have Finder windows
down here at the bottom,


702
00:31:20,526 --> 00:31:22,716
pointing to desktop pictures,
I'm going to copy some stuff


703
00:31:22,716 --> 00:31:23,776
from desktop pictures,


704
00:31:23,776 --> 00:31:26,786
pretending I went
to these places.


705
00:31:26,836 --> 00:31:30,636
I'll drag and drop some
items into the folder.


706
00:31:31,326 --> 00:31:33,456
CocoaSlideCollection is
monitoring the folder,


707
00:31:33,456 --> 00:31:37,786
it will notice the change,
and add items to its model,


708
00:31:37,786 --> 00:31:39,936
add ImageFile instances,
and then it's going


709
00:31:39,936 --> 00:31:41,366
to notify the CollectionView,
okay,


710
00:31:41,596 --> 00:31:44,376
some ImageFiles were added,
so display some more items


711
00:31:44,376 --> 00:31:47,236
and that happens in a very
synchronized, animated way.


712
00:31:47,576 --> 00:31:51,406
We can drag an item out, a file
out, and, when it disappears,


713
00:31:51,406 --> 00:31:54,566
do an updated File system
scan, notice the change,


714
00:31:54,566 --> 00:31:56,076
update our model, and
the CollectionView


715
00:31:56,076 --> 00:31:56,936
updates accordingly.


716
00:31:57,596 --> 00:32:01,116
The KVO mechanics of
this are pretty standard,


717
00:32:01,116 --> 00:32:01,646
run of the mill.


718
00:32:01,886 --> 00:32:04,406
The interesting, part is how
you talk to the CollectionView.


719
00:32:04,986 --> 00:32:07,186
So, we'll elide the former, and
we'll just look at the latter.


720
00:32:07,186 --> 00:32:10,146
You want to look at these
methods at the bottom


721
00:32:10,146 --> 00:32:13,586
of the Window Controller class,
Handle Image Files Inserted


722
00:32:13,616 --> 00:32:15,286
At Index Paths, that's
just something we defined


723
00:32:15,286 --> 00:32:16,936
for our own use, and
this is where we talk


724
00:32:16,936 --> 00:32:20,376
to the image CollectionView
and use this Insert Items


725
00:32:20,416 --> 00:32:22,796
at Index Paths API,
basically what we have had


726
00:32:22,796 --> 00:32:24,996
to do is figure out, OK, what
are the index paths of the items


727
00:32:24,996 --> 00:32:25,986
that are affected by this?


728
00:32:25,986 --> 00:32:27,066
Where did we insert items?


729
00:32:27,496 --> 00:32:29,896
We messaged the CollectionView,
and since we're messaging


730
00:32:29,896 --> 00:32:31,576
through the animator, we'll
get an animated change,


731
00:32:31,576 --> 00:32:33,166
where the re-layout
that needs to happen,


732
00:32:33,446 --> 00:32:35,776
happens in a smooth way,
instead of instantaneously.


733
00:32:35,956 --> 00:32:38,376
You can make it instantaneous
if you want, by omitting this.


734
00:32:38,776 --> 00:32:40,536
If you want an animated
response,


735
00:32:40,536 --> 00:32:41,706
message through the animator,


736
00:32:41,746 --> 00:32:43,596
you can even control
the duration


737
00:32:43,596 --> 00:32:45,986
by setting the animation
context duration.


738
00:32:46,976 --> 00:32:49,246
Similar thing for
when ImageFiles go,


739
00:32:49,246 --> 00:32:52,006
use Delete Items At Index Paths.


740
00:32:53,056 --> 00:32:56,756
Then there are even sections,
InsertSections, DeleteSections,


741
00:32:56,756 --> 00:32:57,796
and other related APIs,


742
00:32:57,796 --> 00:32:59,396
for dealing with
sections coming and going.


743
00:32:59,506 --> 00:33:01,926
We're even equipped to handle
the new tags being added


744
00:33:01,926 --> 00:33:03,036
and tags being removed.


745
00:33:04,726 --> 00:33:06,646
That's pretty much
all there is to it.


746
00:33:09,156 --> 00:33:11,176
So selection and
highlighting are important


747
00:33:11,176 --> 00:33:12,356
when interacting with users.


748
00:33:12,356 --> 00:33:13,766
We'll look at those
in some detail.


749
00:33:15,396 --> 00:33:16,236
Basically selection


750
00:33:16,236 --> 00:33:18,876
and highlighting are both
visually indicated states.


751
00:33:19,126 --> 00:33:22,036
Highlighting in particular
is sort of a transient state


752
00:33:22,036 --> 00:33:25,446
on the way to items becoming
selected, or deselected,


753
00:33:25,656 --> 00:33:27,126
or used as a drop target.


754
00:33:29,236 --> 00:33:31,896
Here in this illustration
we have items


755
00:33:31,896 --> 00:33:34,706
that were briefly flashed orange
as I was dragging over them,


756
00:33:34,706 --> 00:33:36,706
they were candidates for
selection, we're indicating


757
00:33:36,706 --> 00:33:39,156
that with the orange border,
but then they become blue


758
00:33:39,416 --> 00:33:41,646
when they become selected,
rather than highlighted.


759
00:33:44,456 --> 00:33:47,416
So on OS X an item
has a highlightState.


760
00:33:47,416 --> 00:33:48,886
This is a little
different than on iOS,


761
00:33:48,886 --> 00:33:50,716
there is a just a Boolean
highlight property,


762
00:33:50,956 --> 00:33:53,636
we needed a bit more flexibility
on the desktop to be able


763
00:33:53,636 --> 00:33:55,246
to describe different
kinds of states.


764
00:33:55,616 --> 00:34:00,356
The highlightState has
four possible values.


765
00:34:00,956 --> 00:34:04,226
The default is none, basically
means don't highlight this item.


766
00:34:04,316 --> 00:34:06,456
You'll want to look at whether
the item is selected or not,


767
00:34:06,456 --> 00:34:07,926
to decide how to present it.


768
00:34:08,565 --> 00:34:09,985
If it is not selected
or highlighted,


769
00:34:10,206 --> 00:34:11,255
you may display it normally.


770
00:34:12,476 --> 00:34:13,916
an item may be highlighted


771
00:34:13,916 --> 00:34:16,206
for selection meaning it
is not currently selected,


772
00:34:16,206 --> 00:34:18,335
but we're considering
selecting it, based on something


773
00:34:18,335 --> 00:34:20,696
that the user is doing, such
as dragging across items.


774
00:34:20,985 --> 00:34:22,626
Then you may want to
present it with some kind


775
00:34:22,626 --> 00:34:25,806
of highlight indication, this is
entirely up to you how you want


776
00:34:25,806 --> 00:34:29,166
to design this in your UI,
we're using an orange border


777
00:34:29,166 --> 00:34:30,896
around the slide to
show it is highlighted


778
00:34:30,896 --> 00:34:32,556
for selection, but
not yet selected.


779
00:34:33,846 --> 00:34:36,616
An item can also be
highlighted for deselection.


780
00:34:37,005 --> 00:34:40,846
This is possible with the shift
drag behavior that's the same


781
00:34:40,846 --> 00:34:42,525
as in Finder icon views.


782
00:34:43,775 --> 00:34:48,315
Basically the trick here is the
item is selected, but you want


783
00:34:48,315 --> 00:34:50,426
to suppress showing the
usual selected appearance.


784
00:34:50,426 --> 00:34:51,525
You want to show
something different,


785
00:34:51,525 --> 00:34:54,176
to indicate to the user
that the item was selected,


786
00:34:54,176 --> 00:34:56,216
but we're looking at
making it deselected now.


787
00:34:56,306 --> 00:34:58,016
You might want to show it
normally, this is really


788
00:34:58,016 --> 00:35:01,386
up to you what you want to do,
according to your new iDesign.


789
00:35:01,866 --> 00:35:03,586
Lastly, an item can
be highlighted


790
00:35:03,996 --> 00:35:05,976
to indicate it is a
potential Drop Target


791
00:35:05,976 --> 00:35:08,676
which doesn't make a lot of
sense in our example today,


792
00:35:08,676 --> 00:35:10,576
because a slide is
the leaf node,


793
00:35:10,576 --> 00:35:11,756
we don't really have a semantic


794
00:35:11,756 --> 00:35:14,116
for dropping slides
onto another slide.


795
00:35:14,276 --> 00:35:16,276
But, if we had something
that was more of a container,


796
00:35:16,476 --> 00:35:18,166
it might make sense, and
we'd want to indicate


797
00:35:18,166 --> 00:35:21,356
that that container is where
things are going to get dropped


798
00:35:21,356 --> 00:35:23,436
if the user lets the mouse
up at that current point.


799
00:35:23,926 --> 00:35:27,146
Those are the different
highlight states.


800
00:35:27,356 --> 00:35:29,116
One handy thing to
remember, as I said,


801
00:35:29,116 --> 00:35:30,436
everything is layer-backed now,


802
00:35:30,436 --> 00:35:32,796
with the new CollectionView
implementation.


803
00:35:33,466 --> 00:35:36,506
That gives you the
opportunity to take advantage


804
00:35:36,556 --> 00:35:39,706
of backing-layer
properties as an easy way


805
00:35:39,706 --> 00:35:40,886
to change the appearance
of an item


806
00:35:40,886 --> 00:35:42,046
without having to do redraw.


807
00:35:42,416 --> 00:35:45,456
So, CN layer properties such as
background color, border color,


808
00:35:45,456 --> 00:35:47,116
border width, corner radius,
you've probably worked


809
00:35:47,116 --> 00:35:49,146
with these before, are
real handy for this.


810
00:35:49,456 --> 00:35:53,666
So we might set an item's root
views layer's background color


811
00:35:53,666 --> 00:35:56,496
to some color, and then give
it a corner radius, and boom,


812
00:35:56,496 --> 00:35:59,496
in two lines of code we've got
a quick highlight indication


813
00:35:59,496 --> 00:36:01,526
or selection indication,
nice and easy.


814
00:36:01,526 --> 00:36:03,876
You don't have to
do it that way.


815
00:36:03,876 --> 00:36:05,276
That's just optional,
something to keep


816
00:36:05,276 --> 00:36:06,996
in mind now they're we're
in a layer-backed world.


817
00:36:07,846 --> 00:36:09,496
When to apply highlighting?


818
00:36:09,836 --> 00:36:10,496
Real simple.


819
00:36:10,546 --> 00:36:12,766
Any time your item's
highlightState changes,


820
00:36:12,986 --> 00:36:16,166
in Swift you can do that, in
a DidSetObserver clause here,


821
00:36:16,766 --> 00:36:19,696
you will also want to
do the same for watching


822
00:36:19,696 --> 00:36:23,076
when the items selected state,
the Boolean, changes to yes


823
00:36:23,076 --> 00:36:24,996
or no, you want to take
the highlightState,


824
00:36:24,996 --> 00:36:26,976
and the selected state,
into account together,


825
00:36:27,196 --> 00:36:29,786
and decide visually how to
present that item to indicate


826
00:36:29,786 --> 00:36:31,266
that according to your UI style.


827
00:36:33,176 --> 00:36:35,296
Selection of course is
what we're working toward,


828
00:36:35,296 --> 00:36:37,086
we want users to be
able to select items


829
00:36:37,086 --> 00:36:39,896
so that they can then
operate on them by dragging,


830
00:36:39,896 --> 00:36:41,106
or with menu commands.


831
00:36:42,056 --> 00:36:43,996
With a CollectionView,
items are the things


832
00:36:43,996 --> 00:36:45,226
that constitute the selection,


833
00:36:45,226 --> 00:36:46,416
they're what can
become selected.


834
00:36:46,906 --> 00:36:49,696
NSCollectionView supports single


835
00:36:49,696 --> 00:36:51,336
or multiple selection,
as before.


836
00:36:51,616 --> 00:36:54,186
The master switch is whether
it is selectable or not.


837
00:36:55,306 --> 00:36:56,406
If you make it selectable,


838
00:36:56,406 --> 00:36:58,086
you can make it allow
multiple selection,


839
00:36:58,086 --> 00:37:00,776
or force just single
selection, or no selection,


840
00:37:00,776 --> 00:37:02,296
and you can deny the ability


841
00:37:02,296 --> 00:37:04,756
to have an empty selection
making the CollectionView try


842
00:37:04,756 --> 00:37:07,146
to always maintain at
least one item selected.


843
00:37:07,276 --> 00:37:09,876
These are pretty standard,
they are common to other types


844
00:37:09,876 --> 00:37:12,126
of AppKit CollectionViews
and controls


845
00:37:12,906 --> 00:37:14,866
such as Table View,
Outline View.


846
00:37:16,136 --> 00:37:19,436
Selection is tracked by the new
Selection Index Path Property


847
00:37:19,436 --> 00:37:20,666
on NSCollectionView.


848
00:37:20,666 --> 00:37:22,656
That's the authoritative
representation


849
00:37:22,656 --> 00:37:24,206
of what's selected in
the CollectionView,


850
00:37:24,206 --> 00:37:26,166
and we are using index paths
rather than the items, right?


851
00:37:26,166 --> 00:37:28,936
Because items come and go, but
the index paths stick around.


852
00:37:29,326 --> 00:37:31,646
An item, if it happens
to be instantiated,


853
00:37:32,016 --> 00:37:33,706
does know whether it is
part of the selection


854
00:37:33,706 --> 00:37:36,436
as I have mentioned, but
again, items come and go.


855
00:37:36,436 --> 00:37:39,226
CollectionViews are forever,
so usually you want to look


856
00:37:39,226 --> 00:37:41,126
at the SelectionIndexPaths
at the CollectionView,


857
00:37:41,466 --> 00:37:44,306
to do your operations, and there
are Select Items At Index Paths,


858
00:37:44,706 --> 00:37:47,396
and Deselect Items At Index
Paths, methods that you can use,


859
00:37:47,396 --> 00:37:49,856
you can also just set
selection index paths directly.


860
00:37:50,406 --> 00:37:52,836
When you select items at
index paths as on iOS,


861
00:37:52,836 --> 00:37:54,076
you can also ask
the CollectionView


862
00:37:54,276 --> 00:37:57,336
to scroll those items into view
with a particular alignment.


863
00:37:57,666 --> 00:37:58,486
If you want.


864
00:37:59,906 --> 00:38:02,026
User selection is what
we're usually dealing with.


865
00:38:02,926 --> 00:38:05,666
The delegate has the
opportunity as on iOS


866
00:38:05,666 --> 00:38:07,146
to approve selection
and deselection.


867
00:38:07,146 --> 00:38:10,496
We made the API a little
different, because again we want


868
00:38:10,496 --> 00:38:12,716
to be able to handle
bulk operations a little


869
00:38:12,716 --> 00:38:13,446
more efficiently.


870
00:38:13,706 --> 00:38:15,886
Now we have CollectionView,
Should Select Items


871
00:38:15,886 --> 00:38:17,636
At Index Paths, and
CollectionView,


872
00:38:17,636 --> 00:38:19,496
Should Deselect Items
At Index Paths.


873
00:38:19,776 --> 00:38:22,146
Each of which takes a set of
index paths as the parameter.


874
00:38:22,146 --> 00:38:24,416
These are the proposed
index paths we are going


875
00:38:24,416 --> 00:38:26,256
to to select or deselect.


876
00:38:26,256 --> 00:38:27,796
Notice that, instead
of returning a Boolean,


877
00:38:27,796 --> 00:38:30,646
these return also, a
set of index paths.


878
00:38:30,816 --> 00:38:32,656
So, if you just want to
say, do whatever you want,


879
00:38:32,656 --> 00:38:35,176
CollectionView, just return the
set of index paths we gave you,


880
00:38:35,396 --> 00:38:36,936
but you also have
the opportunity here,


881
00:38:37,236 --> 00:38:39,426
to return a different
set of index paths,


882
00:38:39,426 --> 00:38:41,796
you can do a line item
detail here if you want,


883
00:38:42,016 --> 00:38:43,596
based on whatever
criteria you want,


884
00:38:43,596 --> 00:38:46,856
you have fine-grain control over
which items can become selected


885
00:38:46,856 --> 00:38:48,576
or deselected in
certain situations.


886
00:38:48,936 --> 00:38:52,606
There are also DidSelect and
DidDeselect delegate methods,


887
00:38:52,896 --> 00:38:54,546
so you can find out
after the fact


888
00:38:54,546 --> 00:38:56,036
when the selection
change has been committed.


889
00:38:57,206 --> 00:39:00,006
Similarly for highlighting,
the delegate has methods


890
00:39:00,656 --> 00:39:03,726
for approving and
reacting to these changes.


891
00:39:03,726 --> 00:39:06,496
So, Should Change Items At Index
Paths to highlightState, again,


892
00:39:06,496 --> 00:39:08,916
you can return a different
set of index paths,


893
00:39:09,056 --> 00:39:10,336
you have fine-grain control


894
00:39:10,576 --> 00:39:12,436
over highlighting behavior
with your delegate.


895
00:39:12,436 --> 00:39:16,656
We'll look at this real quickly
again on the demo machine.


896
00:39:21,456 --> 00:39:22,576
Fortunately, for time's sake,


897
00:39:22,576 --> 00:39:23,846
I have the code all
written and running.


898
00:39:23,846 --> 00:39:25,386
We just want to go
into our nib file,


899
00:39:26,616 --> 00:39:28,636
and drill down to our
CollectionView here.


900
00:39:36,316 --> 00:39:39,736
We'll make sure that it
is marked as selectable,


901
00:39:39,736 --> 00:39:41,156
we'll allow empty selection,


902
00:39:41,156 --> 00:39:43,586
and we'll allow multiple
selection too.


903
00:39:44,386 --> 00:39:46,696
The rest of the implementation
is pretty straightforward,


904
00:39:46,696 --> 00:39:49,526
based on the understanding
that we now have.


905
00:39:50,316 --> 00:39:51,966
We'll stop, build, and run.


906
00:39:56,216 --> 00:39:58,906
Now we can click on
items and select them.


907
00:39:58,906 --> 00:40:02,576
We have chosen, for illustration
purposes, to show items


908
00:40:02,576 --> 00:40:04,296
that are candidates
for selection.


909
00:40:04,296 --> 00:40:06,876
They're highlighted in orange
before they become selected,


910
00:40:06,876 --> 00:40:10,206
when I let up on the Trackpad,
it becomes blue, it's selected,


911
00:40:10,206 --> 00:40:12,856
and no longer highlighted, we
can click in the background


912
00:40:13,016 --> 00:40:15,946
to clear the selection, I can
click and drag across items,


913
00:40:15,946 --> 00:40:18,636
again we are showing items as
highlighted to become selected,


914
00:40:18,636 --> 00:40:21,426
they're not selected yet, but
when I let up on the Trackpad,


915
00:40:21,666 --> 00:40:24,026
they cease to be highlighted,
now they're selected.


916
00:40:24,636 --> 00:40:28,026
As I mentioned as in
the Finder icon view,


917
00:40:28,026 --> 00:40:30,126
if you hold down shift, and
drag-select you actually end


918
00:40:30,126 --> 00:40:31,486
up sort of inverting
the selection.


919
00:40:31,486 --> 00:40:33,956
Here is an example of
items that were selected,


920
00:40:34,326 --> 00:40:36,726
that become highlighted
for deselection.


921
00:40:37,076 --> 00:40:38,296
So, even though they're
selected,


922
00:40:38,296 --> 00:40:40,546
we're letting the
highlightState override that,


923
00:40:40,546 --> 00:40:41,886
and how we visually
present them,


924
00:40:41,886 --> 00:40:44,656
and we're just showing them
in an ordinary fashion,


925
00:40:44,656 --> 00:40:45,846
with no border around them.


926
00:40:45,846 --> 00:40:48,356
Then, when I let go, the
selection is committed.


927
00:40:48,766 --> 00:40:51,966
Now, since I can select, I can
Drag-and-Drop things around,


928
00:40:51,966 --> 00:40:53,746
reorder them which is nice.


929
00:40:54,236 --> 00:40:55,666
Once you have selection
there is a lot


930
00:40:55,666 --> 00:40:58,496
of neat stuff that you can do.


931
00:40:59,146 --> 00:41:00,536
Since this is all implemented


932
00:41:00,536 --> 00:41:03,366
in a very generalized way that's
agnostic in different layouts,


933
00:41:03,366 --> 00:41:04,896
we can go look at
our custom layouts,


934
00:41:05,216 --> 00:41:07,056
since they implement
the required methods,


935
00:41:07,496 --> 00:41:11,026
we can also drag-select across
items in our custom layouts,


936
00:41:11,056 --> 00:41:13,846
click select, and that
happens automatically,


937
00:41:13,846 --> 00:41:14,696
because they conform


938
00:41:14,696 --> 00:41:17,886
to the standard NSCollectionView
Layout API.


939
00:41:18,736 --> 00:41:20,646
That's kind of a nice
thing to get for free.


940
00:41:20,646 --> 00:41:22,376
Even when we're in
section mode here,


941
00:41:22,946 --> 00:41:27,166
Flow layout lets us drag-select
across sections, and so forth.


942
00:41:27,426 --> 00:41:28,866
That's kind of neat.


943
00:41:29,816 --> 00:41:30,736
It just works.


944
00:41:31,496 --> 00:41:35,966
Two more things to talk about.


945
00:41:35,966 --> 00:41:38,266
We'll talk real quick
about Drag-and-Drop,


946
00:41:38,956 --> 00:41:40,006
which is important to support.


947
00:41:40,006 --> 00:41:41,606
It hasn't fundamentally changed


948
00:41:41,606 --> 00:41:42,866
since the old CollectionView
API,


949
00:41:42,866 --> 00:41:44,626
but there are some new
things to understand.


950
00:41:45,156 --> 00:41:50,326
We can drag-select items now,
and then if you have a cluster


951
00:41:50,326 --> 00:41:51,676
of items selected,
or just a single,


952
00:41:51,676 --> 00:41:53,596
you can drag it, move it around.


953
00:41:54,506 --> 00:41:56,186
The CollectionView,
as you're dragging,


954
00:41:56,816 --> 00:41:59,546
computes candidate
targets for where to drop.


955
00:41:59,546 --> 00:42:01,836
In the case of this example,
we're not allowing dropping


956
00:42:01,836 --> 00:42:03,716
on items because they
don't represent containers,


957
00:42:03,716 --> 00:42:05,796
but we are allowing
dropping between items,


958
00:42:05,796 --> 00:42:07,486
which is the new thing that
we have to be concerned


959
00:42:07,486 --> 00:42:09,126
with on OS X and not on iOS.


960
00:42:11,066 --> 00:42:13,576
So drag and drop, as before,


961
00:42:13,576 --> 00:42:15,956
is handled by the
NSCollectionView's delegate,


962
00:42:15,956 --> 00:42:18,226
it's responsible for your
drag-and-drop response.


963
00:42:18,806 --> 00:42:22,356
The model is intentionally very
similar to NSOutlineView's API,


964
00:42:22,356 --> 00:42:25,476
there is no fundamental reason
for it to be very different.


965
00:42:25,476 --> 00:42:28,106
If you've seen the drag-and-drop
outline view example,


966
00:42:28,106 --> 00:42:30,726
a lot of the same concepts that
you'll see implemented there,


967
00:42:31,196 --> 00:42:33,776
[it's] basically the same
idea with NSCollectionView.


968
00:42:34,806 --> 00:42:37,326
If you want your CollectionView
to be a dragging source,


969
00:42:37,326 --> 00:42:39,186
meaning that items can
be dragged out of it,


970
00:42:40,256 --> 00:42:42,846
your basic responsibility
is to be able to put items


971
00:42:42,906 --> 00:42:45,916
on the pasteboard when
requested by the CollectionView.


972
00:42:46,036 --> 00:42:47,646
If you want to be a
dragging destination,


973
00:42:47,646 --> 00:42:50,566
if you want to receive
drops, you need to be able


974
00:42:50,566 --> 00:42:53,666
to assess a proposed drop,
CollectionView will call you,


975
00:42:53,666 --> 00:42:56,246
say I want -- I'm proposing
to drop these objects


976
00:42:56,246 --> 00:42:59,306
from the pasteboard onto
this target position,


977
00:42:59,306 --> 00:43:02,706
which will be an index path,
indicating either a gap


978
00:43:02,746 --> 00:43:07,116
between items, before an item
that's named, or a position


979
00:43:07,116 --> 00:43:08,606
on top of an existing item,


980
00:43:08,736 --> 00:43:10,176
if you're letting it
act like a container.


981
00:43:10,176 --> 00:43:11,296
There will be an operation,


982
00:43:11,296 --> 00:43:13,366
these are the standard
drag operations,


983
00:43:13,366 --> 00:43:15,906
like copy, move, et cetera.


984
00:43:15,976 --> 00:43:18,776
You can look at this proposal,
you can optionally override any


985
00:43:18,776 --> 00:43:21,156
of these parameters, say
no, I would like to propose


986
00:43:21,156 --> 00:43:23,556
that instead, you actually
target this position


987
00:43:23,556 --> 00:43:25,116
for drop, or refuse the drop.


988
00:43:25,566 --> 00:43:27,886
You need to be able to
implement the drop acceptance,


989
00:43:27,886 --> 00:43:30,146
which is very similar, but
then the user has committed


990
00:43:30,146 --> 00:43:32,476
to the drop, and you
need to go through,


991
00:43:32,476 --> 00:43:34,946
and look at modifying
your model accordingly,


992
00:43:35,006 --> 00:43:36,526
and updating the
CollectionView accordingly.


993
00:43:37,026 --> 00:43:41,206
The mechanics of this boil down
to these APIs, you need to,


994
00:43:41,206 --> 00:43:45,436
like any other NSView, you want
to register for the drag types


995
00:43:45,436 --> 00:43:46,936
that you want to
be able to accept,


996
00:43:47,026 --> 00:43:48,866
because collection view
generically doesn't know what


997
00:43:48,866 --> 00:43:51,616
types of objects you deal
with in terms of your model.


998
00:43:51,986 --> 00:43:54,806
CollectionView has a Dragging
Source Operation Mask,


999
00:43:54,806 --> 00:43:56,976
both for local and
non-local drags.


1000
00:43:56,976 --> 00:43:59,046
This is just basically
letting you set in advance,


1001
00:43:59,356 --> 00:44:02,816
I support copy and move but not
alias, or something like that.


1002
00:44:03,346 --> 00:44:04,626
You want to set that up.


1003
00:44:04,896 --> 00:44:06,836
We do that in our
example as you will see.


1004
00:44:07,836 --> 00:44:10,426
Then the required delegate
methods that correspond


1005
00:44:10,426 --> 00:44:12,906
to the responsibilities I
mentioned on the previous slide.


1006
00:44:13,446 --> 00:44:16,426
Again, you need to be able to
write items to the pasteboard,


1007
00:44:16,556 --> 00:44:18,956
in the modern API you can
provide a pasteboard writer


1008
00:44:18,956 --> 00:44:21,106
for an item in an index path.


1009
00:44:21,336 --> 00:44:22,336
That lets you deal


1010
00:44:22,336 --> 00:44:24,536
with multi-item drags
much more gracefully.


1011
00:44:25,186 --> 00:44:27,836
Certain data types are
pasteboard writers.


1012
00:44:27,836 --> 00:44:31,926
In this example, NSURL,
if it is an absolute URL,


1013
00:44:31,926 --> 00:44:34,446
you can just return the
URL as a pasteboard writer,


1014
00:44:34,946 --> 00:44:36,636
and it knows how to write
itself to the pasteboard.


1015
00:44:36,846 --> 00:44:39,996
Alternatively, you can implement
Write Items At Index Paths,


1016
00:44:40,066 --> 00:44:42,156
toPasteboard, either
way, you're covered.


1017
00:44:42,796 --> 00:44:44,566
Now, to be a dragging
destination, again,


1018
00:44:44,566 --> 00:44:46,386
there's a Validate
Drop Delegate method,


1019
00:44:46,746 --> 00:44:48,626
and an Accept Drop
Delegate method,


1020
00:44:48,626 --> 00:44:49,956
to abbreviate them
a little bit there.


1021
00:44:50,226 --> 00:44:52,686
And you'll see those
implemented in our code sample.


1022
00:44:53,236 --> 00:44:56,206
We don't have time to walk
through the code sample


1023
00:44:56,206 --> 00:44:58,526
in detail today, because drag
and drop is fairly involved.


1024
00:44:58,526 --> 00:45:01,476
It's designed to be,
enabling you to drag items


1025
00:45:01,826 --> 00:45:03,166
from one application to another.


1026
00:45:03,166 --> 00:45:05,586
There is a lot to it, but
there are some fundamental tips


1027
00:45:05,676 --> 00:45:06,586
to understand.


1028
00:45:06,586 --> 00:45:09,786
Once you get these concepts,
the rest is just mechanics,


1029
00:45:09,786 --> 00:45:10,796
and you'll be able to see it all


1030
00:45:10,796 --> 00:45:13,876
in the heavily-commented
code for our sample today.


1031
00:45:15,226 --> 00:45:19,266
The important things to
remember, it is worth figuring


1032
00:45:19,266 --> 00:45:22,606
out and especially handling the
case where a drag is happening


1033
00:45:22,606 --> 00:45:23,936
within your CollectionView.


1034
00:45:24,346 --> 00:45:28,306
When you start to get dragging
destination delegate messages,


1035
00:45:28,306 --> 00:45:30,686
it is worth being
able to say, hey,


1036
00:45:31,006 --> 00:45:33,386
I know that this drag
originated within myself,


1037
00:45:33,386 --> 00:45:35,816
I know which items, which
index paths, are being dragged


1038
00:45:36,066 --> 00:45:38,446
so I can handle this a lot
more simply than, sort of,


1039
00:45:38,446 --> 00:45:40,306
the general, oh, this drag
can be coming from anywhere


1040
00:45:40,306 --> 00:45:42,936
in the system, I have to pull
things off the pasteboard,


1041
00:45:42,936 --> 00:45:44,156
and so on.


1042
00:45:44,756 --> 00:45:46,556
This lets you, with
CollectionView,


1043
00:45:46,556 --> 00:45:47,766
it lets you tell
the CollectionView


1044
00:45:47,766 --> 00:45:50,216
that you're just moving
items from these index paths,


1045
00:45:50,216 --> 00:45:51,326
to these new index paths,


1046
00:45:51,326 --> 00:45:53,026
and can give you a
nice slick animation


1047
00:45:53,336 --> 00:45:54,626
as a side benefit of that.


1048
00:45:54,806 --> 00:45:57,196
It's a lot better,
more sophisticated


1049
00:45:57,196 --> 00:46:00,006
than removing the
items and then, oh,


1050
00:46:00,006 --> 00:46:02,386
I have to reinsert these
same items somewhere else,


1051
00:46:02,646 --> 00:46:03,576
and reconstitute them.


1052
00:46:04,156 --> 00:46:06,376
A handy place to do this
is in the CollectionView,


1053
00:46:06,376 --> 00:46:08,826
dragging Session Will
Begin At Point For Items


1054
00:46:08,826 --> 00:46:11,386
At Index Paths delegate method.


1055
00:46:11,486 --> 00:46:13,316
It's an optional method,
but it's a good place


1056
00:46:13,316 --> 00:46:16,946
to catch those index paths,
stash them in a private property


1057
00:46:17,226 --> 00:46:21,446
of your data source, so you can
find that later, and say, aha,


1058
00:46:21,526 --> 00:46:23,546
I can handle this much more
simply, and you will see


1059
00:46:23,546 --> 00:46:26,186
where the code sample does that.


1060
00:46:26,396 --> 00:46:30,086
I wanted to leave time to
look at customizing layout.


1061
00:46:30,086 --> 00:46:31,876
That's more interesting and fun.


1062
00:46:32,036 --> 00:46:33,356
Let's go to that.


1063
00:46:34,356 --> 00:46:38,066
It's our last task, we're going
to look at both what you need


1064
00:46:38,066 --> 00:46:39,656
to do to adjust an
existing layout,


1065
00:46:39,656 --> 00:46:42,296
let's say Flow does almost
what you want, but you want


1066
00:46:42,296 --> 00:46:44,506
to tweak it just a bit to
get everything pixel perfect,


1067
00:46:44,596 --> 00:46:48,126
you know, I have heard
of doing that before!


1068
00:46:48,216 --> 00:46:52,016
Or, maybe you want to implement
a completely custom new type


1069
00:46:52,016 --> 00:46:53,356
of layout as we have done here,


1070
00:46:53,466 --> 00:46:56,916
with our various other
arrangements of slides.


1071
00:46:57,166 --> 00:46:58,976
We'll look at what it
takes to do that too.


1072
00:46:59,476 --> 00:47:01,926
Adjusting an existing layout
takes a little less work.


1073
00:47:02,196 --> 00:47:03,066
We'll look at that first.


1074
00:47:03,316 --> 00:47:05,766
Let's say you want to
subclass the flow layout class


1075
00:47:05,806 --> 00:47:08,436
to adjust item positioning
just a little bit,


1076
00:47:08,436 --> 00:47:09,386
tweak things here and there.


1077
00:47:09,976 --> 00:47:11,856
You can do that with a
delegate, but let's just suppose


1078
00:47:11,856 --> 00:47:13,916
that you want to do something
that you find you can't do,


1079
00:47:14,216 --> 00:47:15,516
with the existing delegate API.


1080
00:47:16,756 --> 00:47:20,616
This is the main workhorse
method to understand.


1081
00:47:20,896 --> 00:47:23,436
So far this is the
same as on iOS.


1082
00:47:23,436 --> 00:47:26,346
Layout Attributes For Elements
In Rect is a very general API.


1083
00:47:26,346 --> 00:47:27,686
CollectionView calls in,


1084
00:47:27,686 --> 00:47:30,476
and it passes you a
rectangle that's a rectangle


1085
00:47:30,476 --> 00:47:33,406
in the CollectionViews internal
bounds coordinate system.


1086
00:47:33,406 --> 00:47:35,986
It's basically saying, hey,
what's in this rectangle?


1087
00:47:36,506 --> 00:47:38,466
You're obliged to
return an array


1088
00:47:38,606 --> 00:47:39,946
of layout attributes objects.


1089
00:47:39,946 --> 00:47:43,386
Remember, that's our
encapsulation of descriptions


1090
00:47:43,386 --> 00:47:44,806
of items, independent of having


1091
00:47:44,806 --> 00:47:47,086
to actually instantiate
the items just yet.


1092
00:47:47,546 --> 00:47:50,196
You are going to return it
information about items,


1093
00:47:50,196 --> 00:47:52,076
and if you have header
and footer views,


1094
00:47:52,076 --> 00:47:54,056
or other supplementary views
that could be in that area,


1095
00:47:54,506 --> 00:47:56,006
you have to figure
out what's there,


1096
00:47:56,006 --> 00:47:57,316
and return those descriptions.


1097
00:47:57,556 --> 00:47:59,796
This is obviously
highly dependent


1098
00:47:59,796 --> 00:48:01,536
on what your layout
algorithm is.


1099
00:48:01,536 --> 00:48:02,826
It could be anything, right?


1100
00:48:02,826 --> 00:48:04,536
So you are going to traverse
your own internal data


1101
00:48:04,536 --> 00:48:06,156
structures, you want
to figure out how


1102
00:48:06,156 --> 00:48:07,896
to do this really
efficiently for your layout.


1103
00:48:08,136 --> 00:48:09,866
That is this methods'
responsibility,


1104
00:48:09,866 --> 00:48:11,826
to return descriptions of
everything in a rectangle.


1105
00:48:12,296 --> 00:48:14,206
That's the workhorse,
that's what gets called,


1106
00:48:14,206 --> 00:48:15,586
when the CollectionView
first lays


1107
00:48:15,586 --> 00:48:17,326
out the items you have given it.


1108
00:48:17,776 --> 00:48:20,046
Then, there is this companion,
Layout Attributes For Item


1109
00:48:20,046 --> 00:48:21,766
At Index Path, almost
seems superfluous,


1110
00:48:21,806 --> 00:48:25,636
but the CollectionView needs to
ask about specific items, say,


1111
00:48:25,636 --> 00:48:27,156
just describe this item to me,


1112
00:48:27,526 --> 00:48:28,976
and that's what you're
supposed to do here.


1113
00:48:28,976 --> 00:48:32,426
If there is no item at that
index path you return nil.


1114
00:48:32,976 --> 00:48:35,836
Usually, there is,
if it is asking.


1115
00:48:35,966 --> 00:48:38,726
This gets invoked when you're
doing things like moving items


1116
00:48:38,826 --> 00:48:40,106
from one place to another.


1117
00:48:40,846 --> 00:48:43,206
So you want to implement that
too, and the results need


1118
00:48:43,206 --> 00:48:44,906
to be consistent with
the first method.


1119
00:48:45,446 --> 00:48:50,556
Then there is Invalidate Layout
With Context, which is sort


1120
00:48:50,556 --> 00:48:54,356
of a general invalidation method
that CollectionView will invoke


1121
00:48:54,576 --> 00:48:56,686
with a context, that, if
you look at its properties,


1122
00:48:56,686 --> 00:48:58,406
examine it, it is
the same as on iOS,


1123
00:48:58,636 --> 00:49:00,316
it describes what's changed.


1124
00:49:00,316 --> 00:49:01,876
Items were inserted or removed,


1125
00:49:01,876 --> 00:49:04,056
maybe the CollectionView is
resizing, any of a number


1126
00:49:04,056 --> 00:49:05,136
of things could be happening.


1127
00:49:05,616 --> 00:49:08,706
Examining the context properties
gives you the opportunity


1128
00:49:08,936 --> 00:49:11,076
to just try to be as smart
and efficient as you can.


1129
00:49:11,076 --> 00:49:13,536
This is sort of a later
optimization you might want


1130
00:49:13,536 --> 00:49:16,236
to do, after you get your layout
just basically working the way


1131
00:49:16,236 --> 00:49:17,426
you want it to.


1132
00:49:17,686 --> 00:49:22,006
This is your chance to blow
away any invalidated state stuff


1133
00:49:22,006 --> 00:49:24,676
that is internal state that
you track for your layout,


1134
00:49:24,676 --> 00:49:28,436
your own description of it
when certain changes happen.


1135
00:49:29,486 --> 00:49:32,106
So we're just seeing
Flow layout,


1136
00:49:32,106 --> 00:49:33,676
then let's say we're going


1137
00:49:33,676 --> 00:49:36,046
to implement those
first two methods,


1138
00:49:36,046 --> 00:49:39,416
the layout attributes returning
methods, to call up to super,


1139
00:49:39,846 --> 00:49:42,466
see what NSCollectionView
Flow layout proposes,


1140
00:49:42,706 --> 00:49:46,316
we can examine the resultant
layout attributes instance,


1141
00:49:46,316 --> 00:49:49,086
or array of them, and make
whatever tweaks we want to,


1142
00:49:49,086 --> 00:49:51,326
and return a new array
of layout attributes,


1143
00:49:51,326 --> 00:49:52,446
or a single array of
layout attributes.


1144
00:49:52,446 --> 00:49:54,316
That's pretty much
what there is to that,


1145
00:49:54,316 --> 00:49:56,956
as long as the changes you're
making don't change the amount


1146
00:49:56,956 --> 00:49:57,986
of space the layout needs.


1147
00:49:59,396 --> 00:50:01,516
What if you want to implement
a completely custom layout,


1148
00:50:01,516 --> 00:50:02,306
like we have done here?


1149
00:50:02,966 --> 00:50:05,076
You can subclass
NSCollectionView layout


1150
00:50:05,076 --> 00:50:07,046
directly, to just do
everything from scratch,


1151
00:50:07,046 --> 00:50:09,676
if your layout has nothing in
common with Flow, for example.


1152
00:50:10,456 --> 00:50:12,816
You implement the same
methods that we described


1153
00:50:12,816 --> 00:50:13,746
on the previous slide.


1154
00:50:14,526 --> 00:50:15,916
In addition, you need to be able


1155
00:50:15,916 --> 00:50:20,636
to answer certain basic
questions, like, what's the size


1156
00:50:20,636 --> 00:50:23,006
that you need, the width and
height, to display the items


1157
00:50:23,006 --> 00:50:24,756
that the CollectionView
has to offer?


1158
00:50:25,326 --> 00:50:27,576
You basically just telling the
CollectionView here what's the


1159
00:50:27,766 --> 00:50:30,356
size of my document view within?


1160
00:50:30,356 --> 00:50:31,806
-- this determines
your scrollable area.


1161
00:50:33,726 --> 00:50:36,606
Should Invalidate Layout For
Bounds Change returns a Boolean,


1162
00:50:36,606 --> 00:50:38,566
so CollectionView is
going to invoke this


1163
00:50:38,566 --> 00:50:39,866
when it's being resized.


1164
00:50:40,346 --> 00:50:43,826
And typically you'll look at,
What's my layout algorithm?


1165
00:50:43,906 --> 00:50:46,256
Is my layout affected
by this resize?


1166
00:50:46,526 --> 00:50:49,196
If you're a Flow layout
for example, a vertical one


1167
00:50:49,196 --> 00:50:52,466
that lays things out into rows,
maybe you don't care so much


1168
00:50:52,506 --> 00:50:55,136
if the CollectionViews
height is changing, right?


1169
00:50:55,136 --> 00:50:56,546
That just gives you
more or less space.


1170
00:50:56,606 --> 00:50:58,916
But,if the width is changing,
you may have to reflow.


1171
00:50:59,256 --> 00:51:01,296
You may return yes in
that case for example.


1172
00:51:01,576 --> 00:51:03,976
That's what that method does.


1173
00:51:04,726 --> 00:51:07,946
If you're modifying the flow
layout so that the amount


1174
00:51:07,946 --> 00:51:10,076
of space you need changes,
you may actually need


1175
00:51:10,076 --> 00:51:13,176
to implement those two, even
for a slightly customized flow.


1176
00:51:14,666 --> 00:51:16,886
These methods, however,
are brand-new on OS X,


1177
00:51:16,886 --> 00:51:19,606
I mentioned we have the
ability now to hit test,


1178
00:51:19,606 --> 00:51:21,676
to have a layout
in the abstract,


1179
00:51:21,766 --> 00:51:24,016
hit test for drop targets.


1180
00:51:24,266 --> 00:51:25,856
That's a powerful new feature.


1181
00:51:26,266 --> 00:51:28,366
You can define this for
any of your custom layouts,


1182
00:51:28,746 --> 00:51:31,506
Layout Attribute For Drop Target
At Point is the first method.


1183
00:51:32,086 --> 00:51:34,966
If the target is an item,
that's pretty straightforward.


1184
00:51:34,966 --> 00:51:36,626
You're going to return
an attribute,


1185
00:51:36,626 --> 00:51:37,976
a layout attributes instance,


1186
00:51:38,416 --> 00:51:40,516
whose represented
element category is Item.


1187
00:51:41,216 --> 00:51:43,326
You're proposing
dropping on an item,


1188
00:51:43,976 --> 00:51:47,146
you plug the index path in, of
the item you have identified


1189
00:51:47,146 --> 00:51:50,276
that would be dropped
onto, and then you want


1190
00:51:50,276 --> 00:51:54,126
to return the bounding box
of that item as the frame


1191
00:51:54,126 --> 00:51:55,036
of the layout attribute.


1192
00:51:55,036 --> 00:51:56,356
That's imple enough.


1193
00:51:56,606 --> 00:51:59,116
A more interesting case, now,
that we didn't have to deal


1194
00:51:59,116 --> 00:52:01,476
with on iOS, is gaps
between items.


1195
00:52:02,646 --> 00:52:05,536
If you determine that the point
that's being hit tested is


1196
00:52:05,536 --> 00:52:08,556
between items, and you
can identify, in some sort


1197
00:52:08,556 --> 00:52:11,716
of serial order of the
items, where that gap is, OK,


1198
00:52:11,716 --> 00:52:15,376
t is between item at index
6 and index 7, you may want


1199
00:52:15,376 --> 00:52:16,846
to return an Inter Item Gap.


1200
00:52:17,866 --> 00:52:21,126
That will let users drop between
your items in your layout.


1201
00:52:21,546 --> 00:52:24,316
You return one whose element
category is Inter Item Gap,


1202
00:52:25,036 --> 00:52:28,106
the attribute's index
path is the index path


1203
00:52:28,396 --> 00:52:30,426
of the item after the gap.


1204
00:52:30,426 --> 00:52:33,276
If you're between 6 and 7,
you return the index path


1205
00:52:33,276 --> 00:52:35,186
that specifies item
7 in that section.


1206
00:52:36,416 --> 00:52:39,856
Then again, you return as the
attributes frame, a bounding box


1207
00:52:40,146 --> 00:52:44,076
of that gap, the CollectionView
will use that bounding box


1208
00:52:44,076 --> 00:52:46,986
to figure out how to draw its
standard indicators somewhere


1209
00:52:46,986 --> 00:52:47,906
in that rectangle.


1210
00:52:48,196 --> 00:52:53,446
Next there is a method
called Layout Attributes


1211
00:52:53,446 --> 00:52:55,596
For Inter Item Gap
Before Index Path.


1212
00:52:55,596 --> 00:52:58,106
CollectionView sometimes needs
this too, and it will ask


1213
00:52:58,106 --> 00:53:01,556
about a particular position, and
ask you to describe that gap.


1214
00:53:02,116 --> 00:53:03,806
So here we return an Attributes


1215
00:53:03,806 --> 00:53:05,476
With Element Category
Inter Item Gap,


1216
00:53:05,846 --> 00:53:08,586
it's represented element kind
is Inter Item Gap Indicator,


1217
00:53:08,946 --> 00:53:10,926
so this is really,
we're using this to set


1218
00:53:10,926 --> 00:53:12,316
up a supplementary view.


1219
00:53:12,316 --> 00:53:15,156
That's how the Inter Item
Gap Indicator is implemented,


1220
00:53:15,906 --> 00:53:17,926
you just plug in the index
path that you are given,


1221
00:53:18,606 --> 00:53:20,766
and your return is
the attributes frames


1222
00:53:20,866 --> 00:53:22,106
as the Rect of the gap.


1223
00:53:22,206 --> 00:53:23,816
With these two methods together,


1224
00:53:24,156 --> 00:53:29,106
CollectionView can support drop
target indication between items,


1225
00:53:29,106 --> 00:53:32,516
even for potentially-arbitrary
custom layouts


1226
00:53:32,516 --> 00:53:34,596
of your own design,
which is pretty neat.


1227
00:53:35,566 --> 00:53:37,486
We'll look briefly at
our custom layouts,


1228
00:53:37,486 --> 00:53:40,066
and how they're implemented
as our last demo.


1229
00:53:47,616 --> 00:53:49,586
Looking here on the
left-sidebar,


1230
00:53:49,976 --> 00:53:51,386
we have the code categorized.


1231
00:53:51,386 --> 00:53:53,346
We have a layouts group,
you want to look in there.


1232
00:53:53,726 --> 00:53:55,626
We'll look at one example today.


1233
00:53:56,216 --> 00:53:57,166
The circular layout.


1234
00:54:00,686 --> 00:54:03,276
It is fairly simple.


1235
00:54:03,396 --> 00:54:06,476
We implement Layout Attributes
For An Item At Index Path,


1236
00:54:06,476 --> 00:54:08,256
that's where we're asked
about a particular item.


1237
00:54:09,046 --> 00:54:12,626
All we're doing here in concept,
is we're taking the item index


1238
00:54:13,266 --> 00:54:15,706
from the index path,
and that's going


1239
00:54:15,706 --> 00:54:18,106
to define how far we
are around the circle.


1240
00:54:18,416 --> 00:54:23,636
We use that to compute an
angle from 0 to 2 Pi radians.


1241
00:54:23,946 --> 00:54:26,776
That lets us compute a frame
for where the slide should go.


1242
00:54:27,696 --> 00:54:31,736
Then the important part is
here, the API is a little touchy


1243
00:54:31,736 --> 00:54:34,366
to how you instantiate
layout attributes instances,


1244
00:54:34,366 --> 00:54:36,626
to get one that's
bound to the index path


1245
00:54:36,676 --> 00:54:38,026
that it references correctly,


1246
00:54:38,336 --> 00:54:39,906
you want to be careful
to do it this way.


1247
00:54:40,676 --> 00:54:44,986
We'll actually talk
to the layouts class,


1248
00:54:45,366 --> 00:54:48,116
and get the corresponding
layout attributes class,


1249
00:54:48,146 --> 00:54:52,446
basically having this API
allows for layout attributes


1250
00:54:52,506 --> 00:54:54,736
for the NSCollectionView
Layout Attributes Class


1251
00:54:54,956 --> 00:54:56,516
to be subclassed and extended.


1252
00:54:56,806 --> 00:54:59,516
You may have some really
custom layout, just as on iOS,


1253
00:54:59,806 --> 00:55:01,906
that needs to work
with other attributes


1254
00:55:01,906 --> 00:55:04,356
or remember other things about
items that it's laid out,


1255
00:55:04,586 --> 00:55:06,756
you can add those
properties by subclassing.


1256
00:55:07,436 --> 00:55:09,296
You override layout
attribute class


1257
00:55:09,366 --> 00:55:11,336
to return your own subclass.


1258
00:55:12,026 --> 00:55:15,006
This way we make sure we're
instantiating a subclass


1259
00:55:15,006 --> 00:55:15,716
if we need to.


1260
00:55:16,026 --> 00:55:17,696
The appropriate one.


1261
00:55:17,826 --> 00:55:21,286
We invoke this factory method,
Layout Attributes For Items


1262
00:55:21,286 --> 00:55:23,816
With Index Path, we pass
in that path we were given.


1263
00:55:23,816 --> 00:55:26,146
Once we have got a layout
attributes object back,


1264
00:55:27,186 --> 00:55:29,596
we set the properties we
want to, we set the frame,


1265
00:55:29,596 --> 00:55:33,056
the Z index for back-to-front
sort order in the layer world,


1266
00:55:33,056 --> 00:55:34,376
and then we return


1267
00:55:34,376 --> 00:55:36,546
that attributes instance
back to CollectionView.


1268
00:55:37,186 --> 00:55:39,676
We have a superclass,
where for all


1269
00:55:39,676 --> 00:55:43,506
of our custom layouts we have
implemented the Rect-taking


1270
00:55:43,506 --> 00:55:46,546
method, Layout Attributes
For Elements In Rect,


1271
00:55:46,546 --> 00:55:48,716
and we can do that, because
in this case, what's special


1272
00:55:48,716 --> 00:55:50,906
about all of these layouts,
in this case is rather


1273
00:55:50,906 --> 00:55:53,096
than being scrollable
layouts, that just grow


1274
00:55:53,096 --> 00:55:55,916
to whatever size they need
to display their items,


1275
00:55:56,136 --> 00:55:58,206
these all choose to display all


1276
00:55:58,206 --> 00:56:00,956
of the CollectionViews
items in the visible area.


1277
00:56:01,356 --> 00:56:04,336
So the implementation of this
method is basically always


1278
00:56:04,376 --> 00:56:04,816
the same.


1279
00:56:04,816 --> 00:56:07,736
We are looking at the Rect,
and we are going to look


1280
00:56:07,736 --> 00:56:09,446
at every item we have.


1281
00:56:09,976 --> 00:56:13,766
We're returning descriptions of
those back to CollectionView,


1282
00:56:14,076 --> 00:56:16,956
so we're actually just
leveraging the Layout Attributes


1283
00:56:16,956 --> 00:56:18,536
For Item At Index Path method,


1284
00:56:18,746 --> 00:56:20,546
that we implement
in the subclass.


1285
00:56:21,486 --> 00:56:23,926
CollectionView Content
Size is the same for all


1286
00:56:23,926 --> 00:56:25,476
of these slide layouts,
we're just looking


1287
00:56:25,476 --> 00:56:28,846
at the clipped view's bound
size, what area do we have,


1288
00:56:28,846 --> 00:56:29,946
that's visible to the user?


1289
00:56:29,946 --> 00:56:31,676
We're going to lay out
everything out within there,


1290
00:56:31,936 --> 00:56:34,336
and because we're doing
that, we're also going


1291
00:56:34,336 --> 00:56:36,906
to invalidate layout
when the bounds change,


1292
00:56:36,906 --> 00:56:39,776
regardless of what the change
is, we want to re-layout,


1293
00:56:39,896 --> 00:56:43,986
so that we can use the
available space appropriately.


1294
00:56:44,676 --> 00:56:48,196
Prepare Layout, as on iOS, this
is just a handy little hook


1295
00:56:48,196 --> 00:56:51,046
for when layout parameters have
changed, and you're being called


1296
00:56:51,046 --> 00:56:52,536
at the start of a
new layout cycle,


1297
00:56:52,806 --> 00:56:55,276
you can do any pre-computation
you want to in there,


1298
00:56:55,516 --> 00:56:57,686
and just gets invoked once,
at the start of the cycle.


1299
00:56:58,636 --> 00:57:01,096
We can look at our
layouts in action here.


1300
00:57:07,556 --> 00:57:11,456
And say for the circular
layout as we resize,


1301
00:57:11,456 --> 00:57:13,906
the layout is getting
invalidated each time,


1302
00:57:13,906 --> 00:57:16,616
because we want to make
the biggest circle we can,


1303
00:57:16,886 --> 00:57:19,066
leaving some margins
within the available area.


1304
00:57:19,916 --> 00:57:24,666
By implementing those
relatively-few required methods,


1305
00:57:25,036 --> 00:57:26,736
we have a completely
custom layout.


1306
00:57:26,736 --> 00:57:27,746
And again, as before,


1307
00:57:28,116 --> 00:57:32,046
it supports crossing selection
here, and click selection,


1308
00:57:32,576 --> 00:57:34,336
and it is very versatile.


1309
00:57:35,706 --> 00:57:38,536
So, it doesn't take much to
define your own layouts for use


1310
00:57:39,616 --> 00:57:42,766
within NSCollectionView, and
in fact the layout classes,


1311
00:57:42,806 --> 00:57:45,566
the APIs you will find,
except for those additions,


1312
00:57:45,566 --> 00:57:48,606
those augmentations we made to
support drop target hit-testing,


1313
00:57:48,976 --> 00:57:51,126
basically the API
is the same as iOS,


1314
00:57:51,126 --> 00:57:52,836
so if you have the layouts
you have used on iOS,


1315
00:57:53,266 --> 00:57:57,516
you should find it very
easy to port those to OS X.


1316
00:57:57,516 --> 00:57:59,236
We have covered a lot
of topics here today,


1317
00:57:59,236 --> 00:58:02,696
we've basically made an
example run, and you have access


1318
00:58:02,696 --> 00:58:04,036
to the complete source
code to that.


1319
00:58:04,036 --> 00:58:05,816
I encourage you to study it,


1320
00:58:05,996 --> 00:58:09,586
it should help you get started
using the new NSCollectionView


1321
00:58:09,816 --> 00:58:10,866
on El Capitan.


1322
00:58:11,636 --> 00:58:15,586
In conclusion, we have
got a greatly enhanced


1323
00:58:15,586 --> 00:58:17,946
NSCollectionView, I hope
you'll agree on El Capitan,


1324
00:58:17,946 --> 00:58:20,716
it is ready now to handle
scalability to large numbers


1325
00:58:20,716 --> 00:58:23,736
of items, flexibility
to arbitrary layouts,


1326
00:58:24,396 --> 00:58:27,316
and all of the toughest projects
you may want to throw at it.


1327
00:58:27,466 --> 00:58:28,806
We encourage you to do so.


1328
00:58:29,016 --> 00:58:30,046
Let us know what works.


1329
00:58:30,046 --> 00:58:31,756
Let us know what you
have challenges with.


1330
00:58:31,756 --> 00:58:34,196
If you need any help
or guidance,


1331
00:58:34,196 --> 00:58:35,476
we have a lab dedicated


1332
00:58:35,476 --> 00:58:37,536
to CollectionView
specifically tomorrow morning


1333
00:58:37,796 --> 00:58:41,046
in Foundation Lab B downstairs,
Frameworks Lab B, sorry,


1334
00:58:41,526 --> 00:58:44,536
at the foundation of the
building, 9:00 a.m. tomorrow.


1335
00:58:44,536 --> 00:58:46,746
I'll be there along with
other engineers from our team


1336
00:58:46,746 --> 00:58:47,936
who understand CollectionView.


1337
00:58:48,886 --> 00:58:51,276
Be sure to look at not
just the documentation,


1338
00:58:51,276 --> 00:58:53,216
but also the Application
Kit Release Notes,


1339
00:58:53,216 --> 00:58:55,976
I have personally put notes
about CollectionView use


1340
00:58:55,976 --> 00:59:00,776
in there, details about how
to set them up, and also,


1341
00:59:00,776 --> 00:59:01,696
you will find information


1342
00:59:01,696 --> 00:59:03,486
about all the other
great new stuff we have


1343
00:59:03,486 --> 00:59:05,826
in AppKit in 10.11.


1344
00:59:06,896 --> 00:59:09,246
If you missed What's New in
Cocoa, another great place


1345
00:59:09,246 --> 00:59:12,376
to find out about all the new
features that we have added,


1346
00:59:12,376 --> 00:59:14,636
it is quite a lot, it
didn't even fit in one talk,


1347
00:59:15,006 --> 00:59:16,416
I encourage you to
check that out,


1348
00:59:16,456 --> 00:59:18,346
on the session videos
that are available.


1349
00:59:18,346 --> 00:59:21,426
Last but not least we have
two great auto layout sessions


1350
00:59:21,426 --> 00:59:24,026
earlier today, if you're
using Auto Layout constraints


1351
00:59:24,326 --> 00:59:26,786
to position your controls
within your items,


1352
00:59:27,076 --> 00:59:30,266
it might be really helpful to
understand Auto Layout in depth.


1353
00:59:30,836 --> 00:59:32,196
Thank you very much for coming.


1354
00:59:32,196 --> 00:59:33,726
I look forward to
seeing what you create.


1355
00:59:33,726 --> 00:59:35,366
Enjoy the WWDC bash!


1356
00:59:35,396 --> 00:59:36,476
I'll see you tomorrow
morning in the lab.


1357
00:59:37,508 --> 00:59:39,508
[Applause]

