1
00:00:20,516 --> 00:00:22,636
[Applause]


2
00:00:23,136 --> 00:00:26,026
>> STEVE LEWALLEN:
Well, good afternoon!


3
00:00:26,026 --> 00:00:29,066
And welcome to today's session
introducing On Demand Resources.


4
00:00:29,066 --> 00:00:30,166
My name is Steve Lewallen.


5
00:00:30,216 --> 00:00:31,736
So what do we have
for you today?


6
00:00:32,396 --> 00:00:35,176
Well, we're going to begin
by giving you an overview


7
00:00:35,176 --> 00:00:38,126
of On Demand Resources,
or ODR, and we're going


8
00:00:38,126 --> 00:00:41,846
to compare an application built
with ODR to one built without.


9
00:00:41,846 --> 00:00:45,456
We will follow that by listing
all the features and benefits


10
00:00:45,456 --> 00:00:48,406
to you, the developer, as well
as to users of ODR applications.


11
00:00:49,666 --> 00:00:52,796
Then we will deep dive into
a bit of the details of ODR,


12
00:00:52,946 --> 00:00:55,836
how an ODR application is
structured, how you build one.


13
00:00:56,486 --> 00:01:00,036
We will follow that up by
giving you a demo using Xcode


14
00:01:00,396 --> 00:01:03,136
and the new ODR API we
have added to Foundation.


15
00:01:04,575 --> 00:01:07,116
And finally, we will wrap
things up with a segment


16
00:01:07,116 --> 00:01:09,136
on best practices in using


17
00:01:09,136 --> 00:01:11,316
and building the
optimal ODR application.


18
00:01:11,946 --> 00:01:12,896
So let's get started.


19
00:01:12,896 --> 00:01:16,416
So to understand where
we are going with ODR,


20
00:01:16,416 --> 00:01:18,416
we need to understand
where we are today


21
00:01:18,416 --> 00:01:19,756
with the traditional
application.


22
00:01:20,506 --> 00:01:23,476
Now, this application will
have an executable segment.


23
00:01:23,476 --> 00:01:25,786
This is your compiled
Swift, Objective-C,


24
00:01:25,786 --> 00:01:30,456
C++ as well as some base
resources, and the levels


25
00:01:30,456 --> 00:01:32,186
in the game, for example,
if this is a game.


26
00:01:33,366 --> 00:01:35,636
When you, the developer,
are happy with this game


27
00:01:35,636 --> 00:01:37,436
or application, you
upload it to the store,


28
00:01:38,216 --> 00:01:40,996
and when the user comes
along and buys the app


29
00:01:41,366 --> 00:01:43,456
or game they get the
entire thing and down


30
00:01:43,456 --> 00:01:44,566
to the device it goes.


31
00:01:45,166 --> 00:01:46,536
And there it is not alone.


32
00:01:47,076 --> 00:01:49,636
Here we have all the other
compelling applications


33
00:01:49,636 --> 00:01:51,106
and games that you,
the developer,


34
00:01:51,106 --> 00:01:52,726
are writing for all
of these users.


35
00:01:52,996 --> 00:01:55,616
In fact they are so compelling
that they can't get enough


36
00:01:55,696 --> 00:01:58,416
of them and literally
this means more


37
00:01:58,416 --> 00:02:00,996
and more the case this
is literally true.


38
00:02:00,996 --> 00:02:03,556
There just is not enough
space on the device.


39
00:02:04,146 --> 00:02:05,326
So what are we to do?


40
00:02:05,806 --> 00:02:08,466
Well, one thing we can do
is make the observation


41
00:02:08,466 --> 00:02:11,376
that not every part of every
app is needed at any one time.


42
00:02:11,536 --> 00:02:12,706
I will give an example.


43
00:02:12,806 --> 00:02:15,276
I may be on Level 7 of a game.


44
00:02:15,786 --> 00:02:17,886
I certainly don't need
Level 1 any longer


45
00:02:17,886 --> 00:02:20,986
and I probably won't need
Level 30 for quite a while.


46
00:02:21,336 --> 00:02:22,896
So it's with that
thought that we started


47
00:02:22,896 --> 00:02:24,836
to begin to think about ODR.


48
00:02:25,136 --> 00:02:27,456
So now let's look at
an ODR application.


49
00:02:28,316 --> 00:02:31,386
In this case, we start
off with the same bits,


50
00:02:31,386 --> 00:02:33,586
we haven't taken anything
away, but what we're going


51
00:02:33,586 --> 00:02:35,776
to do is we are going to
tease apart the assets


52
00:02:35,776 --> 00:02:37,106
for each level of that game.


53
00:02:37,606 --> 00:02:39,966
And then we are going to upload
the entire thing to the store.


54
00:02:40,786 --> 00:02:43,016
Now, when a customer comes
along and buys the app,


55
00:02:44,276 --> 00:02:46,316
they get the executable
and the base resources


56
00:02:46,426 --> 00:02:48,186
and perhaps the first
level in the game.


57
00:02:49,246 --> 00:02:51,956
So no pun intended we are
already ahead of the game here


58
00:02:51,956 --> 00:02:54,896
because they were able to arrive
at the first level of the game,


59
00:02:55,346 --> 00:02:57,726
the time between buying the app
and playing that first level,


60
00:02:58,026 --> 00:02:59,446
much more quickly
than if they had


61
00:02:59,446 --> 00:03:02,836
to download the entire
app first and they had


62
00:03:02,836 --> 00:03:05,716
to use far less disk
space to do it.


63
00:03:06,136 --> 00:03:08,026
Now, the user starts
playing this game


64
00:03:08,026 --> 00:03:10,646
and the first level is in use.


65
00:03:10,986 --> 00:03:13,926
And a well-designed ODR
application will anticipate


66
00:03:13,926 --> 00:03:15,796
needing, say, the next
level in the game.


67
00:03:16,076 --> 00:03:17,866
So it will download that.


68
00:03:18,326 --> 00:03:21,646
The user continues to play,
they move on to Level 2,


69
00:03:21,646 --> 00:03:25,006
and at this point, the
caching mechanism built


70
00:03:25,006 --> 00:03:27,646
into ODR notices you are
no longer using Level 2,


71
00:03:27,646 --> 00:03:29,216
well I'm just going to
make a note of that.


72
00:03:29,216 --> 00:03:31,576
It's still there, we haven't
done anything with it,


73
00:03:31,576 --> 00:03:33,516
but we're just going to
remember it's no longer needed.


74
00:03:34,156 --> 00:03:37,296
So this continues until we
get to the point, perhaps,


75
00:03:37,296 --> 00:03:38,976
where there is no more
space on the device


76
00:03:38,976 --> 00:03:40,966
for the next level of the game.


77
00:03:40,966 --> 00:03:43,996
We have looked at every other
possible place on the device


78
00:03:44,066 --> 00:03:48,256
to free up resources and all
we have left is ODR content


79
00:03:48,406 --> 00:03:49,166
from this game.


80
00:03:49,166 --> 00:03:52,446
In this case, the caching
mechanism can step in again


81
00:03:52,446 --> 00:03:55,566
and say, you know, I had
Level 1, I can free that up


82
00:03:55,566 --> 00:03:58,746
and now the user can
continue on with the game


83
00:03:58,746 --> 00:03:59,876
and play the next level.


84
00:04:00,726 --> 00:04:02,886
So this is the basic
idea behind ODR;


85
00:04:02,886 --> 00:04:07,226
in the case of a game it's fast
to first play from buy to play


86
00:04:07,756 --> 00:04:10,846
and it's always occupying a
smaller, more manageable amount


87
00:04:10,846 --> 00:04:14,986
of space on the device.


88
00:04:15,496 --> 00:04:18,266
So now let's talk about
all of the features of ODR


89
00:04:18,266 --> 00:04:20,426
that we provide you,
the developers.


90
00:04:21,505 --> 00:04:25,096
First of all, obviously this
is a dynamically loaded content


91
00:04:25,096 --> 00:04:27,376
system and you have
probably used systems sort


92
00:04:27,376 --> 00:04:30,056
of like this before, but we
have added some new wrinkles.


93
00:04:30,656 --> 00:04:32,326
First of all we are
going to host the content


94
00:04:32,326 --> 00:04:34,516
on the App Store right
along with your app.


95
00:04:35,336 --> 00:04:39,336
Second of all, we can download
content during app install


96
00:04:39,336 --> 00:04:42,556
as well as by request and
in fact we can automate,


97
00:04:43,796 --> 00:04:49,326
we can automate this
content download at any time.


98
00:04:49,466 --> 00:04:52,596
And finally, we also include an
intelligent caching mechanism


99
00:04:52,596 --> 00:04:53,166
that I mentioned.


100
00:04:53,956 --> 00:04:58,236
So, for example, we can free
up space to load something new.


101
00:04:58,616 --> 00:05:04,366
And finally, a traditional app
maxes out at 4-gig submission


102
00:05:04,366 --> 00:05:08,596
in the Store, but with
ODR your app can now be


103
00:05:08,626 --> 00:05:09,876
up to 20 gigabytes.


104
00:05:10,566 --> 00:05:14,036
Most of this, of
course, is ODR content.


105
00:05:14,036 --> 00:05:14,266
All right.


106
00:05:15,056 --> 00:05:16,676
So that's what's in it
for you, the developer,


107
00:05:16,676 --> 00:05:17,826
but what's in it for the user?


108
00:05:19,176 --> 00:05:23,436
Well, first of all, we can
improve the install experience.


109
00:05:24,106 --> 00:05:28,556
A traditional DLC system, a game
written using such a technology,


110
00:05:28,906 --> 00:05:30,996
provides an experience
something like this:


111
00:05:30,996 --> 00:05:33,576
the user downloads the
app, they are all excited


112
00:05:33,576 --> 00:05:34,546
about playing the game.


113
00:05:34,786 --> 00:05:37,786
They launch it, but oh no,
the game now needs to go


114
00:05:37,786 --> 00:05:39,736
and download new content.


115
00:05:39,736 --> 00:05:43,546
With ODR we can make sure that
that content is on the device


116
00:05:43,786 --> 00:05:45,686
when the app looks
like it is installed.


117
00:05:45,686 --> 00:05:49,286
So the experience for
the user is much better.


118
00:05:50,086 --> 00:05:53,296
Second, because we are
occupying a smaller


119
00:05:53,296 --> 00:05:57,306
and more manageable space on
device, the footprint of the app


120
00:05:57,306 --> 00:06:00,566
at any one time, we can have
more apps on the device ready


121
00:06:00,566 --> 00:06:03,266
to go and more apps ready
to go at any one time


122
00:06:03,266 --> 00:06:04,986
on the device is always a
good thing for the user.


123
00:06:05,626 --> 00:06:09,326
And finally, for the
user, because, again,


124
00:06:09,326 --> 00:06:11,986
there is more space and we
are keeping a lot of the app


125
00:06:11,986 --> 00:06:16,806
or the game in the cloud on the
App Store, we can have levels


126
00:06:16,846 --> 00:06:19,286
that are richer and more
expansive, for example.


127
00:06:19,596 --> 00:06:22,286
And that is always a good
thing for the user as well.


128
00:06:23,246 --> 00:06:27,816
Okay. So now let's dive into
some of the details about ODR.


129
00:06:29,296 --> 00:06:31,906
First of all, it's an
elementive app thinning in iOS 9


130
00:06:33,176 --> 00:06:35,766
and it's well integrated
with app slicing.


131
00:06:36,006 --> 00:06:38,586
In case you missed the
details of app slicing earlier


132
00:06:38,586 --> 00:06:40,496
in the conference,
app slicing is all


133
00:06:40,496 --> 00:06:43,726
about tailoring the download of
an app to a particular device.


134
00:06:44,406 --> 00:06:46,446
So let me give you an
example: You write an app


135
00:06:46,606 --> 00:06:49,526
that targets many different
iPhone sizes and iPads.


136
00:06:50,726 --> 00:06:53,246
A user with an iPhone comes
along and when they buy


137
00:06:53,246 --> 00:06:55,476
that app, app slicing makes sure


138
00:06:55,476 --> 00:06:58,666
that they only get the resources
you need for that phone.


139
00:06:59,546 --> 00:07:01,346
In the past they
would have gotten all


140
00:07:01,346 --> 00:07:03,136
of the assets including
those for an iPad.


141
00:07:03,916 --> 00:07:08,636
So now when we combine app
slicing and we join it with ODR,


142
00:07:08,896 --> 00:07:10,456
we double the benefits of both.


143
00:07:10,456 --> 00:07:12,306
The footprint is
still even smaller.


144
00:07:12,736 --> 00:07:15,366
We are getting to
first play even faster


145
00:07:15,666 --> 00:07:17,956
and the constant
steady state of the app


146
00:07:18,266 --> 00:07:20,476
on device is much smaller.


147
00:07:21,076 --> 00:07:26,966
Okay. So what does
an ODR app look like?


148
00:07:26,966 --> 00:07:27,826
How is it structured?


149
00:07:28,186 --> 00:07:32,686
It's pretty similar to an
app today, but as you recall,


150
00:07:32,686 --> 00:07:35,926
we teased apart the assets
for those levels in the game.


151
00:07:36,416 --> 00:07:37,806
We call these asset packs.


152
00:07:38,666 --> 00:07:40,766
And the rest of the app
remains your dot app.


153
00:07:41,986 --> 00:07:46,386
Now, you group these together
using Xcode with simple tags.


154
00:07:46,386 --> 00:07:49,006
For example, these are
all my assets in Level 1


155
00:07:49,076 --> 00:07:50,096
of the game, for example.


156
00:07:50,266 --> 00:07:51,776
It's pretty simple to set up.


157
00:07:52,016 --> 00:07:56,146
And you can tag a single
file or a whole folder.


158
00:07:56,146 --> 00:07:58,606
This whole folder is
Level 2, for example.


159
00:07:59,036 --> 00:07:59,786
All right.


160
00:08:00,136 --> 00:08:01,786
Now, what can you tag?


161
00:08:03,256 --> 00:08:05,476
Well, pretty much anything
that can be in a dot app today.


162
00:08:06,386 --> 00:08:11,796
For example, images,
sounds, data, scripts,


163
00:08:12,056 --> 00:08:13,456
many games have scripts in them,


164
00:08:13,886 --> 00:08:17,076
you can also have
in-app purchased content.


165
00:08:17,076 --> 00:08:19,916
So now you can tie together
your in-app purchased receipts


166
00:08:20,376 --> 00:08:21,966
with in-app purchased content


167
00:08:21,966 --> 00:08:24,376
that you are actually
downloading via ODR,


168
00:08:24,376 --> 00:08:26,536
and taking advantage of
all the other ODR API


169
00:08:26,536 --> 00:08:27,446
to help manage that.


170
00:08:28,426 --> 00:08:31,246
The only thing you can't have
is executable content: That's,


171
00:08:31,246 --> 00:08:34,306
again, the compiled
Swift, Objective-C, C, C++.


172
00:08:34,586 --> 00:08:36,926
Leave that in your dot app.


173
00:08:37,086 --> 00:08:37,816
All right.


174
00:08:38,826 --> 00:08:41,796
So where is this content hosted?


175
00:08:42,385 --> 00:08:43,846
Well, I mentioned
one of the locations;


176
00:08:43,846 --> 00:08:44,926
it's obviously the App Store.


177
00:08:46,216 --> 00:08:48,766
We host it in the App Store and
we serve it on demand as needed,


178
00:08:49,596 --> 00:08:52,666
but during development, Xcode
stands in for the App Store,


179
00:08:52,816 --> 00:08:53,666
whether you are developing


180
00:08:53,666 --> 00:08:55,446
against a device
or the simulator.


181
00:08:55,886 --> 00:08:59,216
And it hosts it to your app
and delivers it on demand.


182
00:09:00,056 --> 00:09:03,006
Now, another tool in the Xcode
tool box is the Xcode Server.


183
00:09:03,496 --> 00:09:05,256
You can set this up in
your own department,


184
00:09:05,956 --> 00:09:09,086
such that the app along with
the ODR content is available


185
00:09:09,086 --> 00:09:10,746
on that server, for example,


186
00:09:10,746 --> 00:09:13,946
your Q/A engineering
group to test your app.


187
00:09:14,916 --> 00:09:16,406
And as you might expect,


188
00:09:16,566 --> 00:09:18,526
TestFlight is fully
integrated with ODR.


189
00:09:20,036 --> 00:09:21,766
And finally, if you
are deploying an app


190
00:09:21,766 --> 00:09:24,796
into Enterprise, you can
actually host ODR content


191
00:09:24,796 --> 00:09:27,886
on a web server inside of your
enterprise including behind a


192
00:09:27,886 --> 00:09:31,006
secure login so that not just
anyone can get at that content.


193
00:09:32,296 --> 00:09:34,156
So that's where we
host ODR content.


194
00:09:34,676 --> 00:09:36,056
All right.


195
00:09:36,836 --> 00:09:38,126
So how do you get started?


196
00:09:38,786 --> 00:09:40,296
Well, as a developer,
the first thing you need


197
00:09:40,296 --> 00:09:43,896
to do is take a look at all the
many assets you have in your app


198
00:09:43,896 --> 00:09:45,546
and start to identify them.


199
00:09:45,546 --> 00:09:46,946
You need to categorize them.


200
00:09:47,826 --> 00:09:50,566
You use this, again, by tagging
them with simple strings.


201
00:09:51,016 --> 00:09:53,146
These are all of the assets
that are in Level 1 of my game.


202
00:09:53,786 --> 00:09:55,696
These are the assets
for Level 2 of my game.


203
00:09:55,936 --> 00:09:58,266
And you know, there are some
shared assets between levels?


204
00:09:59,286 --> 00:09:59,746
There they are.


205
00:09:59,746 --> 00:10:03,276
So you can tag assets with
multiple tags in order


206
00:10:03,276 --> 00:10:06,216
to indicate the sharing
and avoid duplication.


207
00:10:07,046 --> 00:10:10,426
So this is part one of
getting ready to use ODR


208
00:10:10,426 --> 00:10:11,916
and that was your
job as a developer.


209
00:10:12,256 --> 00:10:15,386
Now, Xcode does its job because
it takes all this tagging


210
00:10:15,736 --> 00:10:17,946
and groups these
into asset packs.


211
00:10:18,086 --> 00:10:20,756
In this case, we ended up
with three asset packs.


212
00:10:21,656 --> 00:10:25,356
We have the asset pack for Level
1, the asset pack for Level 2,


213
00:10:25,656 --> 00:10:27,676
and we ended up with
a third asset pack


214
00:10:27,676 --> 00:10:30,116
which is the shared assets
between those two levels,


215
00:10:30,716 --> 00:10:32,266
again, avoiding duplication.


216
00:10:33,776 --> 00:10:36,206
Okay. So Xcode has done its job.


217
00:10:36,206 --> 00:10:37,716
Now, it's back to
you, the developer.


218
00:10:39,026 --> 00:10:39,956
The first thing you need


219
00:10:39,956 --> 00:10:42,306
to do is basically just
request the resources: Hey,


220
00:10:42,606 --> 00:10:44,456
I need everything for Level 1,


221
00:10:45,036 --> 00:10:48,406
and down come the two asset
packs, both the dedicated one


222
00:10:48,516 --> 00:10:51,476
to Level 1, and then the
one that was sharing assets


223
00:10:51,476 --> 00:10:52,736
between Level 1 and Level 2.


224
00:10:52,816 --> 00:10:55,386
And because we brought down
that shared asset pack,


225
00:10:55,896 --> 00:10:58,706
when we request Level
2, we get those assets


226
00:10:59,276 --> 00:11:01,416
and we already have the
shared assets on the device.


227
00:11:02,686 --> 00:11:07,326
So this is a high level overview
of what ODR is all about as well


228
00:11:07,326 --> 00:11:09,146
as how to build an
ODR application.


229
00:11:09,146 --> 00:11:10,956
Now, I would like to
invite on stage Tony Parker


230
00:11:11,256 --> 00:11:13,516
to show us how it's done
in Xcode with a real API.


231
00:11:13,896 --> 00:11:14,146
Tony.


232
00:11:15,516 --> 00:11:20,086
[Applause]


233
00:11:20,586 --> 00:11:21,306
>> TONY PARKER: Thanks, Steve.


234
00:11:21,956 --> 00:11:23,626
So, again, my name is Tony
Parker, I'm the manager


235
00:11:23,626 --> 00:11:24,796
of the Foundation team at Apple.


236
00:11:25,426 --> 00:11:26,976
So Steve gave you
a basic overview


237
00:11:26,976 --> 00:11:28,656
of how the ODR system works.


238
00:11:29,046 --> 00:11:31,196
Now we are going to dive
in to the API that we use


239
00:11:31,196 --> 00:11:33,606
in your application to
actually make those requests.


240
00:11:34,296 --> 00:11:37,516
There is really just one piece
of API that you need to know.


241
00:11:37,616 --> 00:11:41,206
It's a new class in Foundation
called NSBundleResourceRequest.


242
00:11:41,686 --> 00:11:45,346
This class follows the
command design pattern.


243
00:11:45,596 --> 00:11:47,066
So what that means is
you're going to set up one


244
00:11:47,066 --> 00:11:48,506
of these objects with
a set of options,


245
00:11:49,096 --> 00:11:51,186
including of course the set of
tags that you are interested


246
00:11:51,186 --> 00:11:54,066
in using, and then you tell
it to begin its request.


247
00:11:54,626 --> 00:11:58,666
So you can create as many of
these objects as you need.


248
00:11:58,726 --> 00:12:00,866
That's because the system
will ref count the tags


249
00:12:00,866 --> 00:12:01,466
under the hood.


250
00:12:01,466 --> 00:12:04,006
So if you have several different
parts of your application


251
00:12:04,006 --> 00:12:08,206
that use ODR and perhaps use
overlapping tags, you don't need


252
00:12:08,206 --> 00:12:10,016
to create a manager
class to keep track


253
00:12:10,016 --> 00:12:11,846
of which ones you
have in use at a time.


254
00:12:11,846 --> 00:12:13,186
We will go ahead
and do that for you.


255
00:12:15,656 --> 00:12:19,156
The most important point,
design point about this class is


256
00:12:19,156 --> 00:12:21,016
that the request is decoupled


257
00:12:21,016 --> 00:12:23,076
from the actual use
of the resources.


258
00:12:23,766 --> 00:12:26,666
What this means is that all
of the APIs that you use today


259
00:12:26,666 --> 00:12:28,426
in your application and
you are already familiar


260
00:12:28,426 --> 00:12:31,186
with like NSBundle's
URLForResource,


261
00:12:31,456 --> 00:12:35,546
NSData's dataWithContentsOfURL
or UIImage imageNamed,


262
00:12:36,116 --> 00:12:38,316
all of those APIs
remain actually as is.


263
00:12:38,796 --> 00:12:41,056
You just need to tell the
system in advance using one


264
00:12:41,056 --> 00:12:43,076
of these request objects
that you are going


265
00:12:43,076 --> 00:12:44,626
to need those resources
to be present.


266
00:12:47,416 --> 00:12:49,476
This object forms a very
simple state machine.


267
00:12:49,726 --> 00:12:51,276
So start off in init.


268
00:12:52,286 --> 00:12:53,916
We move it to this
requested state


269
00:12:53,916 --> 00:12:56,066
when we anticipate the
need for those resources.


270
00:12:56,686 --> 00:12:59,926
And we're going to get back
a completion handler callback


271
00:12:59,926 --> 00:13:02,506
which will tell us either the
resources are now available


272
00:13:02,506 --> 00:13:05,846
for you to use and you can
continue to use those APIs


273
00:13:05,846 --> 00:13:08,906
that we just discussed,
or an error occurred.


274
00:13:09,166 --> 00:13:11,816
Now, of course, when you are
using ODR there are a few errors


275
00:13:11,816 --> 00:13:14,046
that can occur that we may
need to present to the user.


276
00:13:14,366 --> 00:13:16,796
That could include, perhaps,
there is no network available


277
00:13:16,796 --> 00:13:18,196
and we need it to
download the content,


278
00:13:18,566 --> 00:13:20,796
or maybe there is not enough
disk space on the device even


279
00:13:20,796 --> 00:13:23,176
after we tried purging
to hold the content.


280
00:13:23,616 --> 00:13:25,916
So in any case, you need to
present that to the user.


281
00:13:25,976 --> 00:13:27,856
Perhaps there is something they
can do to resolve the issue.


282
00:13:28,336 --> 00:13:31,646
So if the resources were
available, then, as I said,


283
00:13:31,646 --> 00:13:34,936
you can continue to use
them, and also important,


284
00:13:34,936 --> 00:13:37,266
when you are done with those
resources, please tell us


285
00:13:37,266 --> 00:13:39,616
about it, and there are
two mechanisms to do that.


286
00:13:39,976 --> 00:13:42,836
The first is to call an
explicit API on this class


287
00:13:43,246 --> 00:13:45,236
that tells us you are
finished with the content.


288
00:13:46,016 --> 00:13:48,546
The second is to allow the
class to be deallocated,


289
00:13:48,546 --> 00:13:49,876
allow the object
to be deallocated,


290
00:13:49,876 --> 00:13:51,876
in which case we are
going to go ahead


291
00:13:51,876 --> 00:13:54,166
and end the request
on your behalf.


292
00:13:54,626 --> 00:13:58,026
So here is what the
basic methods look like.


293
00:13:58,616 --> 00:14:01,526
First, an initializer, and
you can see it takes a set


294
00:14:01,526 --> 00:14:02,096
of strings.


295
00:14:02,206 --> 00:14:04,316
Those are the tags that you
are interested in requesting.


296
00:14:05,516 --> 00:14:07,736
The method to begin
the request is called


297
00:14:07,736 --> 00:14:09,996
beginAccessingResources
WithCompletionHander,


298
00:14:09,996 --> 00:14:11,536
and you can see there's
the closure


299
00:14:11,536 --> 00:14:13,816
that has the NSError argument.


300
00:14:15,176 --> 00:14:16,306
And finally that method


301
00:14:16,306 --> 00:14:17,706
that tells the system
you are finished,


302
00:14:18,016 --> 00:14:20,186
the explicit
endAccessingResources call.


303
00:14:22,306 --> 00:14:24,796
So next I would like to go
into a demo and show you some


304
00:14:24,796 --> 00:14:25,776
of this API in action.


305
00:14:25,776 --> 00:14:26,426
All right.


306
00:14:34,116 --> 00:14:38,586
So here you have our demo app
today, it's called iTravel,


307
00:14:38,996 --> 00:14:41,866
and iTravel is called iTravel
because it's a travel guide


308
00:14:42,226 --> 00:14:44,576
that gives you all kinds
interesting information


309
00:14:44,576 --> 00:14:48,376
about countries whose names
begin with the letter I.


310
00:14:48,376 --> 00:14:50,446
As you can see, we support
two countries today:


311
00:14:50,736 --> 00:14:52,446
There's Iceland and Italy.


312
00:14:53,006 --> 00:14:54,896
Now, this kind of application
is a great candidate


313
00:14:54,896 --> 00:14:56,626
for adopting On Demand
Resources.


314
00:14:56,666 --> 00:14:58,606
And that is, the reason is


315
00:14:58,606 --> 00:15:00,226
because when the
user buys this app,


316
00:15:00,546 --> 00:15:03,186
they are maybe not interested
in getting all the information


317
00:15:03,186 --> 00:15:06,226
about both Iceland and
Italy or at least not both


318
00:15:06,226 --> 00:15:09,596
at the same time so we
can make the install size


319
00:15:09,596 --> 00:15:12,226
and the download size much
smaller by downloading


320
00:15:12,226 --> 00:15:13,466
that content on demand.


321
00:15:14,136 --> 00:15:15,746
So before we adopt
ODR I just want


322
00:15:15,746 --> 00:15:18,076
to show you a brief
example of how you use this.


323
00:15:18,446 --> 00:15:20,426
First I will go ahead
and visit Iceland.


324
00:15:21,796 --> 00:15:24,596
You can see that I get a list
here of points of interest.


325
00:15:25,216 --> 00:15:26,786
So I can pick one of these


326
00:15:27,216 --> 00:15:29,626
and there is some high
quality pictures, perhaps,


327
00:15:29,626 --> 00:15:32,086
or guide text, and
each of these points


328
00:15:32,086 --> 00:15:34,136
of interest has more pictures.


329
00:15:34,536 --> 00:15:39,436
So you can see that this could
add up to quite a bit of data.


330
00:15:39,576 --> 00:15:41,676
And Italy, of course,
behaves the same way,


331
00:15:42,026 --> 00:15:43,896
but with a different
set of content.


332
00:15:44,386 --> 00:15:48,356
So let's look at how this
application is built.


333
00:15:48,356 --> 00:15:53,186
We are going to spend
most of our time today


334
00:15:53,186 --> 00:15:56,156
in just one class, it's called
the AlbumTableViewController.


335
00:15:56,156 --> 00:15:58,976
This is the view controller
that controls this view


336
00:15:58,976 --> 00:16:01,346
that we see right here with
the list of points of interest.


337
00:16:02,066 --> 00:16:03,286
So let me show you how it works.


338
00:16:04,486 --> 00:16:07,056
When we segue into
this view, we are going


339
00:16:07,056 --> 00:16:09,656
to have this function
called loadAlbum,


340
00:16:09,656 --> 00:16:11,716
and the argument is going to be
which album we are interested


341
00:16:11,716 --> 00:16:13,526
in looking at, either
Italy or Iceland.


342
00:16:14,856 --> 00:16:17,116
We set our title and we
call this helper function


343
00:16:17,116 --> 00:16:18,416
called populateTable.


344
00:16:19,136 --> 00:16:21,456
Now, here in the populateTable
function, we are going


345
00:16:21,456 --> 00:16:25,936
to use NSBundle's URLForResource
to find a JSON file


346
00:16:25,936 --> 00:16:28,216
which describes all of the
points of interest with pictures


347
00:16:28,216 --> 00:16:29,696
to show what the captions are.


348
00:16:29,696 --> 00:16:33,006
We are using NSData's
contentsOfURL method


349
00:16:33,006 --> 00:16:35,026
to actually read that
JSON file from disk.


350
00:16:35,026 --> 00:16:38,156
We are using NSJSONSerialization
to parse it.


351
00:16:38,206 --> 00:16:40,476
We are setting up some more
detailed label text here,


352
00:16:40,716 --> 00:16:42,676
and finally we ask the
tableView to reload itself,


353
00:16:43,056 --> 00:16:43,856
and the data source


354
00:16:43,856 --> 00:16:47,246
in the tableView is
using UIImage.imageNamed


355
00:16:47,386 --> 00:16:49,426
to actually show that,
to fetch that picture.


356
00:16:49,986 --> 00:16:54,246
So the important point here
is that as we adopt ODR


357
00:16:54,246 --> 00:16:55,926
in this application, nothing


358
00:16:55,926 --> 00:16:57,916
in this populateTable
function has to change.


359
00:16:58,446 --> 00:17:00,766
So, again, all of the
APIs that you use today


360
00:17:00,766 --> 00:17:04,536
that access contents of files
on disk or finds those files


361
00:17:04,536 --> 00:17:07,386
like NSBundles, those
remain exactly the same.


362
00:17:07,965 --> 00:17:10,316
So the first thing we are going


363
00:17:10,316 --> 00:17:12,656
to do is actually add some
tags to our application.


364
00:17:13,006 --> 00:17:16,086
So to do that, I will bring
up the inspector here,


365
00:17:16,806 --> 00:17:19,536
and you can see that I have
already organized my application


366
00:17:19,536 --> 00:17:22,036
to have a group called
Resources,


367
00:17:22,396 --> 00:17:25,195
and folders that contain
some of my content.


368
00:17:25,346 --> 00:17:29,126
So this one contains all of the
picture from Iceland, this one,


369
00:17:29,126 --> 00:17:32,986
all of the pictures from
Italy, and these JSON files


370
00:17:32,986 --> 00:17:33,756
that I was discussing.


371
00:17:33,756 --> 00:17:36,786
So what I'm going
to do is go ahead


372
00:17:36,786 --> 00:17:40,676
and select both the JSON file
for Iceland and the folder


373
00:17:41,206 --> 00:17:43,706
and look on the right side
here in this inspector.


374
00:17:43,706 --> 00:17:46,566
You see there is a new field,
On Demand Resource Tags,


375
00:17:47,376 --> 00:17:49,206
so all I have to do
here is start typing


376
00:17:49,406 --> 00:17:52,406
and we will tag our
content as Iceland.


377
00:17:52,446 --> 00:17:55,446
And we will do the same
for our Italy content.


378
00:17:56,156 --> 00:18:02,836
So next we just, so that,
what that does is, of course,


379
00:18:02,836 --> 00:18:05,736
as Steve explained, tell Xcode
how to split up your content.


380
00:18:06,086 --> 00:18:09,276
Now, the next part is to
tell the system at runtime


381
00:18:09,576 --> 00:18:11,606
that when we anticipate the need


382
00:18:11,606 --> 00:18:12,936
for that content
to be available.


383
00:18:12,936 --> 00:18:15,286
So we will do that here
in this view controller.


384
00:18:15,286 --> 00:18:18,906
So the first thing I'm going to
do is add an I var to my class


385
00:18:18,956 --> 00:18:21,176
that holds the class that
we've been talking about,


386
00:18:21,176 --> 00:18:22,366
NSBundleResourceRequest.


387
00:18:22,996 --> 00:18:24,986
So what I'm doing is
taking advantage of the fact


388
00:18:24,986 --> 00:18:27,016
that when this view
controller is torn down,


389
00:18:27,456 --> 00:18:30,206
we maintain pretty tight
control over this object.


390
00:18:30,206 --> 00:18:33,316
So we can control its lifetime
so when it's torn down we know


391
00:18:33,316 --> 00:18:34,386
that we are done
with the request


392
00:18:34,386 --> 00:18:36,686
and we can allow the
system to deallocate it


393
00:18:36,686 --> 00:18:39,366
and that will tell the system
we are done with the content.


394
00:18:39,766 --> 00:18:44,266
Next in our loadAlbum function
before we call populate table,


395
00:18:44,266 --> 00:18:47,516
we are going to create the
request, we are passing


396
00:18:47,516 --> 00:18:50,216
in the set of tags, in this
case it's a set of one tag


397
00:18:50,246 --> 00:18:51,856
which is either Italy
or Iceland.


398
00:18:52,416 --> 00:18:56,136
We call beginAccessingResources
WithCompletionHandler (without


399
00:18:56,306 --> 00:18:57,876
space), and when
we get a result,


400
00:18:58,026 --> 00:19:01,806
this closure will be called,
and it may have an error.


401
00:19:02,156 --> 00:19:04,796
So on the main thread, because
this completion handler will be


402
00:19:04,796 --> 00:19:07,666
called on a non-main thread,
we are going to first check


403
00:19:07,666 --> 00:19:08,946
to make sure that
the error is nil.


404
00:19:09,326 --> 00:19:11,226
If it's non-nil, then
an error occurred


405
00:19:11,226 --> 00:19:13,406
and as we discussed it's
important to present


406
00:19:13,406 --> 00:19:15,686
that to the user, which I'm
doing in a helper function here.


407
00:19:16,616 --> 00:19:18,996
Then we call the exact
same populateTable function


408
00:19:19,266 --> 00:19:20,476
that we just went through.


409
00:19:20,666 --> 00:19:22,016
So, again, nothing
in there changed.


410
00:19:22,746 --> 00:19:24,286
Let's go ahead and run
the application again


411
00:19:24,286 --> 00:19:25,806
and see how this looks.


412
00:19:29,636 --> 00:19:33,016
So now, I'm going to visit
Iceland and we will see


413
00:19:33,016 --> 00:19:36,696
that my content is here because
we have made a request for it,


414
00:19:36,696 --> 00:19:39,676
and I can choose some of these
pictures or points of interest,


415
00:19:40,036 --> 00:19:42,196
and all of my content
is available just


416
00:19:42,196 --> 00:19:44,146
as if it had been part of the
application from the start.


417
00:19:44,146 --> 00:19:46,166
Now, this is a good opportunity


418
00:19:46,166 --> 00:19:48,186
to show you a new
debugging feature in Xcode


419
00:19:48,186 --> 00:19:49,746
that can really help
you to understand


420
00:19:49,996 --> 00:19:51,816
if you are using
these request objects


421
00:19:51,816 --> 00:19:52,826
in the way you think you are.


422
00:19:52,826 --> 00:19:54,956
And that's a new debug gauge.


423
00:19:55,766 --> 00:19:56,366
So I'm going to bring


424
00:19:56,366 --> 00:19:58,766
up the debug gauge view
here and choose disk.


425
00:19:59,296 --> 00:20:01,676
And you'll notice in the middle
we have a new section called


426
00:20:02,106 --> 00:20:03,136
On Demand Resources.


427
00:20:03,616 --> 00:20:05,886
It lists all of the tags that
are part of your application,


428
00:20:06,746 --> 00:20:10,776
so Iceland and Italy, their
size and their current status.


429
00:20:11,196 --> 00:20:13,696
You notice that Iceland
is listed as in use,


430
00:20:13,996 --> 00:20:15,666
and that makes sense
because we are looking


431
00:20:15,666 --> 00:20:18,496
at the Iceland content right
here and it remains in use


432
00:20:18,496 --> 00:20:19,886
as I view some of
these pictures.


433
00:20:20,326 --> 00:20:21,826
But if I go back
to the main table


434
00:20:21,826 --> 00:20:24,446
of contents its status
is changed from in use


435
00:20:24,446 --> 00:20:26,696
to downloaded, and
that's because again


436
00:20:26,696 --> 00:20:28,366
that request object
was deallocated


437
00:20:28,556 --> 00:20:31,456
and the system now knows we are
no longer using that content.


438
00:20:31,916 --> 00:20:35,726
We didn't delete it off disk
immediately so if you go back


439
00:20:35,726 --> 00:20:37,756
to Iceland the content
is available again


440
00:20:38,016 --> 00:20:40,036
and the status changes
back to in use.


441
00:20:40,036 --> 00:20:42,856
Let's see what happens
if I visit Italy now.


442
00:20:42,856 --> 00:20:45,896
Now, you notice that it's going


443
00:20:45,896 --> 00:20:48,966
to take some time to
show this content.


444
00:20:49,436 --> 00:20:52,856
And the reason for
that is that the size


445
00:20:52,856 --> 00:20:55,796
of the Italy tag is actually
much larger than the one


446
00:20:55,796 --> 00:20:57,686
for Iceland; it's
130 megabytes here.


447
00:20:58,386 --> 00:21:00,986
Now, there are two things
that are important to do here.


448
00:21:01,226 --> 00:21:05,856
The first is to actually reduce
the size of the tagged content,


449
00:21:05,856 --> 00:21:08,576
split it up into smaller
chunks, and we are going to go


450
00:21:08,576 --> 00:21:10,776
into some more detail on the
best practices for that later,


451
00:21:11,316 --> 00:21:12,956
but for now, what I want


452
00:21:12,956 --> 00:21:15,286
to do is show you how you
can adopt progress reporting


453
00:21:15,386 --> 00:21:18,106
in your application
in conjunction


454
00:21:18,106 --> 00:21:20,266
with NSBundleResourceRequest
so that


455
00:21:20,266 --> 00:21:22,546
when you are downloading
this content you can display


456
00:21:22,546 --> 00:21:25,406
something to the user so they
understand what's going on.


457
00:21:25,406 --> 00:21:32,146
So let's go back to our
AlbumTableViewController class.


458
00:21:32,596 --> 00:21:37,816
So what we are going
to do is take advantage


459
00:21:37,816 --> 00:21:40,806
of NSBundleResourceRequest
support for NSProgress,


460
00:21:40,806 --> 00:21:44,056
which is a foundation class
you can use to report progress


461
00:21:44,056 --> 00:21:47,216
and compose progress
across your application.


462
00:21:48,486 --> 00:21:51,866
NSProgress supports key value
observing, so what we're going


463
00:21:51,866 --> 00:21:54,526
to do is add this view
controller as an observer


464
00:21:54,526 --> 00:21:58,886
of the progress and in response
to updates, change some UI


465
00:21:58,886 --> 00:22:00,486
on the screen, a
UI progress view,


466
00:22:00,486 --> 00:22:01,926
and some detail label text.


467
00:22:02,916 --> 00:22:06,366
So right here after
we create the request,


468
00:22:06,526 --> 00:22:08,716
we are going to call
addObserver.


469
00:22:09,146 --> 00:22:10,376
This class will be the observer.


470
00:22:10,376 --> 00:22:12,126
The progress property


471
00:22:12,126 --> 00:22:14,576
of the request is the
object we are observing.


472
00:22:15,606 --> 00:22:18,296
The key path of the progress
is fractionCompleted.


473
00:22:18,906 --> 00:22:21,396
And as always when
using KVO it's important


474
00:22:21,396 --> 00:22:23,256
to specify a unique
context pointer


475
00:22:23,616 --> 00:22:25,076
which I have defined
elsewhere in this file.


476
00:22:26,016 --> 00:22:29,366
Also, we are going to go ahead
and unhide a UI progressView


477
00:22:29,546 --> 00:22:31,596
that I have already hooked
up in our storyboard.


478
00:22:32,246 --> 00:22:36,766
When we get our response, that's
a great time to removeObserver


479
00:22:36,856 --> 00:22:39,096
because after that point
we are no longer interested


480
00:22:39,096 --> 00:22:40,596
in updates to the progress.


481
00:22:41,426 --> 00:22:45,376
And then on the main thread we
are also going to unhide the --


482
00:22:45,376 --> 00:22:47,516
sorry, rehide the
UI progressView


483
00:22:47,516 --> 00:22:49,026
because we don't want
our user to be staring


484
00:22:49,026 --> 00:22:50,126
at complete progress bars.


485
00:22:50,536 --> 00:22:53,336
So that adds ourselves
as an observer


486
00:22:53,686 --> 00:22:56,566
and then the second part of
this is to actually do something


487
00:22:56,566 --> 00:22:58,246
when the value changes,


488
00:22:58,246 --> 00:23:00,486
and we do that in the
traditional KVO method,


489
00:23:00,796 --> 00:23:02,066
observeValueForKeyPath.


490
00:23:02,706 --> 00:23:04,186
So here we are first
checking to make sure


491
00:23:04,186 --> 00:23:07,106
that this is the update that
we are interested in observing


492
00:23:07,106 --> 00:23:09,356
by checking the context
pointer and the key path,


493
00:23:10,046 --> 00:23:13,216
and on the main thread, again,
because this update will come


494
00:23:13,216 --> 00:23:14,956
on a non-main thread,
we are going


495
00:23:14,956 --> 00:23:18,396
to update our UI progressView by
setting its progress property,


496
00:23:18,866 --> 00:23:20,176
and we are going
to take advantage


497
00:23:20,176 --> 00:23:24,596
of NSProgress's support for an
automatic localized description


498
00:23:24,596 --> 00:23:26,476
by using its
localizedDescription method.


499
00:23:27,006 --> 00:23:30,526
Let's go ahead and run this
again and see how that works.


500
00:23:36,196 --> 00:23:39,036
So this time when I visit
Italy, you will notice


501
00:23:39,036 --> 00:23:41,546
that at the bottom our detail
label text has been updated


502
00:23:41,546 --> 00:23:45,396
to show a percent completed, and
then as the download completes,


503
00:23:45,396 --> 00:23:48,196
our UI progress view is
updated to show the user


504
00:23:48,196 --> 00:23:49,086
that something has happened.


505
00:23:50,156 --> 00:23:52,696
Also, again, we didn't
delete the content eagerly


506
00:23:52,696 --> 00:23:54,566
so if we go back and
visit Italy again,


507
00:23:54,836 --> 00:23:56,746
you notice that the content
is immediately available


508
00:23:57,286 --> 00:24:00,216
because it's been cached by
the On Demand Resources system.


509
00:24:00,746 --> 00:24:03,026
Let's go back to our slides.


510
00:24:04,386 --> 00:24:13,106
So a few more things about
the progress reporting part


511
00:24:13,106 --> 00:24:13,666
of that demo.


512
00:24:14,126 --> 00:24:16,136
So, again, you can find
information on the progress


513
00:24:16,136 --> 00:24:18,806
of the request by looking
at the progress property.


514
00:24:19,846 --> 00:24:22,276
We also support cancellation,
pausing, and resuming


515
00:24:22,276 --> 00:24:24,406
of the request, and those
are methods you will find


516
00:24:24,406 --> 00:24:27,286
on the NSProgress property,
not the request itself.


517
00:24:29,256 --> 00:24:33,256
Now, actually in iOS 9 and
OS X 10.11 we have made a lot


518
00:24:33,256 --> 00:24:34,376
of really great improvements


519
00:24:34,436 --> 00:24:36,536
to the NSProgress
class in Foundation.


520
00:24:37,066 --> 00:24:40,266
So to learn more about how to
use it, how to incorporate it


521
00:24:40,266 --> 00:24:42,626
from this class and from
elsewhere into your application


522
00:24:42,936 --> 00:24:44,926
in a great way, I really
recommend you check


523
00:24:44,926 --> 00:24:47,606
out this talk on
Friday, Best Practices


524
00:24:47,606 --> 00:24:48,476
for Progress Reporting.


525
00:24:49,086 --> 00:24:54,326
So the beginAccessing method
that we used goes ahead


526
00:24:54,326 --> 00:24:56,946
and downloads content if
it's not already available.


527
00:24:57,366 --> 00:24:59,686
However, sometimes you may
want to only use the content


528
00:24:59,686 --> 00:25:01,076
if it's already available
on disk


529
00:25:01,076 --> 00:25:03,036
without triggering a
download and you can do


530
00:25:03,036 --> 00:25:05,026
that using what we call
a conditional request.


531
00:25:05,916 --> 00:25:06,766
Here's the method:


532
00:25:06,826 --> 00:25:09,516
conditionallyBeginAccessing
ResourcesWithCompletionHandler


533
00:25:09,576 --> 00:25:10,936
(without space), and you can see


534
00:25:10,936 --> 00:25:13,116
that the closure here
has a Boolean argument,


535
00:25:13,116 --> 00:25:14,766
so the answer is
either yes or no,


536
00:25:14,896 --> 00:25:17,166
depending on whether the content
is already available or not.


537
00:25:18,026 --> 00:25:22,716
So in the view of our state
machine, we start off in init,


538
00:25:23,316 --> 00:25:25,416
we move to this conditionally
requested state


539
00:25:25,416 --> 00:25:26,486
by invoking this method.


540
00:25:26,486 --> 00:25:29,676
You will get your response,
either it's available or not.


541
00:25:29,896 --> 00:25:32,566
If it's available, then
the resources are available


542
00:25:32,566 --> 00:25:34,166
to you just as if you had
called the other method.


543
00:25:34,166 --> 00:25:36,606
So, again, be sure to
call endAccessingResources


544
00:25:36,876 --> 00:25:38,286
or allow the object
to be deallocated.


545
00:25:38,286 --> 00:25:40,996
If it wasn't available, at
that point you have a choice:


546
00:25:40,996 --> 00:25:43,676
You can either do nothing


547
00:25:43,766 --> 00:25:46,066
or you can call the
beginAccessingResources method


548
00:25:46,066 --> 00:25:47,766
to cause that download
to happen.


549
00:25:48,316 --> 00:25:53,786
And finally, there are two kinds
of priority APIs on this class


550
00:25:53,786 --> 00:25:54,676
that I want to talk about.


551
00:25:55,106 --> 00:25:56,766
The first is called
a loading priority.


552
00:25:56,766 --> 00:25:59,736
This is a double, and
it provides ordering


553
00:25:59,736 --> 00:26:02,156
for the outstanding
requests in your application.


554
00:26:02,656 --> 00:26:04,056
The value ranges from 0 to 1.


555
00:26:04,346 --> 00:26:06,896
So a value of 1 is
the highest priority


556
00:26:06,896 --> 00:26:08,486
and the value of
0 is the lowest.


557
00:26:08,486 --> 00:26:12,316
What we do with these values
is provide a hint to the system


558
00:26:12,376 --> 00:26:15,696
about which outstanding request
should be prioritized first.


559
00:26:16,176 --> 00:26:19,226
So because the value is not
compared across applications


560
00:26:19,226 --> 00:26:21,406
on the system, but
only within your app,


561
00:26:21,626 --> 00:26:23,356
you can use these
values as you choose


562
00:26:23,356 --> 00:26:25,926
to help order the requests
according to your needs.


563
00:26:26,476 --> 00:26:29,526
We do have a constant that
you can use here actually;


564
00:26:29,526 --> 00:26:33,636
it's called loading priority
urgent, and this is for the case


565
00:26:33,636 --> 00:26:35,866
where the user is doing nothing
but waiting for the download


566
00:26:35,866 --> 00:26:37,536
to finish and we will
talk a little bit more


567
00:26:37,536 --> 00:26:38,166
about this later.


568
00:26:38,736 --> 00:26:42,636
The second kind of priority is
called a preservation priority.


569
00:26:43,266 --> 00:26:46,716
So this method provides ordering
of purging for unused tags


570
00:26:46,716 --> 00:26:48,486
in your app, so this
is not associated


571
00:26:48,486 --> 00:26:50,766
with a particular request,
which is why it's an extension


572
00:26:50,766 --> 00:26:54,606
on NSBundle, but instead
with a tag or set of tags.


573
00:26:55,066 --> 00:26:57,016
Again, the value
ranges from 0 to 1,


574
00:26:57,386 --> 00:26:59,586
with 0 being the least
interesting to keep


575
00:26:59,686 --> 00:27:01,396
and 1 being the most
important to keep.


576
00:27:02,246 --> 00:27:05,116
So you can use this to
tell the system a hint


577
00:27:05,156 --> 00:27:08,646
about which content is the most
important to keep if we run


578
00:27:08,646 --> 00:27:10,306
into disk space pressure.


579
00:27:10,916 --> 00:27:12,536
And the value, again,
is compared only


580
00:27:12,536 --> 00:27:13,716
across your own application,


581
00:27:13,716 --> 00:27:15,486
not between applications
on the system.


582
00:27:16,006 --> 00:27:19,136
So with that, I would like
to bring back Steve to go


583
00:27:19,136 --> 00:27:21,206
over some more best
practices about using ODR.


584
00:27:22,016 --> 00:27:23,926
[Applause]


585
00:27:23,926 --> 00:27:24,416
>> STEVE LEWALLEN:
Thank you, Tony.


586
00:27:28,286 --> 00:27:31,246
All right, so now we
have an overview of ODR,


587
00:27:31,246 --> 00:27:33,826
we understand what it's about,
and we have seen it in use.


588
00:27:34,336 --> 00:27:37,166
So now let's talk about
how we build the optimal


589
00:27:37,166 --> 00:27:38,036
ODR application.


590
00:27:38,846 --> 00:27:40,896
Now, to do that, the
first thing that you need


591
00:27:40,896 --> 00:27:43,056
to do before you start
tagging assets is


592
00:27:43,056 --> 00:27:44,776
to consider your app's behavior,


593
00:27:45,246 --> 00:27:48,036
because this will inform
how you need to tag assets.


594
00:27:48,866 --> 00:27:51,636
There are three patterns that
I can offer up for you today


595
00:27:51,636 --> 00:27:54,866
as to how you might
use ODR content.


596
00:27:55,156 --> 00:27:58,716
The first pattern, this is
like Tony's iTravel app.


597
00:27:59,056 --> 00:28:02,006
We couldn't quite anticipate
where the user would want to go.


598
00:28:02,726 --> 00:28:03,756
This is random access.


599
00:28:03,756 --> 00:28:06,046
And in a random access app,


600
00:28:06,046 --> 00:28:09,626
especially when the assets are
larger, the content in total,


601
00:28:09,626 --> 00:28:13,496
what you want to do is tag
more assets and read things


602
00:28:13,496 --> 00:28:16,526
in progressively so that as soon
as the user makes a decision,


603
00:28:16,846 --> 00:28:18,706
they can start to
see some progress


604
00:28:18,706 --> 00:28:19,806
of that decision in the UI.


605
00:28:21,446 --> 00:28:24,516
The next pattern is
called limited prediction.


606
00:28:24,516 --> 00:28:27,886
This is like an open
world game in some sense,


607
00:28:28,356 --> 00:28:30,886
where though there may be
almost an infinite number


608
00:28:30,886 --> 00:28:33,036
of possibilities,
at any one point


609
00:28:33,036 --> 00:28:34,856
in time there's only
a limited subset.


610
00:28:34,856 --> 00:28:36,586
An so again what you want


611
00:28:36,586 --> 00:28:40,446
to do is have many tags
tagging smaller size content,


612
00:28:40,726 --> 00:28:43,606
progressively read that
in, but also be prepared


613
00:28:43,606 --> 00:28:48,286
to discard content that the
user has chosen not to view, as,


614
00:28:48,286 --> 00:28:50,916
for example, the player in the
game moves around the world


615
00:28:50,916 --> 00:28:54,526
and they have left some
location, you should stop using


616
00:28:54,526 --> 00:28:56,636
that indexing resources,
getting rid


617
00:28:56,636 --> 00:28:58,346
of the NSBundleResourceRequest
object.


618
00:28:59,206 --> 00:29:02,086
Now, the third pattern is the
pattern than I've been using


619
00:29:02,086 --> 00:29:03,956
in my example; it's
the levels in the game.


620
00:29:04,186 --> 00:29:06,676
This is the linear
progression game much


621
00:29:06,676 --> 00:29:07,926
like a first person shooter.


622
00:29:08,446 --> 00:29:11,866
In this case, the biggest task
that you have as a developer is


623
00:29:11,866 --> 00:29:15,526
to anticipate well ahead of
time what will be needed next,


624
00:29:16,016 --> 00:29:17,896
but you are pretty
much assured that all


625
00:29:17,896 --> 00:29:20,206
of the content will be
consumed, and so you just want


626
00:29:20,206 --> 00:29:22,416
to start loading that content


627
00:29:22,896 --> 00:29:26,406
within a reasonable
amount of time.


628
00:29:26,626 --> 00:29:31,546
Okay. Speaking of time, there is
a rhythm to how you use ODR API.


629
00:29:32,296 --> 00:29:34,036
So let's give ourselves
a timeline


630
00:29:34,106 --> 00:29:36,966
from the point the app
launches until it exits.


631
00:29:38,036 --> 00:29:41,196
Now, the well-written ODR
application will anticipate


632
00:29:41,196 --> 00:29:43,236
needing assets well beforehand.


633
00:29:43,856 --> 00:29:45,366
Remember, this is a
network-based app.


634
00:29:45,366 --> 00:29:47,156
It's going to have to
download it from the Store


635
00:29:47,476 --> 00:29:49,466
or another location
we went over earlier,


636
00:29:49,596 --> 00:29:50,676
but that will take some time.


637
00:29:51,286 --> 00:29:54,066
So as soon as you anticipate
needing them, assets,


638
00:29:54,246 --> 00:29:56,836
that's when you call
beginAccessingResources


639
00:29:56,836 --> 00:29:58,486
and that will kick
off the download


640
00:29:58,896 --> 00:30:00,766
if the assets are not
yet on the device.


641
00:30:01,956 --> 00:30:05,826
Now, the best-laid plans can
hit, well, network problems,


642
00:30:05,826 --> 00:30:08,386
for example, and other
things that may result


643
00:30:08,386 --> 00:30:11,336
in you needing the resources
before they are actually ready.


644
00:30:11,786 --> 00:30:15,696
And, again, in this case, you
want to bring up the progress UI


645
00:30:15,696 --> 00:30:17,606
that Tony mentioned using
the progress property


646
00:30:17,606 --> 00:30:18,966
and NSBundleResourceRequest.


647
00:30:19,696 --> 00:30:22,686
Share your learning screen,
allow the download to continue,


648
00:30:22,686 --> 00:30:25,296
and then at some point
that will actually finish,


649
00:30:25,586 --> 00:30:27,866
the resources will be
available and you can take


650
00:30:27,866 --> 00:30:31,076
down the loading screen, and you
can begin to use the resources.


651
00:30:31,936 --> 00:30:35,206
Once you are done using the
resources, you absolutely want


652
00:30:35,206 --> 00:30:37,276
to call endAccessingResources


653
00:30:37,776 --> 00:30:40,056
or allow the
NSBundleResourceRequest object


654
00:30:40,126 --> 00:30:43,556
to dealloc in order to tell the
system, hey, I'm done with this.


655
00:30:44,026 --> 00:30:46,256
And remember that that
doesn't mean we go off


656
00:30:46,256 --> 00:30:47,206
and delete that content.


657
00:30:47,296 --> 00:30:49,066
We are just making a note of it.


658
00:30:49,336 --> 00:30:51,866
So this is the basic timeline
you need to be aware of,


659
00:30:52,186 --> 00:30:54,776
and you can make multiple
these requests simultaneously,


660
00:30:54,776 --> 00:30:57,906
you just need to remember
the basic parts of this.


661
00:30:58,666 --> 00:31:04,756
Okay. Now, I had talked about
how ODR can benefit the user


662
00:31:04,756 --> 00:31:06,896
by improving the
installation experience.


663
00:31:07,756 --> 00:31:08,976
So how is that done?


664
00:31:08,976 --> 00:31:10,666
Well, we need your
help to do that.


665
00:31:11,726 --> 00:31:13,176
What you need to do
as a developer is


666
00:31:13,176 --> 00:31:16,576
to consider the assets that the
user is going to need as soon


667
00:31:16,576 --> 00:31:17,406
as they launch the app.


668
00:31:18,716 --> 00:31:20,846
When you know what those
are, say the first level


669
00:31:20,846 --> 00:31:24,126
in the game is a good one,
then you want to take the tags


670
00:31:24,126 --> 00:31:28,246
for those assets and put them in
Xcode's Initial Install Tags UI.


671
00:31:29,816 --> 00:31:33,676
This will tell the ODR system
to make sure all the assets


672
00:31:34,206 --> 00:31:39,066
with those tags are
downloaded before the app shows


673
00:31:39,066 --> 00:31:40,996
as being 100% installed.


674
00:31:41,066 --> 00:31:43,186
That way when it does show
it's completely installed


675
00:31:43,186 --> 00:31:44,986
and the user taps on
it, it's ready to go.


676
00:31:45,056 --> 00:31:47,126
They are ready to
play that game.


677
00:31:47,126 --> 00:31:50,536
The size of your app that you
see in the App Store is going


678
00:31:50,536 --> 00:31:53,726
to be the size of the
dot app plus the size


679
00:31:53,726 --> 00:31:56,266
of the initial ODR content
that you have tagged here,


680
00:31:56,686 --> 00:31:58,046
so just to be aware
and we will talk


681
00:31:58,046 --> 00:31:59,706
about this point a
little bit later as well.


682
00:32:00,796 --> 00:32:04,406
Okay. So now let's talk about
automating the installation


683
00:32:04,406 --> 00:32:07,496
of ODR content between the
time the app is actually fully


684
00:32:07,496 --> 00:32:10,306
installed, but the user has
still not actually launched it,


685
00:32:10,436 --> 00:32:12,606
because you can automate
that period of time as well.


686
00:32:13,546 --> 00:32:16,086
You could use this, for example,
to make sure the second level


687
00:32:16,086 --> 00:32:19,376
in the game is loading,
or, for example, tutorials.


688
00:32:19,496 --> 00:32:21,776
Maybe some customers want
to see these tutorials


689
00:32:21,776 --> 00:32:24,066
and others don't, so you are
not going to prevent the app


690
00:32:24,266 --> 00:32:26,446
from actually running if
the tutorial isn't there,


691
00:32:26,746 --> 00:32:28,286
but you would like to
make sure it is there


692
00:32:28,286 --> 00:32:29,366
if you have the opportunity.


693
00:32:29,796 --> 00:32:34,266
And to do this, you can also
use Xcode's resource tags UI


694
00:32:34,856 --> 00:32:38,276
and put the tags in the
pre-fetch tag order section.


695
00:32:39,006 --> 00:32:40,926
In the actual order
that you place them


696
00:32:40,926 --> 00:32:44,566
in this section is the
order we will download them.


697
00:32:44,776 --> 00:32:46,506
All right.


698
00:32:46,876 --> 00:32:48,516
Now, let's talk about caching.


699
00:32:48,826 --> 00:32:50,456
We mentioned caching earlier


700
00:32:50,456 --> 00:32:53,956
and we showed how the
system purged game Level 1


701
00:32:53,956 --> 00:32:55,906
to make space for a new level.


702
00:32:56,736 --> 00:32:59,746
The first thing you need to
know is we only purge content


703
00:32:59,806 --> 00:33:01,706
when the system is low on space.


704
00:33:02,596 --> 00:33:04,436
And the only content
that is there


705
00:33:04,436 --> 00:33:05,946
to be purged is ODR content.


706
00:33:07,056 --> 00:33:10,026
When we do come to that point,
there are several attributes


707
00:33:10,026 --> 00:33:11,596
that come into play to inform us


708
00:33:11,786 --> 00:33:15,136
as to what decision we
should make in deleting


709
00:33:15,136 --> 00:33:17,376
which asset pack, for example.


710
00:33:18,496 --> 00:33:19,446
These are pretty obvious.


711
00:33:20,106 --> 00:33:22,386
One is when did you
last use the asset.


712
00:33:22,436 --> 00:33:25,846
So, for example, game Level 1
that was played last Tuesday,


713
00:33:25,846 --> 00:33:28,656
that's probably a better
candidate to delete


714
00:33:28,656 --> 00:33:31,896
than the level you
finished last night.


715
00:33:32,156 --> 00:33:35,306
Also as Tony mentioned you
have preservation priority


716
00:33:35,306 --> 00:33:37,116
which is a ranking
you can place on tags.


717
00:33:38,026 --> 00:33:39,616
So this is your own
ranking but we take


718
00:33:39,616 --> 00:33:40,716
that into account as well.


719
00:33:41,416 --> 00:33:43,496
And finally, we take


720
00:33:43,496 --> 00:33:45,146
into account the
running state of the app.


721
00:33:45,686 --> 00:33:48,616
We will not delete any asset
packs from a running app


722
00:33:48,986 --> 00:33:51,116
when those assets
are actually in use.


723
00:33:51,726 --> 00:33:56,876
Now, there are a few
strategies you can use


724
00:33:57,136 --> 00:33:59,216
to help preserve
your ODR content.


725
00:33:59,896 --> 00:34:02,116
One of them is to
avoid overpurging.


726
00:34:02,546 --> 00:34:03,506
What do I mean by this?


727
00:34:03,506 --> 00:34:04,886
Let me give you an example.


728
00:34:05,366 --> 00:34:07,886
Let's say the system
needs 100 megabytes,


729
00:34:08,676 --> 00:34:09,985
and it's gone everywhere else


730
00:34:09,985 --> 00:34:11,466
to find the space,
it can't find it.


731
00:34:12,436 --> 00:34:14,815
Through the attributes we
discussed just a moment ago,


732
00:34:15,536 --> 00:34:17,326
it's located one of
your asset packs,


733
00:34:17,356 --> 00:34:19,646
but that asset pack
is 512 megabytes.


734
00:34:20,196 --> 00:34:22,565
We are going to have to
purge that asset pack


735
00:34:22,565 --> 00:34:25,436
if it met the conditions
so we will have overpurged


736
00:34:25,476 --> 00:34:30,085
by 412 megabytes, so it's better
to keep your asset pack smaller.


737
00:34:30,085 --> 00:34:33,735
As I mentioned earlier, this
is also good because you want


738
00:34:33,735 --> 00:34:35,916
to progressively download
and consume content,


739
00:34:36,295 --> 00:34:37,835
so smaller is better
there as well.


740
00:34:38,226 --> 00:34:40,786
But smaller is also better
here to avoid overpurging.


741
00:34:41,985 --> 00:34:43,036
All right.


742
00:34:44,335 --> 00:34:46,466
Another thing you might
be tempted to do is


743
00:34:46,466 --> 00:34:49,696
to tag everything with a
1.0 preservation priority,


744
00:34:50,326 --> 00:34:51,775
but that doesn't
really help you.


745
00:34:52,286 --> 00:34:55,696
That just makes more of
your assets look equivalent


746
00:34:55,786 --> 00:34:58,166
to the system when it
comes to it looking


747
00:34:58,166 --> 00:35:00,206
at purging something
from your app.


748
00:35:00,206 --> 00:35:03,426
So you want to use the
1.0 value judiciously.


749
00:35:03,996 --> 00:35:08,946
And finally, again, make
sure, because we look


750
00:35:08,946 --> 00:35:12,426
at the last used date that you
endAccessingResources as soon


751
00:35:12,426 --> 00:35:14,186
as you are done with the tags


752
00:35:14,916 --> 00:35:18,056
or you allow the
NSBundleResourceRequest object


753
00:35:18,186 --> 00:35:19,506
to deallocate as
soon as possible.


754
00:35:19,806 --> 00:35:22,526
This helps the system know
how you are using the assets


755
00:35:22,526 --> 00:35:26,286
so it can make the
best decisions.


756
00:35:26,286 --> 00:35:28,276
Okay. Now, I would be
remiss if I didn't talk


757
00:35:28,276 --> 00:35:30,086
about performance in this talk.


758
00:35:31,506 --> 00:35:33,626
One of the things that
we have been doing here


759
00:35:33,626 --> 00:35:37,506
in this session is to encourage
you to download content


760
00:35:37,506 --> 00:35:38,926
in the background ahead of time.


761
00:35:40,056 --> 00:35:43,966
But we don't want to
do that at the expense


762
00:35:43,966 --> 00:35:46,326
of consuming more
resources of the system


763
00:35:46,656 --> 00:35:47,826
than your app can tolerate.


764
00:35:48,596 --> 00:35:51,776
So we balance the speed of a
download with the resources,


765
00:35:51,776 --> 00:35:54,836
CPU and otherwise, that we
consume while we download


766
00:35:54,836 --> 00:35:57,136
and process these asset packs.


767
00:35:57,226 --> 00:35:58,016
That's the default.


768
00:35:58,496 --> 00:36:00,746
But if you get into a
situation or you just want


769
00:36:00,746 --> 00:36:02,236
to manage this all on
your own and you want


770
00:36:02,236 --> 00:36:04,586
to put full throttle
down, then you can set it


771
00:36:04,586 --> 00:36:08,476
with the urgent priority, and we
will disregard that balancing,


772
00:36:08,476 --> 00:36:10,946
and we will download the
content as quickly as possible.


773
00:36:11,626 --> 00:36:14,966
Again, as Tony mentioned, this
is a good time to set this


774
00:36:14,966 --> 00:36:17,096
when you are putting
up the loading screen,


775
00:36:17,616 --> 00:36:20,976
but your app actually may be
tolerant to the CPU usage,


776
00:36:20,976 --> 00:36:24,366
for example, that we have on the
system when we are doing this.


777
00:36:24,596 --> 00:36:27,986
So it's all up to you.


778
00:36:27,986 --> 00:36:32,516
And also, we should talk
about performance testing.


779
00:36:32,516 --> 00:36:35,346
You need to do real world
testing for an ODR application.


780
00:36:35,616 --> 00:36:38,176
An ODR application is a
network-based application.


781
00:36:38,486 --> 00:36:41,106
So when you have your
device connected via USB


782
00:36:41,106 --> 00:36:44,806
to your MacBook Pro, for
example, running Xcode,


783
00:36:45,026 --> 00:36:48,006
that's not a real
world scenario.


784
00:36:48,006 --> 00:36:48,976
That's just far too fast.


785
00:36:49,926 --> 00:36:51,706
So what you want to do is


786
00:36:51,706 --> 00:36:56,176
to test your app using perhaps
TestFlight or Xcode Server.


787
00:36:57,506 --> 00:37:01,976
And then also use the Developer
Tools Network Link Conditioner


788
00:37:02,696 --> 00:37:05,246
to test out various
networking conditions


789
00:37:06,046 --> 00:37:08,006
that might cause
issues for your app


790
00:37:08,526 --> 00:37:10,576
in how soon ODR content
is downloading.


791
00:37:11,056 --> 00:37:13,806
In fact, I would recommend using
this tool for any networking


792
00:37:13,806 --> 00:37:14,806
that you are doing
from your app.


793
00:37:14,806 --> 00:37:15,396
It's really great.


794
00:37:15,846 --> 00:37:18,236
If you haven't used it
before, I would like to cover


795
00:37:18,236 --> 00:37:19,426
that now just briefly.


796
00:37:19,786 --> 00:37:23,286
So when you attach
your device via USB


797
00:37:23,286 --> 00:37:26,506
to your MacBook Pro again,
for example, of running Xcode


798
00:37:26,506 --> 00:37:28,606
and you then you go to Settings
on your device you are going


799
00:37:28,606 --> 00:37:30,676
to see this entry,
a developer entry.


800
00:37:30,676 --> 00:37:34,496
You tap that and you
will see numerous numbers


801
00:37:34,916 --> 00:37:38,596
of developer settings that you
can use in logging, et cetera,


802
00:37:38,596 --> 00:37:41,586
and in the middle there is
the Network Link Conditioner.


803
00:37:41,936 --> 00:37:46,546
So you tap that, and now you
see the options that you can use


804
00:37:46,546 --> 00:37:49,906
to cause various
conditions to be present


805
00:37:49,906 --> 00:37:52,296
when networking out of your app.


806
00:37:52,296 --> 00:37:55,816
To use this, you enable the
Network Link Conditioner,


807
00:37:56,206 --> 00:37:59,016
and then you decide what type
of situation you want to create.


808
00:37:59,406 --> 00:38:03,606
Perhaps you want to mimic 100%
loss or very slow network,


809
00:38:04,386 --> 00:38:08,546
or perhaps a high latency in
DNS lookups, or you just want


810
00:38:08,546 --> 00:38:10,266
to reproduce a really
bad network.


811
00:38:10,966 --> 00:38:12,896
So this is a great tool


812
00:38:12,896 --> 00:38:17,736
to use while you test
your ODR application.


813
00:38:17,736 --> 00:38:21,016
Okay. Now, speaking
of networking issues,


814
00:38:21,016 --> 00:38:24,326
you may encounter a couple of
networking errors along the way.


815
00:38:24,986 --> 00:38:26,166
One of them is this one.


816
00:38:26,166 --> 00:38:27,506
Obviously there is no network.


817
00:38:28,046 --> 00:38:31,316
So if your app needed ODR
content and there is no network,


818
00:38:31,316 --> 00:38:33,526
you need to be ready to
handle this situation.


819
00:38:35,036 --> 00:38:38,756
Another area you may encounter
is resource unavailable,


820
00:38:38,756 --> 00:38:41,556
and basically what this means is
we thought the ODR content was


821
00:38:41,556 --> 00:38:43,546
going to be in a certain
location and it wasn't.


822
00:38:44,086 --> 00:38:47,256
Generally the case or the cause
of this will be, for example,


823
00:38:47,256 --> 00:38:50,206
setting up a server
inside of your own company


824
00:38:50,206 --> 00:38:52,186
and someone is managing
it, moving things around,


825
00:38:52,526 --> 00:38:55,506
and they just weren't ready
for the users to use that app.


826
00:38:56,176 --> 00:38:59,466
So just to be ready
for that error as well.


827
00:38:59,896 --> 00:39:04,056
Another class of error that
you can encounter relates


828
00:39:04,056 --> 00:39:05,026
to storage space.


829
00:39:06,296 --> 00:39:11,336
So ODR will allow your app
to have a maximum of 2 gig


830
00:39:11,336 --> 00:39:12,586
in use at any one time.


831
00:39:13,466 --> 00:39:15,286
What this means is
your app is running,


832
00:39:15,686 --> 00:39:18,916
you have called
beginAccessingResources on tags


833
00:39:19,466 --> 00:39:22,216
that amount to 2 gigabytes,


834
00:39:22,806 --> 00:39:24,936
you haven't called
endAccessingResources on any


835
00:39:24,936 --> 00:39:28,326
of those, you haven't allowed
the NSBundleResourceRequest


836
00:39:28,666 --> 00:39:32,166
to dealloc for any of those,
so that 2 gig is in use.


837
00:39:32,486 --> 00:39:34,026
And then you go and
make another request.


838
00:39:34,446 --> 00:39:36,116
That goes over and you
are going to get an error


839
00:39:36,116 --> 00:39:37,506
in your request, a callback.


840
00:39:38,316 --> 00:39:40,856
So be aware of that as well.


841
00:39:41,336 --> 00:39:44,576
Also, of course, we just might
hit a low-space condition


842
00:39:44,866 --> 00:39:46,296
on local storage on the device.


843
00:39:46,296 --> 00:39:48,076
And you will get
this notification.


844
00:39:48,806 --> 00:39:51,196
This can happen if you
have initiated a download


845
00:39:51,196 --> 00:39:54,736
or maybe it happens long
after you made that request.


846
00:39:55,766 --> 00:39:57,186
So just be prepared
to handle that.


847
00:39:57,566 --> 00:39:59,156
To handle it you could
do a couple of things;


848
00:39:59,196 --> 00:40:01,006
you could endAccessingResources


849
00:40:01,006 --> 00:40:03,236
on any ODR content
you no longer need.


850
00:40:04,656 --> 00:40:06,926
And you can also look
at what you are storing


851
00:40:06,926 --> 00:40:09,416
on the local device, perhaps
some caches or other documents


852
00:40:09,416 --> 00:40:10,456
that you actually don't need,


853
00:40:10,866 --> 00:40:12,946
and you could free those
up and delete those.


854
00:40:13,486 --> 00:40:18,556
So now let's talk
about cellular data.


855
00:40:18,866 --> 00:40:21,586
Again, an ODR application
is a network application.


856
00:40:22,066 --> 00:40:25,016
So it is governed by the
same cellular data switch


857
00:40:25,896 --> 00:40:27,816
that controls the rest
of your app's networking.


858
00:40:28,246 --> 00:40:30,846
So if that switch is
off, you will not be able


859
00:40:30,846 --> 00:40:32,166
to get any ODR content.


860
00:40:33,176 --> 00:40:36,546
If that switch is on, and you
are downloading ODR content,


861
00:40:37,176 --> 00:40:41,316
then any of that data that
you use over cellular is going


862
00:40:41,316 --> 00:40:43,176
to be attributed to your app.


863
00:40:43,576 --> 00:40:46,216
So this should encourage
you to make sure you ask


864
00:40:46,476 --> 00:40:48,256
for what you need
and not any more.


865
00:40:49,016 --> 00:40:52,936
We don't want to run
up a user's bill.


866
00:40:53,146 --> 00:40:56,666
And finally, the 100-megabyte
cellular download limit still


867
00:40:56,666 --> 00:40:58,286
applies to ODR applications,


868
00:40:58,626 --> 00:41:01,966
so remember where I had
the dot app plus the size


869
00:41:01,966 --> 00:41:04,086
of initial ODR adding
to up the size


870
00:41:04,086 --> 00:41:05,526
of the app listed
in the App Store?


871
00:41:06,046 --> 00:41:09,196
Well, if that's greater than 100
megabytes, your app is not going


872
00:41:09,196 --> 00:41:12,086
to download over cellular,
just like a normal app


873
00:41:12,266 --> 00:41:14,166
that was greater than
100 megabytes would not.


874
00:41:15,206 --> 00:41:18,406
So you need to be aware of
that limitation as well.


875
00:41:20,656 --> 00:41:24,146
Finally, as we begin
to wrap this up,


876
00:41:24,146 --> 00:41:27,146
there is some vital statistics
that you need to be aware of.


877
00:41:27,896 --> 00:41:32,996
First of all, although you can
have an ODR application have a


878
00:41:32,996 --> 00:41:34,886
size of up to 20
gig in the Store,


879
00:41:35,436 --> 00:41:39,666
a maximum of 2 gig is
reserved for your dot app.


880
00:41:40,076 --> 00:41:41,156
So your dot app itself?


881
00:41:41,406 --> 00:41:43,586
Remember when we teased apart
the assets from your dot app,


882
00:41:43,586 --> 00:41:45,136
we had the asset packs
and then your dot app?


883
00:41:45,586 --> 00:41:47,876
That dot app can be a
maximum of 2 gigabytes.


884
00:41:48,286 --> 00:41:50,706
The rest of it can be
ODR content up to 20 gig.


885
00:41:50,876 --> 00:41:56,416
And you can have a
maximum of 2 gig of initial


886
00:41:56,416 --> 00:41:58,126
and pre-fetched ODR content.


887
00:41:58,126 --> 00:42:00,106
This is the content we
set up in Xcode's UI


888
00:42:01,146 --> 00:42:03,636
to download things
during the app install


889
00:42:03,636 --> 00:42:04,736
and right afterwards.


890
00:42:05,016 --> 00:42:10,596
You can have a maximum of two
gigabytes of that combined,


891
00:42:10,596 --> 00:42:13,696
and as I mentioned just a moment
ago, a maximum of two gigabytes


892
00:42:13,776 --> 00:42:16,656
in use at any one time.


893
00:42:16,766 --> 00:42:19,896
And finally, a given asset
pack can be a maximum


894
00:42:19,896 --> 00:42:21,236
of 512 megabytes.


895
00:42:22,786 --> 00:42:25,366
So if you take a single tag
and tag a bunch of resources,


896
00:42:25,496 --> 00:42:28,766
and that adds up to more than
512 megabytes, Xcode is going


897
00:42:28,766 --> 00:42:31,586
to give you a warning, but
it will allow you to continue


898
00:42:31,586 --> 00:42:34,946
to develop your app or game, but
when you submit to the Store,


899
00:42:34,946 --> 00:42:36,456
you are going to get
a submission failure,


900
00:42:36,936 --> 00:42:41,176
and the submission failure
error message will explain why.


901
00:42:41,406 --> 00:42:45,796
Okay. So in summary, On Demand
Resources is a dynamically


902
00:42:45,796 --> 00:42:46,966
loaded content system.


903
00:42:47,896 --> 00:42:49,156
Hosted in the App Store.


904
00:42:50,156 --> 00:42:51,146
This can be automated


905
00:42:51,666 --> 00:42:55,056
to download content during app
install time and by request.


906
00:42:56,236 --> 00:42:58,436
You can prioritize or
order these downloads.


907
00:42:59,776 --> 00:43:02,146
We have an intelligent caching
mechanism so that, for example,


908
00:43:02,146 --> 00:43:05,246
we could get rid of that game
Level 1 in order to make space


909
00:43:05,296 --> 00:43:10,846
for a following level, and
you get 20 gig in the Store.


910
00:43:11,026 --> 00:43:13,916
So for more information we
have a great new documentation


911
00:43:13,916 --> 00:43:16,596
on ODR; we also have
sample code,


912
00:43:17,066 --> 00:43:19,616
and the developer forums are
always a great place to go.


913
00:43:19,616 --> 00:43:22,296
And if you still have
questions you can follow


914
00:43:22,296 --> 00:43:24,056
up with our App Frameworks
evangelist.


915
00:43:24,966 --> 00:43:26,576
You may have missed
a couple of sessions


916
00:43:26,906 --> 00:43:30,556
on other technologies
that relate to ODR.


917
00:43:31,146 --> 00:43:35,156
Those will be available via
videos on the developer website.


918
00:43:35,156 --> 00:43:38,716
And there is going to be a
session as Tony indicated


919
00:43:38,716 --> 00:43:43,896
about progress on Friday as well
as a lab tomorrow from 11:00


920
00:43:43,896 --> 00:43:45,766
to 1:30 dedicated to ODR.


921
00:43:46,016 --> 00:43:49,426
Tony and I and the extended ODR
engineering team will be there


922
00:43:49,426 --> 00:43:51,146
to answer any of your questions,


923
00:43:51,146 --> 00:43:52,956
get you started using
ODR content,


924
00:43:52,956 --> 00:43:56,446
and listen to any
suggestions you might have.


925
00:43:56,926 --> 00:43:57,536
Thank you very much!


926
00:43:58,016 --> 00:44:00,000
[Applause]

