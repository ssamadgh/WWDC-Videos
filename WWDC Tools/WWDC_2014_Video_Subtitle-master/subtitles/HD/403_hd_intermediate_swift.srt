1
00:00:11,516 --> 00:00:14,546
[ Applause ]


2
00:00:15,046 --> 00:00:15,356
>> Good afternoon.


3
00:00:15,356 --> 00:00:15,716
Welcome.


4
00:00:16,186 --> 00:00:17,566
Welcome to "Intermediate Swift."


5
00:00:18,656 --> 00:00:20,666
My name is Brian Lanier.


6
00:00:20,666 --> 00:00:22,606
I'm an engineer in
Developer Publications.


7
00:00:22,866 --> 00:00:25,596
Later I'll be joined on stage
by my colleague Joe Groff,


8
00:00:25,966 --> 00:00:27,836
who is an engineer on
the Swift compiler team.


9
00:00:28,266 --> 00:00:31,786
We're both really excited to be
here today to talk with you more


10
00:00:32,156 --> 00:00:34,316
in depth about the Swift
programming language.


11
00:00:34,976 --> 00:00:36,676
I've been in the labs
the last couple of days


12
00:00:36,676 --> 00:00:38,496
and I've been very
impressed already


13
00:00:38,496 --> 00:00:40,506
with what you've been
able to do with Swift,


14
00:00:41,156 --> 00:00:44,026
and I think that to go
into some more detail


15
00:00:44,026 --> 00:00:46,426
on some really key features
of Swift, you'll be able


16
00:00:46,426 --> 00:00:48,736
to take advantage of
those features even more


17
00:00:48,736 --> 00:00:52,716
so in your code.


18
00:00:52,866 --> 00:00:56,306
So, in particular, we're
going to look at some features


19
00:00:56,306 --> 00:00:59,066
in some more detail,
including optionals


20
00:00:59,246 --> 00:01:02,206
and how you can use them
to make your code safer.


21
00:01:02,826 --> 00:01:05,245
We're going to talk to you
about memory management in Swift


22
00:01:05,245 --> 00:01:06,856
and how it's largely automatic.


23
00:01:07,966 --> 00:01:09,916
We're also going to talk
about initialization


24
00:01:10,486 --> 00:01:13,386
and how you can take advantage
of the power of closures


25
00:01:13,686 --> 00:01:15,226
and pattern matching
in your code.


26
00:01:15,516 --> 00:01:19,406
So, I want to begin
by looking at one


27
00:01:19,406 --> 00:01:22,666
of Swift's most powerful
features, optionals.


28
00:01:24,096 --> 00:01:25,566
But first I want to take a look


29
00:01:25,566 --> 00:01:27,986
at why we might need
optionals in the first place.


30
00:01:29,686 --> 00:01:32,206
Say you need to work with
input data from a user.


31
00:01:32,676 --> 00:01:34,586
Here we're asking
for the user's age.


32
00:01:35,356 --> 00:01:38,406
The response comes in as
a string, but say we need


33
00:01:38,406 --> 00:01:39,546
to convert that string


34
00:01:39,546 --> 00:01:43,876
to an integer using
this toInt method here.


35
00:01:44,096 --> 00:01:47,126
Now when the user
enters a string


36
00:01:47,126 --> 00:01:48,416
that represents a valid integer,


37
00:01:48,806 --> 00:01:53,066
the toInt method returns the
correct result, but, however,


38
00:01:53,066 --> 00:01:56,726
because you're not in control
of the user's response you have


39
00:01:57,276 --> 00:01:59,696
to deal with cases or situations


40
00:01:59,696 --> 00:02:02,376
where there's not an
obvious value to return.


41
00:02:03,346 --> 00:02:05,656
The user has full control
over what they're entering in.


42
00:02:05,706 --> 00:02:09,936
So, if they try to
get cute or snippy,


43
00:02:11,566 --> 00:02:15,426
we don't really have a clear
value to return in this case.


44
00:02:15,856 --> 00:02:19,086
So, what do we do?


45
00:02:19,086 --> 00:02:20,346
What value do we return?


46
00:02:20,346 --> 00:02:23,686
Well, we have lots
of options, right?


47
00:02:25,086 --> 00:02:29,766
Well, as you're probably aware,
various sentinels have been used


48
00:02:30,306 --> 00:02:32,636
in various different
languages to model these kinds


49
00:02:32,636 --> 00:02:35,506
of problems, but
having so many sentinels


50
00:02:35,506 --> 00:02:37,326
around isn't very good.


51
00:02:37,436 --> 00:02:38,636
It's not very safe.


52
00:02:38,976 --> 00:02:41,346
It's a common source of bugs
and problems in your code.


53
00:02:41,826 --> 00:02:42,826
For one, you have to know


54
00:02:42,826 --> 00:02:45,396
which of these possible
sentinels was chosen


55
00:02:45,396 --> 00:02:48,766
by the author of the API,
and then you have to remember


56
00:02:48,766 --> 00:02:51,036
which one to check against it.


57
00:02:52,456 --> 00:02:53,866
So this isn't a very
good pattern.


58
00:02:54,126 --> 00:02:56,066
So really how should
we model this?


59
00:02:57,256 --> 00:03:00,006
Well, in Swift, we
model problems


60
00:03:00,006 --> 00:03:02,606
like these using
the optional type.


61
00:03:03,436 --> 00:03:07,446
The optional type represents
possibly missing values


62
00:03:07,736 --> 00:03:09,506
of any type whatsoever.


63
00:03:10,816 --> 00:03:15,896
The optional type has two
discrete states: a default,


64
00:03:16,536 --> 00:03:21,776
nil state, which represents
literally the absence


65
00:03:21,776 --> 00:03:25,376
of any value whatsoever, and
optionals are defaulted to nil.


66
00:03:25,836 --> 00:03:27,796
You've probably seen a couple
of examples and options.


67
00:03:27,796 --> 00:03:30,646
If you've seen the "Introduction
to Swift" talk, you write them


68
00:03:30,646 --> 00:03:33,496
by writing the base height
followed by a question mark


69
00:03:33,546 --> 00:03:34,866
to indicate their optionality.


70
00:03:36,116 --> 00:03:41,226
Now, in Swift, nil is not
like Swift in Objective-C,


71
00:03:41,516 --> 00:03:44,196
where in Objective-C Swift is
an object pointer to nothing,


72
00:03:44,456 --> 00:03:46,356
and it only works for
the reference types.


73
00:03:47,226 --> 00:03:49,886
In Swift, nil is a
true sentinel value.


74
00:03:50,156 --> 00:03:52,076
It works with any
type whatsoever.


75
00:03:52,116 --> 00:03:54,836
It literally just means
there's no value present.


76
00:03:56,266 --> 00:03:58,706
The other state of an
option includes a presence


77
00:03:58,706 --> 00:04:01,226
of a value that's been
wrapped up in the optional.


78
00:04:01,226 --> 00:04:04,056
Think of optionals as this
wrapper container that wraps


79
00:04:04,056 --> 00:04:06,776
up values when there
are values present.


80
00:04:06,776 --> 00:04:09,316
So here we're setting the
value of optionalNumber to 6,


81
00:04:09,316 --> 00:04:12,346
and the value is wrapped
up in the optional.


82
00:04:12,866 --> 00:04:15,366
We'll see how to unwrap
this value and access it


83
00:04:15,886 --> 00:04:16,766
in just a little while.


84
00:04:18,495 --> 00:04:24,706
So, now that we have a single
sentinel value that works


85
00:04:24,706 --> 00:04:26,826
with any type at
all, even integers,


86
00:04:27,506 --> 00:04:29,566
it's clear what this
method should return.


87
00:04:29,566 --> 00:04:33,446
It's clear that whenever we
have a value that's not valid,


88
00:04:33,536 --> 00:04:35,166
we should just return an
optional, and in fact,


89
00:04:35,696 --> 00:04:37,916
the toInt method is defined
in the standard library


90
00:04:37,986 --> 00:04:41,196
under string type, and it does
just that, it returns nil.


91
00:04:42,066 --> 00:04:44,596
Now because we have optionals,


92
00:04:45,066 --> 00:04:47,276
we also have nonoptional
types as well.


93
00:04:47,276 --> 00:04:49,166
So what are nonoptional types?


94
00:04:49,306 --> 00:04:51,846
Well, they're just ordinary
types you would think they are.


95
00:04:52,146 --> 00:04:55,036
Integers, strings, even
your custom objects.


96
00:04:55,396 --> 00:05:00,016
And the great thing about
nonoptional types is


97
00:05:00,016 --> 00:05:01,706
that they can't be nil.


98
00:05:01,706 --> 00:05:04,126
And we think this is pretty cool


99
00:05:04,126 --> 00:05:06,606
because this makes your
code safe and predictable.


100
00:05:06,606 --> 00:05:08,306
When you declare a value


101
00:05:08,306 --> 00:05:11,796
of a nonoptional
type, it can't be nil.


102
00:05:11,796 --> 00:05:13,776
You can be sure that it's
there when you need it,


103
00:05:14,416 --> 00:05:15,506
and you can't be surprised


104
00:05:15,506 --> 00:05:18,496
by unexpected nil values
propagating throughout


105
00:05:19,146 --> 00:05:21,026
your code.


106
00:05:21,216 --> 00:05:22,996
So, now that we know
what optional types are


107
00:05:22,996 --> 00:05:25,056
and what they represent,
let's see how we can use them


108
00:05:25,056 --> 00:05:27,856
in our code, for example,
to write a function


109
00:05:28,596 --> 00:05:30,206
that returns an optional type.


110
00:05:31,016 --> 00:05:33,496
So here we're going to write a
function that looks for a string


111
00:05:34,286 --> 00:05:35,216
in an array of strings,


112
00:05:35,216 --> 00:05:37,636
and if that string has found
the array it simply returns the


113
00:05:37,636 --> 00:05:41,416
index, but as you might
guess, this is a case in which


114
00:05:42,436 --> 00:05:45,216
if the string isn't found we
need some value to indicate


115
00:05:45,216 --> 00:05:48,156
that failure, and because
we have nil and optionals


116
00:05:48,156 --> 00:05:51,346
at our disposal, let's go ahead
and change return pipe here


117
00:05:51,466 --> 00:05:54,336
to an optional by adding the
question mark at the end.


118
00:05:55,326 --> 00:05:56,956
So, let's implement
the function.


119
00:05:56,956 --> 00:05:58,856
The first thing we need to
do is enumerate the array,


120
00:05:58,856 --> 00:06:00,626
and here we're using
the enumerate method


121
00:06:00,626 --> 00:06:03,136
to find the standard library,
which actually enumerates


122
00:06:03,136 --> 00:06:07,586
to an array and returns as a
tuple, the index and the value


123
00:06:07,586 --> 00:06:09,546
of each value in the array.


124
00:06:09,546 --> 00:06:14,086
We can use that in the 4N
statement here and check to see


125
00:06:14,086 --> 00:06:16,216
if the string that we're looking
for matches the value and,


126
00:06:16,376 --> 00:06:18,246
if so, simply return
the integer.


127
00:06:18,696 --> 00:06:21,746
Now, we're returning an integer
here, but then it gets wrapped


128
00:06:21,746 --> 00:06:24,226
up as we said in the
optional return type.


129
00:06:24,486 --> 00:06:27,756
And because we have nil at our
disposal, we know exactly what


130
00:06:27,756 --> 00:06:30,786
to do when we don't
have a valid result.


131
00:06:30,916 --> 00:06:31,946
We just simply return nil.


132
00:06:32,586 --> 00:06:36,296
Now, as I said, we need
to unwrap optionals.


133
00:06:36,666 --> 00:06:41,986
So, let's use this function here
to look through an array and try


134
00:06:41,986 --> 00:06:43,456
to find a name in this array.


135
00:06:44,086 --> 00:06:47,326
Here you can clearly see that
the string that we're looking


136
00:06:47,326 --> 00:06:50,306
for is in the array, so we
have a valid result to return.


137
00:06:51,176 --> 00:06:52,316
Then we can check, though.


138
00:06:52,406 --> 00:06:55,166
We always want to check to
make sure the value is present,


139
00:06:55,166 --> 00:06:58,346
so we can simply ask if the
index value isn't nil here -


140
00:06:59,076 --> 00:07:01,846
and notice that I don't, I'm not
checking explicitly against nil,


141
00:07:02,236 --> 00:07:05,146
and that's because optionals
can be used in Boolean context.


142
00:07:05,636 --> 00:07:07,166
That means that you can
check them directly,


143
00:07:07,246 --> 00:07:08,896
very naturally, like
I've done here.


144
00:07:09,846 --> 00:07:13,346
So if the value is present,
which it is, we can simply try


145
00:07:13,346 --> 00:07:16,356
to use that value in the
subscript of the array,


146
00:07:16,626 --> 00:07:19,236
but if we've done it like
this we have a problem


147
00:07:20,056 --> 00:07:23,936
because the array is expecting
a nonoptional integer,


148
00:07:23,936 --> 00:07:27,206
but we've said that the function
returns an optional integer.


149
00:07:27,826 --> 00:07:29,176
So the types don't match here


150
00:07:29,176 --> 00:07:31,016
and the compiler will
let us know that first,


151
00:07:31,296 --> 00:07:33,476
before we use it, we need
to unwrap the optionals.


152
00:07:34,146 --> 00:07:35,846
One way we can unwrap optionals,


153
00:07:36,206 --> 00:07:39,236
is using the force unwrapping
operator which simply consists


154
00:07:39,236 --> 00:07:40,306
of an exclamation mark.


155
00:07:41,106 --> 00:07:43,886
You write the exclamation
mark after the optional value


156
00:07:43,886 --> 00:07:44,656
that you wish to unwrap.


157
00:07:46,176 --> 00:07:50,396
And here because our search
returned a valid response,


158
00:07:51,066 --> 00:07:52,416
we can simply print
out the result.


159
00:07:53,156 --> 00:07:54,246
But you have to be careful.


160
00:07:54,246 --> 00:07:55,326
As I said we should check


161
00:07:55,436 --> 00:07:57,756
to make sure the value is nil
first before we unwrap it.


162
00:07:58,206 --> 00:08:00,576
So if we try to use the forced
unwrapping operator here


163
00:08:01,056 --> 00:08:04,186
without checking, we would
actually get a runtime


164
00:08:04,186 --> 00:08:06,606
assertion, a runtime
error because we need


165
00:08:06,606 --> 00:08:08,866
to make sure the value is
there, and we're trying


166
00:08:08,866 --> 00:08:11,486
to force it when it's not.


167
00:08:11,756 --> 00:08:14,316
So instead in Swift we have
a better way of doing this


168
00:08:14,636 --> 00:08:16,766
where we can actually
test and unwrap


169
00:08:17,756 --> 00:08:20,506
at the same time using what
we call optional binding.


170
00:08:21,126 --> 00:08:22,426
Optional binding uses this


171
00:08:22,426 --> 00:08:25,036
if let syntax you may
have seen earlier in the


172
00:08:25,036 --> 00:08:26,086
"Introduction to Swift" talk.


173
00:08:27,476 --> 00:08:29,366
So, the if let statement,
how does it work?


174
00:08:29,536 --> 00:08:31,986
Well, first as I said, it tests,


175
00:08:32,236 --> 00:08:35,456
so it tests to see the
optional type here to see


176
00:08:35,456 --> 00:08:37,686
if it's actually present
or if its value is nil,


177
00:08:38,246 --> 00:08:41,476
and if it's not nil,
it assigns, unwraps


178
00:08:41,535 --> 00:08:45,336
and assigns a nonoptional
type to the index value here,


179
00:08:45,556 --> 00:08:47,006
this temporary constant.


180
00:08:47,226 --> 00:08:49,486
And you can use a temporary
constant because it's unwrapped


181
00:08:50,396 --> 00:08:53,466
as the index, as a
subscript to this array,


182
00:08:54,426 --> 00:08:55,746
and everything should
work just fine.


183
00:08:56,926 --> 00:08:58,666
But we can actually
combine these together.


184
00:08:58,666 --> 00:09:01,416
There's no need to actually
include a temporary variable.


185
00:09:01,656 --> 00:09:06,596
We can simply evaluate the
result of the function directly


186
00:09:06,596 --> 00:09:08,796
in line and then assign
that after it's unwrapped


187
00:09:08,796 --> 00:09:10,496
to the index here,
which now index is


188
00:09:10,496 --> 00:09:14,966
of type nonoptional Int,
just regular old Int.


189
00:09:15,866 --> 00:09:18,116
But that's what optional
bind looks


190
00:09:18,116 --> 00:09:19,286
like in a very simple case.


191
00:09:19,286 --> 00:09:20,406
Let's look at how it might look


192
00:09:20,406 --> 00:09:22,506
if we did something a
little bit more complex.


193
00:09:23,306 --> 00:09:26,296
So, to do that, let's set
up a couple of classes.


194
00:09:26,296 --> 00:09:29,136
Say we have a person class,
which has an optional residence,


195
00:09:30,266 --> 00:09:32,106
and a residence which
has an optional address.


196
00:09:33,066 --> 00:09:34,636
Finally, we have
an address class


197
00:09:34,636 --> 00:09:37,466
that has three optional
properties: the building number,


198
00:09:37,466 --> 00:09:39,466
a street name and
apartment number,


199
00:09:39,466 --> 00:09:40,446
all of which are optional.


200
00:09:41,376 --> 00:09:43,386
Let's do a little
bit more bookkeeping.


201
00:09:43,386 --> 00:09:45,916
Let's go ahead and create a
person instance, Paul, here,


202
00:09:46,396 --> 00:09:48,806
and let's give Paul a residence,


203
00:09:49,716 --> 00:09:52,946
and let's also give
Paul's residence an address


204
00:09:53,126 --> 00:09:54,186
so he can receive his mail.


205
00:09:54,426 --> 00:09:58,436
Now because Paul doesn't live
in an apartment, we're not going


206
00:09:58,436 --> 00:10:00,006
to set the apartment
number, but we're going


207
00:10:00,006 --> 00:10:02,586
to set the building
number to the string 243


208
00:10:02,586 --> 00:10:04,256
and the street name
to Main Street.


209
00:10:05,416 --> 00:10:09,516
Now let's say that we wanted
to get at the address number


210
00:10:09,796 --> 00:10:12,076
as an integer, not as a string.


211
00:10:12,076 --> 00:10:16,336
Well we could use if let binding
to drill down through all


212
00:10:16,336 --> 00:10:17,726
of these properties
and sub properties


213
00:10:17,726 --> 00:10:19,076
of the classes we've defined.


214
00:10:19,246 --> 00:10:21,576
So first we can test to see
if Paul has a residence.


215
00:10:21,576 --> 00:10:23,626
If so, unwrap it,
assign it to home.


216
00:10:24,286 --> 00:10:25,626
We can do the same
with the address,


217
00:10:26,336 --> 00:10:30,346
and finally we can drill down
and finally use the toInt method


218
00:10:30,346 --> 00:10:33,046
to convert that string
into a number and assign it


219
00:10:33,116 --> 00:10:36,386
to the address variable.


220
00:10:37,556 --> 00:10:39,826
But this is really
cumbersome, as you can tell.


221
00:10:40,106 --> 00:10:43,606
This does not lead to pretty
code, and it's kind of hard


222
00:10:43,606 --> 00:10:46,826
to follow all of the nested if
let syntax and statements here.


223
00:10:47,516 --> 00:10:51,796
So in Swift we can actually
use optional chaining as a way


224
00:10:51,796 --> 00:10:53,086
of accomplishing the same thing.


225
00:10:53,706 --> 00:10:55,586
Optional chaining lets
you work with optionals


226
00:10:55,636 --> 00:10:57,406
to conditionally
perform operations.


227
00:10:57,766 --> 00:11:01,086
It's like messaging nil in
Objective-C, but in such a way


228
00:11:01,086 --> 00:11:03,036
that it works with
any type whatsoever.


229
00:11:04,286 --> 00:11:07,876
Optional chaining provides
a clean and succinct syntax


230
00:11:07,996 --> 00:11:09,456
for doing these kinds
of operations.


231
00:11:09,886 --> 00:11:12,316
So what we're doing here is
we're just evaluating each point


232
00:11:12,316 --> 00:11:15,726
using the question mark operator
or the chaining operator to see


233
00:11:15,726 --> 00:11:18,386
if the thing to its left,
which is of an optional type,


234
00:11:18,466 --> 00:11:20,866
if it's nil or if it's
present before we proceed


235
00:11:20,866 --> 00:11:22,216
to the next expression.


236
00:11:22,886 --> 00:11:25,046
So to see how this works in
a little bit more detail,


237
00:11:25,546 --> 00:11:27,646
let's look at this example
and see how it's evaluated.


238
00:11:27,796 --> 00:11:29,186
You could think of
the evaluation


239
00:11:29,736 --> 00:11:31,356
of an optional chaining
expression


240
00:11:32,016 --> 00:11:34,946
like two parallel
railroad tracks that end


241
00:11:34,946 --> 00:11:36,916
in two different
destinations or two stations.


242
00:11:37,196 --> 00:11:40,576
The first station being the
optional value that's wrapped


243
00:11:40,576 --> 00:11:43,876
up here, so in this case an Int
that's wrapped in an optional,


244
00:11:44,416 --> 00:11:46,156
or simply nil when
there's no value present.


245
00:11:47,036 --> 00:11:48,906
So let's see what this
looks like as we go


246
00:11:48,906 --> 00:11:49,666
through the expression.


247
00:11:50,136 --> 00:11:51,966
Well, Paul is nonoptional,
so that's obvious.


248
00:11:51,966 --> 00:11:53,356
We've set him; he's
a valid instance.


249
00:11:54,116 --> 00:11:55,786
We can go to the
first optional here


250
00:11:55,966 --> 00:11:57,836
in the chain expression,
residence.


251
00:11:57,836 --> 00:11:59,686
Well, we know that we've
set it as a residence,


252
00:11:59,946 --> 00:12:02,866
but if it were nil, we would
actually just take the nil


253
00:12:02,866 --> 00:12:05,936
track, and the entire
expression would return nil.


254
00:12:05,936 --> 00:12:08,636
It's still of an optional type,
but it simply returns nil,


255
00:12:08,636 --> 00:12:10,426
and the rest of the
expression is ignored.


256
00:12:11,026 --> 00:12:13,976
But of course, we
did set a residence.


257
00:12:13,976 --> 00:12:16,206
And we can do the same
here along the path.


258
00:12:16,926 --> 00:12:20,576
And we can check every single
optional in a chained expression


259
00:12:20,576 --> 00:12:21,866
to see whether or
not it's valid.


260
00:12:22,486 --> 00:12:24,466
In this case, we've
set an address,


261
00:12:24,466 --> 00:12:28,606
and we've set a building
number, and finally we come


262
00:12:28,606 --> 00:12:32,586
to the last method call
after we've checked all


263
00:12:32,586 --> 00:12:33,556
of the rest of the optionals.


264
00:12:33,946 --> 00:12:34,916
Now the toInt method


265
00:12:34,916 --> 00:12:37,116
as you recall returns
an optional type itself,


266
00:12:37,486 --> 00:12:39,656
so there's actually one more
path we need to consider.


267
00:12:39,906 --> 00:12:42,496
It could, in fact, return nil
if it can't convert the value.


268
00:12:43,926 --> 00:12:47,826
But we've set it, of course, to
a valid string representation


269
00:12:47,826 --> 00:12:50,856
of an integer, and so toInt
method has a result to return,


270
00:12:50,856 --> 00:12:55,406
243, and the entire expression
is completely evaluated.


271
00:12:55,406 --> 00:12:57,676
It's wrapped back
up in an optional


272
00:12:58,096 --> 00:13:00,526
so that the address
number is now an optional


273
00:13:00,796 --> 00:13:02,996
with an underlying value of 243.


274
00:13:03,756 --> 00:13:06,276
But because it's an optional
value, if I need to use it


275
00:13:07,246 --> 00:13:09,986
as a real integer, I
need to unwrap it still.


276
00:13:10,466 --> 00:13:12,856
Actually we can combine
these operations together,


277
00:13:12,856 --> 00:13:17,206
optional chaining, and if let
syntax or optional binding,


278
00:13:17,576 --> 00:13:20,226
to test and unwrap it
at the same time again.


279
00:13:20,566 --> 00:13:23,116
So here we can take the entire
optional chained expression,


280
00:13:23,416 --> 00:13:27,766
evaluate it, see if it isn't
nil, unwrap it and assign it


281
00:13:27,766 --> 00:13:28,596
to the address variable.


282
00:13:28,876 --> 00:13:30,996
We can use it like an
ordinary nonoptional type.


283
00:13:31,446 --> 00:13:32,846
For example, to add
it to a database.


284
00:13:34,236 --> 00:13:35,686
So that's how optionals work.


285
00:13:36,516 --> 00:13:39,546
[ Applause ]


286
00:13:40,046 --> 00:13:40,766
It's pretty cool.


287
00:13:41,166 --> 00:13:42,406
So that's how optionals work.


288
00:13:42,566 --> 00:13:43,816
It's how optional
chaining works,


289
00:13:43,816 --> 00:13:44,856
how optional binding works.


290
00:13:45,106 --> 00:13:46,316
I want to take a step back


291
00:13:46,806 --> 00:13:48,866
and show you what optionals
look like under the hood.


292
00:13:49,376 --> 00:13:51,366
I don't want to spend a lot
of time here, but I do want


293
00:13:51,366 --> 00:13:52,946
to show you how powerful


294
00:13:52,946 --> 00:13:54,916
and expressive the Swift
programming language is


295
00:13:55,226 --> 00:13:57,566
that we can actually model
something so fundamental


296
00:13:57,566 --> 00:14:01,046
to the language like optionals
in the language itself.


297
00:14:01,626 --> 00:14:04,636
So optionals are really
just a simple enumeration,


298
00:14:05,286 --> 00:14:07,566
a generic enumeration
at that, of any type.


299
00:14:07,876 --> 00:14:10,596
You can see the Some type
here represents the case


300
00:14:10,596 --> 00:14:13,686
in which I said that there is a
value present that's wrapped up.


301
00:14:13,906 --> 00:14:15,516
You can see that
wrapping here going on.


302
00:14:15,896 --> 00:14:18,446
And the None case just
simply is a default value,


303
00:14:18,806 --> 00:14:20,796
which we've said that you
can indicate using nil.


304
00:14:22,126 --> 00:14:24,466
We haven't talked too much about
generics, and we're not going


305
00:14:24,466 --> 00:14:27,176
to go into generics in much
detail here, but I encourage you


306
00:14:27,176 --> 00:14:28,376
to watch the "Advanced
Swift" talk,


307
00:14:28,616 --> 00:14:32,476
where you can see the full
power of generics in action.


308
00:14:32,656 --> 00:14:33,636
So that's optionals.


309
00:14:34,316 --> 00:14:37,186
You use optionals to
work safely in your code


310
00:14:37,186 --> 00:14:38,756
with possibly missing values.


311
00:14:39,706 --> 00:14:40,896
Missing values are nil,


312
00:14:40,896 --> 00:14:43,766
and present values are
wrapped up in the optionals.


313
00:14:44,256 --> 00:14:46,576
You can then unwrap the
optionals in two ways:


314
00:14:46,576 --> 00:14:48,446
either with a forced-unwrapping
operator,


315
00:14:48,716 --> 00:14:50,776
but only do that if you're
sure there's a value there


316
00:14:50,776 --> 00:14:54,536
and it's not nil; and you
can also use if let syntax


317
00:14:54,536 --> 00:14:56,396
or optional binding
to unwrap and test


318
00:14:56,396 --> 00:14:58,276
at the same time
in a very safe way.


319
00:14:59,026 --> 00:15:02,226
And finally, you can use
optional chaining to work


320
00:15:02,226 --> 00:15:03,836
in a very succinct
and eloquent way


321
00:15:04,196 --> 00:15:06,616
with multiple optional
expressions chained together,


322
00:15:06,616 --> 00:15:08,336
and that's optionals.


323
00:15:08,696 --> 00:15:11,096
So, I'd like to invite Joe back
on the stage to talk to you


324
00:15:11,096 --> 00:15:12,386
about memory management
in Swift.


325
00:15:13,516 --> 00:15:15,546
[ Applause ]


326
00:15:16,046 --> 00:15:16,886
>> My name is Joe Groff.


327
00:15:16,936 --> 00:15:18,246
I work on the Swift Compiler.


328
00:15:18,356 --> 00:15:21,666
And I'm really excited because
managing memory is my favorite


329
00:15:21,666 --> 00:15:24,116
thing to do when I program.


330
00:15:24,976 --> 00:15:26,266
No, it's not.


331
00:15:26,956 --> 00:15:30,586
Thankfully Swift is built on
automatic reference counting,


332
00:15:30,586 --> 00:15:33,586
the same model we used
in Objective-C or ARC.


333
00:15:35,216 --> 00:15:38,786
We don't make you
use pointer syntax;


334
00:15:38,786 --> 00:15:40,076
we don't make you
spell out Alec.


335
00:15:40,116 --> 00:15:42,426
But still we need a
clear class like this


336
00:15:42,716 --> 00:15:47,166
and a constructed class, you get
a memory allocation implicitly,


337
00:15:47,316 --> 00:15:50,926
and a reference to that is what
gets stored in a local variable,


338
00:15:50,926 --> 00:15:54,006
and it's these references
that keep that memory alive.


339
00:15:55,426 --> 00:15:57,986
Now we can juggle a couple
of these bowling pins here,


340
00:15:57,986 --> 00:16:01,306
and when the last reference
to a class goes away,


341
00:16:01,306 --> 00:16:05,716
an object goes away, the object
automatically gets deallocated.


342
00:16:06,386 --> 00:16:08,006
ARC is a horrible
juggler, but it's great


343
00:16:08,006 --> 00:16:09,606
at reclaiming unused memory.


344
00:16:10,166 --> 00:16:13,636
When a reference
goes out of scope,


345
00:16:13,636 --> 00:16:14,946
it's automatically released.


346
00:16:15,386 --> 00:16:17,286
But as long as you have some
reference to the object,


347
00:16:17,286 --> 00:16:19,836
it's kept alive, and only


348
00:16:19,836 --> 00:16:22,386
when the final reference
is released is the


349
00:16:22,386 --> 00:16:23,576
object deallocated.


350
00:16:23,946 --> 00:16:24,456
It's safe.


351
00:16:24,456 --> 00:16:25,756
It's predictable.


352
00:16:26,236 --> 00:16:27,586
It just works.


353
00:16:28,616 --> 00:16:31,036
Except for those cycles.


354
00:16:31,916 --> 00:16:35,146
Sometimes it doesn't make sense
for an object to be owned.


355
00:16:35,666 --> 00:16:39,766
For instance, apartments
literally aren't owned


356
00:16:39,766 --> 00:16:42,206
by their tenants, but
they also will have


357
00:16:42,206 --> 00:16:43,666
like multiple people
living in them


358
00:16:43,666 --> 00:16:45,236
over the lifetime
of the building.


359
00:16:46,506 --> 00:16:48,806
On the other hand, a person
will move from apartment


360
00:16:48,806 --> 00:16:50,046
to apartment over their life.


361
00:16:50,496 --> 00:16:54,646
Even if you move a
person into an apartment,


362
00:16:56,516 --> 00:16:59,696
this relationship isn't
really an owning relationship.


363
00:16:59,696 --> 00:17:04,036
And there's a problem if
we try to model it as such.


364
00:17:04,566 --> 00:17:08,715
Let's set up a dictionary
of our renters


365
00:17:08,715 --> 00:17:10,576
and our apartments -
say we're a landlord.


366
00:17:11,516 --> 00:17:14,675
Let's move one of our tenants,
Elsvette, into her apartment.


367
00:17:15,486 --> 00:17:16,536
Now there's a problem.


368
00:17:17,286 --> 00:17:20,236
If she tries to move
out, she's trapped.


369
00:17:21,336 --> 00:17:24,376
The reference to the apartment
keeps her object alive,


370
00:17:24,376 --> 00:17:26,215
and even worse, if we try


371
00:17:26,215 --> 00:17:28,626
to sell off the property
we're stuck with the deed.


372
00:17:29,546 --> 00:17:33,476
Both objects keep each other
alive in a reference cycle.


373
00:17:35,296 --> 00:17:38,556
So like Objective-C, we
have weak references,


374
00:17:38,966 --> 00:17:42,026
and these tell Swift that
this object isn't responsible


375
00:17:42,026 --> 00:17:44,116
for keeping the object
on the other end alive.


376
00:17:44,686 --> 00:17:49,736
Now, when we work through the
example again, a weak reference


377
00:17:49,736 --> 00:17:54,366
between these two
objects, Elsvette can move


378
00:17:54,366 --> 00:17:59,566
out of her apartment and make a
clean break with her landlord.


379
00:18:00,146 --> 00:18:03,266
And the reference
automatically gets reset to nil.


380
00:18:04,266 --> 00:18:07,306
There's no dangling reference
to the allocated object.


381
00:18:08,516 --> 00:18:11,116
Now of course, when we sell off
the property, both objects end


382
00:18:11,116 --> 00:18:12,786
up deallocated, and
there's no leak.


383
00:18:13,226 --> 00:18:19,296
And weak references in Swift
are modeled as optional values.


384
00:18:19,296 --> 00:18:20,946
You can use all the
optional operations


385
00:18:20,946 --> 00:18:23,036
that Brian just showed
you to work with them.


386
00:18:23,036 --> 00:18:26,426
And when you take an
optional weak value


387
00:18:26,516 --> 00:18:30,076
and you bind the
nonoptional part out of it,


388
00:18:30,206 --> 00:18:34,536
you get a strong nonoptional
value, and you can safely work


389
00:18:34,536 --> 00:18:36,426
with that just like
any other reference.


390
00:18:37,516 --> 00:18:39,556
If you're applying a
single method or looking


391
00:18:39,556 --> 00:18:41,376
at the single property
conditionally


392
00:18:41,376 --> 00:18:42,716
on a weak reference object,


393
00:18:42,716 --> 00:18:45,796
you can also use the chaining
operator as a nice shorthand.


394
00:18:46,336 --> 00:18:50,646
Some things to be aware
of are that the test


395
00:18:50,646 --> 00:18:53,506
and unwrap pattern does not
work very well with weak.


396
00:18:54,386 --> 00:18:56,086
You could go to cash
your tenant's rent check,


397
00:18:56,086 --> 00:18:57,306
and find out that it bounced,


398
00:18:57,816 --> 00:19:00,226
and evict them before you have
a chance to even greet them,


399
00:19:00,226 --> 00:19:05,596
and end up with a runtime
error you didn't expect.


400
00:19:05,716 --> 00:19:08,886
Chaining also doesn't preserve
a strong reference if you use it


401
00:19:08,886 --> 00:19:11,806
to try to apply multiple
methods to the same object.


402
00:19:12,296 --> 00:19:16,186
Here cashRentCheck could
again cause the tenant


403
00:19:16,186 --> 00:19:20,146
to get released, and then we'd
end up greeting a nil object,


404
00:19:20,656 --> 00:19:23,576
and then, in fact, not
calling greet at all.


405
00:19:27,456 --> 00:19:29,746
Weak references are great
for breaking cycles,


406
00:19:29,846 --> 00:19:31,696
but they aren't always ideal.


407
00:19:32,266 --> 00:19:35,476
Let's say we're a
modern landlord,


408
00:19:35,476 --> 00:19:37,546
and we accept credit card
payments from our tenants.


409
00:19:37,836 --> 00:19:40,136
A dream, I know,
but bear with me.


410
00:19:40,866 --> 00:19:44,376
Now a credit card
should only ever be owned


411
00:19:44,376 --> 00:19:45,826
by one person, right?


412
00:19:46,416 --> 00:19:48,846
So we really want this to
be an immutable binding,


413
00:19:48,846 --> 00:19:51,766
an immutable property
of the credit card.


414
00:19:52,766 --> 00:19:56,016
We also don't even really
want to track a credit card


415
00:19:56,016 --> 00:19:57,666
if it isn't owned by a person.


416
00:19:58,106 --> 00:19:59,766
It shouldn't be an
optional property.


417
00:20:01,616 --> 00:20:04,686
There's obviously a cycle here,
and we could break that cycle


418
00:20:04,686 --> 00:20:07,096
with weak references,
but that forces us


419
00:20:07,096 --> 00:20:09,866
into some unfortunate
loosening of the model here.


420
00:20:10,776 --> 00:20:13,196
First of all, weak
references have to be optional


421
00:20:14,056 --> 00:20:17,136
because they have to
be resettable to nil.


422
00:20:17,356 --> 00:20:19,706
Second of all, they
have to be mutable


423
00:20:20,026 --> 00:20:23,406
because they could be
reset to nil at any time.


424
00:20:24,086 --> 00:20:26,866
And we don't really want this.


425
00:20:27,636 --> 00:20:30,376
We could end up accidently
reassigning a credit card


426
00:20:30,776 --> 00:20:34,706
or ending up with an
orphan credit card just


427
00:20:34,706 --> 00:20:36,876
to deal with memory leaks.


428
00:20:37,086 --> 00:20:38,366
That would suck.


429
00:20:39,196 --> 00:20:41,316
So, instead, we have another
kind of weak reference,


430
00:20:41,316 --> 00:20:42,366
the unowned reference.


431
00:20:42,846 --> 00:20:45,246
What this tells Swift is


432
00:20:45,246 --> 00:20:48,216
that although I don't have an
owning stake in the object,


433
00:20:48,576 --> 00:20:49,806
my life depends on it.


434
00:20:51,036 --> 00:20:54,846
I cannot live without my
owner, my card holder.


435
00:20:58,776 --> 00:21:00,756
So we can go back to
our renter's table.


436
00:21:01,216 --> 00:21:03,686
We can save our tenant's
credit card information,


437
00:21:03,686 --> 00:21:07,286
and you can see here that the
credit card is uniquely owned


438
00:21:07,556 --> 00:21:13,536
by the person record, so that
when her record is deallocated,


439
00:21:13,626 --> 00:21:15,806
the entire object
graph gets deallocated.


440
00:21:16,116 --> 00:21:21,046
There's no need to observe
the credit card independent


441
00:21:21,046 --> 00:21:21,886
of the person.


442
00:21:22,426 --> 00:21:25,446
And because there's
this assumption


443
00:21:25,446 --> 00:21:28,936
that the program is not
correct without the object


444
00:21:28,936 --> 00:21:31,546
on the other side, you can
use unknown references just


445
00:21:31,546 --> 00:21:32,636
like strong references.


446
00:21:32,636 --> 00:21:34,636
You can assign them
into a local variable,


447
00:21:35,066 --> 00:21:36,876
or you can call methods
on them directly.


448
00:21:37,686 --> 00:21:39,996
It's a bit like unsafe,
unretained in C,


449
00:21:40,106 --> 00:21:42,476
or Objective-C, but
it's still safe.


450
00:21:42,476 --> 00:21:45,616
We still assert that the object
is still allocated every time


451
00:21:45,616 --> 00:21:47,366
you access it through
an unowned reference.


452
00:21:47,806 --> 00:21:52,006
So let's look at three kinds
of references in Swift.


453
00:21:53,386 --> 00:21:54,976
Strong references
are the default,


454
00:21:54,976 --> 00:21:57,356
and that's because they're what
you should use most of the time.


455
00:21:57,496 --> 00:21:59,416
Most of the time you
have an ownership stake


456
00:21:59,416 --> 00:22:03,686
in an object you want to use.


457
00:22:03,686 --> 00:22:05,736
However, if you have
independent objects,


458
00:22:05,736 --> 00:22:08,426
objects with independent
lifetimes, sort of a, you know,


459
00:22:08,426 --> 00:22:10,896
a casual relationship
going on where you can move


460
00:22:10,896 --> 00:22:14,046
on if they went away,
weak references are great


461
00:22:14,046 --> 00:22:15,476
for modeling that sort of thing.


462
00:22:16,006 --> 00:22:18,296
If part of your program
ends up deallocated due


463
00:22:18,296 --> 00:22:21,796
to maybe low memory, the rest
of your program marches on,


464
00:22:22,026 --> 00:22:23,666
and optionals are a
great way of dealing


465
00:22:23,926 --> 00:22:25,966
with weak referenced
objects going away.


466
00:22:26,536 --> 00:22:30,916
And unowned references are
great for back references


467
00:22:30,916 --> 00:22:33,426
from dependent objects
backed up to their owners.


468
00:22:34,516 --> 00:22:36,166
If part of the object
graph goes away,


469
00:22:36,166 --> 00:22:37,996
the entire object
graph goes away,


470
00:22:37,996 --> 00:22:39,976
and there's no need
to deal with nil.


471
00:22:41,176 --> 00:22:42,846
And that's memory
management with Swift.


472
00:22:43,436 --> 00:22:46,796
It's automatic, it's automatic
reference counting, it's safe


473
00:22:47,326 --> 00:22:50,126
and it lets you think
about the relationships


474
00:22:50,126 --> 00:22:53,096
between your objects, rather
than the raw mechanics


475
00:22:53,096 --> 00:22:55,086
of memory management,
making strong,


476
00:22:55,086 --> 00:22:58,846
weak and unowned references
to model those relationships,


477
00:22:59,426 --> 00:23:02,076
and provides a nice, safe
foundation for Swift.


478
00:23:02,076 --> 00:23:05,186
To talk a little bit more
about that foundation,


479
00:23:05,186 --> 00:23:06,566
I'm going to bring
it back to Brian


480
00:23:06,796 --> 00:23:08,046
to talk about initialization.


481
00:23:09,516 --> 00:23:11,556
[ Applause ]


482
00:23:12,056 --> 00:23:13,946
>> Thank you, Joe,
thank you, Joe.


483
00:23:14,116 --> 00:23:16,506
So I want to talk to you
about initialization in Swift.


484
00:23:17,426 --> 00:23:21,446
Initialization in Swift
follows one very simple rule,


485
00:23:21,486 --> 00:23:25,726
and that's that every value must
be initialized before it's used.


486
00:23:27,066 --> 00:23:29,996
This one simple rule is
enforced by the compiler,


487
00:23:29,996 --> 00:23:32,956
and it ensures memory
safety in your code.


488
00:23:34,356 --> 00:23:37,666
It ensures that you never read
from uninitialized memory,


489
00:23:38,066 --> 00:23:38,626
and it, therefore,


490
00:23:38,626 --> 00:23:40,536
helps eliminate an
entire class of bugs.


491
00:23:42,146 --> 00:23:44,756
Let's look at how this rule
applies throughout the language.


492
00:23:44,756 --> 00:23:48,546
So let's start with
the simple variables.


493
00:23:49,176 --> 00:23:51,896
Swift doesn't default
initialized variables,


494
00:23:52,366 --> 00:23:56,966
constants, or properties because
there often isn't a natural


495
00:23:56,966 --> 00:23:58,566
and correct value
for everything.


496
00:23:59,056 --> 00:24:02,296
The only exception to this is
optionals, where we saw earlier


497
00:24:02,296 --> 00:24:05,296
that optionals have a very
natural default value of nil.


498
00:24:06,186 --> 00:24:09,466
This means that you need to
set these values explicitly


499
00:24:09,466 --> 00:24:11,976
in your code, but it
doesn't mean that you need


500
00:24:11,976 --> 00:24:14,426
to declare these
values at the point


501
00:24:14,476 --> 00:24:17,176
that you declare your variable
as constants or properties.


502
00:24:17,516 --> 00:24:20,276
It just means that you must
do so before you try to read


503
00:24:20,276 --> 00:24:21,526
from them or access them.


504
00:24:22,756 --> 00:24:26,556
For example, say we
wanted to set message here


505
00:24:27,226 --> 00:24:30,076
to an appropriate value
depending on whether


506
00:24:30,076 --> 00:24:33,406
or not a condition was true and
then print that message out.


507
00:24:34,126 --> 00:24:36,566
Even though the condition is
true in this case, I mean we're


508
00:24:36,566 --> 00:24:37,916
in the middle of the
session after all,


509
00:24:38,626 --> 00:24:40,046
we'd get a compiler error


510
00:24:40,546 --> 00:24:45,576
because we haven't considered
every possible branch


511
00:24:45,626 --> 00:24:46,436
in our code.


512
00:24:47,116 --> 00:24:49,556
We haven't said what
the value of messages


513
00:24:49,846 --> 00:24:51,256
when the condition is false.


514
00:24:52,546 --> 00:24:56,506
So let's add an else
clause to do just that.


515
00:24:56,676 --> 00:24:59,206
Now when we read for message
to print it out, we can be sure


516
00:24:59,206 --> 00:25:00,686
that it has an explicit value


517
00:25:00,976 --> 00:25:03,126
for every single
condition in our code.


518
00:25:03,126 --> 00:25:07,726
But now as I'm sure you're all
aware, it's quite easy to forget


519
00:25:07,726 --> 00:25:09,896
to check all of the
conditions in your code.


520
00:25:10,546 --> 00:25:15,206
So rather than surprising you
by unexpected and hard to track


521
00:25:15,206 --> 00:25:19,096
down behavior, the Swift
compiler catches these kinds


522
00:25:19,096 --> 00:25:21,786
of mistakes for you and
ensures that you're explicit


523
00:25:21,786 --> 00:25:24,056
about the values you want
to set for every branch


524
00:25:24,056 --> 00:25:25,796
and under every condition
in your code.


525
00:25:26,506 --> 00:25:28,066
This is great for memory safety.


526
00:25:28,706 --> 00:25:31,966
Now that we've seen
how this rule applies


527
00:25:31,966 --> 00:25:34,356
to simple variables,
let's see how it applies


528
00:25:34,806 --> 00:25:38,486
when you're defining your
own classes like, classes


529
00:25:38,486 --> 00:25:41,736
or structures, your own types.


530
00:25:41,916 --> 00:25:45,786
So, inside of the structure our
class declaration initializers


531
00:25:45,786 --> 00:25:47,116
handle this responsibility.


532
00:25:47,336 --> 00:25:49,416
They handle the responsibility
of satisfying the rule


533
00:25:49,416 --> 00:25:52,826
that everything is
set before it's used.


534
00:25:53,906 --> 00:25:56,876
Now, you've seen some
initializers in some


535
00:25:56,876 --> 00:25:59,406
of Joe's examples and memory
management just a while ago,


536
00:25:59,406 --> 00:26:01,306
and they're declared
using the key word init,


537
00:26:02,006 --> 00:26:05,896
and they're invoked
at object creation,


538
00:26:06,096 --> 00:26:11,736
or instance creation here,
using this initializer syntax.


539
00:26:11,736 --> 00:26:14,466
Now initializers can have any
number of labeled arguments


540
00:26:14,466 --> 00:26:18,756
or parameters, and when
they do, you need to call,


541
00:26:18,756 --> 00:26:21,236
you need to call it using
these label parameters.


542
00:26:21,236 --> 00:26:23,226
They're required
at the call site.


543
00:26:24,356 --> 00:26:27,606
Before we look at initialization
in classes, let's take a look


544
00:26:27,606 --> 00:26:30,416
at initialization and how
it works in structures.


545
00:26:31,216 --> 00:26:32,766
Let's define a simple
color structure


546
00:26:33,156 --> 00:26:35,986
that has three properties
- red, green and blue


547
00:26:35,986 --> 00:26:37,596
to represent the
color components -


548
00:26:37,906 --> 00:26:39,666
and we'll deal with alpha later.


549
00:26:40,436 --> 00:26:42,626
Now let's say that we
want to create colors


550
00:26:42,626 --> 00:26:43,736
in different shades of gray.


551
00:26:44,696 --> 00:26:47,716
Well to do so we can define
a single initializer here,


552
00:26:47,716 --> 00:26:50,016
a very simple one,
that simply has,


553
00:26:50,486 --> 00:26:55,336
takes a single grayScale
double value and sets all


554
00:26:55,336 --> 00:26:58,576
of the stored properties of the
structure to that same value.


555
00:26:58,776 --> 00:27:01,846
Now, if we had forgotten to set
the red property, for example,


556
00:27:02,496 --> 00:27:03,726
we'd get a compiler error


557
00:27:03,996 --> 00:27:05,626
because we haven't
satisfied the rule


558
00:27:05,626 --> 00:27:08,496
that every value must be
initialized before it's used.


559
00:27:09,566 --> 00:27:11,736
The same is true
for calling a method


560
00:27:12,316 --> 00:27:15,006
in your initializer before you
set all of your properties.


561
00:27:16,256 --> 00:27:19,076
For example, say we want to
validate, we want a method


562
00:27:19,076 --> 00:27:21,646
that validates the color
components to make sure they're


563
00:27:21,646 --> 00:27:26,046
within a valid range
of values say 0 to 1.0.


564
00:27:27,166 --> 00:27:29,826
If we then call this
method here inside


565
00:27:29,826 --> 00:27:32,596
of the initializer before we
set all of our properties,


566
00:27:33,296 --> 00:27:36,356
we'd again get a compiler
error because we're trying


567
00:27:36,356 --> 00:27:38,646
to call a method on
self on the instance,


568
00:27:39,436 --> 00:27:41,606
but before self has
been fully initialized.


569
00:27:42,556 --> 00:27:46,126
So if you need to access self
just customize any property


570
00:27:46,126 --> 00:27:48,926
values or to call on the
methods in your initializer,


571
00:27:49,526 --> 00:27:52,316
always do so after you've set
all of your stored properties


572
00:27:52,316 --> 00:27:53,336
to appropriate values.


573
00:27:55,156 --> 00:27:57,726
Now in structures, if
you don't define any


574
00:27:57,726 --> 00:28:00,526
of your own initializers,
Swift provides you


575
00:28:00,526 --> 00:28:03,656
with a memberwise
initializer automatically.


576
00:28:05,116 --> 00:28:08,276
The memberwise initializer
has arguments that correspond


577
00:28:08,276 --> 00:28:11,556
to each of that instances
store, each of that classes


578
00:28:11,556 --> 00:28:12,746
or structures stored property.


579
00:28:13,636 --> 00:28:16,886
You can also provide default
values in line directly


580
00:28:17,156 --> 00:28:19,526
for your stored properties,
and when you've set all


581
00:28:19,526 --> 00:28:21,986
of your stored properties
and you haven't defined any


582
00:28:21,986 --> 00:28:23,526
of your own custom initializers,


583
00:28:24,606 --> 00:28:27,436
Swift provides a default
initializer for you to use


584
00:28:27,626 --> 00:28:30,666
that takes no parameters
and creates an instance


585
00:28:30,666 --> 00:28:33,516
with the properties you
set as default values


586
00:28:34,116 --> 00:28:35,286
when you declare your structure.


587
00:28:37,106 --> 00:28:39,376
So that's how initialization
works in structures.


588
00:28:40,576 --> 00:28:43,936
Now let's take a look at
how it works in classes.


589
00:28:44,106 --> 00:28:45,166
Really it's no different.


590
00:28:46,786 --> 00:28:48,616
So let's start with a
simple car class here


591
00:28:49,686 --> 00:28:51,996
that has a single
property, a paint color,


592
00:28:52,326 --> 00:28:55,056
and a single initializer that
just sets that paint color


593
00:28:55,326 --> 00:28:56,306
to an appropriate value.


594
00:28:56,306 --> 00:28:58,876
Now, in practice, classes


595
00:28:59,056 --> 00:29:01,336
and often subclass
inherit from other classes.


596
00:29:01,636 --> 00:29:04,316
So we need to deal with
how initialization works


597
00:29:04,316 --> 00:29:05,496
with subclasses as well.


598
00:29:07,036 --> 00:29:09,506
So let's define a
subclass called RaceCar,


599
00:29:09,546 --> 00:29:12,516
and it has one extra property
and its own initializer.


600
00:29:13,586 --> 00:29:15,416
When the RaceCar's
initializer is called,


601
00:29:16,206 --> 00:29:18,146
it first sets its
own properties,


602
00:29:19,046 --> 00:29:21,606
and then it called the
SuperClass initializer.


603
00:29:22,206 --> 00:29:26,326
And the SuperClass
initializer, of course,


604
00:29:26,326 --> 00:29:28,946
sets its own properties to
an appropriate value as well.


605
00:29:29,866 --> 00:29:32,686
And only after the SuperClass
and all the SuperClasses


606
00:29:32,686 --> 00:29:35,746
in the class hierarchy
have had a chance


607
00:29:35,746 --> 00:29:39,356
to set their own values is
a class fully initialized


608
00:29:39,356 --> 00:29:40,326
and ready to use.


609
00:29:41,466 --> 00:29:43,406
Now if you're coming from
an Objective-C background,


610
00:29:44,326 --> 00:29:46,976
you probably noticed that
this is opposite or different


611
00:29:47,346 --> 00:29:50,156
than what you've noticed, than
what you do in Objective-C,


612
00:29:50,376 --> 00:29:53,746
where you always call
your SuperClass first


613
00:29:53,746 --> 00:29:55,366
and then you set
your own properties.


614
00:29:58,806 --> 00:30:00,776
So in Swift if we
were to do this,


615
00:30:00,776 --> 00:30:02,936
if we were to call our
SuperClass initializer first


616
00:30:03,206 --> 00:30:04,586
and then set our own properties,


617
00:30:05,816 --> 00:30:07,346
we would actually
get a compiler error


618
00:30:07,346 --> 00:30:10,236
because it's not always
safe to do so in this order.


619
00:30:11,086 --> 00:30:13,846
And the reason Swift's
initialization follows this


620
00:30:13,846 --> 00:30:18,236
order is that it ensures memory
safety, so that you don't try


621
00:30:18,356 --> 00:30:20,556
to access memory before it's
been completely initialized.


622
00:30:20,556 --> 00:30:24,056
Now it may not be obvious where
you might run into problems


623
00:30:24,096 --> 00:30:26,256
by doing things in this
order, so let's take a look


624
00:30:26,256 --> 00:30:29,176
at an example where calling your
SuperClass initializer first


625
00:30:29,176 --> 00:30:29,846
is unsafe.


626
00:30:31,446 --> 00:30:33,886
Let's say, for example, that
we want to define a function


627
00:30:33,976 --> 00:30:37,146
or method on our car class
that fills up the gas tank,


628
00:30:37,146 --> 00:30:39,766
and we want to call that
function inside the initializer


629
00:30:39,766 --> 00:30:41,836
so that every time we
get a new car it comes


630
00:30:41,836 --> 00:30:42,736
with a full gas tank.


631
00:30:43,516 --> 00:30:45,696
And because race cars use
a different kind of gas


632
00:30:45,726 --> 00:30:46,566
than regular cars,


633
00:30:46,946 --> 00:30:49,256
we've overridden this
method in our subclass.


634
00:30:50,396 --> 00:30:52,886
So, when we create
a new race car,


635
00:30:53,536 --> 00:30:55,066
and its initializer is called,


636
00:30:55,806 --> 00:30:57,896
it first called its
SuperClass initializer,


637
00:30:58,756 --> 00:31:00,756
which then sets its
paint color properties,


638
00:31:01,306 --> 00:31:03,476
and finally calls its
fillGasTank method.


639
00:31:04,356 --> 00:31:06,406
But because we've
overridden it in our subclass,


640
00:31:06,406 --> 00:31:10,146
it gets dynamically dispatched
to the subclass's version


641
00:31:10,636 --> 00:31:13,876
of that same method, and
that's where we have a problem.


642
00:31:15,366 --> 00:31:17,306
And our problem is that
we haven't got a chance


643
00:31:17,306 --> 00:31:20,356
in our own initializer to
set our own properties,


644
00:31:20,586 --> 00:31:22,886
and so we're trying to
call a method on self.


645
00:31:23,196 --> 00:31:25,516
We're trying to access this
object or this instance


646
00:31:25,746 --> 00:31:27,336
that hasn't been
fully initialized,


647
00:31:27,646 --> 00:31:28,486
and that's not safe.


648
00:31:29,926 --> 00:31:34,286
So in Swift, we always make sure
we set our own properties before


649
00:31:34,286 --> 00:31:36,446
we call our SuperClass's
initializer


650
00:31:36,946 --> 00:31:38,156
to have a chance to do the same.


651
00:31:39,846 --> 00:31:43,126
So far we've just seen
examples of a single initializer


652
00:31:43,126 --> 00:31:46,156
in a class, but you can
have multiple initializers


653
00:31:46,156 --> 00:31:48,036
in your class just like
you can in Objective-C.


654
00:31:48,036 --> 00:31:52,356
In fact, you can have designated
initializers - what we've seen


655
00:31:52,356 --> 00:31:54,666
so far - designated
initializers,


656
00:31:54,986 --> 00:31:57,026
which you may be familiar
with coming from Objective-C,


657
00:31:57,606 --> 00:32:00,156
have the sole responsibility
of creating an object


658
00:32:00,156 --> 00:32:01,436
and setting all of
its properties.


659
00:32:01,926 --> 00:32:04,926
And it has a job of calling
the SuperClass's initializer


660
00:32:05,196 --> 00:32:06,386
and delegating up.


661
00:32:06,626 --> 00:32:08,176
Like you can think of
them as funnel points


662
00:32:08,176 --> 00:32:10,426
that funnel the initialization
process all the way


663
00:32:10,426 --> 00:32:12,906
to the class, to the
BaseClass and hierarchy.


664
00:32:13,116 --> 00:32:15,456
But you can also have
convenience initializers.


665
00:32:15,776 --> 00:32:18,966
Convenience initializers are
sort of secondary initializers


666
00:32:19,266 --> 00:32:24,316
that provide an alternative
implementation initialization


667
00:32:24,316 --> 00:32:28,676
interface that allows you to
say, pass certain default values


668
00:32:28,916 --> 00:32:30,556
and make it easier for
your clients to use.


669
00:32:30,796 --> 00:32:32,686
They can only call across.


670
00:32:32,786 --> 00:32:36,836
They can only delegate side
to side in a particular class.


671
00:32:36,866 --> 00:32:37,966
They never call up.


672
00:32:38,156 --> 00:32:40,616
So they can call designated
initializers in the same class


673
00:32:40,956 --> 00:32:42,656
or other convenience
initializers,


674
00:32:43,046 --> 00:32:45,086
but ultimately those
convenience initializers need


675
00:32:45,086 --> 00:32:47,716
to call a designated to
actually do the heavy lifting


676
00:32:47,716 --> 00:32:48,786
of setting up properties.


677
00:32:49,816 --> 00:32:52,176
So let's see how you might
write a convenience initializer


678
00:32:52,406 --> 00:32:53,176
in your own code.


679
00:32:53,726 --> 00:32:55,006
Say we have RaceCar again,


680
00:32:55,086 --> 00:32:57,206
and we want to create a
convenience initializer


681
00:32:57,206 --> 00:32:59,376
that lets it just
pass in a color,


682
00:32:59,376 --> 00:33:01,876
and it sets the turbo
property to true,


683
00:33:01,876 --> 00:33:04,446
and it does so by
delegating this task


684
00:33:05,116 --> 00:33:07,356
to the designated
initializer in the same class.


685
00:33:08,676 --> 00:33:10,846
Now when we do this
kind of thing in Swift,


686
00:33:10,936 --> 00:33:12,756
when we define a
convenience initializer,


687
00:33:13,026 --> 00:33:14,446
we need to let the
Swift compiler know


688
00:33:14,746 --> 00:33:16,676
by including the
convenience keyword


689
00:33:16,946 --> 00:33:18,116
in front of the declaration.


690
00:33:19,236 --> 00:33:22,146
We can even provide more than
one convenience initializer,


691
00:33:22,706 --> 00:33:25,826
so we can even provide a
convenience initializer


692
00:33:25,826 --> 00:33:28,656
that lets us create a RaceCar
providing no parameters at all


693
00:33:28,866 --> 00:33:30,096
and then delegates this task,


694
00:33:31,156 --> 00:33:33,396
here providing a
default gray value,


695
00:33:33,396 --> 00:33:36,556
and it calls the other
convenience initializer we've


696
00:33:36,556 --> 00:33:37,176
just declared.


697
00:33:37,176 --> 00:33:38,766
And that in turn, of course,


698
00:33:39,066 --> 00:33:40,796
has to call the designated
initializer


699
00:33:40,796 --> 00:33:42,086
to actually set the values.


700
00:33:42,536 --> 00:33:44,496
And because we have a
SuperClass to deal with here,


701
00:33:44,866 --> 00:33:46,556
that initializer needs
to call it SuperClass.


702
00:33:47,866 --> 00:33:50,406
And how are initializers
inherited in Swift?


703
00:33:51,186 --> 00:33:53,466
Well, they're not
inherited by default


704
00:33:54,256 --> 00:33:55,946
because doing so
isn't always safe.


705
00:33:57,526 --> 00:34:00,966
However, when your class
provides no initializers at all,


706
00:34:01,476 --> 00:34:04,386
and you set default values for
all of its stored properties


707
00:34:04,386 --> 00:34:06,336
as we've done here with
the FormulaOne RaceCar,


708
00:34:06,336 --> 00:34:08,266
where we've set a
single stored property


709
00:34:08,266 --> 00:34:11,045
to a minimum regulation
weight, and since we know


710
00:34:11,045 --> 00:34:12,476
that weight we can
set it directly.


711
00:34:12,476 --> 00:34:16,606
Now when we do this, we actually
inherit automatically all


712
00:34:16,606 --> 00:34:18,025
of the initializers
of the SuperClass.


713
00:34:18,025 --> 00:34:19,996
That includes designated
initializers


714
00:34:20,266 --> 00:34:22,136
and the convenience initializers
that we've declared.


715
00:34:22,896 --> 00:34:24,815
Now, if we did this in
this particular case,


716
00:34:24,815 --> 00:34:26,835
we'd have a problem because one


717
00:34:26,835 --> 00:34:29,735
of the convenience initializers
we've inherited sets the wrong


718
00:34:29,735 --> 00:34:30,656
value for turbo.


719
00:34:31,226 --> 00:34:34,056
Formula One race cars aren't
allowed to have a turbo


720
00:34:34,226 --> 00:34:36,266
by regulation, and so this
wouldn't be appropriate


721
00:34:36,266 --> 00:34:36,896
in this case.


722
00:34:37,516 --> 00:34:39,826
So instead we'll define
our own initializer here,


723
00:34:39,906 --> 00:34:41,916
and now it's a designated
initializer


724
00:34:41,916 --> 00:34:43,436
because it calls
super and passes


725
00:34:43,436 --> 00:34:44,966
that turbo value of false.


726
00:34:46,206 --> 00:34:47,096
And because we've done this,


727
00:34:47,096 --> 00:34:48,576
we've provided our
own initializer,


728
00:34:49,016 --> 00:34:52,076
we actually don't inherit those
other convenience initializers


729
00:34:52,196 --> 00:34:53,666
or the other designated
initializer.


730
00:34:54,786 --> 00:34:58,846
So that's how you would use
initializers to set properties,


731
00:34:58,846 --> 00:35:01,396
and how you can set
properties in line directly.


732
00:35:02,196 --> 00:35:04,336
But I haven't told you about a
pattern, and you may be familiar


733
00:35:04,336 --> 00:35:05,286
with it from Objective-C,


734
00:35:05,946 --> 00:35:07,886
sometimes called
lazy instantiation


735
00:35:07,886 --> 00:35:12,056
or lazy initialization, where
you want to delay the evaluation


736
00:35:12,296 --> 00:35:16,156
of a property in setting
it because, for example,


737
00:35:16,156 --> 00:35:18,786
maybe doing so is
computationally expensive.


738
00:35:19,706 --> 00:35:23,616
So we have the same concept in
Swift using lazy properties.


739
00:35:24,296 --> 00:35:27,336
And let's take a
look at an example


740
00:35:27,336 --> 00:35:29,466
of where you might use one,
where it might be appropriate.


741
00:35:29,466 --> 00:35:30,506
Say we have a game class,


742
00:35:31,016 --> 00:35:32,806
and the game can either
be a single player game


743
00:35:32,806 --> 00:35:33,896
or a multiplayer game.


744
00:35:34,606 --> 00:35:38,636
Now, the multiplayerManager,
let's just suppose


745
00:35:38,966 --> 00:35:41,326
that it does a bunch of
expensive computation,


746
00:35:41,646 --> 00:35:43,206
and so we don't want
to create it


747
00:35:43,956 --> 00:35:45,716
if there's only ever
a single player.


748
00:35:46,766 --> 00:35:48,816
We only want to create it
when there's multiple players.


749
00:35:49,476 --> 00:35:51,536
So we want to delay
that initialization


750
00:35:51,536 --> 00:35:52,646
until it's appropriate.


751
00:35:53,246 --> 00:35:59,356
So we can do this in Swift by
including the @lazy attribute


752
00:35:59,356 --> 00:36:02,466
in front of the declaration
here, and when we do this,


753
00:36:02,466 --> 00:36:06,156
it will only be evaluated the
time it's accessed and only


754
00:36:06,156 --> 00:36:08,086
when it's accessed and
only that one time.


755
00:36:08,636 --> 00:36:10,226
Now just as we have
initialization


756
00:36:10,226 --> 00:36:10,966
in Swift, we also have -


757
00:36:11,516 --> 00:36:16,716
[ Applause ]


758
00:36:17,216 --> 00:36:18,776
Just as we have initialization
in Swift,


759
00:36:18,776 --> 00:36:20,116
we have deinitialization.


760
00:36:20,116 --> 00:36:22,426
Deinitialization is responsible
for tearing down the object.


761
00:36:22,796 --> 00:36:25,916
Now as Joe has already
told you, memory management


762
00:36:25,916 --> 00:36:28,846
in Swift is automatic, so most
of the time you don't even need


763
00:36:28,906 --> 00:36:31,196
to think about the
initialization - it just works,


764
00:36:31,196 --> 00:36:32,226
it just happens for you.


765
00:36:33,446 --> 00:36:36,566
But for cases where you
do need it, for example,


766
00:36:36,566 --> 00:36:39,756
to unregister yourself as
an observer or, for example,


767
00:36:39,756 --> 00:36:41,686
to close a file that
you may have opened,


768
00:36:42,306 --> 00:36:45,236
we want to have a chance to
close that file and clean


769
00:36:45,236 --> 00:36:46,836
up those nonmemory resources.


770
00:36:47,296 --> 00:36:50,566
So for that we use
a deinitializer,


771
00:36:50,926 --> 00:36:53,756
and deinitializers are just
declared using the deinit


772
00:36:53,806 --> 00:36:54,166
key word.


773
00:36:54,456 --> 00:36:56,876
So, for example, here we have
a class that when we open


774
00:36:56,876 --> 00:36:59,706
up a file, if this class gets
deallocated before we have a


775
00:36:59,706 --> 00:37:02,636
chance to close the
file, that's not good.


776
00:37:02,636 --> 00:37:06,176
So think of this as the last
resort, the last chance you have


777
00:37:06,176 --> 00:37:08,886
to clean up nonmemory
resources before your object


778
00:37:09,226 --> 00:37:10,176
is deallocated.


779
00:37:11,106 --> 00:37:13,016
Again, most of the time you
probably won't need them.


780
00:37:13,656 --> 00:37:15,076
So that's initialization
in Swift.


781
00:37:15,316 --> 00:37:15,876
It's safe.


782
00:37:16,696 --> 00:37:19,386
You initialize all of your
values before you use them,


783
00:37:20,186 --> 00:37:22,216
set your stored property
values first


784
00:37:22,806 --> 00:37:24,746
and then call your
SuperClass initializer,


785
00:37:24,806 --> 00:37:25,626
always in that order.


786
00:37:26,416 --> 00:37:28,536
Designated initializers
only delegate up,


787
00:37:28,976 --> 00:37:31,896
and convenience initializers
only delegate across.


788
00:37:32,816 --> 00:37:35,916
And finally, we have the
initializers if you need them,


789
00:37:36,296 --> 00:37:37,386
but most of the time you won't.


790
00:37:37,386 --> 00:37:39,456
So that's initialization.


791
00:37:39,456 --> 00:37:41,586
I'd like to invite Joe back
on the stage to talk to you


792
00:37:41,586 --> 00:37:42,576
about closures in Swift.


793
00:37:43,516 --> 00:37:50,826
[ Applause ]


794
00:37:51,326 --> 00:37:54,366
>> Now, there are a lot
of ways to sort an array,


795
00:37:54,366 --> 00:37:57,686
and we could keep our standard
library writers busy writing a


796
00:37:57,686 --> 00:38:01,356
million different sort methods
on array, but we'd rather not.


797
00:38:01,676 --> 00:38:04,566
So instead we have a single sort
method that takes a closure.


798
00:38:04,646 --> 00:38:06,656
You've probably seen a bit
of this in the intro talk


799
00:38:06,656 --> 00:38:07,776
or even in the keynotes.


800
00:38:08,766 --> 00:38:13,096
A closure in Swift is
spelled inside curly braces.


801
00:38:13,976 --> 00:38:15,466
You follow it with a signature.


802
00:38:15,466 --> 00:38:18,696
In the case of sort,
it takes two arguments


803
00:38:18,696 --> 00:38:20,666
of the element type of the
array, in this case String.


804
00:38:20,666 --> 00:38:23,396
And in terms of Boolean, telling
us whether the elements are


805
00:38:23,396 --> 00:38:24,546
sorted in the right order.


806
00:38:25,606 --> 00:38:26,886
Default with the in keyword -


807
00:38:26,886 --> 00:38:30,466
you're binding these arguments
inside the body of the closure -


808
00:38:30,926 --> 00:38:34,786
and then you follow it with
the body of the function.


809
00:38:35,346 --> 00:38:40,406
And now we have a single sort
method that can sort an array


810
00:38:40,406 --> 00:38:41,736
in a number of different ways.


811
00:38:42,366 --> 00:38:45,976
We can sort A to Z ascending,
using the lesson operator.


812
00:38:46,736 --> 00:38:49,776
We can sort descending, using
the greater than operator.


813
00:38:50,336 --> 00:38:54,916
We can even do something like
sort from shortest to longest


814
00:38:54,916 --> 00:38:56,876
by counting the number of
characters in each string.


815
00:38:57,566 --> 00:39:00,656
Now this is a great interface.


816
00:39:01,076 --> 00:39:02,636
It's also a lot of typing.


817
00:39:03,986 --> 00:39:07,286
And closures in this form are
a little awkward to work with.


818
00:39:07,796 --> 00:39:11,776
And the actual interesting
part gets lost


819
00:39:11,776 --> 00:39:13,486
in a lot of syntactic noise.


820
00:39:14,686 --> 00:39:16,976
Thankfully we have type
inference to help us here.


821
00:39:17,286 --> 00:39:18,926
Let's open a definition
of sorts.


822
00:39:20,216 --> 00:39:22,936
Sort, of course, already knows
what kind of closure it takes.


823
00:39:22,936 --> 00:39:25,736
In this case, we're working
with an array of strings


824
00:39:25,736 --> 00:39:28,056
so it takes two strings
and returns a Bool.


825
00:39:28,056 --> 00:39:32,336
Let's look at the
call side again,


826
00:39:32,336 --> 00:39:36,026
and that's really offensive,


827
00:39:36,026 --> 00:39:38,306
that's really burning
my eyes here and I want


828
00:39:39,396 --> 00:39:42,526
to do something about that.


829
00:39:42,746 --> 00:39:43,456
Much better.


830
00:39:44,446 --> 00:39:47,066
We can infer the
argument and return types


831
00:39:47,376 --> 00:39:49,416
from the signature
of the function.


832
00:39:49,966 --> 00:39:53,746
That's a great improvement,
but we don't stop there.


833
00:39:54,176 --> 00:39:56,496
If a closure consists of
a single return statement


834
00:39:56,496 --> 00:39:59,336
like this, we don't
need to specify return.


835
00:39:59,746 --> 00:40:03,766
A single expression closure
implicitly returns its results.


836
00:40:04,516 --> 00:40:07,576
[ Applause ]


837
00:40:08,076 --> 00:40:08,456
Thank you.


838
00:40:10,116 --> 00:40:12,996
At this point even the
argument list is starting


839
00:40:12,996 --> 00:40:14,056
to look a little heavy.


840
00:40:14,466 --> 00:40:15,656
Let's get rid of
that, too [laughter].


841
00:40:17,306 --> 00:40:21,836
There are implicit argument
names - $0, $1, $ a million.


842
00:40:22,136 --> 00:40:24,416
They may need a little taste in
some cases, but they're there


843
00:40:24,416 --> 00:40:26,846
if you need them and they
make closures really succinct


844
00:40:26,846 --> 00:40:29,236
and easy to use.


845
00:40:29,406 --> 00:40:31,786
We've also seen that we have
trailing closure syntax.


846
00:40:32,156 --> 00:40:34,106
When you have a single
argument like this,


847
00:40:35,216 --> 00:40:36,326
you can move it outside,


848
00:40:36,376 --> 00:40:38,266
and when it's the only
argument you can drop the


849
00:40:38,266 --> 00:40:39,356
parens altogether.


850
00:40:40,426 --> 00:40:42,136
And this makes functional
programming


851
00:40:42,136 --> 00:40:44,526
in Swift really expressive
and fun to do,


852
00:40:44,526 --> 00:40:48,356
and we've added methods
to the array class,


853
00:40:48,576 --> 00:40:51,366
to the array struct,
to make this possible.


854
00:40:52,116 --> 00:40:53,836
I'll start with a
list of all the words


855
00:40:53,836 --> 00:40:56,726
in the English language that we
got from the dictionary service.


856
00:40:57,086 --> 00:41:03,006
Now we can pick out words
that share some common traits,


857
00:41:03,006 --> 00:41:04,806
say the ones that end
in G-R-Y, and it turns


858
00:41:04,806 --> 00:41:07,496
out there's only two, and
we can use the filter method


859
00:41:07,956 --> 00:41:12,476
which selects out, which applies
a closure to each element


860
00:41:12,476 --> 00:41:14,266
of the array and for the one


861
00:41:14,266 --> 00:41:17,936
that it returns true returns
a new array containing those.


862
00:41:18,336 --> 00:41:23,326
We can then transform
these with the map method,


863
00:41:23,656 --> 00:41:25,246
which applies closure
to each element


864
00:41:25,246 --> 00:41:27,646
and collects the results
into another array.


865
00:41:28,166 --> 00:41:31,016
And then we can use
the reduced method


866
00:41:31,296 --> 00:41:34,246
to fold these into
a single string.


867
00:41:37,136 --> 00:41:40,406
Now each of these is
chaining another method call


868
00:41:40,406 --> 00:41:42,456
onto the result of the
previous expression.


869
00:41:42,926 --> 00:41:45,686
Even if we're using trailing
closure syntax we can just chain


870
00:41:45,686 --> 00:41:48,216
method invocations
using dot, like this.


871
00:41:49,196 --> 00:41:50,796
And because it's a
single expression,


872
00:41:52,286 --> 00:41:54,636
we can even include it in
a yet larger expression


873
00:41:55,706 --> 00:41:58,276
and include a lot
of complex logic


874
00:41:58,276 --> 00:42:00,296
into a very small
amount of code.


875
00:42:00,976 --> 00:42:04,666
It's an extremely expressive
way to build up your logic,


876
00:42:05,736 --> 00:42:08,806
even for a code that
doesn't involve Hulk.


877
00:42:09,516 --> 00:42:15,916
[ Applause ]


878
00:42:16,416 --> 00:42:18,366
Closures can also
capture local states.


879
00:42:18,936 --> 00:42:23,516
We could sum up all the elements
in array using a for loop


880
00:42:23,516 --> 00:42:27,406
or reduce, but we can
actually abuse math to do it.


881
00:42:27,676 --> 00:42:30,196
Inside of closure, we can
refer to local variables


882
00:42:30,196 --> 00:42:31,466
and we can even mutate them.


883
00:42:31,466 --> 00:42:32,746
There's never a need
to mark them


884
00:42:32,746 --> 00:42:35,636
under under block or in any way.


885
00:42:35,636 --> 00:42:36,526
It just works.


886
00:42:37,676 --> 00:42:43,796
And then we can return
that result.


887
00:42:43,796 --> 00:42:46,616
Closures are really just
literal functions in Swift.


888
00:42:47,076 --> 00:42:48,996
Just like you can
pass a literal integer


889
00:42:48,996 --> 00:42:51,746
or a named integer constant
as an integer parameter,


890
00:42:51,746 --> 00:42:54,666
you can pass a closure
or, indeed,


891
00:42:54,666 --> 00:42:57,076
a named function
as a closure value.


892
00:42:57,336 --> 00:43:00,296
We don't have to wrap up print
line in a closure like this.


893
00:43:01,196 --> 00:43:02,426
We can just pass print line.


894
00:43:02,426 --> 00:43:04,516
There's only one kind of
function type in Swift.


895
00:43:05,056 --> 00:43:08,246
We can even do this
with bound methods.


896
00:43:08,826 --> 00:43:12,516
Instead of packing an index
set like this, wrapping a call


897
00:43:12,516 --> 00:43:13,876
to the method in a closure,


898
00:43:14,776 --> 00:43:16,606
we can just pass the
bound method directly


899
00:43:16,606 --> 00:43:17,626
as a function value.


900
00:43:20,836 --> 00:43:23,206
Closures in Swift
are just ARC objects.


901
00:43:23,206 --> 00:43:25,766
They follow the same memory
management rules as classes.


902
00:43:25,766 --> 00:43:29,486
So if we wanted to
have a global variable


903
00:43:29,486 --> 00:43:33,786
that we can install a call
back on and write a function


904
00:43:34,326 --> 00:43:41,836
that installs a call back using
local state of that function,


905
00:43:41,936 --> 00:43:44,476
that reference will keep
that closure and all


906
00:43:44,476 --> 00:43:45,656
of its local state alive.


907
00:43:45,656 --> 00:43:47,806
There's never a need to
explicitly copy a closure


908
00:43:47,806 --> 00:43:50,636
or to worry about dangling
references to its environments.


909
00:43:51,106 --> 00:43:53,976
And just like closures
of functions,


910
00:43:54,036 --> 00:43:55,356
functions are also closures.


911
00:43:55,356 --> 00:43:58,616
We can nest functions inside
other functions and refer


912
00:43:58,616 --> 00:44:00,576
to the local state of
the outer function.


913
00:44:01,116 --> 00:44:03,306
If we look at these in the
debugger or in instruments,


914
00:44:03,306 --> 00:44:04,756
they show up with their names.


915
00:44:05,326 --> 00:44:10,936
So when we store a reference
to this in a global variable,


916
00:44:11,596 --> 00:44:13,586
even when the local
function goes out of scope,


917
00:44:14,206 --> 00:44:16,256
that reference keeps the
local function alive,


918
00:44:16,296 --> 00:44:17,196
just like the closure.


919
00:44:17,806 --> 00:44:22,326
Now because closures
are ARC objects,


920
00:44:22,326 --> 00:44:24,196
they have the same ownership


921
00:44:24,196 --> 00:44:26,836
and reference cycle
problems as classes can have.


922
00:44:27,426 --> 00:44:29,956
If we did something
as seemingly innocent


923
00:44:29,956 --> 00:44:33,716
as taking this call back and
putting it into the property


924
00:44:33,826 --> 00:44:37,026
of a class, we'll
have a problem.


925
00:44:38,406 --> 00:44:41,306
When we go to set up
these objects - of course,


926
00:44:41,476 --> 00:44:43,606
what we're really doing
is we're capturing self,


927
00:44:43,606 --> 00:44:45,386
and we're capturing it
as a strong reference.


928
00:44:45,826 --> 00:44:48,826
And then when we store reference
to the closure inside the class,


929
00:44:49,546 --> 00:44:53,706
we end up with the reference
cycle and a memory leak.


930
00:44:54,666 --> 00:44:59,156
The compiler actually won't let
you implicitly reference self


931
00:44:59,156 --> 00:45:01,136
inside of closure
because of this problem.


932
00:45:01,396 --> 00:45:04,816
Yeah, it's pretty nice.


933
00:45:05,526 --> 00:45:08,346
Now in a past life, you may
have solved this using unknown


934
00:45:08,346 --> 00:45:11,946
reference, using a local
variable with weak ownership.


935
00:45:12,886 --> 00:45:15,696
In Swift, we can use
unowned ownership instead,


936
00:45:16,666 --> 00:45:18,976
but this is problematic.


937
00:45:18,976 --> 00:45:21,536
Even if we did this, if
someone cut and pasted code


938
00:45:21,536 --> 00:45:23,426
into this closure, it
would still be capturing


939
00:45:23,426 --> 00:45:24,366
self strongly.


940
00:45:24,686 --> 00:45:26,356
So we have a better
way to do it in Swift.


941
00:45:27,136 --> 00:45:29,676
You can specify directly
inside the closure how


942
00:45:29,676 --> 00:45:31,176
to capture its local states.


943
00:45:32,516 --> 00:45:37,006
[ Applause ]


944
00:45:37,506 --> 00:45:39,086
And now when we set
up the object graph,


945
00:45:39,136 --> 00:45:41,326
there's no longer a
cycle, and there's no leak.


946
00:45:41,946 --> 00:45:44,716
So that's closures in Swift.


947
00:45:44,716 --> 00:45:47,656
They have an incredibly
expressive syntax


948
00:45:48,966 --> 00:45:51,456
and a much simplified memory
model from Objective-C,


949
00:45:51,456 --> 00:45:53,406
and they make functional
programming


950
00:45:53,406 --> 00:45:55,346
in Swift really awesome
and powerful.


951
00:45:55,346 --> 00:45:59,326
Now I'd like to talk about
another powerful feature


952
00:45:59,326 --> 00:46:01,116
of Swift, pattern matching.


953
00:46:01,716 --> 00:46:08,136
You may have seen in the intro
talk that Switch not only works


954
00:46:08,136 --> 00:46:11,496
with integers, it also works
with strings or, indeed,


955
00:46:11,496 --> 00:46:15,826
values of any type, and also
works with ranges of values,


956
00:46:15,896 --> 00:46:18,006
but that's just the
tip of the iceberg.


957
00:46:19,156 --> 00:46:21,326
You may also remember
that enumerations


958
00:46:21,326 --> 00:46:24,606
in Swift can carry associated
data, and we can tell not only


959
00:46:24,606 --> 00:46:27,076
that a train is delayed,
we can say by how much,


960
00:46:27,296 --> 00:46:29,366
with an integer value
that only makes sense


961
00:46:30,526 --> 00:46:31,896
when the train is delayed.


962
00:46:33,276 --> 00:46:37,516
Because this associated data is
tied to that case of the enum,


963
00:46:38,626 --> 00:46:40,536
we access it through
a case statement.


964
00:46:41,776 --> 00:46:43,796
We combine it to a
variable and then use


965
00:46:43,796 --> 00:46:45,966
that variable inside
that case statement.


966
00:46:46,246 --> 00:46:48,886
It's electrically
scoped to that case.


967
00:46:49,406 --> 00:46:52,476
Cases are electrical
scopes by default in Swift,


968
00:46:52,476 --> 00:46:54,316
and we can't access
it anywhere else.


969
00:46:54,316 --> 00:46:57,276
It's much safer and easier
than using an enum with a union


970
00:46:57,276 --> 00:46:59,076
or struct like you
may have in C.


971
00:46:59,566 --> 00:47:03,326
Now this is a simple
case of a pattern.


972
00:47:04,126 --> 00:47:08,906
This outer construct
Delayed only matches values


973
00:47:08,906 --> 00:47:11,486
of the delayed state
inside the enum.


974
00:47:12,966 --> 00:47:14,636
And if it is at the
delayed state,


975
00:47:14,636 --> 00:47:16,856
it unwraps the associated
data and passes it


976
00:47:16,856 --> 00:47:17,996
down to a sub pattern.


977
00:47:18,196 --> 00:47:21,106
In this case, the let pattern
binds it to a variable.


978
00:47:21,586 --> 00:47:25,446
This is actually a
completely independent


979
00:47:25,446 --> 00:47:26,666
and fully powerful pattern.


980
00:47:26,666 --> 00:47:29,226
Anything we do at the
top level of a switch


981
00:47:29,226 --> 00:47:31,746
with an int we can do
to its associated value.


982
00:47:32,806 --> 00:47:34,726
So we can match it
against a specific value,


983
00:47:34,726 --> 00:47:36,256
say we're delayed by one minute.


984
00:47:36,856 --> 00:47:39,076
We can match it against a range
of values say we're delayed


985
00:47:39,076 --> 00:47:40,166
from two to 10 minutes.


986
00:47:41,046 --> 00:47:42,876
We can also ignore
the value altogether,


987
00:47:42,876 --> 00:47:45,796
match any Delay using
the underscore,


988
00:47:45,796 --> 00:47:47,946
which is the wild card pattern.


989
00:47:48,516 --> 00:47:54,646
[ Applause ]


990
00:47:55,146 --> 00:47:58,266
You can also use enums as
associated data of other enums.


991
00:47:58,796 --> 00:48:02,296
We can track not only the status


992
00:48:02,296 --> 00:48:04,616
of our train while
we're traveling,


993
00:48:04,616 --> 00:48:07,526
we can track the entire state of
our vacation, and when we do so,


994
00:48:07,526 --> 00:48:08,706
we can tell our friends


995
00:48:08,706 --> 00:48:10,526
on social media based
on that state.


996
00:48:11,246 --> 00:48:13,056
We can match a simple
case of the enum,


997
00:48:13,736 --> 00:48:17,196
we can match a nested associated
value two levels deep.


998
00:48:17,296 --> 00:48:20,346
If we're 15 minutes in, we might
be able to, 15 minutes delayed,


999
00:48:20,346 --> 00:48:22,896
we might be a little
snarky, but still composed.


1000
00:48:23,596 --> 00:48:24,756
If we're delayed
any more than that,


1001
00:48:24,756 --> 00:48:26,826
we might get a little upset.


1002
00:48:30,296 --> 00:48:32,686
Pattern matching doesn't
just work with enumerations.


1003
00:48:32,686 --> 00:48:35,656
It also works with the
dynamic types of classes.


1004
00:48:36,166 --> 00:48:38,856
Let's say we're going
to tune up a car,


1005
00:48:38,856 --> 00:48:40,106
and it's an arbitrary car.


1006
00:48:40,766 --> 00:48:44,046
If someone brings a Formula
One car into our mechanics,


1007
00:48:44,046 --> 00:48:48,296
to our mechanic, he's probably
going to be a little confused.


1008
00:48:48,296 --> 00:48:49,886
He might want to take
it to a specialist.


1009
00:48:50,786 --> 00:48:52,716
We can do this using
the as pattern.


1010
00:48:53,276 --> 00:48:56,416
This will both check that the
value is of a type, and if so,


1011
00:48:56,416 --> 00:48:59,516
cast it and pass it
into the sub pattern,


1012
00:48:59,516 --> 00:49:01,406
which we can then use
to bind a variable.


1013
00:49:01,936 --> 00:49:04,996
And then we can pass it on to
a pit crew, who will then tune


1014
00:49:04,996 --> 00:49:06,416
up that Formula One car.


1015
00:49:07,516 --> 00:49:10,866
For a more mundane car,
we can pattern match it,


1016
00:49:10,866 --> 00:49:14,406
and then if it has a turbo, tune
up the turbo before following


1017
00:49:14,456 --> 00:49:17,996
through using the fall through
statement into the default case


1018
00:49:18,196 --> 00:49:22,986
that does the normal
tune-up for a car.


1019
00:49:23,186 --> 00:49:26,096
We can also pattern match
multiple values simultaneously


1020
00:49:26,096 --> 00:49:27,036
using tuples.


1021
00:49:27,446 --> 00:49:30,006
Tuples are a great way of
returning multiple values


1022
00:49:30,006 --> 00:49:33,846
from a function or for
combining related values


1023
00:49:33,846 --> 00:49:39,236
like the components of a color,
and when we do so, each element


1024
00:49:39,236 --> 00:49:41,566
of this tuple pattern is
an independent pattern.


1025
00:49:42,346 --> 00:49:46,506
We can match red against a
single value, we can match green


1026
00:49:46,506 --> 00:49:49,876
against a range of values,
bind blue to a variable


1027
00:49:50,206 --> 00:49:54,826
and ignore the alpha component
all in a single pattern.


1028
00:49:55,516 --> 00:49:59,726
[ Applause ]


1029
00:50:00,226 --> 00:50:02,366
We can also match
multiple values


1030
00:50:02,366 --> 00:50:03,866
and test additional conditions


1031
00:50:03,866 --> 00:50:05,706
with those values
using a where clause.


1032
00:50:06,626 --> 00:50:08,376
Here we're testing that
they're all equal to see


1033
00:50:08,376 --> 00:50:09,606
if it's a grey scale value.


1034
00:50:10,186 --> 00:50:13,956
So these are some
neat parlor tricks.


1035
00:50:14,166 --> 00:50:16,086
Let's try something
a little more real.


1036
00:50:16,086 --> 00:50:21,186
Let's validate a property list,
a dictionary of arbitrary values


1037
00:50:21,186 --> 00:50:24,506
of unknown type, and
given a valid one.


1038
00:50:24,506 --> 00:50:27,386
we want to return a
well-typed struct.


1039
00:50:30,756 --> 00:50:35,236
Given a property list with
a name key that's a string,


1040
00:50:35,306 --> 00:50:36,796
a population that's a number


1041
00:50:37,056 --> 00:50:39,026
and a two-letter
postal abbreviation,


1042
00:50:39,026 --> 00:50:42,056
we want to get a
record like this.


1043
00:50:42,266 --> 00:50:44,756
However, if one of the
fields is of the wrong type,


1044
00:50:44,756 --> 00:50:50,256
or if the postal abbreviation is
too long, we want to return nil.


1045
00:50:51,126 --> 00:50:52,766
Let's see how we can do
this with pattern matching.


1046
00:50:53,436 --> 00:50:59,466
We'll start with a single
key of the property list.


1047
00:50:59,806 --> 00:51:05,466
And you may remember that
optional is just an enumeration,


1048
00:51:05,466 --> 00:51:07,246
so we can use an
enumeration pattern


1049
00:51:07,246 --> 00:51:09,936
to both reject property
lists that don't have the key


1050
00:51:10,166 --> 00:51:14,476
and unwrap the value
for ones that do.


1051
00:51:14,726 --> 00:51:17,906
Inside that pattern, we
can use a type pattern


1052
00:51:17,906 --> 00:51:20,916
to both reject property lists
that don't have a string name


1053
00:51:21,356 --> 00:51:23,796
and get the string value
out for those that do.


1054
00:51:24,896 --> 00:51:27,856
Then we can use a let pattern
to bind to that string value


1055
00:51:28,446 --> 00:51:29,726
and store it to a variable


1056
00:51:30,296 --> 00:51:34,616
with a single default clause
handle all invalid names.


1057
00:51:35,056 --> 00:51:38,726
Now we can repeat this for
each element that we care


1058
00:51:38,726 --> 00:51:41,736
about inside the dictionary,
but there's a better way.


1059
00:51:42,226 --> 00:51:43,816
Remember we can use
tuple patterns


1060
00:51:43,886 --> 00:51:48,396
to match these simultaneously
and repeat this pattern


1061
00:51:48,746 --> 00:51:52,236
for each key of the property
list that we're interested in.


1062
00:51:52,766 --> 00:51:55,316
We can see that the
name is a string,


1063
00:51:55,316 --> 00:51:56,566
the population is a number


1064
00:51:56,566 --> 00:52:00,196
and the abbreviation is a string
all simultaneously, and with the


1065
00:52:00,196 --> 00:52:02,216
where clause even
check the abbreviations


1066
00:52:02,216 --> 00:52:06,596
of the appropriate
length, and we're done.


1067
00:52:06,816 --> 00:52:08,126
With a single default clause,


1068
00:52:08,126 --> 00:52:10,356
we handle all invalid
property lists,


1069
00:52:10,606 --> 00:52:12,496
and it all fits nicely
on a single slide.


1070
00:52:13,746 --> 00:52:14,926
That's the power of
pattern matching.


1071
00:52:15,516 --> 00:52:19,566
[ Applause ]


1072
00:52:20,066 --> 00:52:22,336
It's an incredible way to
test the structure of values


1073
00:52:22,746 --> 00:52:24,536
and really improve
the readability


1074
00:52:24,626 --> 00:52:25,926
and safety of your code.


1075
00:52:26,486 --> 00:52:31,846
So we still just scratched the
surface of what Swift can do.


1076
00:52:33,146 --> 00:52:36,746
We've looked at how optionals
allow you to write safe code;


1077
00:52:37,196 --> 00:52:39,956
we looked at the
foundations of Swift


1078
00:52:39,956 --> 00:52:42,006
in memory management
and initialization.


1079
00:52:43,546 --> 00:52:45,476
We looked at how
powerful closure is


1080
00:52:45,476 --> 00:52:46,616
and pattern matching are.


1081
00:52:47,976 --> 00:52:49,796
There's a ton more
information online.


1082
00:52:50,116 --> 00:52:52,096
There's the book that you
probably already downloaded


1083
00:52:52,096 --> 00:52:52,946
and read by now.


1084
00:52:53,026 --> 00:52:56,036
There's also some additional
material on the developers site


1085
00:52:56,036 --> 00:52:57,386
about Interop with Cocoa.


1086
00:52:58,166 --> 00:53:01,746
If you're following along from
home, talk to Dave, he's great,


1087
00:53:02,016 --> 00:53:02,996
and there's our forums.


1088
00:53:03,656 --> 00:53:07,036
You also might want to
save your seat here.


1089
00:53:07,036 --> 00:53:09,216
We've got a lot of other great
Swift sessions right here


1090
00:53:09,216 --> 00:53:09,916
in Presidio.


1091
00:53:10,816 --> 00:53:11,476
Thank you.

