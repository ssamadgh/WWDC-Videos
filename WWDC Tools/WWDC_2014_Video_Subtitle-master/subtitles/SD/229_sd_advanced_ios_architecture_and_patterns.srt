1
00:00:00,506 --> 00:00:10,516
[ Silence ]


2
00:00:11,016 --> 00:00:14,000
[ Applause ]


3
00:00:15,176 --> 00:00:15,816
>> Thank you.


4
00:00:16,796 --> 00:00:17,616
Thank you very much.


5
00:00:18,206 --> 00:00:19,366
My name is Andy Matuschak.


6
00:00:19,366 --> 00:00:21,686
I work on the UIKit Framework.


7
00:00:22,326 --> 00:00:25,466
And later I'm going to be joined
by my colleague, Colin Barrett,


8
00:00:25,466 --> 00:00:27,026
who also works on UIKit.


9
00:00:27,026 --> 00:00:28,956
And today we're going to talk


10
00:00:29,356 --> 00:00:36,276
about Advanced iOS Architectural
Patterns, which is going to sort


11
00:00:36,276 --> 00:00:39,326
of be a continuation of Bill
Dudney's talk from this morning,


12
00:00:39,326 --> 00:00:41,976
the Core iOS Application
Architecture and Patterns.


13
00:00:41,976 --> 00:00:44,676
We're going to be taking some
of those ideas a little further


14
00:00:45,336 --> 00:00:47,776
and just in case you didn't see
that talk this morning or even


15
00:00:47,776 --> 00:00:50,276
if you did, I want to
tell a little story


16
00:00:50,946 --> 00:00:53,096
that explains I think
how we all got here.


17
00:00:54,006 --> 00:00:56,106
So maybe you start
off by yourself


18
00:00:56,106 --> 00:00:58,606
and the project starts
small, your well intentioned,


19
00:00:59,156 --> 00:01:02,326
you're keeping everything
orderly, you're adding features


20
00:01:03,036 --> 00:01:04,066
and everything is still good.


21
00:01:04,066 --> 00:01:07,666
You add more features
and they kind of pile up


22
00:01:07,666 --> 00:01:09,266
and you got momentum
behind you now.


23
00:01:09,266 --> 00:01:11,086
You have all these users
and they're demanding.


24
00:01:11,086 --> 00:01:13,926
You had some more developers
because maybe that will help,


25
00:01:14,416 --> 00:01:16,896
but it doesn't seem to
have quite the impact


26
00:01:16,896 --> 00:01:18,896
on your progress that
you'd been hoping for


27
00:01:18,896 --> 00:01:24,016
and you're making changes
faster and faster and bugs seem


28
00:01:24,016 --> 00:01:26,296
to be appearing faster
and faster.


29
00:01:27,396 --> 00:01:30,016
And it seems like all you're
doing is spending your time


30
00:01:30,016 --> 00:01:30,586
fighting bugs.


31
00:01:32,086 --> 00:01:35,136
And you think, OK, well
I'll knock a few down


32
00:01:35,136 --> 00:01:36,376
and a few more come back.


33
00:01:36,966 --> 00:01:38,156
You're not adding new features.


34
00:01:38,156 --> 00:01:42,056
You had some unit tests
to try to get a handle


35
00:01:42,056 --> 00:01:42,886
on what's going on here.


36
00:01:42,886 --> 00:01:46,116
Somebody's told you that's going
to help things, but it seems


37
00:01:46,116 --> 00:01:49,636
to help initially and then
the bugs start coming back.


38
00:01:50,256 --> 00:01:54,836
And then you learn actually your
unit test can have bugs too.


39
00:01:55,516 --> 00:01:57,796
[ Laughter ]


40
00:01:58,296 --> 00:02:01,026
What do we do?


41
00:02:01,256 --> 00:02:04,086
People say: Software
Architecture.


42
00:02:04,086 --> 00:02:06,976
And you go, "All right, cool.


43
00:02:08,036 --> 00:02:08,705
Software Architecture.


44
00:02:09,006 --> 00:02:09,826
All right."


45
00:02:10,376 --> 00:02:11,566
What's Software Architecture?


46
00:02:12,896 --> 00:02:16,466
You search around the Internet,
you get a whole bunch of blogs.


47
00:02:16,596 --> 00:02:17,826
They're listing like, "Oh man.


48
00:02:17,826 --> 00:02:20,716
Never do this stuff it's going
to make your architecture bad."


49
00:02:20,716 --> 00:02:23,596
And it seems like there's a
lot of contradicting opinions.


50
00:02:23,596 --> 00:02:25,686
Some people say start
small and some people want


51
00:02:25,686 --> 00:02:26,886
to design everything up front.


52
00:02:27,926 --> 00:02:30,736
Seems like these discussions
just keep coming back


53
00:02:31,066 --> 00:02:35,436
to taste, maybe dogma.


54
00:02:35,586 --> 00:02:37,376
All you really know maybe is


55
00:02:37,416 --> 00:02:43,036
that your taste is improving a
lot faster than your ability.


56
00:02:44,086 --> 00:02:46,086
[ Laughter ]


57
00:02:46,156 --> 00:02:48,206
You can tell that something
is starting to get smelly.


58
00:02:48,206 --> 00:02:49,816
You can tell you've
got a problem,


59
00:02:50,586 --> 00:02:52,826
but maybe you don't know
what to do about it.


60
00:02:53,996 --> 00:02:55,666
So we're going to try to help.


61
00:02:56,436 --> 00:02:58,386
We can only scratched
the surface today.


62
00:02:59,066 --> 00:03:02,336
The idea is to take some
time honored concepts


63
00:03:02,786 --> 00:03:04,566
from computer science
and software engineering


64
00:03:04,566 --> 00:03:09,076
and to present them, hopefully,
less abstractly and in a way


65
00:03:09,076 --> 00:03:13,716
that might make sense to you as
an iOS developer with your apps.


66
00:03:14,456 --> 00:03:17,916
Today, we're hoping to
provide insight, not dogma.


67
00:03:18,016 --> 00:03:19,656
[ Applause ]


68
00:03:19,656 --> 00:03:19,976
We're not--


69
00:03:20,016 --> 00:03:21,396
[ Applause ]


70
00:03:21,396 --> 00:03:21,936
I'm so glad.


71
00:03:21,936 --> 00:03:24,096
I'm so glad to hear that.


72
00:03:24,616 --> 00:03:25,846
Epistemology is important.


73
00:03:26,816 --> 00:03:30,756
You need to know why you're
having architectural problems.


74
00:03:31,146 --> 00:03:35,926
Not just a bag of tricks
that you can use when faced


75
00:03:35,986 --> 00:03:37,716
with any particular issue.


76
00:03:38,946 --> 00:03:41,136
That way, hopefully you'll
have a real objective measure


77
00:03:41,316 --> 00:03:42,916
that you can use to
compare approaches.


78
00:03:43,126 --> 00:03:45,086
That way, when your
colleagues disagree with you,


79
00:03:45,086 --> 00:03:47,126
you can actually talk
about what might be better


80
00:03:47,126 --> 00:03:49,156
and what might be
worse and why rather


81
00:03:49,156 --> 00:03:50,786
than just citing a
bunch of catch phrases.


82
00:03:50,786 --> 00:03:51,526
All right.


83
00:03:52,556 --> 00:03:56,326
So today, we're going to
talk about 3 broad approaches


84
00:03:57,586 --> 00:04:00,266
that you can use to consider the
complexity of your application


85
00:04:00,266 --> 00:04:01,906
and evaluate approaches
to dealing with it.


86
00:04:03,316 --> 00:04:07,636
First, when we have tangled
meshes of information networks


87
00:04:07,696 --> 00:04:09,216
like this, we're
going to clean them


88
00:04:09,216 --> 00:04:12,156
up by actually designing
the information flow


89
00:04:12,156 --> 00:04:13,166
in our application rather


90
00:04:13,166 --> 00:04:15,476
than just letting it
grow ad hoc like a weed.


91
00:04:16,505 --> 00:04:20,666
And then when our objects start
to become amorphous blobs,


92
00:04:21,426 --> 00:04:23,846
we're going to separate them
actually define what their


93
00:04:23,846 --> 00:04:27,076
responsibilities are
and hopefully get each


94
00:04:27,076 --> 00:04:28,326
of those circles
a little smaller.


95
00:04:29,336 --> 00:04:32,956
And finally when the very ground
seems to be shifting out from


96
00:04:32,956 --> 00:04:36,086
under you, we're going to
take advantage of immutability


97
00:04:36,086 --> 00:04:38,956
and in particular, some
new features of Swift


98
00:04:40,016 --> 00:04:41,196
to really get a handle
on things.


99
00:04:41,986 --> 00:04:44,546
So those are the big
concepts from today.


100
00:04:44,546 --> 00:04:49,136
And we'll start by talking about
designing information flow.


101
00:04:49,726 --> 00:04:53,646
Now, much of the complexity


102
00:04:53,646 --> 00:04:55,626
in a modern application
is really just shuffling


103
00:04:55,626 --> 00:04:57,766
information at events around.


104
00:04:58,306 --> 00:05:02,706
You have delegate handlers,
and target action callbacks,


105
00:05:02,706 --> 00:05:05,426
you have completion blocks,
and you have some signals.


106
00:05:06,336 --> 00:05:09,806
And how should those
information and events go


107
00:05:09,876 --> 00:05:10,876
through your application?


108
00:05:10,876 --> 00:05:13,086
You start wiring stuff up.


109
00:05:13,086 --> 00:05:14,386
You set these object
as a delegate


110
00:05:14,386 --> 00:05:15,926
of this other object over here.


111
00:05:16,536 --> 00:05:19,176
You say add target action, and
every time you're doing that,


112
00:05:20,226 --> 00:05:21,926
you're adding a little
node to this network.


113
00:05:22,646 --> 00:05:25,666
And that network is getting
gnarlier and gnarlier


114
00:05:25,666 --> 00:05:28,116
and maybe you've drawn
networks like this for say,


115
00:05:28,846 --> 00:05:31,066
object ownership in
your application.


116
00:05:31,346 --> 00:05:34,446
Which object owns which other
object or maybe for a workflow.


117
00:05:34,716 --> 00:05:37,096
But in this section,
we're going to talk


118
00:05:37,096 --> 00:05:39,906
about thinking conceptually
about this diagram


119
00:05:39,906 --> 00:05:42,746
as it pertains to information
flow in your application.


120
00:05:43,446 --> 00:05:45,846
Where is information coming
from and where is it going?


121
00:05:46,636 --> 00:05:49,456
And the first question
I'll ask is


122
00:05:50,176 --> 00:05:52,826
where is truth in
my application?


123
00:05:53,716 --> 00:05:55,786
And in order to do
that, and in order


124
00:05:55,786 --> 00:05:57,626
to keep things hopefully
somewhat concrete,


125
00:05:57,626 --> 00:06:01,006
we're going to turn
to a demo application


126
00:06:01,526 --> 00:06:05,666
which is having its own
problems with information flow.


127
00:06:05,666 --> 00:06:07,926
All right.


128
00:06:09,696 --> 00:06:13,926
So over here, we have an
application and it's going


129
00:06:13,926 --> 00:06:14,786
to be written in Swift.


130
00:06:14,786 --> 00:06:18,546
And that's just because
I like Swift quite a lot.


131
00:06:18,896 --> 00:06:20,736
But the topics we're discussing


132
00:06:20,736 --> 00:06:24,936
in this particular section
really don't require Swift.


133
00:06:25,946 --> 00:06:26,186
All right.


134
00:06:26,186 --> 00:06:27,306
So with the journaling
application,


135
00:06:28,006 --> 00:06:30,446
write down what's going on in
your life, keep track of things.


136
00:06:30,766 --> 00:06:31,776
Maybe you're Abraham Lincoln.


137
00:06:32,546 --> 00:06:35,096
And like any good
journaling app,


138
00:06:35,096 --> 00:06:36,786
there's a UI to add an entry.


139
00:06:36,786 --> 00:06:40,646
You've gotten a bug report
from a user talking about a bug


140
00:06:40,646 --> 00:06:43,636
with the photo edition
UI in your application.


141
00:06:44,676 --> 00:06:47,426
So we'll go ahead and start
making a journal entry.


142
00:06:49,256 --> 00:06:54,646
We will add a photo, taken
this one from apple.com


143
00:06:55,246 --> 00:07:00,366
and there's this feature that
lets me show and hide the photos


144
00:07:00,366 --> 00:07:02,086
that I've attached
to my journal entry.


145
00:07:03,006 --> 00:07:04,316
Everything is looking
good so far.


146
00:07:05,236 --> 00:07:09,676
But this bug report I got said
that the app seems to break


147
00:07:10,256 --> 00:07:11,516
when I'm playing
with this button.


148
00:07:12,416 --> 00:07:15,706
So, I'll play with the button.


149
00:07:17,136 --> 00:07:19,206
Something really glitchy
is happening there


150
00:07:19,206 --> 00:07:20,276
and we have a crash.


151
00:07:22,526 --> 00:07:23,336
That's no good.


152
00:07:23,776 --> 00:07:25,726
Now we could look
at this back trace


153
00:07:25,726 --> 00:07:30,546
but probably the problem
has already happened.


154
00:07:31,656 --> 00:07:32,946
And we can see the issue is--


155
00:07:33,176 --> 00:07:36,456
now this exclamation
point here is going awry.


156
00:07:37,676 --> 00:07:41,116
Rather than trying to
address this specific crasher,


157
00:07:41,726 --> 00:07:45,386
I'd like to draw your attention
to the infrastructural problem


158
00:07:45,846 --> 00:07:47,316
which is underlying
this crasher.


159
00:07:47,956 --> 00:07:51,246
So let's take a look at
how exactly this expanding


160
00:07:51,246 --> 00:07:53,486
and collapsing of the
PhotoDrawer feature is working.


161
00:07:54,076 --> 00:07:55,316
Here's expandPhotoDrawer.


162
00:07:55,766 --> 00:07:57,836
And first we say, OK do
we have a PhotoDrawerView?


163
00:07:58,696 --> 00:08:02,516
If we don't, make
one, get it all laid


164
00:08:02,516 --> 00:08:04,406
out so it'll expand
from zero height.


165
00:08:05,366 --> 00:08:09,176
Animate it to full height and,
you know, update that button,


166
00:08:09,176 --> 00:08:10,106
a little bit of bookkeeping.


167
00:08:10,686 --> 00:08:14,186
Of course then, in
collapsePhotoDrawer,


168
00:08:14,186 --> 00:08:16,056
if we already have a
PhotoDrawer which we want


169
00:08:16,056 --> 00:08:17,976
to collapse, we animate it shut.


170
00:08:18,836 --> 00:08:21,366
And when the animation
is done, we remove it.


171
00:08:22,486 --> 00:08:24,056
It seems pretty straightforward.


172
00:08:24,546 --> 00:08:27,046
You know, you might
say, well this option,


173
00:08:27,596 --> 00:08:28,856
this option seems
to be the problem.


174
00:08:28,856 --> 00:08:30,306
Like you're letting
users interact


175
00:08:30,306 --> 00:08:32,216
with your UI while the
animation is going on.


176
00:08:32,696 --> 00:08:33,515
You shouldn't do that.


177
00:08:34,285 --> 00:08:37,385
And, OK, so you could
remove this option.


178
00:08:37,926 --> 00:08:43,826
But you know, we do actually
want to keep things fluid.


179
00:08:43,826 --> 00:08:45,816
There's no reason that the
world should have to stop just


180
00:08:45,816 --> 00:08:47,206
because this PhotoDrawer
is opening up.


181
00:08:48,006 --> 00:08:50,836
And furthermore, we're
starting to get a little sense


182
00:08:50,836 --> 00:08:53,336
of that taste versus ability
tradeoff we were talking


183
00:08:53,336 --> 00:08:53,736
about earlier.


184
00:08:53,736 --> 00:08:56,156
I mean, hopefully you're looking
at this and you're saying that


185
00:08:56,156 --> 00:08:59,426
"Well, I don't exactly
see anything wrong.


186
00:08:59,426 --> 00:09:01,586
So trying to work
around this bug


187
00:09:01,586 --> 00:09:03,266
by just disabling the
button doesn't seem


188
00:09:03,266 --> 00:09:04,586
like the best thing to do.


189
00:09:05,336 --> 00:09:06,526
What's really going on?"


190
00:09:07,196 --> 00:09:09,206
And even if we were to
disable this button,


191
00:09:10,016 --> 00:09:12,016
things get somewhat worse.


192
00:09:12,576 --> 00:09:14,136
If I rerun this application,


193
00:09:14,136 --> 00:09:15,766
I'll show you there's
sort of a side feature.


194
00:09:16,056 --> 00:09:19,806
So say that it was the case
that you could not interact


195
00:09:21,096 --> 00:09:24,236
with the Show Photos button
while the animation is going on.


196
00:09:25,356 --> 00:09:30,886
Well, down here is our body
and as we start typing into it,


197
00:09:31,546 --> 00:09:35,816
we hide that PhotoDrawer
because we want


198
00:09:35,816 --> 00:09:37,156
to have more space
for the keyboard.


199
00:09:38,366 --> 00:09:41,796
So it's actually not good enough
just to disable this button


200
00:09:42,426 --> 00:09:44,886
to make this problem go away.


201
00:09:45,306 --> 00:09:46,736
The problem will still exist


202
00:09:46,736 --> 00:09:48,996
because we collapsed
this PhotoDrawer


203
00:09:50,476 --> 00:09:51,856
when we focused the body.


204
00:09:52,166 --> 00:09:54,156
If I were to keep going on
like that, it would crash.


205
00:09:55,296 --> 00:09:57,666
So there's something more
fundamental at play here.


206
00:09:57,666 --> 00:10:02,856
There's some mold growing in the
corner and I'd like to return


207
00:10:03,046 --> 00:10:09,976
to a diagrammatic approach
to examine that mold.


208
00:10:10,046 --> 00:10:13,236
Now this is boxes and
arrows representation


209
00:10:13,236 --> 00:10:14,956
of the information flow
on our application.


210
00:10:16,286 --> 00:10:18,886
We've got this photos
drawer tap action


211
00:10:19,356 --> 00:10:21,466
and we've also got a
text view focus action,


212
00:10:21,626 --> 00:10:24,696
and they're both doing something
based on a piece of information.


213
00:10:24,696 --> 00:10:26,536
And that piece of
information is:


214
00:10:27,446 --> 00:10:29,646
does that photos drawer exist,


215
00:10:29,806 --> 00:10:31,606
does that drawer
view exist already?


216
00:10:31,856 --> 00:10:34,226
And we saw in the code, if it
doesn't exist, OK we'll make it.


217
00:10:34,596 --> 00:10:36,556
And if does exist, we'll
start an animation.


218
00:10:36,556 --> 00:10:38,156
When that animation is
done, we'll throw it out.


219
00:10:38,156 --> 00:10:40,846
That's fundamentally
what's going on here.


220
00:10:42,226 --> 00:10:45,666
This bug is occurring because
we're getting our information


221
00:10:45,666 --> 00:10:46,376
from the wrong place.


222
00:10:47,056 --> 00:10:49,306
There's another piece
of state, which is,


223
00:10:49,306 --> 00:10:52,186
is the drawer semantically
expanded?


224
00:10:52,186 --> 00:10:56,106
And that's separate from,
does the drawer view exist.


225
00:10:56,246 --> 00:10:57,636
Because the draw view isn't torn


226
00:10:57,636 --> 00:11:00,046
down until the animation
completes.


227
00:11:01,306 --> 00:11:05,796
If we start collapsing the
drawer, then we want to think


228
00:11:05,796 --> 00:11:09,246
about the state of the system
as the drawer is collapsed now,


229
00:11:09,856 --> 00:11:11,856
just like if you start animating
a view to the other side


230
00:11:11,856 --> 00:11:14,556
of the screen, its model value
is already at its destination.


231
00:11:15,756 --> 00:11:17,346
The drawer view's
existence is more


232
00:11:17,346 --> 00:11:18,866
like the presentation
value of the view.


233
00:11:18,976 --> 00:11:21,376
It's like a proxy for
that underlying truth.


234
00:11:22,086 --> 00:11:24,156
Should the drawer
view be expanded,


235
00:11:24,156 --> 00:11:26,636
you can module any
animations that are going on.


236
00:11:27,516 --> 00:11:30,806
So we can deal with this problem
by reifying that piece of state.


237
00:11:31,366 --> 00:11:32,166
We can make a property.


238
00:11:32,326 --> 00:11:34,826
Say, you know, is the drawer
view expanded right now,


239
00:11:34,826 --> 00:11:36,976
updated immediately
when we start collapsing


240
00:11:36,976 --> 00:11:39,256
that drawer view and
when we start expanding


241
00:11:39,256 --> 00:11:39,806
that drawer view.


242
00:11:41,206 --> 00:11:44,646
And then once we do that,
we can look at this diagram


243
00:11:44,646 --> 00:11:45,446
and say, "Wait, wait, wait.


244
00:11:46,096 --> 00:11:52,016
Why are these actions getting
their truth from whether


245
00:11:52,016 --> 00:11:53,166
or not the drawer view exists?"


246
00:11:53,166 --> 00:11:55,926
What really matters is whether
or not the drawer is supposed


247
00:11:55,926 --> 00:11:56,896
to be expanded or not.


248
00:11:57,516 --> 00:11:59,006
And when you tap
in the text view,


249
00:11:59,106 --> 00:12:01,396
you should only really be
collapsing the PhotoDrawer


250
00:12:02,496 --> 00:12:04,406
if it is actually expanded.


251
00:12:04,686 --> 00:12:07,666
You don't want to try to
collapse the PhotoDrawer if it's


252
00:12:07,876 --> 00:12:10,806
in the process of
being collapsed already


253
00:12:11,726 --> 00:12:13,886
but that drawer view
hasn't been removed yet.


254
00:12:13,886 --> 00:12:16,906
Now in this talk, I'm
not actually going


255
00:12:16,906 --> 00:12:18,956
to make the code changes
that we're talking about here


256
00:12:18,956 --> 00:12:20,696
because we have a lot of
material to get through


257
00:12:20,696 --> 00:12:21,626
and I want to cover it quickly.


258
00:12:22,176 --> 00:12:24,326
But here we've been able
to solve this problem,


259
00:12:24,816 --> 00:12:28,636
at a conceptual level at least,
by thinking about our system


260
00:12:28,796 --> 00:12:31,976
in terms of how information
is moving through it:


261
00:12:32,096 --> 00:12:33,816
where are we getting data,
how we're making decisions.


262
00:12:34,656 --> 00:12:37,066
And considering first:
where is truth?


263
00:12:38,356 --> 00:12:41,486
Who really knows that state


264
00:12:42,066 --> 00:12:44,406
which one place should
be consulted for it?


265
00:12:44,406 --> 00:12:47,426
And that will help
us get all the boxes


266
00:12:47,426 --> 00:12:48,836
that we need in our diagram.


267
00:12:49,566 --> 00:12:51,946
Now, once we've gotten all the
boxes we need in our diagram,


268
00:12:52,076 --> 00:12:55,386
I want to draw your
attention to the difference


269
00:12:55,586 --> 00:12:59,646
between that root level
truth, that one place


270
00:12:59,646 --> 00:13:01,216
in your application
that actually knows


271
00:13:01,216 --> 00:13:04,676
where things are supposed
to be and the values


272
00:13:04,676 --> 00:13:06,486
which are merely
derived from it.


273
00:13:06,836 --> 00:13:09,406
So in order to do that,
again, let's return


274
00:13:09,406 --> 00:13:10,856
to our demo application.


275
00:13:11,156 --> 00:13:17,526
And you'll see here that
as I continue typing,


276
00:13:18,006 --> 00:13:19,866
there's a character counter.


277
00:13:20,066 --> 00:13:21,176
And that character
counter is there


278
00:13:21,176 --> 00:13:23,736
because you might be
an extremely outgoing


279
00:13:23,736 --> 00:13:25,806
and extroverted person with
your journal and you might want


280
00:13:25,806 --> 00:13:28,056
to take advantage of
this feature that we have


281
00:13:28,056 --> 00:13:30,016
which automatically shares all


282
00:13:30,016 --> 00:13:31,616
of your journal entries
to Twitter.


283
00:13:32,246 --> 00:13:36,216
So we gave you a character count
in order to help you make sure


284
00:13:36,436 --> 00:13:38,626
that it's actually going to
fit when you post to Twitter.


285
00:13:38,946 --> 00:13:39,446
Simple enough.


286
00:13:39,996 --> 00:13:41,246
It goes up as we delete,


287
00:13:41,666 --> 00:13:44,656
and it goes down as
we add new characters.


288
00:13:44,656 --> 00:13:45,656
And that's all fine.


289
00:13:46,006 --> 00:13:51,626
But if we think about this
photo's feature that we have,


290
00:13:53,036 --> 00:13:57,076
you know, when we post to
Twitter, we're going to have


291
00:13:57,076 --> 00:14:00,176
to put a URL for that photo
in the body of the tweet.


292
00:14:00,176 --> 00:14:03,496
So that needs to be included
in the character count.


293
00:14:04,486 --> 00:14:08,036
And we got a bug from users
saying that they tried


294
00:14:08,036 --> 00:14:12,816
to make a post and Twitter
rejected it even though the UI


295
00:14:12,816 --> 00:14:15,526
said it was OK.


296
00:14:15,776 --> 00:14:18,916
So, I added this photo,
you could see it's added


297
00:14:18,916 --> 00:14:21,426
to this entry, and we
can see that the number


298
00:14:21,426 --> 00:14:23,046
of remaining characters
is still 140.


299
00:14:23,686 --> 00:14:27,696
And if I start typing,
watch I'll enter one key,


300
00:14:27,696 --> 00:14:30,076
and we jump down to 118.


301
00:14:30,076 --> 00:14:34,076
It's like it immediately
reconsidered the URL.


302
00:14:34,076 --> 00:14:36,586
I'm sure you've all seen
this kind of bug quite a lot.


303
00:14:36,646 --> 00:14:37,636
Something is stale.


304
00:14:38,016 --> 00:14:40,666
Something that was supposed
to happen has not happened,


305
00:14:41,096 --> 00:14:42,216
and unfortunately, that kind


306
00:14:42,216 --> 00:14:44,116
of problem is really
difficult to debug.


307
00:14:44,116 --> 00:14:46,726
There's nowhere to break.


308
00:14:46,946 --> 00:14:48,676
So, we can look at
the code and say, "OK,


309
00:14:48,676 --> 00:14:49,766
what's supposed to happen?"


310
00:14:51,056 --> 00:14:54,656
There is an updateCharacterCount
method here


311
00:14:55,366 --> 00:14:56,366
and it's very simple.


312
00:14:56,366 --> 00:15:00,506
It just updates this character
count label with the result


313
00:15:00,536 --> 00:15:02,286
of our Twitter entry encoder.


314
00:15:02,286 --> 00:15:04,926
So there's 2 possible
problems here.


315
00:15:05,706 --> 00:15:07,246
Possible problem number 1 is:


316
00:15:07,446 --> 00:15:09,276
the Twitter entry
encoder is at fault.


317
00:15:09,656 --> 00:15:10,776
It's returning a wrong value.


318
00:15:12,026 --> 00:15:13,156
Possible problem number 2 is:


319
00:15:13,156 --> 00:15:15,746
this method is simply not being
called when we add a photo.


320
00:15:17,106 --> 00:15:20,846
So, we can look to invalidate
one of these hypotheses.


321
00:15:20,846 --> 00:15:22,556
We can look to sort of guide


322
00:15:22,986 --> 00:15:26,336
to where we should be addressing
our debugging abilities.


323
00:15:26,336 --> 00:15:29,706
We can do that by just
adding a break point here


324
00:15:30,666 --> 00:15:34,926
and I will go ahead and create
a new journal entry here


325
00:15:34,926 --> 00:15:35,816
to set this up again.


326
00:15:36,396 --> 00:15:37,186
I'll add a photo.


327
00:15:37,186 --> 00:15:38,776
And we see


328
00:15:38,776 --> 00:15:40,416
that updateCharacterCount
is never called.


329
00:15:40,826 --> 00:15:43,316
But when I enter a key
here, it is called.


330
00:15:43,316 --> 00:15:46,066
So our problem appears to be


331
00:15:46,066 --> 00:15:48,666
that this method is just
not even getting called


332
00:15:48,666 --> 00:15:50,806
when it should be
called, and let's continue


333
00:15:50,806 --> 00:15:54,076
to follow this rabbit
hole upwards, I guess,


334
00:15:54,076 --> 00:15:56,396
and see who calls
updateCharacterCount.


335
00:15:56,926 --> 00:16:02,716
Now it's only called in
one place and it's called


336
00:16:02,716 --> 00:16:04,296
on "textViewDidChange".


337
00:16:04,906 --> 00:16:12,456
Now kind of an esoteric
factoid about the UIKit


338
00:16:12,456 --> 00:16:15,866
and at AppKit APIs is that
if you programatically set a


339
00:16:15,936 --> 00:16:20,526
textViews value, the textView
does not emit delegate callbacks


340
00:16:21,116 --> 00:16:22,736
saying that the textViews
value changed.


341
00:16:22,946 --> 00:16:25,826
And then the same thing is true
for basically anything else


342
00:16:25,876 --> 00:16:27,136
that has a delegate callback.


343
00:16:27,136 --> 00:16:29,916
If you programatically set the
value that is corresponding


344
00:16:29,916 --> 00:16:33,016
to that callback, UIKit/AppKit
will not call you back.


345
00:16:33,016 --> 00:16:36,596
So, you could react to
this by saying, oh geez,


346
00:16:37,186 --> 00:16:39,846
got to work around this
weird UIKit behavior.


347
00:16:40,276 --> 00:16:43,606
I guess we'll add an extra
call to updateCharacterCount


348
00:16:44,206 --> 00:16:47,696
when we add a photo
which happens down here,


349
00:16:47,696 --> 00:16:48,526
somewhere, right here.


350
00:16:49,046 --> 00:16:52,726
You know, we could-- we can call
updateCharacterCount there but,


351
00:16:53,026 --> 00:16:56,506
you know, what if we added
an audio recording feature.


352
00:16:56,596 --> 00:16:58,996
You know, take a voice note
about how your day is going.


353
00:16:58,996 --> 00:17:00,476
What if we added a
video recording feature?


354
00:17:00,476 --> 00:17:01,976
All of these things are
going to have to remember


355
00:17:01,976 --> 00:17:06,156
to update the character
count, and, I hope anyway


356
00:17:06,156 --> 00:17:08,695
that you're starting to
get that sort of taste


357
00:17:08,695 --> 00:17:11,026
versus ability smell again.


358
00:17:11,326 --> 00:17:12,786
Something seems amiss here,


359
00:17:13,346 --> 00:17:17,336
and it's not exactly
clear what it is.


360
00:17:18,925 --> 00:17:22,646
So again, I propose that
the solution is thinking


361
00:17:22,646 --> 00:17:25,336
about the information flow


362
00:17:25,336 --> 00:17:26,965
of your application
diagrammatically.


363
00:17:28,185 --> 00:17:30,996
Here again is a diagram


364
00:17:30,996 --> 00:17:32,576
of the information flow
in the application.


365
00:17:33,836 --> 00:17:35,196
There's a text view and
there's a character count.


366
00:17:36,466 --> 00:17:39,386
Both of these things are getting
their values from the model.


367
00:17:39,386 --> 00:17:41,726
So that seems OK.


368
00:17:42,886 --> 00:17:45,226
We've got truth, the
model is holding the truth


369
00:17:46,336 --> 00:17:50,736
and we're using the right
inputs in our information flow,


370
00:17:50,736 --> 00:17:53,106
but we're still not
getting the right behavior.


371
00:17:54,586 --> 00:17:58,026
The reason for that is
that derived values have


372
00:17:58,066 --> 00:17:59,186
to be treated differently.


373
00:17:59,746 --> 00:18:05,186
Let's think about what these
derived values are in comparison


374
00:18:05,546 --> 00:18:07,946
to the truth which
provides their inputs.


375
00:18:09,106 --> 00:18:10,356
Now, if you have
a derived value,


376
00:18:10,356 --> 00:18:12,216
it does a couple of things.


377
00:18:12,216 --> 00:18:14,906
It computes some other
value like a character count


378
00:18:15,156 --> 00:18:16,576
from some set of inputs.


379
00:18:17,896 --> 00:18:20,036
That's straightforward; we saw
that in updateCharacterCount.


380
00:18:21,306 --> 00:18:26,466
Separately, it needs to
recompute that output when one


381
00:18:26,466 --> 00:18:28,026
of the inputs changes.


382
00:18:29,296 --> 00:18:33,216
These requirements are really
very much like a cache.


383
00:18:33,756 --> 00:18:37,496
And I propose to you that
everywhere in your program


384
00:18:37,496 --> 00:18:40,246
where you have something
like a character count,


385
00:18:40,436 --> 00:18:42,336
which seems like a very
straightforward thing,


386
00:18:42,336 --> 00:18:45,356
it's just a value derived
from another value.


387
00:18:45,576 --> 00:18:50,456
All of those things have many of
the same properties of a cache,


388
00:18:51,016 --> 00:18:54,146
which means that they're
subject to the same problems


389
00:18:54,206 --> 00:18:55,406
that a cache has as well.


390
00:18:56,176 --> 00:18:58,986
For instance, when your
original data changes,


391
00:18:58,986 --> 00:19:00,786
you need to make sure
to update the cash data


392
00:19:00,786 --> 00:19:03,366
or else you are going
to have staleness bugs.


393
00:19:04,596 --> 00:19:08,176
And on the flip side, if the
original data hasn't changed,


394
00:19:09,106 --> 00:19:10,246
then you shouldn't be going


395
00:19:10,246 --> 00:19:13,016
about generating new
cache representations


396
00:19:13,016 --> 00:19:14,666
of that information
either, or else you're going


397
00:19:14,666 --> 00:19:15,706
to have efficiency problems.


398
00:19:17,146 --> 00:19:21,676
Now our problem here is
staleness, and you can see


399
00:19:21,676 --> 00:19:27,846
that the same issues apply for
truth versus derived values


400
00:19:28,146 --> 00:19:32,626
as they do for caches and the
values which are being cached.


401
00:19:32,626 --> 00:19:36,776
So let's focus on the
staleness issue here and try


402
00:19:36,776 --> 00:19:39,166
to understand what's going
on with our application.


403
00:19:39,166 --> 00:19:39,986
How do we get here?


404
00:19:40,106 --> 00:19:40,986
Where did we go wrong?


405
00:19:41,916 --> 00:19:43,876
And how do we model it with
these information diagrams?


406
00:19:43,906 --> 00:19:46,976
So, returning to this diagram,


407
00:19:48,046 --> 00:19:52,116
we see that the model's value
defines the text view value.


408
00:19:53,406 --> 00:19:56,096
I guess I didn't show it to you,
but take me on my word on that,


409
00:19:56,156 --> 00:19:57,236
you know, the model's
value changes


410
00:19:57,236 --> 00:19:58,336
and we set the text view values.


411
00:19:58,336 --> 00:19:59,216
It's very straight forward.


412
00:19:59,216 --> 00:20:00,976
We haven't seen any bugs with
that, at least not yet anyway.


413
00:20:01,126 --> 00:20:03,496
So let's go ahead and assume
that this is how it works ,


414
00:20:03,526 --> 00:20:07,116
nd when the model is changed,
the text view is invalidated.


415
00:20:07,116 --> 00:20:08,326
So, all of that is fine.


416
00:20:08,606 --> 00:20:10,616
The problem that we're having
is with the character count.


417
00:20:11,516 --> 00:20:13,506
We've seen the definition
of updateCharacterCount.


418
00:20:13,506 --> 00:20:16,716
We know that the character
count is deriving its value


419
00:20:16,716 --> 00:20:17,426
from the model.


420
00:20:18,026 --> 00:20:21,596
But when the model changes,


421
00:20:21,596 --> 00:20:23,076
the character count
is not invalidated.


422
00:20:23,616 --> 00:20:26,396
Rather it's when the
text view changes,


423
00:20:27,236 --> 00:20:29,156
the character count
is being invalidated.


424
00:20:29,686 --> 00:20:33,306
And the lopsidedness of this
diagram should hopefully


425
00:20:33,306 --> 00:20:34,316
indicate something to you.


426
00:20:34,316 --> 00:20:37,216
You know, each of these arrows
is basically doing half a job.


427
00:20:37,426 --> 00:20:39,496
You're splitting up
these responsibilities


428
00:20:39,806 --> 00:20:40,656
in 2 different places,


429
00:20:41,606 --> 00:20:43,376
and that's really
the cause of our bug.


430
00:20:43,376 --> 00:20:46,676
We can solve our bug by merging
those responsibilities back


431
00:20:46,676 --> 00:20:47,216
to one place.


432
00:20:47,516 --> 00:20:48,966
We can solve the
staleness problem by saying,


433
00:20:48,966 --> 00:20:50,746
"OK whenever the model
changes, we need to make sure


434
00:20:50,746 --> 00:20:54,276
to update all the values which
are derived from that model."


435
00:20:55,716 --> 00:20:57,326
It's really easy
to do this in Swift


436
00:20:57,326 --> 00:21:00,336
because we've got these
fancy new property observers.


437
00:21:01,576 --> 00:21:03,176
All we have to do is add


438
00:21:03,176 --> 00:21:05,286
that updateCharacterCount
call to our didSet block.


439
00:21:06,166 --> 00:21:09,576
And in general, you're
going to be way better off


440
00:21:10,216 --> 00:21:12,356
if you always keep those
arrows merged together;


441
00:21:12,906 --> 00:21:14,936
unless there's a very
pressing reason not to.


442
00:21:16,316 --> 00:21:19,296
So, that's just one more tool
in your tool bag for thinking


443
00:21:19,296 --> 00:21:22,036
about the complexity
in your application.


444
00:21:22,436 --> 00:21:24,606
Actually draw out these
information flows.


445
00:21:25,176 --> 00:21:26,036
What are the boxes?


446
00:21:26,266 --> 00:21:27,046
What are the arrows?


447
00:21:27,486 --> 00:21:30,966
Do each of those arrows
actually mean both definition


448
00:21:31,076 --> 00:21:32,146
and invalidation?


449
00:21:32,666 --> 00:21:33,816
Because they need to.


450
00:21:34,246 --> 00:21:35,506
Or else you might have
staleness problems.


451
00:21:36,246 --> 00:21:41,066
Now, finally, I'd like to turn
your attention to the text view.


452
00:21:42,466 --> 00:21:45,326
Now we said, OK, the text
view is getting its value


453
00:21:45,606 --> 00:21:48,556
from the model, and that
part appears to work.


454
00:21:48,556 --> 00:21:51,046
But we know that when the
user types into the text view,


455
00:21:51,046 --> 00:21:52,386
that model must be
getting updated.


456
00:21:52,716 --> 00:21:54,716
After all, I can make
a new journal entry


457
00:21:55,216 --> 00:21:58,516
and it appears to get saved.


458
00:21:58,706 --> 00:22:01,506
So there must be some reverse
relationship here, too.


459
00:22:02,086 --> 00:22:05,296
How do we think about that
schematically in the same way?


460
00:22:05,296 --> 00:22:08,206
And in particular, this looks


461
00:22:08,206 --> 00:22:11,716
like an infinite
loop, but it's not.


462
00:22:13,016 --> 00:22:14,086
We don't have a stack overflow.


463
00:22:14,386 --> 00:22:16,766
So these arrows must be
asymmetric in some way.


464
00:22:17,346 --> 00:22:20,116
And I propose to
you that in thinking


465
00:22:20,116 --> 00:22:22,716
about how new truth is created,


466
00:22:23,506 --> 00:22:26,406
you need to carefully
consider the asymmetry


467
00:22:26,766 --> 00:22:29,036
of those relationships
in your application.


468
00:22:29,116 --> 00:22:29,666
All right.


469
00:22:30,276 --> 00:22:36,206
So let's return to our app and
talk about creating new truth.


470
00:22:36,396 --> 00:22:38,146
Now our application has
another feature I haven't told


471
00:22:38,146 --> 00:22:38,526
you about.


472
00:22:39,086 --> 00:22:42,226
That feature is that I can share
my journal with a loved one.


473
00:22:43,016 --> 00:22:45,256
I can let my fiancée see
all these entries I write.


474
00:22:45,896 --> 00:22:50,686
And that's a great feature,
but it's complicated somewhat


475
00:22:50,686 --> 00:22:52,306
by the fact that there's
this Edit button here.


476
00:22:53,976 --> 00:22:56,946
You know, if I were to
start editing this entry,


477
00:22:57,076 --> 00:22:59,126
and you see our character
count issue on display again,


478
00:22:59,766 --> 00:23:01,146
if I were to start
editing this entry--


479
00:23:01,146 --> 00:23:03,486
oh, you don't need this
break point anymore.


480
00:23:05,796 --> 00:23:11,446
Then, we don't expect for
my fiancée if she's staring


481
00:23:11,446 --> 00:23:15,106
at her phone to actually see
this edited journal entry,


482
00:23:15,146 --> 00:23:15,416
right.


483
00:23:15,416 --> 00:23:19,626
Because I could hit Cancel,
and I'd be throwing it out,


484
00:23:19,626 --> 00:23:21,496
presumably the old entry
would still be there.


485
00:23:22,766 --> 00:23:25,626
So, I said that we're
working with the model here,


486
00:23:25,626 --> 00:23:29,026
but we must not be
working with the model.


487
00:23:29,026 --> 00:23:32,186
We must be working
with some other model


488
00:23:32,576 --> 00:23:34,996
that has a relationship
to the first model.


489
00:23:35,436 --> 00:23:38,046
Because if there were
really one model,


490
00:23:38,546 --> 00:23:41,296
then there will be no real way
to implement this cancel button


491
00:23:41,296 --> 00:23:44,416
and she would be seeing those
changes as soon as I made them.


492
00:23:44,976 --> 00:23:51,236
I'm going to suggest that
thinking about the relationship


493
00:23:51,236 --> 00:23:55,696
between this editing UIs model
and the underlying model,


494
00:23:55,866 --> 00:24:00,086
which it is editing, is actually
the same as the relationship


495
00:24:00,506 --> 00:24:04,716
between the model underlying
the text view and the new values


496
00:24:04,716 --> 00:24:06,476
that the text view is
emitting to the model.


497
00:24:07,066 --> 00:24:10,226
But if we're going to think
about this effectively,


498
00:24:11,116 --> 00:24:15,676
we really need to be
able to think about it


499
00:24:15,776 --> 00:24:18,626
from a diagrammatic
perspective so that we can see


500
00:24:18,866 --> 00:24:20,876
where everything is
and how it's going.


501
00:24:21,176 --> 00:24:24,006
So, let's talk about
these arrows.


502
00:24:24,596 --> 00:24:26,586
Let's talk about what they mean.


503
00:24:27,766 --> 00:24:28,816
What's that asymmetry?


504
00:24:29,706 --> 00:24:32,346
We know if we start
with just a text view,


505
00:24:33,816 --> 00:24:36,046
that the text views value is
defined by the models value.


506
00:24:36,786 --> 00:24:38,296
We also know that if
we edit the text view,


507
00:24:38,296 --> 00:24:39,986
somehow that model value
is getting updated.


508
00:24:41,176 --> 00:24:45,966
But, the text view is
deferent to the model value.


509
00:24:46,816 --> 00:24:48,996
If the model value
were to change out from


510
00:24:48,996 --> 00:24:51,106
out of the text view, somebody
were to just set the body


511
00:24:51,106 --> 00:24:54,566
to something else, that text
view would probably just update


512
00:24:54,566 --> 00:24:57,496
immediately to that new
value and if some other piece


513
00:24:57,496 --> 00:25:01,496
of the program were wondering
what is the body value


514
00:25:01,646 --> 00:25:04,646
of this journal entry, they
wouldn't ask the text view,


515
00:25:05,046 --> 00:25:07,406
or at least we hope that they
wouldn't as we saw earlier.


516
00:25:07,746 --> 00:25:10,476
Instead, we hope, that
they would ask the model.


517
00:25:11,836 --> 00:25:16,106
The model is truth, and these
derived values are deferent


518
00:25:16,106 --> 00:25:16,766
to truth.


519
00:25:16,886 --> 00:25:19,346
These new values they
emit, as you edit,


520
00:25:20,206 --> 00:25:23,776
are like suggestions
flowing back up the graph


521
00:25:24,146 --> 00:25:26,716
to the model along
these dashed arrows.


522
00:25:26,956 --> 00:25:29,086
Truth: new pieces
of information.


523
00:25:29,086 --> 00:25:33,306
Fact: these things flow from
the model to the derived values


524
00:25:34,256 --> 00:25:37,126
and suggested new pieces
of information flow back


525
00:25:37,126 --> 00:25:38,156
from the text view to the model;


526
00:25:38,436 --> 00:25:40,106
because of course there
could be validation.


527
00:25:40,656 --> 00:25:43,386
The behavior of our
application with respect


528
00:25:43,656 --> 00:25:45,866
to that 140-character
Twitter limit could be


529
00:25:45,866 --> 00:25:46,726
that we just truncate.


530
00:25:47,456 --> 00:25:49,176
So, it could be that that
suggested value is not


531
00:25:49,176 --> 00:25:50,946
applied exactly.


532
00:25:51,496 --> 00:25:54,626
In this way, this
relationship is asymmetrical,


533
00:25:55,716 --> 00:25:59,476
and we can use the same
structure of thinking to think


534
00:25:59,476 --> 00:26:03,476
about the "entry viewing
controller", which presented


535
00:26:03,476 --> 00:26:07,236
that editing controller, and
the "entry editing controller".


536
00:26:07,786 --> 00:26:10,256
There's some original model, and
that's what my fiancée is seeing


537
00:26:10,256 --> 00:26:11,076
if she looks at the app.


538
00:26:11,076 --> 00:26:14,406
And that's the one that's
going to still be there


539
00:26:14,506 --> 00:26:17,026
if we hit Cancel and
then there's the model


540
00:26:17,026 --> 00:26:21,146
that we're editing
which began from a copy


541
00:26:21,526 --> 00:26:22,436
of the original model.


542
00:26:23,296 --> 00:26:24,956
So in the same way as
these other relationships


543
00:26:24,956 --> 00:26:27,946
in our graph, the model that
we're editing is derived


544
00:26:27,946 --> 00:26:28,816
from the original model.


545
00:26:30,286 --> 00:26:32,486
And when we hit that
Done button,


546
00:26:33,056 --> 00:26:37,696
our editing controller
is suggesting a new value


547
00:26:37,696 --> 00:26:39,746
for the model to the
viewing controller.


548
00:26:40,776 --> 00:26:43,606
That is how new truth
is created.


549
00:26:43,606 --> 00:26:48,986
I want you to imagine with me,
because it isn't on the slide,


550
00:26:49,436 --> 00:26:53,436
that there is a dashed arrow
coming from the model back


551
00:26:53,436 --> 00:26:56,396
up to the original model;
that is how you can think


552
00:26:56,396 --> 00:26:57,386
about this relationship.


553
00:26:58,256 --> 00:27:01,706
Just as the model may
validate the text views value


554
00:27:01,706 --> 00:27:03,556
as it's coming out
of the text view,


555
00:27:03,756 --> 00:27:07,996
the original entry view
controller may be validating the


556
00:27:08,036 --> 00:27:08,896
edited entry.


557
00:27:09,846 --> 00:27:10,996
For instance, if she were able


558
00:27:10,996 --> 00:27:12,646
to edit those journal
entries also,


559
00:27:12,726 --> 00:27:13,826
there could be a conflict now.


560
00:27:14,066 --> 00:27:16,256
And so when the new
model value is suggested,


561
00:27:16,596 --> 00:27:19,606
some UI might be presented to
allow that merge to happen.


562
00:27:20,286 --> 00:27:24,396
In the same way, the editing
controller, its value is derived


563
00:27:24,396 --> 00:27:25,486
from the viewing controller


564
00:27:25,846 --> 00:27:27,586
and the new value
is only a suggestion


565
00:27:28,286 --> 00:27:29,236
to the viewing controller.


566
00:27:29,806 --> 00:27:34,216
So, we've worked through how
these techniques can help us


567
00:27:34,216 --> 00:27:36,166
solve several real world
application problems


568
00:27:37,086 --> 00:27:39,906
and hopefully they
suggest to you ways


569
00:27:39,906 --> 00:27:41,946
that you can solve the
kinds of problems you face


570
00:27:41,946 --> 00:27:42,786
in your app every day.


571
00:27:43,056 --> 00:27:45,236
You just have to actually
think about how information


572
00:27:45,236 --> 00:27:46,856
and events are flowing
through your application.


573
00:27:47,426 --> 00:27:48,776
First, where is truth?


574
00:27:48,776 --> 00:27:51,206
Who really knows?


575
00:27:51,276 --> 00:27:54,596
Who is really responsible
for those fundamental pieces


576
00:27:54,596 --> 00:27:57,726
of state, information and
events in your application?


577
00:27:58,586 --> 00:28:00,466
And then once you start
thinking about how they flow


578
00:28:00,466 --> 00:28:03,466
through your application,
remember the difference


579
00:28:03,466 --> 00:28:06,276
between truth and the
values derived from truth.


580
00:28:07,566 --> 00:28:09,576
Remember that values derived
from truth are in many ways


581
00:28:09,576 --> 00:28:12,786
like a cache and needed
to be treated as such.


582
00:28:13,716 --> 00:28:16,266
And finally, remember that
when new truth is created,


583
00:28:17,576 --> 00:28:20,696
that relationship is
asymmetrical by necessity


584
00:28:20,786 --> 00:28:22,526
in order to avoid some
kind of infinite loop.


585
00:28:23,466 --> 00:28:25,906
One direction -- facts flow.


586
00:28:25,906 --> 00:28:29,556
And then the other direction
-- suggested new values flow,


587
00:28:29,746 --> 00:28:31,636
which may need to be merged
or validated in some way.


588
00:28:31,636 --> 00:28:34,576
And by thinking systematically
about the information flow


589
00:28:34,576 --> 00:28:36,806
in your application, you
can really get a handle


590
00:28:37,016 --> 00:28:37,746
on complexity.


591
00:28:37,746 --> 00:28:38,366
All right.


592
00:28:39,736 --> 00:28:42,106
So, now let's move on.


593
00:28:43,496 --> 00:28:45,856
I'm going to invite
Colin Barrett up to talk


594
00:28:45,856 --> 00:28:48,066
about defining clear
responsibilities


595
00:28:48,066 --> 00:28:48,826
for your application.


596
00:28:49,516 --> 00:28:55,616
[ Applause ]


597
00:28:56,116 --> 00:28:56,976
>> Thank you, Andy.


598
00:28:57,386 --> 00:28:58,356
Good afternoon, everybody.


599
00:28:59,256 --> 00:29:03,946
In this next section, I'm going
to show you how to identify


600
00:29:04,826 --> 00:29:08,646
and tease apart responsibilities
in your application.


601
00:29:09,386 --> 00:29:14,746
Let's start with an
example: form validation.


602
00:29:16,126 --> 00:29:18,486
We've all at least
used a form like this.


603
00:29:19,516 --> 00:29:21,166
Many of us have,
maybe, implemented one.


604
00:29:22,716 --> 00:29:26,096
You know, it's not as simple as
just putting some text fields


605
00:29:26,096 --> 00:29:27,796
on the screen and a button.


606
00:29:29,776 --> 00:29:32,556
There are rules about
what values are allowed


607
00:29:32,816 --> 00:29:35,586
in the different text
fields, the four we have here,


608
00:29:36,206 --> 00:29:38,906
and how the other
interface elements


609
00:29:39,496 --> 00:29:45,186
in this view are enabled and
disabled, or shown and hidden,


610
00:29:46,296 --> 00:29:49,666
depending on the values
of these text fields.


611
00:29:49,776 --> 00:29:55,826
So, let's say we're
implementing this view here.


612
00:29:56,806 --> 00:29:57,576
Where would we start?


613
00:29:58,256 --> 00:30:01,146
Well, we'll need to know


614
00:30:01,146 --> 00:30:03,026
when the user finishes
editing a text field.


615
00:30:04,066 --> 00:30:06,896
So, we'll implement
the text field "did


616
00:30:07,426 --> 00:30:11,136
and editing" delegate message
on our view controller.


617
00:30:12,546 --> 00:30:15,326
And in that delegate
message we're going to need


618
00:30:15,326 --> 00:30:18,776
to consider each text field
and if they're all valid,


619
00:30:19,466 --> 00:30:20,516
enable the sign-up button.


620
00:30:22,216 --> 00:30:27,566
But, we can't exactly consider
all of these fields uniformly.


621
00:30:28,336 --> 00:30:29,816
They all have different rules.


622
00:30:29,816 --> 00:30:33,766
Let's look at the rules
for the username field.


623
00:30:33,766 --> 00:30:39,306
We have this regular expression
that our server engineers gave


624
00:30:39,306 --> 00:30:41,586
to us and we have to match
that against the contents


625
00:30:41,586 --> 00:30:42,676
of the username text field.


626
00:30:43,256 --> 00:30:46,036
If we don't have any--
If it doesn't match,


627
00:30:46,796 --> 00:30:48,376
we're going to need to
show the users somehow


628
00:30:48,376 --> 00:30:51,106
that they've messed up
and then you go back


629
00:30:51,106 --> 00:30:53,926
and correct the mistake.


630
00:30:54,066 --> 00:30:56,996
Now, there's one other
complication here and that's


631
00:30:56,996 --> 00:30:58,606
if our text fields are empty.


632
00:31:01,316 --> 00:31:04,826
If our text field is empty
when we're checking each field,


633
00:31:06,256 --> 00:31:07,466
we're going to want
to leave it alone.


634
00:31:07,986 --> 00:31:13,516
But when we're considering the
state of the sign-up button,


635
00:31:13,676 --> 00:31:17,976
we're going to want to leave
the sign-up button disabled.


636
00:31:18,586 --> 00:31:21,946
So, we're going to want
to leave it disabled


637
00:31:21,946 --> 00:31:23,986
because we don't want
the user to proceed


638
00:31:23,986 --> 00:31:27,016
with a partially
filled out form.


639
00:31:27,176 --> 00:31:30,106
So, let's go back to this
username part and see what


640
00:31:30,106 --> 00:31:31,656
that would look like in code.


641
00:31:31,656 --> 00:31:36,466
So, yes, this is a lot of code,


642
00:31:36,566 --> 00:31:40,206
but it's all different
sorts of things.


643
00:31:40,206 --> 00:31:41,796
It's intermingled.


644
00:31:41,796 --> 00:31:46,096
We have local variables to track
the state of the text fields


645
00:31:46,096 --> 00:31:47,686
and of empty text fields.


646
00:31:48,626 --> 00:31:51,536
We have a bunch of regular
expression code right next


647
00:31:51,536 --> 00:31:56,466
to that, and in between all of
that, we have these 2 lines,


648
00:31:57,126 --> 00:31:58,956
which are really
the most important


649
00:31:59,366 --> 00:32:02,326
for what the view controller
does, which is to manage


650
00:32:02,756 --> 00:32:05,216
and configure its
constituent views.


651
00:32:07,256 --> 00:32:10,056
So, much like we can
diagram information flow


652
00:32:10,056 --> 00:32:15,246
in our application, we can
also diagram responsibilities.


653
00:32:15,776 --> 00:32:16,546
Who does what?


654
00:32:17,856 --> 00:32:20,856
Here is the diagram that we've
been thinking about so far.


655
00:32:20,856 --> 00:32:24,016
We have our view
controller, which manages


656
00:32:24,016 --> 00:32:27,456
and configures its constituent
views, and we have our views,


657
00:32:28,266 --> 00:32:30,026
which display the
data they're given


658
00:32:30,526 --> 00:32:33,216
with core animation
and core graphics.


659
00:32:33,956 --> 00:32:38,156
But we've identified a third
overlapping responsibility:


660
00:32:38,766 --> 00:32:39,436
validation.


661
00:32:40,956 --> 00:32:46,216
This may not seem so bad, but if
we add another view controller


662
00:32:46,216 --> 00:32:49,926
that also has to do similar
validation, they don't have


663
00:32:49,926 --> 00:32:51,256
that same logic in two places.


664
00:32:51,626 --> 00:32:55,556
A bug in one has to
be fixed in the other.


665
00:32:55,786 --> 00:32:58,066
And since these are
in different places,


666
00:32:58,266 --> 00:33:00,456
it's likely that they'll
diverge over time.


667
00:33:00,926 --> 00:33:04,476
A type of rule get added in
one place but not the other


668
00:33:04,476 --> 00:33:05,656
because it's not
necessary there,


669
00:33:06,086 --> 00:33:08,266
making it even more
difficult to change


670
00:33:08,796 --> 00:33:13,686
and fix these common
issues over time.


671
00:33:13,946 --> 00:33:18,466
So, what we want to do is
separate that responsibility


672
00:33:18,466 --> 00:33:22,726
out into one place that can be
shared by both view controllers.


673
00:33:27,096 --> 00:33:29,856
So, to do that, we first need


674
00:33:29,856 --> 00:33:33,766
to identify what
validation actually is.


675
00:33:34,806 --> 00:33:36,606
When thinking about
these types of questions,


676
00:33:37,456 --> 00:33:40,786
it's useful to think of
the inputs and outputs.


677
00:33:41,686 --> 00:33:45,816
Or, to put in another way,
what information do I need


678
00:33:45,816 --> 00:33:48,446
and what questions am
I trying to answer?


679
00:33:49,266 --> 00:33:53,436
So, as I build through this
common sense explanation


680
00:33:53,436 --> 00:33:56,446
of what validation is, I'm
going to fill in the inputs


681
00:33:56,616 --> 00:33:59,456
and outputs in this table.


682
00:33:59,616 --> 00:34:05,306
So, validation seems to be that
if you give me an input value,


683
00:34:06,626 --> 00:34:07,836
I can tell you if it's valid.


684
00:34:08,866 --> 00:34:10,866
And if it's not valid,
I can tell you why.


685
00:34:11,576 --> 00:34:15,235
These pretty directly translate
to fairly simple data types.


686
00:34:16,585 --> 00:34:19,826
And if we look at what that
looks like here in Swift --


687
00:34:21,916 --> 00:34:23,376
forgive the syntax
error there --


688
00:34:23,856 --> 00:34:26,666
we have our output
types right here


689
00:34:26,666 --> 00:34:28,446
but we're missing our input.


690
00:34:29,726 --> 00:34:32,315
That's because we want to
leave this actually open


691
00:34:32,315 --> 00:34:33,966
to interpretation in this case.


692
00:34:34,656 --> 00:34:37,126
Because a good technique
for dealing


693
00:34:37,126 --> 00:34:40,146
with complicated
responsibilities is to be able


694
00:34:40,146 --> 00:34:43,646
to build larger units
out of smaller ones.


695
00:34:43,916 --> 00:34:45,956
So, in this case, we'll
build larger validators


696
00:34:46,966 --> 00:34:47,926
out of smaller ones.


697
00:34:48,786 --> 00:34:52,576
So for those larger validators,
the input will be implicit


698
00:34:53,626 --> 00:34:56,216
in the constituent
validator's input.


699
00:34:57,186 --> 00:34:59,126
This technique is
called composition.


700
00:34:59,496 --> 00:35:02,666
We're composing a larger
validator out of smaller ones


701
00:35:03,666 --> 00:35:06,196
and it works totally
fine in Objective-C, too.


702
00:35:06,756 --> 00:35:08,616
I also really like Swift.


703
00:35:10,016 --> 00:35:14,086
So, let's look at what
a username object,


704
00:35:14,256 --> 00:35:15,736
username validator object,


705
00:35:15,806 --> 00:35:18,216
that implements this validation
protocol would look like.


706
00:35:19,426 --> 00:35:21,726
Well, we have our input
here, it's a String,


707
00:35:22,426 --> 00:35:28,156
and this validateWitherror
function is where we're going


708
00:35:28,156 --> 00:35:30,436
to have our regular
expression code.


709
00:35:30,676 --> 00:35:32,076
It's now isolated.


710
00:35:32,496 --> 00:35:34,936
It's not intermingled with
all of these other code.


711
00:35:35,556 --> 00:35:40,296
We can do likewise for
password validation.


712
00:35:41,756 --> 00:35:46,536
But, maybe wondering that this
only represents the validity


713
00:35:46,536 --> 00:35:49,716
of a single password
field, then that's correct.


714
00:35:49,876 --> 00:35:53,516
We need to represent that two
password fields match in value,


715
00:35:53,886 --> 00:35:55,876
in addition to not
being too short,


716
00:35:55,976 --> 00:35:58,366
not being high MoM,
things like that.


717
00:35:59,186 --> 00:36:01,926
So, we'll create a
SetPasswordValidator


718
00:36:02,076 --> 00:36:04,136
that has two password
validators.


719
00:36:04,396 --> 00:36:05,696
This is composition in action.


720
00:36:06,396 --> 00:36:07,316
It's going to represent,


721
00:36:08,186 --> 00:36:11,176
in addition so that the password
fields individually are valid,


722
00:36:12,016 --> 00:36:13,616
that they're also
matching in value.


723
00:36:14,856 --> 00:36:17,326
We can also apply this
composition technique


724
00:36:17,746 --> 00:36:18,786
to our overall form.


725
00:36:19,356 --> 00:36:23,856
We have our usernameValidator,
setPasswordValidator


726
00:36:24,266 --> 00:36:25,596
and emailAddressValidator.


727
00:36:29,656 --> 00:36:32,186
This is also where we'll
handle the behavior of nil,


728
00:36:32,186 --> 00:36:33,086
we talked about earlier.


729
00:36:33,736 --> 00:36:38,706
The constituent validators
will allow nil,


730
00:36:38,956 --> 00:36:41,156
because we don't want the
individual text fields


731
00:36:41,156 --> 00:36:43,506
to show any sort of error
state when they're empty.


732
00:36:43,686 --> 00:36:44,736
That would be just confusing.


733
00:36:46,126 --> 00:36:49,386
But, this SignUpValidator
will check


734
00:36:49,636 --> 00:36:53,156
that its constituent
validators have non-nil input.


735
00:36:54,036 --> 00:36:57,876
And if any of those inputs are
nil, it'll say it's not valid,


736
00:36:58,136 --> 00:37:00,486
allowing us to easily
disable sign-up button.


737
00:37:01,576 --> 00:37:03,786
So, let's return to that
workflow we were looking


738
00:37:03,786 --> 00:37:08,326
at earlier and see
what that looks like.


739
00:37:08,596 --> 00:37:11,466
Now, we're able to consider
each text field uniformly


740
00:37:12,036 --> 00:37:14,166
because all we do
is set the input


741
00:37:14,166 --> 00:37:15,566
on the corresponding validator.


742
00:37:16,256 --> 00:37:18,866
We're also able to decorate all


743
00:37:18,866 --> 00:37:20,376
of the text fields
uniformly as well.


744
00:37:20,846 --> 00:37:23,166
The logic and that
responsibility has been


745
00:37:23,166 --> 00:37:23,836
moved elsewhere.


746
00:37:24,206 --> 00:37:27,286
We're only talking to
an abstract interface.


747
00:37:28,376 --> 00:37:30,706
So, let's define clear
responsibilities.


748
00:37:31,566 --> 00:37:35,316
We've separated out the
responsibility of validation


749
00:37:35,466 --> 00:37:38,516
from the rest of our program.


750
00:37:38,606 --> 00:37:41,986
We've used composition to build


751
00:37:41,986 --> 00:37:44,626
up larger pieces
from smaller ones.


752
00:37:45,076 --> 00:37:47,276
Let's move on now to
our third section,


753
00:37:48,266 --> 00:37:49,516
simplifying with immutability.


754
00:37:51,676 --> 00:37:54,496
You may have heard on the
internet that mutability is


755
00:37:54,496 --> 00:37:57,566
"bad", and you should
feel bad for using it.


756
00:37:58,116 --> 00:38:01,176
But nobody's really
told you why.


757
00:38:02,416 --> 00:38:03,286
Why is it bad?


758
00:38:03,286 --> 00:38:06,016
I mean, it's easy to use,
you just set it, right.


759
00:38:06,016 --> 00:38:08,716
We're working in an imperative
oriented languages here.


760
00:38:08,716 --> 00:38:09,576
We have statements.


761
00:38:11,466 --> 00:38:14,506
So, to illustrate that, let's
look at another diagram.


762
00:38:15,006 --> 00:38:21,656
In this diagram, the red box
represents immutable object,


763
00:38:21,836 --> 00:38:23,876
which has the value of five,


764
00:38:24,646 --> 00:38:28,376
and these circles here
represent other objects


765
00:38:28,376 --> 00:38:30,266
that are passing this
mutable data around.


766
00:38:31,286 --> 00:38:34,686
So, when A passes this
mutable object to B,


767
00:38:35,176 --> 00:38:39,366
B probably doesn't want


768
00:38:39,366 --> 00:38:40,926
that object changing
out from under it.


769
00:38:41,886 --> 00:38:45,526
So, how do we ensure
that that happens?


770
00:38:45,526 --> 00:38:50,256
Well, A still has a
reference to this object.


771
00:38:50,306 --> 00:38:56,626
So, B depends on-oh, sorry, if--
yes, exactly, if A changes it,


772
00:38:56,626 --> 00:38:57,936
then B sees that change.


773
00:38:58,506 --> 00:39:02,126
So, B depends on A
behaving in a specific way.


774
00:39:02,606 --> 00:39:04,326
They're linked in this sort


775
00:39:04,656 --> 00:39:07,636
of responsibility
and dependency graph.


776
00:39:07,936 --> 00:39:11,766
Now, likewise if this
object now gets passed to C,


777
00:39:12,676 --> 00:39:15,096
these other objects could
still have references to it.


778
00:39:15,096 --> 00:39:16,076
They could still change it.


779
00:39:17,276 --> 00:39:19,516
So, C may depend on A and B.


780
00:39:20,066 --> 00:39:25,346
But it actually gets a little
bit worse than that, because A


781
00:39:25,346 --> 00:39:28,016
or B could be waiting for C
to make some sort of change.


782
00:39:28,346 --> 00:39:32,146
Maybe A has registered
for KVO observation.


783
00:39:32,666 --> 00:39:35,316
Maybe B is the delegate of
this object and is waiting


784
00:39:35,316 --> 00:39:36,626
for some sort of
callback to happen.


785
00:39:37,156 --> 00:39:39,086
The specific timing
of that could be part


786
00:39:39,086 --> 00:39:40,566
of B's implementation.


787
00:39:41,266 --> 00:39:45,536
If C changes when it calls some
setter, that could screw up B.


788
00:39:46,496 --> 00:39:49,946
So, we're seeing here
how mutability ties all


789
00:39:49,946 --> 00:39:50,996
of these things together.


790
00:39:51,616 --> 00:39:54,916
It's one of the biggest
reasons why you feel that drag


791
00:39:55,286 --> 00:39:57,866
that Andy was talking about as
your application grows bigger.


792
00:39:58,756 --> 00:40:02,636
And it also explains why adding
abstraction often doesn't help.


793
00:40:03,256 --> 00:40:05,936
As long as you're passing
around the same mutable data,


794
00:40:06,396 --> 00:40:08,436
it doesn't matter how
many layers you have.


795
00:40:08,966 --> 00:40:12,576
You're in fact just
lashing more mutable layers


796
00:40:12,576 --> 00:40:14,346
onto this big ball.


797
00:40:15,116 --> 00:40:17,876
So, let's look at
what would happen


798
00:40:17,876 --> 00:40:19,416
if this object was
immutable instead.


799
00:40:20,706 --> 00:40:21,946
We couldn't change its value.


800
00:40:23,106 --> 00:40:28,036
When A passes it to B, well,
A still has a reference to it,


801
00:40:28,036 --> 00:40:30,306
but it can't change it.


802
00:40:30,436 --> 00:40:31,286
No one can change it.


803
00:40:31,456 --> 00:40:32,436
It can never change.


804
00:40:32,946 --> 00:40:35,756
If B does need to make a
change, it has to make a copy


805
00:40:36,726 --> 00:40:38,056
and pass that copy to C.


806
00:40:38,056 --> 00:40:41,066
There are no arrows here;
there's no dependencies.


807
00:40:41,396 --> 00:40:47,146
Everything has the data that
they have and that's it.


808
00:40:47,376 --> 00:40:50,546
So, there is a tradeoff
here though, right?


809
00:40:51,176 --> 00:40:54,796
Mutability is easier
to think about locally.


810
00:40:55,936 --> 00:40:58,366
Think about building up
a string or an array.


811
00:40:59,726 --> 00:41:02,226
It's also wasteful to
create intermediate copies


812
00:41:02,806 --> 00:41:05,366
when no else is mutating our--


813
00:41:05,366 --> 00:41:08,316
when no one else can
see those mutations yet.


814
00:41:08,966 --> 00:41:10,296
You may be wondering
is there a better way?


815
00:41:11,816 --> 00:41:14,096
Happy to say this, Swift
Structs are that better way.


816
00:41:14,446 --> 00:41:18,546
They have opt-in mutability
via the mutating keyword.


817
00:41:19,606 --> 00:41:23,066
This lets you choose whether
or not a struct is mutable


818
00:41:23,066 --> 00:41:26,056
or immutable, based on
using the let or our keyword


819
00:41:26,056 --> 00:41:29,716
to introduce the binding to
the name when you declare it.


820
00:41:29,816 --> 00:41:34,736
So, Swift Structs also have the
property that they are called


821
00:41:34,736 --> 00:41:36,176
by value which just means


822
00:41:36,176 --> 00:41:39,376
that a new copy is automatically
created from you when you pass


823
00:41:39,376 --> 00:41:41,586
that struct from one
function to another.


824
00:41:42,206 --> 00:41:44,676
You don't pass a reference
or a pointer like you do


825
00:41:44,676 --> 00:41:48,016
with an Objective-C
or Swift object.


826
00:41:49,266 --> 00:41:51,306
So, let's go back to
that diagram and see what


827
00:41:51,306 --> 00:41:52,756
that would look like
one more time.


828
00:41:53,276 --> 00:41:57,916
Here we have our Swift
Struct, happy green box,


829
00:41:57,916 --> 00:42:03,506
and when we pass it from A to
B, an implicit copy is made


830
00:42:03,726 --> 00:42:05,066
and that's what's passed to B.


831
00:42:05,956 --> 00:42:07,426
B can happily mutate.


832
00:42:08,216 --> 00:42:12,456
A won't see those changes
and again when we pass it,


833
00:42:13,386 --> 00:42:15,696
another copy is made,
and C gets its own copy.


834
00:42:17,056 --> 00:42:20,026
So, that's one sort
of immutability,


835
00:42:20,336 --> 00:42:23,336
and that's how Swift
Structs can help us be--


836
00:42:23,976 --> 00:42:25,946
get a lot of the
benefits of immutability


837
00:42:26,736 --> 00:42:30,406
without sacrificing programming,
ease of programability.


838
00:42:31,036 --> 00:42:31,786
But there's another kind


839
00:42:31,786 --> 00:42:33,276
of immutability I
want to talk about.


840
00:42:33,836 --> 00:42:35,526
We can see that in
UIMotionEffect.


841
00:42:36,036 --> 00:42:37,496
You're not familiar
with UIMotionEffect?


842
00:42:38,756 --> 00:42:42,946
It simply adjusts properties on
views based on gyroscope data.


843
00:42:42,946 --> 00:42:47,226
We use this to achieve
the parallax effects


844
00:42:47,226 --> 00:42:51,646
on the Home screen and
elsewhere throughout the OS.


845
00:42:51,916 --> 00:42:54,256
MotionEffects are
reusable across many views.


846
00:42:54,256 --> 00:42:56,416
If you have one type of motion,


847
00:42:56,416 --> 00:42:58,866
you only have to
create one effect.


848
00:43:00,876 --> 00:43:03,696
MotionEffects also have very
low latency requirements.


849
00:43:03,726 --> 00:43:05,976
We don't want to get
behind the gyro data


850
00:43:06,746 --> 00:43:10,556
because that looks laggy and it
really ruins the magical effect


851
00:43:10,556 --> 00:43:14,236
of parallax on the Home
screen and other places.


852
00:43:15,636 --> 00:43:23,526
So, again, we're going to show
how this is also immutability.


853
00:43:23,746 --> 00:43:26,536
Once again by considering
the inputs and outputs


854
00:43:26,866 --> 00:43:30,216
of the MotionEffect process.


855
00:43:30,336 --> 00:43:32,946
MotionEffects take
a device pose,


856
00:43:33,096 --> 00:43:34,996
which is simply a description


857
00:43:35,106 --> 00:43:37,536
of the device's orientation
in space.


858
00:43:38,566 --> 00:43:42,066
In return, a relative
offset for each key path


859
00:43:42,556 --> 00:43:43,716
that we want to change.


860
00:43:44,276 --> 00:43:47,786
It may be somewhat surprising


861
00:43:47,786 --> 00:43:49,536
to describe a motion
effect as immutable.


862
00:43:49,536 --> 00:43:51,146
It doesn't really have a bunch


863
00:43:51,146 --> 00:43:53,846
of properties not
unless we're dealing


864
00:43:53,846 --> 00:43:55,246
UIInterpolatingMotionEffect.


865
00:43:56,036 --> 00:43:58,056
It feels more like a function.


866
00:43:59,066 --> 00:44:03,346
But immutability is actually a
deep idea, and has deep power.


867
00:44:04,906 --> 00:44:08,506
Because motion effects take
an absolute device pose


868
00:44:08,506 --> 00:44:09,986
and return relative offsets,


869
00:44:10,576 --> 00:44:12,896
they can always return
the same dictionary


870
00:44:13,426 --> 00:44:15,266
for the same input device pose.


871
00:44:16,456 --> 00:44:18,726
In much the same way that
if you don't have a setter,


872
00:44:18,786 --> 00:44:22,516
you'll always return the
same value for your getter.


873
00:44:22,686 --> 00:44:27,256
So, to really show that
this design is immutable,


874
00:44:27,606 --> 00:44:30,856
let's look at some alternative
designs for motion effects.


875
00:44:32,186 --> 00:44:33,196
Let's say that we thought


876
00:44:33,196 --> 00:44:37,306
that having delta inputs rather
then an actual absolute device


877
00:44:37,306 --> 00:44:40,696
pose was a better design.


878
00:44:40,846 --> 00:44:43,586
Well, we would still have
our device pose data,


879
00:44:43,586 --> 00:44:45,756
but it will be deltas and
we'd still be giving back


880
00:44:45,756 --> 00:44:46,786
relative offsets.


881
00:44:47,716 --> 00:44:51,096
But to calculate those offsets,
we would actually need to figure


882
00:44:51,096 --> 00:44:53,636
out what the current
orientation of the device was.


883
00:44:54,506 --> 00:44:57,316
So, we would depend
upon all previous poses


884
00:44:57,906 --> 00:45:01,726
as an implicit form of input.


885
00:45:01,856 --> 00:45:05,236
Now our inputs are not just
all-possible device poses


886
00:45:05,646 --> 00:45:08,996
but all possible sequences
of device pose deltas.


887
00:45:09,716 --> 00:45:11,376
That's a lot bigger input space.


888
00:45:11,706 --> 00:45:14,106
It's harder to test, it's
harder to reason about


889
00:45:15,066 --> 00:45:17,226
and it's also not immutable


890
00:45:17,296 --> 00:45:19,496
because as our application
changes over time,


891
00:45:19,876 --> 00:45:23,046
we're going to get
different answers.


892
00:45:23,046 --> 00:45:26,976
Likewise, if we had
absolute offsets rather


893
00:45:26,976 --> 00:45:31,656
than relative offsets, we would
have a value for each key path


894
00:45:31,656 --> 00:45:33,616
that we're returning
in absolute offset,


895
00:45:33,616 --> 00:45:35,776
we would be dependent
on a particular view.


896
00:45:35,776 --> 00:45:40,006
And that particular view would
make this MotionEffect not


897
00:45:40,006 --> 00:45:42,326
something that was reusable
across many different places,


898
00:45:42,586 --> 00:45:45,266
and again would make
it so that its value


899
00:45:45,796 --> 00:45:50,536
for a particular device
pose would change over time.


900
00:45:50,716 --> 00:45:53,856
So, that's simplifying
with immutability.


901
00:45:54,206 --> 00:45:56,906
We've seen two different
forms of immutability,


902
00:45:57,526 --> 00:46:01,456
and how we can leverage
those to build simpler,


903
00:46:01,456 --> 00:46:05,226
more easy to reason about,
portions of our application.


904
00:46:06,346 --> 00:46:08,536
Being able to reason
abstractly about pieces


905
00:46:08,536 --> 00:46:10,076
of your application is critical.


906
00:46:10,076 --> 00:46:13,326
If you have to know every
nook and cranny of the system


907
00:46:13,426 --> 00:46:16,506
and wonder if changing one thing
is going to cause something else


908
00:46:16,506 --> 00:46:19,586
to break, your app just
becomes this big spider web,


909
00:46:19,626 --> 00:46:21,136
that you can never
really escape from.


910
00:46:21,646 --> 00:46:25,956
We've talked about a lot today.


911
00:46:26,156 --> 00:46:30,086
So, let's just review everything
we've gone over right now.


912
00:46:30,716 --> 00:46:33,146
First, we talked about how


913
00:46:33,146 --> 00:46:35,306
to design information
flow in your application.


914
00:46:36,236 --> 00:46:39,626
We learned the difference
between truth and derived value,


915
00:46:39,626 --> 00:46:41,796
and how new truth is created.


916
00:46:42,356 --> 00:46:45,626
We saw how to define
clear responsibilities,


917
00:46:45,996 --> 00:46:48,656
how to tease apart
different portions of your app


918
00:46:48,656 --> 00:46:50,126
and how to isolate them.


919
00:46:50,616 --> 00:46:53,346
We also saw how to
use that isolation


920
00:46:53,606 --> 00:46:54,966
to build things with
composition.


921
00:46:56,536 --> 00:46:59,036
We also saw how to
simplify with immutability


922
00:46:59,406 --> 00:47:01,916
to increase our ability
to abstractly reason


923
00:47:02,286 --> 00:47:03,426
about our application.


924
00:47:04,626 --> 00:47:05,186
So, what now?


925
00:47:05,636 --> 00:47:08,876
You've heard this talk; maybe,
hopefully, you're all fired


926
00:47:08,876 --> 00:47:10,246
up about these concepts.


927
00:47:10,246 --> 00:47:15,936
Go back to your app; put
some of these in action.


928
00:47:16,186 --> 00:47:17,436
When you're designing a feature,


929
00:47:17,676 --> 00:47:19,086
think about the information
flow,


930
00:47:19,246 --> 00:47:20,656
think about the
responsibilities.


931
00:47:21,696 --> 00:47:23,526
Share this talk with
your coworkers.


932
00:47:24,576 --> 00:47:27,536
Tell them about a time in your
app, specifically your app,


933
00:47:27,746 --> 00:47:30,756
where there was a bug, where you
were maybe updating some sort


934
00:47:30,756 --> 00:47:33,266
of cache, that you didn't
really even realize was a cache


935
00:47:33,266 --> 00:47:33,976
until just now.


936
00:47:37,656 --> 00:47:39,016
That's all we've got today.


937
00:47:39,016 --> 00:47:42,076
For more information,
contact Jake Behrens.


938
00:47:42,956 --> 00:47:47,386
Bill gave a talk this
morning about some other types


939
00:47:47,386 --> 00:47:49,116
of design patterns
in our frameworks.


940
00:47:50,566 --> 00:47:51,386
Thank you for listening.


941
00:47:51,686 --> 00:47:52,476
Have a great afternoon.


942
00:47:53,516 --> 00:47:59,760
[ Applause ]

