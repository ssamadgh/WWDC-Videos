1
00:00:22,516 --> 00:00:29,546
[Applause]


2
00:00:30,046 --> 00:00:32,006
>> NIHAR SHARMA: Good
afternoon and welcome


3
00:00:32,006 --> 00:00:33,846
to the CloudKit tips
and tricks session.


4
00:00:34,656 --> 00:00:36,816
My name is Nihar Sharma
and I'm an engineer


5
00:00:36,816 --> 00:00:38,656
on the CloudKit team.


6
00:00:39,076 --> 00:00:41,956
I know some of you may be
completely new to our platform


7
00:00:42,226 --> 00:00:43,966
and encountering the
CloudKit framework


8
00:00:44,046 --> 00:00:47,526
for the first time while
others may already have an app


9
00:00:47,526 --> 00:00:48,086
on the Store.


10
00:00:48,616 --> 00:00:51,036
This session we will have
something for everyone.


11
00:00:51,456 --> 00:00:52,266
Let's jump right in.


12
00:00:53,006 --> 00:00:55,306
What is CloudKit?


13
00:00:56,406 --> 00:01:01,036
Last year we introduced CloudKit
as a whole new way for you


14
00:01:01,036 --> 00:01:03,986
to be able to talk to Apple's
iCloud database servers.


15
00:01:05,016 --> 00:01:08,636
With that we gave you a set
of built-in technologies


16
00:01:09,286 --> 00:01:10,516
like large file storage.


17
00:01:12,186 --> 00:01:15,286
We gave you a privacy
conscious identifier to be able


18
00:01:15,286 --> 00:01:18,196
to manage the users
who could now be anyone


19
00:01:18,196 --> 00:01:21,336
with an iCloud account.


20
00:01:21,336 --> 00:01:25,926
First and foremost, we made
this public facing developer API


21
00:01:26,246 --> 00:01:28,746
because we wanted you to be
able to leverage the power


22
00:01:28,746 --> 00:01:31,706
of this platform and build
great apps for your users.


23
00:01:32,176 --> 00:01:36,926
Last but not the least,
Apple's heavily invested


24
00:01:36,926 --> 00:01:37,766
in this technology.


25
00:01:38,146 --> 00:01:40,036
Last year alone when
we first shipped,


26
00:01:40,656 --> 00:01:41,566
we shipped with a couple


27
00:01:41,566 --> 00:01:43,906
of major clients
including iCloud drive


28
00:01:44,086 --> 00:01:48,096
and iCloud photo library,
and this year we added a host


29
00:01:48,096 --> 00:01:50,716
of new clients like the
Notes app, the news app


30
00:01:51,316 --> 00:01:54,456
and WWDC app a lot of you have
been using throughout the week


31
00:01:54,736 --> 00:01:58,176
and have in your
hands right now.


32
00:01:58,176 --> 00:02:01,666
If all of this sounds unfamiliar
to you, I invite you to go back


33
00:02:01,666 --> 00:02:03,766
and take a look at
the intro to CloudKit


34
00:02:03,916 --> 00:02:06,496
and Advanced CloudKit sessions
from last year's conference.


35
00:02:06,876 --> 00:02:09,346
They are a great resource for
an introduction to the new API,


36
00:02:09,346 --> 00:02:11,846
and I highly recommend
you check them out.


37
00:02:12,476 --> 00:02:13,956
First things first.


38
00:02:13,956 --> 00:02:16,206
A lot of you have been playing


39
00:02:16,246 --> 00:02:18,886
with the amazing new
features of Swift 2.


40
00:02:19,286 --> 00:02:22,396
I'm pleased to announce
with iOS 9, the experience


41
00:02:22,396 --> 00:02:25,456
of using CloudKit from
Swift is much better.


42
00:02:26,486 --> 00:02:28,646
Let me give you a
couple of examples


43
00:02:28,646 --> 00:02:29,586
of what I'm talking about.


44
00:02:30,256 --> 00:02:34,346
Up until now, you had to use
the old set object for key,


45
00:02:34,346 --> 00:02:37,396
object for key syntax when
setting and getting values


46
00:02:37,396 --> 00:02:40,386
in the CK record, which are the
workhorse of the CloudKit API,


47
00:02:40,386 --> 00:02:44,176
but with iOS 9, you can
use the much more familiar


48
00:02:44,176 --> 00:02:46,566
and modern dictionary
subscripting syntax


49
00:02:46,776 --> 00:02:48,116
when working with CK records.


50
00:02:48,636 --> 00:02:52,736
In addition to that, we
have made your CloudKit code


51
00:02:52,896 --> 00:02:56,396
from Swift as well as
Objective-C a lot more type safe


52
00:02:56,596 --> 00:02:58,486
by adopting the libidity
qualifiers


53
00:02:58,676 --> 00:02:59,756
and Lightweight generics.


54
00:03:00,416 --> 00:03:05,196
Previously you could have set
an array of objects of any type


55
00:03:05,566 --> 00:03:09,066
on the records and safe
product of CKRecords operation.


56
00:03:09,726 --> 00:03:14,056
Now with the latest tools in
iOS 9, the compiler can warn you


57
00:03:14,056 --> 00:03:16,676
when you do that so you
can catch the errors early


58
00:03:16,966 --> 00:03:18,476
and write more robust code.


59
00:03:18,476 --> 00:03:23,296
So with that, let me
give you a brief recap


60
00:03:23,616 --> 00:03:25,306
on the storage architecture
of CloudKit.


61
00:03:25,936 --> 00:03:31,136
The top level silo in CloudKit
is called a CloudKit container.


62
00:03:32,246 --> 00:03:35,756
It is subdivided
into two databases.


63
00:03:36,276 --> 00:03:39,766
The public database, which
is a large soup of all


64
00:03:39,766 --> 00:03:43,136
of your apps data shared
among all of your users,


65
00:03:43,686 --> 00:03:46,906
and the private database
which is tied


66
00:03:46,906 --> 00:03:48,216
to a user's iCloud account.


67
00:03:48,916 --> 00:03:50,496
This daatabase will contain data


68
00:03:50,496 --> 00:03:53,266
for a particular iCloud
account shared across all


69
00:03:53,266 --> 00:03:54,376
of that user's devices.


70
00:03:55,756 --> 00:03:59,366
Within each database we have
a further layer of isolation


71
00:03:59,566 --> 00:04:01,036
for the records you
store in them,


72
00:04:01,506 --> 00:04:03,106
and we call these record zones.


73
00:04:04,516 --> 00:04:08,016
They are a way for CloudKit to
offer additional capabilities


74
00:04:08,016 --> 00:04:10,056
for the records you store
in them where we can.


75
00:04:10,056 --> 00:04:13,746
If the public database has a
single zone called the default


76
00:04:13,746 --> 00:04:15,086
zone where all the records live,


77
00:04:15,736 --> 00:04:20,216
and the private database
also has one default zone.


78
00:04:20,636 --> 00:04:23,216
Along with that, we
give you the capability


79
00:04:23,216 --> 00:04:25,336
to create multiple custom zones


80
00:04:25,716 --> 00:04:29,196
where you have these additional
capabilities for your records.


81
00:04:30,576 --> 00:04:33,756
So with that, let's talk


82
00:04:33,756 --> 00:04:37,426
about what we will cover
in our session today.


83
00:04:37,606 --> 00:04:39,386
You might remember the
schema from last year.


84
00:04:39,836 --> 00:04:42,876
We talked about an
example schema for an app


85
00:04:43,326 --> 00:04:44,686
that shows parties with clouds.


86
00:04:45,046 --> 00:04:48,036
It had a simple schema where
we had a party record type


87
00:04:48,036 --> 00:04:50,936
and clown record type and stored
them in the public database.


88
00:04:51,766 --> 00:04:54,776
I thought this year let's
run with this example


89
00:04:55,716 --> 00:04:57,496
and develop a couple of
features for this app,


90
00:04:58,286 --> 00:05:00,336
example app we'll
call clown central


91
00:05:00,336 --> 00:05:02,896
because it's all about clowns.


92
00:05:03,026 --> 00:05:07,036
We will use the example to walk
through a set of tips and tricks


93
00:05:07,196 --> 00:05:09,076
that you can use when
working with CloudKit.


94
00:05:09,076 --> 00:05:14,256
Our app will have a simplistic
UI where we show the list


95
00:05:14,256 --> 00:05:17,266
of parties and a couple of
features that we will walk


96
00:05:17,266 --> 00:05:19,976
through together
in this session.


97
00:05:20,136 --> 00:05:23,606
Now, truth as example, there
are four major areas I want


98
00:05:23,606 --> 00:05:24,236
to cover today.


99
00:05:25,676 --> 00:05:27,586
Number one is error handling.


100
00:05:28,766 --> 00:05:30,476
Last year we told
you a difference


101
00:05:30,476 --> 00:05:33,106
between a CloudKit app
that handles errors and one


102
00:05:33,106 --> 00:05:34,966
that does not is
not the difference


103
00:05:34,966 --> 00:05:36,756
between a great app
and a good one.


104
00:05:37,136 --> 00:05:38,916
It's a difference
between a functional app


105
00:05:39,116 --> 00:05:40,456
and a completely broken one.


106
00:05:41,046 --> 00:05:42,156
We meant it.


107
00:05:42,396 --> 00:05:45,626
I would like to walk
you through a set


108
00:05:45,626 --> 00:05:48,416
of special error codes you may
encounter when using the API


109
00:05:48,416 --> 00:05:50,696
and give you some
general guidelines


110
00:05:50,876 --> 00:05:52,976
on how to handle them.


111
00:05:53,396 --> 00:05:56,426
With that, we'll start
talking about a couple of tips


112
00:05:56,426 --> 00:05:59,356
that you can keep in mind
when maintaining a local cache


113
00:05:59,646 --> 00:06:00,676
when working with CloudKit.


114
00:06:01,626 --> 00:06:04,156
That will lead us into
talking about how to get set


115
00:06:04,156 --> 00:06:06,946
up with subscriptions to
keep our cache up to date,


116
00:06:07,636 --> 00:06:10,096
and finally I would
like to talk about a set


117
00:06:10,096 --> 00:06:12,806
of general purpose performance
tips that you should keep


118
00:06:12,806 --> 00:06:15,176
in mind and adopt
in your apps today.


119
00:06:16,626 --> 00:06:18,636
So we've got a ton of
great stuff to cover.


120
00:06:18,636 --> 00:06:21,296
Let's jump in and talk
about error handling.


121
00:06:26,276 --> 00:06:27,496
The first thing that I would


122
00:06:27,496 --> 00:06:29,616
like to do is talk
about accounts.


123
00:06:30,816 --> 00:06:33,076
CloudKit does not require you


124
00:06:33,076 --> 00:06:35,136
to have an iCloud
account to be used.


125
00:06:35,446 --> 00:06:38,946
We allow anonymous read only
access to the public database.


126
00:06:40,036 --> 00:06:41,996
Let's say for demonstration
purposes here


127
00:06:41,996 --> 00:06:44,806
that the clown central app
will require an iCloud account.


128
00:06:46,206 --> 00:06:47,776
We talk about a couple
of features


129
00:06:47,776 --> 00:06:50,926
that use the private
database which, by definition,


130
00:06:50,926 --> 00:06:52,766
require an authenticated
account.


131
00:06:53,336 --> 00:06:56,116
And by default, write access


132
00:06:56,116 --> 00:06:58,076
to the database requires
an account as well.


133
00:06:58,656 --> 00:07:03,206
As a reminder, the way you
check the account status


134
00:07:03,466 --> 00:07:06,016
for the current user is by
using the account status


135
00:07:06,016 --> 00:07:11,236
with completion handler API,
available on CK container.


136
00:07:11,836 --> 00:07:15,086
Any errors that you encounter
when working with CloudKit due


137
00:07:15,086 --> 00:07:16,486
to authentication will fail


138
00:07:16,486 --> 00:07:20,106
with a special error code called
CKError not authenticated.


139
00:07:20,916 --> 00:07:23,826
The general guideline we
give to handle this error is


140
00:07:23,826 --> 00:07:26,946
to recheck the account status.


141
00:07:26,946 --> 00:07:29,256
Let's say we have a
missing iCloud account.


142
00:07:30,076 --> 00:07:31,526
When you check the
account status,


143
00:07:31,726 --> 00:07:36,026
you receive CKAccount
status no account.


144
00:07:36,356 --> 00:07:40,276
Previously you had no way
of knowing when requests


145
00:07:40,276 --> 00:07:42,456
that failed due to a
missing account would start


146
00:07:42,456 --> 00:07:43,176
succeeding again.


147
00:07:44,236 --> 00:07:47,656
For that very purpose with
iOS 9 and OS X El Capitan,


148
00:07:47,926 --> 00:07:50,476
we added CKAccount
change notification.


149
00:07:50,906 --> 00:07:53,616
We will send you this
notification whenever there is a


150
00:07:53,616 --> 00:07:57,136
change to the user's account,
for example on log ins, log outs


151
00:07:57,456 --> 00:07:59,826
or if the iCloud drive
capability switch is turned


152
00:07:59,826 --> 00:08:02,006
on or off.


153
00:08:02,846 --> 00:08:06,146
With that I would like to touch
on a couple of best practices


154
00:08:06,146 --> 00:08:09,106
when handling a missing
account in your apps.


155
00:08:09,726 --> 00:08:13,206
It might be tempting when
encountering this situation


156
00:08:13,206 --> 00:08:16,506
to throw up an alert for the
user telling them they don't


157
00:08:16,506 --> 00:08:18,846
have a logged in iCloud
account and can't proceed.


158
00:08:19,546 --> 00:08:21,616
This is not helpful to the user


159
00:08:21,616 --> 00:08:25,456
because they might dismiss the
alert and retry an operation


160
00:08:25,456 --> 00:08:28,506
that led them to see the
alert in the first place.


161
00:08:29,116 --> 00:08:31,536
What we recommend instead is


162
00:08:31,536 --> 00:08:35,116
that you gracefully
degrade your UI in a way


163
00:08:35,116 --> 00:08:37,246
that simply disables
the features of your app


164
00:08:37,736 --> 00:08:41,895
that require an account, and
for this purpose you can now use


165
00:08:41,895 --> 00:08:44,396
CKAccount change notification
to re-enable that UI,


166
00:08:44,396 --> 00:08:47,346
when you receive it,
re-check the account status,


167
00:08:47,346 --> 00:08:49,236
and see that one
account is now available.


168
00:08:49,826 --> 00:08:55,176
A missing account is not
one of the only conditions


169
00:08:55,176 --> 00:08:59,026
under which your operations
might fail temporarily,


170
00:09:00,756 --> 00:09:03,166
but may start succeeding at
some point in the future.


171
00:09:04,506 --> 00:09:06,996
For example, under
poor network conditions


172
00:09:07,116 --> 00:09:09,876
where you might encounter this
error, CKError network failure,


173
00:09:11,346 --> 00:09:13,336
or if the CloudKit
servers are busy.


174
00:09:13,516 --> 00:09:14,936
Or you might see
one of these errors:


175
00:09:14,936 --> 00:09:18,226
CKError service unavailable
or CKError zone busy.


176
00:09:19,206 --> 00:09:24,256
When encountering this error, we
want you to retry the operation


177
00:09:24,256 --> 00:09:28,196
at a later date, but
you might be wondering


178
00:09:28,426 --> 00:09:29,926
when do I retry those
operations?


179
00:09:30,536 --> 00:09:32,896
Well, you don't have
to guess at that value.


180
00:09:33,676 --> 00:09:37,776
In these errors, user info
dictionaries we return


181
00:09:37,776 --> 00:09:41,946
to you a special value under the
key "CKError retry after key."


182
00:09:42,976 --> 00:09:46,246
This value is a value of
time in seconds that you need


183
00:09:46,246 --> 00:09:48,516
to wait before retrying
that operation.


184
00:09:51,156 --> 00:09:53,476
Now, let's take a
similar example


185
00:09:54,066 --> 00:09:57,206
where let's say our
app initially had a bug


186
00:09:57,206 --> 00:10:00,356
which might have caused it
to send a lot of updates


187
00:10:00,356 --> 00:10:03,246
to the server in a very
short amount of time.


188
00:10:03,246 --> 00:10:07,006
Let's say if this app made it to
the wild in that way and a lot


189
00:10:07,006 --> 00:10:08,326
of users started
hitting that bug,


190
00:10:08,636 --> 00:10:10,426
it would overwhelm
the iCloud servers.


191
00:10:11,086 --> 00:10:12,876
The way we avoid this is


192
00:10:12,876 --> 00:10:16,826
by using a special error
code called CKError request


193
00:10:16,826 --> 00:10:17,306
rate limited.


194
00:10:18,536 --> 00:10:22,076
This is CloudKit's way of
mitigating application bugs


195
00:10:22,186 --> 00:10:24,166
from overwhelming
the iCloud servers.


196
00:10:25,836 --> 00:10:30,296
Any requests that hit the rate
limited error will not be sent


197
00:10:30,296 --> 00:10:33,456
up to the server until a
period of time has elapsed.


198
00:10:34,156 --> 00:10:35,936
Once again what is
that period of time?


199
00:10:36,736 --> 00:10:40,496
It is given to you by the
CKError retry after key.


200
00:10:42,036 --> 00:10:45,626
So when you encounter this
error, look for this key


201
00:10:45,626 --> 00:10:47,116
in the errors user
info dictionary.


202
00:10:47,496 --> 00:10:50,046
Wait for a period of time,
and retry your request.


203
00:10:50,656 --> 00:10:54,236
Now I would like to start
talking about a different class


204
00:10:54,236 --> 00:10:55,996
of errors that you
might encounter


205
00:10:56,866 --> 00:10:59,706
because of the way your schema
is designed, specifically


206
00:10:59,706 --> 00:11:05,716
if your schema allows multiple
users to update the same record


207
00:11:05,716 --> 00:11:06,706
in your Cloud database.


208
00:11:07,746 --> 00:11:10,356
So let's say we want to
add a feature to our app


209
00:11:10,686 --> 00:11:13,986
where we allow attendees to
add themselves to a party.


210
00:11:15,276 --> 00:11:17,786
But unfortunately, when
designing the schema


211
00:11:17,786 --> 00:11:20,926
for this feature, we did not
watch last year's advanced


212
00:11:20,926 --> 00:11:21,556
CloudKit session.


213
00:11:22,956 --> 00:11:24,606
So this is a schema
we came up with.


214
00:11:25,866 --> 00:11:29,336
On the party record itself,
we decided to store an array


215
00:11:29,336 --> 00:11:31,446
of references to
attendee records


216
00:11:31,496 --> 00:11:32,536
that want to join that party.


217
00:11:33,206 --> 00:11:38,776
Now, you can see that
every single time we wish


218
00:11:38,776 --> 00:11:41,256
to add an attendee to a
particular party, we are going


219
00:11:41,256 --> 00:11:43,576
to end up modifying
the same party record.


220
00:11:45,116 --> 00:11:47,646
Let's take a look at an
example of what happens


221
00:11:47,966 --> 00:11:53,116
when two different users try
to add themselves to a party.


222
00:11:53,296 --> 00:11:55,936
Since the WWDC bash
is starting up soon,


223
00:11:56,216 --> 00:12:00,626
let's say we saved this
record to CloudKit.


224
00:12:00,626 --> 00:12:03,456
And now before we
get into what happens


225
00:12:03,456 --> 00:12:06,076
when two users download this
record, I would like to talk


226
00:12:06,076 --> 00:12:10,466
about what are record
change tags.


227
00:12:10,466 --> 00:12:15,796
You can think of them as simply
a string that the server uses


228
00:12:15,796 --> 00:12:18,176
to identify a particular
version of a record.


229
00:12:18,676 --> 00:12:21,706
This version of the
record as it exists


230
00:12:21,706 --> 00:12:24,756
on the server is recognized
by the change tag A.


231
00:12:26,026 --> 00:12:29,396
We expose this to you as a read
only property on CKRecords,


232
00:12:29,586 --> 00:12:32,556
but it will only be populated
on records that have been saved.


233
00:12:34,056 --> 00:12:36,716
Let's say two users, John
and Alice, come along


234
00:12:36,716 --> 00:12:38,956
and download this particular
version of the record.


235
00:12:39,546 --> 00:12:43,406
You can see they receive
the same change tags, A.


236
00:12:43,656 --> 00:12:46,876
Now, John adds himself as an
attendee to the party first,


237
00:12:47,586 --> 00:12:50,306
goes ahead and tries to save
his record to the server.


238
00:12:51,436 --> 00:12:54,136
Now, with the records saved,
we will send the change tag


239
00:12:54,136 --> 00:12:57,076
that John had, which
is A, up to the server.


240
00:12:57,076 --> 00:12:59,736
And the server sees that
the change tags match


241
00:13:00,616 --> 00:13:02,166
and accepts John's modification.


242
00:13:03,376 --> 00:13:06,516
Now, since the version of the
server record has changed,


243
00:13:06,776 --> 00:13:09,876
the server will generate a new
change tag in this case, B,


244
00:13:10,036 --> 00:13:12,776
and send that back to John
in the record save response.


245
00:13:12,776 --> 00:13:17,856
Now let's say Alice comes along
and decides to attend the party.


246
00:13:19,436 --> 00:13:22,126
She tries the same operation,
adds herself to the array


247
00:13:22,256 --> 00:13:23,906
and tries to save her
version of the record.


248
00:13:24,626 --> 00:13:26,736
This time you can see
that she will be sending


249
00:13:26,736 --> 00:13:30,476
up the old change tag A,
and the server will complain


250
00:13:30,566 --> 00:13:33,516
that she is trying to alter a
version of the server record


251
00:13:33,516 --> 00:13:34,666
that no longer exists.


252
00:13:35,106 --> 00:13:38,316
She encountered a conflict.


253
00:13:38,316 --> 00:13:42,336
On her device, the way CloudKit
tells her about this conflict is


254
00:13:42,336 --> 00:13:47,066
by a special error code called
CK error: server record changed.


255
00:13:48,716 --> 00:13:51,596
There's no magic
happening behind the scenes,


256
00:13:51,596 --> 00:13:53,276
and we don't make assumptions


257
00:13:53,276 --> 00:13:55,366
about how you wish
to resolve conflicts.


258
00:13:55,666 --> 00:13:57,066
You are the best
person to do that.


259
00:13:57,566 --> 00:14:01,836
So we will try to provide you
with as much useful information


260
00:14:01,836 --> 00:14:04,826
as we can for you to resolve
those conflicts yourself.


261
00:14:05,866 --> 00:14:07,836
And the first and most
important piece of information


262
00:14:07,836 --> 00:14:11,196
that we give you is the
version of the record as it was


263
00:14:11,196 --> 00:14:13,356
in the server when an
update was rejected.


264
00:14:14,676 --> 00:14:15,636
Where do you find that?


265
00:14:15,906 --> 00:14:18,846
You find that once again in the
errors user's info dictionary


266
00:14:19,116 --> 00:14:22,286
under the key CKRecord changed
error, server record key.


267
00:14:22,286 --> 00:14:25,016
In this case, when we pull it


268
00:14:25,016 --> 00:14:27,236
out of the errors
user's info dictionary,


269
00:14:27,436 --> 00:14:29,726
we would find the record
as it was in the server


270
00:14:29,956 --> 00:14:33,346
with John attending the party
and the new change tag B.


271
00:14:33,946 --> 00:14:37,046
Now, in addition to
the server record,


272
00:14:37,456 --> 00:14:40,146
we give you back a few
more pieces of information.


273
00:14:42,036 --> 00:14:46,096
These include the ancestor
record key which is the record


274
00:14:46,096 --> 00:14:49,426
as Alice had before she made
any modifications to it.


275
00:14:50,836 --> 00:14:54,506
And the client record key
which will contain the record


276
00:14:54,506 --> 00:14:59,566
that Alice tried to
save to the server.


277
00:14:59,736 --> 00:15:01,946
Now, what I want to
emphasize here is


278
00:15:01,946 --> 00:15:05,496
that the most important thing to
do, and what you will be doing


279
00:15:05,496 --> 00:15:07,436
in most cases when
resolving a conflict,


280
00:15:07,896 --> 00:15:10,576
is trying to save the
modifications that you were


281
00:15:10,576 --> 00:15:12,996
in the first place before
you encountered the error


282
00:15:12,996 --> 00:15:15,946
but instead on to the
server record returned


283
00:15:15,946 --> 00:15:16,666
to you by the error.


284
00:15:17,486 --> 00:15:20,316
So in this case, you
take the server record.


285
00:15:20,956 --> 00:15:23,686
We'll make the same modification
to it that we were trying


286
00:15:23,686 --> 00:15:26,816
to save, which in our case is
simply add Alice as an attendee


287
00:15:26,816 --> 00:15:31,346
to the party, include her along
with John, and save this version


288
00:15:31,346 --> 00:15:32,306
of the record to the server.


289
00:15:32,836 --> 00:15:37,416
You can see that we have the
server's new change tag B.


290
00:15:38,146 --> 00:15:40,716
When we save the record
those change tags will match,


291
00:15:40,716 --> 00:15:42,026
and the server will
accept the save.


292
00:15:42,576 --> 00:15:47,266
Now, a point to note here is


293
00:15:47,266 --> 00:15:50,206
that we could have avoided
this entire class of errors


294
00:15:50,416 --> 00:15:52,426
if we had used a better
schema for this feature.


295
00:15:53,616 --> 00:15:57,626
I'll talk about what that
schema is in a short while.


296
00:15:58,416 --> 00:16:00,216
But you can see that trying


297
00:16:00,216 --> 00:16:03,536
to modify the same record every
single time a different user


298
00:16:03,536 --> 00:16:05,646
makes that modification
is not the best idea.


299
00:16:06,226 --> 00:16:11,106
So talk through this new schema,


300
00:16:11,526 --> 00:16:13,636
let's look at CloudKit
operations.


301
00:16:14,966 --> 00:16:19,056
We want to add a feature to
our app that allows users


302
00:16:19,056 --> 00:16:20,686
to store photos for parties.


303
00:16:22,016 --> 00:16:25,046
We need a similar one-to-many
relationship between parties


304
00:16:25,046 --> 00:16:28,056
and photos this time, so photos
would be their own record type,


305
00:16:28,846 --> 00:16:32,786
but we don't want to store them
on the party record this time.


306
00:16:33,236 --> 00:16:34,286
How do we do this?


307
00:16:34,286 --> 00:16:37,646
We can save the photo
records with a back reference


308
00:16:37,646 --> 00:16:39,666
to the party that they
belong to instead.


309
00:16:40,976 --> 00:16:46,376
You can see now when we save
photo records, we don't have


310
00:16:46,376 --> 00:16:49,776
to modify the party
record that they belong to.


311
00:16:52,896 --> 00:16:55,416
So let's talk about how we
are saving these records.


312
00:16:56,026 --> 00:17:00,846
Let's say right now in our app
we are using the convenience


313
00:17:00,846 --> 00:17:03,096
API, save record with
completion handler


314
00:17:03,096 --> 00:17:06,506
to save one photo
record at a time.


315
00:17:06,675 --> 00:17:11,406
But users could potentially
store multiple photos at once.


316
00:17:11,465 --> 00:17:14,685
In that case, we are currently
using the convenience API


317
00:17:14,826 --> 00:17:17,306
in the tight loop to
save multiple records.


318
00:17:18,195 --> 00:17:21,126
Let's take a look at what is
happening behind the scenes


319
00:17:21,376 --> 00:17:22,165
when we do that.


320
00:17:22,656 --> 00:17:28,096
The app calls the convenience
API a bunch of times to be able


321
00:17:28,096 --> 00:17:29,526
to save multiple photos.


322
00:17:30,436 --> 00:17:33,336
Each one much those in
the system gets wrapped


323
00:17:33,486 --> 00:17:39,796
into a CK operation with a set
of default values, and each one


324
00:17:39,796 --> 00:17:43,046
of those operations turns into
at least one network request


325
00:17:43,176 --> 00:17:45,036
when we try to save that
record up to the server.


326
00:17:45,836 --> 00:17:48,566
We are not going to
overwhelm the server with all


327
00:17:48,566 --> 00:17:52,146
of those requests at once, so we
have also created a bottleneck


328
00:17:52,146 --> 00:17:55,106
in the system, and the system
sends up a few requests


329
00:17:55,106 --> 00:17:59,086
at a time in order to
save those records.


330
00:18:00,106 --> 00:18:02,566
Now, in addition
to this bottleneck,


331
00:18:02,566 --> 00:18:05,296
there is one more thing
that you should consider.


332
00:18:05,956 --> 00:18:11,626
Every single one of those
requests to save one record


333
00:18:11,626 --> 00:18:13,486
at a time, for example
in this case,


334
00:18:13,846 --> 00:18:16,316
counts against your
network request quota


335
00:18:16,316 --> 00:18:17,716
as CloudKit app developers.


336
00:18:19,226 --> 00:18:20,606
This is clearly a bad idea.


337
00:18:22,216 --> 00:18:24,906
We want to be able to
batch those record updates


338
00:18:25,156 --> 00:18:28,346
into one network request, or
at least the minimum number


339
00:18:28,346 --> 00:18:29,736
of network requests possible.


340
00:18:30,026 --> 00:18:30,956
How do we do that?


341
00:18:31,986 --> 00:18:36,286
Well, we do that by using
the CK operation counterpart


342
00:18:36,286 --> 00:18:37,356
to our convenience API.


343
00:18:38,876 --> 00:18:41,956
Almost every convenience
API that works on one item


344
00:18:41,956 --> 00:18:45,056
at a time has a CKOperation
counterpart


345
00:18:45,196 --> 00:18:46,786
that batches record
updates together.


346
00:18:47,426 --> 00:18:50,816
In this case we want to use
CKModify Records operation


347
00:18:51,186 --> 00:18:53,646
to be able to save
multiple records at once


348
00:18:54,726 --> 00:18:57,226
by providing them as an array
to the record save property.


349
00:18:57,876 --> 00:19:00,996
Look at what happens when
we adopt this operation.


350
00:19:01,496 --> 00:19:04,176
Now we can bunch all of
the records that we want


351
00:19:04,206 --> 00:19:05,846
to save into one operation.


352
00:19:06,456 --> 00:19:09,626
It queues in the system.


353
00:19:09,626 --> 00:19:12,016
The system is able to
use the minimum number


354
00:19:12,016 --> 00:19:14,876
of requests it needs to be
able to save those records


355
00:19:14,876 --> 00:19:17,846
to the server, and we
eliminated the bottleneck.


356
00:19:19,396 --> 00:19:24,216
At the same time we've
helped you optimize the use


357
00:19:24,216 --> 00:19:25,156
of your request quota.


358
00:19:26,496 --> 00:19:30,436
This is an important point I
would like all of you to think


359
00:19:30,436 --> 00:19:32,856
about in your apps when
using the convenience API.


360
00:19:33,646 --> 00:19:36,526
If you are ever using it
for the same kind of request


361
00:19:36,526 --> 00:19:41,086
in multiple places or some
kind of loop, think instead


362
00:19:41,086 --> 00:19:43,136
of adopting the CKOperation API


363
00:19:43,136 --> 00:19:44,906
that lets you batch
those updates.


364
00:19:44,906 --> 00:19:47,066
It will save you
your request quota,


365
00:19:47,066 --> 00:19:50,566
and at the same time be more
efficient for the system.


366
00:19:50,566 --> 00:19:51,266
All right.


367
00:19:52,456 --> 00:19:55,036
Now that we are working
with batches,


368
00:19:55,846 --> 00:19:58,766
there is an additional
consideration


369
00:19:58,906 --> 00:20:00,366
that we need to think about.


370
00:20:02,536 --> 00:20:05,836
The server imposes
certain limits on the sizes


371
00:20:05,836 --> 00:20:07,906
of the batches that
can be sent up at once.


372
00:20:09,776 --> 00:20:14,166
These limits include the number
of items in each request,


373
00:20:15,346 --> 00:20:18,316
as well as the total
size of the request.


374
00:20:18,526 --> 00:20:21,096
The total size of the
request is simply the sum


375
00:20:21,096 --> 00:20:23,746
of the key value data that
you set in the records


376
00:20:23,746 --> 00:20:25,026
that that belong
to that request.


377
00:20:26,366 --> 00:20:30,086
An impportant thing to keep
in mind here is that the size


378
00:20:30,086 --> 00:20:32,526
of the data the you are
trying to store as part


379
00:20:32,526 --> 00:20:36,886
of bulk stoarage via the CKAsset
API does not count towards this


380
00:20:36,886 --> 00:20:37,636
key value data.


381
00:20:38,206 --> 00:20:43,496
But if your request were to
trip any one of these limits,


382
00:20:44,616 --> 00:20:47,446
you would receive a special
error code called CKError


383
00:20:47,446 --> 00:20:48,176
limit exceeded.


384
00:20:49,016 --> 00:20:51,766
The general guideline
we give developers


385
00:20:51,766 --> 00:20:54,696
to handle this error is simply
divide the number of items


386
00:20:54,696 --> 00:20:58,836
in your batch by half and issue
two operations instead of one.


387
00:21:00,086 --> 00:21:03,206
And recursively do that if those
operations encounter the same


388
00:21:03,206 --> 00:21:05,926
error again.


389
00:21:06,366 --> 00:21:10,636
Now, what if only some items
in your batch were to fail?


390
00:21:10,856 --> 00:21:15,076
Since the batch consists
of a lot of items


391
00:21:15,076 --> 00:21:18,526
but returns only one error to
you, we still want to tell you


392
00:21:18,526 --> 00:21:20,256
about every single
one of those errors.


393
00:21:20,996 --> 00:21:25,376
We do that by using a special
error code called CKError


394
00:21:25,376 --> 00:21:26,176
partial failure.


395
00:21:27,476 --> 00:21:31,296
This is a top level error code
that you don't really want


396
00:21:31,296 --> 00:21:34,636
to handle directly,
but once again


397
00:21:35,246 --> 00:21:37,096
under the errors
user's info dictionary,


398
00:21:37,096 --> 00:21:40,016
if you look under CKPartial
errors by item ID key,


399
00:21:40,106 --> 00:21:42,946
we will give you a
dictionary of item IDs


400
00:21:42,946 --> 00:21:47,106
to the corresponding
errors from your batch.


401
00:21:47,286 --> 00:21:51,146
For example, in this case we
have had one item ID that failed


402
00:21:51,146 --> 00:21:53,826
with CKRecord invalid
arguments, and there may


403
00:21:53,826 --> 00:21:56,426
or may not be errors for any
other items in your batch.


404
00:21:56,756 --> 00:22:00,516
You want to open this up, look
inside the dictionary and handle


405
00:22:00,516 --> 00:22:01,486
that error individually.


406
00:22:03,456 --> 00:22:05,686
This situation changes slightly


407
00:22:06,346 --> 00:22:09,536
when considering atomic
updates in custom zones.


408
00:22:11,356 --> 00:22:15,626
Custom zones, as a
reminder, have the capability


409
00:22:15,626 --> 00:22:17,776
for your CKModify
records operation


410
00:22:17,776 --> 00:22:19,046
to issue atomic updates,


411
00:22:19,096 --> 00:22:22,346
in which case the server will
either accept the entire batch


412
00:22:22,346 --> 00:22:24,436
as one or fail the entire batch.


413
00:22:25,806 --> 00:22:28,526
Now, if one item in our
batch, as in this case,


414
00:22:28,526 --> 00:22:31,046
would have failed with
CKError invalid arguments,


415
00:22:31,106 --> 00:22:33,656
the rest of the item IDs
would also contain an errror


416
00:22:34,036 --> 00:22:36,886
with a special error code,
CKRecords batch request failed.


417
00:22:38,096 --> 00:22:40,066
When working with
atomic updates,


418
00:22:40,066 --> 00:22:42,136
make sure to look
inside the dictionaries


419
00:22:42,326 --> 00:22:43,966
and handle all the
errors that are not


420
00:22:44,066 --> 00:22:47,916
in CKError batch request fails.


421
00:22:48,476 --> 00:22:51,766
That's storing all of our
photo records up to the Cloud


422
00:22:51,766 --> 00:22:53,916
in an optimized manner.


423
00:22:53,916 --> 00:22:57,616
Let's talk about the other
half, downloading them.


424
00:22:57,616 --> 00:23:00,116
The way we do that is by
using CloudKit queries.


425
00:23:00,206 --> 00:23:00,356
All right.


426
00:23:01,466 --> 00:23:02,696
Downloading photo records


427
00:23:02,696 --> 00:23:06,136
for a particular party
has now become really easy


428
00:23:06,136 --> 00:23:08,966
with the new schema
that we adopted


429
00:23:08,966 --> 00:23:11,766
where photo records reference
the party they belong to.


430
00:23:12,646 --> 00:23:15,556
We do that by simply
constructing a CK query


431
00:23:15,866 --> 00:23:17,486
that tries to match
that reference


432
00:23:17,706 --> 00:23:21,786
to a known party record ID.


433
00:23:22,046 --> 00:23:25,076
Now, when we issue our query
to download photos for a party,


434
00:23:25,856 --> 00:23:27,746
some parties might
have a lot of photos.


435
00:23:28,046 --> 00:23:31,106
Do we really need to
download all of them?


436
00:23:31,106 --> 00:23:35,396
Let's take a look at how we
can issue an optimized download


437
00:23:35,396 --> 00:23:37,026
for the photos for
a particular party


438
00:23:37,346 --> 00:23:38,946
by using CKQuery operation.


439
00:23:41,996 --> 00:23:44,406
The first question
to really answer is:


440
00:23:44,706 --> 00:23:47,656
We have no idea how many photos
belong to a particular party.


441
00:23:47,936 --> 00:23:49,306
So how many should we download?


442
00:23:49,376 --> 00:23:52,146
It doesn't make sense
to download all of them.


443
00:23:53,276 --> 00:23:55,526
What makes sense is for our UI


444
00:23:55,526 --> 00:23:57,306
to drive the answer
to that question.


445
00:23:58,246 --> 00:24:00,266
Now, if you take a look
at our example UI here,


446
00:24:00,556 --> 00:24:03,436
you can see that when we
pull up a particular party,


447
00:24:03,676 --> 00:24:06,366
all we see are 20 photos.


448
00:24:07,646 --> 00:24:09,466
So it would make a lot of sense


449
00:24:09,526 --> 00:24:13,046
if our query only
returned 20 photos to us


450
00:24:13,116 --> 00:24:14,206
when we first issued it.


451
00:24:15,176 --> 00:24:18,366
We can do just that by using
the results limit property


452
00:24:18,536 --> 00:24:19,736
on CKQuery operation.


453
00:24:20,916 --> 00:24:26,816
This property helps a lot for
you to be able to manage items


454
00:24:27,026 --> 00:24:28,386
in a particular batch size


455
00:24:28,446 --> 00:24:31,086
when you have no idea how
many items might be returned


456
00:24:31,086 --> 00:24:31,856
to you in total.


457
00:24:32,466 --> 00:24:35,516
So for that reason
it is also available


458
00:24:35,516 --> 00:24:37,736
on CKFetch record
changes operation


459
00:24:38,036 --> 00:24:40,056
where you maybe returned
a lot of changes,


460
00:24:40,056 --> 00:24:42,526
and you have no idea how
many from a custom zone


461
00:24:43,866 --> 00:24:46,576
and on CKFetch notification
changes operation


462
00:24:46,576 --> 00:24:47,646
for a similar reason.


463
00:24:47,646 --> 00:24:48,306
All right.


464
00:24:49,156 --> 00:24:52,656
So now we are downloading
just 20 records.


465
00:24:52,986 --> 00:24:53,796
That's an improvement.


466
00:24:54,496 --> 00:24:55,986
But can we do better?


467
00:24:56,756 --> 00:24:58,456
Well, let's take a look at
what we are downloading.


468
00:24:59,266 --> 00:25:02,066
Once again we let our UI
answer this question for us.


469
00:25:02,236 --> 00:25:04,686
Whenever we are viewing
a particular party,


470
00:25:04,686 --> 00:25:07,856
all we are seeing is
tiny thumbnails, cropped


471
00:25:07,856 --> 00:25:09,806
and down scaled photos
for a particular party.


472
00:25:11,136 --> 00:25:14,876
But what we've stored
on our photo record


473
00:25:15,116 --> 00:25:18,046
that is being downloaded
completely by default


474
00:25:18,046 --> 00:25:22,266
for us is probably a high
resolution version of that photo


475
00:25:23,446 --> 00:25:25,526
that we've taken with
the amazing cameras


476
00:25:25,526 --> 00:25:26,596
on our iOS devices.


477
00:25:27,786 --> 00:25:30,976
Well, wouldn't it be great
if we could somehow add


478
00:25:30,976 --> 00:25:33,666
that information right
on to our photo record


479
00:25:34,406 --> 00:25:37,746
so that we have something that
we can pull down partially,


480
00:25:38,606 --> 00:25:40,376
but how do we pull
down partial records?


481
00:25:41,006 --> 00:25:43,656
Well, we do that by using
the desired keys property


482
00:25:43,946 --> 00:25:45,166
on CKQuery operation.


483
00:25:46,326 --> 00:25:50,216
In this case, the desired keys
property will take an array


484
00:25:50,216 --> 00:25:53,026
of keys that you wish to
fetch on all the records


485
00:25:53,026 --> 00:25:53,826
that match your query.


486
00:25:55,136 --> 00:25:57,366
So if we set that just to
be our photo thumbnail,


487
00:25:57,366 --> 00:26:00,406
you can see that we have
drastically reduced the amount


488
00:26:00,406 --> 00:26:02,906
of data that we are loading
when our query returns.


489
00:26:05,696 --> 00:26:09,156
This is also available on
CKFetch records operation


490
00:26:09,536 --> 00:26:12,346
where you may know the
record IDs in advance


491
00:26:12,346 --> 00:26:15,106
of the records you are
fetching, but either your UI


492
00:26:15,106 --> 00:26:18,466
or some other reason you
only want partial records


493
00:26:18,576 --> 00:26:19,236
to be downloaded.


494
00:26:21,406 --> 00:26:24,266
As well as on CKFetch
record changes operation


495
00:26:24,396 --> 00:26:27,386
which once again by default
downloads the full record


496
00:26:27,796 --> 00:26:29,366
for any records that
may have changed.


497
00:26:29,886 --> 00:26:35,106
So now that we're displaying
only 20 photos, it makes sense


498
00:26:35,106 --> 00:26:38,236
for us to have a certain
ordering on the photos


499
00:26:38,236 --> 00:26:39,786
that we are first
displaying to the user.


500
00:26:40,416 --> 00:26:43,266
Let's say we want to show
the photos in the order


501
00:26:43,266 --> 00:26:45,516
that they have been,
in the order


502
00:26:45,516 --> 00:26:48,076
that they were most
recently saved into iCloud.


503
00:26:50,226 --> 00:26:54,686
We do that by setting the sort
discriptor right on the CKQuery


504
00:26:54,686 --> 00:26:56,976
that we initialized our
CKQuery operation with.


505
00:26:57,586 --> 00:27:01,876
You can see here we are
creating a sort descriptor


506
00:27:01,876 --> 00:27:04,946
on the creation date key
which is a system field


507
00:27:05,086 --> 00:27:07,976
on all CKRecords that have
been saved to the server.


508
00:27:08,536 --> 00:27:11,096
And set that to descending.


509
00:27:11,696 --> 00:27:17,646
One thing to keep in mind here,
since this is a system field,


510
00:27:17,906 --> 00:27:21,096
you need to ensure that
it's sortable on the server.


511
00:27:21,656 --> 00:27:24,736
You do that configuration
via the iCloud dashboard.


512
00:27:25,606 --> 00:27:26,656
Make sure to have


513
00:27:26,656 --> 00:27:29,426
that configuration set before
those records are saved.


514
00:27:29,926 --> 00:27:34,976
Otherwise, the previous records
saved previously are not going


515
00:27:34,976 --> 00:27:37,626
to have that index on them.


516
00:27:38,296 --> 00:27:41,136
So now that we are
fetching just a small slice


517
00:27:41,206 --> 00:27:43,956
of our entire results
set, you may be wondering,


518
00:27:43,956 --> 00:27:45,546
how do we show the
user the rest?


519
00:27:45,826 --> 00:27:48,506
Say the user starts scrolling
down, and we want to look


520
00:27:48,506 --> 00:27:49,776
at the next batch of photos.


521
00:27:51,876 --> 00:27:55,086
How do we implement
pagination in this case?


522
00:27:55,676 --> 00:27:58,666
Well, we do that by
looking at what we get back


523
00:27:58,736 --> 00:27:59,986
in our query completion block.


524
00:28:01,306 --> 00:28:04,976
When a query completes, in
addition to all the results


525
00:28:04,976 --> 00:28:06,966
that were returned to us
in the progress call backs,


526
00:28:07,256 --> 00:28:09,066
we get back a CKQuery cursor.


527
00:28:10,576 --> 00:28:16,906
This is an opaque marker for you
to use that shows you your place


528
00:28:16,906 --> 00:28:18,186
in the entire results set.


529
00:28:18,936 --> 00:28:21,856
So you should store the
query cursor returned to you


530
00:28:21,856 --> 00:28:25,806
from the first query
operation, and when you wish


531
00:28:25,806 --> 00:28:28,496
to fetch the next
batch of results,


532
00:28:28,936 --> 00:28:32,556
initialize another CKQuery
operation using the cursor


533
00:28:32,556 --> 00:28:34,636
initializer and pass it,


534
00:28:34,956 --> 00:28:37,296
the cursor that you
stored previously.


535
00:28:37,296 --> 00:28:43,386
Now, since we are optimizing
our CKQuery operation


536
00:28:43,386 --> 00:28:47,216
in this manner, make sure
to set the same desired keys


537
00:28:47,216 --> 00:28:49,976
and results limit on the new
query operation once again.


538
00:28:50,976 --> 00:28:54,276
That will give you just the
optimized next batch of photos.


539
00:28:56,956 --> 00:28:59,696
That was about downloading
records.


540
00:29:01,086 --> 00:29:05,716
Now I would like to switch
gears and talk about some tips


541
00:29:05,716 --> 00:29:06,926
that you can keep in mind


542
00:29:07,066 --> 00:29:11,376
when maintaining a local
cache working with CloudKit.


543
00:29:11,376 --> 00:29:12,736
Let's start talking
about a new feature.


544
00:29:13,286 --> 00:29:17,336
Let's say we want to add
the ability for users


545
00:29:17,336 --> 00:29:20,416
to store small personal
Notes for parties.


546
00:29:20,656 --> 00:29:24,326
Now, since these Notes
are going to be personal,


547
00:29:24,946 --> 00:29:27,176
we want to store them in
the user's private database.


548
00:29:27,696 --> 00:29:33,596
We don't want to fetch these
Notes every single time a user


549
00:29:33,596 --> 00:29:35,716
wants to view them
or modify them.


550
00:29:36,446 --> 00:29:38,016
We want to make sure
that we have some kind


551
00:29:38,016 --> 00:29:39,786
of offline access
for these Notes.


552
00:29:40,256 --> 00:29:45,936
And you can see that in this
particular scenario what we


553
00:29:46,206 --> 00:29:50,126
actually need is a small
amount of data but on all


554
00:29:50,126 --> 00:29:51,606
of a particular user's devices.


555
00:29:52,936 --> 00:29:55,956
So it makes a lot of sense for
us to maintain a local cache


556
00:29:56,636 --> 00:30:00,436
when working with
CloudKit in this scenario.


557
00:30:00,436 --> 00:30:03,346
Let's first talk about how we
can start downloading things


558
00:30:03,346 --> 00:30:04,406
from a private database.


559
00:30:05,566 --> 00:30:09,396
Now, if you recall, we have the
ability to store custom zones


560
00:30:09,396 --> 00:30:11,866
in the private database that
gave us additional capabilities.


561
00:30:13,096 --> 00:30:14,856
We go ahead and do just that.


562
00:30:15,366 --> 00:30:18,686
Create a new zone in the private
database called the notes zone.


563
00:30:19,926 --> 00:30:21,796
And now we have two main ways


564
00:30:22,086 --> 00:30:25,936
in which we can start
fetching data from this zone.


565
00:30:26,136 --> 00:30:28,866
Once again, we can either
use a CKQuery operation


566
00:30:29,156 --> 00:30:31,126
and optimize it just
the way we saw,


567
00:30:31,616 --> 00:30:36,576
or we can use delta downloads
via the CKRecords fetch


568
00:30:36,666 --> 00:30:41,236
operation which lets us
fetch only the records


569
00:30:41,236 --> 00:30:42,556
in the zone that have changed.


570
00:30:43,086 --> 00:30:48,276
If you recall, this operation is
only available to work on zones


571
00:30:48,276 --> 00:30:50,036
which have the fetch
changes capability.


572
00:30:50,536 --> 00:30:52,226
Currently, all custom zones


573
00:30:52,226 --> 00:30:54,406
in a private database
do have this capability.


574
00:30:55,936 --> 00:30:57,246
Now, if you wish to learn more


575
00:30:57,246 --> 00:31:00,056
about how exactly delta
downloads work, I invite you


576
00:31:00,056 --> 00:31:01,186
to go back and look


577
00:31:01,186 --> 00:31:02,886
at the advanced CloudKit
session from last year.


578
00:31:03,216 --> 00:31:06,596
It's a great walk through of
how the operation exactly works.


579
00:31:07,126 --> 00:31:10,726
Let's say we are using it.


580
00:31:11,236 --> 00:31:12,766
We've started fetching
our changes.


581
00:31:13,136 --> 00:31:16,756
We have our app objects that
we are storing in some sort


582
00:31:16,756 --> 00:31:18,386
of local database,
whether it's core data


583
00:31:18,676 --> 00:31:20,246
or any other database
of your choice.


584
00:31:21,166 --> 00:31:24,276
That's where we encode
our app objects currently.


585
00:31:25,936 --> 00:31:28,206
So here we have a party object.


586
00:31:28,406 --> 00:31:31,776
We see we've added the notes
key on it corresponding


587
00:31:32,096 --> 00:31:34,106
for that particular user's
Notes for that party.


588
00:31:34,896 --> 00:31:39,266
We encode our app object
to our local storage.


589
00:31:39,266 --> 00:31:42,156
When working with a
corresponding CKRecords,


590
00:31:42,686 --> 00:31:46,766
we want to store those
records up in the Cloud.


591
00:31:46,916 --> 00:31:50,616
We might think about
encoding the entire CKRecord


592
00:31:51,446 --> 00:31:55,766
so that we have that cached
along with our app object.


593
00:31:56,196 --> 00:31:57,646
Let's take a look at
what happens here.


594
00:31:58,036 --> 00:32:00,796
You can see that
CKRecord also has all


595
00:32:00,796 --> 00:32:02,366
of the app objects
key set on it.


596
00:32:02,676 --> 00:32:05,796
Of course, when we encode
it we are duplicating all


597
00:32:05,796 --> 00:32:06,536
of the apps keys.


598
00:32:07,936 --> 00:32:09,976
Once we encoded our
app object and now


599
00:32:09,976 --> 00:32:11,446
when we are encoding
our CKRecord.


600
00:32:12,266 --> 00:32:15,286
This is clearly not
what we want.


601
00:32:16,006 --> 00:32:18,196
Well, the orange
fields that you saw


602
00:32:18,196 --> 00:32:21,776
on the CKRecord belong
just to the CKRecord.


603
00:32:22,316 --> 00:32:24,546
They are the fields
needed by the server


604
00:32:24,546 --> 00:32:26,796
to recognize a particular
version of the record.


605
00:32:27,016 --> 00:32:28,536
We call them system fields.


606
00:32:29,456 --> 00:32:32,176
So what you really want
in this case is a way


607
00:32:32,176 --> 00:32:35,176
to encode just the system
fields of the record.


608
00:32:36,096 --> 00:32:39,456
And you can do just that by
using the encode system fields


609
00:32:39,456 --> 00:32:41,336
with coder API on CKRecord.


610
00:32:42,896 --> 00:32:45,536
Now this is all the code
that you need to be able


611
00:32:45,536 --> 00:32:46,846
to encode those system fields.


612
00:32:46,846 --> 00:32:50,416
I highly recommend that you
reference this if you ever,


613
00:32:50,416 --> 00:32:54,766
if the situation arises and
you ever need to look back.


614
00:32:55,016 --> 00:32:56,346
Now let's take a
look at what happens


615
00:32:56,346 --> 00:32:58,396
when we start encoding
just the system fields.


616
00:32:59,686 --> 00:33:02,636
We are efficiently storing
now what is important


617
00:33:02,636 --> 00:33:07,976
about a CKRecord and the
corresponding party object.


618
00:33:08,126 --> 00:33:11,096
Now, let's walk through a
scenario of what happens


619
00:33:11,306 --> 00:33:13,166
when we try to modify
a party object


620
00:33:13,546 --> 00:33:18,256
for which we've stored the
system fields in this manner.


621
00:33:18,416 --> 00:33:22,666
For that we use the coder
initializer for CKRecord.


622
00:33:26,796 --> 00:33:28,566
So you can see that
when we pull it out,


623
00:33:29,456 --> 00:33:34,706
we will get back all the system
fields that we had stored.


624
00:33:34,706 --> 00:33:37,316
For brevity I've only shown the
record ID and the change tag


625
00:33:37,656 --> 00:33:40,226
which we've already seen.


626
00:33:40,426 --> 00:33:44,406
Now on this bare CKRecord it is
completely legitimate for you


627
00:33:44,406 --> 00:33:48,766
to set just the keys that
have changed on this record.


628
00:33:49,156 --> 00:33:50,816
So let's say we want to
change just the party


629
00:33:51,696 --> 00:33:54,926
and make this record
our WWDC bash record.


630
00:33:55,176 --> 00:33:57,186
We set the new value
for that key


631
00:33:57,536 --> 00:33:58,996
and save the new
record for the server.


632
00:33:59,556 --> 00:34:05,686
It is important to note that
you don't always have to set all


633
00:34:05,686 --> 00:34:07,836
of the keys that
belong to a record


634
00:34:08,036 --> 00:34:10,186
when storing changes
for that record.


635
00:34:10,186 --> 00:34:15,206
So now that we are officially
maintaining and storing


636
00:34:15,206 --> 00:34:19,516
that local cache, let's talk
about how do we fetch changes


637
00:34:19,596 --> 00:34:23,906
from our custom zone in order
to keep that cache up to date?


638
00:34:24,186 --> 00:34:27,545
Well, once again we already
have the answer to this


639
00:34:27,606 --> 00:34:31,286
by using CKFetch record changes
operation which gives us all


640
00:34:31,286 --> 00:34:32,946
of the records that have
changed in our zone.


641
00:34:33,596 --> 00:34:36,946
The real question is, when
do we use this operation?


642
00:34:37,565 --> 00:34:40,505
Because using this operation
alone does not tell us


643
00:34:40,656 --> 00:34:42,485
when our zone has changed.


644
00:34:43,025 --> 00:34:44,446
So for that we need


645
00:34:44,446 --> 00:34:49,426
to use notifications via
the CKSubscription API.


646
00:34:49,676 --> 00:34:52,585
More specifically,
since the changes


647
00:34:52,585 --> 00:34:56,485
in the zone are not changes that
you wish to alert a user about,


648
00:34:56,485 --> 00:34:59,576
what we really want here
are silent notifications.


649
00:35:01,236 --> 00:35:06,476
So in the next section, I would
like to talk to you about how


650
00:35:06,476 --> 00:35:09,426
to get up and running with
subscriptions especially


651
00:35:09,426 --> 00:35:11,646
when you want to use
silent subscriptions.


652
00:35:12,436 --> 00:35:14,446
Let's start with brief recap.


653
00:35:15,136 --> 00:35:16,336
What are subscriptions?


654
00:35:17,476 --> 00:35:20,316
Subscriptions are per
user persistent queries


655
00:35:20,316 --> 00:35:21,446
that you saved to the server.


656
00:35:22,016 --> 00:35:26,016
They are a way for
you, for your app


657
00:35:26,156 --> 00:35:29,476
to receive remote notifications
per relevant changes.


658
00:35:30,496 --> 00:35:33,266
There are two types of
subscriptions, and they differ


659
00:35:33,266 --> 00:35:36,586
in the way you define what a
relevant change for you is.


660
00:35:38,336 --> 00:35:41,496
Number one, there are
query subscriptions


661
00:35:41,696 --> 00:35:43,216
which allow you to
store a predicate.


662
00:35:44,006 --> 00:35:46,406
So when the predicate
values to true,


663
00:35:46,606 --> 00:35:47,666
that's your relevant change.


664
00:35:48,976 --> 00:35:51,356
The second ones are
zone subscriptions


665
00:35:51,356 --> 00:35:53,336
where every modification


666
00:35:53,336 --> 00:35:55,636
to a zone counts as
a relevant change.


667
00:35:56,226 --> 00:36:02,796
So this is clearly what we
want in the case of trying


668
00:36:02,796 --> 00:36:05,686
to get silent notifications
whenever our zone changes.


669
00:36:06,996 --> 00:36:10,746
But first, let's walk through
the general setup that you need


670
00:36:11,076 --> 00:36:13,346
when handling all kinds
of CloudKit subscriptions.


671
00:36:13,726 --> 00:36:17,316
What I would like to
emphasize with this setup is


672
00:36:17,316 --> 00:36:22,216
that you still need to go
through the motions of setting


673
00:36:22,216 --> 00:36:24,076
up remote notifications


674
00:36:24,236 --> 00:36:26,396
as if they were not
coming from CloudKit.


675
00:36:27,546 --> 00:36:28,706
Let me show you what
I mean by that.


676
00:36:29,266 --> 00:36:31,956
Number one, you still
need the APS capability


677
00:36:31,956 --> 00:36:34,586
for the app ID turned on
from the developer portal.


678
00:36:35,256 --> 00:36:38,236
This should get automatically
turned on for you when you turn


679
00:36:38,236 --> 00:36:39,416
on the CloudKit capability.


680
00:36:39,866 --> 00:36:44,756
Number two, you need to set the
APS environment key in your app


681
00:36:44,826 --> 00:36:47,446
into a P list for development
while you're testing your app


682
00:36:47,446 --> 00:36:49,276
and expecting remote
notifications.


683
00:36:51,476 --> 00:36:52,946
Third, you still need


684
00:36:52,946 --> 00:36:55,256
to register via the
UI application API.


685
00:36:55,986 --> 00:36:58,956
At the very least, you
need to call register


686
00:36:58,956 --> 00:37:02,906
for remote notifications
and also call user,


687
00:37:03,036 --> 00:37:05,766
register user notification
settings if you are planning


688
00:37:05,766 --> 00:37:10,576
to show user notifications
in your app.


689
00:37:11,196 --> 00:37:14,146
Now, since we are interested
in silent notifications


690
00:37:14,486 --> 00:37:16,166
and we're dealing with
the CloudKit server


691
00:37:16,166 --> 00:37:19,256
that sends us notifications,
how do we tell the server


692
00:37:19,966 --> 00:37:21,626
that this should be a
silent notification?


693
00:37:22,736 --> 00:37:26,476
We do that through
CKNotification info


694
00:37:26,596 --> 00:37:28,316
corresponding to
our CK subscription.


695
00:37:28,826 --> 00:37:30,166
That is our entry point


696
00:37:30,406 --> 00:37:32,886
into telling the CloudKit
server just what kind


697
00:37:32,886 --> 00:37:36,146
of a push payload should be
sent and at what priority.


698
00:37:36,516 --> 00:37:37,736
Let's talk about priorities.


699
00:37:39,006 --> 00:37:44,426
So like I said, we configure
our CKNotification info in a way


700
00:37:44,526 --> 00:37:45,916
that tells the CloudKit server


701
00:37:46,156 --> 00:37:48,706
that this is a silent
notification and it needs


702
00:37:48,706 --> 00:37:49,846
to come at a low priority.


703
00:37:51,776 --> 00:37:54,926
The server will send you a high
priority push if you have any


704
00:37:54,926 --> 00:37:57,396
of these keys set on your
CK notification info.


705
00:37:57,826 --> 00:38:02,136
Whether it's the alert body,
should badge or sound name.


706
00:38:03,586 --> 00:38:06,316
These are what we call UI
keys for your subscription.


707
00:38:06,416 --> 00:38:07,756
If you send any one of them,


708
00:38:08,176 --> 00:38:10,716
the server sends a high
priority push that is meant


709
00:38:10,716 --> 00:38:11,966
to be delivered immediately.


710
00:38:14,036 --> 00:38:17,726
All other pushes are sent
at medium priority and count


711
00:38:17,726 --> 00:38:19,026
as silent notifications.


712
00:38:21,116 --> 00:38:24,826
So let's walk through what is
a silent notification specific


713
00:38:24,826 --> 00:38:28,206
setup that you need.


714
00:38:28,956 --> 00:38:30,776
Number one, you need to turn


715
00:38:30,776 --> 00:38:33,626
on the remote notification
background mode for your app.


716
00:38:34,276 --> 00:38:36,876
You do this through the
capabilities pane in Xcode.


717
00:38:37,966 --> 00:38:41,846
You should remember
to checkmark that.


718
00:38:42,056 --> 00:38:43,756
Number two, you should make sure


719
00:38:43,756 --> 00:38:45,766
that you implement
the application


720
00:38:45,766 --> 00:38:47,346
that you receive
remote notification,


721
00:38:47,706 --> 00:38:49,666
fetch completion
handler notification


722
00:38:49,666 --> 00:38:51,016
of the application delegate API.


723
00:38:52,696 --> 00:38:55,696
The other version is not going
to be called in the background.


724
00:38:55,696 --> 00:38:58,456
Make sure when you are
expecting silent notifications,


725
00:38:58,456 --> 00:38:59,966
you have implemented
this version.


726
00:39:00,536 --> 00:39:06,366
And third, once again now we
need to tell the CloudKit server


727
00:39:06,366 --> 00:39:08,236
that this is going
to be a silent push,


728
00:39:08,786 --> 00:39:10,746
how do we configure our
CKNotification info?


729
00:39:11,256 --> 00:39:14,446
First and most importantly,


730
00:39:14,446 --> 00:39:17,516
you should set the 'should send
content available' property


731
00:39:17,516 --> 00:39:17,986
to true.


732
00:39:18,786 --> 00:39:20,296
It tells the CloudKit server


733
00:39:20,296 --> 00:39:22,706
that in your push payload it
should include the content


734
00:39:22,706 --> 00:39:24,766
available key.


735
00:39:26,056 --> 00:39:29,766
Secondly you should not
set any of the UI keys


736
00:39:29,766 --> 00:39:32,796
that we just talked about
on that CKNotification info.


737
00:39:33,506 --> 00:39:35,466
Setting any one of
these properties along


738
00:39:35,466 --> 00:39:38,206
with should send content
available is not a supported


739
00:39:38,206 --> 00:39:40,716
configuration and will result
in an error on the server.


740
00:39:43,216 --> 00:39:46,606
So now let's talk about
silent push delivery.


741
00:39:46,606 --> 00:39:49,196
We've configured everything,
we are expecting pushes.


742
00:39:49,566 --> 00:39:51,966
When do we get them?


743
00:39:52,406 --> 00:39:55,606
Since these notifications are
not meant to alert the user


744
00:39:55,606 --> 00:39:58,836
in any way, they
are sent at a time


745
00:39:58,836 --> 00:40:00,326
that is opportune
for the system.


746
00:40:00,826 --> 00:40:03,806
The system considers a variety
of factors when deciding


747
00:40:03,806 --> 00:40:04,896
when they should get delivered.


748
00:40:05,516 --> 00:40:10,556
And push delivery in
general is best effort.


749
00:40:11,636 --> 00:40:14,336
What I mean by that is that
pushes could get coalesced


750
00:40:14,656 --> 00:40:17,276
or even dropped depending on
the conditions of a device.


751
00:40:17,966 --> 00:40:21,426
For example, if a device was
in airplane mode when a flurry


752
00:40:21,426 --> 00:40:24,416
of pushes was expected,
coming out of airplane mode,


753
00:40:24,446 --> 00:40:27,516
the Apple push notification
server will only send the device


754
00:40:27,556 --> 00:40:31,546
the last push that was
meant to be received on it.


755
00:40:31,806 --> 00:40:34,976
Now, we have ways to mitigate
this because we are dealing


756
00:40:34,976 --> 00:40:36,456
with CloudKit notifications.


757
00:40:37,486 --> 00:40:42,656
In particular, CloudKit server
stores all of the notifications


758
00:40:42,656 --> 00:40:44,646
that were meant to be
delivered to your device


759
00:40:44,746 --> 00:40:46,846
in what we call a
notification collection.


760
00:40:47,996 --> 00:40:50,846
So when you do receive
a silent notification,


761
00:40:51,076 --> 00:40:53,796
you should make sure
to fetch changes


762
00:40:53,796 --> 00:40:55,226
from this notification
collection,


763
00:40:55,316 --> 00:40:58,886
and you do that via the CKFetch
notification changes operation.


764
00:40:59,486 --> 00:41:04,566
So now we are getting silent
notifications, we are checking


765
00:41:04,666 --> 00:41:06,416
if there are any
notifications that we've missed,


766
00:41:07,146 --> 00:41:09,096
and we know that
our zone has changed


767
00:41:09,096 --> 00:41:11,566
which is the reason we got the
notification in the first place.


768
00:41:12,036 --> 00:41:15,736
This is where we use CKFetch
record changes operation


769
00:41:15,826 --> 00:41:17,366
to see what has changed
in our zone.


770
00:41:18,436 --> 00:41:22,446
But once again like we've
talked about before,


771
00:41:22,446 --> 00:41:24,926
we have no idea how many
things changed in that zone.


772
00:41:25,706 --> 00:41:28,056
So potentially this could
be a long running operation.


773
00:41:28,376 --> 00:41:31,176
If you need a little more time
for that operation to complete,


774
00:41:31,686 --> 00:41:32,816
I recommend that you look


775
00:41:32,816 --> 00:41:35,436
into the background task
API on UI application.


776
00:41:36,996 --> 00:41:39,776
This will let you get
that extra time in order


777
00:41:39,776 --> 00:41:43,786
for your operation to complete.


778
00:41:44,136 --> 00:41:46,346
Now, before we start
talking about notifications,


779
00:41:46,926 --> 00:41:50,536
in iOS 8 we introduced
an entirely new category


780
00:41:50,796 --> 00:41:53,426
of notifications called
interactive notifications


781
00:41:53,646 --> 00:41:57,696
which allow a user to interact
with pushes from banner,


782
00:41:57,786 --> 00:41:59,616
alert or from a notification
center.


783
00:42:01,046 --> 00:42:03,776
And we have had a lot of
requests from you to be able


784
00:42:03,776 --> 00:42:06,206
to configure interactive
notifications with CloudKit.


785
00:42:06,716 --> 00:42:09,156
I'm pleased to announce
with iOS 9 you can do just


786
00:42:09,156 --> 00:42:10,966
that with minimal
amount of setup.


787
00:42:11,416 --> 00:42:15,116
Once again if you just set
the new category property


788
00:42:15,396 --> 00:42:19,506
on CKNotification
info, it corresponds


789
00:42:19,506 --> 00:42:21,426
to the identifier
you that registered


790
00:42:21,936 --> 00:42:24,406
with UI mutable notification
categories


791
00:42:24,546 --> 00:42:26,576
when registering user
notification settings.


792
00:42:27,496 --> 00:42:29,916
That is all the setup you
need to get up and running


793
00:42:29,916 --> 00:42:31,696
with interactive
notifications with CloudKit.


794
00:42:32,516 --> 00:42:38,856
[Applause]


795
00:42:39,356 --> 00:42:39,896
>> NIHAR SHARMA: Thank you.


796
00:42:40,586 --> 00:42:43,526
And with that, I would
like to start talking


797
00:42:43,526 --> 00:42:46,106
about a general set
of performance tips


798
00:42:46,196 --> 00:42:49,116
that you should keep in mind
and use in your apps today


799
00:42:49,296 --> 00:42:51,886
when working with CloudKit.


800
00:42:52,336 --> 00:42:56,736
CloudKit is a highly
asynchronous API.


801
00:42:56,966 --> 00:43:00,436
Most operations talk over the
network, and it is very common


802
00:43:00,436 --> 00:43:03,756
to run into situations where you
have a set of dependent tasks


803
00:43:04,306 --> 00:43:06,706
and you want to maintain
some sort of ordering


804
00:43:06,796 --> 00:43:09,286
in which they complete.


805
00:43:09,756 --> 00:43:15,056
Now, when implementing
task management for these,


806
00:43:15,366 --> 00:43:18,796
there are a couple of goals,
a couple of high level goals


807
00:43:18,796 --> 00:43:21,906
that we would like
you to keep in mind.


808
00:43:22,056 --> 00:43:23,966
Number one, obviously


809
00:43:24,276 --> 00:43:27,536
that whatever technique
you employ allows you


810
00:43:27,536 --> 00:43:30,536
to implement great error
handling for every single one


811
00:43:30,536 --> 00:43:33,296
of your CloudKit tasks.


812
00:43:33,456 --> 00:43:35,966
Secondly, since these are
asynchronous operations,


813
00:43:35,966 --> 00:43:38,536
you should make sure to
never end up in a situation


814
00:43:38,536 --> 00:43:39,866
where you block the main thread


815
00:43:40,276 --> 00:43:41,836
and degrade their
UI performance.


816
00:43:42,376 --> 00:43:47,536
And last but not the least, as
developers you want to make sure


817
00:43:47,926 --> 00:43:51,236
that your task management
scheme is, lets you end


818
00:43:51,236 --> 00:43:54,376
up with maintainable code
that is easy to reason about,


819
00:43:54,376 --> 00:43:56,986
debug and extend as you add
new features to your app.


820
00:43:57,726 --> 00:44:01,316
Let's take a look at a couple
of ways where we do this


821
00:44:01,686 --> 00:44:03,826
and some dos and don'ts.


822
00:44:05,636 --> 00:44:09,236
The number one don't is
nesting convenience API calls.


823
00:44:09,886 --> 00:44:14,146
Let's take a simple example.


824
00:44:14,296 --> 00:44:17,076
If we had to modify one
of the attendee records


825
00:44:17,206 --> 00:44:20,086
in the old schema that we
saw, once again never use


826
00:44:20,086 --> 00:44:21,356
that schema in the real world.


827
00:44:21,796 --> 00:44:24,046
But if you had to modify
the attendee record,


828
00:44:24,046 --> 00:44:25,416
this is what you
would have to do


829
00:44:25,416 --> 00:44:27,036
when using convenience
API calls.


830
00:44:27,386 --> 00:44:30,066
You would first fetch
record with ID and try


831
00:44:30,066 --> 00:44:31,106
to fetch the party record


832
00:44:31,106 --> 00:44:33,176
that you know the
attendees are part of,


833
00:44:33,836 --> 00:44:36,716
then pull out the record
ID for the attendee


834
00:44:36,926 --> 00:44:41,526
from the attendees array, and
then make your modification


835
00:44:41,526 --> 00:44:44,256
to the attendee's record, and
then try to save that record.


836
00:44:45,246 --> 00:44:48,166
This is trying to
modify one record


837
00:44:48,566 --> 00:44:50,086
with one set of dependencies.


838
00:44:50,296 --> 00:44:52,366
You can see we have
ended up with code


839
00:44:52,846 --> 00:45:00,426
that is just a mangled piece
of soup where you have no idea


840
00:45:00,556 --> 00:45:03,656
where to handle which
error and how best


841
00:45:03,656 --> 00:45:05,116
to retry those operations.


842
00:45:06,096 --> 00:45:09,486
In addition to that, there
is an additional point


843
00:45:09,486 --> 00:45:10,176
of concern here.


844
00:45:11,386 --> 00:45:14,836
Let's say that we issue these
operations due to some sort


845
00:45:14,836 --> 00:45:16,296
of user action in our app.


846
00:45:17,336 --> 00:45:20,716
Now, if a subsequent
user action were


847
00:45:20,716 --> 00:45:22,916
to render these tasks
unnecessary,


848
00:45:23,216 --> 00:45:25,676
once you've enqueued
them, you have no way


849
00:45:25,676 --> 00:45:26,696
to cancel these tasks.


850
00:45:27,676 --> 00:45:30,206
So if they are potentially
long running, you are stuck


851
00:45:30,236 --> 00:45:34,256
with them running, you are
stuck waiting for them.


852
00:45:34,476 --> 00:45:36,566
We recommend that you
never use this approach


853
00:45:36,686 --> 00:45:40,666
when managing dependent
tasks especially if you need


854
00:45:40,666 --> 00:45:43,526
to make the same modification
for a batch of records.


855
00:45:45,356 --> 00:45:48,156
Now, another technique that
we see is to simply get rid


856
00:45:48,156 --> 00:45:50,686
of the asynchronous
nature of the API perhaps


857
00:45:50,806 --> 00:45:54,656
by introducing a
semaphore and waiting on it.


858
00:45:55,076 --> 00:45:57,236
This can get hairy in a
couple of situations too.


859
00:45:58,126 --> 00:46:00,956
You should almost
never try to do this.


860
00:46:02,176 --> 00:46:06,316
If you do, you should keep
in mind that especially


861
00:46:06,316 --> 00:46:08,546
if you wait forever for
operations to complete,


862
00:46:08,546 --> 00:46:10,916
it it is very easy
for you to end


863
00:46:10,916 --> 00:46:12,686
up with circular
dependencies that end


864
00:46:12,686 --> 00:46:15,726
up causing a deadlock
in your app.


865
00:46:15,726 --> 00:46:19,226
Or if you were to ever use
this practice on a main thread,


866
00:46:19,846 --> 00:46:23,176
this will block your UI
right away on an operation


867
00:46:23,176 --> 00:46:25,406
that is likely waiting
on the network and result


868
00:46:25,406 --> 00:46:26,806
in a terrible user experience.


869
00:46:28,636 --> 00:46:30,806
So we don't really recommend it.


870
00:46:33,596 --> 00:46:36,456
What we do recommend is
for you to take a look


871
00:46:36,456 --> 00:46:40,336
at the dependency management
API that NSOperation offers.


872
00:46:41,576 --> 00:46:43,186
This is what I mean by that API.


873
00:46:44,076 --> 00:46:47,316
NSOperation lets you easily
add and remove dependencies


874
00:46:47,316 --> 00:46:48,866
between other NSOperations.


875
00:46:49,396 --> 00:46:53,776
Let's take a look at how
this works with CKOperations


876
00:46:53,826 --> 00:46:55,866
that are a subclass
of NSOperations.


877
00:46:57,856 --> 00:47:01,156
If we have two dependent
fetch records operations


878
00:47:01,706 --> 00:47:05,206
and the second one should not
begin before the first one is


879
00:47:05,206 --> 00:47:09,046
completed, all you need to do is
set up both of those operations


880
00:47:09,596 --> 00:47:13,096
and add the first fetch as
a dependency on the second


881
00:47:13,096 --> 00:47:14,936
and enqueue both of
those operations.


882
00:47:15,926 --> 00:47:19,816
This will guarantee that the
second fetch does not start


883
00:47:20,136 --> 00:47:21,546
before the first
fetch is finished.


884
00:47:22,536 --> 00:47:25,586
You can see this offers
you a logical way to think


885
00:47:25,586 --> 00:47:27,916
about the errors for
particular operations


886
00:47:28,246 --> 00:47:30,976
and at the same time
manage dependencies for them


887
00:47:31,096 --> 00:47:34,086
in a convenient manner.


888
00:47:34,716 --> 00:47:37,886
Now, when thinking
about NSOperations


889
00:47:37,886 --> 00:47:39,476
from a performance context,


890
00:47:40,936 --> 00:47:44,056
there is an additional
distinction that I would


891
00:47:44,056 --> 00:47:45,366
like you guys to think about.


892
00:47:46,796 --> 00:47:49,256
Not all NSOperations
are created equal.


893
00:47:50,026 --> 00:47:51,396
Some of them may
have been created


894
00:47:51,396 --> 00:47:53,196
because of an explicit
user action


895
00:47:53,196 --> 00:47:56,556
in your apps while others may
represent background tasks


896
00:47:56,746 --> 00:47:58,026
that are of lower priority.


897
00:47:59,396 --> 00:48:02,246
To indicate this notion
of relative importance


898
00:48:02,246 --> 00:48:04,146
between NSOperations
to the system,


899
00:48:04,506 --> 00:48:07,236
in iOS 8 we introduced
the quality


900
00:48:07,236 --> 00:48:09,646
of service property
on NSOperations.


901
00:48:11,056 --> 00:48:14,916
This property lets you indicate
the nature and importance


902
00:48:14,916 --> 00:48:17,596
of work encapsulated
by your NSOperation.


903
00:48:18,806 --> 00:48:21,276
These are the various
service levels


904
00:48:21,276 --> 00:48:24,676
that this property can take,
and I recommend that you check


905
00:48:24,676 --> 00:48:26,936
out the documentation for
a description of each one


906
00:48:26,936 --> 00:48:28,686
of these values and
their significance.


907
00:48:29,466 --> 00:48:32,086
But what is important to keep
in mind here is that each


908
00:48:32,086 --> 00:48:35,206
of these service values
directly affects the priority


909
00:48:35,206 --> 00:48:38,946
with which the NSOperation is
allocated system resources,


910
00:48:39,356 --> 00:48:43,166
like CPU time, disk resources,
as well as network resources.


911
00:48:45,086 --> 00:48:49,976
Now, with CloudKit last year, we
wanted to give you a similar way


912
00:48:49,976 --> 00:48:53,276
to be able to opt your
lower priority CKOperations


913
00:48:53,466 --> 00:48:55,196
into discretionary
network behavior.


914
00:48:56,336 --> 00:48:57,916
What we mean by that, is


915
00:48:57,916 --> 00:49:01,326
that for your nonuser
initiated tasks, for example,


916
00:49:01,766 --> 00:49:04,416
pre-fetching content for
the user like we just went


917
00:49:04,416 --> 00:49:07,326
through by using CKRecords
fetch record changes operation


918
00:49:07,326 --> 00:49:09,386
in response to silent
notifications.


919
00:49:10,306 --> 00:49:13,236
You want those tasks to opt
into discretionary behavior


920
00:49:13,236 --> 00:49:16,356
so that the system waits
for an opportune time


921
00:49:16,936 --> 00:49:18,616
to perform those
network requests.


922
00:49:19,776 --> 00:49:22,376
The system takes a variety
of factors into account


923
00:49:22,586 --> 00:49:25,436
when deciding when to
perform them, for exmple,


924
00:49:26,146 --> 00:49:27,536
cellular connectivity.


925
00:49:27,946 --> 00:49:31,936
The system might wait
for network connectivity


926
00:49:31,936 --> 00:49:35,546
to improve before sending
out those requests.


927
00:49:35,546 --> 00:49:36,786
Also power conditions.


928
00:49:37,276 --> 00:49:38,796
If a user is running
low on battery


929
00:49:39,036 --> 00:49:41,956
or the device is not currently
charging, the system will wait


930
00:49:41,956 --> 00:49:45,236
for power conditions to improve
before sending those requests.


931
00:49:46,176 --> 00:49:49,816
We did this by exposing the
user background session property


932
00:49:49,896 --> 00:49:50,896
on CKOperations.


933
00:49:52,096 --> 00:49:58,796
With iOS 9 we saw an opportunity
here to greatly simplify


934
00:49:59,086 --> 00:50:03,496
and unify these things, these
two concepts by using quality


935
00:50:03,496 --> 00:50:06,616
of service to infer
your network behavior,


936
00:50:06,956 --> 00:50:09,946
and at the same time
pull in everything else


937
00:50:09,946 --> 00:50:12,646
that a given service level
already indicates to the system.


938
00:50:13,466 --> 00:50:14,756
So we are doing just that.


939
00:50:16,296 --> 00:50:18,526
By deprecating the user's
background session property


940
00:50:19,116 --> 00:50:22,146
and recommending that you start
setting quality of service


941
00:50:22,326 --> 00:50:24,086
on all of your CKOperations.


942
00:50:25,776 --> 00:50:29,776
Now, in the context of network
behavior, you can set either


943
00:50:29,776 --> 00:50:33,456
of the service levels user
interactive or user initiated


944
00:50:33,456 --> 00:50:35,746
to opt out of this
discretionary behavior.


945
00:50:38,376 --> 00:50:41,156
And for discretionary behavior,


946
00:50:41,156 --> 00:50:43,776
you can either set
the value utility


947
00:50:44,816 --> 00:50:45,956
in which case we will try


948
00:50:45,956 --> 00:50:49,526
to infer whether you should be
opted into discretionary based


949
00:50:49,526 --> 00:50:53,966
on whether the requesting app is
foreground or not or background


950
00:50:54,756 --> 00:50:57,396
which will always result in
discretionary network behavior.


951
00:50:57,896 --> 00:51:03,126
Please keep in mind that if
you build your apps with iOS 9


952
00:51:03,126 --> 00:51:05,436
and OS X El Capitan or later,


953
00:51:06,466 --> 00:51:09,796
all new CKOperations will
have the background quality


954
00:51:09,796 --> 00:51:10,956
of service by default.


955
00:51:11,826 --> 00:51:15,186
You should make sure that you
audit all of your CKOperations,


956
00:51:16,166 --> 00:51:17,546
take a look at what
is the importance


957
00:51:17,546 --> 00:51:18,736
of work that they represent.


958
00:51:19,076 --> 00:51:20,486
Be a good systems citizen


959
00:51:20,726 --> 00:51:24,946
and set the appropriate
QS values on them.


960
00:51:25,206 --> 00:51:26,976
NSOperation is very
powerful API,


961
00:51:27,216 --> 00:51:28,796
and there's a lot more
you can do with it.


962
00:51:29,556 --> 00:51:32,816
If you want to learn more, I
highly recommend that you go


963
00:51:32,816 --> 00:51:35,696
to the advanced NSOperation
session tomorrow morning


964
00:51:36,396 --> 00:51:38,216
in Presidio.


965
00:51:38,216 --> 00:51:43,086
In summary, I'd like to
reiterate that error handling


966
00:51:43,086 --> 00:51:45,006
for your CloudKit code is vital.


967
00:51:45,336 --> 00:51:48,846
It is as important as any
feature, and we would like you


968
00:51:48,846 --> 00:51:51,156
to take a look, go back
today and take a look


969
00:51:51,156 --> 00:51:53,336
at all your operations,
see what kinds


970
00:51:53,336 --> 00:51:54,386
of errors have you been hitting,


971
00:51:54,666 --> 00:51:56,926
and if you followed the
general guidelines we talked


972
00:51:56,926 --> 00:52:00,336
about today in handling them.


973
00:52:00,526 --> 00:52:03,036
Number two, start
batching your requests.


974
00:52:03,306 --> 00:52:06,966
Whenever you see your app
using the convenience API,


975
00:52:07,426 --> 00:52:10,506
working on one item
at a time and doing


976
00:52:10,506 --> 00:52:11,386
that in multiple places,


977
00:52:11,386 --> 00:52:14,816
think with about using the
CKOperation version of that API


978
00:52:15,506 --> 00:52:16,716
and batching those requests up.


979
00:52:17,226 --> 00:52:19,176
You will not only
improve the efficiency


980
00:52:19,536 --> 00:52:22,496
that your operations execute
with in the system in general,


981
00:52:22,896 --> 00:52:25,526
you will also save your
own network request quota.


982
00:52:27,456 --> 00:52:29,426
Think about schema tradeoffs.


983
00:52:29,606 --> 00:52:33,596
We've seen two cases where
our schema tradeoffs came --


984
00:52:33,596 --> 00:52:38,336
let us take advantage
of optimizations.


985
00:52:38,496 --> 00:52:41,376
For example when we
added the thumbnail key


986
00:52:41,376 --> 00:52:45,546
to our photo record, we were
able to optimize our download


987
00:52:45,546 --> 00:52:48,156
by just downloading
the data that we need.


988
00:52:48,906 --> 00:52:52,036
And in another case we were
able to avoid an entire class


989
00:52:52,036 --> 00:52:56,896
of errors when we avoided the
same party record being modified


990
00:52:57,076 --> 00:52:58,486
when photo records
were stored on it.


991
00:52:59,096 --> 00:53:01,276
So think about your
schema carefully


992
00:53:02,336 --> 00:53:03,366
when designing features.


993
00:53:03,916 --> 00:53:08,356
And last but not the least,
configure your CKOperations.


994
00:53:08,356 --> 00:53:11,206
They have, they are
a very powerful API


995
00:53:11,206 --> 00:53:14,066
and they offer a ton of
optimizations you can make


996
00:53:14,236 --> 00:53:16,676
to the actual network
request that gets sent


997
00:53:16,676 --> 00:53:17,876
to the CloudKit servers.


998
00:53:19,816 --> 00:53:22,886
For more information please
check out our documentation


999
00:53:22,886 --> 00:53:25,036
on developer.Apple.com/CloudKit.


1000
00:53:25,766 --> 00:53:28,716
For all the other questions and
answers, the technical support,


1001
00:53:28,716 --> 00:53:31,886
the forums and the CK support
site are a great place.


1002
00:53:32,276 --> 00:53:35,466
For general queries, please
e-mail CloudKit@Apple.com.


1003
00:53:36,246 --> 00:53:38,996
We have had some great
related sessions this week.


1004
00:53:38,996 --> 00:53:41,206
I invite you to check them
out when you go back today


1005
00:53:41,526 --> 00:53:44,096
to Learn all that's
new with Web services


1006
00:53:44,546 --> 00:53:45,926
and what else is
new in CloudKit.


1007
00:53:46,976 --> 00:53:49,326
We have one more Lab
coming up tomorrow morning


1008
00:53:49,326 --> 00:53:51,136
at 9 in Frameworks lab D.


1009
00:53:51,136 --> 00:53:54,316
Bring your questions and
we'd be happy to answer them.


1010
00:53:54,886 --> 00:53:55,196
Thank you.


1011
00:53:56,516 --> 00:54:00,500
[Applause]

