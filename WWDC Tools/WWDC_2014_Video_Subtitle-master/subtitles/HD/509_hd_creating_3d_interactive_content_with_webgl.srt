1
00:00:11,396 --> 00:00:12,286
>> Hi, everyone.


2
00:00:12,546 --> 00:00:14,496
I'm Dean. In a few minutes,


3
00:00:14,496 --> 00:00:16,155
my colleague Brady will
go come up on stage.


4
00:00:16,556 --> 00:00:19,036
We're both engineers
on Apple's WebKit team.


5
00:00:19,666 --> 00:00:22,796
How often have you heard a
presentation start with "Today,


6
00:00:22,796 --> 00:00:25,386
I'm really excited to talk to
you about blah, blah, blah?"


7
00:00:25,596 --> 00:00:27,386
And I told myself I
didn't really want


8
00:00:27,876 --> 00:00:29,206
to introduce this
session that way


9
00:00:29,206 --> 00:00:31,226
and then I realized I
actually am really passionate


10
00:00:31,226 --> 00:00:33,786
about this topic because
over the past few years,


11
00:00:33,786 --> 00:00:36,526
I've worked on a lot of graphics
technologies on the web like SVG


12
00:00:37,006 --> 00:00:41,216
and Canvas, CSS transforms,
animations, filters.


13
00:00:41,426 --> 00:00:44,196
And I really think like WebGL
is the next significant leap


14
00:00:44,196 --> 00:00:46,336
in the type of graphics you
can do in a web browser.


15
00:00:47,686 --> 00:00:52,866
WebGL takes the power of
the OpenGL ES standard,


16
00:00:53,426 --> 00:00:57,516
which is popular on mobile chips
and combines it with the speed


17
00:00:57,516 --> 00:01:00,666
and convenience of JavaScript,
the web's programming language.


18
00:01:01,626 --> 00:01:03,976
This means-Well, because
you got this proliferation


19
00:01:03,976 --> 00:01:08,406
of really powerful
GPU hardware combined


20
00:01:08,406 --> 00:01:11,676
with this incredible performance
improvement in JavaScript,


21
00:01:11,676 --> 00:01:12,896
we've hit this sort
of sweet spot


22
00:01:12,896 --> 00:01:14,596
where you can do these
amazing graphics.


23
00:01:15,106 --> 00:01:18,866
This is going to give you the
full power of a configurable


24
00:01:18,866 --> 00:01:22,406
and programmable pipeline,
as well as performance,


25
00:01:23,116 --> 00:01:25,466
both because you're
talking directly to the GPU


26
00:01:26,856 --> 00:01:30,626
and because JavaScript
is super-fast nowadays.


27
00:01:30,626 --> 00:01:33,116
This is going to allow
you to write web content


28
00:01:33,796 --> 00:01:37,546
such as showing an interactive
3D model while still maintaining


29
00:01:37,546 --> 00:01:40,396
the flexibility and ease
of use of having your text


30
00:01:40,396 --> 00:01:42,256
and interactive controls
in HTML.


31
00:01:42,336 --> 00:01:45,536
Or maybe you want to take that
3D model a little bit further


32
00:01:45,536 --> 00:01:48,896
and do something like an
architectural walk-through flow


33
00:01:48,896 --> 00:01:50,506
through a building site.


34
00:01:50,616 --> 00:01:54,706
You can see here we've got more
advanced lighting, shadows.


35
00:01:59,056 --> 00:02:02,776
There's also data
visualization and mapping.


36
00:02:02,776 --> 00:02:05,006
We all know 3D mapping
is becoming more popular.


37
00:02:05,006 --> 00:02:06,406
But it's not just 3D.


38
00:02:06,886 --> 00:02:10,666
Let's say you want to do a
2D-You want to provide something


39
00:02:10,666 --> 00:02:13,266
like an image editor
that's doing 2D operations


40
00:02:13,266 --> 00:02:14,506
on your content.


41
00:02:14,506 --> 00:02:15,826
And here, you get
to do something


42
00:02:15,826 --> 00:02:18,416
that previously wasn't
available or was difficult to do


43
00:02:18,576 --> 00:02:19,776
in regular JavaScript.


44
00:02:20,166 --> 00:02:24,426
Well, something that's
very popular


45
00:02:24,426 --> 00:02:27,206
on the web is just
doing image transitions.


46
00:02:27,486 --> 00:02:29,386
So here, we've got
something a bit more exciting


47
00:02:29,456 --> 00:02:32,976
than a normal image slide where
we can do a 3D ripple effect.


48
00:02:34,076 --> 00:02:36,186
And of course, there's games.


49
00:02:36,186 --> 00:02:37,706
This is a demo, AngryBots,


50
00:02:37,776 --> 00:02:41,136
by Unity where you've got
this console level game engine


51
00:02:41,356 --> 00:02:46,176
which has things like realistic
lighting, particles and shadows


52
00:02:46,176 --> 00:02:48,846
and also the ability
to destroy evil robots.


53
00:02:49,886 --> 00:02:54,536
Or maybe you want to do
something like casual gaming


54
00:02:54,836 --> 00:02:56,716
and this is Swooop
by PlayCanvas.


55
00:02:56,716 --> 00:02:58,726
And it's a really
great innovative take


56
00:02:58,726 --> 00:03:02,056
on the infinite 2D runner where
instead of like sliding along


57
00:03:02,056 --> 00:03:06,566
in 2D, you're actually flying
this sort of nice stylized plane


58
00:03:06,566 --> 00:03:08,646
around this 3D island;
it's quite fun.


59
00:03:08,646 --> 00:03:13,546
So, what are you
going to learn today?


60
00:03:14,336 --> 00:03:18,746
We'd start by how to set
up-how to get access to WebGL


61
00:03:18,746 --> 00:03:20,076
and set it up in your web page.


62
00:03:20,126 --> 00:03:22,296
And then, we're going
to show how


63
00:03:22,296 --> 00:03:23,786
to do basic drawing with WebGL.


64
00:03:23,786 --> 00:03:25,806
And this is going to be sort
of like crash course into how


65
00:03:25,806 --> 00:03:28,766
to draw something with
WebGL and you get an idea


66
00:03:28,766 --> 00:03:31,016
of how powerful the
rendering system is.


67
00:03:31,556 --> 00:03:32,906
Once we get that, we're
actually going to move


68
00:03:32,906 --> 00:03:35,876
on to advanced drawing and
how to do simple animation.


69
00:03:35,966 --> 00:03:37,896
And lastly, because
it's a web technology,


70
00:03:38,086 --> 00:03:39,736
we want to tell you
how WebGL fits


71
00:03:39,736 --> 00:03:41,356
into other parts of
the web platform.


72
00:03:41,866 --> 00:03:45,706
But the important topic is
where is WebGL available?


73
00:03:45,706 --> 00:03:48,886
And we're happy to say that
WebGL is available in Safari,


74
00:03:48,886 --> 00:03:51,596
on OS X Yosemite, and that
was announced on Monday.


75
00:03:52,516 --> 00:03:54,546
[ Applause ]


76
00:03:55,046 --> 00:03:56,966
And what wasn't announced,
but I'm happy to say,


77
00:03:56,966 --> 00:03:59,836
is it's also available
in Safari on iOS.


78
00:04:00,516 --> 00:04:05,556
[ Applause ]


79
00:04:06,056 --> 00:04:09,036
The even better news is
this-WebGL is available


80
00:04:09,036 --> 00:04:13,006
on every device that can
install these operating systems.


81
00:04:13,816 --> 00:04:15,936
If you're a programmer and
you want to use WebGL content


82
00:04:15,936 --> 00:04:17,666
in your app, you're
going to want to know


83
00:04:17,666 --> 00:04:21,565
about the modern WebKit API
and its WKWebView class.


84
00:04:22,096 --> 00:04:25,326
Now, one of the many benefits
of using this new modern API is


85
00:04:25,326 --> 00:04:30,066
that you get full benefit of
the JavaScript Nitro engine,


86
00:04:30,066 --> 00:04:32,636
which means your content has
got to be running super-fast


87
00:04:32,886 --> 00:04:35,576
which we all know is Craig's
mom's favorite feature


88
00:04:35,576 --> 00:04:38,236
and she's updated all her
apps to use the modern API.


89
00:04:38,236 --> 00:04:45,896
Something else is that the
API surface area between iOS


90
00:04:45,896 --> 00:04:47,916
and OS X is identical
and this means


91
00:04:47,916 --> 00:04:51,556
that your content should run
the same on both devices with,


92
00:04:51,556 --> 00:04:54,096
of course, the understanding
that some devices don't run


93
00:04:54,396 --> 00:04:57,736
or don't have as powerful GPUs,
but otherwise, it's identical.


94
00:04:58,016 --> 00:04:59,596
And similarly, because
it's a web standard,


95
00:04:59,596 --> 00:05:00,846
that same content should run


96
00:05:00,846 --> 00:05:02,546
on other browsers
that support WebGL.


97
00:05:04,376 --> 00:05:09,206
Now, creating great 3D
content is made a lot easier


98
00:05:09,206 --> 00:05:10,476
if you have a good tool system.


99
00:05:10,806 --> 00:05:13,516
And even though WebGL is a
relatively young technology,


100
00:05:13,676 --> 00:05:15,876
it does have a sort of
thriving ecosystem of tools.


101
00:05:16,126 --> 00:05:17,956
And there's a couple I want
to call out in particular


102
00:05:17,956 --> 00:05:20,106
and these are big
vendors, Epic Games,


103
00:05:20,106 --> 00:05:22,916
the makers of Unreal Engine,
and Unity Technologies,


104
00:05:22,916 --> 00:05:26,506
the makers of Unity, both
have announced WebGL export


105
00:05:26,506 --> 00:05:27,446
from their systems.


106
00:05:27,496 --> 00:05:31,986
This means not only do you get
the state-of-the-art 3D engines


107
00:05:31,986 --> 00:05:33,836
and editing environments,
you also get access


108
00:05:33,836 --> 00:05:36,446
to their marketplace where
you can purchase 3D models


109
00:05:36,596 --> 00:05:39,796
or materials or other assets
to help you make your content.


110
00:05:41,356 --> 00:05:44,026
Another example is the
company called PlayCanvas,


111
00:05:44,216 --> 00:05:47,006
who also have a 3D engine and
editing tool, but they do it all


112
00:05:47,006 --> 00:05:48,846
within the web browser,
and this means


113
00:05:48,846 --> 00:05:51,496
that you can have distributed
teams working inside


114
00:05:51,496 --> 00:05:54,076
of a browser editing the same
content; it's really cool.


115
00:05:54,406 --> 00:05:57,266
If you're a developer, there's
a bunch of open source libraries


116
00:05:57,266 --> 00:05:58,646
and I've just listed a few here.


117
00:05:59,096 --> 00:06:02,156
Most of these do wrap
the low-level WebGL API


118
00:06:02,156 --> 00:06:05,716
and something higher which
allows you to program in terms


119
00:06:05,716 --> 00:06:08,226
of spheres and cubes
and materials rather


120
00:06:08,346 --> 00:06:09,926
than buffers and triangles.


121
00:06:10,666 --> 00:06:13,246
But today, we are going to talk
about buffers and triangles


122
00:06:13,246 --> 00:06:16,196
because we think it's important
that you understand that level


123
00:06:16,396 --> 00:06:18,636
of programming especially
if you are using some


124
00:06:18,636 --> 00:06:19,836
of these high-level tools.


125
00:06:20,076 --> 00:06:22,436
You have some hints as to
what might be going wrong


126
00:06:22,436 --> 00:06:24,986
and what you can do to
improve your content.


127
00:06:25,326 --> 00:06:27,416
Before I get into that, I just
want to talk about one thing


128
00:06:27,736 --> 00:06:30,026
which is motivation,
why we're doing this.


129
00:06:30,026 --> 00:06:33,956
So, Apple has always considered
rich, powerful graphics


130
00:06:33,956 --> 00:06:36,426
to be super important
to web developers


131
00:06:36,426 --> 00:06:37,656
and to the Safari engine.


132
00:06:37,656 --> 00:06:39,926
And in fact, this is
why about a decade ago,


133
00:06:39,926 --> 00:06:41,346
we invented the <canvas> element


134
00:06:41,556 --> 00:06:43,706
which is what the
basis of WebGL is.


135
00:06:45,146 --> 00:06:48,576
As soon as WebGL was announced,
we joined the working group


136
00:06:48,946 --> 00:06:50,806
and to this day, we
volunteer ourselves


137
00:06:50,806 --> 00:06:52,366
as the editor of
the specification.


138
00:06:52,916 --> 00:06:55,216
So, next question is
why do we choose OpenGL?


139
00:06:55,316 --> 00:06:58,736
OpenGL is the most important
standard graphics API


140
00:06:58,736 --> 00:07:00,506
that's around.


141
00:07:00,506 --> 00:07:02,326
It's already been demonstrated.


142
00:07:02,326 --> 00:07:04,476
It can run on a billion
mobile devices.


143
00:07:04,476 --> 00:07:07,416
And the content you can create
there is still just amazing


144
00:07:07,416 --> 00:07:09,676
on other devices or more
powerful devices as well.


145
00:07:10,456 --> 00:07:12,846
So, again, it sort
of made a no-brainer


146
00:07:12,846 --> 00:07:14,666
that we choose the best
standard and that way,


147
00:07:14,666 --> 00:07:16,926
all browsers can implement
it and we end up with WebGL.


148
00:07:17,516 --> 00:07:21,306
OK. So, let's get coding.


149
00:07:21,716 --> 00:07:25,346
Like all programming examples,
we want to start with "Hello,


150
00:07:25,346 --> 00:07:29,416
world" and we got to the
"Hello, world" of WebGL.


151
00:07:29,786 --> 00:07:31,946
So, imagine you're
opening your text editor


152
00:07:32,276 --> 00:07:33,966
and we're starting
with a blank slate.


153
00:07:33,966 --> 00:07:35,566
We're just going to
type a few commands


154
00:07:35,566 --> 00:07:39,846
and create something that's
this 3D interactive environment.


155
00:07:39,846 --> 00:07:43,456
We're actually going to start
with something very simple


156
00:07:43,456 --> 00:07:44,456
which is just a triangle.


157
00:07:44,776 --> 00:07:47,936
But while that might sound
disappointing, if we go back


158
00:07:47,936 --> 00:07:49,816
to the 3D environment,
we look at it


159
00:07:49,816 --> 00:07:52,936
and think actually-let's take
a look-it's actually made


160
00:07:52,936 --> 00:07:55,016
up of millions of
little triangles and each


161
00:07:55,016 --> 00:07:56,476
of those triangles have color


162
00:07:56,596 --> 00:07:58,956
or texture applied
or some lighting.


163
00:07:59,466 --> 00:08:01,566
And then we're rendering
it again with another pass


164
00:08:01,566 --> 00:08:05,256
where we might be doing blurs
or glows or shadows or whatever.


165
00:08:05,416 --> 00:08:07,186
And when you combine
them all together,


166
00:08:07,186 --> 00:08:09,576
you actually do get
the advanced rendering.


167
00:08:09,916 --> 00:08:13,986
So, you learn a lot of detail
from how to draw one triangle


168
00:08:14,156 --> 00:08:16,816
and the power that you learn
goes on to create better things.


169
00:08:18,226 --> 00:08:20,436
So, let's start creating,
configuring and drawing.


170
00:08:20,436 --> 00:08:22,146
And for that, we need 4 things.


171
00:08:22,696 --> 00:08:26,376
First, we're going to
need somewhere to draw to,


172
00:08:26,376 --> 00:08:27,486
something to draw on to.


173
00:08:28,226 --> 00:08:29,716
Then, we're going to need
something to draw with.


174
00:08:29,936 --> 00:08:32,296
Then, we're going to
configure that thing,


175
00:08:32,456 --> 00:08:33,785
choose what paint we
want to paint with.


176
00:08:33,785 --> 00:08:36,176
And lastly, we got
to do the drawing.


177
00:08:36,176 --> 00:08:38,135
We'll go through each of
these steps one by one.


178
00:08:38,885 --> 00:08:41,596
So, let's start with
something to draw onto.


179
00:08:41,726 --> 00:08:44,786
And artists like myself
call this a canvas


180
00:08:45,146 --> 00:08:46,806
which is super convenient


181
00:08:46,806 --> 00:08:49,176
because HTML already has
an element called <canvas>.


182
00:08:49,686 --> 00:08:50,456
So, we'll use that.


183
00:08:50,456 --> 00:08:54,336
And this is like a regular
image element except instead


184
00:08:54,336 --> 00:08:58,256
of getting the graphics to draw
from say, a file on the web,


185
00:08:58,546 --> 00:09:01,776
you provide the commands
in JavaScript that draw


186
00:09:01,776 --> 00:09:03,676
into the image and then
the browser renders that.


187
00:09:04,136 --> 00:09:06,376
You might already have one in
your page as a <canvas> element


188
00:09:06,506 --> 00:09:09,266
or you can create one through
JavaScript via createElement.


189
00:09:09,916 --> 00:09:11,086
In my example, I'm
going to pretend


190
00:09:11,086 --> 00:09:12,976
that I've already got one
in the page and I'm going


191
00:09:12,976 --> 00:09:16,036
to select it using the DOM
API and I'm going to store


192
00:09:16,036 --> 00:09:17,686
in the local variable
"canvas" 'cause I want


193
00:09:17,686 --> 00:09:18,786
to reference to it later.


194
00:09:19,616 --> 00:09:20,886
Now, before I can draw into it,


195
00:09:21,196 --> 00:09:23,956
I need to tell the system
how big an image it is


196
00:09:23,956 --> 00:09:26,216
or how many pixels it
needs to allocate so that


197
00:09:26,216 --> 00:09:28,986
when I draw the rendering
happens into that image.


198
00:09:28,986 --> 00:09:31,506
And I do that by
setting the width


199
00:09:31,506 --> 00:09:33,506
and height variables
on the canvas.


200
00:09:33,806 --> 00:09:37,526
Here, I want to set it to 600
by 400 but also I want to take


201
00:09:37,526 --> 00:09:39,606
into account if I'm
on a Retina display,


202
00:09:39,606 --> 00:09:41,016
I want a higher resolution
image,


203
00:09:41,016 --> 00:09:43,086
so I'm querying
window.devicePixelRatio.


204
00:09:44,796 --> 00:09:46,476
That's all I need for
something to draw.


205
00:09:46,476 --> 00:09:48,316
The next thing is I need
something to draw with.


206
00:09:48,526 --> 00:09:51,476
And in WebGL, that is the
WebGLRenderingContext.


207
00:09:51,476 --> 00:09:54,116
This is the object that
exposes the entire WebGL API.


208
00:09:54,116 --> 00:09:58,346
In code form, you do
that-you get one quite easily.


209
00:09:58,346 --> 00:10:01,616
You just call getContext passing
the string parameter WebGL.


210
00:10:02,756 --> 00:10:04,596
If you're familiar with
2D Canvas rendering,


211
00:10:04,596 --> 00:10:08,026
you would have seen someone
call this with a 2D string


212
00:10:08,026 --> 00:10:08,966
and you get the 2D API.


213
00:10:08,966 --> 00:10:11,526
So here, we've-we'd
code it with WebGL


214
00:10:11,526 --> 00:10:13,536
and we have a variable
called GL,


215
00:10:13,536 --> 00:10:15,086
which is the thing
we got to draw with.


216
00:10:15,986 --> 00:10:19,016
If you're familiar with
Native OpenGL programming,


217
00:10:19,246 --> 00:10:22,086
you might be wondering where
did I set my pixel format


218
00:10:22,086 --> 00:10:24,516
and create my render buffers
and frame buffers, et cetera,


219
00:10:24,846 --> 00:10:26,206
you don't have to
do that in WebGL.


220
00:10:27,216 --> 00:10:29,736
The previous step allocated the
image that you got to draw into


221
00:10:29,736 --> 00:10:31,876
and this step is giving you
the context that you got


222
00:10:31,876 --> 00:10:35,166
to draw with, that's
all you have to do.


223
00:10:35,396 --> 00:10:37,876
Next, we're going to
need something to-We need


224
00:10:37,876 --> 00:10:39,336
to configure the
system and this is


225
00:10:39,336 --> 00:10:40,536
where it gets a little
bit tricky


226
00:10:40,536 --> 00:10:42,616
so if-with only a few
lines, we've got something


227
00:10:42,616 --> 00:10:45,046
to draw with, now we're
getting into the native system.


228
00:10:45,226 --> 00:10:48,406
We got to give-This
is where we're got


229
00:10:48,406 --> 00:10:50,666
to start the crash
course in WebGL rendering.


230
00:10:51,556 --> 00:10:52,966
Before we are able
to render something,


231
00:10:52,966 --> 00:10:54,206
we need to do a few things.


232
00:10:54,206 --> 00:10:56,206
We need to create buffers.


233
00:10:56,206 --> 00:10:57,566
And buffers are just
a set of data


234
00:10:57,566 --> 00:10:59,206
that we got to upload
to the GPU.


235
00:10:59,646 --> 00:11:01,206
And that data can be
any types of things


236
00:11:01,206 --> 00:11:03,326
but they're almost certainly
got to contain the geometry


237
00:11:03,326 --> 00:11:04,226
that we want to render.


238
00:11:05,076 --> 00:11:07,946
Next thing we need is a
program which is going


239
00:11:07,946 --> 00:11:09,936
to be the actual way
that WebGL renders it.


240
00:11:10,356 --> 00:11:12,416
Now, you're going to
be a bit confused here


241
00:11:12,416 --> 00:11:14,906
because we're already making a
program what's-is this another


242
00:11:14,906 --> 00:11:17,316
program and the answer
is it is, we got to get


243
00:11:17,316 --> 00:11:18,746
into the details of
what it is later.


244
00:11:18,746 --> 00:11:21,756
But just imagine that you got to
be writing some specialized code


245
00:11:21,756 --> 00:11:24,386
that gets uploaded also to
the GPU and executed there.


246
00:11:24,706 --> 00:11:25,996
Let's start with the buffers.


247
00:11:26,156 --> 00:11:28,726
I want to draw this triangle,


248
00:11:28,726 --> 00:11:31,136
and the triangle is just
made up of 3 points.


249
00:11:32,056 --> 00:11:34,486
In WebGL, the coordinate
system goes from minus 1,


250
00:11:34,486 --> 00:11:38,616
minus 1 on the bottom left to 1,
1, on the top right and I want


251
00:11:38,616 --> 00:11:40,356
to create a buffer
out of these 3 points.


252
00:11:40,436 --> 00:11:43,636
So, what I'm going to
do is allocate 6 values,


253
00:11:43,636 --> 00:11:45,506
an array of 6 values
and I'm going


254
00:11:45,506 --> 00:11:49,086
to map those points
to those 6 values.


255
00:11:49,086 --> 00:11:53,306
So here, I've got (X1,
Y1), (X2, Y2), (X3, Y3).


256
00:11:53,306 --> 00:11:56,536
This is all I need
to upload to the GPU.


257
00:11:56,536 --> 00:11:59,446
So, I'm going to show you how to
do that in WebGL.In JavaScript,


258
00:11:59,756 --> 00:12:01,926
we just start with
the array of 6 values.


259
00:12:01,926 --> 00:12:03,706
This is a JavaScript array.


260
00:12:03,706 --> 00:12:07,236
And I'm going to assign
it into a Float32Array.


261
00:12:07,236 --> 00:12:09,346
And this is a special
type array in JavaScript


262
00:12:09,346 --> 00:12:12,576
and that's telling the system
that I want it to imagine


263
00:12:12,576 --> 00:12:15,746
or allocate this data
as a fixed-length array


264
00:12:16,046 --> 00:12:19,246
where each value is a full
byte floating point number.


265
00:12:19,936 --> 00:12:22,456
This comes in handy because
when we upload it to the GPU,


266
00:12:22,636 --> 00:12:25,606
we've already told the system
what the type of data is


267
00:12:25,606 --> 00:12:27,036
and that way, it-so
it doesn't have


268
00:12:27,036 --> 00:12:28,886
to do another conversion
from JavaScript.


269
00:12:29,496 --> 00:12:31,326
So, they actually
create the buffer.


270
00:12:31,326 --> 00:12:34,856
I'm going to call it
createBuffer command.


271
00:12:35,136 --> 00:12:37,496
And now I'm going to provide
the data that is going


272
00:12:37,496 --> 00:12:38,696
to be uploaded through the GPU.


273
00:12:38,696 --> 00:12:40,786
So, I just tell it, "That
buffer you just created?


274
00:12:41,026 --> 00:12:43,946
Send that vertex-vertices
variable up there."


275
00:12:43,946 --> 00:12:45,646
And that's all we have
to do to create a buffer.


276
00:12:45,646 --> 00:12:49,316
Now, we're going to
talk about the program.


277
00:12:49,836 --> 00:12:52,936
Now, conceptually, what
we're doing is we've got some


278
00:12:52,936 --> 00:12:55,706
JavaScript commands we're
executing and then we're going


279
00:12:55,706 --> 00:12:57,256
to end up with pixels
on the screen.


280
00:12:57,256 --> 00:13:01,556
But what really happens is that
we process some JavaScript,


281
00:13:01,726 --> 00:13:04,016
it gets sent to the
WebGL rendering pipeline


282
00:13:04,016 --> 00:13:05,316
and it's the thing that draws.


283
00:13:05,316 --> 00:13:06,846
So, we've really got to
understand what's happening


284
00:13:06,846 --> 00:13:08,396
in the WebGL rendering pipeline.


285
00:13:08,676 --> 00:13:10,346
Now, you can look
up OpenGL textbooks


286
00:13:10,346 --> 00:13:12,846
and they all explain the
same thing, but it's made


287
00:13:12,846 --> 00:13:14,426
up of basically 8 steps,


288
00:13:14,426 --> 00:13:16,936
and each of these 8 steps you
have different configuration


289
00:13:16,936 --> 00:13:18,136
options you can pass to them.


290
00:13:18,976 --> 00:13:21,516
But these 2 that you have
almost complete control of over


291
00:13:21,516 --> 00:13:23,206
and they're the 2
most important ones


292
00:13:23,206 --> 00:13:24,796
and the ones we're going
to talk about today.


293
00:13:24,796 --> 00:13:26,356
And that's the Vertex
Shader step


294
00:13:26,356 --> 00:13:27,686
and the Fragment Shader step.


295
00:13:28,486 --> 00:13:31,236
If we take them in isolation,
we can really consider


296
00:13:31,236 --> 00:13:33,076
that for the sake of
this presentation,


297
00:13:33,236 --> 00:13:34,596
I'm executing JavaScript.


298
00:13:34,596 --> 00:13:36,806
I'm going to send the commands
into the Vertex Shader.


299
00:13:37,036 --> 00:13:38,646
The Vertex Shader is going
to do something with it,


300
00:13:38,646 --> 00:13:41,126
send the command-send the
output onto the Fragment Shader


301
00:13:41,126 --> 00:13:43,026
which is going to do
something to it and eventually,


302
00:13:43,026 --> 00:13:44,356
we get the pixels on the screen.


303
00:13:45,006 --> 00:13:46,786
And this combination
of the Vertex Shader


304
00:13:46,786 --> 00:13:48,596
and the Fragment Shader
is what we were referring


305
00:13:48,596 --> 00:13:49,886
to as the program before.


306
00:13:50,416 --> 00:13:53,966
Now, Shaders are these little
programs that you got to write


307
00:13:53,966 --> 00:13:55,706
in another language
which we'll get to later


308
00:13:55,706 --> 00:13:57,756
and they're the things
that execute on the GPU.


309
00:13:57,756 --> 00:13:58,796
And the reason there's two


310
00:13:58,796 --> 00:14:00,466
of them is they have two
different operations.


311
00:14:00,786 --> 00:14:02,726
The Vertex Shader is
mostly about geometry.


312
00:14:02,726 --> 00:14:05,626
So, you're passing in
points to it and it's got


313
00:14:05,626 --> 00:14:07,396
to output converted points.


314
00:14:07,996 --> 00:14:10,206
The Fragment Shader is
really about what color


315
00:14:10,206 --> 00:14:12,976
of pixels you're going to do
based on the input of points.


316
00:14:13,616 --> 00:14:17,596
If we rotate this diagram
clockwise 90 degrees,


317
00:14:18,086 --> 00:14:18,996
we'll look at it another way.


318
00:14:18,996 --> 00:14:21,576
Here, I've got the buffer
that I've allocated before


319
00:14:21,576 --> 00:14:22,846
and I've uploaded to the GPU.


320
00:14:22,846 --> 00:14:24,526
I'm going to send it
into the Vertex Shader.,


321
00:14:24,526 --> 00:14:26,516
except it doesn't
quite work this way.


322
00:14:26,516 --> 00:14:28,926
And this is where the power
of GPUs comes in to play.


323
00:14:28,926 --> 00:14:32,946
I'm actually going to separate
each of those by buffering


324
00:14:32,946 --> 00:14:35,336
to a set of three
vertices and it gets sent


325
00:14:35,336 --> 00:14:37,496
to a different instance
of the Vertex Shader.


326
00:14:37,496 --> 00:14:40,606
And these were all executed
in parallel on the GPU.


327
00:14:40,606 --> 00:14:42,126
And this is where you get
this great performance.


328
00:14:42,656 --> 00:14:45,786
So, given a Vertex,
which is just the (x,


329
00:14:45,786 --> 00:14:47,866
y) point in this case,
the Vertex Shader is going


330
00:14:47,866 --> 00:14:49,926
to do something and
create another point


331
00:14:50,116 --> 00:14:51,476
and send it back to the system.


332
00:14:51,716 --> 00:14:54,286
And when the system has
collected all the points,


333
00:14:54,286 --> 00:14:56,116
it's going to do what's
called rasterization.


334
00:14:56,396 --> 00:14:59,016
So, it now knows where the
geometry on the screen is going


335
00:14:59,016 --> 00:15:01,356
to be displayed and which
pixels are going to be touched.


336
00:15:01,356 --> 00:15:04,656
But it still doesn't know
what color to draw the pixels


337
00:15:05,026 --> 00:15:07,256
and it's-this is the next
step where it's very similar


338
00:15:07,256 --> 00:15:08,306
to the Vertex Shader steps.


339
00:15:08,306 --> 00:15:10,516
It's going to take all those
pixels and then send them


340
00:15:10,516 --> 00:15:12,456
out to a bunch of
parallel instances


341
00:15:12,456 --> 00:15:13,406
of the Fragment Shaders.


342
00:15:13,406 --> 00:15:15,206
And the Fragment Shaders
just have the one task:


343
00:15:15,496 --> 00:15:17,396
given a pixel, what
color should it be?


344
00:15:18,176 --> 00:15:19,776
Let's look at the code for this.


345
00:15:19,966 --> 00:15:24,526
I'm going to start by creating
a vertexShader object which I do


346
00:15:24,526 --> 00:15:26,716
by createShader,
passing in the parameter,


347
00:15:26,716 --> 00:15:28,936
telling it that it's going
to be of type, vertex shader.


348
00:15:29,356 --> 00:15:30,406
And next, I'm going to tell it


349
00:15:30,406 --> 00:15:32,256
to provide some source
code for the shader.


350
00:15:32,256 --> 00:15:33,966
I'm not showing you the
source code at the moment


351
00:15:34,146 --> 00:15:36,116
but you can just imagine I'm
getting it from somewhere.


352
00:15:36,116 --> 00:15:37,946
It might be I create
it by JavaScript


353
00:15:38,196 --> 00:15:40,426
or I might have preloaded it
or got it from the internet


354
00:15:40,616 --> 00:15:41,516
and we'll get to that later.


355
00:15:41,516 --> 00:15:44,246
I'm going to compile it, which
is turning it into commands


356
00:15:44,246 --> 00:15:46,116
that we can use later
on the GPU.


357
00:15:46,506 --> 00:15:48,376
I do the same thing with
the Fragment Shader.


358
00:15:48,736 --> 00:15:50,096
It's pretty much identical.


359
00:15:50,096 --> 00:15:50,606
Of course, I'm going


360
00:15:50,606 --> 00:15:52,316
to use different source
code, which we'll see.


361
00:15:53,116 --> 00:15:55,686
Once we have those two
objects, the vertexShader


362
00:15:55,686 --> 00:15:58,576
and the fragmentShader, I
want to create a program


363
00:15:58,886 --> 00:16:01,426
and we tell the program that
it's two objects that it needs


364
00:16:01,426 --> 00:16:03,306
to talk to, or the two
shaders we created.


365
00:16:03,306 --> 00:16:06,696
I'm going to link it and then
lastly, I'm going to tell WebGL


366
00:16:06,696 --> 00:16:08,526
that this is the
program I want you to use


367
00:16:08,526 --> 00:16:09,616
when you do your drawing.


368
00:16:10,216 --> 00:16:12,626
So, that's all we have
to do for configuration.


369
00:16:12,626 --> 00:16:15,976
So, we now have a setup where
we have something to draw,


370
00:16:16,086 --> 00:16:18,696
we have something to draw with
and we've configured it to draw


371
00:16:18,696 --> 00:16:21,146
and the last thing we need to
do is render our masterpiece.


372
00:16:23,966 --> 00:16:26,226
Now, the next tricky step.


373
00:16:26,746 --> 00:16:28,436
I haven't shown you
any source code


374
00:16:28,966 --> 00:16:31,726
but what we-what the general
idea is here, we have a bunch


375
00:16:31,726 --> 00:16:34,016
of WebGL-we have a
bunch of JavaScript


376
00:16:34,066 --> 00:16:36,376
and we have some buffers on
the GPU that are what I want


377
00:16:36,376 --> 00:16:39,036
to render and I've got these
programs that I got to render it


378
00:16:39,076 --> 00:16:41,906
and I need to, through
JavaScript,


379
00:16:42,186 --> 00:16:45,716
tell the system how I'm binding
the data in those buffers


380
00:16:45,996 --> 00:16:47,466
to variables in my program.


381
00:16:47,466 --> 00:16:49,096
And you'll see the variables
in the program later.


382
00:16:49,096 --> 00:16:52,096
But the first thing I'm going
to do here is say, when you come


383
00:16:52,096 --> 00:16:54,246
to execute the program, there's
going to be a variable called


384
00:16:54,246 --> 00:16:57,656
"aPosition" and I want you
to associate every vertex


385
00:16:57,756 --> 00:17:00,886
in the-that you've uploaded
as a buffer to that variable.


386
00:17:01,226 --> 00:17:05,486
Next, when you actually
go to use the buffer,


387
00:17:05,486 --> 00:17:09,506
I have to tell the system that,
well, I've uploaded X, Y, X, Y,


388
00:17:09,506 --> 00:17:11,396
X, Y so I want you to assume


389
00:17:11,396 --> 00:17:15,236
that when you're processing this
buffer, take it two at a time


390
00:17:15,236 --> 00:17:16,806
and that they're
floating point values.


391
00:17:18,896 --> 00:17:20,296
Then, I just have to draw.


392
00:17:20,476 --> 00:17:21,146
I've sent a buffer.


393
00:17:21,146 --> 00:17:23,016
I'm going to draw the vertices


394
00:17:23,016 --> 00:17:25,656
in the buffer starting position
zero and I've got three of them


395
00:17:25,656 --> 00:17:28,506
which makes the three points
in the triangle and eventually,


396
00:17:28,806 --> 00:17:31,096
we end up with a
triangle on the screen.


397
00:17:31,286 --> 00:17:35,446
Now that-if we have to look at
the source code all at once,


398
00:17:35,446 --> 00:17:36,696
you might be a little
bit worried


399
00:17:36,696 --> 00:17:38,246
that it was actually a
fair bit of source code.


400
00:17:38,246 --> 00:17:40,096
I've skipped some in the
slides because I wanted


401
00:17:40,096 --> 00:17:41,276
to add some error
checking or whatever.


402
00:17:41,276 --> 00:17:43,826
But the important thing is
actually while you only drew a


403
00:17:43,826 --> 00:17:45,796
red triangle, there's
an insane amount


404
00:17:45,796 --> 00:17:47,796
of power behind that
red triangle.


405
00:17:48,006 --> 00:17:49,396
That power comes
from the shaders


406
00:17:49,396 --> 00:17:52,696
and that's what we're
going to look at next.


407
00:17:52,696 --> 00:17:54,576
So, I didn't show the
source code to the shaders,


408
00:17:54,576 --> 00:17:56,306
but we'll get into that.


409
00:17:56,306 --> 00:17:56,946
Shaders are written


410
00:17:56,946 --> 00:17:59,446
in a language called GL
Shading Language or GLSL.


411
00:18:00,526 --> 00:18:03,406
It's a C-like language
designed for parallel graphics.


412
00:18:04,706 --> 00:18:07,056
What this means is that
it's got-it looks like C


413
00:18:07,056 --> 00:18:10,306
but it's got some extra
primitives for vectors


414
00:18:10,306 --> 00:18:14,386
and matrices and also some
operations on those primitives


415
00:18:14,386 --> 00:18:16,046
so that you can multiply
matrices and whatever.


416
00:18:16,046 --> 00:18:17,526
You don't have to do
the math yourself.


417
00:18:17,646 --> 00:18:19,946
It also has a bunch
of built-in functions,


418
00:18:20,246 --> 00:18:23,806
such as trigonometry
functions or other operations


419
00:18:23,806 --> 00:18:25,806
on the matrices, like
dot products and normals


420
00:18:26,286 --> 00:18:29,476
and some other sort of helper
functions to make the -


421
00:18:29,476 --> 00:18:32,146
that are common in
graphics operations.


422
00:18:32,736 --> 00:18:36,266
Let's go back to the view
of the rendering pipe.


423
00:18:36,596 --> 00:18:38,076
So, I have the buffer
that I was sending off


424
00:18:38,106 --> 00:18:40,346
to multiple Vertex
Shaders that we're sending


425
00:18:40,346 --> 00:18:41,436
on to Fragment Shaders.


426
00:18:41,436 --> 00:18:43,176
But we'll simplify it
again and come back.


427
00:18:43,556 --> 00:18:46,056
Now, the data I was sending
in, the buffer at the top


428
00:18:46,056 --> 00:18:48,786
that you're familiar with,
I-at the moment, I only have X,


429
00:18:48,786 --> 00:18:52,176
Y positions but really you
can send any data into it.


430
00:18:52,316 --> 00:18:54,566
So here, I've just
added some other data.


431
00:18:54,566 --> 00:18:57,856
And again, this is the-these are
your input to the Vertex Shader.


432
00:18:57,856 --> 00:19:01,096
Each part, chunk of the buffer
is going to be associated


433
00:19:01,096 --> 00:19:04,666
with the vertex and sent in
to a Vertex Shader instance.


434
00:19:05,316 --> 00:19:07,686
But you might want to send data


435
00:19:07,686 --> 00:19:10,316
into the Vertex Shader that's
shared across all the instances


436
00:19:10,316 --> 00:19:12,816
that are running and you
do that by using uniforms.


437
00:19:13,446 --> 00:19:15,236
And these are global constants.


438
00:19:15,236 --> 00:19:17,626
So, good examples of this
might be the current frame


439
00:19:17,626 --> 00:19:20,336
of the animation that you want
to run or the mask position


440
00:19:20,336 --> 00:19:25,206
or the time-the rendering time
or maybe the camera position


441
00:19:25,256 --> 00:19:27,786
on matrix that you want to
do as a viewing position.


442
00:19:28,546 --> 00:19:31,706
So, the Vertex Shader is going
to operate on those two sets


443
00:19:31,706 --> 00:19:33,676
of inputs, one's
coming per vertex


444
00:19:33,676 --> 00:19:35,836
and the other one that's
coming as global variables


445
00:19:35,996 --> 00:19:38,246
and that only has one task
and that's to produce a point.


446
00:19:38,246 --> 00:19:40,026
And it produces that
point by writing


447
00:19:40,026 --> 00:19:42,356
to the global variable
called glPosition.


448
00:19:43,136 --> 00:19:45,146
The Fragment Shader
is quite similar.


449
00:19:45,146 --> 00:19:47,176
It's got to use the
position that was passed


450
00:19:47,176 --> 00:19:49,146
by the Vertex Shader
and any other data


451
00:19:49,146 --> 00:19:52,306
and the global constants and
it's going to write to one thing


452
00:19:52,306 --> 00:19:54,756
which is the color of the
pixel which it does by writing


453
00:19:54,756 --> 00:19:56,916
to the global variable,
GL fragment position.


454
00:19:57,426 --> 00:20:00,956
Let's look at the-finally,
look at the source code.


455
00:20:01,046 --> 00:20:02,606
So, my Vertex Shader,


456
00:20:02,606 --> 00:20:06,686
I've picked basically the most
simple Vertex Shader I can do.


457
00:20:07,316 --> 00:20:09,596
Now remember, we saw
that we were binding


458
00:20:09,756 --> 00:20:12,906
in JavaScript the
value aPosition-sorry,


459
00:20:12,906 --> 00:20:15,536
the variable aPosition to the
buffers that we passed in.


460
00:20:15,716 --> 00:20:16,986
Here's where I actually
get to do it.


461
00:20:17,216 --> 00:20:20,306
So here I am in the Vertex
Shader saying the data


462
00:20:20,306 --> 00:20:23,866
that comes in from the vertex,
I want you to associate it


463
00:20:23,866 --> 00:20:27,416
with the variable aPosition and
I'm doing the one thing I have


464
00:20:27,416 --> 00:20:29,016
to do which is writing
to gl-Position


465
00:20:29,016 --> 00:20:31,086
and I'm just writing the
same value that I got in.


466
00:20:31,086 --> 00:20:32,876
It's just sending the
inputs straight through.


467
00:20:33,396 --> 00:20:36,386
At this step, normally, you
would do something like map


468
00:20:36,386 --> 00:20:38,546
from your world coordinate
system


469
00:20:38,546 --> 00:20:40,726
into the camera coordinate
system,


470
00:20:40,726 --> 00:20:41,866
which then the camera maps it


471
00:20:41,866 --> 00:20:43,226
into the screen coordinate
system.


472
00:20:43,776 --> 00:20:47,036
But because I-the data I send
is actually really and already


473
00:20:47,036 --> 00:20:48,756
in the screen coordinate
system, I can just pass it


474
00:20:48,756 --> 00:20:49,746
through for convenience.


475
00:20:50,346 --> 00:20:53,946
The Fragment Shader is equally
simple-the Fragment Shader


476
00:20:53,946 --> 00:20:54,956
example is equally simple.


477
00:20:54,956 --> 00:20:56,286
I'll start with some
boilerplate.


478
00:20:56,286 --> 00:20:58,916
And the boilerplate is
telling the system what level


479
00:20:58,916 --> 00:21:01,906
of precision I want it to use
for floating point operations.


480
00:21:02,526 --> 00:21:05,586
And then I'm going to write
the color of the pixel and,


481
00:21:05,586 --> 00:21:08,426
in this case, I'm
writing to gl-FragColor.


482
00:21:08,426 --> 00:21:09,986
I'm going to write
every instance


483
00:21:09,986 --> 00:21:12,536
that the Fragment Shader is
writing the same value which,


484
00:21:12,536 --> 00:21:17,486
in this case is four-a vector
of four values which is the red,


485
00:21:17,486 --> 00:21:19,026
green, blue and alpha values.


486
00:21:19,336 --> 00:21:22,636
So here, I am writing
100 percent red, 0 green,


487
00:21:22,636 --> 00:21:24,336
0 blue and 100 percent alpha


488
00:21:24,336 --> 00:21:26,756
and this is why every
pixel came out as red.


489
00:21:26,756 --> 00:21:30,206
Now that was pretty simple.


490
00:21:30,206 --> 00:21:32,576
And to take it and show
you a little bit more power


491
00:21:32,576 --> 00:21:34,766
of the shaders, I'm going
to show a live demo.


492
00:21:35,896 --> 00:21:37,096
OK. So, here's our triangle.


493
00:21:37,646 --> 00:21:39,816
Now, this is running in
Safari and it's a web page


494
00:21:39,956 --> 00:21:41,946
and what you've got
is a-the top half


495
00:21:41,946 --> 00:21:44,566
of the screen is a WebGL canvas
that's drawing the triangle we


496
00:21:44,566 --> 00:21:45,206
did before.


497
00:21:45,596 --> 00:21:46,336
And the bottom half


498
00:21:46,336 --> 00:21:49,296
of the screen is showing the
source code to the shaders.


499
00:21:49,616 --> 00:21:52,456
So, in this case, it's
showing the Vertex Shader,


500
00:21:52,456 --> 00:21:56,156
and here's the Fragment Shader.


501
00:21:56,606 --> 00:21:58,586
And this whole environment
is live.


502
00:21:58,586 --> 00:22:00,616
So, if I make an edit
in the page here,


503
00:22:00,766 --> 00:22:03,176
it's going to grab the
source code out of the page,


504
00:22:03,286 --> 00:22:06,486
recompile the program, upload
it to the GPU and render again.


505
00:22:06,666 --> 00:22:08,236
It's actually rendering
constantly here.


506
00:22:08,236 --> 00:22:10,766
You just don't see it
because nothing's changing.


507
00:22:11,156 --> 00:22:12,106
So here's an example.


508
00:22:12,106 --> 00:22:17,256
Let's say here's the-me
writing the color of the pixel


509
00:22:17,256 --> 00:22:19,086
and I've set it to 1, 0, 0, 1.


510
00:22:19,086 --> 00:22:23,016
If I change this to just
1, I get full red, green,


511
00:22:23,016 --> 00:22:24,196
zero blue and I get yellow.


512
00:22:24,916 --> 00:22:27,486
Let's reset that and go
back to the Vertex Shader.


513
00:22:28,666 --> 00:22:33,036
So, you can see here is the
attribute that I'm passing in


514
00:22:33,036 --> 00:22:35,236
and I'm also passing
in some uniform values


515
00:22:35,236 --> 00:22:37,316
which is the time, as
in, every time I render,


516
00:22:37,316 --> 00:22:40,126
I update that value so that
I can read it in the shader.


517
00:22:40,196 --> 00:22:43,376
So, I could do something tricky
here like, well, maybe I want


518
00:22:43,376 --> 00:22:44,876
to do some kind of
coordinate transform.


519
00:22:44,876 --> 00:22:50,086
I want to make the
triangle twice as high


520
00:22:50,086 --> 00:22:52,616
so I just multiplied the Y
position or I can do something


521
00:22:52,616 --> 00:22:57,326
like if I take the attribute
in and I say I want the X value


522
00:22:57,326 --> 00:22:59,266
to be the Y value and the
Y value to be the X value,


523
00:22:59,266 --> 00:23:01,116
we've got this flipped triangle.


524
00:23:01,466 --> 00:23:04,166
I've got a preloaded one
which is doing it here.


525
00:23:04,976 --> 00:23:09,896
So, in this case, what I'm doing
is, I've got the input variable


526
00:23:09,896 --> 00:23:11,696
that I've post in called
time and I'm just mapping


527
00:23:11,696 --> 00:23:14,486
that between 0 and 1 and
calling it-assigning it


528
00:23:14,486 --> 00:23:15,796
to the variable called progress.


529
00:23:15,796 --> 00:23:17,966
And then when I come
to write the position,


530
00:23:18,226 --> 00:23:21,466
I'm just telling the position
that I want to interpolate


531
00:23:21,666 --> 00:23:24,056
between the X and
the Y positions using


532
00:23:24,056 --> 00:23:26,706
that progress value and that's
why you get this nice reflection


533
00:23:26,706 --> 00:23:28,016
across the diagonal axis.


534
00:23:28,926 --> 00:23:31,926
Let's reset again and go
back to the Fragment Shader.


535
00:23:32,906 --> 00:23:37,266
Now, we can do some cool
things in the Fragment Shader.


536
00:23:37,266 --> 00:23:40,606
For example, I've got
this communication


537
00:23:40,606 --> 00:23:42,956
between the Vertex Shader
and the Fragment Shader


538
00:23:42,956 --> 00:23:46,096
where I've alloc-of telling it,
the shader, where the position


539
00:23:46,096 --> 00:23:48,286
in X and Y is of the fragment.


540
00:23:48,476 --> 00:23:51,366
So, if I say instead of the
green value, I set it to be,


541
00:23:51,366 --> 00:23:55,716
say, fragPosition.x,
then we get a gradient


542
00:23:55,716 --> 00:23:59,306
because the value moves from
0 to 1 across the triangle.


543
00:24:00,256 --> 00:24:03,546
Again, I've got a preset one
so I don't have to type it out,


544
00:24:03,706 --> 00:24:04,986
but I'm doing something
similar here


545
00:24:04,986 --> 00:24:07,416
where the red value
is the X position,


546
00:24:07,596 --> 00:24:09,286
the green value is
the Y position


547
00:24:09,496 --> 00:24:11,816
and then the blue value
is oscillating over time


548
00:24:11,816 --> 00:24:13,916
so you get this nice
triangle that's moving.


549
00:24:14,066 --> 00:24:18,166
I'm kind of getting sick of the
triangle so let's have a look


550
00:24:18,166 --> 00:24:19,246
at it in wireframe mode.


551
00:24:19,536 --> 00:24:23,016
Now, we said that really GL is
about drawing lots of triangles.


552
00:24:23,016 --> 00:24:25,426
I want to draw a rectangle,


553
00:24:25,506 --> 00:24:27,696
which is really just two
triangles joined together.


554
00:24:27,696 --> 00:24:29,296
And if we go back
to the solid mode,


555
00:24:29,296 --> 00:24:31,246
you see that the same
animation is still running.


556
00:24:31,796 --> 00:24:35,646
Now, what's really impressive
is this program is running


557
00:24:35,646 --> 00:24:39,086
and calculating the value of
every pixel every time we draw.


558
00:24:39,086 --> 00:24:41,656
And this really blew my
mind when I first saw it


559
00:24:41,806 --> 00:24:43,596
but even this is a
pretty simple example


560
00:24:43,596 --> 00:24:45,516
and we can do way
more cool things.


561
00:24:45,516 --> 00:24:47,346
So, here's a little
bit more code.


562
00:24:49,256 --> 00:24:52,476
But what it's really doing is
just taking some sine waves


563
00:24:52,536 --> 00:24:56,016
and with slightly different
offsets and adding them


564
00:24:56,136 --> 00:24:58,086
up to get this interactive
thing.


565
00:24:58,086 --> 00:25:00,476
So, there's no images here,
it's all being calculated live.


566
00:25:00,616 --> 00:25:02,846
And the cool thing is you
can play around with stuff.


567
00:25:02,846 --> 00:25:05,806
So, here is where I
basically choose the frequency


568
00:25:05,806 --> 00:25:10,386
of the plasma so I can make it
a little bit higher by dividing


569
00:25:10,386 --> 00:25:14,996
by less and, let's say I
don't really like the colors,


570
00:25:14,996 --> 00:25:16,416
this is the-here's the point


571
00:25:16,416 --> 00:25:18,256
where I'm assigning
the color value.


572
00:25:18,256 --> 00:25:21,556
Let's say, instead of
minus 4, let's do plus 4,


573
00:25:21,556 --> 00:25:23,676
I like those colors
a little bit better.


574
00:25:23,826 --> 00:25:26,186
And I can go up here and
say, "Well, here's the number


575
00:25:26,186 --> 00:25:27,436
of iterations that
I'm adding up.


576
00:25:27,436 --> 00:25:30,186
So let's say, go down to 7.


577
00:25:31,006 --> 00:25:33,126
Let's do something like
3, kind of like that."


578
00:25:33,126 --> 00:25:36,706
This looks pretty cool.


579
00:25:36,916 --> 00:25:38,706
Now, as programmers you'll know


580
00:25:38,706 --> 00:25:40,646
that you can do cool
things like here.


581
00:25:40,646 --> 00:25:42,706
Let's say I want to
change the value of Pi,


582
00:25:42,706 --> 00:25:44,776
something that's quite hard
to do in the real world


583
00:25:44,776 --> 00:25:45,856
as far as I'm concerned.


584
00:25:46,046 --> 00:25:47,926
We will say something like 5, 6,


585
00:25:48,186 --> 00:25:50,626
or we can go-that's
kind of a nice effect.


586
00:25:51,226 --> 00:25:53,056
You can even do something
like crazy-what happens


587
00:25:53,706 --> 00:25:54,786
if I, hold on a second.


588
00:25:54,786 --> 00:25:57,106
Now, I came across
something earlier in the week


589
00:25:57,106 --> 00:26:00,076
which I really liked,
which was-I saw on the web


590
00:26:00,076 --> 00:26:01,816
and it was a guy and
his name is Israel


591
00:26:01,816 --> 00:26:04,496
and he saw the WWDC
branding and said, "Hey,


592
00:26:04,496 --> 00:26:07,056
I could write a Shader that
does this," and I asked him


593
00:26:07,056 --> 00:26:08,516
if I could use it
and here's the code.


594
00:26:08,836 --> 00:26:11,686
This is really cool, so this is
again a program that's running


595
00:26:11,686 --> 00:26:14,146
for every pixel every
time we draw and it's sort


596
00:26:14,146 --> 00:26:16,146
of this interactive WWDC logo.


597
00:26:16,146 --> 00:26:19,596
And you see, scroll down,
there's a fair bit of code.


598
00:26:19,686 --> 00:26:21,266
Amazing that it's all
running every step.


599
00:26:21,826 --> 00:26:24,286
Let's say I want to comment out
the final one and get black.


600
00:26:24,696 --> 00:26:26,366
You could sort of see what
he was doing in each step,


601
00:26:26,366 --> 00:26:27,286
so there's the gradient.


602
00:26:29,036 --> 00:26:31,536
There's the balls
that he was animating.


603
00:26:31,536 --> 00:26:34,026
And he sort of masked
them out to that


604
00:26:34,026 --> 00:26:36,126
and then eventually it
gets the square grid.


605
00:26:36,606 --> 00:26:39,276
I think this is really cool.


606
00:26:39,516 --> 00:26:43,486
So, I wrote this whole
system in a couple of hours,


607
00:26:43,836 --> 00:26:46,026
what's important to you is
that there's actually a couple


608
00:26:46,026 --> 00:26:47,946
of communities out there that
have something very similar,


609
00:26:47,946 --> 00:26:49,756
shadertoy.com and
the GLSL workspace,


610
00:26:49,756 --> 00:26:53,736
or becoming what is
called a playground, maybe.


611
00:26:54,016 --> 00:26:56,046
And if you look this up,
you'll see whole examples


612
00:26:56,046 --> 00:26:58,826
of amazing shaders that
will really blow your mind.


613
00:26:59,156 --> 00:27:04,296
So, in wrap up, shaders are
C-like programs that you write


614
00:27:04,856 --> 00:27:06,736
in GLSL and upload to the GPU.


615
00:27:07,016 --> 00:27:09,486
You get complete control
over the vertex positions


616
00:27:09,486 --> 00:27:13,296
that you pass in and the
color of the pixels you render


617
00:27:13,296 --> 00:27:15,296
to the screen and they're
extremely powerful.


618
00:27:16,616 --> 00:27:19,326
So with that, I'm going to pass
it on to my colleague Brady.


619
00:27:19,596 --> 00:27:23,226
Who's going to talk to you about
how to do advanced rendering.


620
00:27:23,276 --> 00:27:26,276
>> Thank you, Dean.


621
00:27:27,856 --> 00:27:30,386
So, so far, we've seen
the Hello World program


622
00:27:30,386 --> 00:27:32,716
of WebGL, the basic triangle.


623
00:27:33,016 --> 00:27:35,526
And yeah, there was a
little bit of effort to get


624
00:27:35,526 --> 00:27:37,026
that basic triangle
on the screen.


625
00:27:37,026 --> 00:27:41,016
But once we'd gone through that
effort, with just a few lines


626
00:27:41,016 --> 00:27:42,306
of shader code, we start


627
00:27:42,306 --> 00:27:45,216
to achieve some pretty
fancy things pretty quickly.


628
00:27:46,616 --> 00:27:49,026
And there's a lot more to be
said about shaders and we'll get


629
00:27:49,026 --> 00:27:51,266
into that more very soon.


630
00:27:51,696 --> 00:27:53,996
But I want to start out focusing
back on that red triangle.


631
00:27:55,416 --> 00:27:56,756
So, what is that triangle?


632
00:27:57,066 --> 00:27:58,916
The triangle is three
points in space.


633
00:27:59,606 --> 00:28:03,666
I can rearrange those three
points and move this triangle


634
00:28:03,666 --> 00:28:05,356
and reshape it however
I'd like to.


635
00:28:05,866 --> 00:28:08,356
Make it really skinny and tall.


636
00:28:09,136 --> 00:28:12,126
Now, I have two triangles,
two slightly different colors.


637
00:28:12,506 --> 00:28:14,636
This is starting to look very
familiar to me for some reason.


638
00:28:15,686 --> 00:28:16,556
Oh, that's why.


639
00:28:16,906 --> 00:28:19,026
OK. So, that's part
of the needle


640
00:28:19,026 --> 00:28:20,676
of the compass in
the Safari logo.


641
00:28:22,256 --> 00:28:24,316
So, let's build up
on this a little bit.


642
00:28:25,066 --> 00:28:29,656
We're going to take the Safari
logo and we're going to bring it


643
00:28:29,656 --> 00:28:32,206
into the third dimension
using WebGL.


644
00:28:33,076 --> 00:28:35,016
So, this is the most
basic example


645
00:28:35,016 --> 00:28:37,456
of a 3D compass you could say.


646
00:28:38,906 --> 00:28:40,446
But except for that
picture on top,


647
00:28:40,706 --> 00:28:42,656
it's basically just a gray disc.


648
00:28:43,096 --> 00:28:48,136
So, this gray disc is
actually very similar


649
00:28:48,406 --> 00:28:50,216
to that red triangle
that we started out with.


650
00:28:50,776 --> 00:28:52,766
And by that I mean, it's nothing


651
00:28:52,766 --> 00:28:54,626
but a whole bunch
of triangles itself.


652
00:28:54,826 --> 00:28:58,416
As Dean has already mentioned,
even the most complex scenes


653
00:28:58,416 --> 00:29:01,946
in WebGL are just
hundreds, thousands,


654
00:29:01,946 --> 00:29:03,276
maybe even millions
of triangles.


655
00:29:03,276 --> 00:29:08,916
So, for each of those triangles,
we have three points of course.


656
00:29:09,966 --> 00:29:12,086
Let's go back to the code that
Dean has already showed us


657
00:29:12,496 --> 00:29:16,536
where we take three points
to make a basic flat triangle


658
00:29:16,536 --> 00:29:19,136
and upload it to the GPU.


659
00:29:19,336 --> 00:29:22,696
And for our disc, our
basic little gray disc,


660
00:29:22,976 --> 00:29:24,286
we're just going to
do more of the same,


661
00:29:26,016 --> 00:29:27,796
a lot more of the same.


662
00:29:28,926 --> 00:29:31,956
So, how did I get all
these coordinates here?


663
00:29:32,426 --> 00:29:33,536
I'll tell you what I didn't do.


664
00:29:33,646 --> 00:29:35,286
I didn't calculate them by hand.


665
00:29:35,286 --> 00:29:37,206
I didn't type them out by hand.


666
00:29:37,956 --> 00:29:39,116
I used a tool.


667
00:29:39,526 --> 00:29:44,076
As Dean has already touched on,
your toolbox is very important


668
00:29:44,076 --> 00:29:45,386
when programming with WebGL.


669
00:29:46,076 --> 00:29:48,276
Unless you're doing the
most basic of examples,


670
00:29:48,276 --> 00:29:51,666
a handful of triangles, you're
probably going to want to rely


671
00:29:52,046 --> 00:29:56,136
on 3D modeling tools,
preexisting 3D models


672
00:29:56,456 --> 00:30:00,926
to shape your geometry and
the appearance and get them


673
00:30:00,926 --> 00:30:02,076
into your WebGL program.


674
00:30:03,076 --> 00:30:04,086
There's great native tools.


675
00:30:04,086 --> 00:30:05,266
There's great web
tools out there.


676
00:30:05,266 --> 00:30:06,396
Dean touched on a few.


677
00:30:06,796 --> 00:30:08,166
But what they all
have in common is


678
00:30:08,166 --> 00:30:10,356
that they'll export vertex data.


679
00:30:11,586 --> 00:30:13,516
And that is any data you want.


680
00:30:13,776 --> 00:30:14,856
That's what a vertex is.


681
00:30:15,466 --> 00:30:20,336
It's any data you want
for any point you want.


682
00:30:20,516 --> 00:30:22,746
We've already touched on the
most obvious bit of this data,


683
00:30:22,746 --> 00:30:25,636
which is the coordinate:
the X, Y and Z coordinate


684
00:30:25,636 --> 00:30:26,806
of that point in space.


685
00:30:28,136 --> 00:30:31,206
We can also directly include
the color of the point.


686
00:30:31,866 --> 00:30:35,196
But then as we get into more
advanced graphics programming,


687
00:30:35,406 --> 00:30:37,496
we'll want to include the
normal vectors of the point.


688
00:30:37,996 --> 00:30:41,266
This tells WebGL which
direction the point is facing,


689
00:30:41,506 --> 00:30:43,916
which is important for things
such as lighting later on.


690
00:30:44,426 --> 00:30:49,786
And then we can also
include texture coordinates.


691
00:30:50,536 --> 00:30:52,036
So, what are textures?


692
00:30:52,586 --> 00:30:57,496
Textures are just flat bitmap
images, an array of pixels


693
00:30:57,796 --> 00:30:59,526
and each pixel has
a color to it.


694
00:30:59,766 --> 00:31:01,526
You know this as
an image, right?


695
00:31:01,526 --> 00:31:04,516
So, here's the Safari
icon; it's just an image.


696
00:31:05,046 --> 00:31:08,976
But what texture coordinates
do is they map those pixels


697
00:31:08,976 --> 00:31:11,626
from the image onto our
three-dimensional shape.


698
00:31:12,376 --> 00:31:15,036
So, we can have the
basic, uncolored 3D shape


699
00:31:15,366 --> 00:31:18,786
and use a flat image to define
what colors it will show.


700
00:31:19,296 --> 00:31:21,936
So, how does this look in code?


701
00:31:23,146 --> 00:31:25,696
Back to our example of uploading
the geometry of our shape


702
00:31:25,766 --> 00:31:27,506
onto the GPU for use


703
00:31:27,506 --> 00:31:29,906
in our shaders program-our
Shader programs,


704
00:31:30,516 --> 00:31:32,946
here's the first 10
pixels from the disc.


705
00:31:33,686 --> 00:31:36,986
So, for each of these
10 vertices,


706
00:31:37,336 --> 00:31:38,866
we have an X, Y and
a Z coordinate.


707
00:31:39,956 --> 00:31:43,446
And then our tool can also
output the texture coordinates.


708
00:31:44,116 --> 00:31:48,396
These are just X and Y
coordinates into a texture image


709
00:31:48,596 --> 00:31:50,306
to map the pixels
onto our geometry.


710
00:31:51,106 --> 00:31:54,566
Instead of working from
the native pixel count


711
00:31:54,566 --> 00:31:57,146
of the image, it
works from 0 to 1.


712
00:32:00,856 --> 00:32:03,516
So, once we have that
data from our tool,


713
00:32:03,516 --> 00:32:05,636
we need to get it onto the GPU.


714
00:32:06,216 --> 00:32:08,796
So, you've already seen the code
that Dean showed us about how


715
00:32:08,796 --> 00:32:11,966
to get the position
vertices up onto the GPU.


716
00:32:12,046 --> 00:32:14,346
We're going to do a
little bit more of the same


717
00:32:14,346 --> 00:32:16,506
to get the texture
coordinates to the GPU.


718
00:32:17,176 --> 00:32:19,436
We're going to specify
a new attribute.


719
00:32:19,436 --> 00:32:24,246
Remember, an attribute is a way
to specify to the GPU the inputs


720
00:32:24,246 --> 00:32:25,506
into the shader programs.


721
00:32:26,136 --> 00:32:27,856
And we're going to
say that the input


722
00:32:27,856 --> 00:32:30,826
to the texture coordinate
attribute is our texture


723
00:32:30,826 --> 00:32:31,936
coordinate buffer.


724
00:32:32,436 --> 00:32:35,976
And then, we'll go ahead
and upload the data


725
00:32:35,976 --> 00:32:41,166
from that JavaScript
array onto the GPU.


726
00:32:41,656 --> 00:32:43,656
Now, back to our Vertex
Shader source code.


727
00:32:44,296 --> 00:32:46,746
This is the most basic
Vertex Shader example


728
00:32:46,746 --> 00:32:48,086
that Dean had showed
us, where we have


729
00:32:48,356 --> 00:32:50,026
that position attribute
as an input.


730
00:32:50,026 --> 00:32:53,506
We'll just go ahead and add the
texture coordinate attribute


731
00:32:53,786 --> 00:32:54,836
as an input as well.


732
00:32:54,836 --> 00:32:56,666
And now, it's available
to the Vertex Shader.


733
00:32:56,666 --> 00:33:01,776
One of the examples Dean showed


734
00:33:01,776 --> 00:33:05,206
in the demo had what's
called a varying variable


735
00:33:05,206 --> 00:33:06,036
in the shader program.


736
00:33:06,166 --> 00:33:08,456
He didn't touch on what that
is, so I'll tell you now.


737
00:33:08,926 --> 00:33:11,596
A varying variable is
a quick and easy way


738
00:33:11,596 --> 00:33:13,816
for the two shader
programs to share data.


739
00:33:14,316 --> 00:33:16,976
So, by declaring the
vTextureCoord variable,


740
00:33:17,656 --> 00:33:20,626
we can pass data from the Vertex
Shader to the Fragment Shader.


741
00:33:21,136 --> 00:33:24,936
And then, since we've already
pre-calculated what the texture


742
00:33:24,936 --> 00:33:27,746
coordinates are, we don't need
to transform them in any way.


743
00:33:28,156 --> 00:33:30,766
We're just going to pass them on
directly to our Fragment Shader.


744
00:33:32,436 --> 00:33:34,976
So, over in the Fragment
Shader source code,


745
00:33:35,826 --> 00:33:37,756
you'll make a similar change.


746
00:33:38,036 --> 00:33:40,296
We'll declare that texture
coordinate attribute


747
00:33:40,856 --> 00:33:42,916
and now it's available
in the Fragment Shader.


748
00:33:44,156 --> 00:33:45,636
So, this is the texture
coordinates.


749
00:33:45,816 --> 00:33:47,026
We've gotten them from our tool.


750
00:33:47,236 --> 00:33:48,906
We've gotten the
JavaScript array for them.


751
00:33:49,146 --> 00:33:50,716
We've uploaded them to the GPU.


752
00:33:50,836 --> 00:33:52,126
Now, the coordinates
are available


753
00:33:52,126 --> 00:33:53,316
in that Fragment Shader program.


754
00:33:54,436 --> 00:33:56,156
Now, we need to worry
about the texture itself.


755
00:33:56,606 --> 00:34:03,086
So, the way WebGL gets the
pixel data from an image


756
00:34:03,146 --> 00:34:05,036
that is your texture and uses it


757
00:34:05,036 --> 00:34:08,716
in the shader programs
is by using a sampler.


758
00:34:10,005 --> 00:34:12,485
So, back on our JavaScript where
we're configuring our shaders,


759
00:34:12,886 --> 00:34:14,556
we'll just declare
a sampler variable.


760
00:34:14,985 --> 00:34:17,306
This is uniform variable
as Dean already mentioned,


761
00:34:17,306 --> 00:34:19,826
it's a global variable that
JavaScript can assign to,


762
00:34:20,156 --> 00:34:22,176
to pass some data into
the shader programs.


763
00:34:23,735 --> 00:34:27,775
So, once it's been declared
in JavaScript, we can go back


764
00:34:27,775 --> 00:34:30,596
to our Fragment Shader and
declare it there in GLSL.


765
00:34:31,856 --> 00:34:34,956
The type here is sampler2D,
that's one of the few types


766
00:34:35,536 --> 00:34:40,706
in the GL language that
operate on textures.


767
00:34:41,856 --> 00:34:44,356
And once we have that
sampler, we'll change


768
00:34:44,356 --> 00:34:47,226
that straight red color where
we're saying every pixel is red.


769
00:34:48,045 --> 00:34:51,056
And now, we'll use the sampler
with this quick function call.


770
00:34:51,056 --> 00:34:53,396
What this function
call does is it says,


771
00:34:53,866 --> 00:34:57,796
for the texture source
represented in the sampler,


772
00:34:58,346 --> 00:35:01,496
I want the color of the pixel
at this texture coordinate.


773
00:35:02,146 --> 00:35:04,156
And then we assign
it to gl-FragColor


774
00:35:04,156 --> 00:35:08,016
and that's what's going
to show up in the scene.


775
00:35:08,106 --> 00:35:09,106
So, Texture Source.


776
00:35:09,376 --> 00:35:10,936
What is a texture source?


777
00:35:12,036 --> 00:35:13,596
In OpenGL, it means one thing.


778
00:35:13,596 --> 00:35:16,276
Here in WebGL, we're working
with web technologies.


779
00:35:16,746 --> 00:35:18,936
There's a few different
options for your texture source.


780
00:35:19,646 --> 00:35:21,846
The most obvious is
the <img> element.


781
00:35:22,316 --> 00:35:26,206
If you have an image in your
HTML page, in the markup,


782
00:35:26,476 --> 00:35:27,776
and your page is
finished loading,


783
00:35:28,176 --> 00:35:30,686
you can use that image
element as a texture source.


784
00:35:31,286 --> 00:35:33,346
You can also create an
image element dynamically.


785
00:35:33,386 --> 00:35:35,056
And as long as you've
waited for it to load,


786
00:35:35,406 --> 00:35:40,416
those pixels are ready to
be uploaded to the GPU.


787
00:35:40,536 --> 00:35:41,866
You can also grab data


788
00:35:41,866 --> 00:35:44,826
from a server directly
using XMLHttpRequest.


789
00:35:45,556 --> 00:35:50,136
You can-XMLHttpRequest has the
ability to grab the raw bytes


790
00:35:50,136 --> 00:35:52,586
of the response and
that is used in WebGL


791
00:35:52,586 --> 00:35:57,196
to get those vertex
points into the shader.


792
00:35:57,706 --> 00:36:01,096
Then there's a <video> element.


793
00:36:01,456 --> 00:36:05,496
The video element is a great way
to display video in your webpage


794
00:36:05,886 --> 00:36:09,346
without using any plug-ins in
a native web technology manner


795
00:36:09,346 --> 00:36:11,636
that interacts with all the
other web technologies created.


796
00:36:12,036 --> 00:36:15,336
But what a video really is,
is just a sequence of images.


797
00:36:15,866 --> 00:36:18,496
So, if you use a video
element as your texture source


798
00:36:18,686 --> 00:36:20,686
when you're drawing a
frame of your scene,


799
00:36:21,106 --> 00:36:23,346
it'll grab the freeze frame
of whatever is being shown


800
00:36:23,346 --> 00:36:25,046
in the video element
at that point in time


801
00:36:25,536 --> 00:36:27,056
and that freeze frame
will be used


802
00:36:27,056 --> 00:36:28,326
as the image for the texture.


803
00:36:28,806 --> 00:36:35,626
Last but definitely not least,
some pretty cool possibilities


804
00:36:35,806 --> 00:36:38,516
with the <canvas> element
being used as a texture source.


805
00:36:39,156 --> 00:36:40,046
You can draw whatever you


806
00:36:40,046 --> 00:36:43,256
like into a canvas
element: an image, text.


807
00:36:43,866 --> 00:36:47,256
You can use the canvas 2D
drawing APIs to draw a 2D scene.


808
00:36:47,866 --> 00:36:50,286
You can also use the WebGL API


809
00:36:50,286 --> 00:36:52,996
to draw a three-dimensional
scene into a canvas,


810
00:36:52,996 --> 00:36:56,026
and then use that canvas
as a texture source


811
00:36:56,176 --> 00:36:57,586
for a different WebGL scene.


812
00:36:57,926 --> 00:37:01,506
This way you can render
one 3D scene to be used


813
00:37:01,506 --> 00:37:05,236
in another 3D scene for a
movie screen or a billboard


814
00:37:05,236 --> 00:37:07,796
or television or much
more creative ideas.


815
00:37:08,316 --> 00:37:12,556
But how this looks in code,
we're just going to stick


816
00:37:12,556 --> 00:37:13,826
to the basic image element.


817
00:37:14,306 --> 00:37:16,836
Here's an image element
I have in my HTML markup


818
00:37:17,286 --> 00:37:20,476
and it's pointing to an image
that represents the Safari logo.


819
00:37:20,566 --> 00:37:26,966
Now, in JavaScript, first,
we ask the GL context


820
00:37:27,136 --> 00:37:29,336
to create a texture and then,


821
00:37:29,796 --> 00:37:32,006
similar to what we've
done a few times,


822
00:37:32,346 --> 00:37:38,216
we bind-do some binding
voodoo to specify


823
00:37:38,216 --> 00:37:39,606
which texture we're working on.


824
00:37:40,236 --> 00:37:43,016
TEXTURE0: this constant
might seem a little weird.


825
00:37:43,616 --> 00:37:46,606
The story behind TEXTURE0
is that each program,


826
00:37:46,606 --> 00:37:50,266
each set of shader programs
can access up to 32 textures


827
00:37:50,266 --> 00:37:52,536
and there's a constant
for texture 0, 1,


828
00:37:52,536 --> 00:37:53,876
2, all the way up to 31.


829
00:37:54,326 --> 00:37:55,786
We're just using
1 in this example,


830
00:37:55,786 --> 00:37:57,076
so we'll stick with the first.


831
00:37:57,506 --> 00:38:00,176
Then we get our texture source.


832
00:38:00,606 --> 00:38:01,886
Using this basic DOM API,


833
00:38:02,006 --> 00:38:03,836
we grabbed a reference
to the image element.


834
00:38:04,386 --> 00:38:08,586
Now, this line of code is
where the magic happens.


835
00:38:09,126 --> 00:38:12,146
In this line of code, we're
updating the raw pixel data,


836
00:38:12,146 --> 00:38:15,606
the RGBA bytes, 8
bytes per component,


837
00:38:16,206 --> 00:38:18,956
and we're uploading it
to the GPU to be used


838
00:38:18,956 --> 00:38:19,946
in our shader programs.


839
00:38:20,476 --> 00:38:23,836
And the key in this line
is the texture source,


840
00:38:23,946 --> 00:38:25,756
and that's the image
element you've grabbed,


841
00:38:25,966 --> 00:38:29,176
and this is where you might put
the XMLHttpRequest, the <video>


842
00:38:29,176 --> 00:38:30,976
or the <canvas> element
as a texture source,


843
00:38:30,976 --> 00:38:31,866
if that's what you're doing.


844
00:38:32,336 --> 00:38:37,176
And then, we're going
to go ahead and interact


845
00:38:37,176 --> 00:38:40,036
with that uniform variable that
we created earlier, the sampler,


846
00:38:40,556 --> 00:38:42,166
and now we actually
need to set its value.


847
00:38:42,526 --> 00:38:44,636
And the value we're
setting here is zero


848
00:38:44,926 --> 00:38:46,576
because we're working
on TEXTURE0.


849
00:38:47,056 --> 00:38:49,646
Behind the scenes, WebGL
translates that into an object


850
00:38:49,646 --> 00:38:53,146
that says, "I'm going to
be sampling pixel data


851
00:38:53,546 --> 00:38:55,086
from texture image zero."


852
00:38:57,496 --> 00:39:02,546
Now, we're ready to go and that
Vertex Shader can put those


853
00:39:02,546 --> 00:39:04,476
pixels onto the screen
from our texture.


854
00:39:05,456 --> 00:39:09,886
So, using textures, we
can map a flat 2D image


855
00:39:10,166 --> 00:39:11,706
onto our 3D geometry.


856
00:39:12,216 --> 00:39:15,426
In this example I've been
talking about so far,


857
00:39:15,426 --> 00:39:16,666
it's a very basic disc


858
00:39:17,126 --> 00:39:20,136
and a very flat image that's
just mapping one to one.


859
00:39:21,256 --> 00:39:25,166
But using our tools, we can have
a much more complicated texture


860
00:39:25,366 --> 00:39:26,446
where different regions


861
00:39:26,446 --> 00:39:29,606
of the texture represent
different parts of the geometry


862
00:39:29,656 --> 00:39:31,676
and then we can have much
more geometry as well.


863
00:39:32,826 --> 00:39:34,506
So, I'd like to show
you a live demo


864
00:39:35,166 --> 00:39:36,876
of what we've talked
about so far.


865
00:39:37,226 --> 00:39:39,286
So, I'm not going to show
you any code in this demo.


866
00:39:39,386 --> 00:39:42,936
I just think it helps to
visualize what I've been talking


867
00:39:42,936 --> 00:39:44,636
about with these
texture coordinates


868
00:39:44,826 --> 00:39:46,036
by building up an example.


869
00:39:46,936 --> 00:39:49,896
So, here's our very basic
three-dimensional disc.


870
00:39:50,416 --> 00:39:55,266
You can see it's got a
wireframe which is nothing


871
00:39:55,266 --> 00:39:57,686
but a whole bunch of triangles
that build up this round shape.


872
00:39:58,106 --> 00:40:03,136
But as I alluded to in the slide
right before I started the demo,


873
00:40:03,136 --> 00:40:04,976
we can have a much more
complex version of this.


874
00:40:05,626 --> 00:40:09,186
We can build up the geometry
to represent the features


875
00:40:09,186 --> 00:40:11,096
of the compass in
three dimensions.


876
00:40:11,616 --> 00:40:17,516
And then, we can go ahead and
apply that complicated texture


877
00:40:17,516 --> 00:40:19,336
onto that geometry, and now,


878
00:40:19,336 --> 00:40:24,356
we have a live 3D
representation of a compass.


879
00:40:24,476 --> 00:40:28,136
Now, to really convince you it's
live, let's start animating.


880
00:40:29,506 --> 00:40:31,956
So, this is a really quick
little routine that's just


881
00:40:31,956 --> 00:40:34,016
animating a camera
around the compass,


882
00:40:34,356 --> 00:40:39,446
following some sign waves
and the time, just to kind


883
00:40:39,446 --> 00:40:41,356
of give an ooh, aah, view of it.


884
00:40:42,636 --> 00:40:45,006
To further convince you that
this is a live 3D model,


885
00:40:45,316 --> 00:40:47,356
I can show you that parts of it
are independent from another.


886
00:40:47,476 --> 00:40:49,356
So, let's go ahead and
start that needle spinning.


887
00:40:51,516 --> 00:40:55,406
So, all that data generated
using a tool, its output,


888
00:40:55,716 --> 00:40:58,246
the coordinate information,


889
00:40:58,446 --> 00:41:01,036
the texture-the position
coordinate information,


890
00:41:01,036 --> 00:41:02,456
the texture coordinate
information,


891
00:41:02,806 --> 00:41:04,886
it's also outputted
a whole bunch


892
00:41:04,886 --> 00:41:06,986
of other vertex information
that we've uploaded


893
00:41:06,986 --> 00:41:11,536
to our shader programs and can
be using to show this compass.


894
00:41:12,086 --> 00:41:16,046
Now, the same code was being
executed both in JavaScript


895
00:41:16,046 --> 00:41:19,686
and on the shaders no
matter which geometry


896
00:41:19,686 --> 00:41:22,946
and vertices I'm
passing into it.


897
00:41:23,036 --> 00:41:25,716
But vertex information does
not need to come from a tool.


898
00:41:26,356 --> 00:41:29,616
We can also procedurally
generate vertex information.


899
00:41:30,716 --> 00:41:33,246
So here, we have a terrain
underneath the compass


900
00:41:33,576 --> 00:41:35,356
that we're generating
in JavaScript.


901
00:41:35,546 --> 00:41:39,146
It's just a few dozen lines
of code to generate this strip


902
00:41:39,146 --> 00:41:40,106
of terrain underneath.


903
00:41:40,636 --> 00:41:43,046
So, we can move the
compass over to terrain,


904
00:41:43,646 --> 00:41:44,836
the needle is still spinning,


905
00:41:45,506 --> 00:41:47,366
and some more advanced
things we can do, too,


906
00:41:47,366 --> 00:41:50,426
right now I haven't talked
about yet but we'll get


907
00:41:50,426 --> 00:41:52,306
into in a little bit
more detail later.


908
00:41:52,306 --> 00:41:53,856
So, we can add some lighting.


909
00:41:54,116 --> 00:41:56,536
So now, we have some lights
animating over the terrain.


910
00:41:57,236 --> 00:41:59,766
You can see how they
affect the entire scene


911
00:41:59,766 --> 00:42:00,766
and the compass itself.


912
00:42:00,766 --> 00:42:07,336
So, in that demo, we showed a
live representation of a few


913
00:42:07,336 --> 00:42:08,956
of the concepts we've
been talking about so far:


914
00:42:09,116 --> 00:42:11,226
outputting complex
geometry from a tool,


915
00:42:11,226 --> 00:42:13,056
outputting texture
information from a tool.


916
00:42:13,576 --> 00:42:16,086
But the code that are


917
00:42:16,086 --> 00:42:20,166
in the demo really was only a
few dozen lines of JavaScript


918
00:42:20,166 --> 00:42:23,286
and Vertex Shader programming
that we've already gone over.


919
00:42:23,406 --> 00:42:25,566
There's some additional
JavaScript to animate things.


920
00:42:26,066 --> 00:42:31,716
But it barely scraped the
surface of what WebGL can do.


921
00:42:32,386 --> 00:42:34,976
Even with that procedural
terrain generation


922
00:42:35,276 --> 00:42:38,816
and the lighting effects which
I haven't told you any details


923
00:42:38,816 --> 00:42:41,266
about, that's still
barely scraped the surface


924
00:42:41,266 --> 00:42:42,476
of what WebGL can do.


925
00:42:42,476 --> 00:42:43,896
It is immensely powerful.


926
00:42:43,896 --> 00:42:47,186
It is a toolbox unto
itself and trying


927
00:42:47,186 --> 00:42:49,186
to describe everything
would take a lot more


928
00:42:49,186 --> 00:42:50,036
of these sessions.


929
00:42:50,556 --> 00:42:54,166
So, I'm not going to go into
much more detail on any of that,


930
00:42:54,676 --> 00:42:56,846
but I am going to talk about
a different toolbox now,


931
00:42:57,186 --> 00:42:59,176
like to shift gears and touch


932
00:42:59,176 --> 00:43:01,436
up on the web platform
a little bit.


933
00:43:02,016 --> 00:43:05,296
The web platform is pretty
mature at this point,


934
00:43:05,296 --> 00:43:10,896
it's been around for dozens
of years and WebGL is just one


935
00:43:10,896 --> 00:43:14,356
of the newest star children
tools in the web platform.


936
00:43:15,136 --> 00:43:18,536
But there's also some very basic
tools that are still there.


937
00:43:18,906 --> 00:43:20,456
HTML is what started it all.


938
00:43:20,456 --> 00:43:22,836
HTML specifies the
content and structure


939
00:43:23,156 --> 00:43:24,566
of the document in your webpage.


940
00:43:25,086 --> 00:43:28,926
And then a little bit
later, we introduced CSS,


941
00:43:29,276 --> 00:43:31,646
which specifies how that
content is presented.


942
00:43:32,056 --> 00:43:35,836
CSS can do simple things like
change the font of some text,


943
00:43:36,176 --> 00:43:39,736
but it can also animate
the transitions of an image


944
00:43:39,736 --> 00:43:42,436
or any element from
different points on the page,


945
00:43:42,586 --> 00:43:44,126
including 3D transforms.


946
00:43:44,316 --> 00:43:49,066
That's already been available
in CSS, a native web technology


947
00:43:49,066 --> 00:43:50,366
that preexisted WebGL.


948
00:43:50,886 --> 00:43:53,976
And then of course,
there is JavaScript.


949
00:43:54,306 --> 00:43:56,216
We've talked a lot
about JavaScript today


950
00:43:56,216 --> 00:43:58,866
because you use JavaScript
to drive WebGL


951
00:43:59,246 --> 00:44:02,906
but JavaScript also has native
DOM bindings to the HTML content


952
00:44:03,296 --> 00:44:05,866
and can transition
styles on the page.


953
00:44:07,076 --> 00:44:10,956
So, using just this bottom
tier of technologies, the HTML,


954
00:44:11,036 --> 00:44:13,306
the CSS, and JavaScript,
we've already been able


955
00:44:13,306 --> 00:44:14,666
to do some pretty cool things.


956
00:44:15,576 --> 00:44:17,266
For example, if I
wanted to go into


957
00:44:17,706 --> 00:44:20,576
and create a 3D image gallery,
I wouldn't need to jump


958
00:44:20,576 --> 00:44:22,146
into WebGL just to do that.


959
00:44:22,556 --> 00:44:26,926
The HTML can specify a series
of images and their relation


960
00:44:26,926 --> 00:44:28,646
to each other, the order
in which they appear.


961
00:44:29,156 --> 00:44:34,966
The CSS can define a 3D
presentation of those images


962
00:44:35,176 --> 00:44:41,226
and JavaScript can drive some
CSS animations between them.


963
00:44:41,426 --> 00:44:44,976
Something else that's already
been possible is really advanced


964
00:44:45,116 --> 00:44:46,426
text operations.


965
00:44:46,806 --> 00:44:50,336
Using HTML and CSS and things
like the font-face rules,


966
00:44:50,626 --> 00:44:52,576
you can add your own
fonts to content,


967
00:44:52,846 --> 00:44:56,856
you can really finally tweak
how the font is rendered


968
00:44:57,556 --> 00:45:00,906
and it's pretty simple
to do versus,


969
00:45:00,906 --> 00:45:02,876
if you try to do font
rendering in WebGL,


970
00:45:02,876 --> 00:45:04,816
you might find it
much more difficult.


971
00:45:05,796 --> 00:45:07,676
Also, in this little
video I just showed,


972
00:45:07,906 --> 00:45:09,926
you can see that HTML


973
00:45:09,926 --> 00:45:12,016
and JavaScript have
built-in event handling


974
00:45:12,016 --> 00:45:15,806
for the mouse pointer and a
whole bunch of built-in controls


975
00:45:15,926 --> 00:45:18,746
and built-in hit testing for
different elements on the page.


976
00:45:19,076 --> 00:45:21,286
These are all built in
and easy to use already.


977
00:45:21,756 --> 00:45:25,806
And then at an even
more basic level,


978
00:45:26,116 --> 00:45:28,786
what HTML does is
lay out content.


979
00:45:29,036 --> 00:45:31,576
It lays out texts and
other elements on a page.


980
00:45:31,946 --> 00:45:33,836
You can see in this
iBook example,


981
00:45:34,146 --> 00:45:37,336
the text flows beautifully
around elements on the page


982
00:45:37,676 --> 00:45:41,176
and that was basically all free
for whoever wrote that content


983
00:45:41,346 --> 00:45:43,176
and put that image
into that document.


984
00:45:43,666 --> 00:45:47,446
And then very importantly,


985
00:45:47,646 --> 00:45:50,346
sticking with the native web
technologies whenever you can


986
00:45:50,716 --> 00:45:52,166
gets you accessibility for free.


987
00:45:52,746 --> 00:45:57,796
So today, we're talking
a lot about tools,


988
00:45:58,486 --> 00:46:02,486
and the point I'd just
like to drive home here is


989
00:46:02,806 --> 00:46:05,856
to use the appropriate
tool whenever you can,


990
00:46:05,926 --> 00:46:09,066
it's an old programming
adage and it's really true


991
00:46:09,306 --> 00:46:11,756
when we take a platform as
mature as the web platform


992
00:46:11,936 --> 00:46:14,606
and introduce as something
as powerful as WebGL.


993
00:46:15,096 --> 00:46:20,366
And finally, I have one more
thing we need to talk about


994
00:46:20,976 --> 00:46:22,036
and that's when to draw.


995
00:46:23,166 --> 00:46:25,376
So far, Dean and I
have described a lot


996
00:46:25,376 --> 00:46:29,056
about how you render an
individual frame in your scene,


997
00:46:29,356 --> 00:46:32,706
you set up the geometry
of objects and the colors


998
00:46:32,706 --> 00:46:35,386
and you set up your shaders
and then you make a call


999
00:46:35,386 --> 00:46:39,016
to draw triangles and, boom,
you've rendered a still frame.


1000
00:46:39,856 --> 00:46:43,046
Now, each of the demos we showed
you had animation involved.


1001
00:46:43,516 --> 00:46:44,806
How did that animation happen?


1002
00:46:45,696 --> 00:46:49,446
Well, as you know by now,
JavaScript drives drawing


1003
00:46:49,446 --> 00:46:53,216
in WebGL, but JavaScript
is not always running.


1004
00:46:54,506 --> 00:46:58,886
Take this beautiful web page
here, it's clean and looks nice,


1005
00:46:59,156 --> 00:47:02,756
but it's also very static
and as long as I'm the user


1006
00:47:02,756 --> 00:47:04,436
and I'm not touching
the mouse or keyboard


1007
00:47:04,606 --> 00:47:06,256
and I'm not interacting
with the page at all


1008
00:47:06,576 --> 00:47:08,726
and the page is very static,
it doesn't have timers


1009
00:47:08,726 --> 00:47:11,856
or any other things going on,
no JavaScript is executing.


1010
00:47:12,616 --> 00:47:15,366
So, how can we render WebGL
if no JavaScript is executing?


1011
00:47:16,526 --> 00:47:20,126
Well, but then if I start
moving the mouse over the page,


1012
00:47:20,656 --> 00:47:24,306
and selecting things and
dragging and bringing up menus,


1013
00:47:24,766 --> 00:47:28,136
now, JavaScript is executing
a whole bunch, except,


1014
00:47:28,356 --> 00:47:30,506
it's responding to all these
events that are happening.


1015
00:47:30,506 --> 00:47:35,126
It's executing asynchronously
hundreds of times a second.


1016
00:47:35,256 --> 00:47:37,736
So, in one of those little
JavaScript executions,


1017
00:47:37,766 --> 00:47:41,226
you could do some drawing, but
you probably shouldn't draw


1018
00:47:41,806 --> 00:47:44,556
in every single EventHandler
that's called


1019
00:47:44,806 --> 00:47:46,306
because that'd just be crazy.


1020
00:47:46,306 --> 00:47:49,816
You'd be drawing-trying to draw
hundreds of times a second.


1021
00:47:50,306 --> 00:47:53,246
That can't possibly work because
drawing takes a long time


1022
00:47:53,246 --> 00:47:55,126
compared to how quickly
these events would normally


1023
00:47:55,126 --> 00:47:55,706
be handled.


1024
00:47:56,116 --> 00:47:59,706
You can only get bits to the
screen 60 times a second.


1025
00:48:00,146 --> 00:48:02,236
So basically, you just
slow down responsiveness.


1026
00:48:02,236 --> 00:48:04,186
You'd start chewing
through CPU and battery life


1027
00:48:04,186 --> 00:48:06,886
and you wouldn't even
gain anything out of it.


1028
00:48:07,756 --> 00:48:10,056
But there are times when
you might want to draw


1029
00:48:10,056 --> 00:48:12,376
in direct response to
one of these events.


1030
00:48:12,376 --> 00:48:15,586
Imagine if you're rendering
a 3D button using WebGL


1031
00:48:15,586 --> 00:48:16,676
and the user clicks on it.


1032
00:48:17,426 --> 00:48:20,126
You might immediately
want to redraw your scene


1033
00:48:20,166 --> 00:48:21,216
to update the state there.


1034
00:48:21,786 --> 00:48:23,626
That's great; that makes sense.


1035
00:48:24,106 --> 00:48:26,796
If you have a complex scene
that is animating a lot


1036
00:48:26,796 --> 00:48:30,216
of geometry though, you probably
want a smooth animation.


1037
00:48:30,396 --> 00:48:33,866
You probably are going for that
60 frames per second animation.


1038
00:48:34,496 --> 00:48:37,726
Now to get that, I can tell
you one steadfast rule:


1039
00:48:39,056 --> 00:48:40,656
please don't use timers!


1040
00:48:41,526 --> 00:48:44,936
JavaScript timers are a way
to execute a chunk of code


1041
00:48:44,936 --> 00:48:47,946
at some point in the future
that's based on a time delay.


1042
00:48:49,236 --> 00:48:51,416
This, it turns out,
is not appropriate


1043
00:48:51,416 --> 00:48:53,186
for rendering animations.


1044
00:48:54,166 --> 00:48:56,876
One example where
it's inappropriate is


1045
00:48:56,876 --> 00:48:59,626
that the system might be under
load and you might not be able


1046
00:48:59,626 --> 00:49:01,386
to keep up with 60
frames per second.


1047
00:49:01,636 --> 00:49:04,386
So, if you set a timer to
run 60 frames per second,


1048
00:49:04,646 --> 00:49:07,516
not knowing the system is under
load, you're going to be trying


1049
00:49:07,516 --> 00:49:11,146
to draw more often than your
drawing can be presented


1050
00:49:11,146 --> 00:49:11,846
onto the screen.


1051
00:49:12,706 --> 00:49:14,466
This is just wasteful.


1052
00:49:14,606 --> 00:49:18,106
It's going to waste CPU, heat
up the user's mobile device,


1053
00:49:18,106 --> 00:49:21,946
burn through the battery.


1054
00:49:22,076 --> 00:49:23,276
So, what can we use instead?


1055
00:49:24,756 --> 00:49:27,426
There's an API specifically
for drawing


1056
00:49:28,466 --> 00:49:30,266
that you should use
instead of timers


1057
00:49:30,336 --> 00:49:32,136
and it's called
requestAnimationFrame().


1058
00:49:33,686 --> 00:49:35,476
Much like a timer,
you pass a callback


1059
00:49:35,476 --> 00:49:36,716
to request animation frame.


1060
00:49:38,216 --> 00:49:40,196
So that's the first
thing you do to use it.


1061
00:49:40,746 --> 00:49:42,146
Now, when is your
callback called?


1062
00:49:42,916 --> 00:49:48,286
Your callback is invoked when
WebKit Safari or the application


1063
00:49:48,286 --> 00:49:51,456
that runs WebKit, knows
that it's time to draw.


1064
00:49:51,876 --> 00:49:54,816
So, if the system load is light


1065
00:49:55,236 --> 00:49:57,646
and your drawing is
simple enough, you can keep


1066
00:49:57,646 --> 00:49:59,066
up that 60 frames a second,


1067
00:49:59,346 --> 00:50:02,966
so requestAnimationFrame() will
be called 60 times a second.


1068
00:50:03,046 --> 00:50:05,156
If the system is under a
little bit of a heavier load


1069
00:50:05,306 --> 00:50:06,616
and you can't keep up with that,


1070
00:50:06,806 --> 00:50:09,796
it'll call request-it'll call
your callback less often.


1071
00:50:10,916 --> 00:50:13,726
If your web content is in
a background tab in Safari,


1072
00:50:13,806 --> 00:50:17,376
for example, or the canvas
your WebGL is painting


1073
00:50:17,376 --> 00:50:21,386
into is offscreen, request
animation frame might be called


1074
00:50:21,576 --> 00:50:24,736
much less often or not at
all because WebKit knows


1075
00:50:24,986 --> 00:50:28,666
that drawing a scene that
can't be seen is not important.


1076
00:50:29,156 --> 00:50:34,206
So, here, we have a
drawingCallback function


1077
00:50:35,446 --> 00:50:38,476
and we set it up to be called
by calling requestAnimationFrame


1078
00:50:38,786 --> 00:50:39,606
with the drawingCallback.


1079
00:50:41,896 --> 00:50:44,146
Inside our callback,
we do some drawing.


1080
00:50:45,376 --> 00:50:47,306
This can be updating
physics based on the amount


1081
00:50:47,306 --> 00:50:49,736
of time that's passed,
responding to queued


1082
00:50:49,736 --> 00:50:52,786
up user events that we've logged
as the user was moving the mouse


1083
00:50:52,786 --> 00:50:55,126
around and pressing
keys and such,


1084
00:50:55,316 --> 00:50:58,006
and then we can draw
the individual elements


1085
00:50:58,006 --> 00:51:00,356
for our scene: the
compass, other entities,


1086
00:51:00,416 --> 00:51:01,506
the terrain in the background.


1087
00:51:02,206 --> 00:51:04,346
And then when we're
done drawing,


1088
00:51:04,886 --> 00:51:06,236
we request the next callback.


1089
00:51:07,536 --> 00:51:10,586
We're telling WebKit, "Hey,
we finished drawing one frame.


1090
00:51:11,066 --> 00:51:14,286
Now it's time for me to be told
when to draw the next frame."


1091
00:51:14,806 --> 00:51:18,126
And that's it.


1092
00:51:23,676 --> 00:51:25,326
So, that's all we
have to talk about,


1093
00:51:25,326 --> 00:51:28,506
about these nitty-gritty
topics, the code


1094
00:51:28,866 --> 00:51:31,116
and how things fit together
with the web platform,


1095
00:51:31,386 --> 00:51:32,976
but I want to show
you one final demo.


1096
00:51:33,716 --> 00:51:35,846
I'll call it the
requestAnimationFrame() demo


1097
00:51:35,846 --> 00:51:39,666
because this demo certainly does
use requestAnimationFrame().


1098
00:51:40,296 --> 00:51:42,506
But it also uses
a whole lot more.


1099
00:51:43,246 --> 00:51:46,186
So, our friends at
Epic Games were happy


1100
00:51:46,186 --> 00:51:49,196
to let us use this demo
from the Unreal Engine,


1101
00:51:49,716 --> 00:51:53,326
and this is just a really cool
little temple thing we have.


1102
00:51:53,366 --> 00:51:54,926
Let me go ahead and
take it full screen.


1103
00:51:55,506 --> 00:51:57,716
So, this is rendering in Safari.


1104
00:51:57,716 --> 00:51:59,556
This is executing JavaScript.


1105
00:52:00,106 --> 00:52:04,546
This is executing Fragment
Shaders and Vertex Shaders,


1106
00:52:05,066 --> 00:52:10,066
and what we're seeing
is just amazing.


1107
00:52:11,216 --> 00:52:13,096
So, there's a lot going on here.


1108
00:52:13,096 --> 00:52:15,596
We have light, reflection.


1109
00:52:15,686 --> 00:52:18,066
A lot of these surfaces
are really interesting:


1110
00:52:18,066 --> 00:52:19,126
marble and glass.


1111
00:52:19,126 --> 00:52:22,396
We have fire casting
reflections and light.


1112
00:52:23,296 --> 00:52:26,226
As we move around, you can
see the background scene being


1113
00:52:26,226 --> 00:52:28,206
reflected off the shiny walls.


1114
00:52:28,706 --> 00:52:31,896
Let's climb these
stairs over here.


1115
00:52:31,896 --> 00:52:37,226
So, as I enter this
hallway-let me go back


1116
00:52:37,226 --> 00:52:38,596
and forth just a few times,


1117
00:52:38,596 --> 00:52:41,836
I love this-you can see this
orange reflection on the wall.


1118
00:52:42,326 --> 00:52:44,236
So, I'm wondering where
that orange is coming from.


1119
00:52:44,626 --> 00:52:46,336
Something also interesting
is you see this room


1120
00:52:46,336 --> 00:52:49,626
over here is a lot brighter,
the engine is doing HDR


1121
00:52:49,626 --> 00:52:52,426
for dynamic lighting
effects to great effect.


1122
00:52:53,066 --> 00:52:58,936
So, we can see that these
fires on these podiums here,


1123
00:52:58,936 --> 00:53:01,026
they are casting
shadows into the hallway.


1124
00:53:01,026 --> 00:53:03,306
Here's more examples
of the HDR contrast.


1125
00:53:03,616 --> 00:53:04,776
I mean, there's a bright room,


1126
00:53:04,776 --> 00:53:06,416
so it's dark off
in the distance.


1127
00:53:08,976 --> 00:53:12,306
This is millions of
triangles, millions of vertices.


1128
00:53:12,716 --> 00:53:15,266
It was generated with some
pretty advanced tools,


1129
00:53:16,456 --> 00:53:19,626
but then the actual code
that drives it isn't nearly


1130
00:53:19,626 --> 00:53:21,596
as advanced as the
data that's coming in.


1131
00:53:21,946 --> 00:53:24,196
It's just relying on the
power of GL and the power


1132
00:53:24,196 --> 00:53:28,236
of the web platform to do
previously impossible things,


1133
00:53:28,876 --> 00:53:32,796
using the tools of
the web platform.


1134
00:53:32,796 --> 00:53:36,196
And to wrap us up, I'd like to
invite my colleague Dean back


1135
00:53:36,196 --> 00:53:36,626
on stage.


1136
00:53:37,516 --> 00:53:43,706
[ Applause ]


1137
00:53:44,206 --> 00:53:44,716
>> Thanks, Brady.


1138
00:53:44,836 --> 00:53:46,686
That's pretty awesome and,
like I said at the start,


1139
00:53:46,686 --> 00:53:49,416
WebGL is insanely fun
technology to play with.


1140
00:53:49,766 --> 00:53:51,386
So, while you might
not get quite


1141
00:53:51,386 --> 00:53:53,766
to the Unreal Engine straight
away, you can certainly play


1142
00:53:53,766 --> 00:53:57,036
with stuff right away and
get some amazing input.


1143
00:53:57,726 --> 00:53:58,666
Let's wrap up.


1144
00:53:58,666 --> 00:54:00,586
So, WebGL provides rich, fast,


1145
00:54:00,586 --> 00:54:02,586
powerful graphics
inside the web browser.


1146
00:54:03,326 --> 00:54:08,876
It's available in Safari, on
both OS X Yosemite and iOS 8.


1147
00:54:10,226 --> 00:54:13,766
And it's also available in the
modern WebKit API, WKWebView,


1148
00:54:13,766 --> 00:54:14,656
if you're a developer.


1149
00:54:15,546 --> 00:54:18,126
With that, I want to
tell you-direct you


1150
00:54:18,126 --> 00:54:18,976
to more information.


1151
00:54:18,976 --> 00:54:21,696
There's an email address you
can get for contact with Apple.


1152
00:54:21,696 --> 00:54:23,616
There's a few websites
and, of course,


1153
00:54:23,616 --> 00:54:26,016
WebKit is an open source
project so you can follow along


1154
00:54:26,016 --> 00:54:27,826
with that development
on webkit.org.


1155
00:54:28,726 --> 00:54:31,106
There's some related
sessions: the one yesterday


1156
00:54:31,106 --> 00:54:32,156
on the modern WebKit API,


1157
00:54:32,156 --> 00:54:34,396
which is definitely
worth checking out,


1158
00:54:34,746 --> 00:54:37,806
and we've got one tomorrow
on the Web Inspector


1159
00:54:37,806 --> 00:54:40,406
and Modern JavaScript which, of
course, is important to WebGL.


1160
00:54:40,606 --> 00:54:42,506
And we're looking forward
to seeing whatever you do.


1161
00:54:42,506 --> 00:54:43,846
Have a great rest
of the conference.


1162
00:54:44,516 --> 00:54:49,640
[ Applause ]

