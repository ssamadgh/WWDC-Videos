1
00:00:07,516 --> 00:00:20,516
[ Music ]


2
00:00:21,516 --> 00:00:27,546
[ Applause ]


3
00:00:28,046 --> 00:00:29,076
>> Good morning, welcome to


4
00:00:29,116 --> 00:00:30,116
What's New in LLVM.


5
00:00:31,136 --> 00:00:32,406
I'm Jim Grosbach, your friendly


6
00:00:32,406 --> 00:00:33,766
neighborhood pointy hair boss.


7
00:00:34,036 --> 00:00:35,536
I'm here to tell you a little


8
00:00:35,536 --> 00:00:37,966
bit of background about the LLVM


9
00:00:37,966 --> 00:00:40,066
project before we dive into the


10
00:00:40,066 --> 00:00:41,296
deep technical details of all


11
00:00:41,296 --> 00:00:43,296
the exciting new things that we


12
00:00:43,296 --> 00:00:44,306
have for you today.


13
00:00:45,426 --> 00:00:48,276
Start off, LLVM is more than


14
00:00:48,276 --> 00:00:50,916
just the compiler, it is the


15
00:00:50,916 --> 00:00:52,736
background for the Clang


16
00:00:52,736 --> 00:00:54,096
compiler, for the C family of


17
00:00:54,096 --> 00:00:55,706
languages that we all use every


18
00:00:55,706 --> 00:00:57,596
day, but it also powers the


19
00:00:57,596 --> 00:01:00,316
Static Analyzer, the sanitizers,


20
00:01:00,316 --> 00:01:03,216
the LLDB debugger, and is the


21
00:01:03,216 --> 00:01:04,726
optimization code generation


22
00:01:04,726 --> 00:01:06,616
framework underneath the GPU


23
00:01:06,616 --> 00:01:08,576
shader compilers for all of


24
00:01:08,576 --> 00:01:11,166
Apple's mobile platforms.


25
00:01:12,016 --> 00:01:13,396
In addition to this, it also


26
00:01:13,396 --> 00:01:15,806
powers one additional little


27
00:01:15,806 --> 00:01:17,726
project that you may have heard


28
00:01:17,726 --> 00:01:19,036
of from time to time called


29
00:01:19,036 --> 00:01:19,676
Swift.


30
00:01:21,016 --> 00:01:23,906
And like Swift LLVM is an open


31
00:01:23,906 --> 00:01:24,906
source project.


32
00:01:26,456 --> 00:01:27,696
We all operate under the


33
00:01:27,696 --> 00:01:30,276
watchful eye of our LLVM wyvern


34
00:01:30,276 --> 00:01:31,916
here, he's normally a very


35
00:01:31,916 --> 00:01:33,586
friendly fellow, though I do


36
00:01:33,586 --> 00:01:34,776
have to caution you he gets a


37
00:01:34,776 --> 00:01:36,456
little bit cranky if you call


38
00:01:36,456 --> 00:01:38,176
him a dragon so don't do that.


39
00:01:39,596 --> 00:01:42,296
As an open source project LLVM


40
00:01:42,296 --> 00:01:44,996
is a partnership, we work with


41
00:01:44,996 --> 00:01:47,186
industry partners, academics,


42
00:01:47,246 --> 00:01:49,356
researchers and hobbyists from


43
00:01:49,596 --> 00:01:51,166
all over the world and in


44
00:01:51,166 --> 00:01:53,106
different parts of the industry


45
00:01:53,756 --> 00:01:55,826
and many more all over the


46
00:01:55,866 --> 00:01:56,396
place.


47
00:01:56,646 --> 00:01:58,036
This is really fantastic, we


48
00:01:58,396 --> 00:01:59,576
work together to build the


49
00:01:59,576 --> 00:02:01,646
greatest tools that we possibly


50
00:02:01,646 --> 00:02:03,806
can to move technology forward.


51
00:02:04,906 --> 00:02:07,686
And if you ever have a compiler


52
00:02:07,686 --> 00:02:08,895
itch that you would like to


53
00:02:08,895 --> 00:02:10,735
scratch we would like to invite


54
00:02:10,735 --> 00:02:13,396
you to participate with us and


55
00:02:13,396 --> 00:02:15,146
go to the LLVM website here at


56
00:02:15,146 --> 00:02:17,986
llvm.org or you can come talk to


57
00:02:17,986 --> 00:02:19,716
us later today later today in


58
00:02:19,716 --> 00:02:21,906
the LLVM labs and many of our


59
00:02:21,906 --> 00:02:23,446
compiler engineers from Apple


60
00:02:23,446 --> 00:02:25,066
will be there and I'm sure will


61
00:02:25,066 --> 00:02:27,506
be more than happy to talk your


62
00:02:27,506 --> 00:02:28,786
ear off about anything and


63
00:02:28,786 --> 00:02:30,136
everything compiler related


64
00:02:30,476 --> 00:02:31,646
you've ever wanted to know.


65
00:02:32,666 --> 00:02:36,096
So for today we have a great set


66
00:02:36,096 --> 00:02:37,306
of things that we want to share


67
00:02:37,306 --> 00:02:37,656
with you.


68
00:02:37,656 --> 00:02:39,476
We have updates on automated


69
00:02:39,476 --> 00:02:40,766
reference counting that makes it


70
00:02:40,766 --> 00:02:42,826
even easier for the compiler to


71
00:02:42,826 --> 00:02:43,876
help you with your memory


72
00:02:43,876 --> 00:02:44,466
management.


73
00:02:44,786 --> 00:02:47,146
We have new diagnostics in Xcode


74
00:02:47,206 --> 00:02:49,266
10 and new checks in the Static


75
00:02:49,266 --> 00:02:51,536
Analyzer to help catch bugs in


76
00:02:51,536 --> 00:02:53,536
your project sooner at build


77
00:02:53,536 --> 00:02:55,646
time to improve the quality of


78
00:02:55,646 --> 00:02:56,376
your code.


79
00:02:56,786 --> 00:02:58,116
We have compiler features that


80
00:02:58,116 --> 00:02:59,526
improve security, both of


81
00:02:59,526 --> 00:03:01,446
Apple's platforms and of your


82
00:03:01,446 --> 00:03:01,966
apps.


83
00:03:02,336 --> 00:03:04,506
And new features to allow you to


84
00:03:04,506 --> 00:03:06,446
take advantage of all of the


85
00:03:06,446 --> 00:03:08,186
really great new things on the


86
00:03:08,186 --> 00:03:09,866
hardware architectures to get


87
00:03:09,866 --> 00:03:11,696
the performance that we all want


88
00:03:12,026 --> 00:03:13,276
out of our platforms and


89
00:03:13,276 --> 00:03:14,016
architectures.


90
00:03:14,786 --> 00:03:16,126
So with that I would like to


91
00:03:16,126 --> 00:03:18,366
invite my colleague Alex up to


92
00:03:18,646 --> 00:03:19,806
talk about ARC.


93
00:03:20,476 --> 00:03:20,886
Alex.


94
00:03:21,516 --> 00:03:27,546
[ Applause ]


95
00:03:28,046 --> 00:03:28,676
>> Thank you, Jim.


96
00:03:29,696 --> 00:03:31,736
Automatic reference counting has


97
00:03:31,736 --> 00:03:33,956
greatly simplified Objective-C


98
00:03:33,956 --> 00:03:36,196
program since we introduced it a


99
00:03:36,196 --> 00:03:37,216
couple of years ago.


100
00:03:38,106 --> 00:03:40,016
A couple of restrictions made it


101
00:03:40,016 --> 00:03:42,066
harder to migrate from the old


102
00:03:42,376 --> 00:03:44,416
manual retain release mode over


103
00:03:44,416 --> 00:03:44,926
to ARC.


104
00:03:45,576 --> 00:03:46,866
I'm happy to say that we've now


105
00:03:46,866 --> 00:03:48,416
lifted one such restriction.


106
00:03:49,056 --> 00:03:50,496
Xcode 10 has support for ARC


107
00:03:50,536 --> 00:03:51,706
object pointer fields in C


108
00:03:51,736 --> 00:03:51,976
structures.


109
00:03:52,516 --> 00:04:00,616
[ Applause ]


110
00:04:01,116 --> 00:04:02,166
Let's take a look at an example


111
00:04:02,336 --> 00:04:03,506
let's say we'd like to write a


112
00:04:03,506 --> 00:04:05,846
food ordering app and we'd like


113
00:04:05,876 --> 00:04:07,676
to create a data structure which


114
00:04:07,676 --> 00:04:09,176
represents a menu item.


115
00:04:09,736 --> 00:04:13,226
In Xcode 9 and earlier it would


116
00:04:13,226 --> 00:04:14,716
have been impossible for us to


117
00:04:14,716 --> 00:04:17,055
actually use a C structure with


118
00:04:17,055 --> 00:04:19,505
ARC object pointer fields, so we


119
00:04:19,536 --> 00:04:21,546
would have had to use a C, an


120
00:04:21,546 --> 00:04:24,506
Objective-C class here.


121
00:04:24,506 --> 00:04:26,516
Xcode 10 now allows us to


122
00:04:26,516 --> 00:04:27,926
actually create a C structure


123
00:04:27,926 --> 00:04:29,616
that has ARC object pointer


124
00:04:29,726 --> 00:04:29,976
fields.


125
00:04:35,066 --> 00:04:35,906
Let's keep going and keep


126
00:04:35,906 --> 00:04:38,176
writing our food ordering app.


127
00:04:38,176 --> 00:04:39,546
Let's create a function that


128
00:04:39,606 --> 00:04:41,236
orders free food for us.


129
00:04:41,696 --> 00:04:43,246
In the function let's create a


130
00:04:43,246 --> 00:04:45,736
variable item of type menu item


131
00:04:45,976 --> 00:04:46,996
with a price of zero.


132
00:04:48,416 --> 00:04:50,436
Then let's pass this item into


133
00:04:50,436 --> 00:04:52,096
another function that actually


134
00:04:52,376 --> 00:04:53,416
orders the food for us.


135
00:04:54,846 --> 00:04:57,276
When the item is created the


136
00:04:57,276 --> 00:04:59,716
compiler has to synthesize code


137
00:05:00,086 --> 00:05:02,096
which retains the ARC object


138
00:05:02,176 --> 00:05:03,796
pointer fields in the item.


139
00:05:05,066 --> 00:05:06,766
The code comments on the slide


140
00:05:07,106 --> 00:05:08,936
demonstrate the code that the


141
00:05:08,936 --> 00:05:10,306
compiler synthesizes.


142
00:05:11,056 --> 00:05:13,386
This code ensures the name and


143
00:05:13,386 --> 00:05:15,586
the price of the item are not


144
00:05:15,586 --> 00:05:17,346
released prematurely before the


145
00:05:17,346 --> 00:05:18,726
item is actually used.


146
00:05:18,726 --> 00:05:23,076
Now at the end of the function


147
00:05:23,286 --> 00:05:25,706
item goes out of scope and is


148
00:05:25,706 --> 00:05:27,666
deallocated from the stack so


149
00:05:27,666 --> 00:05:30,256
the compiler has to synthesize


150
00:05:30,256 --> 00:05:32,686
code which releases the ARC


151
00:05:32,686 --> 00:05:34,116
object pointer fields in the


152
00:05:34,116 --> 00:05:34,536
item.


153
00:05:35,596 --> 00:05:37,306
This ensures that the name and


154
00:05:37,306 --> 00:05:39,536
the price are not leaked when


155
00:05:39,536 --> 00:05:40,756
the item is released.


156
00:05:42,986 --> 00:05:44,676
Previously it was possible to


157
00:05:44,676 --> 00:05:46,546
use Objective-C object pointer


158
00:05:46,546 --> 00:05:48,916
fields when using manual


159
00:05:48,976 --> 00:05:51,076
retained release mode, but you


160
00:05:51,076 --> 00:05:53,246
had to write the retains and


161
00:05:53,276 --> 00:05:54,506
releases yourself.


162
00:05:55,206 --> 00:05:57,856
With ARC the compiler hides all


163
00:05:57,856 --> 00:05:59,826
of this complexity for you and


164
00:05:59,826 --> 00:06:01,646
synthesizes code that retains


165
00:06:01,646 --> 00:06:02,826
and releases the fields.


166
00:06:03,676 --> 00:06:04,956
So the compiler is really your


167
00:06:04,956 --> 00:06:07,056
friend here and it does the


168
00:06:07,056 --> 00:06:09,116
correct job of managing memory


169
00:06:09,286 --> 00:06:12,056
for variables on the stack and


170
00:06:12,056 --> 00:06:13,846
also for fields in other


171
00:06:13,846 --> 00:06:16,156
structures, and also instance


172
00:06:16,156 --> 00:06:17,916
variables inside Objective-C


173
00:06:17,916 --> 00:06:18,436
classes.


174
00:06:19,686 --> 00:06:21,756
But there is one place we have


175
00:06:21,816 --> 00:06:23,346
to put in a little bit of extra


176
00:06:23,346 --> 00:06:25,126
work to support structures with


177
00:06:25,126 --> 00:06:27,996
ARC object pointer fields and


178
00:06:27,996 --> 00:06:29,386
that place is heap.


179
00:06:30,656 --> 00:06:31,926
Let's go back to our structure,


180
00:06:32,216 --> 00:06:33,126
let's say you would like to


181
00:06:33,126 --> 00:06:35,366
allocate an array of menu items


182
00:06:35,366 --> 00:06:36,046
on the heap.


183
00:06:36,796 --> 00:06:38,526
Now if this was an Objective-C


184
00:06:38,526 --> 00:06:40,836
interface we could have used an


185
00:06:40,946 --> 00:06:43,366
NSArray here, but it's not so


186
00:06:43,366 --> 00:06:45,196
let's use malloc and free.


187
00:06:46,166 --> 00:06:48,416
Now this code actually has two


188
00:06:48,596 --> 00:06:49,176
issues.


189
00:06:49,766 --> 00:06:52,176
First issue, the memory is not


190
00:06:52,176 --> 00:06:53,956
zero initialized when it's


191
00:06:53,956 --> 00:06:56,146
allocated, which means that


192
00:06:56,146 --> 00:06:58,106
their pointers will be invalid


193
00:06:58,646 --> 00:07:00,396
which will cause undesired


194
00:07:00,696 --> 00:07:02,156
runtime behavior for your


195
00:07:02,156 --> 00:07:03,316
program at runtime.


196
00:07:04,896 --> 00:07:07,996
The second issue is that the ARC


197
00:07:07,996 --> 00:07:09,406
object pointer fields are not


198
00:07:09,516 --> 00:07:11,116
cleared before the memory is


199
00:07:11,166 --> 00:07:14,666
deallocated which will cause


200
00:07:14,876 --> 00:07:16,496
runtime memory leaks in your


201
00:07:16,496 --> 00:07:17,076
program.


202
00:07:17,656 --> 00:07:21,916
Now to fix the first issue you


203
00:07:21,916 --> 00:07:23,916
can replace the call to malloc


204
00:07:23,976 --> 00:07:25,106
with a call to calloc.


205
00:07:25,816 --> 00:07:27,526
This will ensure that your


206
00:07:27,526 --> 00:07:29,346
memory is zero initialized,


207
00:07:30,126 --> 00:07:32,386
which will remove all of those


208
00:07:32,546 --> 00:07:34,666
nasty unexpected runtime issues.


209
00:07:35,796 --> 00:07:38,076
To fix the second issue you can


210
00:07:38,076 --> 00:07:40,516
write a loop before it's


211
00:07:40,516 --> 00:07:42,086
allocated in your memory to


212
00:07:42,086 --> 00:07:43,976
clear out all of the ARC object


213
00:07:44,036 --> 00:07:45,396
pointer fields in your items.


214
00:07:46,326 --> 00:07:48,226
This will ensure that the name


215
00:07:48,226 --> 00:07:50,076
and the price in the items are


216
00:07:50,076 --> 00:07:51,836
not leaked when the items are


217
00:07:51,836 --> 00:07:51,976
freed.


218
00:07:56,086 --> 00:07:57,836
Now this is an exciting new


219
00:07:57,906 --> 00:08:00,586
feature and if any of you were


220
00:08:00,586 --> 00:08:02,896
put off from migrates over to


221
00:08:02,896 --> 00:08:05,746
ARC because of lack of features


222
00:08:05,746 --> 00:08:07,906
like that I hope that support


223
00:08:07,906 --> 00:08:09,486
from ARC object pointer fields


224
00:08:09,486 --> 00:08:11,596
in Xcode 10 will help you


225
00:08:11,596 --> 00:08:12,816
reconsider your choice.


226
00:08:14,076 --> 00:08:15,526
Now let's take a look at


227
00:08:16,356 --> 00:08:17,636
Objective-C pointers and


228
00:08:17,636 --> 00:08:19,476
structures in general and see


229
00:08:19,856 --> 00:08:22,646
where and how can the structures


230
00:08:22,686 --> 00:08:25,066
be used in different language


231
00:08:25,066 --> 00:08:26,286
modes in Xcode 10.


232
00:08:27,506 --> 00:08:30,966
So in Xcode 10 you can use


233
00:08:31,146 --> 00:08:33,056
structures that have Objective-C


234
00:08:33,056 --> 00:08:35,015
object pointer fields across


235
00:08:35,015 --> 00:08:36,086
different language modes.


236
00:08:36,576 --> 00:08:38,426
For example, you can use the


237
00:08:38,496 --> 00:08:41,785
same structure in C Objective-C


238
00:08:41,926 --> 00:08:43,796
or even Objective-C++.


239
00:08:44,806 --> 00:08:47,046
And it will work correctly even


240
00:08:47,246 --> 00:08:49,316
when you're compiling your code


241
00:08:49,646 --> 00:08:51,956
in ARC or in the manual retain


242
00:08:51,956 --> 00:08:52,606
release mode.


243
00:08:54,176 --> 00:08:56,446
In Xcode 10 we actually unified


244
00:08:56,796 --> 00:08:59,746
the Objective-C++ ABI between


245
00:08:59,746 --> 00:09:02,596
calls to functions that took in


246
00:09:02,666 --> 00:09:05,126
or returned structures that had


247
00:09:05,126 --> 00:09:06,676
ARC object pointer fields in


248
00:09:06,676 --> 00:09:07,916
Objective-C++.


249
00:09:08,316 --> 00:09:10,756
And this was done through an ABI


250
00:09:11,056 --> 00:09:14,046
change in Xcode 10 and ABI


251
00:09:14,226 --> 00:09:16,016
change affects functions in


252
00:09:16,016 --> 00:09:19,166
Objective C++ which return or


253
00:09:19,166 --> 00:09:21,206
take in a structure by value


254
00:09:21,606 --> 00:09:23,516
that has ARC object pointer


255
00:09:23,516 --> 00:09:26,006
fields and no special member


256
00:09:26,006 --> 00:09:27,726
functions like constructors or


257
00:09:27,726 --> 00:09:28,626
destructors.


258
00:09:30,126 --> 00:09:31,776
Now if you are not sure what


259
00:09:31,896 --> 00:09:33,656
this means for you or whether


260
00:09:33,946 --> 00:09:35,676
your code is affected by this


261
00:09:35,716 --> 00:09:38,146
ABI change please take a look at


262
00:09:38,276 --> 00:09:40,286
Xcode's release notes where we


263
00:09:40,286 --> 00:09:42,526
describe in more details the


264
00:09:42,526 --> 00:09:44,296
effects and the impact of this


265
00:09:44,296 --> 00:09:44,886
ABI change.


266
00:09:49,046 --> 00:09:50,676
Now there is one caveat when it


267
00:09:50,676 --> 00:09:53,176
comes to the ARC object pointer


268
00:09:53,176 --> 00:09:55,866
fields and C structures, they're


269
00:09:55,866 --> 00:09:56,976
not supported in Swift.


270
00:09:57,766 --> 00:09:59,546
So if you try to use a structure


271
00:10:00,046 --> 00:10:01,386
that has ARC object pointer


272
00:10:01,386 --> 00:10:03,766
fields from Swift you will just


273
00:10:03,766 --> 00:10:05,346
get a compilation error because


274
00:10:05,676 --> 00:10:06,976
the structure will not be found.


275
00:10:14,046 --> 00:10:16,286
In addition to new features like


276
00:10:16,696 --> 00:10:18,356
support for ARC object pointer


277
00:10:18,356 --> 00:10:22,306
fields Xcode 10 comes with a lot


278
00:10:22,306 --> 00:10:24,356
of new compiler diagnostics.


279
00:10:24,896 --> 00:10:26,426
We actually have over a hundred


280
00:10:26,556 --> 00:10:28,986
new warnings in Xcode 10 and


281
00:10:28,986 --> 00:10:30,566
today I'd like to talk about two


282
00:10:30,566 --> 00:10:30,846
of them.


283
00:10:31,986 --> 00:10:33,326
The first warning might be of


284
00:10:33,556 --> 00:10:36,036
interest to those of you who


285
00:10:36,036 --> 00:10:38,676
have mixed Swift and Objective-C


286
00:10:38,676 --> 00:10:39,036
code.


287
00:10:39,906 --> 00:10:42,466
So as you know Swift code can be


288
00:10:42,466 --> 00:10:45,786
imported into Objective-C and


289
00:10:46,316 --> 00:10:48,586
Xcode allows you to do that by


290
00:10:48,586 --> 00:10:50,356
generating a header file that


291
00:10:50,356 --> 00:10:52,826
describes the Swift interface


292
00:10:53,086 --> 00:10:54,836
using Objective-C declarations.


293
00:10:55,266 --> 00:10:57,856
And you can import this header


294
00:10:57,856 --> 00:10:59,476
file into your own Objective-C


295
00:10:59,476 --> 00:11:01,736
code to get access to the


296
00:11:01,736 --> 00:11:03,816
underlying Swift declarations.


297
00:11:04,756 --> 00:11:06,546
Now let's get more specific and


298
00:11:06,546 --> 00:11:08,396
let's talk about how Swift's


299
00:11:08,546 --> 00:11:10,486
closure parameters are important


300
00:11:10,486 --> 00:11:11,436
to Objective-C.


301
00:11:12,226 --> 00:11:14,296
So right now on the screen you


302
00:11:14,296 --> 00:11:16,186
see an example of a Swift


303
00:11:16,356 --> 00:11:17,846
protocol called Executor.


304
00:11:18,796 --> 00:11:20,796
This protocol defines a function


305
00:11:20,796 --> 00:11:22,726
member called performOperation


306
00:11:22,976 --> 00:11:24,536
which takes in a closure


307
00:11:24,536 --> 00:11:25,926
parameter called handler.


308
00:11:27,246 --> 00:11:29,506
Now in Swift closure parameters


309
00:11:29,506 --> 00:11:31,236
are non-escaping by default,


310
00:11:31,576 --> 00:11:33,496
which means that they should not


311
00:11:33,496 --> 00:11:35,896
be retained or called after the


312
00:11:35,896 --> 00:11:37,056
function returns.


313
00:11:38,596 --> 00:11:40,366
Now it can be easy for the


314
00:11:40,366 --> 00:11:42,486
program and to forget that this


315
00:11:42,486 --> 00:11:44,826
contract exists when conforming


316
00:11:44,826 --> 00:11:46,446
to the executive protocol in


317
00:11:46,446 --> 00:11:47,356
Objective-C.


318
00:11:48,156 --> 00:11:50,316
For example, as you see right


319
00:11:50,316 --> 00:11:52,096
now on the slide we have a


320
00:11:52,096 --> 00:11:54,406
dispatch Executor interface in


321
00:11:54,406 --> 00:11:56,566
Objective-C and conforms to the


322
00:11:56,566 --> 00:11:58,676
Executor protocol, so it


323
00:11:58,676 --> 00:12:00,416
provides the performOperation


324
00:12:00,416 --> 00:12:02,146
method which takes in the


325
00:12:02,146 --> 00:12:03,616
handler block parameter that


326
00:12:03,656 --> 00:12:05,726
corresponds to Swift's handler


327
00:12:05,726 --> 00:12:06,766
closure parameter.


328
00:12:07,516 --> 00:12:08,736
But just by looking at the


329
00:12:08,736 --> 00:12:11,406
Objective-C code we have no way


330
00:12:11,406 --> 00:12:12,786
of knowing whether the handler


331
00:12:12,786 --> 00:12:14,486
parameter can escape or not.


332
00:12:15,986 --> 00:12:19,046
Xcode 10 now provides a warning


333
00:12:19,366 --> 00:12:21,976
that helps us to remember that


334
00:12:21,976 --> 00:12:23,656
this parameter is actually


335
00:12:23,926 --> 00:12:24,866
non-escaping.


336
00:12:25,456 --> 00:12:29,346
To fix this this warning you can


337
00:12:29,486 --> 00:12:31,196
annotate your block parameter


338
00:12:31,196 --> 00:12:33,596
with the NS NOESCAPE annotation.


339
00:12:34,676 --> 00:12:36,056
You should also annotate the


340
00:12:36,056 --> 00:12:38,416
implementation of the method or


341
00:12:38,416 --> 00:12:39,456
the parameter in the


342
00:12:39,456 --> 00:12:40,716
implementation of the method


343
00:12:40,786 --> 00:12:42,816
with NS NOESCAPE annotation.


344
00:12:44,246 --> 00:12:46,466
Now the NS NOESCAPE annotation


345
00:12:46,636 --> 00:12:48,976
is simply a reminder for you the


346
00:12:48,976 --> 00:12:51,656
programmer to ensure that you


347
00:12:51,656 --> 00:12:54,516
don't store or call the handler


348
00:12:54,516 --> 00:12:55,756
block after they perform


349
00:12:55,756 --> 00:12:57,466
operation method returns.


350
00:12:58,756 --> 00:13:01,866
So it's there for you to help


351
00:13:01,866 --> 00:13:03,196
you remember that there is this


352
00:13:03,196 --> 00:13:05,686
contract that exists between


353
00:13:05,686 --> 00:13:09,926
your Swift and Objective-C code.


354
00:13:10,146 --> 00:13:11,616
Now the second warning might be


355
00:13:11,616 --> 00:13:14,326
of interest to those of you who


356
00:13:14,326 --> 00:13:16,056
work with more low-level code


357
00:13:16,056 --> 00:13:18,296
and who care about the way that


358
00:13:18,296 --> 00:13:20,156
structures are laid out in


359
00:13:20,156 --> 00:13:20,566
memory.


360
00:13:21,846 --> 00:13:22,886
Let's take a look at one


361
00:13:22,886 --> 00:13:23,406
structure.


362
00:13:23,866 --> 00:13:25,776
So in C structures have to


363
00:13:25,776 --> 00:13:27,766
follow strict layout and


364
00:13:27,766 --> 00:13:28,816
alignment rules.


365
00:13:29,866 --> 00:13:31,126
In this particular structure


366
00:13:31,126 --> 00:13:32,096
that you see right now on the


367
00:13:32,096 --> 00:13:34,606
slide the compiler has to insert


368
00:13:34,646 --> 00:13:36,706
a 2-byte pattern between the


369
00:13:36,706 --> 00:13:38,666
second and the third field of


370
00:13:38,666 --> 00:13:39,246
the structure.


371
00:13:40,776 --> 00:13:42,066
Sometimes you might want to


372
00:13:42,066 --> 00:13:44,386
relax these rules and the


373
00:13:44,386 --> 00:13:46,956
compiler provides a pragma pack


374
00:13:47,066 --> 00:13:48,906
directive that you can use to


375
00:13:48,906 --> 00:13:50,446
control the layout and the


376
00:13:50,446 --> 00:13:51,846
alignment of your structures.


377
00:13:54,196 --> 00:13:56,956
Now in this example we use the


378
00:13:56,956 --> 00:13:59,906
pragma pack push, 1 directive to


379
00:13:59,906 --> 00:14:03,556
remove this fixated layout and


380
00:14:03,556 --> 00:14:05,346
to ensure that our structure is


381
00:14:05,436 --> 00:14:05,956
tightly packed.


382
00:14:07,436 --> 00:14:08,766
This can be useful when


383
00:14:09,446 --> 00:14:11,146
serializing your structures or


384
00:14:11,146 --> 00:14:12,296
when transferring your


385
00:14:12,296 --> 00:14:13,576
structures over the network.


386
00:14:14,836 --> 00:14:16,976
Now pragma pack is typically


387
00:14:16,976 --> 00:14:19,036
used with a push and a pop


388
00:14:19,136 --> 00:14:21,386
directive, but it can be easy


389
00:14:21,386 --> 00:14:23,526
for the programmer to forget to


390
00:14:23,526 --> 00:14:25,416
insert the pop into the code.


391
00:14:27,246 --> 00:14:29,346
Xcode 10 will now warn about


392
00:14:29,376 --> 00:14:31,526
code that doesn't have a


393
00:14:31,526 --> 00:14:33,526
corresponding pragma pack pop


394
00:14:33,526 --> 00:14:36,036
directive and to point you to


395
00:14:36,036 --> 00:14:37,516
the location of the push.


396
00:14:38,146 --> 00:14:41,426
So to fix this warning you


397
00:14:41,426 --> 00:14:42,866
should take a look at the


398
00:14:42,866 --> 00:14:44,586
location of your push directive


399
00:14:45,156 --> 00:14:47,716
and insert the pop directive at


400
00:14:47,716 --> 00:14:49,706
the corresponding location in


401
00:14:49,706 --> 00:14:50,376
your code.


402
00:14:51,806 --> 00:14:53,426
So in our case we can insert the


403
00:14:53,426 --> 00:14:55,296
pop directly after the packed


404
00:14:55,376 --> 00:14:55,836
structure.


405
00:14:57,186 --> 00:15:00,986
Once we do that the new layout


406
00:15:00,986 --> 00:15:02,546
rules will apply only to the


407
00:15:02,546 --> 00:15:05,006
packed structure so they won't


408
00:15:05,296 --> 00:15:06,676
affect any other structures in


409
00:15:06,676 --> 00:15:06,976
our program.


410
00:15:12,046 --> 00:15:13,596
These two new warnings that I


411
00:15:13,596 --> 00:15:16,026
mentioned are enabled by default


412
00:15:16,026 --> 00:15:18,936
in Xcode 10 and they are there


413
00:15:18,936 --> 00:15:21,186
to help you write more correct


414
00:15:21,346 --> 00:15:22,606
and more robust code.


415
00:15:23,306 --> 00:15:24,766
And to talk more about more


416
00:15:24,766 --> 00:15:27,066
correct and more robust code I'd


417
00:15:27,066 --> 00:15:28,646
like to invite George up on


418
00:15:28,646 --> 00:15:30,126
stage who will talk about the


419
00:15:30,126 --> 00:15:31,556
new static analyzing


420
00:15:31,556 --> 00:15:33,126
improvements in Xcode 10.


421
00:15:33,376 --> 00:15:33,536
George.


422
00:15:34,516 --> 00:15:39,500
[ Applause ]


423
00:15:42,056 --> 00:15:43,426
>> Thanks Alex, so I would like


424
00:15:43,426 --> 00:15:44,836
to tell you about some of the


425
00:15:44,836 --> 00:15:46,706
improvements we have done for


426
00:15:46,986 --> 00:15:48,896
Xcode 10 for the Clang Static


427
00:15:48,896 --> 00:15:49,456
Analyzer.


428
00:15:50,356 --> 00:15:52,086
So the Clang Static Analyzer is


429
00:15:52,086 --> 00:15:53,566
a great tool for finding HK


430
00:15:53,566 --> 00:15:55,936
hard-to-reproduce bugs in your


431
00:15:55,936 --> 00:15:56,486
program.


432
00:15:56,736 --> 00:15:58,656
And not only the Static Analyzer


433
00:15:58,656 --> 00:16:00,726
finds the bug for you it also


434
00:16:00,726 --> 00:16:02,416
displays the visualization in


435
00:16:02,496 --> 00:16:04,336
Xcode of the paths which


436
00:16:04,386 --> 00:16:04,936
[inaudible] the bug.


437
00:16:05,636 --> 00:16:07,546
So here nil is added to


438
00:16:07,636 --> 00:16:09,566
NSMutableArray which can cause a


439
00:16:09,566 --> 00:16:10,596
crash later on.


440
00:16:10,636 --> 00:16:12,626
And Static Analyzer shows you


441
00:16:12,626 --> 00:16:14,566
the path for this crash so you


442
00:16:14,566 --> 00:16:16,026
can see how the application can


443
00:16:16,026 --> 00:16:16,516
be fixed.


444
00:16:17,686 --> 00:16:19,536
And I would like to tell you


445
00:16:19,536 --> 00:16:20,916
about three of the new


446
00:16:20,916 --> 00:16:22,166
improvements we have done.


447
00:16:22,816 --> 00:16:25,346
Firstly, we have a new check for


448
00:16:25,346 --> 00:16:27,266
detecting Grand Central Dispatch


449
00:16:27,266 --> 00:16:29,146
anti-patterning, which can cause


450
00:16:29,146 --> 00:16:30,876
poor performance and hangs of


451
00:16:30,876 --> 00:16:31,666
your replication.


452
00:16:32,346 --> 00:16:34,286
Secondly, we have a new check


453
00:16:34,286 --> 00:16:36,066
for detecting a misuse of


454
00:16:36,066 --> 00:16:38,146
autoreleasing variables inside


455
00:16:38,146 --> 00:16:39,866
autorelease pools which can


456
00:16:39,866 --> 00:16:41,136
cause crashes with [inaudible].


457
00:16:41,136 --> 00:16:44,876
And finally, we have improved


458
00:16:44,916 --> 00:16:46,556
performance and visualizations


459
00:16:46,556 --> 00:16:47,916
for the Clang Static Analyzer.


460
00:16:49,116 --> 00:16:51,486
So let's start with a new check


461
00:16:51,486 --> 00:16:52,836
for detecting Grand Central


462
00:16:52,836 --> 00:16:54,086
Dispatch anti-pattern.


463
00:16:54,986 --> 00:16:57,226
So many APIs on our platforms


464
00:16:57,656 --> 00:17:00,076
are asynchronous, but sometimes


465
00:17:00,076 --> 00:17:01,606
developers would like to use


466
00:17:01,606 --> 00:17:03,296
them in a synchronous way for


467
00:17:03,296 --> 00:17:04,476
one reason or another.


468
00:17:05,526 --> 00:17:06,796
Maybe because their code is


469
00:17:06,796 --> 00:17:07,796
already running on the


470
00:17:07,796 --> 00:17:09,915
background queue or maybe


471
00:17:09,915 --> 00:17:11,036
because the function cannot


472
00:17:11,036 --> 00:17:12,415
proceed at all until the


473
00:17:12,415 --> 00:17:13,915
required value is available.


474
00:17:14,306 --> 00:17:16,415
And the tempting solution there


475
00:17:16,415 --> 00:17:18,606
is to use a semaphore to ensure


476
00:17:18,606 --> 00:17:19,486
synchronization.


477
00:17:20,536 --> 00:17:21,965
So that's what's happening in


478
00:17:21,965 --> 00:17:24,685
this example, so here there is


479
00:17:24,906 --> 00:17:27,336
an SXPC object self.connection


480
00:17:27,826 --> 00:17:29,186
and we use its property


481
00:17:29,186 --> 00:17:32,046
remoteObjectProxy to call, to


482
00:17:32,046 --> 00:17:33,846
get the current task name


483
00:17:33,996 --> 00:17:35,866
asynchronously from a different


484
00:17:35,866 --> 00:17:36,606
process.


485
00:17:37,566 --> 00:17:39,506
And then we wait on a semaphore


486
00:17:40,076 --> 00:17:41,666
which is signal to inside the


487
00:17:41,926 --> 00:17:42,546
callback.


488
00:17:43,286 --> 00:17:45,126
And that helps to ensure that by


489
00:17:45,126 --> 00:17:46,696
the time the function returns


490
00:17:47,376 --> 00:17:48,996
the task name is available.


491
00:17:49,256 --> 00:17:51,966
So this approach works but has


492
00:17:51,966 --> 00:17:53,566
known performance implications.


493
00:17:54,466 --> 00:17:56,536
So the main problem here is when


494
00:17:56,536 --> 00:17:58,956
you wait using a semaphore on


495
00:17:58,956 --> 00:18:01,016
some asynchronous process you


496
00:18:01,016 --> 00:18:02,736
might be waiting on a queue with


497
00:18:02,736 --> 00:18:04,776
a much lower priority than yours


498
00:18:05,156 --> 00:18:07,256
costing prior inversion which


499
00:18:07,756 --> 00:18:08,516
[inaudible] performance and


500
00:18:08,516 --> 00:18:09,176
cause hangs.


501
00:18:09,816 --> 00:18:12,876
And moreover using a semaphore


502
00:18:12,876 --> 00:18:14,956
in such a way also spawns


503
00:18:14,956 --> 00:18:16,426
useless threads which further


504
00:18:16,426 --> 00:18:17,616
degrades the performance.


505
00:18:18,426 --> 00:18:20,706
And to help you address this


506
00:18:20,706 --> 00:18:23,016
issue now Static Analyzer warns


507
00:18:23,386 --> 00:18:27,966
on such cases helping to see


508
00:18:27,966 --> 00:18:29,096
where the issue occurs.


509
00:18:29,096 --> 00:18:32,846
Now let's see how the issue can


510
00:18:32,846 --> 00:18:33,446
be fixed.


511
00:18:34,066 --> 00:18:35,776
In the best-case scenario there


512
00:18:35,836 --> 00:18:38,406
is a synchronous API available


513
00:18:38,446 --> 00:18:39,646
which can be used in stat.


514
00:18:40,286 --> 00:18:42,966
So for an SXPC connection there


515
00:18:42,966 --> 00:18:44,146
is an [inaudible] API


516
00:18:44,576 --> 00:18:47,116
synchronousRemoteObjectProxy


517
00:18:47,736 --> 00:18:49,526
which when used in start


518
00:18:49,526 --> 00:18:50,536
eliminates the need for the


519
00:18:50,536 --> 00:18:53,016
semaphore and runs much foster.


520
00:18:55,196 --> 00:18:57,306
Alternatively, if no such


521
00:18:57,306 --> 00:18:59,976
synchronous API is available you


522
00:18:59,976 --> 00:19:00,836
could restructure your


523
00:19:00,836 --> 00:19:02,586
application to use continuations


524
00:19:02,586 --> 00:19:04,176
in stat and just calls the


525
00:19:04,176 --> 00:19:05,586
required function inside the


526
00:19:05,586 --> 00:19:06,176
callback.


527
00:19:08,876 --> 00:19:10,706
So this check is not enabled by


528
00:19:10,706 --> 00:19:12,516
default but we encourage you to


529
00:19:12,516 --> 00:19:14,576
enable it in build settings in


530
00:19:14,576 --> 00:19:16,276
order to make sure no such


531
00:19:16,316 --> 00:19:17,256
problem securing your


532
00:19:17,256 --> 00:19:18,956
application and it runs as fast


533
00:19:18,956 --> 00:19:19,526
as possible.


534
00:19:19,526 --> 00:19:23,076
Now let's talk about the second


535
00:19:23,076 --> 00:19:24,746
check for detecting the


536
00:19:24,746 --> 00:19:25,976
autoreleasing variables


537
00:19:25,976 --> 00:19:27,646
outliving the lifetime of the


538
00:19:27,646 --> 00:19:28,566
autorelease pool.


539
00:19:29,166 --> 00:19:32,336
So the autoreleasing qualifier


540
00:19:32,626 --> 00:19:34,526
specifies that the value has to


541
00:19:34,526 --> 00:19:36,356
be released once the control


542
00:19:36,356 --> 00:19:37,886
exits the autorelease pool.


543
00:19:38,606 --> 00:19:41,156
So here we have an example where


544
00:19:41,216 --> 00:19:42,786
we create an error variable


545
00:19:43,076 --> 00:19:44,956
inside the autorelease pool and


546
00:19:44,956 --> 00:19:46,326
once the control is outside of


547
00:19:46,326 --> 00:19:47,596
the autorelease pool the


548
00:19:47,596 --> 00:19:49,336
variable is released and


549
00:19:49,336 --> 00:19:50,456
subsequently destroyed.


550
00:19:51,176 --> 00:19:53,516
And autoreleasing pools are a


551
00:19:53,516 --> 00:19:55,556
useful feature of Objective-C to


552
00:19:55,556 --> 00:19:56,976
help contain the big memory


553
00:19:56,976 --> 00:19:58,586
footprint of your applications


554
00:19:58,586 --> 00:19:59,986
and to ensure that thumbprints


555
00:19:59,986 --> 00:20:00,946
are destroyed where necessary.


556
00:20:02,756 --> 00:20:05,576
However, it can cause unexpected


557
00:20:05,576 --> 00:20:08,276
crashes and they're even more


558
00:20:08,276 --> 00:20:10,096
unexpected because you don't


559
00:20:10,096 --> 00:20:11,546
even need to write the word


560
00:20:11,626 --> 00:20:12,756
autoreleasing in your


561
00:20:12,756 --> 00:20:14,036
application to have those


562
00:20:14,036 --> 00:20:14,576
crashes.


563
00:20:15,126 --> 00:20:16,896
So for instance, there is a


564
00:20:16,896 --> 00:20:19,336
validation function here and it


565
00:20:19,336 --> 00:20:21,586
takes in out parameter NSError.


566
00:20:22,336 --> 00:20:24,366
And out parameters are actually


567
00:20:24,366 --> 00:20:25,996
autoreleasing in Objective-C


568
00:20:25,996 --> 00:20:27,436
under ARC by default.


569
00:20:28,126 --> 00:20:30,456
So when we write to this out


570
00:20:30,506 --> 00:20:32,326
parameter inside the autorelease


571
00:20:32,326 --> 00:20:36,956
pool and then the function exits


572
00:20:37,206 --> 00:20:38,706
the error value is actually


573
00:20:38,706 --> 00:20:39,196
released.


574
00:20:39,926 --> 00:20:41,556
And then if the caller tries to


575
00:20:41,556 --> 00:20:42,966
read the value of this error


576
00:20:42,966 --> 00:20:45,086
variable they might crash with


577
00:20:45,086 --> 00:20:45,976
use-after-free.


578
00:20:51,046 --> 00:20:53,046
That pattern is already hard to


579
00:20:53,046 --> 00:20:54,936
detect, but it actually gets


580
00:20:54,996 --> 00:20:56,896
even worse when you don't even


581
00:20:56,896 --> 00:20:57,986
control the part of the


582
00:20:57,986 --> 00:20:59,106
application which has the


583
00:20:59,106 --> 00:21:00,016
autorelease pool.


584
00:21:00,776 --> 00:21:02,416
So here is a similar function


585
00:21:02,666 --> 00:21:04,676
which [inaudible] and out


586
00:21:04,676 --> 00:21:06,696
parameter error and then it


587
00:21:06,696 --> 00:21:07,176
calls an


588
00:21:07,176 --> 00:21:10,236
enumerateObjectsUsingBlock which


589
00:21:10,236 --> 00:21:12,476
is a popular foundation API


590
00:21:12,616 --> 00:21:14,126
which calls a block on every


591
00:21:14,126 --> 00:21:15,676
element of a collection.


592
00:21:16,486 --> 00:21:17,046
However


593
00:21:17,316 --> 00:21:19,246
enumerateObjectsUsingBlock


594
00:21:19,476 --> 00:21:21,156
actually calls [inaudible] given


595
00:21:21,156 --> 00:21:22,576
block inside the autorelease


596
00:21:22,576 --> 00:21:23,486
pool of return.


597
00:21:24,096 --> 00:21:25,906
So a similar problem occurs here


598
00:21:26,386 --> 00:21:28,066
that when we create an error


599
00:21:28,066 --> 00:21:30,726
value inside the block and write


600
00:21:30,726 --> 00:21:32,916
it to the out parameter it will


601
00:21:32,916 --> 00:21:34,666
actually get released by the


602
00:21:34,666 --> 00:21:36,386
time the control reaches out of


603
00:21:36,436 --> 00:21:38,126
enumerateObjectsUsingBlock.


604
00:21:39,356 --> 00:21:41,106
And then when the caller tries


605
00:21:41,816 --> 00:21:44,126
to read it they also can crash


606
00:21:44,126 --> 00:21:45,186
with the use-after-free.


607
00:21:45,666 --> 00:21:49,416
And previously we have


608
00:21:49,416 --> 00:21:51,056
introduced the compiler warning


609
00:21:51,456 --> 00:21:53,436
which warns when an implicitly


610
00:21:53,436 --> 00:21:55,376
autoreleasing out parameter is


611
00:21:55,376 --> 00:21:56,466
captured in the block.


612
00:21:57,046 --> 00:21:58,206
And the compiler warning


613
00:21:58,206 --> 00:21:59,436
suggested to make such


614
00:21:59,476 --> 00:22:00,636
parameters explicitly


615
00:22:00,636 --> 00:22:01,346
autoreleasing.


616
00:22:02,156 --> 00:22:03,486
But we have noticed that such


617
00:22:03,486 --> 00:22:06,486
issue kept occurring, so in


618
00:22:06,486 --> 00:22:08,026
Xcode 10 we introduced a more


619
00:22:08,026 --> 00:22:10,356
powerful Clang Static Analyzer


620
00:22:10,356 --> 00:22:13,906
warning which knows which APIs


621
00:22:14,956 --> 00:22:16,866
call the provided block inside


622
00:22:16,866 --> 00:22:18,846
the autorelease pool and warns


623
00:22:18,846 --> 00:22:19,966
about such cases.


624
00:22:24,066 --> 00:22:24,956
So now let's see how this issue


625
00:22:24,956 --> 00:22:25,676
can be fixed.


626
00:22:26,286 --> 00:22:28,316
And the simplest fix here is


627
00:22:28,316 --> 00:22:29,796
just to introduce a strong local


628
00:22:29,796 --> 00:22:32,376
variable and then when you're


629
00:22:32,376 --> 00:22:34,836
inside the block write a value


630
00:22:34,836 --> 00:22:36,296
into the strong variable in


631
00:22:36,296 --> 00:22:36,806
stat.


632
00:22:37,646 --> 00:22:39,456
And then only copy to the out


633
00:22:39,516 --> 00:22:41,646
parameter once the control is


634
00:22:41,646 --> 00:22:43,286
outside of the block and you


635
00:22:43,286 --> 00:22:44,666
know it's not inside the


636
00:22:44,666 --> 00:22:46,216
autorelease pool and it's safe


637
00:22:46,276 --> 00:22:47,696
to write into the autoreleasing


638
00:22:47,696 --> 00:22:47,976
variable.


639
00:22:53,236 --> 00:22:55,206
And finally, we also have


640
00:22:55,206 --> 00:22:56,306
improved performance and


641
00:22:56,306 --> 00:22:57,706
visualizations of the Clang


642
00:22:57,706 --> 00:22:58,566
Static Analyzer.


643
00:22:59,676 --> 00:23:02,736
So in Xcode 10 we have improved


644
00:23:02,736 --> 00:23:03,966
the analyzer to explore your


645
00:23:03,966 --> 00:23:05,536
program in a more efficient way


646
00:23:05,766 --> 00:23:08,386
so now it finds up to 15% more


647
00:23:09,096 --> 00:23:10,666
bugs during the same analysis


648
00:23:10,666 --> 00:23:11,006
time.


649
00:23:11,896 --> 00:23:14,226
And not only it finds more bugs


650
00:23:14,786 --> 00:23:16,556
the bug report it now generates


651
00:23:17,006 --> 00:23:19,116
tend to be smaller and more


652
00:23:19,116 --> 00:23:19,906
understandable.


653
00:23:20,116 --> 00:23:22,006
And what I mean by that is


654
00:23:22,006 --> 00:23:25,026
sometimes in Xcode 10 you would


655
00:23:25,026 --> 00:23:26,646
get examples which have a lot of


656
00:23:26,646 --> 00:23:28,866
steps and a lot of arrows and


657
00:23:28,866 --> 00:23:30,016
which would be somewhat hard to


658
00:23:30,016 --> 00:23:30,686
comprehend.


659
00:23:31,246 --> 00:23:33,976
And in many of those examples in


660
00:23:33,976 --> 00:23:36,256
your version of Xcode we give


661
00:23:36,256 --> 00:23:38,196
you a much smaller error path


662
00:23:38,196 --> 00:23:40,116
which is much easier to see and


663
00:23:40,116 --> 00:23:41,146
you can see the issue much


664
00:23:41,146 --> 00:23:41,656
faster.


665
00:23:43,116 --> 00:23:45,346
So in order to use Static


666
00:23:45,346 --> 00:23:47,566
Analyzer on your projects you


667
00:23:47,566 --> 00:23:51,256
can use Product, Analyze or you


668
00:23:51,256 --> 00:23:53,396
can even enable Analyze During


669
00:23:53,396 --> 00:23:55,456
Build to make sure no analyzer


670
00:23:55,456 --> 00:23:56,626
issue gets unnoticed.


671
00:23:56,666 --> 00:23:58,676
So I encourage you to use the


672
00:23:58,676 --> 00:24:00,336
Static Analyzer, it's a great


673
00:24:00,336 --> 00:24:01,726
tool to find your bugs before


674
00:24:01,726 --> 00:24:02,366
users do.


675
00:24:02,706 --> 00:24:04,996
And now my colleague Ahmed will


676
00:24:04,996 --> 00:24:06,376
talk about low-level


677
00:24:06,376 --> 00:24:07,026
improvements.


678
00:24:07,936 --> 00:24:10,916
>> Thank you George.


679
00:24:11,016 --> 00:24:13,000
[ Applause ]


680
00:24:15,046 --> 00:24:16,176
So as Alex and George told you,


681
00:24:16,176 --> 00:24:18,486
we have lots of warnings and


682
00:24:18,776 --> 00:24:20,326
Static Analyzer checks in the


683
00:24:20,326 --> 00:24:22,496
compiler, but you also have the


684
00:24:22,496 --> 00:24:24,186
sanitizer and all of these tools


685
00:24:24,186 --> 00:24:25,476
help you find lots of bugs,


686
00:24:25,576 --> 00:24:26,586
including security bugs.


687
00:24:27,146 --> 00:24:29,606
So I'm sure you all have lots of


688
00:24:29,606 --> 00:24:30,866
tests and use all these great


689
00:24:30,866 --> 00:24:33,766
tools to find all the bugs in


690
00:24:33,766 --> 00:24:34,366
these tests.


691
00:24:35,066 --> 00:24:36,126
But for some of the most


692
00:24:36,126 --> 00:24:38,496
egregious security bugs we want


693
00:24:38,496 --> 00:24:39,546
to make sure that they don't


694
00:24:39,546 --> 00:24:41,566
happen in release builds if


695
00:24:41,566 --> 00:24:43,126
somehow they snuck past all the


696
00:24:43,126 --> 00:24:43,516
testing.


697
00:24:44,116 --> 00:24:48,246
So for those we have mitigations


698
00:24:48,246 --> 00:24:49,516
in the code generator that are


699
00:24:49,516 --> 00:24:50,856
always emitted even in release


700
00:24:50,886 --> 00:24:51,216
builds.


701
00:24:52,146 --> 00:24:54,326
So I'm Ahmed, I work on the code


702
00:24:54,326 --> 00:24:55,616
generator and today I'm going to


703
00:24:55,616 --> 00:24:57,486
tell you about a new mitigation


704
00:24:57,486 --> 00:24:58,316
in Xcode 10.


705
00:24:58,906 --> 00:25:01,226
So to see how that works we need


706
00:25:01,226 --> 00:25:02,536
to understand how the stack


707
00:25:02,536 --> 00:25:02,936
works.


708
00:25:03,546 --> 00:25:06,896
So here I have a simple C


709
00:25:06,896 --> 00:25:09,706
function called dlog and I use


710
00:25:09,706 --> 00:25:11,196
it to print a string that I'm


711
00:25:11,196 --> 00:25:13,666
passed into a dlog bug.


712
00:25:14,496 --> 00:25:16,306
So in this case it's called with


713
00:25:16,306 --> 00:25:17,286
a string hello.


714
00:25:17,376 --> 00:25:20,016
And the way this works is we


715
00:25:20,016 --> 00:25:22,646
need to allocate some memory to


716
00:25:22,646 --> 00:25:23,976
keep track of this call.


717
00:25:25,816 --> 00:25:27,766
So we allocate that into a


718
00:25:27,766 --> 00:25:28,936
region called the stack.


719
00:25:29,776 --> 00:25:31,946
So the stack grows down towards


720
00:25:31,946 --> 00:25:33,146
the null pointer or address


721
00:25:33,146 --> 00:25:33,436
zero.


722
00:25:34,066 --> 00:25:37,746
So when we do our dlog hello


723
00:25:37,746 --> 00:25:39,586
call this allocates what's


724
00:25:39,586 --> 00:25:41,566
called the stack frame and the


725
00:25:41,566 --> 00:25:43,166
stack frame contains things like


726
00:25:43,166 --> 00:25:44,626
the return address so that we


727
00:25:44,626 --> 00:25:46,486
know to go back to main.


728
00:25:47,306 --> 00:25:48,746
But it also contains other


729
00:25:48,746 --> 00:25:50,286
things like parameters and local


730
00:25:50,286 --> 00:25:50,876
variables.


731
00:25:51,746 --> 00:25:53,686
So for instance if I have a log


732
00:25:53,686 --> 00:25:55,076
file [inaudible] local variable


733
00:25:56,106 --> 00:25:57,606
that lives in the stack frame.


734
00:25:58,206 --> 00:26:01,846
So now if I try to make another


735
00:26:01,846 --> 00:26:03,796
function call to this dlog file


736
00:26:03,796 --> 00:26:06,636
function that in turn will


737
00:26:06,636 --> 00:26:07,846
allocate its own stack frame.


738
00:26:08,226 --> 00:26:11,226
And when it's done it's going to


739
00:26:11,226 --> 00:26:12,856
deallocate the stack frame and


740
00:26:12,856 --> 00:26:14,056
return back to the caller.


741
00:26:14,666 --> 00:26:18,766
So now let's look at this stack


742
00:26:18,766 --> 00:26:20,006
frame in more details.


743
00:26:21,256 --> 00:26:23,046
So let's say I change my


744
00:26:23,046 --> 00:26:25,436
function to have a local buffer,


745
00:26:25,436 --> 00:26:27,336
so it's a 4 bytes character


746
00:26:27,916 --> 00:26:28,006
array.


747
00:26:29,556 --> 00:26:31,136
And I'm trying to prepare my


748
00:26:31,136 --> 00:26:34,166
debug string by first doing a


749
00:26:34,166 --> 00:26:35,466
strcpy of the string that I'm


750
00:26:35,466 --> 00:26:38,466
passed into that buffer.


751
00:26:38,596 --> 00:26:40,696
So this does the obvious copy by


752
00:26:40,916 --> 00:26:44,546
[inaudible], so it does H-E-L-L.


753
00:26:44,546 --> 00:26:47,496
But then there's a problem at


754
00:26:47,496 --> 00:26:48,866
this point we already wrote 4


755
00:26:48,866 --> 00:26:50,786
bytes and that we already


756
00:26:50,786 --> 00:26:52,766
exhausted all 4 bytes available


757
00:26:52,766 --> 00:26:53,276
in our buffer.


758
00:26:54,206 --> 00:26:56,066
So if we keep going which is


759
00:26:56,066 --> 00:26:57,876
what strcpy will do then we're


760
00:26:57,876 --> 00:26:59,276
going to override the return


761
00:26:59,276 --> 00:27:01,536
address and this is a big


762
00:27:01,536 --> 00:27:02,386
security problem.


763
00:27:02,956 --> 00:27:04,826
So if an attacker controls the


764
00:27:04,826 --> 00:27:06,446
string that I'm copying which is


765
00:27:06,716 --> 00:27:08,496
not that hard, then it can


766
00:27:08,496 --> 00:27:09,776
control the return address.


767
00:27:10,276 --> 00:27:11,496
If it can control the return


768
00:27:11,496 --> 00:27:12,626
address then they control


769
00:27:12,626 --> 00:27:13,806
basically what the program does


770
00:27:13,806 --> 00:27:14,706
next, so it's a big security


771
00:27:14,706 --> 00:27:14,976
problem.


772
00:27:19,076 --> 00:27:21,446
So if you had a test that caught


773
00:27:21,506 --> 00:27:23,586
this and you ran the address


774
00:27:23,586 --> 00:27:26,376
sanitizer, then you will have


775
00:27:26,446 --> 00:27:27,886
had an easy way to fix this.


776
00:27:28,436 --> 00:27:29,266
And really what I should have


777
00:27:29,266 --> 00:27:32,686
done here is strncpy that knows


778
00:27:32,686 --> 00:27:34,546
about the size or even better


779
00:27:34,546 --> 00:27:35,876
use a higher-level API like


780
00:27:35,876 --> 00:27:36,886
NSString or [inaudible] string.


781
00:27:37,406 --> 00:27:40,736
But still sometimes these bugs


782
00:27:40,736 --> 00:27:42,236
can survive into release builds


783
00:27:43,156 --> 00:27:46,566
and we avoid these by using


784
00:27:46,566 --> 00:27:48,366
what's called the Stack


785
00:27:49,496 --> 00:27:49,766
Protector.


786
00:27:49,766 --> 00:27:51,086
So the Stack Protector changes


787
00:27:51,086 --> 00:27:52,176
the layout of the stack frame to


788
00:27:52,176 --> 00:27:54,716
add a new field the canary so


789
00:27:55,416 --> 00:27:58,616
that when we do our write we


790
00:27:58,616 --> 00:28:00,136
have a little bit of code right


791
00:28:00,136 --> 00:28:01,256
before the return of the


792
00:28:01,256 --> 00:28:02,796
function that checks whether the


793
00:28:02,796 --> 00:28:04,406
canary is still valid.


794
00:28:05,916 --> 00:28:07,676
So if we keep writing in strcpy


795
00:28:07,676 --> 00:28:08,826
we're going to override the


796
00:28:08,826 --> 00:28:12,666
canary first and then we're


797
00:28:12,666 --> 00:28:14,126
going to check the canary first


798
00:28:14,126 --> 00:28:16,246
before returning and that's


799
00:28:16,246 --> 00:28:16,866
going to abort.


800
00:28:17,686 --> 00:28:19,076
So we turned ad potentially


801
00:28:19,076 --> 00:28:20,276
exploitable security


802
00:28:20,426 --> 00:28:22,516
vulnerability into a reliable


803
00:28:22,516 --> 00:28:24,366
crash and that's not good for an


804
00:28:24,366 --> 00:28:24,766
attacker.


805
00:28:25,386 --> 00:28:27,506
So this is what's called the


806
00:28:27,506 --> 00:28:27,966
Stack Protector.


807
00:28:33,416 --> 00:28:34,896
It defects certain kinds of


808
00:28:34,896 --> 00:28:36,306
stack buffer overflows, which is


809
00:28:36,306 --> 00:28:37,346
the attack that we just saw.


810
00:28:37,406 --> 00:28:39,466
And it's already enabled by


811
00:28:39,466 --> 00:28:41,096
default in many versions of


812
00:28:41,096 --> 00:28:41,416
Xcode.


813
00:28:41,976 --> 00:28:45,856
So next I'm going to talk about


814
00:28:45,856 --> 00:28:47,596
a trickier case where we


815
00:28:47,676 --> 00:28:48,866
introduced a new mitigation.


816
00:28:48,986 --> 00:28:52,346
So let's say I took my function,


817
00:28:52,986 --> 00:28:55,346
again my dlog function and I


818
00:28:55,346 --> 00:28:56,616
changed the buffer so that now


819
00:28:56,616 --> 00:28:57,776
it's a variable length array.


820
00:28:58,856 --> 00:29:00,426
And the length comes from a


821
00:29:00,426 --> 00:29:02,186
parameter called len.


822
00:29:03,756 --> 00:29:07,186
So let's say len in a specific


823
00:29:07,186 --> 00:29:09,046
call is something big like


824
00:29:09,046 --> 00:29:12,006
15,000, so now the stack frame


825
00:29:12,006 --> 00:29:13,826
has to be at least 15,000 bytes


826
00:29:13,826 --> 00:29:14,056
long.


827
00:29:16,696 --> 00:29:18,816
But memory is not all


828
00:29:18,816 --> 00:29:20,636
immediately available, so memory


829
00:29:20,636 --> 00:29:23,216
is split into pages and the


830
00:29:23,216 --> 00:29:25,696
stack grows only when necessary.


831
00:29:26,656 --> 00:29:28,176
So for instance, when we try to


832
00:29:28,176 --> 00:29:30,866
access by 10,000 of the buffer


833
00:29:30,926 --> 00:29:32,136
that's in the next page of the


834
00:29:32,136 --> 00:29:35,066
stack that's not yet available


835
00:29:35,566 --> 00:29:36,716
so it's going to do a page fault


836
00:29:36,716 --> 00:29:37,966
in the CPU that talks to the


837
00:29:37,966 --> 00:29:39,556
opening system, the operating


838
00:29:39,556 --> 00:29:40,586
system sees that we have the


839
00:29:40,586 --> 00:29:42,306
right to grow the stack, and it


840
00:29:42,306 --> 00:29:43,706
grows it and we can continue


841
00:29:43,706 --> 00:29:44,016
writing.


842
00:29:44,936 --> 00:29:46,926
So this all happens under the


843
00:29:48,816 --> 00:29:48,926
hood.


844
00:29:49,146 --> 00:29:51,736
But say an attacker controls the


845
00:29:51,736 --> 00:29:54,296
length and it makes it huge, big


846
00:29:54,296 --> 00:29:56,256
enough that it spans many pages.


847
00:29:57,556 --> 00:29:58,876
So now there's a new problem,


848
00:29:59,896 --> 00:30:02,626
the memory is not infinite so if


849
00:30:02,626 --> 00:30:04,176
we keep allocating in this stack


850
00:30:04,366 --> 00:30:05,906
eventually we'll hit another


851
00:30:05,906 --> 00:30:07,026
region of memory that's already


852
00:30:07,026 --> 00:30:10,646
allocated and usually that's the


853
00:30:10,646 --> 00:30:10,736
heap.


854
00:30:10,736 --> 00:30:12,116
And when we do that then we're


855
00:30:12,116 --> 00:30:13,226
going to clash with the heap,


856
00:30:13,806 --> 00:30:15,256
with whatever is already used in


857
00:30:15,256 --> 00:30:16,316
there, so that's usually things


858
00:30:16,316 --> 00:30:17,776
like malloc and new.


859
00:30:20,276 --> 00:30:22,016
So if we try to see what would


860
00:30:22,016 --> 00:30:23,816
happen with our strcpy example


861
00:30:24,616 --> 00:30:26,826
then we will try to write the


862
00:30:26,826 --> 00:30:27,696
bytes one by one.


863
00:30:28,406 --> 00:30:32,766
So we do H-E-L, etcetera.


864
00:30:32,816 --> 00:30:34,616
And from the standpoint of the


865
00:30:34,616 --> 00:30:37,026
CPU, the code that's generated


866
00:30:37,026 --> 00:30:38,156
and the operating system this is


867
00:30:38,156 --> 00:30:39,856
all fine because we're just


868
00:30:39,856 --> 00:30:41,586
writing into a page that's


869
00:30:41,586 --> 00:30:43,526
already available and allocated.


870
00:30:44,556 --> 00:30:47,006
But it really isn't because this


871
00:30:47,006 --> 00:30:48,216
is part of the heap, this is not


872
00:30:48,216 --> 00:30:50,046
part of our local stack


873
00:30:50,046 --> 00:30:50,796
allocated array.


874
00:30:51,186 --> 00:30:52,606
So when we do our writes we're


875
00:30:52,606 --> 00:30:53,576
actually overriding some


876
00:30:53,576 --> 00:30:55,586
completely unrelated piece of


877
00:30:55,586 --> 00:30:57,416
information like I don't know a


878
00:30:57,416 --> 00:30:58,496
Boolean that checks whether we


879
00:30:58,496 --> 00:30:59,356
should check a password.


880
00:31:00,126 --> 00:31:01,496
So this is another important


881
00:31:01,496 --> 00:31:01,926
security flaw.


882
00:31:07,046 --> 00:31:08,346
So this is something that we


883
00:31:08,346 --> 00:31:11,026
mitigated with a new feature and


884
00:31:11,026 --> 00:31:13,056
the future works by emitting


885
00:31:13,056 --> 00:31:15,196
some new codes at the entry of


886
00:31:15,196 --> 00:31:17,926
the function that checks whether


887
00:31:17,926 --> 00:31:20,056
it's okay to have the stack


888
00:31:20,056 --> 00:31:20,286
frame.


889
00:31:21,446 --> 00:31:22,806
So it asks the operating system


890
00:31:22,806 --> 00:31:23,976
above the maximum size of the


891
00:31:23,976 --> 00:31:26,146
stack and if you try to make an


892
00:31:26,146 --> 00:31:27,256
allocation that's bigger than


893
00:31:27,256 --> 00:31:29,456
that then it actually aborts.


894
00:31:29,836 --> 00:31:33,106
And again, this turns a


895
00:31:33,106 --> 00:31:34,726
potentially exploitable security


896
00:31:34,726 --> 00:31:37,586
bug into a reliable crash and


897
00:31:37,586 --> 00:31:41,176
that's no good for an attacker.


898
00:31:41,176 --> 00:31:43,076
So this is Stack Checking, it


899
00:31:43,076 --> 00:31:44,116
detects something that you might


900
00:31:44,116 --> 00:31:46,206
have heard of called Stack Clash


901
00:31:46,806 --> 00:31:48,226
and it's enabled by default in


902
00:31:48,226 --> 00:31:48,806
Xcode 10.


903
00:31:53,056 --> 00:31:55,246
So next I want to talk about a


904
00:31:55,246 --> 00:31:56,836
new set of features we added in


905
00:31:56,836 --> 00:31:58,906
Xcode 10 and that's support for


906
00:31:58,906 --> 00:32:00,796
new extension, sect extensions.


907
00:32:01,646 --> 00:32:04,386
So as you all know we have lots


908
00:32:04,386 --> 00:32:07,046
of great Apple devices and one


909
00:32:07,046 --> 00:32:08,536
of the great things about Xcode


910
00:32:08,536 --> 00:32:10,326
is that with just a few build


911
00:32:10,326 --> 00:32:11,856
settings you can target your


912
00:32:11,856 --> 00:32:13,596
code for each of these devices.


913
00:32:13,966 --> 00:32:17,356
And so under the hood in macOS,


914
00:32:17,356 --> 00:32:20,456
iOS, watchOS, etcetera we tweak


915
00:32:20,826 --> 00:32:22,966
every OS so that it uses


916
00:32:22,966 --> 00:32:24,766
everything that's available on a


917
00:32:24,766 --> 00:32:25,986
specific piece of hardware.


918
00:32:26,476 --> 00:32:27,516
So it guarantees maximum


919
00:32:27,516 --> 00:32:29,146
performance no matter where we


920
00:32:29,146 --> 00:32:29,436
run.


921
00:32:29,796 --> 00:32:32,856
And so if you an app with


922
00:32:33,206 --> 00:32:34,736
extremely high-performance


923
00:32:34,736 --> 00:32:35,966
requirements that's something


924
00:32:35,966 --> 00:32:37,156
that you might want to do as


925
00:32:37,156 --> 00:32:37,356
well.


926
00:32:39,516 --> 00:32:41,146
So we have three features to


927
00:32:41,146 --> 00:32:42,916
talk about that are available in


928
00:32:42,916 --> 00:32:44,656
the iMac Pro and the iPhone 8


929
00:32:44,696 --> 00:32:45,946
Plus and X.


930
00:32:46,836 --> 00:32:49,046
And let's start with the iMac


931
00:32:50,996 --> 00:32:51,106
Pro.


932
00:32:51,316 --> 00:32:53,186
So the iMac Pro has the Intel


933
00:32:53,186 --> 00:32:58,006
Xeon CPU which has a set of new


934
00:32:58,006 --> 00:32:59,886
features called AVX-512.


935
00:32:59,886 --> 00:33:03,536
So AVX-512 is a set of new


936
00:33:03,536 --> 00:33:05,326
instructions with vector


937
00:33:05,326 --> 00:33:05,846
registers.


938
00:33:08,476 --> 00:33:12,106
And these provide benefits over


939
00:33:12,386 --> 00:33:16,466
X86-64, so in X86-64 we can only


940
00:33:16,466 --> 00:33:18,546
assume that we have 128-bit


941
00:33:18,546 --> 00:33:20,536
vectors available, so that's


942
00:33:20,536 --> 00:33:21,976
guaranteed on any Mac ever


943
00:33:22,036 --> 00:33:23,836
that's Intel powered.


944
00:33:25,156 --> 00:33:26,886
Now it happens that any new Mac


945
00:33:26,886 --> 00:33:28,946
today has more than that, but


946
00:33:28,946 --> 00:33:30,366
the iMac Pro is the first that


947
00:33:30,366 --> 00:33:32,836
has 512-bit registers.


948
00:33:35,456 --> 00:33:37,246
And with the Auto-Vectorizer


949
00:33:37,246 --> 00:33:39,136
that's enabled in the Xcode


950
00:33:39,136 --> 00:33:41,826
Clang this is great because it


951
00:33:41,826 --> 00:33:43,736
means that we can have many more


952
00:33:43,736 --> 00:33:45,186
elements in the vector.


953
00:33:46,136 --> 00:33:47,676
So this can greatly improve


954
00:33:47,676 --> 00:33:48,246
throughputs.


955
00:33:48,786 --> 00:33:52,346
But there are other benefits


956
00:33:52,346 --> 00:33:55,826
with AVX-512, so for instance we


957
00:33:55,916 --> 00:33:58,086
not only have bigger vectors we


958
00:33:58,086 --> 00:33:59,326
also have more of them.


959
00:33:59,916 --> 00:34:02,546
So on X86-64 we only have 16 now


960
00:34:02,546 --> 00:34:04,526
we have 32, so this is a lot of


961
00:34:04,526 --> 00:34:07,196
data to process.


962
00:34:07,326 --> 00:34:09,085
And even if for some reason the


963
00:34:09,085 --> 00:34:10,735
auto-vectorizer is not able to


964
00:34:11,176 --> 00:34:13,786
make use of these vectors then


965
00:34:13,786 --> 00:34:15,806
we still have ore skill


966
00:34:15,806 --> 00:34:17,235
registers or even for code that


967
00:34:17,235 --> 00:34:18,696
just does float or double.


968
00:34:19,556 --> 00:34:21,166
There are lots of performance


969
00:34:21,166 --> 00:34:22,985
benefits in AVX-512.


970
00:34:23,916 --> 00:34:25,636
So let's look at how we can


971
00:34:26,246 --> 00:34:28,206
exploit it in my compute


972
00:34:28,235 --> 00:34:29,525
[inaudible] expensive function.


973
00:34:30,106 --> 00:34:32,886
So the first thing I'm going to


974
00:34:32,886 --> 00:34:35,065
do is to keep around my existing


975
00:34:35,065 --> 00:34:36,676
function because that's going to


976
00:34:36,676 --> 00:34:38,646
be the fallback that I have that


977
00:34:38,646 --> 00:34:39,896
runs on all Macs.


978
00:34:40,326 --> 00:34:43,275
Next, I can try to specialize my


979
00:34:43,275 --> 00:34:43,696
function.


980
00:34:44,025 --> 00:34:45,815
So one way to do that is using


981
00:34:45,815 --> 00:34:46,806
the target attributes.


982
00:34:47,306 --> 00:34:50,826
And that tells the compiler that


983
00:34:50,826 --> 00:34:52,666
it's okay to assume that this


984
00:34:52,666 --> 00:34:54,516
function has AVX-512, so it only


985
00:34:54,516 --> 00:34:57,206
runs on an iMac Pro.


986
00:34:57,416 --> 00:34:58,926
So if you use simd.h, for


987
00:34:58,926 --> 00:35:01,126
instance the simd float4 128-bit


988
00:35:01,126 --> 00:35:03,336
vector type then now we might


989
00:35:03,336 --> 00:35:04,696
have better performance than the


990
00:35:04,696 --> 00:35:06,466
AVX-512 version using the same


991
00:35:06,466 --> 00:35:06,716
code.


992
00:35:07,216 --> 00:35:10,906
And if you use the even larger


993
00:35:10,906 --> 00:35:12,026
vector types, so for instance


994
00:35:12,026 --> 00:35:14,336
simd float16, then now you have


995
00:35:14,366 --> 00:35:15,606
much better performance than the


996
00:35:15,606 --> 00:35:17,506
AVX-512 version where the


997
00:35:17,506 --> 00:35:19,406
512-bit vector is actually


998
00:35:19,996 --> 00:35:20,146
native.


999
00:35:21,776 --> 00:35:23,146
And if you go all the way down


1000
00:35:23,146 --> 00:35:25,206
to X86 intrinsics, then now you


1001
00:35:25,206 --> 00:35:27,256
can start using the new AVX-512


1002
00:35:27,256 --> 00:35:29,636
variance, as well as the M512


1003
00:35:30,306 --> 00:35:30,436
types.


1004
00:35:32,536 --> 00:35:34,316
So if you want to specialize


1005
00:35:34,496 --> 00:35:35,836
larger units of codes, so not


1006
00:35:35,836 --> 00:35:37,166
just individual functions but


1007
00:35:37,836 --> 00:35:40,706
files, targets, libraries, then


1008
00:35:40,706 --> 00:35:42,936
you can use the new AVX-512


1009
00:35:42,936 --> 00:35:45,156
value of the additional vector


1010
00:35:45,156 --> 00:35:46,116
extensions build setting.


1011
00:35:46,666 --> 00:35:50,236
So when you do that there are


1012
00:35:50,236 --> 00:35:52,176
some things to keep in mind and


1013
00:35:52,176 --> 00:35:53,776
if you're familiar with AVX-1


1014
00:35:53,776 --> 00:35:56,246
and AVX-2 these are very similar


1015
00:35:56,386 --> 00:35:56,816
issues.


1016
00:35:58,516 --> 00:36:00,286
So you can only pass large


1017
00:36:00,286 --> 00:36:03,666
vectors, so 256 bits and up from


1018
00:36:03,666 --> 00:36:05,296
and to AVX-512 functions.


1019
00:36:05,626 --> 00:36:07,766
So the ABI is different from the


1020
00:36:07,766 --> 00:36:09,016
generic and a specialized


1021
00:36:09,016 --> 00:36:10,516
variance, so you cannot pass


1022
00:36:10,516 --> 00:36:13,966
them between those.


1023
00:36:14,166 --> 00:36:16,376
Additionally, these vectors are


1024
00:36:16,376 --> 00:36:18,236
large and they're large enough


1025
00:36:18,236 --> 00:36:19,856
that their natural alignment is


1026
00:36:20,106 --> 00:36:21,966
too big for what's guaranteed by


1027
00:36:21,966 --> 00:36:22,746
things like malloc.


1028
00:36:22,746 --> 00:36:24,216
So you have to take that into


1029
00:36:24,216 --> 00:36:25,596
account when allocating these


1030
00:36:26,526 --> 00:36:30,316
anywhere other than the stack.


1031
00:36:30,316 --> 00:36:31,876
And so in general all of these


1032
00:36:31,956 --> 00:36:33,406
things are things that we are


1033
00:36:33,406 --> 00:36:34,396
already go through lots of


1034
00:36:34,536 --> 00:36:36,056
things in the opening system.


1035
00:36:36,536 --> 00:36:37,936
So for instance, if you can at


1036
00:36:37,936 --> 00:36:40,056
all use accelerate.framework and


1037
00:36:40,056 --> 00:36:41,326
it's much easier to do so


1038
00:36:41,656 --> 00:36:42,976
because we already specialized


1039
00:36:42,976 --> 00:36:44,506
all the functions for every


1040
00:36:44,506 --> 00:36:45,696
single microarchitecture.


1041
00:36:46,346 --> 00:36:49,806
So this is AVX-512.


1042
00:36:50,406 --> 00:36:53,576
Now we also have new features on


1043
00:36:53,576 --> 00:36:56,936
the iPhone 8, 8 Plus and X.


1044
00:36:59,016 --> 00:37:01,716
So one of the first feature is


1045
00:37:02,196 --> 00:37:05,476
ARM v8.1 Atomics and that's


1046
00:37:05,626 --> 00:37:07,066
thanks to one of the great


1047
00:37:07,066 --> 00:37:09,566
things about the iPhone X and


1048
00:37:09,706 --> 00:37:11,976
that's the A11 Bionic chip.


1049
00:37:16,426 --> 00:37:19,786
So the A11 Bionic chip has one


1050
00:37:20,176 --> 00:37:22,426
great new feature compared to


1051
00:37:22,466 --> 00:37:24,616
the A10 which is its support for


1052
00:37:24,956 --> 00:37:27,636
six CPUs, six cores running all


1053
00:37:27,636 --> 00:37:29,326
at the same time and that's a


1054
00:37:29,326 --> 00:37:30,786
first in iOS.


1055
00:37:32,196 --> 00:37:34,386
And since you have more cores


1056
00:37:34,386 --> 00:37:35,326
than you probably have more


1057
00:37:35,326 --> 00:37:37,376
threads all at the same time and


1058
00:37:37,376 --> 00:37:38,616
with more threads you might need


1059
00:37:38,616 --> 00:37:40,376
more synchronization to make


1060
00:37:40,376 --> 00:37:41,326
these threads cooperate.


1061
00:37:42,256 --> 00:37:43,876
And that's implemented using


1062
00:37:43,876 --> 00:37:44,426
atomics.


1063
00:37:45,756 --> 00:37:47,636
So the A11 chip also introduces


1064
00:37:47,636 --> 00:37:48,826
a new family of atomic


1065
00:37:48,826 --> 00:37:51,116
instructions that are better


1066
00:37:51,116 --> 00:37:54,346
optimized for the new extra


1067
00:37:54,346 --> 00:37:54,796
cores.


1068
00:37:55,366 --> 00:37:58,386
So let's look at how that works.


1069
00:37:58,386 --> 00:38:02,536
So the way atomics work is


1070
00:38:03,546 --> 00:38:04,746
through a small sequence of


1071
00:38:04,796 --> 00:38:05,096
codes.


1072
00:38:05,776 --> 00:38:08,116
So suppose I have a thread and


1073
00:38:08,116 --> 00:38:09,156
it's trying to access main


1074
00:38:09,156 --> 00:38:11,856
memory, so it has an atomic


1075
00:38:11,856 --> 00:38:13,826
shared variable in there and


1076
00:38:13,826 --> 00:38:14,996
it's just trying to increment


1077
00:38:15,656 --> 00:38:15,726
it.


1078
00:38:17,216 --> 00:38:18,716
So under the hood the code


1079
00:38:18,716 --> 00:38:20,176
generator will emit a small


1080
00:38:20,176 --> 00:38:23,026
sequence of codes that first


1081
00:38:23,276 --> 00:38:24,946
takes exclusive excess of a


1082
00:38:24,946 --> 00:38:26,816
cache line and that's a small


1083
00:38:26,816 --> 00:38:28,766
region of memory that contains


1084
00:38:28,766 --> 00:38:30,836
completely this atomic variable.


1085
00:38:31,426 --> 00:38:34,816
Now that we have exclusive


1086
00:38:34,816 --> 00:38:36,186
access we can load from the


1087
00:38:36,186 --> 00:38:38,046
variable, then we can do our


1088
00:38:38,046 --> 00:38:39,326
increment on the temporary


1089
00:38:39,436 --> 00:38:41,756
loaded value and store the


1090
00:38:41,756 --> 00:38:43,026
result back.


1091
00:38:44,636 --> 00:38:46,186
And we know that this is safe


1092
00:38:46,186 --> 00:38:47,066
because we have exclusive


1093
00:38:47,066 --> 00:38:48,766
access, so no other thread could


1094
00:38:48,766 --> 00:38:50,376
have changed the value while


1095
00:38:50,376 --> 00:38:51,936
we're computing our temporary


1096
00:38:51,936 --> 00:38:52,346
results.


1097
00:38:53,696 --> 00:38:55,496
But now suppose another thread


1098
00:38:55,496 --> 00:38:57,446
does access either the same


1099
00:38:57,446 --> 00:38:58,906
variable or another variable in


1100
00:38:58,906 --> 00:39:02,536
the same cache line.


1101
00:39:02,776 --> 00:39:04,366
So both are going to try to have


1102
00:39:04,366 --> 00:39:05,876
exclusive access over this


1103
00:39:06,126 --> 00:39:08,616
variable and that is not


1104
00:39:08,616 --> 00:39:09,846
possible, that's what it means


1105
00:39:09,886 --> 00:39:12,196
to be exclusive.


1106
00:39:12,246 --> 00:39:14,346
So both of them are going to


1107
00:39:14,346 --> 00:39:16,636
fail their exclusive access and


1108
00:39:16,636 --> 00:39:17,726
they're going to have to try


1109
00:39:17,726 --> 00:39:18,656
again until one of them


1110
00:39:18,656 --> 00:39:19,146
succeeds.


1111
00:39:19,796 --> 00:39:23,086
And this is not ideal for


1112
00:39:23,086 --> 00:39:23,706
performance.


1113
00:39:24,286 --> 00:39:27,896
So in ARM v8.1 which is the


1114
00:39:28,536 --> 00:39:31,546
architecture in the A10 CPU we


1115
00:39:31,546 --> 00:39:32,636
have new instructions that do


1116
00:39:32,636 --> 00:39:34,626
this all in a single step and in


1117
00:39:34,626 --> 00:39:35,756
some cases, that can greatly


1118
00:39:35,756 --> 00:39:36,566
improve performance.


1119
00:39:37,126 --> 00:39:39,676
So again, this is something that


1120
00:39:39,676 --> 00:39:41,216
you can specialize code for


1121
00:39:41,526 --> 00:39:43,796
using the per function


1122
00:39:43,796 --> 00:39:45,426
specialization or for entire


1123
00:39:45,426 --> 00:39:45,996
targets.


1124
00:39:46,246 --> 00:39:48,086
And this is something that's


1125
00:39:48,086 --> 00:39:49,606
only really useful when you have


1126
00:39:49,606 --> 00:39:52,106
your own C11 or C++ 11 atomics.


1127
00:39:53,086 --> 00:39:54,486
So in general, it's much easier


1128
00:39:54,486 --> 00:39:55,736
to use the higher-level


1129
00:39:56,146 --> 00:39:58,376
libraries like GCD or PThread or


1130
00:39:58,376 --> 00:39:58,976
os unfair lock, etcetera.


1131
00:39:59,106 --> 00:40:02,096
So these are already tweaked for


1132
00:40:02,096 --> 00:40:03,976
ARM v8.1, but they also


1133
00:40:03,976 --> 00:40:04,976
cooperate to the operating


1134
00:40:04,976 --> 00:40:06,236
system to have even better


1135
00:40:06,236 --> 00:40:06,856
performance.


1136
00:40:11,216 --> 00:40:13,446
So another feature in the A11


1137
00:40:13,506 --> 00:40:15,356
CPU is 16-bit floating points.


1138
00:40:16,346 --> 00:40:18,186
So you are all familiar with the


1139
00:40:18,616 --> 00:40:20,366
two standard floating point


1140
00:40:20,366 --> 00:40:21,966
types, so we have double which


1141
00:40:21,966 --> 00:40:24,596
is 64 bits and float which is 32


1142
00:40:24,596 --> 00:40:24,956
bits.


1143
00:40:26,186 --> 00:40:27,456
So on A11 we also have the


1144
00:40:27,456 --> 00:40:31,756
16-bit float16, this has much


1145
00:40:31,756 --> 00:40:34,436
less range and precision so it's


1146
00:40:34,966 --> 00:40:37,126
not as useful for as many cases.


1147
00:40:37,916 --> 00:40:39,066
But in some cases like machine


1148
00:40:39,066 --> 00:40:39,856
learning or when you're trying


1149
00:40:39,856 --> 00:40:41,986
to talk to GPU via Metal this is


1150
00:40:41,986 --> 00:40:43,236
great because it's smaller and


1151
00:40:43,236 --> 00:40:44,176
it's faster to compute.


1152
00:40:45,256 --> 00:40:46,726
And that's even more true if you


1153
00:40:46,726 --> 00:40:48,166
put them in vectors where you


1154
00:40:48,166 --> 00:40:49,626
can put more of them in the same


1155
00:40:49,866 --> 00:40:50,456
ARM vector.


1156
00:40:51,086 --> 00:40:54,476
So this is also something that


1157
00:40:54,476 --> 00:40:56,966
you can specialize code for and


1158
00:40:56,966 --> 00:40:58,426
in general something to keep in


1159
00:40:58,426 --> 00:40:59,966
mind with all of these features


1160
00:41:00,586 --> 00:41:01,716
is that they're not available


1161
00:41:01,716 --> 00:41:02,106
everywhere.


1162
00:41:03,516 --> 00:41:05,166
So when you want to use them you


1163
00:41:05,166 --> 00:41:06,666
have to always make sure that


1164
00:41:06,666 --> 00:41:08,246
they're actually dynamically


1165
00:41:08,246 --> 00:41:09,246
available on the device you're


1166
00:41:09,246 --> 00:41:11,096
running and you can do that


1167
00:41:11,096 --> 00:41:12,236
using sysctlbyname.


1168
00:41:12,436 --> 00:41:15,326
And so in general we already do


1169
00:41:15,326 --> 00:41:16,736
all this in system framework, so


1170
00:41:16,736 --> 00:41:18,546
it's much easier to just rely on


1171
00:41:18,546 --> 00:41:18,966
those.


1172
00:41:19,546 --> 00:41:22,776
So these are three new


1173
00:41:22,776 --> 00:41:24,666
instruction set extensions, we


1174
00:41:24,666 --> 00:41:26,786
have on the iMac Pro AVX-512 and


1175
00:41:26,856 --> 00:41:28,606
on iPhone X, 8, and 8 Plus we


1176
00:41:28,606 --> 00:41:30,526
have Atomics and 16-bit floating


1177
00:41:30,526 --> 00:41:30,836
points.


1178
00:41:31,256 --> 00:41:35,306
So that's just part of all the


1179
00:41:35,306 --> 00:41:36,556
new features in Xcode.


1180
00:41:37,306 --> 00:41:39,356
So from ARC object pointers in C


1181
00:41:39,356 --> 00:41:41,026
Structs to the improved static


1182
00:41:41,026 --> 00:41:42,756
analyzer there are lots of great


1183
00:41:42,796 --> 00:41:43,696
things in Xcode 10.


1184
00:41:44,286 --> 00:41:45,986
And there are also some things


1185
00:41:45,986 --> 00:41:47,176
that we didn't even talk about


1186
00:41:47,516 --> 00:41:48,616
like for instance, over a


1187
00:41:48,616 --> 00:41:50,446
hundred new warnings and support


1188
00:41:50,446 --> 00:41:53,186
for C++ 17 standard library


1189
00:41:53,186 --> 00:41:53,586
function.


1190
00:41:55,496 --> 00:41:57,636
So if you want to learn more we


1191
00:41:57,636 --> 00:41:59,226
have the video and the slides


1192
00:41:59,226 --> 00:42:00,466
available on the website soon.


1193
00:42:01,006 --> 00:42:01,826
And if you're here at the


1194
00:42:01,826 --> 00:42:03,296
conference come join us at the


1195
00:42:03,296 --> 00:42:04,146
lab this afternoon.


1196
00:42:04,146 --> 00:42:04,756
Thank you.


1197
00:42:05,516 --> 00:42:11,500
[ Applause ]

