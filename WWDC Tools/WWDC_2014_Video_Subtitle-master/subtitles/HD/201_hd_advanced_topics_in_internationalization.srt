1
00:00:13,536 --> 00:00:14,126
>> All right.


2
00:00:14,166 --> 00:00:15,086
Good morning, everyone.


3
00:00:15,356 --> 00:00:17,046
Good to see you all
here bright and early.


4
00:00:17,256 --> 00:00:20,216
We're here today to talk to
you about internationalization.


5
00:00:21,786 --> 00:00:24,046
Now if you've been
following along


6
00:00:24,046 --> 00:00:25,346
with our previous years' talks


7
00:00:25,346 --> 00:00:26,836
on international
support then you know


8
00:00:26,836 --> 00:00:28,836
that the App Store
is available in many,


9
00:00:28,836 --> 00:00:31,936
many countries worldwide,
more than 150 by last count.


10
00:00:32,646 --> 00:00:35,476
So I'm sure you've all
made your apps localizable,


11
00:00:35,476 --> 00:00:37,496
so you can send them
out to localizers


12
00:00:37,496 --> 00:00:40,126
and make them available
in multiple languages.


13
00:00:41,246 --> 00:00:42,456
Is that sufficient though?


14
00:00:42,726 --> 00:00:44,676
Well, not necessarily.


15
00:00:45,166 --> 00:00:48,956
You need to take some care with
regard to internationalization,


16
00:00:49,426 --> 00:00:53,056
otherwise you might end up
with complaints like say,


17
00:00:54,176 --> 00:00:57,676
half of the contact names show
up backwards in their app.


18
00:00:57,676 --> 00:01:00,326
Or, the dates in this
application are unreadable.


19
00:01:00,326 --> 00:01:02,146
Or, my text is all messed up.


20
00:01:03,176 --> 00:01:06,546
Working in this area we've seen
problems like this occur many,


21
00:01:06,546 --> 00:01:09,406
many times, and we're here today
to tell you how to fix them.


22
00:01:09,406 --> 00:01:13,436
What we're going to
do is, first of all,


23
00:01:13,876 --> 00:01:15,936
we'll run through what
we have that's new


24
00:01:15,936 --> 00:01:18,906
in international support
in Yosemite and iOS 8.


25
00:01:19,446 --> 00:01:22,266
Then we'll go into
detail about language


26
00:01:22,266 --> 00:01:23,536
and locale when you use what.


27
00:01:23,666 --> 00:01:25,166
And then we're going
to run through a number


28
00:01:25,166 --> 00:01:28,136
of case studies,
problems that we've seen


29
00:01:28,456 --> 00:01:32,736
in internationalization
and how to fix them.


30
00:01:32,976 --> 00:01:36,016
So let's start off with what's
new in internationalization


31
00:01:36,386 --> 00:01:38,486
and the latest releases
of our operating systems.


32
00:01:38,486 --> 00:01:41,686
We have a number of nice, new
features, both at the user level


33
00:01:41,906 --> 00:01:44,076
and in APIs at the
developer level.


34
00:01:44,076 --> 00:01:46,886
So at the user level
we have for iOS,


35
00:01:46,886 --> 00:01:51,446
a number of new localizations
and some new keyboards.


36
00:01:51,736 --> 00:01:54,616
We've redone the iOS
language and region settings.


37
00:01:55,916 --> 00:01:58,466
And we have some
new improvements


38
00:01:58,466 --> 00:01:59,736
to lunar Calendar support.


39
00:02:00,266 --> 00:02:04,346
Then in API at the developer
level, we have an API


40
00:02:04,346 --> 00:02:05,946
for string encoding detection.


41
00:02:06,806 --> 00:02:08,765
We have some interesting
new formatters


42
00:02:08,846 --> 00:02:11,926
and something new called
formatting context,


43
00:02:11,926 --> 00:02:13,336
which I'll go into
in a few minutes.


44
00:02:14,736 --> 00:02:16,546
So let's start with
the new localizations


45
00:02:16,546 --> 00:02:18,036
and keyboards we have for iOS.


46
00:02:18,036 --> 00:02:21,126
We have new localizations for
Hindi, for Indian English,


47
00:02:21,126 --> 00:02:25,786
Canadian French, and Hong Kong
Chinese, and some new keyboards.


48
00:02:25,786 --> 00:02:29,856
First of all, for three Indic
languages, Bengali, Marathi


49
00:02:29,856 --> 00:02:32,936
and Urdu, to go along
with our existing Hindi


50
00:02:32,936 --> 00:02:34,116
and Tamil keyboards.


51
00:02:34,116 --> 00:02:36,516
And we also have keyboards
for Indian English,


52
00:02:36,516 --> 00:02:38,066
Filipino and Slovenian.


53
00:02:38,766 --> 00:02:42,866
And there are a number of
other new things like new fonts


54
00:02:43,136 --> 00:02:44,906
for various scripts worldwide.


55
00:02:47,106 --> 00:02:48,776
Second, so you may recall


56
00:02:48,776 --> 00:02:50,686
that in Mavericks we
redid the language


57
00:02:50,686 --> 00:02:52,046
and region settings for OS X.


58
00:02:52,046 --> 00:02:54,636
Well this time around,
it's the turn of iOS.


59
00:02:54,636 --> 00:02:57,826
And in iOS 8, we've redone the
language and region settings,


60
00:02:58,316 --> 00:03:00,936
and they look something
like this now.


61
00:03:01,316 --> 00:03:04,386
So you can still as always
specify the primary language


62
00:03:04,386 --> 00:03:05,146
for localization.


63
00:03:06,336 --> 00:03:09,536
But now in addition, in
iOS you can also specify,


64
00:03:09,576 --> 00:03:11,836
users can specify the whole list


65
00:03:11,836 --> 00:03:13,606
of their preferred
languages in order.


66
00:03:14,186 --> 00:03:18,506
So one thing this allows you
to do is to localize your apps


67
00:03:18,836 --> 00:03:22,616
into localizations for which
Apple does not provide a primary


68
00:03:22,696 --> 00:03:26,376
OS localization simply because
the users can specify those


69
00:03:26,376 --> 00:03:28,666
ahead of one of the
localizations


70
00:03:28,666 --> 00:03:30,346
that Apple provides, and
then your app will run


71
00:03:30,346 --> 00:03:34,406
in those languages for
the users who need that.


72
00:03:34,616 --> 00:03:36,336
There also is an
advanced setting


73
00:03:36,336 --> 00:03:38,746
that allows specifying
the language


74
00:03:38,746 --> 00:03:40,466
of the region format
independently


75
00:03:40,876 --> 00:03:41,996
of the localization.


76
00:03:43,316 --> 00:03:45,486
We make them the
same by default,


77
00:03:45,486 --> 00:03:47,466
but users can change
them if they like.


78
00:03:47,466 --> 00:03:50,336
And we'll go into that
in more detail later on.


79
00:03:51,456 --> 00:03:54,176
We have some improvements to
our support for lunar calendars.


80
00:03:54,626 --> 00:03:59,186
So in our Calendar applications,
we now have the support


81
00:03:59,186 --> 00:04:03,586
for turning on, as an
overlay, lunar calendar dates


82
00:04:03,586 --> 00:04:05,806
in addition to Gregorian dates.


83
00:04:06,196 --> 00:04:09,096
We also have a couple
of new Calendar options.


84
00:04:09,096 --> 00:04:11,066
These are variants on
the Islamic calendar.


85
00:04:11,366 --> 00:04:13,976
Let's take a little
closer look at what the,


86
00:04:13,976 --> 00:04:18,716
so this is Calendar app
with Chinese calendar,


87
00:04:19,036 --> 00:04:20,666
lunar calendar dates, turned on.


88
00:04:20,666 --> 00:04:23,716
You see, they show up as an
overlay underneath the Gregorian


89
00:04:23,716 --> 00:04:24,156
dates here.


90
00:04:24,156 --> 00:04:27,426
It's very useful for
Chinese customers.


91
00:04:28,596 --> 00:04:30,636
And here's what this
looks like in OS X.


92
00:04:31,996 --> 00:04:33,986
And see here the
Gregorian dates on the right


93
00:04:33,986 --> 00:04:35,966
and the lunar calendar
dates on the left.


94
00:04:36,836 --> 00:04:41,996
At the API level, these
are APIs available


95
00:04:41,996 --> 00:04:46,386
at the foundation level
on both iOS and OS X.


96
00:04:46,386 --> 00:04:48,986
So you may recall from some
previous years' text sessions,


97
00:04:48,986 --> 00:04:51,736
we talked about the unfortunate
situation that can occur


98
00:04:52,076 --> 00:04:55,996
when you have a TXT file or some
other chunk of external text


99
00:04:56,356 --> 00:04:58,966
and you don't happen to
know what encoding it's in.


100
00:04:59,556 --> 00:05:03,516
Well, in that case, you may
have no other option but to try


101
00:05:03,516 --> 00:05:05,806
to guess the encoding
from the text.


102
00:05:06,346 --> 00:05:10,676
We now have a specific API to do
that automatically for you based


103
00:05:10,676 --> 00:05:12,886
on all the evidence that's
available from the text.


104
00:05:14,086 --> 00:05:15,386
And it's very handy.


105
00:05:15,386 --> 00:05:16,566
There are lots of options.


106
00:05:16,886 --> 00:05:20,186
You can have it do the whole
conversion for you once,


107
00:05:20,186 --> 00:05:22,286
or just tell you what it
thinks the encoding is.


108
00:05:23,426 --> 00:05:26,286
You can have lossy or
non-lossy conversion.


109
00:05:26,586 --> 00:05:29,286
And if you happen to think you
known what encoding it's likely


110
00:05:29,286 --> 00:05:32,696
to be in, you can specify those,
or you can require it to be one


111
00:05:32,696 --> 00:05:34,516
of a certain list of encodings.


112
00:05:36,586 --> 00:05:38,806
We also have a number
of nice, new formatters.


113
00:05:39,536 --> 00:05:42,076
So NSDateFormatter is great
if the thing you're trying


114
00:05:42,076 --> 00:05:46,056
to format is a date, a
particular moment in time.


115
00:05:46,676 --> 00:05:49,946
But what if what you're trying
to format is more like an amount


116
00:05:49,946 --> 00:05:51,446
of time, extent, or an interval.


117
00:05:52,466 --> 00:05:54,616
We have
NSDateComponentsFormatter


118
00:05:54,996 --> 00:05:59,966
for displaying durations or
amounts of time, number of hours


119
00:05:59,966 --> 00:06:01,736
or minutes or weeks
or what have you.


120
00:06:03,266 --> 00:06:06,146
You can specify the amount
of time either as a start


121
00:06:06,146 --> 00:06:09,426
and an end date or a time
interval, or you can specify all


122
00:06:09,426 --> 00:06:11,036
of the components
individually if you like.


123
00:06:12,006 --> 00:06:14,086
Then you can specify how
it's supposed to be formatted


124
00:06:14,366 --> 00:06:17,666
with one of a list of
date and time styles.


125
00:06:18,086 --> 00:06:20,676
And you can also get
to specify exactly


126
00:06:20,756 --> 00:06:22,896
which of the components
you want displayed.


127
00:06:24,376 --> 00:06:26,066
And there are some
interesting things too.


128
00:06:26,476 --> 00:06:29,296
You can turn on, in a
locale-sensitive way,


129
00:06:29,296 --> 00:06:33,826
you can add language to it that
says "about" a certain amount


130
00:06:33,826 --> 00:06:35,426
of time, if this is
an approximate time.


131
00:06:35,566 --> 00:06:39,616
Or the locale-sensitive
way of saying "remaining".


132
00:06:39,616 --> 00:06:42,266
For example, if this is a sort
of countdown of some sort.


133
00:06:42,836 --> 00:06:46,236
So here are some examples of
this in various languages.


134
00:06:46,606 --> 00:06:49,346
You can as I say,
choose various styles,


135
00:06:49,346 --> 00:06:52,406
either a lengthy spell-out kind
of style, something shorter,


136
00:06:52,406 --> 00:06:53,916
something very short
and numerical only.


137
00:06:54,286 --> 00:06:56,866
And the last line shows
the "about" option.


138
00:06:57,806 --> 00:07:01,986
Now one thing I want you
to notice here is that some


139
00:07:01,986 --> 00:07:05,126
of these have their
first word capitalized.


140
00:07:05,486 --> 00:07:06,406
Well that's appropriate


141
00:07:06,406 --> 00:07:07,886
since they're showing
up in the table here.


142
00:07:08,786 --> 00:07:12,946
But there are other contexts
where you might want these not


143
00:07:12,946 --> 00:07:14,096
to have the first
word capitalized,


144
00:07:14,096 --> 00:07:16,376
say if they were showing up
in the middle of a sentence.


145
00:07:17,016 --> 00:07:19,746
And I'll talk about that
more in just a minute.


146
00:07:19,746 --> 00:07:25,076
Another new formatter,
NSDateIntervalFormatter,


147
00:07:25,596 --> 00:07:29,226
if what you're trying to
display is a range of times


148
00:07:30,026 --> 00:07:33,836
from some beginning time or
date to some end time or date,


149
00:07:34,236 --> 00:07:37,366
you might want in
this case to say,


150
00:07:37,706 --> 00:07:41,346
not to shown only once
the pieces that are common


151
00:07:41,446 --> 00:07:43,026
to the start and end date.


152
00:07:43,026 --> 00:07:44,856
NSDateIntervalFormatter
will do that for you.


153
00:07:45,746 --> 00:07:47,556
You provide the start
date and the end date.


154
00:07:48,666 --> 00:07:53,286
You can specify again any of
a list of date or time styles


155
00:07:53,586 --> 00:07:57,766
or a template for full control
over which pieces get displayed.


156
00:07:58,846 --> 00:08:00,366
So here are some
examples of this.


157
00:08:00,516 --> 00:08:01,966
And again, in various languages,


158
00:08:02,286 --> 00:08:05,046
so you can see it can
show a range of dates,


159
00:08:05,046 --> 00:08:07,836
or a range of times, or a
range of dates and times,


160
00:08:08,306 --> 00:08:12,306
and appropriately the pieces
that are common to the start


161
00:08:12,306 --> 00:08:14,506
and end are only shown once.


162
00:08:16,796 --> 00:08:22,376
We also have some specific
formatters for particular kinds


163
00:08:22,416 --> 00:08:24,166
of quantities: energy,
length and mass.


164
00:08:25,146 --> 00:08:26,576
That's NSEnergyFormatter,


165
00:08:26,576 --> 00:08:28,206
NSLengthFormatter,
NSMassFormatter.


166
00:08:28,446 --> 00:08:31,376
This is very useful, for
example, if you're working


167
00:08:31,376 --> 00:08:34,395
with HealthKit and you're
trying to display, say,


168
00:08:35,066 --> 00:08:36,905
the number of calories
a person has consumed,


169
00:08:36,905 --> 00:08:38,885
or how tall they are,
how far they run,


170
00:08:38,885 --> 00:08:40,216
or how much they weigh.


171
00:08:42,056 --> 00:08:46,276
And it will show these numeric
parts plus a localized unit.


172
00:08:46,746 --> 00:08:48,836
You can specify the
exact unit you want,


173
00:08:48,836 --> 00:08:51,746
or you can request
locale-appropriate unit,


174
00:08:51,746 --> 00:08:53,886
whatever's standard in
that particular locale.


175
00:08:54,356 --> 00:08:56,326
There's a number
formatter attached to it,


176
00:08:56,566 --> 00:08:58,546
so you can use all the
number formatter options


177
00:08:58,546 --> 00:08:59,856
for formatting the numeric part.


178
00:09:00,986 --> 00:09:03,016
And there's a special
option you can check


179
00:09:03,386 --> 00:09:05,796
if that mass is particularly
for a person's weight


180
00:09:05,796 --> 00:09:07,206
or if the energy is
particularly for food


181
00:09:07,206 --> 00:09:11,466
because there may be particular
standards for displaying those.


182
00:09:12,106 --> 00:09:18,016
So here are some examples of
that in various languages.


183
00:09:18,056 --> 00:09:24,206
You can see that the units
vary, and the numbers,


184
00:09:24,456 --> 00:09:29,056
you can choose an
appropriate format for those.


185
00:09:29,836 --> 00:09:31,716
Finally, formatting context.


186
00:09:32,006 --> 00:09:34,816
Now remember as I mentioned
before, you may need


187
00:09:34,816 --> 00:09:37,826
to have a piece of
text that's formatted.


188
00:09:37,826 --> 00:09:39,946
You might want to capitalize
differently depending


189
00:09:39,946 --> 00:09:41,036
on where it's showing up.


190
00:09:41,906 --> 00:09:44,556
And for some languages there
are other transformations


191
00:09:44,556 --> 00:09:48,826
that may need to apply depending
on where it shows up in your UI.


192
00:09:49,136 --> 00:09:52,296
So we have a new property of
formatting context available


193
00:09:52,296 --> 00:09:54,886
for date and number formatter
and date components formatter


194
00:09:54,886 --> 00:09:56,276
and byte count formatter
currently.


195
00:09:57,226 --> 00:09:59,136
It's the formatting
context property.


196
00:09:59,336 --> 00:10:02,706
It's one of an enumerated
set of values to specify


197
00:10:03,066 --> 00:10:05,226
where this formatted
thing is supposed to end


198
00:10:06,106 --> 00:10:07,676
up so it can be capitalized


199
00:10:07,676 --> 00:10:11,596
or otherwise appropriately
changed for its context.


200
00:10:12,166 --> 00:10:14,466
You can choose the standalone
context, for example,


201
00:10:14,466 --> 00:10:16,526
if it's going to appear
by itself in a field.


202
00:10:17,446 --> 00:10:18,896
So that might be capitalized.


203
00:10:19,366 --> 00:10:22,146
The list item context, say,
if it's going to be in a menu


204
00:10:22,146 --> 00:10:23,036
or something like that.


205
00:10:24,216 --> 00:10:25,636
The beginning of
sentence context,


206
00:10:26,046 --> 00:10:27,876
again usually capitalized.


207
00:10:28,946 --> 00:10:32,176
And the middle of the sentence
context probably will not


208
00:10:32,176 --> 00:10:33,076
be capitalized.


209
00:10:33,446 --> 00:10:38,136
But, it may happen that your
formatted result is going


210
00:10:38,136 --> 00:10:40,166
to show up, it's
going to be inserted


211
00:10:40,166 --> 00:10:43,126
into a localized string, and
you don't know a priority


212
00:10:43,126 --> 00:10:45,746
without having that localized
string yet whether it's going


213
00:10:45,746 --> 00:10:47,296
to be at the start or
somewhere in the middle.


214
00:10:48,046 --> 00:10:50,966
So we have another
value, the dynamic value.


215
00:10:51,256 --> 00:10:54,246
You just specify that and
then once it's inserted


216
00:10:54,296 --> 00:10:58,296
into that format string,
it gets automatically,


217
00:10:58,486 --> 00:11:01,276
it automatically detects whether
it's a start or in the middle,


218
00:11:01,276 --> 00:11:02,676
and it will capitalize it


219
00:11:02,676 --> 00:11:06,536
or otherwise change it
appropriately automatically.


220
00:11:08,186 --> 00:11:09,186
So that's what new.


221
00:11:09,736 --> 00:11:12,546
And now I'm going to bring up
my colleague, Deborah Goldsmith


222
00:11:12,626 --> 00:11:16,756
to go into detail about
languages and locales.


223
00:11:17,606 --> 00:11:18,846
>> Thanks, Doug.


224
00:11:20,236 --> 00:11:21,316
Hi, everybody.


225
00:11:21,596 --> 00:11:25,156
Today we're going to talk
about languages and locales,


226
00:11:25,256 --> 00:11:27,906
the differences between
them, and how to use them.


227
00:11:29,316 --> 00:11:31,526
So Doug just showed
us the new language


228
00:11:31,526 --> 00:11:33,556
and region settings in iOS 8.


229
00:11:34,066 --> 00:11:35,666
Here you can see an example.


230
00:11:35,666 --> 00:11:38,216
On the left there's
the language settings.


231
00:11:38,456 --> 00:11:41,296
And you can see there's a list
of three languages, English,


232
00:11:41,356 --> 00:11:43,746
simplified Chinese, and
traditional Chinese.


233
00:11:44,366 --> 00:11:46,866
On the right, you see the
Region or Locale setting,


234
00:11:47,346 --> 00:11:50,286
and that's showing a region
of United States which,


235
00:11:50,286 --> 00:11:53,346
together with English, makes
a locale of U.S. English.


236
00:11:54,206 --> 00:11:56,836
So, why are there
two preferences?


237
00:11:56,836 --> 00:11:57,726
What are they used for?


238
00:11:58,436 --> 00:12:00,636
Well, the language
setting keeps track


239
00:12:00,636 --> 00:12:03,656
of which languages the
user prefers to use.


240
00:12:04,246 --> 00:12:07,086
The Region or Locale
setting keeps track


241
00:12:07,086 --> 00:12:09,686
of which regional conventions
they want to follow.


242
00:12:10,496 --> 00:12:12,206
It's worth pointing
out that neither


243
00:12:12,206 --> 00:12:15,936
of these indicates the language
that users use in documents.


244
00:12:15,936 --> 00:12:17,556
That might be the same language,


245
00:12:17,586 --> 00:12:19,516
but it might be something
completely different.


246
00:12:19,696 --> 00:12:22,136
And we'll talk more about
that a little later on.


247
00:12:24,416 --> 00:12:26,916
So, let's look a
little more closely


248
00:12:26,916 --> 00:12:28,676
at the preferred language list.


249
00:12:30,316 --> 00:12:31,076
What uses it?


250
00:12:31,646 --> 00:12:33,366
Well, probably the
most important thing


251
00:12:33,366 --> 00:12:35,856
that uses the preferred
language list is NSBundle.


252
00:12:36,306 --> 00:12:39,566
It uses that information
to pick the localization


253
00:12:40,036 --> 00:12:42,026
that your app uses when it runs.


254
00:12:43,376 --> 00:12:45,096
But it's also used by NSString.


255
00:12:45,436 --> 00:12:49,476
NSString has several
language-sensitive operations


256
00:12:49,476 --> 00:12:53,316
such as localized string
comparison or breaking text


257
00:12:53,316 --> 00:12:54,846
into words or sentences.


258
00:12:55,306 --> 00:12:59,106
And NSString uses the preferred
language list to determine


259
00:12:59,106 --> 00:13:00,536
which language to use for that.


260
00:13:01,496 --> 00:13:02,976
It's also used by WebKit.


261
00:13:03,536 --> 00:13:06,666
Every time WebKit sends a
request to a web server,


262
00:13:07,246 --> 00:13:11,166
it includes in the HTTP header
a field called Accept-Language,


263
00:13:11,416 --> 00:13:13,666
which is essentially the
preferred language list.


264
00:13:14,076 --> 00:13:16,856
The web server looks at
that information and uses it


265
00:13:16,856 --> 00:13:21,386
to decide which language to
use for the page it sends back.


266
00:13:23,156 --> 00:13:25,286
The list is in preference order


267
00:13:25,646 --> 00:13:27,766
from the user's most
preferred language


268
00:13:27,766 --> 00:13:29,806
to the one they want
to see last.


269
00:13:30,346 --> 00:13:33,256
Any languages that the
user is not interested


270
00:13:33,256 --> 00:13:34,916
in don't appear in
the list at all.


271
00:13:35,896 --> 00:13:38,776
So, effectively, it's a little
more complicated than this,


272
00:13:38,806 --> 00:13:41,986
but effectively what apps
and websites do is step


273
00:13:41,986 --> 00:13:44,646
through the list in
order, and they look


274
00:13:44,646 --> 00:13:46,806
for the first language
that they support.


275
00:13:47,596 --> 00:13:49,776
And then they use that
as their localization.


276
00:13:50,176 --> 00:13:52,416
If they don't find a
language that they support,


277
00:13:52,966 --> 00:13:55,146
then they'll use a
default that depends


278
00:13:55,146 --> 00:13:57,396
on the particular
application or website.


279
00:13:58,206 --> 00:14:02,226
By contrast, NSString will
use the very first language


280
00:14:02,226 --> 00:14:04,476
in the list always
as the language


281
00:14:04,476 --> 00:14:06,606
for language-sensitive
operations.


282
00:14:07,976 --> 00:14:10,376
It's worth pointing out that


283
00:14:11,026 --> 00:14:13,246
when the user changes
the language preference,


284
00:14:13,856 --> 00:14:16,606
apps don't pick it up until
the next time they restart.


285
00:14:16,656 --> 00:14:20,106
So, they'll keep using the old
setting until that happens.


286
00:14:21,916 --> 00:14:25,266
So now let's talk about the
Locale or Region setting


287
00:14:25,266 --> 00:14:28,676
in a little bit more detail
and see what it's used for.


288
00:14:30,296 --> 00:14:33,796
Well, most importantly,
it's used for the locale,


289
00:14:33,796 --> 00:14:35,416
in particular, the
current locale.


290
00:14:35,516 --> 00:14:37,806
It determines the
properties of that locale,


291
00:14:38,366 --> 00:14:39,926
many different properties


292
00:14:39,926 --> 00:14:42,606
that determine the
regional conventions.


293
00:14:43,886 --> 00:14:46,896
In turn, that controls the
behavior of formatters,


294
00:14:46,896 --> 00:14:50,826
both the familiar daytime and
number formatters that have been


295
00:14:50,826 --> 00:14:54,146
around for a while, and
also all the new formatters


296
00:14:54,146 --> 00:14:55,366
that Doug just talked about.


297
00:14:56,346 --> 00:14:59,966
It controls the behavior of
calendars, both the calendar


298
00:14:59,966 --> 00:15:01,706
that you're using, for example,


299
00:15:02,066 --> 00:15:05,456
you might use the Gregorian
calendar in one country


300
00:15:05,806 --> 00:15:07,296
or the Thai Buddhist calendar.


301
00:15:08,086 --> 00:15:10,776
But it also controls
other calendar aspects


302
00:15:10,776 --> 00:15:13,076
such as what's the
first day of the week?


303
00:15:13,076 --> 00:15:15,156
Is it Monday, Sunday
or something else?


304
00:15:15,786 --> 00:15:19,496
Now in contrast to the
language preference,


305
00:15:20,666 --> 00:15:23,336
when the user changes
the locale preference,


306
00:15:23,736 --> 00:15:25,406
apps don't need to restart.


307
00:15:25,406 --> 00:15:27,906
They're supposed to pick up
that new setting right away.


308
00:15:28,296 --> 00:15:33,486
And we'll talk a little bit
more later on on how to do that.


309
00:15:34,006 --> 00:15:36,046
So, what is the locale anyway?


310
00:15:36,646 --> 00:15:39,756
Earlier we saw one example
of the U.S. English locale.


311
00:15:40,096 --> 00:15:42,326
There was a language,
and there was a region.


312
00:15:42,956 --> 00:15:46,116
But locales can have
many more attributes.


313
00:15:46,416 --> 00:15:48,186
There can be an optional script.


314
00:15:48,286 --> 00:15:51,056
For example, you might need
to indicate whether you want


315
00:15:51,056 --> 00:15:54,716
to use Arabic or Cyrillic script
with a particular language.


316
00:15:55,486 --> 00:15:57,786
There can also be keywords added


317
00:15:57,786 --> 00:16:00,196
which fine-tune the
behavior of the locale.


318
00:16:00,926 --> 00:16:03,226
So let's look at one
hypothetical example.


319
00:16:03,776 --> 00:16:06,566
Let's look at a particular
user's current locale


320
00:16:06,946 --> 00:16:08,976
and print out its identifier.


321
00:16:10,146 --> 00:16:11,006
There it is.


322
00:16:11,526 --> 00:16:15,186
So, let's pick it apart and
see what each part means.


323
00:16:16,086 --> 00:16:17,786
So the first part
is the language.


324
00:16:17,886 --> 00:16:19,316
That's Urdu, in this case.


325
00:16:20,046 --> 00:16:24,456
The region is India, so what
the user is saying is they want


326
00:16:24,456 --> 00:16:28,646
to see their dates, times and
so forth in the Urdu language


327
00:16:28,646 --> 00:16:31,216
and following the regional
conventions of India.


328
00:16:32,546 --> 00:16:35,656
But the user also has some
keywords to do some overrides


329
00:16:35,656 --> 00:16:38,496
of the default for
that particular locale.


330
00:16:38,936 --> 00:16:41,756
For example, the
default calendar


331
00:16:41,756 --> 00:16:44,246
in India is the Gregorian
calendar.


332
00:16:44,626 --> 00:16:47,436
But this user wants to
use the Islamic calendar.


333
00:16:47,846 --> 00:16:49,206
Perhaps they do a
lot of business


334
00:16:49,206 --> 00:16:50,446
with people in the Middle East.


335
00:16:51,916 --> 00:16:55,026
In addition, the default
currency for India is the Rupee,


336
00:16:55,296 --> 00:16:58,376
but this user says they
want to use the U.S. dollar


337
00:16:58,376 --> 00:16:59,566
as their default currency.


338
00:16:59,806 --> 00:17:02,766
Again, perhaps because they do
a lot of international business.


339
00:17:05,556 --> 00:17:08,056
So locales have a lot
of information in them,


340
00:17:08,236 --> 00:17:10,566
but you shouldn't get
all the information


341
00:17:10,566 --> 00:17:11,986
that you need out of the locale.


342
00:17:12,445 --> 00:17:14,336
There are some things you
should get from elsewhere.


343
00:17:15,316 --> 00:17:18,796
So, you might think that because
there's a region in the locale


344
00:17:19,126 --> 00:17:20,806
that that's where
the user is located.


345
00:17:21,326 --> 00:17:23,516
But the region just
indicates their preference


346
00:17:23,516 --> 00:17:24,526
for certain things.


347
00:17:24,816 --> 00:17:26,746
It doesn't mean that that's
where they actually are.


348
00:17:27,455 --> 00:17:29,876
I can have my region
setting as India.


349
00:17:29,876 --> 00:17:31,296
That doesn't mean
that I'm in India.


350
00:17:31,976 --> 00:17:35,066
So if you need to know where
the user is located or,


351
00:17:35,066 --> 00:17:37,456
more precisely, where
their device is located,


352
00:17:37,456 --> 00:17:38,606
use CoreLocation.


353
00:17:38,966 --> 00:17:44,436
Again, the locale has a
language associated with it.


354
00:17:44,816 --> 00:17:47,056
But that's not necessarily
the language


355
00:17:47,056 --> 00:17:48,786
that your application
is running in.


356
00:17:49,376 --> 00:17:52,206
So if you need to ask
localization questions,


357
00:17:52,386 --> 00:17:54,766
use NSBundle, not NSLocale.


358
00:17:55,726 --> 00:17:59,056
As I mentioned earlier,
the language the user uses


359
00:17:59,056 --> 00:18:01,946
in their documents may
not be the same languages


360
00:18:01,946 --> 00:18:05,216
as either the locale or
the localization language.


361
00:18:06,036 --> 00:18:08,756
Typically you don't need
to know what language is


362
00:18:08,756 --> 00:18:10,606
in a user document
but, if you do,


363
00:18:10,826 --> 00:18:12,776
you can use NSLinguisticTagger.


364
00:18:16,236 --> 00:18:19,516
Again, the region and the
locale is just a preference.


365
00:18:19,896 --> 00:18:22,586
It's not something you
should use for regulatory


366
00:18:22,586 --> 00:18:26,786
or legal purposes or
determining which kind


367
00:18:27,496 --> 00:18:29,186
of credit card to
use or whatever.


368
00:18:29,186 --> 00:18:31,126
For that you'll have
to use other means,


369
00:18:31,506 --> 00:18:33,096
probably talking to a server.


370
00:18:33,576 --> 00:18:40,286
Again, if you're doing financial
or commercial transactions,


371
00:18:40,656 --> 00:18:43,066
they'll be in some
particular currency.


372
00:18:43,496 --> 00:18:46,656
But that's not necessarily
the currency that's indicated


373
00:18:46,656 --> 00:18:47,716
by the current locale.


374
00:18:48,206 --> 00:18:49,426
You should use some other means,


375
00:18:49,466 --> 00:18:52,206
probably having your server
tell you which currency to use.


376
00:18:52,946 --> 00:18:54,746
Now if you know the currency,


377
00:18:55,166 --> 00:18:57,006
if you know the three
letter ISO code,


378
00:18:57,356 --> 00:18:59,366
you can set that on
a number formatter,


379
00:18:59,766 --> 00:19:01,346
and it will then format amounts


380
00:19:01,346 --> 00:19:03,876
in that currency using
the user's preferences.


381
00:19:04,316 --> 00:19:06,276
It won't do conversion
between currencies though.


382
00:19:06,276 --> 00:19:07,926
You'll have to handle
that yourself.


383
00:19:09,366 --> 00:19:11,166
Now we've discussed
some of the differences


384
00:19:11,166 --> 00:19:13,246
between languages and locales.


385
00:19:13,446 --> 00:19:15,296
So how do you read
those preferences?


386
00:19:16,606 --> 00:19:18,136
Well, typically you
don't have to.


387
00:19:18,136 --> 00:19:19,816
The system handles this for you.


388
00:19:20,486 --> 00:19:23,246
All of the formatter objects,
including the new ones,


389
00:19:23,316 --> 00:19:23,986
calendars,


390
00:19:23,986 --> 00:19:28,636
locale objects-they'll all use
the user's locale preference


391
00:19:28,716 --> 00:19:29,366
by default.


392
00:19:29,766 --> 00:19:31,016
You don't have to do anything.


393
00:19:31,896 --> 00:19:35,686
If you're doing localization,
use NSBundle,


394
00:19:35,686 --> 00:19:37,836
and that will use the
user's preferences for you.


395
00:19:37,836 --> 00:19:39,356
You don't need to
read them directly.


396
00:19:40,016 --> 00:19:42,836
And again, if you're doing
language-sensitive operations


397
00:19:42,836 --> 00:19:46,446
using NSString, like localized
comparisons for sorting


398
00:19:46,446 --> 00:19:49,716
or searching, NSString will
do the right thing by default.


399
00:19:50,316 --> 00:19:56,046
But you say, "I have
some application in mind.


400
00:19:56,046 --> 00:19:59,196
I have some kind of
decision I need to make


401
00:19:59,196 --> 00:20:01,416
about behavior of
my application.


402
00:20:01,736 --> 00:20:04,976
Or I need to get localized
resources that are elsewhere.


403
00:20:05,416 --> 00:20:07,606
So I really need to
read these preferences."


404
00:20:08,516 --> 00:20:11,946
Well, even in that case, you
don't need to quite often.


405
00:20:12,506 --> 00:20:15,616
So for example, you might
think you need the language


406
00:20:15,616 --> 00:20:19,186
that your application is running
in in order to control behavior.


407
00:20:19,706 --> 00:20:22,996
Say you wanted to do something
when it's running in English,


408
00:20:23,026 --> 00:20:25,726
but you don't want it to do that
when it's running in Japanese.


409
00:20:26,646 --> 00:20:28,756
Well you don't need to read
the preference for that.


410
00:20:29,496 --> 00:20:32,096
You can use NSBundle to
make this decision for you.


411
00:20:32,096 --> 00:20:34,826
If you wanted to do something
when it's running in English


412
00:20:34,826 --> 00:20:37,536
but not Japanese, put
a localized resource


413
00:20:37,536 --> 00:20:41,286
in your bundle, which has the
value "yes" for English but "no"


414
00:20:41,286 --> 00:20:44,636
for Japanese, and your
application will pick


415
00:20:44,636 --> 00:20:46,376
up the right behavior
automatically.


416
00:20:47,346 --> 00:20:50,366
Now if you are getting
localized information


417
00:20:50,596 --> 00:20:54,136
from outside your
application, then you might need


418
00:20:54,136 --> 00:20:56,436
to know the language you're
running in, and we'll talk


419
00:20:56,436 --> 00:20:59,836
about that in a little bit.


420
00:21:00,056 --> 00:21:03,676
Similarly, if you have a
set of language resources


421
00:21:03,886 --> 00:21:06,816
from elsewhere, say, they're
stored on a server and you need


422
00:21:06,816 --> 00:21:09,176
to pick the right one,
you might think you'd need


423
00:21:09,176 --> 00:21:10,936
to read the user's
preferred languages.


424
00:21:11,246 --> 00:21:13,216
But NSBundle can
handle this for you.


425
00:21:13,806 --> 00:21:16,956
There's a class method,
preferredLocalizationsFromArray.


426
00:21:17,536 --> 00:21:21,796
You hand it an array, which is
a list of language identifiers


427
00:21:22,686 --> 00:21:26,236
which represent your localized
resources, and it will match


428
00:21:26,236 --> 00:21:28,036
that against the
user's preferences


429
00:21:28,406 --> 00:21:30,136
and pick the right
one for you to use.


430
00:21:30,136 --> 00:21:32,086
You don't need to read
the preferences directly.


431
00:21:32,086 --> 00:21:35,226
And this will use the same
logic that NSBundle uses


432
00:21:35,596 --> 00:21:38,226
when picking localized
resources out of a bundle.


433
00:21:42,156 --> 00:21:46,026
And again, if you need to
know the language content


434
00:21:46,026 --> 00:21:50,186
of a document, which is
unusual but sometimes necessary,


435
00:21:50,296 --> 00:21:52,056
you can use NSLinguisticTagger.


436
00:21:52,706 --> 00:21:54,486
One thing to keep in mind is


437
00:21:54,486 --> 00:21:57,366
that a single document can
have more than one language.


438
00:21:57,726 --> 00:22:00,426
And in fact, you can have
different languages appearing


439
00:22:00,426 --> 00:22:03,036
even in the same
paragraph or sentence.


440
00:22:06,136 --> 00:22:09,916
So, suppose you do need to
get some localized information


441
00:22:09,916 --> 00:22:12,086
from outside your
application's bundle.


442
00:22:12,486 --> 00:22:14,276
How do you go about doing that?


443
00:22:14,466 --> 00:22:15,736
Well, the first thing you need


444
00:22:15,736 --> 00:22:18,876
to know is what language
your application is running


445
00:22:18,876 --> 00:22:19,616
in right now.


446
00:22:19,966 --> 00:22:21,806
That's actually pretty
straightforward.


447
00:22:21,806 --> 00:22:23,126
You just get your main bundle.


448
00:22:23,476 --> 00:22:25,826
You ask it for its
preferred localizations,


449
00:22:26,176 --> 00:22:29,626
and the first object in that
array will be the language code


450
00:22:29,836 --> 00:22:33,596
for the language your
application is using right now.


451
00:22:34,166 --> 00:22:35,406
So, what's an example


452
00:22:35,406 --> 00:22:36,986
of something you
might use that for?


453
00:22:38,496 --> 00:22:41,886
Say your application displays
the names of currencies.


454
00:22:42,686 --> 00:22:45,366
You could ask your localizers
to localize the names


455
00:22:45,366 --> 00:22:47,606
of all the currencies
for you and put it


456
00:22:47,606 --> 00:22:48,756
in your application bundle.


457
00:22:48,756 --> 00:22:52,056
But that's unnecessary, and
NSLocale has that information.


458
00:22:53,476 --> 00:22:57,666
So you can ask a locale for the
localized name of a currency,


459
00:22:58,126 --> 00:23:01,246
but if you do that with the
current locale, you'll get it


460
00:23:01,436 --> 00:23:03,406
in the language of
the current locale


461
00:23:03,736 --> 00:23:05,476
which may not be
the same language


462
00:23:05,476 --> 00:23:06,946
that your application
is running in.


463
00:23:06,946 --> 00:23:10,246
And then you'll have a mismatch
where the UI of your app is


464
00:23:10,356 --> 00:23:12,776
in one language, but the
currency names are showing


465
00:23:12,776 --> 00:23:13,376
up in another.


466
00:23:14,256 --> 00:23:18,916
So to avoid that, what we do
is we make a locale using the


467
00:23:18,916 --> 00:23:21,646
language ID that we computed
in the previous slide.


468
00:23:22,286 --> 00:23:24,526
So we take the language
ID our app is running in.


469
00:23:24,566 --> 00:23:25,776
We make a locale from it.


470
00:23:26,026 --> 00:23:29,386
And then we ask that locale
what the localized name


471
00:23:29,386 --> 00:23:30,356
of a currency is.


472
00:23:31,186 --> 00:23:33,006
So here's an example
of what you'll get


473
00:23:33,006 --> 00:23:34,706
for three different
localizations


474
00:23:34,996 --> 00:23:41,836
for the ISO currency code CNY:
English, French and Chinese.


475
00:23:46,196 --> 00:23:49,726
Similarly, NSLocale can
give you localized beginning


476
00:23:49,726 --> 00:23:50,526
and end quotes.


477
00:23:51,366 --> 00:23:55,286
And if you want those
quotes to match the language


478
00:23:55,286 --> 00:23:57,356
that your application
is running in, again,


479
00:23:57,736 --> 00:24:00,806
you make a locale using that
language and then query it


480
00:24:00,806 --> 00:24:02,116
for the beginning
and end quotes.


481
00:24:02,646 --> 00:24:05,566
If you wanted the quotes to
match a different language,


482
00:24:05,896 --> 00:24:07,996
say you've retrieved
a webpage and you want


483
00:24:07,996 --> 00:24:11,796
to insert quote marks in it,
then you would use that language


484
00:24:11,796 --> 00:24:15,096
to create the locale and
query it for the quote marks.


485
00:24:15,606 --> 00:24:17,876
So here again is an
example of what you'll get


486
00:24:17,876 --> 00:24:19,586
for three different
localizations:


487
00:24:20,146 --> 00:24:22,486
English, French and Japanese.


488
00:24:26,916 --> 00:24:30,206
So I mentioned a few slides back


489
00:24:30,386 --> 00:24:32,726
that the user can change
their locale preference,


490
00:24:32,756 --> 00:24:35,736
their Region setting, and
apps don't need to restart


491
00:24:35,736 --> 00:24:36,916
for that to take effect.


492
00:24:36,976 --> 00:24:38,566
Apps are supposed
to react to it.


493
00:24:39,136 --> 00:24:41,076
So let me show you
what a lot of apps do


494
00:24:41,076 --> 00:24:43,386
when the user changes
the locale.


495
00:24:45,216 --> 00:24:47,856
Well, unfortunately,
they don't react to it.


496
00:24:48,276 --> 00:24:52,276
And the user is forced to quit
the app and restart it in order


497
00:24:52,276 --> 00:24:53,596
for the change to take effect.


498
00:24:54,976 --> 00:24:57,576
So let's talk about how we're
supposed to handle this.


499
00:24:58,496 --> 00:25:01,346
So the first thing you
need to do is listen


500
00:25:01,346 --> 00:25:03,996
for the notification which
is NSCurrentLocaleDid


501
00:25:03,996 --> 00:25:05,236
ChangeNotification.


502
00:25:06,246 --> 00:25:08,916
. If you have objects
around that use the locale


503
00:25:08,916 --> 00:25:11,616
like formatters or
locale objects,


504
00:25:12,306 --> 00:25:15,156
you'll need to update
their locale property.


505
00:25:15,926 --> 00:25:17,616
But there's a workaround
for this.


506
00:25:17,616 --> 00:25:20,246
If you set up the
object in the first place


507
00:25:20,246 --> 00:25:23,926
to use the auto-updating
variant of the current locale,


508
00:25:24,416 --> 00:25:25,616
you don't need to do anything.


509
00:25:25,746 --> 00:25:27,166
They'll be updated
automatically.


510
00:25:28,166 --> 00:25:30,146
But there's still some
work that needs to be done.


511
00:25:30,716 --> 00:25:32,886
If you have a date
formatter, for example,


512
00:25:33,176 --> 00:25:35,456
that is using template formats,


513
00:25:35,726 --> 00:25:38,506
you'll need to regenerate
those based on the new locale.


514
00:25:39,406 --> 00:25:40,866
And, of course, any strings


515
00:25:40,866 --> 00:25:43,646
that you formatted using
your formatters need


516
00:25:43,646 --> 00:25:46,456
to be created again to
reflect the new locale.


517
00:25:46,506 --> 00:25:51,756
And, finally, if you want
the change in the locale


518
00:25:51,756 --> 00:25:55,396
to be reflected on the display,
you need to invalidate any views


519
00:25:55,396 --> 00:25:57,906
that are showing that
kind of information.


520
00:25:59,916 --> 00:26:02,246
So here's a very simple example.


521
00:26:03,956 --> 00:26:05,256
First, we set up a listener


522
00:26:05,406 --> 00:26:08,476
for the NSCurrentLocaleDid
ChangeNotification.


523
00:26:08,946 --> 00:26:11,056
. And when the user
changes their preference,


524
00:26:11,616 --> 00:26:12,536
here's what we do.


525
00:26:12,786 --> 00:26:14,416
So assume there's
a date formatter.


526
00:26:14,786 --> 00:26:18,486
The first thing I'm going to do
is update the locale property


527
00:26:18,546 --> 00:26:20,546
with the new value of
the current locale.


528
00:26:20,986 --> 00:26:23,756
Now again, if I set
that locale property


529
00:26:23,756 --> 00:26:27,166
with the auto-updating current
locale, I could skip this step.


530
00:26:28,226 --> 00:26:32,236
This particular date formatter
is using a date format generated


531
00:26:32,236 --> 00:26:33,046
from a template.


532
00:26:33,556 --> 00:26:36,456
And since that generation
depends on the locale,


533
00:26:36,456 --> 00:26:37,766
I have to do it over again.


534
00:26:38,296 --> 00:26:41,406
So I call the class
method on NSDateFormatter,


535
00:26:41,836 --> 00:26:43,866
pass it the new locale
of the formatter


536
00:26:43,866 --> 00:26:45,506
and regenerate the date format.


537
00:26:46,306 --> 00:26:48,526
Finally, I mark myView dirty


538
00:26:48,916 --> 00:26:51,086
so that everything
gets redisplayed.


539
00:26:51,086 --> 00:26:53,706
And in this case, I'm
assuming that the draw method


540
00:26:53,706 --> 00:26:55,966
of the view will
call the formatters


541
00:26:55,966 --> 00:26:59,476
to regenerate all the strings
for dates, times and so on.


542
00:27:00,836 --> 00:27:04,506
And now I'd like to ask Karan
Misra to come up to talk


543
00:27:04,506 --> 00:27:05,756
about some case studies.


544
00:27:06,516 --> 00:27:07,076
Karan.


545
00:27:07,516 --> 00:27:10,586
>> Thank you, Debbie.


546
00:27:10,766 --> 00:27:15,056
Hello. I'm Karan Misra and I'd
like to talk to you a little bit


547
00:27:15,056 --> 00:27:19,186
about making your app work
for international customers.


548
00:27:20,336 --> 00:27:26,116
Now this is a very normal
looking time string.


549
00:27:26,116 --> 00:27:28,616
And this is a time that's
appropriately formatted


550
00:27:28,616 --> 00:27:30,186
for U.S. English.


551
00:27:30,926 --> 00:27:34,116
What you might not have
seen before is that iOS


552
00:27:34,116 --> 00:27:36,026
and OS actually support
dates and times


553
00:27:36,026 --> 00:27:37,046
in many different languages.


554
00:27:37,156 --> 00:27:39,616
And here are just a few of
them to show you the variety.


555
00:27:40,116 --> 00:27:41,916
So some of the differences
are, of course,


556
00:27:42,066 --> 00:27:44,616
you might not even
have an AM/PM marker


557
00:27:44,616 --> 00:27:45,916
because it is 24-hour time.


558
00:27:46,296 --> 00:27:48,926
But, of course, even if
that marker is there,


559
00:27:48,926 --> 00:27:50,766
it can take many
different shapes and sizes


560
00:27:50,766 --> 00:27:51,836
and go in different places.


561
00:27:52,576 --> 00:27:54,486
So what do you need to
keep in mind about this?


562
00:27:55,156 --> 00:27:56,796
Well, let's take two examples.


563
00:27:57,736 --> 00:27:59,966
On the left, you
have U.S. English.


564
00:27:59,966 --> 00:28:02,426
And, on the right, you
have simplified Chinese


565
00:28:02,426 --> 00:28:04,166
as spoken in mainland China.


566
00:28:06,576 --> 00:28:08,996
This is a common problem
that we see in many apps,


567
00:28:09,056 --> 00:28:13,746
which is that a format for U.S.
English is applied to Chinese.


568
00:28:14,286 --> 00:28:16,476
To a Chinese user,
this looks very wrong.


569
00:28:18,796 --> 00:28:21,966
Similarly, here's a perfectly
formatted date for U.S. English.


570
00:28:22,446 --> 00:28:25,956
This is not a perfectly
formatted date in Chinese.


571
00:28:26,036 --> 00:28:27,316
In fact, it looks like nonsense.


572
00:28:28,046 --> 00:28:32,286
The date on the right is what
a Chinese user would expect


573
00:28:32,286 --> 00:28:33,076
to see instead.


574
00:28:33,076 --> 00:28:37,206
And, just to turn
the tables around,


575
00:28:37,956 --> 00:28:40,426
here's a date that's well
formatted for Chinese


576
00:28:40,426 --> 00:28:42,216
with the day, month and year.


577
00:28:42,216 --> 00:28:44,986
Of course, in Chinese,
it's year, month, day.


578
00:28:45,696 --> 00:28:48,396
And here's what happens
if you take that order


579
00:28:48,396 --> 00:28:50,016
and apply it to an English date.


580
00:28:50,016 --> 00:28:52,656
As you can see, what you would
expect to see is something


581
00:28:52,656 --> 00:28:53,576
on the right-hand side.


582
00:28:53,576 --> 00:28:55,666
And when you see
something on the left,


583
00:28:55,666 --> 00:28:56,766
it doesn't just look wrong,


584
00:28:56,766 --> 00:28:59,186
it looks blatantly
wrong like it's broken.


585
00:28:59,996 --> 00:29:03,446
So how do we avoid
making these faux pas?


586
00:29:03,856 --> 00:29:08,186
Well, the first thing is,
don't use a fixed format.


587
00:29:08,186 --> 00:29:11,016
Fixed formats will work for
a fixed language and not work


588
00:29:11,016 --> 00:29:11,796
for all the languages.


589
00:29:12,586 --> 00:29:16,806
So, now you might look
at the English UK example


590
00:29:16,886 --> 00:29:19,706
in the second row and say,
"Well, that looks fine.


591
00:29:19,706 --> 00:29:21,146
It's English and
it makes sense".


592
00:29:21,826 --> 00:29:23,926
But what you might
not imagine is,


593
00:29:24,466 --> 00:29:26,066
even if you just
cross the Atlantic,


594
00:29:26,236 --> 00:29:28,046
the formats change
pretty drastically.


595
00:29:28,306 --> 00:29:32,126
So in UK English, for example,
it's 3 June instead of June 3,


596
00:29:32,736 --> 00:29:35,366
and they use 24-hour
time by default,


597
00:29:35,366 --> 00:29:36,886
so you don't have
the AM/PM marker.


598
00:29:37,986 --> 00:29:40,036
So what's the right way to
do this at the API level?


599
00:29:40,036 --> 00:29:45,626
Well, localizedStringFromDate
is going to get you a date


600
00:29:45,626 --> 00:29:48,176
that is properly formatted
for the current locale.


601
00:29:48,396 --> 00:29:50,956
And you pass in a
dateStyle and a timeStyle,


602
00:29:51,276 --> 00:29:54,486
and that determines how succinct


603
00:29:54,486 --> 00:29:56,406
or verbose you want your
dates and times to be.


604
00:29:57,556 --> 00:29:59,676
And it formats the
date appropriately


605
00:29:59,676 --> 00:30:00,616
for all your locales.


606
00:30:01,246 --> 00:30:03,096
Now you might come back
to me and say, "Well,


607
00:30:03,096 --> 00:30:04,456
that's not working for me.


608
00:30:04,736 --> 00:30:05,906
I need something more custom."


609
00:30:06,726 --> 00:30:09,506
So, the first step
on your journey


610
00:30:09,506 --> 00:30:11,186
to custom dates should
be looking


611
00:30:11,186 --> 00:30:12,976
at dateFormatFromTemplate.


612
00:30:13,576 --> 00:30:16,396
Now this allows you to
specify a template and,


613
00:30:16,396 --> 00:30:19,066
within the template, the
template contains information


614
00:30:19,066 --> 00:30:21,336
about exactly what
elements of the date


615
00:30:21,336 --> 00:30:22,276
and time you want to show.


616
00:30:22,276 --> 00:30:26,716
And then you pass in a
locale so that the template,


617
00:30:26,716 --> 00:30:29,716
it gives you a format
back from the template.


618
00:30:29,776 --> 00:30:32,876
And then that format is
appropriately, is appropriate


619
00:30:32,926 --> 00:30:34,266
for the locale that
you passed in.


620
00:30:34,506 --> 00:30:37,276
And then finally you set
that format on the formatter


621
00:30:37,276 --> 00:30:39,646
to get your dates and times.


622
00:30:40,056 --> 00:30:42,806
Now of course, you might still
come back to me and say, "Well,


623
00:30:42,806 --> 00:30:45,156
none of the preset
styles work for me,


624
00:30:45,446 --> 00:30:48,886
and none of the template
formats they work for me.


625
00:30:48,886 --> 00:30:49,676
So what should I do?"


626
00:30:50,496 --> 00:30:52,946
Well, it becomes a little more
complicated as you can see.


627
00:30:53,056 --> 00:30:57,646
But the basic idea is you
might have a custom format


628
00:30:57,986 --> 00:31:01,766
but you probably have not
considered every possible locale


629
00:31:01,766 --> 00:31:02,266
in the world.


630
00:31:02,856 --> 00:31:05,756
So, don't apply your
custom format


631
00:31:05,756 --> 00:31:07,176
to every possible
locale in the world.


632
00:31:07,346 --> 00:31:09,826
If you have a custom
format for U.S. English,


633
00:31:10,416 --> 00:31:14,426
check for English U.S. and
apply just to English U.S..


634
00:31:14,526 --> 00:31:15,936
And, of course, if you
have custom formats


635
00:31:15,936 --> 00:31:18,786
for other locales, check
for those specific locales


636
00:31:18,786 --> 00:31:21,986
and make sure to fall back to
the default in your else case.


637
00:31:23,396 --> 00:31:25,766
And that's all there
is to dates and times.


638
00:31:25,836 --> 00:31:27,246
Next, let's move on to names.


639
00:31:28,316 --> 00:31:30,136
Now very similar
to dates and times,


640
00:31:30,386 --> 00:31:32,476
names come in many
different languages


641
00:31:32,476 --> 00:31:34,526
and scripts and formats.


642
00:31:34,826 --> 00:31:40,196
And here is what happens if you
apply a name format intended


643
00:31:40,196 --> 00:31:41,996
for Chinese to an English name.


644
00:31:42,156 --> 00:31:43,476
It doesn't look very good.


645
00:31:45,086 --> 00:31:48,916
And believe me that this Chinese
name looks just as awkward


646
00:31:49,296 --> 00:31:51,756
to a Chinese user because it's
using an English name format.


647
00:31:52,756 --> 00:31:54,376
So, what's wrong here?


648
00:31:55,466 --> 00:31:57,626
Well, most commonly
what we see is


649
00:31:57,626 --> 00:32:01,016
that a fixed format
has been hard coded.


650
00:32:01,546 --> 00:32:04,516
And when you use a fixed
format, it's only going


651
00:32:04,516 --> 00:32:05,366
to work for some names.


652
00:32:05,366 --> 00:32:07,346
So clearly, this is
not the right approach.


653
00:32:07,846 --> 00:32:11,136
Now what might not
be super intuitive is


654
00:32:11,136 --> 00:32:13,666
that even using a
format obtained


655
00:32:13,826 --> 00:32:17,676
from the current localization
will not give you the right


656
00:32:17,676 --> 00:32:18,596
formatting every time.


657
00:32:18,986 --> 00:32:21,896
Why? Now, if you're
living in the US,


658
00:32:21,896 --> 00:32:23,766
most of your contacts
might be in English.


659
00:32:24,096 --> 00:32:27,216
But a lot of customers,
especially those in Asia,


660
00:32:27,796 --> 00:32:29,876
most often have contacts


661
00:32:29,966 --> 00:32:32,096
in at least two languages,
if not more.


662
00:32:32,216 --> 00:32:34,336
Say Chinese and English
or Japanese and English.


663
00:32:35,506 --> 00:32:37,876
So with the fixed
format obtained


664
00:32:37,876 --> 00:32:40,926
from the current localization,
you might format, say,


665
00:32:40,926 --> 00:32:42,166
all Chinese names right.


666
00:32:42,466 --> 00:32:44,316
But you might then get all
the English names wrong.


667
00:32:44,506 --> 00:32:46,156
So that's just not
a good experience.


668
00:32:47,296 --> 00:32:48,066
So what should you do?


669
00:32:48,456 --> 00:32:52,296
Well, there's a great API called
ABRecordCopyCompositeName.


670
00:32:53,066 --> 00:32:55,506
You pass it a record
from Address Book.


671
00:32:55,766 --> 00:32:57,256
It'll give you back
the name to display.


672
00:32:57,536 --> 00:32:58,546
It's that simple.


673
00:32:59,646 --> 00:33:00,766
There's no code underneath.


674
00:33:01,136 --> 00:33:06,576
And this API, of course, it
encapsulates a lot of logic


675
00:33:06,746 --> 00:33:10,266
that we have designed that
takes into account the language


676
00:33:10,266 --> 00:33:12,176
of the contact, the
user settings,


677
00:33:12,366 --> 00:33:14,726
and of course it has a lot
of language-specific logic


678
00:33:14,726 --> 00:33:17,206
to then find the right format
to show the contact in.


679
00:33:17,546 --> 00:33:18,816
But you don't need
to worry about that.


680
00:33:18,876 --> 00:33:19,606
Just use this API.


681
00:33:20,816 --> 00:33:23,836
Of course you might say,
my contacts don't come


682
00:33:23,836 --> 00:33:25,396
from the Address Book, they
come from somewhere else.


683
00:33:26,026 --> 00:33:26,526
That's fine.


684
00:33:27,216 --> 00:33:29,166
You can take the name
information that you get


685
00:33:29,166 --> 00:33:32,456
from another source,
create a temporary ABRecord,


686
00:33:32,456 --> 00:33:36,326
assign these values, and then
ask for the display name again.


687
00:33:37,266 --> 00:33:40,226
And of course, if
you're using OS X,


688
00:33:40,726 --> 00:33:42,856
then there's a displayName
API there too.


689
00:33:43,636 --> 00:33:45,166
And that's really all
there is to names.


690
00:33:45,526 --> 00:33:47,116
Just use these APIs,
and it'll be all right.


691
00:33:49,256 --> 00:33:52,426
Next, I'd like to talk to
you about right-to-left text.


692
00:33:52,426 --> 00:33:56,156
So, first of all,
don't think that just


693
00:33:56,156 --> 00:33:58,686
because you don't have a
right-to-left localization,


694
00:33:58,816 --> 00:34:00,576
like Arabic or Hebrew, that
you can stop listening.


695
00:34:00,576 --> 00:34:03,946
This is important even if
you localize just in English.


696
00:34:05,006 --> 00:34:06,686
So what's different
about these languages?


697
00:34:07,036 --> 00:34:10,275
Well, they run right-to-left.


698
00:34:10,275 --> 00:34:10,956
That's what's different.


699
00:34:11,255 --> 00:34:13,686
And that actually
causes a lot of issues.


700
00:34:15,275 --> 00:34:17,315
So, there are two
main topics here.


701
00:34:17,616 --> 00:34:20,076
One is alignment, and the
other is directionality.


702
00:34:20,156 --> 00:34:21,646
Let me talk about
alignment first.


703
00:34:22,876 --> 00:34:25,366
This looks like a
perfectly innocuous line


704
00:34:25,456 --> 00:34:27,216
of code, set alignment left.


705
00:34:27,216 --> 00:34:29,406
I mean, what's the alignment
for if not for setting it?


706
00:34:30,025 --> 00:34:32,626
Well, it works fine
for English text.


707
00:34:33,176 --> 00:34:36,496
But if you set Arabic
text in left alignment,


708
00:34:36,926 --> 00:34:40,525
it's kind of like setting
English text in right alignment.


709
00:34:40,676 --> 00:34:44,206
You might do it for a heading
or for some special cases,


710
00:34:44,206 --> 00:34:46,755
but you don't format
entire paragraphs of text


711
00:34:47,386 --> 00:34:48,585
in right alignment for English.


712
00:34:49,116 --> 00:34:52,596
So that text is not
very easy to read.


713
00:34:52,735 --> 00:34:53,585
What's the answer?


714
00:34:53,846 --> 00:34:56,795
Well, the answer is you
should use natural alignment.


715
00:34:57,096 --> 00:35:01,166
Now this lets the underlying
frameworks determine what the


716
00:35:01,166 --> 00:35:04,356
appropriate alignment is
left to right depending


717
00:35:04,386 --> 00:35:05,316
on the language and use.


718
00:35:05,916 --> 00:35:09,386
And if you use this, you'll get
nice left alignment for English


719
00:35:09,386 --> 00:35:10,666
and other left-to-right
languages.


720
00:35:10,666 --> 00:35:13,346
And you'll get nice right
alignment for Arabic


721
00:35:13,346 --> 00:35:14,486
and other right-to-left
languages.


722
00:35:15,226 --> 00:35:15,806
So that's easy.


723
00:35:17,096 --> 00:35:19,256
Let's move on to something
less easy, directionality.


724
00:35:19,726 --> 00:35:23,996
Now, directionality, in
contrast to alignment,


725
00:35:24,286 --> 00:35:28,186
determines what the logical
order and the visual order


726
00:35:28,186 --> 00:35:30,496
of the words is within
a given run of text,


727
00:35:30,496 --> 00:35:31,706
like within a single sentence.


728
00:35:32,316 --> 00:35:36,056
So what we see most
commonly going wrong is


729
00:35:36,056 --> 00:35:39,126
that someone is trying
actually to be helpful,


730
00:35:39,126 --> 00:35:42,476
and they take the fact that
the app is running in Arabic


731
00:35:42,476 --> 00:35:47,086
or Hebrew, and they hard-code
the base writing direction


732
00:35:47,086 --> 00:35:49,096
to right-to-left.


733
00:35:49,746 --> 00:35:50,506
Why is this wrong?


734
00:35:50,666 --> 00:35:54,796
Well, this is wrong because user
content can be in any language,


735
00:35:54,856 --> 00:35:56,406
as Debbie mentioned before.


736
00:35:56,586 --> 00:35:59,096
And you cannot assume the
language of user content.


737
00:35:59,556 --> 00:36:01,956
Now this is a sentence that's
supposed to be in English,


738
00:36:02,426 --> 00:36:04,656
with one Urdu word
in the middle.


739
00:36:04,656 --> 00:36:07,296
So it's supposed to say,
"WWDC is a fun conference."


740
00:36:07,636 --> 00:36:09,066
It's not really saying
that right now


741
00:36:09,206 --> 00:36:12,596
because it's using right-to-left
text directionality,


742
00:36:13,146 --> 00:36:16,686
and that doesn't make sense.


743
00:36:16,686 --> 00:36:18,556
So, what should you do?


744
00:36:18,816 --> 00:36:20,986
Well, for any text
view or text field


745
00:36:20,986 --> 00:36:23,176
in which you expect the
user to type content,


746
00:36:23,916 --> 00:36:26,226
set the writing direction
to natural.


747
00:36:26,536 --> 00:36:30,286
Now again, that lets the
underlying frameworks determine


748
00:36:30,586 --> 00:36:34,546
what a good best guess for
the writing direction is.


749
00:36:35,256 --> 00:36:38,326
In this case, it will take a
look at the first few letters


750
00:36:38,326 --> 00:36:40,836
of the string, which is WWDC,


751
00:36:41,256 --> 00:36:43,336
and since those are
left-to-right characters,


752
00:36:43,716 --> 00:36:46,626
it will take a guess that this
string should go left-to-right.


753
00:36:46,626 --> 00:36:51,166
And in this case, that produces
the expected sentence, which is,


754
00:36:51,166 --> 00:36:53,086
"WWDC is a must conference."


755
00:36:55,156 --> 00:37:00,456
So, of course, as I
mentioned, it's a best guess.


756
00:37:00,686 --> 00:37:03,496
And so you might have
a sentence like this.


757
00:37:03,706 --> 00:37:06,916
Now since you saw it animate
in, you can see the order.


758
00:37:07,066 --> 00:37:08,706
So you can see it one more time.


759
00:37:09,196 --> 00:37:10,696
So Safari first, then
[foreign language]


760
00:37:10,696 --> 00:37:13,216
in Arabic, and then Mac.


761
00:37:13,856 --> 00:37:18,096
So, you might be able to tell,
if you saw it being typed,


762
00:37:18,426 --> 00:37:20,666
that the user wants to
say, "Safari on Mac."


763
00:37:21,186 --> 00:37:23,456
But because it started
with Latin letters


764
00:37:23,456 --> 00:37:24,506
that would go left-to-right,


765
00:37:24,896 --> 00:37:28,166
the directionality was
assumed as left-to-right.


766
00:37:28,166 --> 00:37:30,976
And so, you have the opposite
sentence, "Mac on Safari."


767
00:37:33,266 --> 00:37:35,236
So how do you fix this?


768
00:37:35,486 --> 00:37:40,106
Well, this is the
sentence you want to get.


769
00:37:40,516 --> 00:37:45,966
And in order to get this order
of the words, what you need


770
00:37:45,966 --> 00:37:49,226
to do is you need to
insert a right-to-left mark


771
00:37:49,426 --> 00:37:51,516
at the beginning
of the sentence.


772
00:37:51,866 --> 00:37:55,306
This is an invisible
character that you insert


773
00:37:55,826 --> 00:37:58,836
to control the directionality
of the string.


774
00:38:00,756 --> 00:38:05,326
And, of course, you might have
a case that is the opposite,


775
00:38:05,326 --> 00:38:08,476
in fact, in which you start
with, say, an Arabic word,


776
00:38:08,756 --> 00:38:11,006
which is right-to-left,
and the OS will guess


777
00:38:11,126 --> 00:38:12,736
that the whole sentence
is supposed


778
00:38:12,736 --> 00:38:13,756
to flow from right-to-left.


779
00:38:13,756 --> 00:38:17,996
But what you intended
was for the sentence


780
00:38:18,186 --> 00:38:19,406
to flow from left-to-right.


781
00:38:19,406 --> 00:38:20,966
And, if you have
a translation app,


782
00:38:20,966 --> 00:38:23,296
you might actually have already
encountered a case like this.


783
00:38:24,646 --> 00:38:27,186
And, in this case,
the solution is


784
00:38:27,256 --> 00:38:28,466
to insert a left-to-right mark.


785
00:38:29,646 --> 00:38:32,816
So, what you're probably
thinking is, "Well,


786
00:38:32,816 --> 00:38:34,636
that's great, but who's supposed


787
00:38:34,636 --> 00:38:36,736
to insert these marks
into the strings?"


788
00:38:36,786 --> 00:38:38,996
because you might not
have heard about them.


789
00:38:39,726 --> 00:38:42,466
So the answer is,
well it is you.


790
00:38:43,046 --> 00:38:46,226
But, probably not exactly you.


791
00:38:46,476 --> 00:38:49,226
What you need to do is to
talk to your localizers.


792
00:38:49,776 --> 00:38:53,426
Your localizers, and not just
your right-to-left language


793
00:38:53,426 --> 00:38:55,776
localizers like localizers
for Arabic and Hebrew,


794
00:38:55,896 --> 00:38:58,986
all of your localizers need to
understand how these marks work.


795
00:38:59,446 --> 00:39:02,456
Because they need to insert
these in, for example,


796
00:39:02,456 --> 00:39:05,626
if there's a localizable
string that starts


797
00:39:05,626 --> 00:39:07,226
with a format argument.


798
00:39:07,966 --> 00:39:12,306
Now, when the user
content comes in,


799
00:39:12,306 --> 00:39:15,406
that format argument could be
replaced by an English word


800
00:39:15,406 --> 00:39:17,926
or an Arabic word or a
Hebrew word or a French word,


801
00:39:18,326 --> 00:39:21,366
so you don't know at compile
time what it's going to be.


802
00:39:21,586 --> 00:39:24,816
So you need to insert, if you're
in a left-to-right localization


803
00:39:24,816 --> 00:39:26,196
like English or French
or German,


804
00:39:26,476 --> 00:39:29,566
you need to have a left-to-right
mark there to tell it that even


805
00:39:29,566 --> 00:39:31,596
if an Arabic word comes
in, I want the sentence


806
00:39:31,596 --> 00:39:32,446
to flow left-to-right.


807
00:39:32,446 --> 00:39:35,116
And the same and the opposite
for right-to-left localizations.


808
00:39:37,186 --> 00:39:40,866
Of course, this is just
a brief introduction


809
00:39:41,326 --> 00:39:45,126
to handling right-to-left
text, or actually,


810
00:39:45,126 --> 00:39:48,716
mixed text I should say,
and you should check our


811
00:39:48,716 --> 00:39:50,536
internationalization
and localization guide


812
00:39:50,916 --> 00:39:53,756
for more details about
handling more advanced cases.


813
00:39:55,316 --> 00:39:58,616
Lastly, for right-to-left,
I should mention


814
00:39:59,696 --> 00:40:01,696
that Xcode 6 has a
great new feature


815
00:40:01,696 --> 00:40:04,396
which lets you simulate a
right-to-left localization


816
00:40:04,656 --> 00:40:07,146
so you can run in English
but in right-to-left


817
00:40:07,146 --> 00:40:09,896
and see how your layout flows
in a right-to-left localization.


818
00:40:10,416 --> 00:40:11,966
And of course, I
highly encourage you


819
00:40:11,966 --> 00:40:14,696
to attend the Localizing
with Xcode session


820
00:40:14,696 --> 00:40:17,596
which is later today to
learn more about Xcode 6


821
00:40:17,596 --> 00:40:18,856
and what it brings
for localization.


822
00:40:20,966 --> 00:40:23,206
Next, let me talk
about the keyboard.


823
00:40:24,106 --> 00:40:25,906
Now this is the U.S.
English keyboard.


824
00:40:25,906 --> 00:40:29,046
And, as you probably
know from yesterday,


825
00:40:29,596 --> 00:40:30,716
we now have predictive typing.


826
00:40:31,736 --> 00:40:34,646
So, what does this mean
for you as a developer?


827
00:40:35,456 --> 00:40:40,636
Well, even more than before, you
need to keep track of the height


828
00:40:40,636 --> 00:40:41,796
and size of the keyboard.


829
00:40:42,446 --> 00:40:44,496
So, I first of all
hope that none


830
00:40:44,496 --> 00:40:45,876
of you have hard-coded the size


831
00:40:45,876 --> 00:40:48,416
of the keyboard anywhere
in your apps.


832
00:40:49,026 --> 00:40:51,806
And now, of course, if
you do that, you're going


833
00:40:51,806 --> 00:40:53,206
to get a lot of one
star ratings.


834
00:40:54,096 --> 00:40:57,436
So, first of all
notice that even


835
00:40:57,436 --> 00:41:00,956
when predictive typing
is off, like on the left,


836
00:41:01,506 --> 00:41:03,156
there's still a thin bar
on top of the keyboard.


837
00:41:03,156 --> 00:41:04,696
So the height of the
keyboard is still different


838
00:41:04,696 --> 00:41:05,516
from what it used to be.


839
00:41:06,316 --> 00:41:08,216
But, not all the keyboards


840
00:41:08,216 --> 00:41:11,236
on iOS are predictive
typing enabled.


841
00:41:11,636 --> 00:41:13,286
So you still might
have a keyboard


842
00:41:13,286 --> 00:41:15,596
like the Bengali keyboard,
which is new in iOS 8,


843
00:41:16,096 --> 00:41:18,116
which does not have even
the thin bar on top.


844
00:41:18,116 --> 00:41:21,046
So already you have
three different sizes.


845
00:41:21,656 --> 00:41:26,596
Then we also have keyboards like
Japanese and Chinese in which,


846
00:41:26,776 --> 00:41:29,586
before the user starts
typing, it's the short height.


847
00:41:29,586 --> 00:41:31,846
And, once they start
typing, there's a bar on top


848
00:41:31,846 --> 00:41:33,096
and it becomes a tall height.


849
00:41:33,096 --> 00:41:34,096
So, your app needs


850
00:41:34,096 --> 00:41:36,106
to accommodate these
size changes on the fly.


851
00:41:36,106 --> 00:41:38,276
And, of course, users
will switch back and forth


852
00:41:38,326 --> 00:41:39,236
between these keyboards.


853
00:41:41,036 --> 00:41:43,696
Not only that, but this is
something you're probably aware


854
00:41:43,776 --> 00:41:47,676
of for sure is that when the
keyboard comes up, your UI needs


855
00:41:47,676 --> 00:41:49,256
to move away if you
don't want it


856
00:41:49,256 --> 00:41:50,426
to get hidden behind
the keyboard.


857
00:41:51,506 --> 00:41:52,556
So how do we do all of this?


858
00:41:53,256 --> 00:41:56,316
Well, helpfully, the
keyboard lets you know


859
00:41:56,316 --> 00:41:59,136
when it's coming in, going
out, or changing size.


860
00:41:59,596 --> 00:42:01,556
So all you need to do is
watch for those notifications.


861
00:42:02,956 --> 00:42:04,916
Now, what can you do with these?


862
00:42:05,186 --> 00:42:07,856
Well, here's an example
of Safari.


863
00:42:08,886 --> 00:42:11,756
When the keyboard comes
in, as you can see,


864
00:42:11,906 --> 00:42:14,546
the search field shrinks.


865
00:42:15,356 --> 00:42:17,566
And I'll play it
again so you can see


866
00:42:17,846 --> 00:42:21,436
that these two animations are
actually happening in tandem.


867
00:42:22,106 --> 00:42:24,206
So how do you make this
happen in your apps?


868
00:42:25,166 --> 00:42:28,256
Well, the keyboard will show,


869
00:42:28,476 --> 00:42:30,926
notification actually
contains a lot of information.


870
00:42:31,146 --> 00:42:33,416
First of all, it contains
information about the frame,


871
00:42:33,666 --> 00:42:34,756
where the keyboard will start


872
00:42:34,756 --> 00:42:36,686
and where the keyboard
will end its animation.


873
00:42:38,006 --> 00:42:39,556
It also contains information


874
00:42:39,666 --> 00:42:41,796
about the animation
duration and curve.


875
00:42:42,146 --> 00:42:44,716
So actually you can
use these two pieces


876
00:42:44,716 --> 00:42:48,736
of information together and make
sure that your UI moves away


877
00:42:48,736 --> 00:42:51,806
from the keyboard and also moves
in tandem with the keyboard


878
00:42:51,806 --> 00:42:55,916
so it gives a very smooth
experience to the user.


879
00:42:56,076 --> 00:42:57,646
We also have hardware keyboards.


880
00:42:58,196 --> 00:43:02,336
So, iOS, any iOS device can
attach to a hardware keyboard


881
00:43:02,336 --> 00:43:03,086
if you have Bluetooth.


882
00:43:03,426 --> 00:43:05,056
And of course if you
want to simulate it,


883
00:43:05,056 --> 00:43:07,816
there's an optional
Simulator to do that as well.


884
00:43:07,816 --> 00:43:10,446
So what does this
mean for your apps?


885
00:43:10,856 --> 00:43:14,106
Well, if you have an app like
this, which has a toolbar


886
00:43:14,106 --> 00:43:17,896
above the keyboard, the
important thing to keep


887
00:43:17,896 --> 00:43:20,416
in mind is that there's
functionality like Choose Font


888
00:43:20,416 --> 00:43:23,306
in this case, which you
don't want the user to lose


889
00:43:23,306 --> 00:43:24,976
when they attach a
hardware keyboard.


890
00:43:25,806 --> 00:43:27,876
So, this is not what you want


891
00:43:27,986 --> 00:43:29,066
when a hardware keyboard
is attached.


892
00:43:30,246 --> 00:43:33,316
What you want is this
in which the toolbar


893
00:43:33,316 --> 00:43:34,446
at the bottom remains,


894
00:43:34,446 --> 00:43:36,196
even though a hardware
keyboard is attached.


895
00:43:37,076 --> 00:43:38,246
So how do you make this happen?


896
00:43:38,846 --> 00:43:41,396
Well, if you do have a
view that just goes on top


897
00:43:41,396 --> 00:43:45,736
of the keyboard, it's a one
line code change, which is,


898
00:43:45,966 --> 00:43:47,466
to use inputAccessoryView.


899
00:43:48,316 --> 00:43:51,456
inputAccessoryView allows
you to specify the view,


900
00:43:51,866 --> 00:43:53,986
and that view is stuck
on top of the keyboard.


901
00:43:54,036 --> 00:43:56,216
And the keyboard takes
care of animating it in,


902
00:43:56,216 --> 00:43:58,876
animating it out, and making
sure it docks at the bottom


903
00:43:59,026 --> 00:44:01,376
when the hardware
keyboard is attached.


904
00:44:01,376 --> 00:44:05,036
Moving on to another
keyboard topic: keyboard type.


905
00:44:06,586 --> 00:44:10,396
Now keyboard types
basically allow you to specify


906
00:44:10,396 --> 00:44:13,976
within the same keyboard
different, specific,


907
00:44:14,036 --> 00:44:15,436
optimized keyboard types.


908
00:44:15,436 --> 00:44:18,096
So for example, here we have
the email type which is meant


909
00:44:18,096 --> 00:44:21,296
for email addresses, user
names, etc. And as you can see,


910
00:44:21,526 --> 00:44:24,486
it has the @ and full-stop
keys on the first plane


911
00:44:24,696 --> 00:44:25,856
to let you easily type those.


912
00:44:27,016 --> 00:44:30,766
Of course, the punctuation
planes are also optimized


913
00:44:30,766 --> 00:44:32,326
for email address typing.


914
00:44:32,846 --> 00:44:35,646
And so you have more
frequently used symbols there.


915
00:44:36,996 --> 00:44:39,826
What you might not know
is that in the keyboards


916
00:44:39,826 --> 00:44:43,896
for many languages, like
simplified Chinese, Arabic,


917
00:44:43,896 --> 00:44:47,606
etc. many of the commonly
used punctuation symbols


918
00:44:47,936 --> 00:44:51,216
for other languages are not
the same symbols that are used


919
00:44:51,216 --> 00:44:53,796
for email address or URLs.


920
00:44:53,966 --> 00:44:58,386
And so the problem is that,
if you expect a certain kind


921
00:44:58,386 --> 00:44:59,586
of input in your text field


922
00:44:59,586 --> 00:45:01,146
and you don't specify
the right type,


923
00:45:01,586 --> 00:45:04,266
the user might actually be
forced to switch keyboards just


924
00:45:04,266 --> 00:45:05,836
to type an email
address or username.


925
00:45:05,836 --> 00:45:07,136
And that's not a
very good experience.


926
00:45:07,996 --> 00:45:10,216
So, make sure to specify
the right keyboard type.


927
00:45:10,216 --> 00:45:11,936
And, of course, we have
more than just email.


928
00:45:12,026 --> 00:45:14,636
We have URL, Twitter, NumberPad.


929
00:45:15,266 --> 00:45:17,586
In fact, we have a whole host
of different keyboard types.


930
00:45:18,146 --> 00:45:20,576
And another one I would
like to call your attention


931
00:45:20,576 --> 00:45:21,876
to is ASCIICapable.


932
00:45:22,396 --> 00:45:24,086
Now if you have a
textField or textView


933
00:45:24,086 --> 00:45:26,936
in which you are expecting
content that is only in ASCII,


934
00:45:27,476 --> 00:45:29,566
go ahead and specify
the ASCIICapable type.


935
00:45:29,676 --> 00:45:32,226
That'll make sure that the
user's keyboard is switched,


936
00:45:32,226 --> 00:45:36,576
for example, from Chinese to an
ASCII keyboard automatically.


937
00:45:37,316 --> 00:45:41,996
And they don't have to manually
switch keyboards to do that.


938
00:45:42,226 --> 00:45:44,306
You should also know about
the autocorrection type.


939
00:45:44,656 --> 00:45:46,546
So, for some of your
textViews and textFields,


940
00:45:46,926 --> 00:45:48,296
autocorrection might
not be useful.


941
00:45:48,296 --> 00:45:50,606
In fact, it might
actually hamper user input.


942
00:45:50,606 --> 00:45:53,006
So, make sure to turn
autocorrection off


943
00:45:53,096 --> 00:45:53,876
where appropriate.


944
00:45:55,506 --> 00:46:00,596
Similarly, auto-capitalization
has four options


945
00:46:00,596 --> 00:46:02,756
which are very useful
for different contexts.


946
00:46:02,756 --> 00:46:05,106
And these are all
also language aware.


947
00:46:05,106 --> 00:46:07,886
So you should use these
appropriately depending


948
00:46:07,886 --> 00:46:09,276
on what kind of input
you're expecting


949
00:46:09,276 --> 00:46:10,786
in a certain textView
or textField.


950
00:46:14,616 --> 00:46:17,806
And lastly, I want to
talk about mark text.


951
00:46:18,486 --> 00:46:20,776
Now you might never
have seen this


952
00:46:20,776 --> 00:46:23,266
if you've never used a
Chinese or Japanese keyboard.


953
00:46:23,686 --> 00:46:26,946
But for these languages,
when the user types,


954
00:46:27,096 --> 00:46:30,046
they do not directly type
the output characters


955
00:46:30,046 --> 00:46:30,986
like they do in English.


956
00:46:31,246 --> 00:46:34,076
But they first type usually
a phonetic or other kind


957
00:46:34,076 --> 00:46:38,676
of input string and then
they choose a candidate


958
00:46:38,676 --> 00:46:39,586
from the bar below.


959
00:46:39,586 --> 00:46:40,866
Or it's above the keyboard.


960
00:46:42,436 --> 00:46:44,976
So what does this mean
for you as a developer?


961
00:46:46,086 --> 00:46:51,056
The important thing to know
here is when a textView


962
00:46:51,056 --> 00:46:52,986
or textField has
marked text in it.


963
00:46:53,806 --> 00:46:56,026
Because when it does
have marked text in it,


964
00:46:56,526 --> 00:46:58,686
the number one thing
you want to make sure is


965
00:46:58,686 --> 00:47:02,226
to not edit the content of
that textView or textField.


966
00:47:02,556 --> 00:47:04,166
Why? Because if you do that,


967
00:47:04,556 --> 00:47:07,846
their marked text will get
committed to the document.


968
00:47:09,596 --> 00:47:11,796
Pretty much no user
wants that to happen


969
00:47:11,796 --> 00:47:13,716
because that is not the text
they were trying to type.


970
00:47:13,716 --> 00:47:16,196
And you're going to have
some very frustrated users


971
00:47:16,196 --> 00:47:16,796
if you do that.


972
00:47:18,166 --> 00:47:23,136
And of course, while the marked
text is there, you can use it


973
00:47:23,216 --> 00:47:25,136
for other things
like autocompletion


974
00:47:25,136 --> 00:47:28,716
or showing some predictions
to the user.


975
00:47:28,716 --> 00:47:31,026
But what you should remember is


976
00:47:31,026 --> 00:47:32,806
that this is not
their final text.


977
00:47:33,066 --> 00:47:35,126
And often the marked
text is not going


978
00:47:35,126 --> 00:47:37,776
to contain meaningful
linguistic content


979
00:47:37,776 --> 00:47:40,756
because it's just the input
codes for that input method.


980
00:47:41,406 --> 00:47:44,706
So, use it for live
search if you'd like,


981
00:47:44,916 --> 00:47:48,586
but note that it might not
be the user's final content.


982
00:47:50,496 --> 00:47:56,696
And that is really all, well,
that's not all, but I would say


983
00:47:56,696 --> 00:47:59,046
that those are the most common
things you should keep in mind.


984
00:47:59,986 --> 00:48:03,896
And let me just reiterate some
of the items that we talked


985
00:48:03,896 --> 00:48:08,466
about earlier that will help
prevent you getting a one-star


986
00:48:08,466 --> 00:48:11,176
rating from someone in
Asia or the Middle East.


987
00:48:12,266 --> 00:48:18,316
So, first of all, localize your
app into tons of languages.


988
00:48:18,886 --> 00:48:23,716
Of course, iOS and OS X both
support a lot of languages,


989
00:48:23,716 --> 00:48:26,226
and we added new ones
for both platforms.


990
00:48:27,336 --> 00:48:32,586
And, starting in iOS 8, you can
localize into many languages


991
00:48:32,586 --> 00:48:38,566
that Apple doesn't localize
into, so don't let us stop you.


992
00:48:38,566 --> 00:48:41,206
Secondly, understand the
differences between language


993
00:48:41,206 --> 00:48:42,926
and locale and when to use them


994
00:48:42,926 --> 00:48:46,686
and when you don't
need to use them.


995
00:48:47,446 --> 00:48:50,956
Of course, format dates,
times and names correctly.


996
00:48:50,956 --> 00:48:55,296
As you saw, it's
really easy to do.


997
00:48:56,566 --> 00:49:00,126
And, note that there are a lot


998
00:49:00,126 --> 00:49:02,946
of right-to-left users
on both iOS and OS X.


999
00:49:02,946 --> 00:49:05,626
In fact, it's one of the
most popular languages


1000
00:49:05,626 --> 00:49:08,206
for input on iOS and OS X.


1001
00:49:08,206 --> 00:49:12,786
So, regardless of whether you
localize into Arabic or Hebrew


1002
00:49:12,786 --> 00:49:14,126
or another right-to-left
language or not,


1003
00:49:14,336 --> 00:49:16,676
make sure that you're
not breaking text input


1004
00:49:16,926 --> 00:49:17,716
for these users.


1005
00:49:18,876 --> 00:49:23,526
Keyboards, of course, come
in many different shapes


1006
00:49:23,526 --> 00:49:28,026
and sizes and-well actually,
one shape, many sizes-and,


1007
00:49:28,886 --> 00:49:31,436
of course, they come in
new sizes with iOS 8.


1008
00:49:31,436 --> 00:49:33,346
So make sure you
keep that in mind.


1009
00:49:34,166 --> 00:49:37,806
Of course, choose the right
keyboard type for the context


1010
00:49:37,946 --> 00:49:42,496
so that you make the input
experience smooth and easy.


1011
00:49:42,686 --> 00:49:47,616
And don't touch the marked text
if-don't touch the document


1012
00:49:47,696 --> 00:49:53,426
while there's marked
text in the document.


1013
00:49:53,426 --> 00:49:55,066
For more information, of course,


1014
00:49:55,066 --> 00:49:59,056
you can contact Jake who's
our App Frameworks Evangelist.


1015
00:49:59,556 --> 00:50:01,686
And we also have the
Internationalization


1016
00:50:01,686 --> 00:50:03,676
and Localization Guide
that I mentioned previously


1017
00:50:03,856 --> 00:50:08,146
up on our website that you
should really check out.


1018
00:50:09,386 --> 00:50:13,266
We also have two sessions that
you should definitely check out.


1019
00:50:13,266 --> 00:50:16,376
One is Localizing with Xcode
6, which is later this morning.


1020
00:50:17,006 --> 00:50:21,246
And, actually, we covered a
lot of new material this year


1021
00:50:21,246 --> 00:50:23,366
and we didn't actually
repeat a lot of the material


1022
00:50:23,366 --> 00:50:26,816
from previous years'
internationalization talks,


1023
00:50:27,096 --> 00:50:29,956
which are actually still
relevant for your apps today.


1024
00:50:30,116 --> 00:50:33,296
So definitely go ahead and check
out Making Your App World-Ready,


1025
00:50:33,296 --> 00:50:35,476
which is last year's
internationalization session.


1026
00:50:36,186 --> 00:50:37,016
Thank you very much.

