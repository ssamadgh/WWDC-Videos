1
00:00:08,516 --> 00:00:18,500
[ Music ]


2
00:00:21,516 --> 00:00:26,616
[ Applause ]


3
00:00:27,116 --> 00:00:29,696
>> Thank you, hello
everybody and welcome


4
00:00:29,696 --> 00:00:32,375
to Controlling Game
Input for Apple TV.


5
00:00:32,976 --> 00:00:36,086
I'm JJ Cwik, Game
Technology Software Engineer.


6
00:00:36,916 --> 00:00:41,876
Now when we introduce Apple
TV back in September we talked


7
00:00:41,876 --> 00:00:43,516
about the 10 foot experience.


8
00:00:44,316 --> 00:00:47,016
We talked about it being a
shared communal experience,


9
00:00:47,446 --> 00:00:50,426
one that's ideally suited
to longer gameplay sessions.


10
00:00:51,376 --> 00:00:52,716
And the fact of the matter is


11
00:00:52,866 --> 00:00:55,386
that people just love playing
games in their living room


12
00:00:56,136 --> 00:00:57,906
and Apple TV is great for that.


13
00:00:58,426 --> 00:01:00,036
It gives you the tools you need


14
00:01:00,286 --> 00:01:02,756
to create really
compelling game experiences.


15
00:01:03,596 --> 00:01:07,236
And I'm really happy to talk to
you today about the Siri Remote,


16
00:01:07,846 --> 00:01:09,776
MFi game controllers and how


17
00:01:09,776 --> 00:01:11,686
to best integrate
them into your game.


18
00:01:12,966 --> 00:01:15,856
Now before I start
spoiler alert,


19
00:01:15,986 --> 00:01:17,926
here's what's new in tvOS 10.


20
00:01:18,736 --> 00:01:23,036
As you heard on Monday, games
with advanced game mechanics


21
00:01:23,326 --> 00:01:24,436
that cannot be supported


22
00:01:24,436 --> 00:01:29,036
by the Siri Remote can
optionally include the


23
00:01:29,036 --> 00:01:33,216
requirement that they
require game controllers.


24
00:01:34,416 --> 00:01:36,926
Now we've also included
support for up


25
00:01:36,926 --> 00:01:38,976
to four MFi game controllers.


26
00:01:39,236 --> 00:01:41,526
This is going to be great
for multiplayer gaming.


27
00:01:42,986 --> 00:01:46,816
And as you also heard on Monday,
we have an Apple TV Remote app


28
00:01:47,276 --> 00:01:51,316
that can be used to control
your Apple TV and can be used


29
00:01:51,316 --> 00:01:52,486
as a game input device.


30
00:01:53,226 --> 00:01:55,036
Now I'll talk about all
these throughout the course


31
00:01:55,036 --> 00:01:58,686
of the talk, so let's
get started.


32
00:01:58,806 --> 00:02:02,976
Now apps on tvOS
typically take their input


33
00:02:02,976 --> 00:02:06,966
from the focus engine or
they also take the inputs


34
00:02:07,256 --> 00:02:09,515
from touches and gestures.


35
00:02:10,545 --> 00:02:13,026
But there's also a third
option available and that's


36
00:02:13,026 --> 00:02:15,836
to read inputs directly
off of the Siri Remote


37
00:02:16,096 --> 00:02:18,816
and game controllers with the
Game Controller framework.


38
00:02:19,446 --> 00:02:22,356
Now let me give you
a quick overview


39
00:02:22,476 --> 00:02:24,756
of the Game Controller
framework for those of you


40
00:02:24,756 --> 00:02:25,976
who may not be familiar with it.


41
00:02:26,716 --> 00:02:28,916
The Game Controller framework
was initially created


42
00:02:29,256 --> 00:02:32,506
to expose third-party game
controllers to your games.


43
00:02:33,086 --> 00:02:35,286
These compatible game
controllers are what we call


44
00:02:35,396 --> 00:02:36,476
MFi controllers.


45
00:02:37,476 --> 00:02:39,296
Now the framework has
since been updated


46
00:02:39,296 --> 00:02:41,536
to also include support
for the Siri Remote.


47
00:02:42,836 --> 00:02:47,056
The Game Controller framework
is a standardized simple API


48
00:02:47,056 --> 00:02:50,766
that allows you to
access all controllers


49
00:02:51,146 --> 00:02:53,816
and use the same
API calls regardless


50
00:02:54,016 --> 00:02:55,366
of the controller vendors.


51
00:02:56,796 --> 00:02:58,936
It standardizes detection
of controllers.


52
00:03:00,176 --> 00:03:02,346
It seamlessly handles
controllers that connect


53
00:03:02,346 --> 00:03:04,446
and disconnect while
your game is running.


54
00:03:05,176 --> 00:03:08,656
And it allows you to
control input or rather


55
00:03:08,656 --> 00:03:11,616
to read inputs off of the
controllers using polling


56
00:03:11,786 --> 00:03:12,886
or an event-driven model.


57
00:03:14,246 --> 00:03:18,866
And it's also available
on tvOS, iOS and macOS.


58
00:03:19,736 --> 00:03:23,176
And so even though this talk
is geared towards tvOS a lot


59
00:03:23,176 --> 00:03:26,876
of the code and concepts
still apply on iOS and macOS.


60
00:03:26,876 --> 00:03:30,956
So now that you have
an understanding


61
00:03:30,956 --> 00:03:34,566
of the framework I'd like to
talk about some specifics.


62
00:03:35,766 --> 00:03:36,976
There is a core class


63
00:03:37,116 --> 00:03:39,556
in the Game Controller
framework called GCController.


64
00:03:39,926 --> 00:03:41,806
This represents physical
controllers


65
00:03:42,456 --> 00:03:44,476
and it's the same class
for the Siri Remote


66
00:03:44,746 --> 00:03:46,316
and MFi game controllers.


67
00:03:46,846 --> 00:03:50,666
Now the first thing you're
probably going to want to do


68
00:03:50,666 --> 00:03:52,456
in your app is to get a list


69
00:03:52,456 --> 00:03:54,206
of all the currently
connected controllers.


70
00:03:54,706 --> 00:03:57,586
And to do this you use the
controller's class method


71
00:03:57,906 --> 00:03:59,036
on GCController.


72
00:03:59,686 --> 00:04:02,586
This returns you a list of the
currently connected controllers


73
00:04:02,836 --> 00:04:05,126
as an array of GCController
instances


74
00:04:05,846 --> 00:04:08,786
or an empty array if none exist.


75
00:04:10,796 --> 00:04:13,926
It's also common for controllers
to connect and disconnect


76
00:04:14,126 --> 00:04:20,055
as your app is running and to be
notified of this add observers


77
00:04:20,236 --> 00:04:23,686
for the GCCcontrollerDidConnect
Notification


78
00:04:23,986 --> 00:04:26,466
and GCControllerDidDisconnect
Notification.


79
00:04:27,326 --> 00:04:29,476
A great place to do this is


80
00:04:29,476 --> 00:04:31,996
in your application Did
Finish Launching with Options.


81
00:04:33,816 --> 00:04:36,666
So now we know which controllers
are connected and I'd


82
00:04:36,666 --> 00:04:38,846
like to shift focus and
talk about the Siri Remote.


83
00:04:39,606 --> 00:04:41,826
Now the Siri Remote is
surface to your game


84
00:04:41,966 --> 00:04:44,956
as a game controller using
the GCController class


85
00:04:44,956 --> 00:04:45,756
that I just mentioned.


86
00:04:47,176 --> 00:04:49,696
And in the Game Controller
framework, there's this concept


87
00:04:49,696 --> 00:04:53,976
of profiles and profiles grouped
together common functionality


88
00:04:54,506 --> 00:04:56,796
and the Siri Remote
supports two profiles.


89
00:04:57,456 --> 00:05:00,236
The first is called
GCMicroGamepad.


90
00:05:00,936 --> 00:05:03,446
This is what you use to
access the touch surface


91
00:05:03,656 --> 00:05:05,606
and the buttons on
the Siri Remote.


92
00:05:06,856 --> 00:05:11,146
The second profile that the
Siri Remote supports is called


93
00:05:11,146 --> 00:05:15,136
GCMotion and this is what you
use to access the gyroscope


94
00:05:15,236 --> 00:05:17,326
and accelerometer
on the Siri Remote.


95
00:05:18,196 --> 00:05:20,656
Now note that this is different
than what you might be used


96
00:05:20,656 --> 00:05:23,006
to on iOS where motion comes


97
00:05:23,006 --> 00:05:24,356
through the CoreMotion
framework.


98
00:05:25,786 --> 00:05:29,036
On tvOS motion comes through
the Game Controller framework.


99
00:05:30,376 --> 00:05:32,566
So let's look at each of
these profiles in turn.


100
00:05:33,146 --> 00:05:35,466
First, the GCMicroGamepad.


101
00:05:38,026 --> 00:05:41,016
Now the touch surface on
the Siri Remote is surface


102
00:05:41,016 --> 00:05:43,906
to your game as a
virtual DPAD of sorts.


103
00:05:44,696 --> 00:05:49,746
And you can query its value
using an analog representation


104
00:05:49,996 --> 00:05:55,356
as an XY coordinate pair or
as a digital input basically


105
00:05:55,356 --> 00:05:58,086
as four buttons up,
down, left and right.


106
00:06:00,756 --> 00:06:03,956
The GCMicroGamepad profile
also has an A button


107
00:06:04,236 --> 00:06:06,286
and this corresponds
to clicking the remote.


108
00:06:07,066 --> 00:06:10,366
This is ideally suited for the
primary action in your games,


109
00:06:10,666 --> 00:06:12,246
especially when the
remote is being held


110
00:06:12,246 --> 00:06:13,546
in portrait orientation.


111
00:06:14,106 --> 00:06:19,576
And the profile also has
an X button, this is useful


112
00:06:19,576 --> 00:06:21,476
as a secondary action
in your games


113
00:06:22,376 --> 00:06:25,166
and it becomes really natural
when the remote is tilted


114
00:06:25,166 --> 00:06:27,516
on its side and held in
landscape orientation


115
00:06:27,846 --> 00:06:29,876
to have a thumb on
the touch surface


116
00:06:30,096 --> 00:06:32,006
and another thumb
on the X button.


117
00:06:33,876 --> 00:06:36,426
Now note that there's also a
Menu button on this remote,


118
00:06:37,306 --> 00:06:39,046
I'll be talking about
that momentarily.


119
00:06:39,956 --> 00:06:41,156
And the remainder of the buttons


120
00:06:41,156 --> 00:06:43,466
on the remote are
reserved for system use.


121
00:06:43,916 --> 00:06:49,006
Here's a code example
to show how simple it is


122
00:06:49,006 --> 00:06:50,726
to read inputs off
of the buttons.


123
00:06:51,396 --> 00:06:55,276
Here we see we have a controller
that's already been connected


124
00:06:56,036 --> 00:06:58,726
and from that we can read
the MicroGamepad profile.


125
00:06:59,856 --> 00:07:02,766
That stores the button A
and button X properties


126
00:07:03,316 --> 00:07:05,776
and from there we just
check the isPressed property


127
00:07:06,106 --> 00:07:08,766
to determine whether or not
those buttons are pressed.


128
00:07:09,446 --> 00:07:12,136
Now we also support
an event-driven model.


129
00:07:12,796 --> 00:07:14,126
So if you want to be notified


130
00:07:14,126 --> 00:07:15,916
when the buttons are
pressed instead of having


131
00:07:15,916 --> 00:07:17,656
to poll you can do that.


132
00:07:19,106 --> 00:07:20,806
These are called the
pressedChangeHandler


133
00:07:21,776 --> 00:07:24,406
and this block of code that
you supply is run whenever the


134
00:07:24,406 --> 00:07:25,386
button changes state.


135
00:07:26,336 --> 00:07:27,606
Notice of this is called twice


136
00:07:27,606 --> 00:07:30,306
for traditional button
press once on button down


137
00:07:30,606 --> 00:07:31,846
and another time on button up.


138
00:07:33,456 --> 00:07:34,346
So those are the buttons.


139
00:07:34,726 --> 00:07:35,836
Let's look at the DPAD now.


140
00:07:36,876 --> 00:07:38,796
The DPAD as I mentioned
can be read


141
00:07:38,796 --> 00:07:40,866
as four buttons up,
down, left and right.


142
00:07:40,866 --> 00:07:43,386
And interestingly, has
a second representation


143
00:07:43,626 --> 00:07:46,336
as two axes, xAxis and yAxis.


144
00:07:46,656 --> 00:07:47,526
So let's look at those.


145
00:07:49,516 --> 00:07:52,476
Here you can see there's a DPAD
property on the MicroGamepad


146
00:07:52,926 --> 00:07:55,346
and it has xAxis and
yAxis properties.


147
00:07:55,986 --> 00:07:57,846
From there we read
the value property


148
00:07:57,846 --> 00:08:02,006
which returns a float normalized
between zero or sorry,


149
00:08:02,146 --> 00:08:04,946
normalized between
negative 1 and positive 1.


150
00:08:06,376 --> 00:08:09,276
Now as you'd expect, we also
have an event callback for that.


151
00:08:09,596 --> 00:08:13,586
And note in this case our
value change handler is used


152
00:08:13,586 --> 00:08:15,196
or we're supplying a
value change handler


153
00:08:15,196 --> 00:08:18,606
on the DPAD itself not
on the xAxis and yAxis.


154
00:08:18,956 --> 00:08:21,816
This is because we want to
be notified whenever either


155
00:08:21,816 --> 00:08:23,516
of those two axes changes.


156
00:08:24,066 --> 00:08:29,846
Now there's some interesting
aspects of the DPAD remote


157
00:08:29,886 --> 00:08:31,000
that I'd like to talk
to you about now.


158
00:08:39,066 --> 00:08:40,836
And the first one is
called DPAD windowing.


159
00:08:41,785 --> 00:08:44,706
Now what this is is it really
defines where the origin


160
00:08:44,706 --> 00:08:46,956
of your x and yAxis
is for the DPAD.


161
00:08:48,166 --> 00:08:49,896
Now you might be wondering
shouldn't this always be


162
00:08:49,896 --> 00:08:54,286
at the center and the answer is
a lot of times, no not really.


163
00:08:54,986 --> 00:08:57,816
A lot of times a player doesn't
concern themselves so much


164
00:08:57,816 --> 00:08:59,896
with the precise location
that they're touching


165
00:08:59,896 --> 00:09:02,276
on the touch surface,
but rather they just want


166
00:09:02,276 --> 00:09:04,296
to put their thumb
down and move relative


167
00:09:04,296 --> 00:09:05,656
to where they initially
touch down.


168
00:09:06,326 --> 00:09:08,366
And that's what DPAD
windowing allows you to do


169
00:09:08,366 --> 00:09:10,956
as a game developer is to tap
into this relative motion.


170
00:09:11,516 --> 00:09:12,766
So initial touch downs


171
00:09:12,766 --> 00:09:15,136
on the touch surface
establish an origin


172
00:09:15,556 --> 00:09:20,216
and then further movement from
there has DPAD values reported


173
00:09:20,216 --> 00:09:22,136
to your game relative
to that origin.


174
00:09:22,836 --> 00:09:24,196
Let me explain with an example.


175
00:09:25,076 --> 00:09:26,466
So here's our touch surface


176
00:09:26,466 --> 00:09:28,056
and I place my thumb
down right here.


177
00:09:28,516 --> 00:09:31,296
Notice it's not at the
midpoint of the touch surface,


178
00:09:32,076 --> 00:09:36,056
but with DPAD windowing
enabled this is where our origin


179
00:09:36,056 --> 00:09:39,146
for our x and yAxis
is established.


180
00:09:39,606 --> 00:09:43,906
Also note there's an imaginary
DPAD window placed outside


181
00:09:43,906 --> 00:09:45,656
of that centered
about the origin.


182
00:09:46,456 --> 00:09:48,066
Now watch what happens
as I move my thumb


183
00:09:48,066 --> 00:09:49,216
across the touch surface.


184
00:09:51,196 --> 00:09:54,546
The values reported to your
game are relative to this origin


185
00:09:54,906 --> 00:09:57,056
and in proportion to
the size of the window.


186
00:09:57,976 --> 00:09:59,886
Now as I continue
dragging my thumb


187
00:09:59,886 --> 00:10:02,806
across the touch surface
it drags the window


188
00:10:02,986 --> 00:10:04,936
and the axis along with it.


189
00:10:06,386 --> 00:10:10,306
Now we have established a new
origin and any further movement


190
00:10:10,306 --> 00:10:13,446
across the touch surface
has the DPAD values reported


191
00:10:13,446 --> 00:10:15,426
to your game relative
to this new origin.


192
00:10:16,226 --> 00:10:17,336
So that's DPAD windowing.


193
00:10:18,716 --> 00:10:22,026
If you want to receive absolute
DPAD values all the time you can


194
00:10:22,026 --> 00:10:25,396
opt into this with the
reportsAbsoluteDpadValues


195
00:10:25,446 --> 00:10:30,856
property, set this to true
and we always have the origin


196
00:10:30,856 --> 00:10:33,356
at the physical midpoint
of the touch surface.


197
00:10:34,086 --> 00:10:35,926
Then as I place my
thumb down and move it


198
00:10:35,926 --> 00:10:39,716
across the touch surface all
the values reported are relative


199
00:10:39,716 --> 00:10:41,816
to the physical midpoint
of the touch surface.


200
00:10:42,186 --> 00:10:44,000
So that's DPAD windowing.


201
00:10:50,136 --> 00:10:51,546
Next up rotation.


202
00:10:51,906 --> 00:10:54,866
So the DPAD values
surface to your game are


203
00:10:54,946 --> 00:10:57,866
in portrait orientation
and this means X is going


204
00:10:57,866 --> 00:11:00,236
to the right and Y is going up.


205
00:11:00,896 --> 00:11:03,346
However, this might cause a
problem if the player wants


206
00:11:03,346 --> 00:11:05,076
to play in landscape
orientation.


207
00:11:05,766 --> 00:11:09,176
In this case, your game would
need to transpose those values


208
00:11:09,776 --> 00:11:11,726
so that it's proper
to be played in game.


209
00:11:12,306 --> 00:11:14,936
But then what happens if
the user tilts the remote


210
00:11:14,936 --> 00:11:16,746
in the other direction,
you would need


211
00:11:16,746 --> 00:11:19,066
to transpose those values
in the opposite direction.


212
00:11:20,566 --> 00:11:22,576
And how would you even do
this, you'd either have


213
00:11:22,616 --> 00:11:24,486
to force the player to play


214
00:11:24,486 --> 00:11:28,006
in a particular orientation
all the time or you'd have


215
00:11:28,006 --> 00:11:29,576
to start reading
accelerometer data


216
00:11:29,576 --> 00:11:31,606
and track the orientation
changes yourself.


217
00:11:31,976 --> 00:11:33,556
And this isn't something
you want to be doing.


218
00:11:34,236 --> 00:11:37,486
So we've provided a property
for this called allowsRotation.


219
00:11:37,976 --> 00:11:40,176
Now by default this
property is set to false.


220
00:11:40,766 --> 00:11:43,806
But if you set it to true,
then the DPAD values reported


221
00:11:43,806 --> 00:11:46,176
to your game will
be with respect


222
00:11:46,176 --> 00:11:48,556
to whatever orientation the
remote is being held in.


223
00:11:49,166 --> 00:11:51,316
So when this is true
and when the remote's


224
00:11:51,316 --> 00:11:53,286
in portrait orientation
X is going


225
00:11:53,286 --> 00:11:54,806
to the right and Y is going up.


226
00:11:56,066 --> 00:12:00,126
And in landscape left X is going
to the right and Y is going up.


227
00:12:00,626 --> 00:12:03,626
And in landscape right
you've guessed it X is going


228
00:12:03,626 --> 00:12:05,266
to the right and Y is going up.


229
00:12:06,196 --> 00:12:08,356
So if your game wants
to allow players to play


230
00:12:08,356 --> 00:12:12,066
in landscape orientation
set allows rotation to true


231
00:12:12,506 --> 00:12:14,906
so you don't have to worry
about orientation changes


232
00:12:14,966 --> 00:12:16,666
or rotating DPAD
values yourself.


233
00:12:17,106 --> 00:12:18,856
So that's rotation.


234
00:12:19,726 --> 00:12:20,736
Next up motion.


235
00:12:22,146 --> 00:12:25,076
As I mentioned earlier,
the second profile


236
00:12:25,076 --> 00:12:27,616
that the Siri Remote
supports is called GCMotion.


237
00:12:28,936 --> 00:12:32,066
Now as the user moves the
remote around the gravity


238
00:12:32,066 --> 00:12:34,476
in user acceleration
vectors supplied


239
00:12:34,476 --> 00:12:36,596
by the GCMotion profile
are updated.


240
00:12:38,146 --> 00:12:40,726
Note that these values are
already filtered before they get


241
00:12:40,726 --> 00:12:41,386
to your game.


242
00:12:41,766 --> 00:12:43,416
So if you have a tvOS game


243
00:12:43,676 --> 00:12:46,766
and you're doing motion
filtering we suggest you remove


244
00:12:46,766 --> 00:12:49,406
that so that you don't
introduce any unnecessary lag


245
00:12:49,406 --> 00:12:50,646
into your game.


246
00:12:51,986 --> 00:12:56,426
Also, this is fused motion data
and what we mean by that is


247
00:12:56,426 --> 00:13:00,116
that the accelerometer and the
gyroscope help to reinforce


248
00:13:00,116 --> 00:13:01,066
and correct each other.


249
00:13:01,746 --> 00:13:05,396
So just like on your
iPhone the gravity vector


250
00:13:05,686 --> 00:13:09,106
from the accelerometer
helps to correct the drift


251
00:13:09,106 --> 00:13:12,576
in the gyroscope and
the gyroscope data helps


252
00:13:12,576 --> 00:13:15,426
to smooth the values coming
from the accelerometer.


253
00:13:15,996 --> 00:13:17,036
They reinforce each other.


254
00:13:18,156 --> 00:13:20,786
But really, vigorous
motion can overwhelm that,


255
00:13:21,236 --> 00:13:24,606
so for this reason we recommend
you avoid creating scenarios


256
00:13:24,606 --> 00:13:26,896
in your game that
require the user


257
00:13:27,146 --> 00:13:28,756
to vigorously shake the remote.


258
00:13:29,376 --> 00:13:31,756
Because this causes data
that's difficult correct


259
00:13:32,076 --> 00:13:34,376
until the sensors have
had a chance to stabilize.


260
00:13:37,126 --> 00:13:39,886
Next up I want to talk
about the Menu button.


261
00:13:43,476 --> 00:13:46,346
Now all controllers
supported by tvOS


262
00:13:46,396 --> 00:13:48,596
in the Game Controller
framework have a Menu button.


263
00:13:49,226 --> 00:13:51,426
It's the same Menu button
with the same behavior


264
00:13:51,646 --> 00:13:54,656
on the Siri Remote and
MFi game controllers.


265
00:13:58,936 --> 00:14:04,036
Now in an app on tvOS when
the Menu button is pressed the


266
00:14:04,036 --> 00:14:07,586
recommended behavior changes
depending on the context.


267
00:14:08,066 --> 00:14:11,356
Sometimes pressing the Menu
button will minimize your app


268
00:14:11,836 --> 00:14:13,886
and return you back to
the Apple TV Home Screen.


269
00:14:15,576 --> 00:14:17,676
That's typically done in
your game's main menu.


270
00:14:18,676 --> 00:14:22,636
At other times pressing the Menu
button will go back one level


271
00:14:22,826 --> 00:14:25,316
in your apps menu hierarchy


272
00:14:25,766 --> 00:14:27,646
and this is typically
done in submenus.


273
00:14:30,326 --> 00:14:33,946
Lastly, pressing the Menu
button sometimes pauses


274
00:14:33,946 --> 00:14:35,856
or resumes your active gameplay.


275
00:14:39,056 --> 00:14:42,706
Now nongame apps
written entirely


276
00:14:42,706 --> 00:14:46,506
in UIKit get the first two
behaviors largely for free


277
00:14:46,506 --> 00:14:50,536
without any additional
work, but most games due


278
00:14:50,536 --> 00:14:54,256
to their custom UI have to do
a little bit of extra work here


279
00:14:54,536 --> 00:14:56,326
to indicate to the
system their intent.


280
00:14:57,266 --> 00:14:57,966
Let me explain.


281
00:15:00,736 --> 00:15:03,726
So in UIKit when the
Menu button is pressed


282
00:15:04,176 --> 00:15:07,986
for UIKit apps it pops the child
view controller off the stack.


283
00:15:08,476 --> 00:15:11,536
This returns you back to your
previous level of your menus.


284
00:15:12,616 --> 00:15:14,156
Now you can do this successively


285
00:15:14,156 --> 00:15:18,006
with each Menu button press
popping the child view


286
00:15:18,006 --> 00:15:19,706
controllers off the
stack and then


287
00:15:19,706 --> 00:15:22,326
at some point you have
one view controller,


288
00:15:22,486 --> 00:15:24,336
your root view controller
remaining on the stack.


289
00:15:25,586 --> 00:15:27,196
Now when there's only
one view controller left


290
00:15:27,196 --> 00:15:30,856
on the stack the next Menu
button press minimizes your app


291
00:15:30,856 --> 00:15:33,376
and bounces you back to
the Apple TV Home Screen.


292
00:15:35,096 --> 00:15:38,366
Most games by comparison
are architected differently,


293
00:15:38,796 --> 00:15:41,576
they typically have custom
in-game UI that's not written


294
00:15:41,766 --> 00:15:42,476
in UIKit.


295
00:15:43,246 --> 00:15:45,766
And they also typically
have scene transitions


296
00:15:45,766 --> 00:15:47,586
between the different
portions of the game


297
00:15:47,806 --> 00:15:50,306
that also aren't
written in UIKit.


298
00:15:52,176 --> 00:15:55,296
And so for this reason
they typically can get away


299
00:15:55,296 --> 00:15:56,956
with only having
one view controller,


300
00:15:56,956 --> 00:15:58,016
the root view controller,


301
00:15:58,016 --> 00:15:59,706
for the entire duration
of their game.


302
00:16:00,326 --> 00:16:01,996
But by the rule that we just saw


303
00:16:02,286 --> 00:16:04,696
because there's only one
view controller in the stack


304
00:16:04,696 --> 00:16:06,036
at all points of your game


305
00:16:06,386 --> 00:16:09,056
by default pressing the Menu
button will bounce you back


306
00:16:09,056 --> 00:16:10,326
to the Apple TV Home Screen.


307
00:16:10,926 --> 00:16:13,586
So you're going to need some
way to indicate to the system


308
00:16:13,856 --> 00:16:16,646
when you want Menu button
presses to return you


309
00:16:16,646 --> 00:16:18,946
to the Apple TV Home
Screen and when you don't.


310
00:16:21,066 --> 00:16:23,000
Enter GCEventViewController.


311
00:16:28,116 --> 00:16:31,816
This is a special view
controller we created for single


312
00:16:31,816 --> 00:16:34,166
or rather for game
controller games


313
00:16:34,166 --> 00:16:35,696
that have a single-view
controller.


314
00:16:37,076 --> 00:16:41,116
So if your game is one of these
you're going to want to set this


315
00:16:41,196 --> 00:16:42,536
as your root view controller.


316
00:16:43,426 --> 00:16:46,686
Now this view controller
has a property called


317
00:16:46,686 --> 00:16:49,866
controllerUserInteractionEnabled
and this is the key


318
00:16:49,866 --> 00:16:52,936
that you have for controlling
when your app returns back


319
00:16:52,936 --> 00:16:54,806
to the home screen for
Menu button presses.


320
00:16:56,796 --> 00:16:59,526
When this value is false this
view controller effectively


321
00:16:59,566 --> 00:17:02,536
traps the Menu button presses
and prevents them from going


322
00:17:02,536 --> 00:17:03,636
up the responder chain,


323
00:17:03,966 --> 00:17:05,526
effectively keeping
you in your app.


324
00:17:07,806 --> 00:17:09,076
Incidentally, this is also


325
00:17:09,076 --> 00:17:11,106
where your controller
pause handler is called


326
00:17:11,205 --> 00:17:12,536
and I'll get to that
momentarily.


327
00:17:13,726 --> 00:17:14,846
Now when this value is set


328
00:17:14,846 --> 00:17:19,546
to true Menu button events
are allowed to proceed


329
00:17:19,546 --> 00:17:23,675
up the responder chain as
normal, which allows your app


330
00:17:23,715 --> 00:17:25,185
to be minimized and
takes you back


331
00:17:25,185 --> 00:17:26,386
to the Apple TV Home Screen.


332
00:17:27,486 --> 00:17:30,576
So your job as a game
developer is to manage the state


333
00:17:30,576 --> 00:17:32,456
of
controllerUserInteractionEnabled


334
00:17:32,726 --> 00:17:34,116
as a user goes back and forth


335
00:17:34,166 --> 00:17:35,446
between different
parts of your game.


336
00:17:36,096 --> 00:17:37,706
Let me show you with
a block diagram.


337
00:17:38,176 --> 00:17:39,926
So here we are at the
Apple TV Home Screen


338
00:17:39,926 --> 00:17:40,826
and we launch our app.


339
00:17:41,576 --> 00:17:43,226
Some games have a splash screen


340
00:17:43,226 --> 00:17:45,076
or some other introductory
sequence


341
00:17:45,346 --> 00:17:47,816
and many games will
eventually land


342
00:17:48,016 --> 00:17:49,726
on an in-game main
menu of sorts.


343
00:17:50,446 --> 00:17:53,486
And for both of these
the user's expectation is


344
00:17:53,486 --> 00:17:55,756
that when they press the Menu
button they will be bounced back


345
00:17:55,806 --> 00:17:57,506
to the Apple TV Home
Screen immediately.


346
00:17:58,306 --> 00:17:58,826
Therefore,


347
00:17:58,906 --> 00:18:00,776
set
controllerUserInteractionEnabled


348
00:18:00,776 --> 00:18:01,916
to true.


349
00:18:02,476 --> 00:18:04,776
Now when the user progresses
to other parts of the game,


350
00:18:05,016 --> 00:18:07,296
say active gameplay
or in submenus,


351
00:18:07,896 --> 00:18:09,346
the user's expectations is


352
00:18:09,346 --> 00:18:12,156
that Menu button presses
will not bounce you back


353
00:18:12,266 --> 00:18:13,386
to the Apple TV Home Screen.


354
00:18:13,736 --> 00:18:16,616
So in these cases set
controllerUserInteractionEnabled


355
00:18:16,616 --> 00:18:17,106
to false.


356
00:18:18,086 --> 00:18:19,986
And if a user transitions back


357
00:18:20,016 --> 00:18:21,796
to the in-game main
menu remember


358
00:18:21,796 --> 00:18:23,196
to set this back to true again.


359
00:18:24,436 --> 00:18:28,096
So that covers our first
behavior when we return back


360
00:18:28,136 --> 00:18:29,696
to the Apple TV Home
Screen and not.


361
00:18:30,296 --> 00:18:32,156
And we still have the
two behaviors remaining.


362
00:18:32,156 --> 00:18:35,856
We need to worry about going
back in submenus and pausing


363
00:18:35,856 --> 00:18:37,206
and resuming active gameplay.


364
00:18:37,586 --> 00:18:40,086
Basically all the dark
boxes on this diagram.


365
00:18:41,186 --> 00:18:43,236
And the good news is that
those are both handled


366
00:18:43,236 --> 00:18:44,866
in the controllerPausedHandler.


367
00:18:45,426 --> 00:18:50,096
The controllerPausedHandler is
a block of code that you supply


368
00:18:50,846 --> 00:18:54,066
to the controller or for
each controller rather


369
00:18:54,446 --> 00:18:56,676
and this is code that runs
whenever the Menu button is


370
00:18:56,676 --> 00:18:58,566
pressed and you're not
going to be bounced back


371
00:18:58,566 --> 00:18:59,816
to the Apple TV Home Screen.


372
00:19:00,796 --> 00:19:04,056
And it's a simple matter within
this block of code to check


373
00:19:04,516 --> 00:19:06,596
if you're in a submenu go back


374
00:19:06,596 --> 00:19:08,936
to the previous level
menu in your game.


375
00:19:09,626 --> 00:19:12,326
If you're in active gameplay
toggle the pause state.


376
00:19:13,216 --> 00:19:15,236
And that's it now
your game is set


377
00:19:15,236 --> 00:19:18,246
up to properly handle Menu
button presses regardless


378
00:19:18,246 --> 00:19:19,346
of where you are in your game.


379
00:19:25,126 --> 00:19:27,486
So now let's talk about
MFi game controllers.


380
00:19:28,366 --> 00:19:30,836
Some games can really take
advantage of the extended set


381
00:19:30,836 --> 00:19:34,226
of controls offered by
wireless extended gamepads


382
00:19:34,656 --> 00:19:36,126
and these are optional
accessories


383
00:19:36,126 --> 00:19:36,916
that players may have.


384
00:19:38,086 --> 00:19:40,256
Now by extended what
we're referring


385
00:19:40,256 --> 00:19:42,736
to is the control
layout and it's a layout


386
00:19:42,736 --> 00:19:44,366
that you're probably
already very familiar with.


387
00:19:44,936 --> 00:19:48,896
It features a DPAD on the left,
it features four face buttons A,


388
00:19:48,896 --> 00:19:51,766
B, X, Y in these
positions and in this shape,


389
00:19:52,176 --> 00:19:53,646
the diamond pattern
on the right.


390
00:19:54,506 --> 00:19:57,136
On the front of the controller
it features two thumb sticks


391
00:19:57,656 --> 00:20:00,126
and on top we have two
shoulders and two triggers.


392
00:20:01,186 --> 00:20:02,926
Now all of these buttons
that I've mentioned


393
00:20:02,926 --> 00:20:06,746
so far are pressure-sensitive
and I'll cover that momentarily.


394
00:20:07,696 --> 00:20:10,686
We also have a Menu button,
which I already discussed


395
00:20:11,046 --> 00:20:13,186
and we have four
player indicator LEDs.


396
00:20:13,916 --> 00:20:19,026
Now just like the Siri Remote
supports the GCMicroGamepad


397
00:20:20,476 --> 00:20:22,426
extended game controllers
support the


398
00:20:22,426 --> 00:20:24,526
GCExtendedGamepad profile.


399
00:20:25,126 --> 00:20:27,926
And you'll notice on the left
here there's a table listing all


400
00:20:27,926 --> 00:20:28,586
the properties.


401
00:20:29,556 --> 00:20:32,906
Also notice the data types
GCControllerDirectionPad


402
00:20:32,986 --> 00:20:34,826
and GCControllerButtonInput.


403
00:20:35,326 --> 00:20:36,826
These are the same
data types you're used


404
00:20:36,826 --> 00:20:37,926
to on the Siri Remote.


405
00:20:39,196 --> 00:20:41,656
Now one thing I'd like to
point out is that the DPAD


406
00:20:41,776 --> 00:20:44,116
and the buttons and
every single input


407
00:20:44,116 --> 00:20:46,846
on this table actually
is pressure-sensitive.


408
00:20:47,366 --> 00:20:49,256
So even those buttons and inputs


409
00:20:49,256 --> 00:20:51,266
that are typically
considered digital only


410
00:20:51,266 --> 00:20:54,466
in other controllers that
you may have encountered


411
00:20:54,656 --> 00:20:56,466
like the DPAD and
the face buttons


412
00:20:56,466 --> 00:20:59,356
and shoulder buttons they're
all pressure-sensitive


413
00:20:59,526 --> 00:21:02,486
and so they can be read in an
analog and in a digital sense.


414
00:21:03,746 --> 00:21:06,606
So let's look at code that shows
that analog digital duality.


415
00:21:07,286 --> 00:21:09,866
Here we have the A button and
the first line is showing how


416
00:21:09,866 --> 00:21:11,646
to access the digital state


417
00:21:11,646 --> 00:21:13,446
of the button whether
or not it's pressed.


418
00:21:13,816 --> 00:21:16,676
So if your game only concerns
itself in a particular situation


419
00:21:16,676 --> 00:21:19,176
with whether or not a button is
pressed this is what you want


420
00:21:19,176 --> 00:21:19,536
to use.


421
00:21:21,176 --> 00:21:24,206
However, if you care about
how hard a button is pressed,


422
00:21:24,906 --> 00:21:26,556
that's when you'd use
the value property.


423
00:21:27,296 --> 00:21:29,956
And this is great to add more
nuance control to your game.


424
00:21:30,486 --> 00:21:32,906
Maybe you're creating a
sports game and you want


425
00:21:32,906 --> 00:21:35,416
to allow players to vary
the speed of their passes


426
00:21:35,416 --> 00:21:39,476
from a soft gentle pass to a
fast bullet pass and you can do


427
00:21:39,476 --> 00:21:42,146
that by reading how hard
the button was pressed


428
00:21:42,146 --> 00:21:43,016
with the value property.


429
00:21:43,816 --> 00:21:47,876
We also offer event
callbacks as you'd expect.


430
00:21:48,356 --> 00:21:50,406
Now notice there's a
pressedChangeHandler,


431
00:21:50,406 --> 00:21:52,306
which corresponds to
the press property.


432
00:21:52,596 --> 00:21:54,126
This is for Boolean
state changes


433
00:21:54,126 --> 00:21:55,316
or digital state changes.


434
00:21:55,846 --> 00:21:58,206
And there's a value changed
property which corresponds


435
00:21:58,206 --> 00:22:02,396
to the value or sorry, a value
change handler which corresponds


436
00:22:02,396 --> 00:22:03,456
with the value property.


437
00:22:04,686 --> 00:22:07,966
Now the value change
handler is called many times


438
00:22:07,966 --> 00:22:10,836
in a typical button press
as the button progresses


439
00:22:10,836 --> 00:22:13,266
down through its travel
range and back up again.


440
00:22:14,436 --> 00:22:16,536
And for those of you looking
for guidance on whether


441
00:22:16,536 --> 00:22:19,846
to use polling or event
callbacks, there's no hard


442
00:22:19,846 --> 00:22:22,626
and fast rules, but
polling tends to be good


443
00:22:23,026 --> 00:22:25,756
for reading those
inputs that change


444
00:22:25,756 --> 00:22:27,406
over a longer period of time.


445
00:22:27,806 --> 00:22:30,856
Like maybe the accelerator
on a racecar game being tied


446
00:22:30,856 --> 00:22:34,076
to the trigger of a button
or rather the trigger


447
00:22:34,076 --> 00:22:34,926
of the game controller.


448
00:22:35,506 --> 00:22:39,786
And event callbacks
tend to work really well


449
00:22:40,416 --> 00:22:42,876
when you're concerned about
edge transitions of buttons.


450
00:22:43,216 --> 00:22:44,726
So maybe you have
an adventure game


451
00:22:44,726 --> 00:22:47,626
and a player swings
their sword and you want


452
00:22:47,626 --> 00:22:50,316
to activate the swing sword
animation the moment the button


453
00:22:50,316 --> 00:22:50,886
is pressed.


454
00:22:51,226 --> 00:22:53,746
Event callbacks are
great for that.


455
00:22:55,256 --> 00:22:58,876
So by this point you
probably have an understanding


456
00:22:58,876 --> 00:23:03,566
of the mechanics of
connecting and reading inputs


457
00:23:03,566 --> 00:23:05,446
from the Siri Remote
and game controllers


458
00:23:06,316 --> 00:23:07,596
and you're probably
starting to think


459
00:23:07,596 --> 00:23:09,996
about which control types
your game is going to support.


460
00:23:10,836 --> 00:23:12,406
Will it support just
the Siri Remote


461
00:23:12,616 --> 00:23:17,416
or will it support the Siri
Remote and MFi game controllers?


462
00:23:19,616 --> 00:23:20,976
Or as you heard on Monday,


463
00:23:21,826 --> 00:23:23,816
games that have advanced
game mechanics


464
00:23:24,276 --> 00:23:25,406
that can't be supported


465
00:23:25,406 --> 00:23:29,000
by the Siri Remote can require
the use of a game controller.


466
00:23:39,146 --> 00:23:40,476
Now how you specify


467
00:23:40,476 --> 00:23:44,096
which controller types your
game supports is in Xcode.


468
00:23:44,846 --> 00:23:48,696
In your target settings
there's a capabilities tab


469
00:23:49,296 --> 00:23:51,506
and in there you'll find the
game controllers capability.


470
00:23:51,946 --> 00:23:55,176
Enable this capability
and select which types


471
00:23:55,176 --> 00:23:56,866
of controllers your
game supports.


472
00:23:58,026 --> 00:24:01,696
Interacting with this GUI
changes the keys and values


473
00:24:01,776 --> 00:24:04,206
in your info.plist
file accordingly.


474
00:24:04,796 --> 00:24:08,816
And this is important for
app review because all games


475
00:24:08,816 --> 00:24:11,956
that link the Game Controller
framework are going to


476
00:24:12,416 --> 00:24:16,056
or rather these keys are going
to be looked for in app review


477
00:24:16,056 --> 00:24:18,146
by all games that link the
Game Controller framework.


478
00:24:18,866 --> 00:24:21,906
And where this really
matters is in the App Store


479
00:24:22,266 --> 00:24:25,956
because your users are going
to be notified in the App Store


480
00:24:26,046 --> 00:24:28,776
if your game has game
controllers as optional


481
00:24:28,986 --> 00:24:30,556
or game controllers as required.


482
00:24:31,356 --> 00:24:35,496
Additionally, the user may
be warned if they tried


483
00:24:35,496 --> 00:24:37,896
to download a game
controller required game


484
00:24:39,916 --> 00:24:41,806
when they haven't
paired a game controller


485
00:24:41,806 --> 00:24:43,096
to that Apple TV before.


486
00:24:44,536 --> 00:24:46,566
Now note that this
is only a safeguard


487
00:24:47,346 --> 00:24:49,766
because it's very
possible that your game


488
00:24:49,996 --> 00:24:52,926
that requires game
controllers may still launch


489
00:24:53,486 --> 00:24:55,526
and find no game
controllers connected.


490
00:24:56,096 --> 00:24:59,766
And this is a case that you
need to account for and handle.


491
00:25:01,096 --> 00:25:03,896
It's very possible that maybe
the user merely forgot to turn


492
00:25:03,896 --> 00:25:04,886
on their game controller.


493
00:25:05,636 --> 00:25:08,866
So in this situation
notify the player


494
00:25:09,306 --> 00:25:11,376
that no game controllers
were found


495
00:25:11,446 --> 00:25:12,786
and to connect a
game controller.


496
00:25:14,976 --> 00:25:17,446
Otherwise, the user may be
wondering why your game is


497
00:25:17,446 --> 00:25:18,866
seemingly not controllable.


498
00:25:19,526 --> 00:25:22,776
Now there's one other
place to concern yourself


499
00:25:22,776 --> 00:25:25,326
with notifying the user in
this kind of manner and that's


500
00:25:25,326 --> 00:25:26,696
on controller disconnections.


501
00:25:27,126 --> 00:25:29,226
This is because the controller


502
00:25:29,486 --> 00:25:32,606
or rather the controllers
available may pass your initial


503
00:25:32,606 --> 00:25:34,356
check, but then somewhere


504
00:25:34,356 --> 00:25:36,446
down the line while
your app is running one


505
00:25:36,446 --> 00:25:38,216
of the game controllers
could disconnect.


506
00:25:38,556 --> 00:25:40,116
And if this is the
only game controller


507
00:25:40,116 --> 00:25:43,376
that was available then at this
point your game can't proceed


508
00:25:43,376 --> 00:25:44,856
since it requires
game controllers


509
00:25:44,916 --> 00:25:47,000
and again a place
to notify the user.


510
00:25:53,046 --> 00:25:56,426
For more information,
see Designing for tvOS,


511
00:25:56,656 --> 00:26:00,000
session 802 for more information
on requiring game controllers.


512
00:26:07,046 --> 00:26:08,536
So let's talk about
something new now,


513
00:26:08,716 --> 00:26:09,976
the Apple TV Remote app.


514
00:26:10,816 --> 00:26:14,366
As you heard on Monday, this
is a new app and it's available


515
00:26:14,366 --> 00:26:16,706
in beta form on
developer.apple.com.


516
00:26:17,856 --> 00:26:20,246
This app allows you to
control your Apple TV


517
00:26:20,666 --> 00:26:22,886
and it features a large
touch surface in the middle


518
00:26:22,886 --> 00:26:26,666
of the screen and on-screen
buttons that you'll find


519
00:26:26,666 --> 00:26:27,906
as well on the Siri Remote.


520
00:26:28,416 --> 00:26:32,196
And importantly for our
discussion this can be used


521
00:26:32,196 --> 00:26:33,396
as a game input device.


522
00:26:33,946 --> 00:26:38,966
And the way that's done
on tvOS is it's surfaced


523
00:26:39,646 --> 00:26:41,616
by the Game Controller
framework to your game


524
00:26:41,616 --> 00:26:42,866
in a very familiar manner.


525
00:26:43,406 --> 00:26:45,676
It's effectively an
emulated Siri Remote.


526
00:26:46,396 --> 00:26:48,906
So it shows up as a
GCController instance


527
00:26:50,006 --> 00:26:52,366
and it supports the
GCMicroGamepad


528
00:26:52,366 --> 00:26:55,146
and GCMotion profiles
just like the Siri Remote.


529
00:26:56,046 --> 00:26:57,856
In fact, it's indistinguishable


530
00:26:58,106 --> 00:27:00,766
in the Game Controller
framework from the Siri Remote.


531
00:27:01,306 --> 00:27:06,226
So the code you write for the
Siri Remote will work for both.


532
00:27:07,686 --> 00:27:12,336
Now by default these
remotes are coalesced,


533
00:27:12,886 --> 00:27:16,906
so if you have a Siri Remote and
a TV Remote app they will appear


534
00:27:16,906 --> 00:27:19,236
as one game controller
by default


535
00:27:19,426 --> 00:27:20,536
in your controllers array.


536
00:27:21,646 --> 00:27:24,396
This means that button inputs
from both will be surface


537
00:27:24,396 --> 00:27:26,626
to your game as if they
came from one controller


538
00:27:27,466 --> 00:27:29,326
and the same thing
with DPAD inputs.


539
00:27:30,476 --> 00:27:33,816
Now for motion we didn't want
the motion input form one


540
00:27:34,066 --> 00:27:36,436
overwriting and fighting with
the motion input from the other,


541
00:27:36,706 --> 00:27:39,336
so we take motion from
one controller or sorry,


542
00:27:39,336 --> 00:27:40,826
from one remote at a time.


543
00:27:41,346 --> 00:27:45,026
And the remote we take
it from is the remote


544
00:27:45,026 --> 00:27:48,246
that last received intentional
user input either swipes


545
00:27:48,246 --> 00:27:50,826
on the touch surface or
A or X button presses.


546
00:27:52,126 --> 00:27:55,806
Now if you want you can opt-in
to separate these remotes


547
00:27:55,806 --> 00:27:58,176
and have them show up
as distinct instances


548
00:27:58,176 --> 00:27:59,506
in your controllers array.


549
00:28:00,326 --> 00:28:03,856
To do this, go to
your info.plist file


550
00:28:03,986 --> 00:28:08,016
and add the Boolean key
GCSupportsMultipleMicroGamepads,


551
00:28:08,416 --> 00:28:11,546
set this to yes and
now the Siri Remote


552
00:28:11,546 --> 00:28:13,756
and Apple TV Remote
apps will show


553
00:28:13,756 --> 00:28:17,906
up as distinct controller
instances in your array.


554
00:28:17,906 --> 00:28:25,316
Now I want to talk to you
about a special mode inside


555
00:28:25,316 --> 00:28:28,226
of the Apple TV Remote app
called Game Controller mode.


556
00:28:28,636 --> 00:28:31,936
This is a mode that users can
switch into and out of at will


557
00:28:32,206 --> 00:28:34,726
in any game that links the
Game Controller framework.


558
00:28:35,426 --> 00:28:41,876
Now this app is in landscape
orientation and as such,


559
00:28:41,906 --> 00:28:43,716
the DPAD values are rotated


560
00:28:43,716 --> 00:28:46,516
by 90 degrees before they
even get to your app.


561
00:28:47,276 --> 00:28:49,866
So your app doesn't
have to do anything


562
00:28:50,006 --> 00:28:51,666
to take advantage of this mode.


563
00:28:53,146 --> 00:28:56,146
However, just note that if
your game manually rotates DPAD


564
00:28:56,146 --> 00:28:58,956
values by 90 degrees
you're effectively going


565
00:28:58,956 --> 00:29:00,456
to be doing a double rotation.


566
00:29:01,316 --> 00:29:04,746
So our recommendation is if
you have a game that wants


567
00:29:04,746 --> 00:29:07,376
to allow players to play
in landscape orientation


568
00:29:07,596 --> 00:29:10,226
with the Siri Remote
and Game Controller mode


569
00:29:10,226 --> 00:29:14,396
on the Apple TV Remote app
set allowsRotation to true


570
00:29:14,396 --> 00:29:18,176
like we saw previously
in the talk and allow us


571
00:29:18,176 --> 00:29:20,856
to handle the orientation
and DPAD changes for you.


572
00:29:21,706 --> 00:29:23,846
Now one more thing to note,


573
00:29:24,266 --> 00:29:27,876
the Apple TV Remote app's Game
Controller mode separates the


574
00:29:27,876 --> 00:29:29,806
touch surface from the A button.


575
00:29:30,356 --> 00:29:33,476
This is different
from the Siri Remote


576
00:29:33,846 --> 00:29:37,056
where clicking the touch surface
it activates the A button.


577
00:29:37,926 --> 00:29:41,586
Now mechanically this doesn't
provide any problems the user


578
00:29:41,586 --> 00:29:44,156
can still simultaneously
enter input on both


579
00:29:44,376 --> 00:29:46,046
and your game code
can still check


580
00:29:46,046 --> 00:29:47,716
for simultaneous input on both.


581
00:29:48,576 --> 00:29:51,946
But the key point is if you
have game code that assumes


582
00:29:51,946 --> 00:29:55,606
that all A button presses will
also activate the touch surface


583
00:29:55,876 --> 00:29:58,886
this won't work in the same
way on the Game Controller mode


584
00:29:58,886 --> 00:30:00,000
for the Apple TV Remote app.


585
00:30:11,166 --> 00:30:14,206
And lastly, I'd like to talk to
you about multiple controllers.


586
00:30:14,206 --> 00:30:16,736
We get asked all the time how
many controllers does Apple


587
00:30:16,736 --> 00:30:17,646
TV support.


588
00:30:18,686 --> 00:30:23,556
And the answer is one Siri
Remote new for tvOS 10


589
00:30:23,556 --> 00:30:28,086
up to four MFi game controllers
and the Apple TV Remote app.


590
00:30:29,666 --> 00:30:31,706
Now we typically get
asked this in the context


591
00:30:31,706 --> 00:30:35,696
of multiplayer gaming and
with the addition of up


592
00:30:35,696 --> 00:30:38,986
to four MFi game controllers
for tvOS 10 this is going


593
00:30:38,986 --> 00:30:40,636
to be great for multiplayer
gaming.


594
00:30:42,116 --> 00:30:44,896
But something that may not
be initially obvious is


595
00:30:44,896 --> 00:30:47,716
that this is very important for
single-player gaming as well.


596
00:30:48,336 --> 00:30:49,006
Let me explain.


597
00:30:50,046 --> 00:30:53,596
When your app launches you're
not sure if you're going


598
00:30:53,596 --> 00:30:58,246
to find only one Siri Remote
connected or maybe you're going


599
00:30:58,246 --> 00:31:00,386
to find a game controller
connected


600
00:31:01,776 --> 00:31:03,186
or maybe you'll find one of each


601
00:31:04,626 --> 00:31:06,646
or maybe you'll find
a Siri Remote,


602
00:31:06,646 --> 00:31:09,026
multiple game controllers,
the TV Remote app.


603
00:31:09,266 --> 00:31:10,206
You get the picture right?


604
00:31:10,326 --> 00:31:13,856
So the key point here is on
Apple TV it's very natural


605
00:31:13,856 --> 00:31:17,226
to receive inputs from
multiple controllers even


606
00:31:17,226 --> 00:31:18,436
for single-player games.


607
00:31:18,796 --> 00:31:21,276
And importantly, you
don't know ahead of time


608
00:31:21,676 --> 00:31:24,036
which controller the
user is intending to use.


609
00:31:24,896 --> 00:31:26,116
So you can't just assume


610
00:31:26,406 --> 00:31:29,456
that the controller's
array index zero is the one


611
00:31:29,456 --> 00:31:30,506
that the player wants to use.


612
00:31:31,246 --> 00:31:32,866
So how should we handle this?


613
00:31:33,456 --> 00:31:35,656
Well the key realization here is


614
00:31:35,656 --> 00:31:38,256
that players can switch
controllers at any point.


615
00:31:38,856 --> 00:31:40,316
Maybe they launched your app,


616
00:31:41,146 --> 00:31:43,846
traverse through your
in-game menus and launch


617
00:31:43,846 --> 00:31:47,026
into gameplay all with the
Siri Remote and then switch


618
00:31:47,026 --> 00:31:48,236
to the MFi game controller


619
00:31:48,236 --> 00:31:50,426
to actually start
controlling the gameplay.


620
00:31:51,016 --> 00:31:58,726
And games that allow players
to switch freely and flexibly


621
00:31:58,986 --> 00:32:01,696
between different
controllers without having


622
00:32:01,696 --> 00:32:04,916
to prompt the user with
unnecessary confirmation dialogs


623
00:32:05,366 --> 00:32:08,026
or without requiring the
user to exit gameplay


624
00:32:08,026 --> 00:32:09,186
and reenter gameplay


625
00:32:09,186 --> 00:32:13,206
with a different controller will
create a really great seamless


626
00:32:13,206 --> 00:32:14,296
user experience.


627
00:32:15,376 --> 00:32:16,466
So how should we do this?


628
00:32:17,676 --> 00:32:20,596
Well one way to go about
this is to treat input


629
00:32:20,596 --> 00:32:22,566
from all controllers
as valid input


630
00:32:22,566 --> 00:32:23,686
for your single-player game.


631
00:32:24,846 --> 00:32:26,556
So if you have a character
that moves onscreen


632
00:32:26,556 --> 00:32:30,466
from the DPAD allow all
controllers that are connected,


633
00:32:30,706 --> 00:32:32,966
allow their DPADs to control
the character movement.


634
00:32:34,156 --> 00:32:36,966
Similarly with buttons, if
your character or rather


635
00:32:36,966 --> 00:32:38,266
if your character jumps


636
00:32:38,906 --> 00:32:41,596
by pressing the A button
allow all the A buttons


637
00:32:41,626 --> 00:32:44,506
on all the connected controllers
to control the character.


638
00:32:45,686 --> 00:32:49,796
And if a controller
connects in the middle


639
00:32:49,796 --> 00:32:52,476
of your gameplay you can
silently start tracking


640
00:32:52,476 --> 00:32:54,626
that controller too
and allow its inputs


641
00:32:54,626 --> 00:32:55,676
to control your character.


642
00:32:57,376 --> 00:32:59,156
Now this is working
really well we're able


643
00:32:59,156 --> 00:33:03,456
to give the player a system here
in your game where they're able


644
00:33:03,456 --> 00:33:05,396
to switch back and forth
between controllers.


645
00:33:05,546 --> 00:33:08,166
And this is effectively a
manual coalescing strategy


646
00:33:08,576 --> 00:33:10,316
where we're taking the
inputs from Siri remotes


647
00:33:10,316 --> 00:33:12,116
and game controllers
and feeding them all


648
00:33:12,116 --> 00:33:13,666
into our single-player
experience.


649
00:33:14,066 --> 00:33:18,336
But there's one edge case
here that I want to talk


650
00:33:18,336 --> 00:33:19,386
about and that's motion.


651
00:33:19,766 --> 00:33:21,176
So let me explain
with an example.


652
00:33:22,696 --> 00:33:25,276
If you have a game
that uses motion say


653
00:33:25,276 --> 00:33:28,256
to control the attitude of
an airplane flying in the air


654
00:33:28,456 --> 00:33:31,886
with the Siri Remote
you might also offload


655
00:33:31,886 --> 00:33:34,726
that controlling the
airplane to a thumb stick


656
00:33:34,726 --> 00:33:36,736
if the player is playing
with a game controller.


657
00:33:36,946 --> 00:33:38,866
And that's perfectly fine
that works really well.


658
00:33:40,516 --> 00:33:43,896
The key concern here though is
you don't want your thumb stick


659
00:33:43,926 --> 00:33:47,046
that controls the airplane
with the game controller


660
00:33:47,356 --> 00:33:50,286
to be overwritten by any motion
data that might be coming


661
00:33:50,286 --> 00:33:53,066
from the Siri Remote when
you're manually coalescing them.


662
00:33:53,626 --> 00:33:56,956
So in this case the code in your
game that controls the attitude


663
00:33:56,956 --> 00:33:59,616
of the airplane should
gate on whether it's taking


664
00:33:59,616 --> 00:34:02,856
that information from
motion or from thumb sticks.


665
00:34:03,526 --> 00:34:06,646
So then back to our example
as I'm controlling my plane


666
00:34:06,646 --> 00:34:08,606
with my Siri Remote if I pick


667
00:34:08,606 --> 00:34:11,985
up my game controller any
intentional user input


668
00:34:11,985 --> 00:34:15,366
on that game controller whether
it's DPAD or thumb sticks


669
00:34:15,366 --> 00:34:19,516
or triggers or buttons will
start ignoring the motion coming


670
00:34:19,516 --> 00:34:22,346
from the Siri Remote and
use the right thumb stick


671
00:34:22,456 --> 00:34:26,056
to control the attitude of
the airplane and vice versa.


672
00:34:26,056 --> 00:34:29,346
If I then pick up my Siri
Remote intentional user input,


673
00:34:29,636 --> 00:34:32,156
namely swipes across
the touch surface or A


674
00:34:32,156 --> 00:34:35,545
or X button presses will at
that point start listening


675
00:34:35,545 --> 00:34:38,795
to motion coming from the Siri
Remote and switch to that.


676
00:34:39,996 --> 00:34:43,516
In using this we have a control
scheme that's very flexible


677
00:34:43,516 --> 00:34:45,496
for players and allows
them to switch


678
00:34:45,496 --> 00:34:46,766
as seamlessly as possible.


679
00:34:48,246 --> 00:34:52,755
Now I'd like to end
this section by saying


680
00:34:52,755 --> 00:34:54,196
that maybe these techniques


681
00:34:54,196 --> 00:34:57,216
that I've shown you here can
be directly used by your game


682
00:34:58,176 --> 00:35:01,736
or maybe they're a good starting
point and you can tweak them


683
00:35:01,736 --> 00:35:04,716
and customize them to suit
your game just perfectly.


684
00:35:05,646 --> 00:35:08,026
But in any case, I really
want to encourage you


685
00:35:08,276 --> 00:35:12,246
to go beyond the mere mechanics
of controllers connecting


686
00:35:12,246 --> 00:35:15,186
and disconnecting and
reading button values


687
00:35:15,946 --> 00:35:18,706
and really thoughtfully
consider how you're going


688
00:35:18,706 --> 00:35:20,706
to integrate game
controllers into your game.


689
00:35:21,416 --> 00:35:23,516
Because when you get
this right in the mind


690
00:35:23,516 --> 00:35:26,266
of the player game
controllers just melt away


691
00:35:26,716 --> 00:35:29,406
and it really allows them
to become immersed by


692
00:35:29,406 --> 00:35:31,786
and enjoy the game experiences


693
00:35:31,856 --> 00:35:33,476
that you've worked
so hard to create.


694
00:35:33,476 --> 00:35:35,616
And that's what games
are all about right.


695
00:35:38,646 --> 00:35:40,086
So we've talked about
a lot today.


696
00:35:40,476 --> 00:35:42,306
To summarize, we talked


697
00:35:42,306 --> 00:35:45,806
about the Siri Remote how it
supports the GCMicroGamepad


698
00:35:45,806 --> 00:35:48,226
profile in the GCMotion profile.


699
00:35:48,896 --> 00:35:51,506
I talked about DPAD
windowing and allowsRotation.


700
00:35:52,246 --> 00:35:54,876
I also talked about
the Menu button and how


701
00:35:54,876 --> 00:35:58,476
on Apple TV the expected
behavior varies depending


702
00:35:58,476 --> 00:35:59,686
on the context of your app.


703
00:36:00,556 --> 00:36:02,996
And how you can use the
GCEventViewController


704
00:36:03,106 --> 00:36:06,266
and control or pause handlers
to control that behavior.


705
00:36:07,716 --> 00:36:10,136
I also talked about
MFi game controllers


706
00:36:10,886 --> 00:36:13,666
that these use the
GCExtendedGamepad profile


707
00:36:14,066 --> 00:36:16,026
that they introduce
pressure sensitivity


708
00:36:16,916 --> 00:36:18,966
and that they can
now be required


709
00:36:18,966 --> 00:36:20,766
as a controller for your game.


710
00:36:21,336 --> 00:36:24,786
I also talked about
the TV Remote app


711
00:36:25,666 --> 00:36:28,256
and how that's an emulated Siri
Remote from the perspective


712
00:36:28,256 --> 00:36:29,456
of the Game Controller
framework.


713
00:36:29,936 --> 00:36:31,636
And I talked about
Game Controller mode


714
00:36:31,636 --> 00:36:34,926
of the Apple TV Remote app
and design considerations


715
00:36:35,206 --> 00:36:38,376
so that your game
works as intended


716
00:36:38,376 --> 00:36:40,106
for the Apple TV Remote app.


717
00:36:41,056 --> 00:36:42,876
And lastly, I finished
up by talking


718
00:36:42,876 --> 00:36:45,486
about multiple controllers
and how it's great


719
00:36:45,486 --> 00:36:49,206
for multiplayer gaming, but it's
equally as important to consider


720
00:36:49,486 --> 00:36:50,666
for single-player gaming.


721
00:36:50,956 --> 00:36:55,236
Namely, allowing your players to
switch controllers as seamlessly


722
00:36:55,326 --> 00:36:59,566
as you can for your game.


723
00:36:59,646 --> 00:37:01,696
Here's the URL for this session.


724
00:37:01,796 --> 00:37:03,966
You can find the
video, documentation


725
00:37:03,966 --> 00:37:05,076
and code samples here.


726
00:37:05,456 --> 00:37:07,196
This is session 607.


727
00:37:08,616 --> 00:37:11,946
Related sessions include
Mastering UIKit on tvOS


728
00:37:12,256 --> 00:37:13,826
and Designing for tvOS.


729
00:37:14,366 --> 00:37:17,306
There's also a tvOS lab
for more general questions.


730
00:37:18,666 --> 00:37:20,106
Thank you so much
for your attention


731
00:37:20,356 --> 00:37:21,826
and have a wonderful
rest of your show.

