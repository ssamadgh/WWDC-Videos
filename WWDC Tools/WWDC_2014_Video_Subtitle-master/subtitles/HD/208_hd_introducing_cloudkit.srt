1
00:00:13,236 --> 00:00:14,526
>> My name is Olivier Bonnet.


2
00:00:14,526 --> 00:00:18,266
I'm the engineering manager for
the CloudKit on the client side.


3
00:00:20,536 --> 00:00:25,976
So, up until today Apple
had many iCloud technologies


4
00:00:25,976 --> 00:00:28,266
and they looked like
this to you.


5
00:00:28,426 --> 00:00:31,666
We had iCloud Drive, iCloud
Core Data, iCloud file Library


6
00:00:31,976 --> 00:00:33,736
and how they interacted
with the iCloud,


7
00:00:34,526 --> 00:00:36,996
the Apple iCloud server
was kind of a mystery.


8
00:00:37,286 --> 00:00:42,276
So today we're lifting
some of the mystery


9
00:00:42,276 --> 00:00:43,576
in introducing CloudKit.


10
00:00:45,056 --> 00:00:47,336
So let's look at
what we're going


11
00:00:47,336 --> 00:00:49,816
to cover here in this session.


12
00:00:49,866 --> 00:00:53,686
First we're going to start
with what is CloudKit.


13
00:00:55,566 --> 00:00:58,996
We're going to walk you through
the couple of steps you need


14
00:00:58,996 --> 00:01:01,466
to enable CloudKit in your
application and start using it.


15
00:01:02,806 --> 00:01:05,996
We're going to do a walkthrough
of the different APIs,


16
00:01:06,676 --> 00:01:10,266
we're going to talk about
how CloudKit interacts


17
00:01:10,266 --> 00:01:15,406
with the Apple, the iCloud
user accounts and last


18
00:01:15,406 --> 00:01:18,786
but not least we'll cover when
to use CloudKit as opposed


19
00:01:18,786 --> 00:01:23,426
to other existing iCloud APIs we
already have on the platforms.


20
00:01:25,356 --> 00:01:26,416
So let's start.


21
00:01:26,416 --> 00:01:27,286
What is CloudKit?


22
00:01:28,576 --> 00:01:31,686
You'll notice the new batch
but the whole session is new


23
00:01:31,786 --> 00:01:33,626
so it's share only
on that slide.


24
00:01:35,566 --> 00:01:38,276
[Laughter] CloudKit is
a way to give you access


25
00:01:38,276 --> 00:01:42,396
to iCloud servers and
we really mean it.


26
00:01:42,806 --> 00:01:46,206
CloudKit is the foundation
for both iCloud Drive


27
00:01:46,466 --> 00:01:47,736
and iCloud file Library.


28
00:01:48,346 --> 00:01:51,586
Those features were written
from scratch on top of CloudKit.


29
00:01:52,936 --> 00:01:55,936
CloudKit is supported
on both OS 10 and iOS.


30
00:01:56,006 --> 00:01:58,966
It's a new public
framework, cloudkit.framework.


31
00:01:59,436 --> 00:02:01,326
Check it out in SDK.


32
00:02:02,596 --> 00:02:05,826
CloudKit uses the iCloud
accounts infrastructure.


33
00:02:05,826 --> 00:02:10,376
That means that if there's
a logged in iCloud account


34
00:02:10,376 --> 00:02:14,656
on the device we'll use
that to identify the user.


35
00:02:15,196 --> 00:02:18,766
If there's none, we'll provide
read only anonymous access.


36
00:02:20,006 --> 00:02:24,116
CloudKit supports both a concept
of public and private databases.


37
00:02:24,116 --> 00:02:26,776
You can see public
databases as a soup


38
00:02:26,776 --> 00:02:30,126
of data that's all your
user can access to.


39
00:02:30,986 --> 00:02:36,796
Private databases are meant
to store the actual data just


40
00:02:36,796 --> 00:02:38,296
on behalf of a specific user.


41
00:02:41,136 --> 00:02:43,946
CloudKit support both
structured and bulk data.


42
00:02:44,366 --> 00:02:48,646
You can use it to store
large files on iCloud servers


43
00:02:48,646 --> 00:02:51,936
and we'll take care of
transmitting them efficiently


44
00:02:52,286 --> 00:02:54,646
from the iCloud servers.


45
00:02:55,926 --> 00:02:59,546
Importantly CloudKit is
a transport technology.


46
00:02:59,776 --> 00:03:02,356
It doesn't provide
any local persistence.


47
00:03:02,476 --> 00:03:06,946
It enables you to send and
receive data from the servers.


48
00:03:08,766 --> 00:03:09,506
So let's start.


49
00:03:09,696 --> 00:03:12,526
How do you enable CloudKit
in your application?


50
00:03:12,766 --> 00:03:16,956
So first you'll want to navigate
your application's capabilities,


51
00:03:16,956 --> 00:03:18,006
pane and X code.


52
00:03:18,236 --> 00:03:21,056
See that big iCloud off switch?


53
00:03:21,056 --> 00:03:24,266
You want to turn
it on and you want


54
00:03:24,266 --> 00:03:28,056
to check the CloudKit
checkbox here.


55
00:03:28,746 --> 00:03:29,806
At that point you're ready.


56
00:03:30,026 --> 00:03:30,986
There's no fourth step.


57
00:03:32,646 --> 00:03:35,166
Your app is ready to
read and write data


58
00:03:35,206 --> 00:03:39,776
to Apple's iCloud server and to
walk you through the API on how


59
00:03:39,776 --> 00:03:43,656
to do this I'm going to hand
over to Paul to chat about it.


60
00:03:43,656 --> 00:03:43,723
[Applause]


61
00:03:43,723 --> 00:03:44,476
>> All right.


62
00:03:45,156 --> 00:03:45,866
Thank you, Olivier.


63
00:03:46,516 --> 00:03:49,996
[ Applause ]


64
00:03:50,496 --> 00:03:52,156
So, as Olivier said,
my name is Paul.


65
00:03:52,156 --> 00:03:54,966
I work on the CloudKit client
framework, and I'm very excited


66
00:03:54,966 --> 00:03:57,276
to talk to you guys
today about CloudKit.


67
00:03:57,356 --> 00:03:59,446
We're going to start off
we're going to start talking


68
00:03:59,446 --> 00:04:01,746
about the fundamental
CloudKit objects.


69
00:04:01,796 --> 00:04:03,206
These are going to
be the set of objects


70
00:04:03,206 --> 00:04:05,336
that you're initially
exposed to when you open up


71
00:04:05,336 --> 00:04:06,986
and start playing with
the CloudKit framework.


72
00:04:07,976 --> 00:04:10,016
Just running through a quick
list of them we're going to talk


73
00:04:10,016 --> 00:04:12,616
about containers and we're
going to talk about databases,


74
00:04:12,976 --> 00:04:15,396
we're going to talk about
records, we're going to talk


75
00:04:15,396 --> 00:04:19,706
about record zones
and RecordIDentifiers,


76
00:04:20,196 --> 00:04:21,555
we're going to talk
about references


77
00:04:21,555 --> 00:04:23,126
and we're going to
talk about assets.


78
00:04:23,126 --> 00:04:23,766
It's quite a list.


79
00:04:23,766 --> 00:04:26,886
This is going to be a really fun
and really jam-packed session.


80
00:04:27,226 --> 00:04:31,046
So let's get started and we're
going to talk about containers.


81
00:04:31,786 --> 00:04:33,876
This is sort of the
idealized model


82
00:04:34,106 --> 00:04:36,656
of your application
talking about iCloud.


83
00:04:36,656 --> 00:04:39,706
Now you guys are
application developers,


84
00:04:39,706 --> 00:04:42,046
you guys are client
developers, and you know


85
00:04:42,046 --> 00:04:44,856
that your application
running on a client whether


86
00:04:44,856 --> 00:04:46,216
that client is a iPhone


87
00:04:46,276 --> 00:04:49,556
or whether it be a Mac Book
yours is not the only process


88
00:04:49,556 --> 00:04:50,446
running on that client.


89
00:04:50,876 --> 00:04:52,106
Rather yours is one of many.


90
00:04:52,906 --> 00:04:56,486
Now on your client your
process is going to be siloed,


91
00:04:56,486 --> 00:04:57,926
sandboxed in some ways.


92
00:04:58,616 --> 00:05:02,206
In some cases, it's
a literal sandbox.


93
00:05:02,236 --> 00:05:03,166
Certainly in others
you're running


94
00:05:03,166 --> 00:05:04,326
in your own memory space.


95
00:05:05,006 --> 00:05:06,926
This concept of taking
your client


96
00:05:06,926 --> 00:05:08,666
and actually running
it separated


97
00:05:08,666 --> 00:05:10,656
from other clients
is pretty powerful.


98
00:05:10,656 --> 00:05:12,176
It has got a couple
of advantages.


99
00:05:12,326 --> 00:05:15,256
It helps with security,
it helps with stability


100
00:05:15,256 --> 00:05:16,646
and it helps with privacy.


101
00:05:17,506 --> 00:05:20,536
So as we are figuring out how
we wanted to build CloudKit,


102
00:05:20,586 --> 00:05:23,456
we thought to ourselves how can
we take these three advantages


103
00:05:23,846 --> 00:05:25,336
and replicate them
up in the server?


104
00:05:25,336 --> 00:05:28,026
So here's what we did.


105
00:05:28,026 --> 00:05:30,836
Just as your client is
one of many, I'm sorry,


106
00:05:30,936 --> 00:05:33,076
your application is one of
many running on the client,


107
00:05:33,516 --> 00:05:35,806
so too the part of
iCloud that you're talking


108
00:05:35,806 --> 00:05:39,056
to is one of many up on iCloud.


109
00:05:39,096 --> 00:05:41,016
We call these different
silos containers.


110
00:05:41,646 --> 00:05:43,966
So containers.


111
00:05:44,456 --> 00:05:46,566
Containers are exposed
in the CloudKit framework


112
00:05:46,566 --> 00:05:48,556
as the CKContainer class.


113
00:05:48,556 --> 00:05:49,626
CK is our prefix
and you're going


114
00:05:49,626 --> 00:05:51,326
to see this all over the place.


115
00:05:51,466 --> 00:05:54,146
By default one application
talks to one container.


116
00:05:55,546 --> 00:05:58,336
Containers afford us the
ability to segregate data.


117
00:05:58,866 --> 00:06:01,306
That means that your application
can read and write data


118
00:06:01,306 --> 00:06:03,856
to iCloud, another application
can read and write data


119
00:06:03,856 --> 00:06:05,586
to iCloud and the two datasets


120
00:06:05,586 --> 00:06:07,326
up on the server will
not be intermingled.


121
00:06:08,256 --> 00:06:11,986
In addition to data segregation,
this containerization


122
00:06:11,986 --> 00:06:15,876
of iCloud storage allows us to
encapsulate user information.


123
00:06:16,626 --> 00:06:17,876
Now as Olivier mentioned,


124
00:06:18,226 --> 00:06:21,776
CloudKit involves using the
iCloud account infrastructure


125
00:06:22,266 --> 00:06:24,496
and we want to give
you some limited access


126
00:06:24,556 --> 00:06:26,896
to that iCloud account
and we want to make sure


127
00:06:26,896 --> 00:06:29,816
that we're doing so in a
privacy conscientious manner.


128
00:06:30,436 --> 00:06:33,486
So in order to do that, we
encapsulate user information.


129
00:06:33,946 --> 00:06:36,406
User information available
to your application is going


130
00:06:36,406 --> 00:06:38,116
to be container scoped
and, therefore,


131
00:06:38,116 --> 00:06:41,416
different than the view
of user information seen


132
00:06:41,416 --> 00:06:42,456
by another application.


133
00:06:43,896 --> 00:06:46,076
Containers are managed
by you the developer.


134
00:06:46,076 --> 00:06:49,256
You're going to be managing
them via the WWDR portal.


135
00:06:50,186 --> 00:06:52,796
It's important to note
that the name space


136
00:06:52,796 --> 00:06:55,616
of containers is
global to all developers


137
00:06:55,966 --> 00:06:58,046
so when you're choosing a name
for your container make sure


138
00:06:58,046 --> 00:06:59,366
that you're using
it in a reverse,


139
00:06:59,406 --> 00:07:01,706
you're using a reverse DNS name.


140
00:07:02,986 --> 00:07:06,606
Now, right up there just like
a little while ago I said


141
00:07:06,606 --> 00:07:08,876
that by default there
is one container


142
00:07:08,876 --> 00:07:10,736
to one application,
a one to one mapping.


143
00:07:11,406 --> 00:07:14,486
We think this is going to be
successful for 99% of use cases


144
00:07:14,756 --> 00:07:17,126
and certainly as you go and
start using CloudKit it's going


145
00:07:17,126 --> 00:07:18,896
to be great as you start
exploring the framework.


146
00:07:19,316 --> 00:07:21,566
We recognize that there
are some scenarios


147
00:07:21,566 --> 00:07:23,386
where you need a
more complex mapping


148
00:07:23,716 --> 00:07:25,426
so we support a many
to many model.


149
00:07:25,526 --> 00:07:29,166
What we mean is that multiple
applications can coordinate


150
00:07:29,166 --> 00:07:31,026
on the same iCloud container.


151
00:07:32,046 --> 00:07:34,006
Also a single application
can talk


152
00:07:34,006 --> 00:07:35,496
to multiple iCloud containers.


153
00:07:38,306 --> 00:07:39,266
On to databases.


154
00:07:40,226 --> 00:07:42,686
One of the chief purposes
of CloudKit is the ability


155
00:07:42,686 --> 00:07:45,516
to take your object model in
your application and replicate


156
00:07:45,516 --> 00:07:46,356
that up to the server.


157
00:07:46,786 --> 00:07:49,206
So when we start
thinking about how we want


158
00:07:49,206 --> 00:07:51,436
to present this modeling
to you we thought


159
00:07:51,436 --> 00:07:54,486
to ourselves how can we
divide up application objects?


160
00:07:54,486 --> 00:07:55,706
Obviously all objects


161
00:07:55,706 --> 00:07:57,776
in my application are
not treated equally.


162
00:07:58,536 --> 00:08:01,116
One of the first things that we
notice was there's a fundamental


163
00:08:01,116 --> 00:08:03,796
difference in the
audience of data.


164
00:08:04,576 --> 00:08:08,246
Some data is intended to be used
by the user that created it.


165
00:08:08,736 --> 00:08:11,136
If you imagine an application
where I'm writing up notes


166
00:08:11,136 --> 00:08:13,236
and I want to see my notes
everywhere else, that's my data.


167
00:08:13,276 --> 00:08:15,576
I create it, I consume it.


168
00:08:15,956 --> 00:08:19,386
On the other hand, there's use
for what we call public data.


169
00:08:19,816 --> 00:08:23,026
This is data that can be,
a, created by the user


170
00:08:23,026 --> 00:08:24,316
for the benefit of a community;


171
00:08:24,686 --> 00:08:26,856
think perhaps a review
on a restaurant.


172
00:08:27,676 --> 00:08:29,916
Or it could be information that
you the developer has uploaded


173
00:08:29,916 --> 00:08:32,265
to iCloud because it's
useful to your application.


174
00:08:33,025 --> 00:08:35,736
In either case, the audience
is not just a single user


175
00:08:35,736 --> 00:08:36,686
but a community of people.


176
00:08:37,395 --> 00:08:38,895
So how did we solve the fact


177
00:08:38,895 --> 00:08:40,756
that we've got these
different types of data.


178
00:08:41,346 --> 00:08:43,306
Let's break open a container
and have a look inside.


179
00:08:44,186 --> 00:08:46,596
Inside of a container
you're going to notice first


180
00:08:46,596 --> 00:08:48,026
and foremost the
public database.


181
00:08:48,026 --> 00:08:50,236
This is the soup, this is
where all of the public


182
00:08:50,236 --> 00:08:52,886
and communal data
co-lives, co-mingles.


183
00:08:53,946 --> 00:08:55,036
Additionally, you're
going to notice


184
00:08:55,036 --> 00:08:57,366
that there's private databases
and you're going to find


185
00:08:57,366 --> 00:08:59,076
that there's an individual
private database


186
00:08:59,076 --> 00:09:00,716
for each user of
your application.


187
00:09:01,436 --> 00:09:03,836
Now this is sort of the
50,000 foot overview


188
00:09:03,836 --> 00:09:05,466
of what the iCloud
infrastructure looks like,


189
00:09:05,606 --> 00:09:07,866
but you know, how much do
you guys care about that?


190
00:09:08,186 --> 00:09:09,186
What you guys are interested


191
00:09:09,186 --> 00:09:11,156
in is what does this
infrastructure look


192
00:09:11,156 --> 00:09:13,726
like to me the client running
on a phone or running on a Mac.


193
00:09:14,736 --> 00:09:16,196
Obviously you're only
going to have access


194
00:09:16,196 --> 00:09:18,026
to the currently
logged in iCloud user.


195
00:09:18,216 --> 00:09:20,246
So rather than seeing
a public database


196
00:09:20,246 --> 00:09:22,926
and a gajillion private
databases, your view is going


197
00:09:22,926 --> 00:09:24,116
to look a little
bit more like this.


198
00:09:24,256 --> 00:09:26,196
You're going to have a choice
between a public database


199
00:09:26,656 --> 00:09:28,486
or the private database
that is correlated


200
00:09:28,486 --> 00:09:30,006
to the currently
logged in iCloud user.


201
00:09:31,096 --> 00:09:32,556
So databases.


202
00:09:33,096 --> 00:09:36,606
Databases are exposed in our
API as a CK database class.


203
00:09:37,176 --> 00:09:38,866
Every application has
access to two of them,


204
00:09:39,266 --> 00:09:40,516
the public and the private.


205
00:09:41,376 --> 00:09:44,266
Let's have a look at
a little bit of code.


206
00:09:44,556 --> 00:09:47,206
The container is the initial
entry point into CloudKit.


207
00:09:47,726 --> 00:09:49,726
Here we see that I am talking
to my default container


208
00:09:50,066 --> 00:09:51,496
and getting its public database.


209
00:09:51,876 --> 00:09:53,276
I can also talk to
the default container


210
00:09:53,276 --> 00:09:54,476
and get it to private database.


211
00:09:55,186 --> 00:09:56,296
Let's have a look
at the differences


212
00:09:56,296 --> 00:09:57,646
between these 2 databases.


213
00:09:58,396 --> 00:10:01,166
As we mentioned, the
desired audience is going


214
00:10:01,166 --> 00:10:02,906
to be different between
the public database


215
00:10:02,906 --> 00:10:03,796
and the private database.


216
00:10:03,836 --> 00:10:06,476
The public db is for shared
data, the private db is


217
00:10:06,476 --> 00:10:07,386
for the user's own data.


218
00:10:08,586 --> 00:10:11,116
As such, we have different
requirements for whether


219
00:10:11,116 --> 00:10:13,756
or not an iCloud account
needs to exist on the client.


220
00:10:14,566 --> 00:10:16,766
In the private database,
since I am reading


221
00:10:16,766 --> 00:10:19,566
and writing a user's data if
we have no notion of the user,


222
00:10:19,696 --> 00:10:23,206
that is if we don't have a login
iCloud account there's really no


223
00:10:23,206 --> 00:10:24,806
utility in moving
this information


224
00:10:24,806 --> 00:10:26,336
to and from the server.


225
00:10:26,656 --> 00:10:29,336
So we require an iCloud account
to be logged in if you want


226
00:10:29,336 --> 00:10:30,446
to use the private database.


227
00:10:30,996 --> 00:10:33,446
In the public database since
the audience is more communal,


228
00:10:33,686 --> 00:10:37,086
we allow you read only anonymous
access to the public database.


229
00:10:40,466 --> 00:10:42,796
You'll recall from
yesterday's talk


230
00:10:42,876 --> 00:10:45,476
that CloudKit is
free with Linux.


231
00:10:45,846 --> 00:10:48,816
So we've got some
pretty aggressive quotas.


232
00:10:49,266 --> 00:10:50,826
That being said we
still need to account


233
00:10:50,886 --> 00:10:53,846
for where data is being used
so that we can talk to you


234
00:10:53,846 --> 00:10:55,516
when we start approaching
those limits.


235
00:10:56,086 --> 00:10:59,086
Data stored in the public
database is accounted


236
00:10:59,086 --> 00:11:00,196
for on the developer's quota.


237
00:11:00,416 --> 00:11:02,226
Date stored in the private
database is accounted


238
00:11:02,226 --> 00:11:03,126
for on the user's quota.


239
00:11:04,256 --> 00:11:07,066
By default data written
into the public database is


240
00:11:07,066 --> 00:11:07,776
world readable.


241
00:11:08,466 --> 00:11:10,796
Data written to the private
database is user readable.


242
00:11:10,986 --> 00:11:13,636
Again it's the user's own data
so they're really the only ones


243
00:11:13,636 --> 00:11:15,586
to have access to it in
the private database.


244
00:11:16,756 --> 00:11:20,816
We recognize that world readable
is not an appropriate permission


245
00:11:20,816 --> 00:11:22,606
for a lot of data in
the public database


246
00:11:22,926 --> 00:11:25,416
so we give you the ability
to edit these permissions


247
00:11:25,416 --> 00:11:27,456
on a record class level.


248
00:11:28,306 --> 00:11:31,126
The mechanism by which you edit
these permissions is something


249
00:11:31,126 --> 00:11:33,376
that we call the
iCloud Dashboard roles.


250
00:11:33,946 --> 00:11:36,286
iCloud Dashboard is the
administrative interface


251
00:11:36,346 --> 00:11:37,306
into CloudKit.


252
00:11:37,926 --> 00:11:39,696
I invite you guys to
come back on Thursday


253
00:11:39,746 --> 00:11:40,536
for the advanced talk.


254
00:11:40,536 --> 00:11:43,246
We're going to go into a lot
of detail about the dashboard.


255
00:11:43,926 --> 00:11:46,446
Suffice it to say there's
an ability to set ACLs


256
00:11:46,726 --> 00:11:48,926
so that a user is
a member of a role


257
00:11:49,376 --> 00:11:52,356
and a role can have
certain enlarged access


258
00:11:52,356 --> 00:11:53,436
to a class of records.


259
00:11:54,246 --> 00:11:56,396
In the private database,
things start


260
00:11:56,396 --> 00:11:58,136
out in lockdown there's
no need to edit them.


261
00:11:58,236 --> 00:12:00,036
The user is the only
one to create data


262
00:12:00,036 --> 00:12:01,966
and the user is the only one
to be able to read that data.


263
00:12:02,506 --> 00:12:04,856
When I say that the user is
the only one to be able to read


264
00:12:04,856 --> 00:12:06,136
that data, I really mean it.


265
00:12:06,226 --> 00:12:08,836
You as the developer
do not have access


266
00:12:08,836 --> 00:12:10,456
into somebody else's
private database.


267
00:12:10,606 --> 00:12:11,536
Their data is their own.


268
00:12:11,536 --> 00:12:14,546
All right so those
are databases.


269
00:12:14,906 --> 00:12:15,896
Let's talk about records.


270
00:12:17,376 --> 00:12:19,946
So, here's our model
that we have so far.


271
00:12:19,946 --> 00:12:22,246
We've got a container, within
containers are databases.


272
00:12:22,246 --> 00:12:24,696
Let's keep going down the rabbit
hole and crack open a database.


273
00:12:25,096 --> 00:12:27,326
Inside the database we see
that it's full of records.


274
00:12:29,086 --> 00:12:32,056
Records are exposed in our
framework as the CKRecord class.


275
00:12:32,196 --> 00:12:35,156
They are the mechanism by which
you've moved structured data


276
00:12:35,226 --> 00:12:36,406
to and from CloudKit.


277
00:12:37,816 --> 00:12:41,536
CKRecords wrap key value pairs.


278
00:12:41,626 --> 00:12:44,316
Lest you think that a CKRecord
is just a glorified dictionary,


279
00:12:44,316 --> 00:12:45,486
there are some additional
attributes


280
00:12:45,486 --> 00:12:47,816
that make it worthwhile
of being in its own class.


281
00:12:47,866 --> 00:12:49,916
To start off with records
have a record type.


282
00:12:50,726 --> 00:12:53,326
If CloudKit is a mechanism by
which you take your object graph


283
00:12:53,326 --> 00:12:55,406
from your application and
move it into CloudKit,


284
00:12:55,816 --> 00:12:57,126
then let's continue
with that analogy.


285
00:12:57,586 --> 00:13:00,416
An instance of an object in
your application is equivalent


286
00:13:00,466 --> 00:13:02,386
to an instance of a CKRecord.


287
00:13:02,936 --> 00:13:05,006
Similarly the class
of the object


288
00:13:05,006 --> 00:13:07,076
in your application
is equivalent


289
00:13:07,076 --> 00:13:08,886
to the record type
of the CKRecord.


290
00:13:11,286 --> 00:13:12,976
Records have a just
in time schema.


291
00:13:13,196 --> 00:13:16,726
You do not need to tell CloudKit
about what your data looks


292
00:13:16,826 --> 00:13:18,866
like before you hand
CloudKit your data.


293
00:13:19,686 --> 00:13:23,076
Hand us your data and
we'll figure it out.


294
00:13:23,966 --> 00:13:27,046
CloudKit, excuse me,
CKRecord also supports a raft


295
00:13:27,046 --> 00:13:28,156
of metadata.


296
00:13:28,466 --> 00:13:30,636
For example, a record
understands


297
00:13:30,636 --> 00:13:32,296
when it was created
and who created it.


298
00:13:32,896 --> 00:13:35,246
It understands when a
record was last modified


299
00:13:35,246 --> 00:13:36,976
and who last modified it.


300
00:13:36,976 --> 00:13:40,016
Lastly a record contains
a notion of a change tag.


301
00:13:40,016 --> 00:13:42,596
A change tag is a
version of a record.


302
00:13:42,596 --> 00:13:45,246
It represents a specific
revision of this record.


303
00:13:45,686 --> 00:13:47,836
It's use so that we can
have a lightweight way


304
00:13:47,836 --> 00:13:50,286
of determining whether or not
a client server had the same


305
00:13:50,286 --> 00:13:51,106
version of a record.


306
00:13:51,746 --> 00:13:55,756
Let's talk a little bit
about record values,


307
00:13:55,756 --> 00:13:57,406
CKRecords wrap key value pairs.


308
00:13:57,806 --> 00:13:59,596
What are the acceptable
value types


309
00:13:59,596 --> 00:14:01,046
that you can put
into a CKRecord?


310
00:14:01,736 --> 00:14:04,646
Well, we've got your usual
suspects, your P list types,


311
00:14:04,646 --> 00:14:07,646
your strings, your numbers,
your datas and your dates.


312
00:14:07,716 --> 00:14:09,476
We think that especially


313
00:14:09,476 --> 00:14:11,636
in the public database
domain location is an


314
00:14:11,636 --> 00:14:12,466
interesting scenario.


315
00:14:12,736 --> 00:14:16,246
So, CLLocation is a native type
that you can set on a CKRecord.


316
00:14:17,686 --> 00:14:20,336
You can set CKReferences and
CKAssets and we're going to go


317
00:14:20,336 --> 00:14:21,596
over what those are
in just a moment.


318
00:14:22,846 --> 00:14:25,206
Lastly any value can
be a single instance.


319
00:14:25,206 --> 00:14:29,006
I can have a string or a date
or it can be a homogenous array.


320
00:14:29,256 --> 00:14:32,536
I can have an array of numbers
or an array of CKAssets.


321
00:14:32,536 --> 00:14:37,686
Let's have a look at
a little bit of code.


322
00:14:38,206 --> 00:14:39,746
Here we see a CKRecord.


323
00:14:39,826 --> 00:14:41,676
The CKRecord Initializer
takes a record type


324
00:14:41,676 --> 00:14:44,256
because that's an invaluable
and necessary piece of a record.


325
00:14:44,976 --> 00:14:47,806
You can set objects
and get objects


326
00:14:47,806 --> 00:14:49,506
from a record using
a dictionary syntax


327
00:14:49,696 --> 00:14:51,836
or a keyed subscripting syntax.


328
00:14:52,486 --> 00:14:55,026
We also give you the ability to
enumerate all keys on a record


329
00:14:55,336 --> 00:14:57,926
so that you can dump the
entire key value pair.


330
00:14:57,926 --> 00:15:00,886
Let's have a look at
a specific example.


331
00:15:01,596 --> 00:15:03,326
Now, throughout this
talk my example is going


332
00:15:03,326 --> 00:15:05,806
to be an application that I've
created for me and my friends.


333
00:15:05,996 --> 00:15:09,016
This application allows us to
create parties and we're going


334
00:15:09,016 --> 00:15:11,546
to stick party records
in the public database.


335
00:15:11,546 --> 00:15:13,776
A party might be a
structured data it's going


336
00:15:13,776 --> 00:15:15,536
to have a summary, a
start date and end date


337
00:15:15,536 --> 00:15:17,846
and it might also have
additional metadata


338
00:15:17,846 --> 00:15:19,016
that we associate with it,


339
00:15:19,256 --> 00:15:20,576
pictures of the party,
et cetera.


340
00:15:21,746 --> 00:15:23,716
So, how do I create
a party record?


341
00:15:24,246 --> 00:15:26,016
Well I create one just
as you might imagine


342
00:15:26,016 --> 00:15:28,176
with a party record type.


343
00:15:28,896 --> 00:15:31,276
I can now set values on
it and I can read values


344
00:15:31,276 --> 00:15:34,536
from it using the dictionary
or key subscripting syntax.


345
00:15:35,226 --> 00:15:35,986
Those are records.


346
00:15:36,756 --> 00:15:38,156
Let's talk about record zones.


347
00:15:38,596 --> 00:15:41,386
This is the model that we've
just presented and it was kind


348
00:15:41,386 --> 00:15:44,466
of a lie but it was a
useful lie at the time.


349
00:15:45,276 --> 00:15:51,236
So, records don't exist by
themselves just as objects


350
00:15:51,236 --> 00:15:52,946
in your application don't
exist by themselves.


351
00:15:52,946 --> 00:15:54,756
There's going to be a
natural grouping of objects


352
00:15:54,756 --> 00:15:55,656
within your application.


353
00:15:56,046 --> 00:15:58,516
Similarly we want a way


354
00:15:58,516 --> 00:16:00,576
to express this grouping
in CloudKit.


355
00:16:00,756 --> 00:16:03,926
Fundamentally we're trying
via CloudKit to take as much


356
00:16:03,926 --> 00:16:06,336
of your knowledge about your
object graph and reflect


357
00:16:06,336 --> 00:16:07,096
that up to the server.


358
00:16:08,066 --> 00:16:10,466
So the way that we group
records is via something


359
00:16:10,466 --> 00:16:11,646
that we call a record zone.


360
00:16:12,566 --> 00:16:14,606
There can be multiple
records within a record zone


361
00:16:15,246 --> 00:16:17,916
and there can be multiple
record zones within a database.


362
00:16:18,666 --> 00:16:21,046
Every database has a
default record zone.


363
00:16:21,366 --> 00:16:24,486
Some databases support
additional custom record zones.


364
00:16:25,386 --> 00:16:27,686
Record zones are the
default granularity


365
00:16:27,686 --> 00:16:28,296
at which you're going


366
00:16:28,296 --> 00:16:30,426
to do atomic commits
and change tracking.


367
00:16:31,016 --> 00:16:32,716
If either of those sound
interesting to you,


368
00:16:32,716 --> 00:16:34,596
I invite you back on Thursday
for the advanced talk.


369
00:16:34,596 --> 00:16:37,406
We're going to go over
a whole bunch of that.


370
00:16:37,616 --> 00:16:38,996
So, those were record zones.


371
00:16:38,996 --> 00:16:40,496
Let's talk about
RecordIDentifiers.


372
00:16:41,366 --> 00:16:45,846
RecordIDentifiers, let's get
the code up there, are a tuple.


373
00:16:45,846 --> 00:16:48,306
They represent both a
client provided record name


374
00:16:48,876 --> 00:16:51,696
and also the zone in which
that record name exists.


375
00:16:52,676 --> 00:16:54,046
So what are their
characteristics?


376
00:16:54,556 --> 00:16:56,946
Number one they are
created by the client.


377
00:16:57,306 --> 00:17:01,246
You get to specify the ID,
the record name of the record,


378
00:17:02,456 --> 00:17:04,695
but because we are
coupling this record name,


379
00:17:04,826 --> 00:17:08,596
which is scoped per record
zone, along with a reference


380
00:17:08,656 --> 00:17:09,996
to the owning record zone,


381
00:17:10,455 --> 00:17:13,236
they become a fully normalized
representation of the record.


382
00:17:13,326 --> 00:17:15,256
It's the full path to it.


383
00:17:15,256 --> 00:17:19,695
We think that it's going to be
fairly common for you to try


384
00:17:19,695 --> 00:17:22,246
and bridge an external
dataset into CloudKit.


385
00:17:22,596 --> 00:17:25,746
If you're doing so and if your
external dataset has a unique


386
00:17:25,746 --> 00:17:30,716
key, using that unique key
as the CKRecordID allows you


387
00:17:30,716 --> 00:17:32,956
to have a foreign key back
into your external dataset.


388
00:17:33,236 --> 00:17:34,436
Totally an approved usage.


389
00:17:35,646 --> 00:17:37,186
Let's have a look at some code.


390
00:17:37,616 --> 00:17:39,626
Here we are, you know,
creating a record,


391
00:17:39,626 --> 00:17:40,446
you've seen that already,


392
00:17:41,076 --> 00:17:43,236
and we've got multiple
initializers for CKRecord.


393
00:17:43,366 --> 00:17:45,126
You can either choose
to provide us a RecordID


394
00:17:45,126 --> 00:17:46,106
or you can choose not to.


395
00:17:46,236 --> 00:17:48,216
If you choose not to
provide a RecordID,


396
00:17:48,466 --> 00:17:51,206
we're going to assign a random
view UUID to the record.


397
00:17:52,206 --> 00:17:55,556
Also note here that when I
created my RecordID I chose not


398
00:17:55,556 --> 00:17:56,726
to give it a zone.


399
00:17:57,186 --> 00:17:59,946
Throughout CloudKit's
API if you choose not


400
00:17:59,946 --> 00:18:01,556
to give us a record zone,
we're going to assume


401
00:18:01,556 --> 00:18:02,856
that you meant the default zone.


402
00:18:03,156 --> 00:18:06,346
So here, I am creating
a RecordID


403
00:18:06,346 --> 00:18:08,306
with the name well-known
party that exists


404
00:18:08,306 --> 00:18:09,216
within the default zone.


405
00:18:10,316 --> 00:18:11,526
So those are RecordIDs.


406
00:18:12,066 --> 00:18:13,406
Now let's talk about references.


407
00:18:14,126 --> 00:18:16,386
Just as there's a natural
grouping of records that we want


408
00:18:16,386 --> 00:18:18,976
to expose via a record
zone, there's also going


409
00:18:18,976 --> 00:18:20,996
to be a natural relationship
between objects.


410
00:18:21,746 --> 00:18:24,776
For example, let's say that in
addition to being able to write


411
00:18:24,776 --> 00:18:27,156
up parties I can assign
different clowns to parties


412
00:18:27,186 --> 00:18:28,466
because what is the
point of a party


413
00:18:28,466 --> 00:18:29,806
if you don't have a few clowns?


414
00:18:30,206 --> 00:18:31,916
So, I want some way


415
00:18:32,276 --> 00:18:36,146
of representing the object
relationship that I have


416
00:18:36,146 --> 00:18:39,056
between parties and clowns up
to the server and the way we do


417
00:18:39,056 --> 00:18:40,946
that is via something
that we call references.


418
00:18:41,756 --> 00:18:45,726
Now you'll note here that in
this contrived example parties


419
00:18:45,776 --> 00:18:46,636
own clowns.


420
00:18:46,636 --> 00:18:49,336
That is we've got a parent/child
relationship with the party


421
00:18:49,336 --> 00:18:50,896
as a parent and the
clown as a child


422
00:18:50,896 --> 00:18:54,276
and that the reference
goes from the child object,


423
00:18:54,276 --> 00:18:56,446
from the clown, up
to its parent object.


424
00:18:56,816 --> 00:18:58,846
We call that a back reference.


425
00:19:00,316 --> 00:19:03,816
References are exposing API
as the CKReference class.


426
00:19:03,816 --> 00:19:05,516
They are a way of letting
the server understand the


427
00:19:05,516 --> 00:19:06,916
relationship between records.


428
00:19:07,516 --> 00:19:09,086
When the server understands
the relationship


429
00:19:09,086 --> 00:19:11,166
between records it can do
very interesting things


430
00:19:11,236 --> 00:19:12,576
such as cascade delete.


431
00:19:13,216 --> 00:19:16,266
If the server notices that
you've deleted a record


432
00:19:16,266 --> 00:19:19,676
and that record is the parent in
a parent and child relationship,


433
00:19:20,196 --> 00:19:21,896
the server will automatically
go ahead


434
00:19:21,896 --> 00:19:24,556
and cascade delete all
the children of that item.


435
00:19:25,116 --> 00:19:28,086
With any database
the scope and scale


436
00:19:28,146 --> 00:19:31,396
of CloudKit dangling pointers
are going to become a necessary


437
00:19:31,396 --> 00:19:35,326
and inconvenient truth
of your use of CloudKit.


438
00:19:35,916 --> 00:19:38,256
By the time you fetch a record
and you read a reference,


439
00:19:38,386 --> 00:19:40,246
then you go and fetch the
target of that reference,


440
00:19:40,246 --> 00:19:41,536
the target may not exist.


441
00:19:41,976 --> 00:19:44,746
So it's important that you're
code is resilient to this.


442
00:19:46,156 --> 00:19:49,076
Again, as I mentioned, we
prefer back references.


443
00:19:49,076 --> 00:19:52,046
It's not a requirement, but it's
more efficient if references go


444
00:19:52,046 --> 00:19:54,126
from child objects
to parent objects.


445
00:19:54,256 --> 00:19:55,836
This is the tip of the iceberg


446
00:19:55,836 --> 00:19:58,766
in a very large topic
called data modeling


447
00:19:59,066 --> 00:20:00,606
and if you come back
on Thursday we're going


448
00:20:00,606 --> 00:20:02,526
to tell you a whole bunch about
data modeling in CloudKit.


449
00:20:03,296 --> 00:20:05,746
Let's have a look at some code.


450
00:20:06,766 --> 00:20:11,006
Here we see creating a reference
between two CKRecord instances


451
00:20:11,006 --> 00:20:14,316
that I have in memory,
but it's not necessary


452
00:20:14,316 --> 00:20:16,516
that I have the target
of a reference in memory.


453
00:20:17,146 --> 00:20:19,986
I can make a reference
that points at a RecordID.


454
00:20:20,656 --> 00:20:23,096
This allows me to refer to a
record that I've got, you know,


455
00:20:23,236 --> 00:20:25,326
reason to believe
exists up on the server.


456
00:20:26,116 --> 00:20:28,636
If I were to save this record
and the target didn't exist,


457
00:20:28,636 --> 00:20:31,706
I'd actually be creating a
dangling pointer and that's okay


458
00:20:31,706 --> 00:20:33,926
because the code you're going
to write is going to support


459
00:20:34,076 --> 00:20:36,106
and be resilient in the
face of dangling pointers.


460
00:20:37,466 --> 00:20:39,976
So those are references now
let's talk about assets.


461
00:20:40,236 --> 00:20:43,716
Here we have our
model again just


462
00:20:43,716 --> 00:20:45,466
to refresh our container
database record


463
00:20:46,366 --> 00:20:50,146
and now let's take the idea
that I want to write a record,


464
00:20:50,146 --> 00:20:53,056
I want to write a party record
up to the server, but let's say


465
00:20:53,056 --> 00:20:55,626
that I want to associate a
large file with that record.


466
00:20:55,746 --> 00:20:57,036
Let's say, for example,
that we're going


467
00:20:57,036 --> 00:20:59,496
to have a get together after
the presentation and I'm going


468
00:20:59,496 --> 00:21:01,316
to read you a screen play
that I've been working on.


469
00:21:02,266 --> 00:21:03,666
Now I know, I understand


470
00:21:03,666 --> 00:21:04,906
that there's different
characteristics


471
00:21:04,906 --> 00:21:06,186
between these different datas.


472
00:21:06,246 --> 00:21:09,156
I understand that the record
about the party is structured,


473
00:21:09,306 --> 00:21:11,136
you know, it's got a summary,
it's got a start date,


474
00:21:11,136 --> 00:21:14,636
it's got an end date and, you
know, just innately I believe


475
00:21:14,636 --> 00:21:15,376
that I want the server


476
00:21:15,376 --> 00:21:17,776
to understand those
bits about the record.


477
00:21:18,126 --> 00:21:20,826
If you contrast that to
the screen play, well,


478
00:21:20,826 --> 00:21:23,016
the screen play is just
essentially a bag of bits.


479
00:21:23,266 --> 00:21:24,826
I don't feel any real need


480
00:21:24,826 --> 00:21:26,556
to tell the server how
my screen play breaks


481
00:21:26,556 --> 00:21:29,266
down into amazing acts and,
you know, dashing scenes,


482
00:21:29,916 --> 00:21:32,876
but I do know that
I want to treat them


483
00:21:32,876 --> 00:21:33,836
as just an opaque bag.


484
00:21:34,296 --> 00:21:35,646
So how do we solve this?


485
00:21:35,646 --> 00:21:38,256
Well, we're going to
solve this and we're going


486
00:21:38,256 --> 00:21:40,396
to solve the fact that data
has different characteristics


487
00:21:40,396 --> 00:21:42,086
like this in two different ways.


488
00:21:42,836 --> 00:21:44,716
Up on the server we're
going to introduce a notion


489
00:21:44,716 --> 00:21:46,186
that we call bulk storage.


490
00:21:46,836 --> 00:21:48,716
As you might expect,
bulk storage is great


491
00:21:48,716 --> 00:21:49,926
for storing bulk data.


492
00:21:51,176 --> 00:21:54,966
Similarly on the client
you're going to tell CloudKit


493
00:21:54,966 --> 00:21:56,746
about the different
characteristics of your data


494
00:21:57,036 --> 00:21:58,946
by treating some
of it as a CKRecord


495
00:21:59,296 --> 00:22:01,146
and other bits of
it as a CKAsset.


496
00:22:01,436 --> 00:22:04,296
A CKAsset is the representation
of this bag of bits.


497
00:22:04,656 --> 00:22:06,766
Now when you ask CloudKit
to save this record,


498
00:22:07,246 --> 00:22:08,326
the appropriate bits
are going to go


499
00:22:08,326 --> 00:22:09,386
in the appropriate database.


500
00:22:09,476 --> 00:22:11,186
Structured data in
public database,


501
00:22:11,246 --> 00:22:12,846
bulk data in bulk storage.


502
00:22:13,646 --> 00:22:15,136
So assets.


503
00:22:15,396 --> 00:22:19,466
Assets are exposed in our
framework as the CKAsset class.


504
00:22:19,526 --> 00:22:21,226
They represent large,
unstructured data.


505
00:22:22,196 --> 00:22:24,396
Because you don't necessarily
want large unstructured data


506
00:22:24,396 --> 00:22:26,826
in memory, the way you
communicate assets to


507
00:22:26,826 --> 00:22:29,156
and from CloudKit is
via files on disks.


508
00:22:30,506 --> 00:22:32,266
Assets are owned by records.


509
00:22:32,376 --> 00:22:33,746
This gives us a nice
tight coupling


510
00:22:33,746 --> 00:22:34,896
between a record and an asset.


511
00:22:36,186 --> 00:22:39,596
What this allows the server to
do is garbage collect assets.


512
00:22:40,006 --> 00:22:42,826
Even though that we're storing
this data in two separate areas


513
00:22:43,216 --> 00:22:45,866
when the server detects a delete
for a record it can go ahead


514
00:22:45,866 --> 00:22:48,676
and clean up any assets that
were owned by that record.


515
00:22:49,936 --> 00:22:53,336
Lastly because we expect CKAsset
to be large, opaque data,


516
00:22:53,636 --> 00:22:56,756
we go through some great pains
to try and move that data to


517
00:22:56,756 --> 00:22:58,516
and from the server as
efficiently as possible.


518
00:22:58,676 --> 00:23:01,316
This is all sort of inside
of CloudKit but we're going


519
00:23:01,316 --> 00:23:03,926
to send only the bits
that the minimal amount


520
00:23:03,926 --> 00:23:04,676
of bits that we can.


521
00:23:05,386 --> 00:23:07,496
Let's have a look at some code.


522
00:23:08,566 --> 00:23:11,876
Here I'm creating a
CKAsset based on a file URL


523
00:23:11,876 --> 00:23:14,296
to my screen play
on disk and just


524
00:23:14,296 --> 00:23:18,076
like any other CKRecord value
supporting class I'm setting it


525
00:23:18,076 --> 00:23:19,296
on CKRecord.


526
00:23:19,986 --> 00:23:22,856
So these are the fundamental
objects in CloudKit.


527
00:23:23,266 --> 00:23:24,806
The first thing you
talk to is a container.


528
00:23:25,176 --> 00:23:27,056
Within a container are
two different databases.


529
00:23:27,516 --> 00:23:30,196
Databases contains
records, records are wrapped


530
00:23:30,196 --> 00:23:31,746
and grouped within record zones.


531
00:23:32,136 --> 00:23:34,666
You identify a record
via a RecordIDentifier


532
00:23:35,286 --> 00:23:39,086
and records are related to
one another via references


533
00:23:39,086 --> 00:23:41,016
and large bulk data
is transmitted to


534
00:23:41,016 --> 00:23:43,356
and from CloudKit via CKAssets.


535
00:23:45,286 --> 00:23:46,216
All right you guys made it


536
00:23:46,216 --> 00:23:48,086
through the nouns now
let's get into the verbs.


537
00:23:50,486 --> 00:23:53,206
[Laughter] CloudKit we
offer two different APIs


538
00:23:53,206 --> 00:23:54,176
for using CloudKit.


539
00:23:54,416 --> 00:23:56,986
We call them the operational
API and the convenience API.


540
00:23:57,786 --> 00:24:00,086
The operational API
has every single bell


541
00:24:00,086 --> 00:24:01,536
and whistle you might
care about.


542
00:24:01,536 --> 00:24:07,806
In some cases, you're going to
want to tweak every single bell


543
00:24:07,806 --> 00:24:09,896
and whistle to fit your
application's model,


544
00:24:10,926 --> 00:24:14,246
but not every application really
wants to do all of this tweaking


545
00:24:14,406 --> 00:24:16,406
and not every application
has enough knowledge


546
00:24:16,406 --> 00:24:17,786
to set these bits correctly.


547
00:24:18,186 --> 00:24:20,206
Sometimes you want to let
the framework make some


548
00:24:20,206 --> 00:24:22,596
of these decisions
on your behalf.


549
00:24:22,596 --> 00:24:25,536
So, we offer the
convenience API.


550
00:24:25,876 --> 00:24:27,946
It's convenient, it's
going to be what you want


551
00:24:27,946 --> 00:24:30,206
to start off playing with when
you start looking at CloudKit.


552
00:24:30,316 --> 00:24:32,766
For many uses of
CloudKit it's all


553
00:24:32,766 --> 00:24:35,396
that you're going
to need to touch.


554
00:24:35,576 --> 00:24:37,696
So quickly we're going to go
over how you save a record


555
00:24:37,696 --> 00:24:40,036
in the convenience of API,
how you fetch a record


556
00:24:40,036 --> 00:24:42,726
from the server via
the convenience of API


557
00:24:42,726 --> 00:24:45,966
and how you can take a
fetched record, modify it


558
00:24:45,966 --> 00:24:47,386
and save it back
up to the server.


559
00:24:48,526 --> 00:24:49,986
Let's start off with
saving a record.


560
00:24:52,876 --> 00:24:53,996
Here I am creating a record.


561
00:24:53,996 --> 00:24:55,926
You guys are now very
well familiar with this.


562
00:24:57,566 --> 00:24:59,196
When I want to save the
record, I have to choose


563
00:24:59,196 --> 00:25:02,176
which database I
want to save it into.


564
00:25:02,176 --> 00:25:03,206
Here I'm going to save the data


565
00:25:03,206 --> 00:25:05,536
into the public database
and how do I do that?


566
00:25:06,096 --> 00:25:08,896
Well, I call the save record
with completion handler method.


567
00:25:08,896 --> 00:25:12,136
Now I want you guys to
note three separate things


568
00:25:12,136 --> 00:25:13,686
about this code right here.


569
00:25:14,306 --> 00:25:15,856
First of all it's very simple.


570
00:25:16,266 --> 00:25:17,946
You guys aren't providing
a lot of options,


571
00:25:17,946 --> 00:25:19,936
you're delegating a lot
of the bells and whistles


572
00:25:19,936 --> 00:25:21,536
like how important is this,


573
00:25:21,596 --> 00:25:23,326
what interface should
I send this data over,


574
00:25:23,736 --> 00:25:25,536
you're delegating those
choices off to CloudKit.


575
00:25:26,576 --> 00:25:28,616
Second, it's asynchronous.


576
00:25:28,946 --> 00:25:30,056
As Olivier mentioned,


577
00:25:30,056 --> 00:25:32,536
the CloudKit does not
have local persistence.


578
00:25:32,616 --> 00:25:33,996
We are a transport technology.


579
00:25:34,466 --> 00:25:36,136
We're going to transport
your data up to the server


580
00:25:36,136 --> 00:25:38,196
and we'll store it on the server
and we'll transport it back


581
00:25:38,196 --> 00:25:39,556
down to other clients.


582
00:25:40,316 --> 00:25:43,626
So when you save a record
via CloudKit, we are going


583
00:25:43,626 --> 00:25:45,716
to attempt to save that
record directly to the server.


584
00:25:46,186 --> 00:25:48,916
If it fails, we're going to tell
you about that immediately or,


585
00:25:49,016 --> 00:25:50,086
you know, as quickly as we can.


586
00:25:51,396 --> 00:25:53,526
Now we don't want
to block threads


587
00:25:53,616 --> 00:25:55,006
and we don't want you
to block the user.


588
00:25:55,226 --> 00:25:56,816
So we don't want to make
this a synchronous call.


589
00:25:57,256 --> 00:25:59,006
So here we've got an
asynchronous call.


590
00:26:00,366 --> 00:26:02,206
Now the third thing
I want you to note is


591
00:26:02,206 --> 00:26:05,236
that even though is a very
simple method we do provide an


592
00:26:05,236 --> 00:26:06,696
error as part of the call back.


593
00:26:07,136 --> 00:26:09,516
Now if you've been
to WWC in the past


594
00:26:09,516 --> 00:26:11,036
or if you've watched
any presentations,


595
00:26:11,036 --> 00:26:12,516
you've seen something
that looks like this.


596
00:26:12,516 --> 00:26:14,096
We've got an Apple
developer up here


597
00:26:14,096 --> 00:26:16,976
and the Apple developer says
you need to handle errors


598
00:26:16,976 --> 00:26:18,096
that return from our framework.


599
00:26:18,096 --> 00:26:21,496
Now, I'm not calling them
liars it's true you do need


600
00:26:21,496 --> 00:26:23,216
to handle errors
returned from frameworks.


601
00:26:23,216 --> 00:26:26,386
In many applications, it's
the difference between a good


602
00:26:26,386 --> 00:26:28,506
and functioning application
and a great application.


603
00:26:29,616 --> 00:26:30,846
CloudKit is a little
bit different.


604
00:26:31,366 --> 00:26:33,276
CloudKit by its very
nature is going


605
00:26:33,276 --> 00:26:34,506
to be talking over the network.


606
00:26:34,756 --> 00:26:36,196
Networks are inherently
lossy [phonetic].


607
00:26:36,516 --> 00:26:38,926
Phones like to fall off
the network all the time.


608
00:26:38,926 --> 00:26:42,046
So, in CloudKit, the difference
between handling an error


609
00:26:42,046 --> 00:26:44,376
versus not handling an error
is really the difference


610
00:26:44,376 --> 00:26:46,606
between a functional and
a non-functional app.


611
00:26:47,106 --> 00:26:49,026
Error handling has got to
be one of the first things


612
00:26:49,026 --> 00:26:50,936
that you look at when
you start using CloudKit.


613
00:26:50,936 --> 00:26:53,416
I'm going to be a little bit
glib throughout the slides here


614
00:26:53,416 --> 00:26:54,976
but every time you
see a comment imagine


615
00:26:54,976 --> 00:26:57,146
that you're seeing just some
really nice error handling.


616
00:26:57,876 --> 00:27:02,486
[Laughter] So let's talk about
now that we've saved a record


617
00:27:02,486 --> 00:27:04,146
up to the server, how do
we fetch a record back


618
00:27:04,146 --> 00:27:04,986
down from the server?


619
00:27:05,756 --> 00:27:09,646
I'm going to start by
deciding which database I want


620
00:27:09,646 --> 00:27:10,486
to fetch a record from.


621
00:27:10,556 --> 00:27:13,666
I'm then going to construct
a RecordID, the identifier


622
00:27:13,666 --> 00:27:16,526
of the record I care
to fetch down.


623
00:27:16,526 --> 00:27:19,456
Here I've gotten this name
either via some side channel


624
00:27:19,456 --> 00:27:21,136
or something that's built
into my application.


625
00:27:22,586 --> 00:27:25,396
I then can ask the database
to fetch a record with ID


626
00:27:25,396 --> 00:27:26,226
with completion handler.


627
00:27:26,826 --> 00:27:30,296
Again, asynchronous, simple,
amazing error handling.


628
00:27:32,276 --> 00:27:35,026
Once I fetched a record let's
get that code back up here,


629
00:27:35,546 --> 00:27:38,886
I want you to note that the
successful return value is an


630
00:27:38,886 --> 00:27:40,646
actual CKRecord instance


631
00:27:40,646 --> 00:27:43,016
and this is a live
honest to God CKRecord.


632
00:27:43,536 --> 00:27:45,726
Let's say I'm having so much
fun at this party I pulled


633
00:27:46,126 --> 00:27:47,586
that I want it to last
a little bit longer.


634
00:27:47,776 --> 00:27:50,346
I can take a record off of it
and I can bump out the end date


635
00:27:50,346 --> 00:27:52,486
by half an hour and I
can set that record,


636
00:27:52,486 --> 00:27:53,816
that value back on the record.


637
00:27:54,656 --> 00:27:57,476
Once I've done that I can take
my CKRecord instance and just


638
00:27:57,476 --> 00:27:59,776
like one that I've created
locally I can turn around


639
00:27:59,776 --> 00:28:02,506
and save it back up
to the database again


640
00:28:02,506 --> 00:28:03,456
with amazing error handling.


641
00:28:04,496 --> 00:28:07,586
All right so that's
the convenience API,


642
00:28:07,586 --> 00:28:09,396
the initial typical flow
that you're going to go


643
00:28:09,446 --> 00:28:10,446
through when talking
with CloudKit.


644
00:28:10,446 --> 00:28:12,586
You're going to be saving
records, fetching records


645
00:28:12,996 --> 00:28:16,086
and taking those records that
you fetched modifying them


646
00:28:16,236 --> 00:28:18,096
and putting them back
up to the server.


647
00:28:19,096 --> 00:28:21,926
So now let's say my party
application starts becoming


648
00:28:21,926 --> 00:28:24,056
really popular and it's grown.


649
00:28:24,056 --> 00:28:27,476
My user base is no longer me and
my friends but it's all of you.


650
00:28:27,476 --> 00:28:29,906
Everyone is really excited
about joining into the parties.


651
00:28:30,586 --> 00:28:32,216
What are some of the problems
I'm going to run into?


652
00:28:32,986 --> 00:28:35,506
Well, let's assume
that when I started


653
00:28:35,506 --> 00:28:37,306
out I was a relatively
naive developer


654
00:28:37,566 --> 00:28:40,276
and because the developer on
stage said CloudKit is all


655
00:28:40,276 --> 00:28:41,856
about taking your object
graph and moving it to


656
00:28:41,856 --> 00:28:43,956
and from the cloud,
that's exactly what I did.


657
00:28:43,956 --> 00:28:45,586
I had the one to one mapping.


658
00:28:45,806 --> 00:28:47,766
My objects went up to the Cloud


659
00:28:48,016 --> 00:28:50,546
and on every client I would
fetch the entire cloud state


660
00:28:50,546 --> 00:28:52,056
and that would become
my object graph.


661
00:28:52,486 --> 00:28:53,996
What are some problems
we're going to run into?


662
00:28:54,876 --> 00:28:57,776
Well, at that point we've got
big data and a very tiny phone.


663
00:28:58,626 --> 00:29:00,776
The more popular my app
becomes the more data


664
00:29:00,776 --> 00:29:03,876
on the database the less
reasonable it is to have a cache


665
00:29:03,876 --> 00:29:06,406
of that entire data
locally on my device.


666
00:29:06,816 --> 00:29:08,016
So how are we going
to solve this.


667
00:29:08,016 --> 00:29:10,186
Let's think about
what we want to do.


668
00:29:10,776 --> 00:29:13,456
We want to keep the large
data up in the Cloud.


669
00:29:13,606 --> 00:29:15,726
The Cloud is very good at
storing large datasets.


670
00:29:16,366 --> 00:29:18,676
My client wants to view
a slice of that data.


671
00:29:19,276 --> 00:29:21,556
Because I'm writing an
application for my users


672
00:29:21,556 --> 00:29:24,666
and my users have their own
preferences, I want each client


673
00:29:24,666 --> 00:29:26,716
to be able to view a
different slice of that data


674
00:29:26,916 --> 00:29:28,406
and each individual
client might want


675
00:29:28,406 --> 00:29:29,926
to change its view of that data.


676
00:29:30,776 --> 00:29:34,246
The way we saw this is via
something that we call queries.


677
00:29:35,176 --> 00:29:37,616
Clients use queries to
focus their viewpoint


678
00:29:38,076 --> 00:29:40,986
so that they can see a small
section of a large dataset


679
00:29:41,076 --> 00:29:42,586
that exists up on the cloud.


680
00:29:43,556 --> 00:29:45,506
So what is a query?


681
00:29:45,506 --> 00:29:47,606
As you might imagine,
it's exposed in our API


682
00:29:47,606 --> 00:29:49,536
as the CK query class.


683
00:29:50,666 --> 00:29:52,866
A query combines three
different things.


684
00:29:52,866 --> 00:29:54,706
It combines a record
type, a predicate


685
00:29:55,096 --> 00:29:56,796
and optionally a
sort descriptor.


686
00:29:57,986 --> 00:30:00,126
If you've used NS
predicate in the past,


687
00:30:00,126 --> 00:30:02,046
you know that NS predicate
is very expressive.


688
00:30:03,036 --> 00:30:04,986
CloudKit supports
most of NS predicate.


689
00:30:05,226 --> 00:30:08,746
We document the parts that we do
and if you hand us a predicate


690
00:30:08,746 --> 00:30:10,576
that we don't understand, we're
going to throw an exception.


691
00:30:10,716 --> 00:30:12,406
So you're going to learn
pretty quickly which ones are


692
00:30:12,406 --> 00:30:13,046
and are not supported.


693
00:30:13,046 --> 00:30:13,976
Let's have a look at
some that are supported.


694
00:30:14,126 --> 00:30:19,476
Here we see a predicate
that would match records


695
00:30:19,706 --> 00:30:21,936
where name is equal to
a value I had in memory.


696
00:30:23,376 --> 00:30:25,636
Predicates allow you
to use dynamic keys


697
00:30:25,636 --> 00:30:28,126
so that I don't have to know
the key name at compile time.


698
00:30:29,166 --> 00:30:31,386
We can do relative
ordering comparisons


699
00:30:31,386 --> 00:30:32,856
as opposed to strict equalities.


700
00:30:33,436 --> 00:30:36,846
We mentioned that location
is an interesting aspect


701
00:30:36,846 --> 00:30:37,836
in the public database.


702
00:30:37,906 --> 00:30:40,656
So you can query with
location as a filter.


703
00:30:41,136 --> 00:30:43,306
This is every location
within a 100 meters


704
00:30:43,306 --> 00:30:44,726
of where we're standing
here in Moscone.


705
00:30:46,716 --> 00:30:48,736
CloudKit supports a
tokenization search.


706
00:30:49,096 --> 00:30:52,616
So, what this predicate is going
to do is it's going to tokenize


707
00:30:52,706 --> 00:30:55,376
that string after session
and it's going to come


708
00:30:55,376 --> 00:30:57,906
up with two different
tokens, after and session.


709
00:30:58,726 --> 00:31:00,466
This predicate will
match any record


710
00:31:00,466 --> 00:31:03,106
that has those two
tokens as values.


711
00:31:03,806 --> 00:31:05,996
These two tokens don't
need to exist side by side,


712
00:31:06,076 --> 00:31:08,176
they don't even need to exist
in the same key value pair,


713
00:31:08,736 --> 00:31:10,846
but so long as the
record has the token after


714
00:31:11,096 --> 00:31:13,726
and the record has the token
session the record will be


715
00:31:13,726 --> 00:31:14,226
a match.


716
00:31:15,826 --> 00:31:19,656
Lastly, CloudKit supports
compound predicates joined using


717
00:31:19,656 --> 00:31:20,676
the and operator.


718
00:31:21,216 --> 00:31:23,086
Here we see a predicate
that does that.


719
00:31:25,406 --> 00:31:26,826
Here we see the creation
of a query


720
00:31:27,086 --> 00:31:30,846
and as we mentioned it's
combining both a record type


721
00:31:30,846 --> 00:31:31,426
and a predicate.


722
00:31:32,956 --> 00:31:35,076
How do I perform queries
after I've created them?


723
00:31:36,186 --> 00:31:39,176
Well, just like saving records
performing a query is going


724
00:31:39,176 --> 00:31:41,186
to be a database
specific operation.


725
00:31:41,396 --> 00:31:42,866
So I'm going to choose
the database


726
00:31:42,866 --> 00:31:45,646
on which I want to
perform a query.


727
00:31:45,756 --> 00:31:48,966
Even in the simple API and the
convenience API we give you the


728
00:31:48,966 --> 00:31:52,096
ability to restrict these
queries by record zones.


729
00:31:52,176 --> 00:31:54,166
You see here that we're
not choosing to pass


730
00:31:54,166 --> 00:31:55,056
in a record zone filter.


731
00:31:55,506 --> 00:31:56,886
So this query is going to search


732
00:31:56,886 --> 00:31:58,436
across the entire
public database.


733
00:31:58,946 --> 00:32:01,156
Let's have a look
at what happens


734
00:32:01,226 --> 00:32:02,796
in the completion handler.


735
00:32:03,026 --> 00:32:05,306
First, of course,
amazing error handling.


736
00:32:05,736 --> 00:32:08,146
Second, if we don't have errors,


737
00:32:08,146 --> 00:32:09,456
let's have a look
at the results.


738
00:32:09,456 --> 00:32:12,736
You'll see here that the results
are actually CKRecord instances.


739
00:32:12,736 --> 00:32:13,936
These are live objects.


740
00:32:14,426 --> 00:32:16,506
If I wanted to, I could
pull data off of them,


741
00:32:16,506 --> 00:32:18,886
I could set data on them
and I could even choose


742
00:32:18,886 --> 00:32:20,226
to save them back to the server.


743
00:32:20,226 --> 00:32:26,446
So a way to think about queries
is that queries are polls


744
00:32:26,446 --> 00:32:28,446
and polls are great
in some scenarios.


745
00:32:28,826 --> 00:32:31,036
They're great for slicing
through large datasets.


746
00:32:31,286 --> 00:32:33,666
If your application wants to
start up and, for example,


747
00:32:33,666 --> 00:32:36,566
show all the parties, the top
10 parties that are near me,


748
00:32:36,986 --> 00:32:40,516
a query is absolutely the way
to go, but there's other things


749
00:32:40,516 --> 00:32:41,726
that you might be
tempted to use a query


750
00:32:41,726 --> 00:32:43,116
for that are not perfect.


751
00:32:43,116 --> 00:32:46,806
If you find yourself issuing
the same query over and over


752
00:32:46,806 --> 00:32:49,516
and over again and you're
getting back a static,


753
00:32:49,516 --> 00:32:53,116
a mostly same data
result set, well,


754
00:32:53,116 --> 00:32:55,866
then you've got a large
mostly static dataset


755
00:32:55,866 --> 00:32:58,606
and queries are bad for that
use case for a few reasons.


756
00:32:59,336 --> 00:33:00,506
They're bad for battery life.


757
00:33:00,636 --> 00:33:03,106
You have to constantly
wake the device up, poll,


758
00:33:03,106 --> 00:33:05,986
run the same query and get back
more or less the same results.


759
00:33:06,886 --> 00:33:08,026
They're bad for network traffic.


760
00:33:08,236 --> 00:33:09,956
All those questions
go to the server


761
00:33:09,956 --> 00:33:11,436
and if they're not
pulling down new


762
00:33:11,436 --> 00:33:13,706
and interesting data,
why do we bother?


763
00:33:14,486 --> 00:33:17,036
They are also bad for
the user experience.


764
00:33:17,286 --> 00:33:20,506
By definition, you're only
going to learn about new results


765
00:33:20,506 --> 00:33:24,056
on the period of how
often you're polling.


766
00:33:24,726 --> 00:33:26,796
Users nowadays have
come to expect push.


767
00:33:27,816 --> 00:33:30,386
So as opposed to using
a client-generated query


768
00:33:30,386 --> 00:33:33,146
in the scenario, what you really
want is you want the server


769
00:33:33,146 --> 00:33:34,616
to be running the
query on your behalf.


770
00:33:35,466 --> 00:33:37,276
You want the server to be
running the query on your behalf


771
00:33:37,366 --> 00:33:39,306
in the background and
you want that to happen


772
00:33:39,306 --> 00:33:41,756
after every single record
save whether it was you


773
00:33:41,756 --> 00:33:43,336
or somebody else that
saved the record.


774
00:33:44,146 --> 00:33:46,136
Lastly, of course,
you want pushes


775
00:33:46,136 --> 00:33:47,976
when the results have changes.


776
00:33:48,816 --> 00:33:51,086
Well, we've given you this and
we call that subscriptions.


777
00:33:51,736 --> 00:33:51,816
Yay.


778
00:33:52,516 --> 00:33:58,986
[ Applause ]


779
00:33:59,486 --> 00:34:01,436
So subscriptions are
exposed in our API


780
00:34:01,436 --> 00:34:03,516
as the CKSubscription class.


781
00:34:03,986 --> 00:34:07,106
They combine a record
type, a predicate and push.


782
00:34:08,186 --> 00:34:10,496
Push is delivered via
the Apple Push Service.


783
00:34:10,496 --> 00:34:12,676
If you've used APS in the
past, you're largely familiar


784
00:34:12,676 --> 00:34:16,116
with this, but note CloudKit
pushes are slightly augmented.


785
00:34:16,346 --> 00:34:18,476
They contain CloudKit
specific information


786
00:34:18,746 --> 00:34:20,246
about what caused
the push to happen.


787
00:34:20,576 --> 00:34:21,985
Let's have a look at an example.


788
00:34:23,726 --> 00:34:26,516
Here we have a phone and that
phone is interested in parties


789
00:34:26,516 --> 00:34:27,985
that are going to be
happening in the future.


790
00:34:28,936 --> 00:34:31,866
This phone when it sees that
happening wants to be alerted


791
00:34:31,866 --> 00:34:33,335
with a push that
says party time.


792
00:34:34,005 --> 00:34:36,426
The phone is going to go ahead
and save that up to iCloud


793
00:34:36,516 --> 00:34:39,235
and iCloud is going to,
you know, shuffle it away


794
00:34:39,235 --> 00:34:40,505
with all the other
subscriptions.


795
00:34:41,436 --> 00:34:42,576
Now along comes the Mac.


796
00:34:42,886 --> 00:34:44,275
The Mac creates a new record.


797
00:34:44,505 --> 00:34:46,706
It's a record-type party
and it's happening tonight


798
00:34:47,266 --> 00:34:50,295
and because the Mac didn't chose
to give us a RecordID we created


799
00:34:50,295 --> 00:34:52,306
that random UUID you see.


800
00:34:52,746 --> 00:34:55,795
The Mac goes ahead and
saves that to ICloud.


801
00:34:55,795 --> 00:34:58,756
ICloud is then going
to loop through all


802
00:34:58,756 --> 00:35:00,376
of the subscriptions
that it knows about.


803
00:35:00,756 --> 00:35:02,256
Eventually it's going
to come across this one.


804
00:35:02,936 --> 00:35:04,556
It's going to check
and say, yeah, okay,


805
00:35:04,556 --> 00:35:07,286
this is a new party and, yeah,
it's happening in the future.


806
00:35:07,946 --> 00:35:10,496
So at that point it's going to
create a push and it's going


807
00:35:10,496 --> 00:35:12,796
to take some information
from the subscription.


808
00:35:13,206 --> 00:35:15,476
Here it took the alert
string party time.


809
00:35:16,066 --> 00:35:17,446
It's going to take
other information


810
00:35:17,656 --> 00:35:19,066
from the record itself.


811
00:35:19,066 --> 00:35:20,556
Here we're pulling
in the RecordID.


812
00:35:21,186 --> 00:35:23,316
Now that I've constructed
this augmented payload,


813
00:35:23,426 --> 00:35:25,946
I can send that augmented
payload down to all clients


814
00:35:25,996 --> 00:35:28,126
that are registered
and interested in it.


815
00:35:29,316 --> 00:35:30,706
So let's look at some code.


816
00:35:31,246 --> 00:35:32,526
How do I create a subscription?


817
00:35:33,126 --> 00:35:37,356
Well, a subscription combines
a record type and a predicate.


818
00:35:38,826 --> 00:35:41,136
Because a subscription
is also in charge


819
00:35:41,136 --> 00:35:43,596
of telling the server how
you want to be alerted,


820
00:35:44,106 --> 00:35:46,516
we introduce a notion
called CKNotificationInfo.


821
00:35:47,546 --> 00:35:51,826
Here we're requesting that
the server badges our icon,


822
00:35:51,826 --> 00:35:54,626
that it plays a particular sound
pulled out of my resources,


823
00:35:55,296 --> 00:35:57,916
and that it shows an alert
string based on a string


824
00:35:57,916 --> 00:35:59,166
in my localized strings file.


825
00:35:59,846 --> 00:36:02,186
I can associate that
notification info


826
00:36:02,186 --> 00:36:04,846
with a subscription and now
I've created everything I need


827
00:36:04,846 --> 00:36:05,556
in my subscription.


828
00:36:06,266 --> 00:36:07,636
Let's go ahead and
save it to the server.


829
00:36:08,826 --> 00:36:11,926
As you might imagine via the
convenience API, it's simple,


830
00:36:11,926 --> 00:36:14,176
it's asynchronous and it's
got great error handling.


831
00:36:14,656 --> 00:36:18,566
Let's look at how you're going
to be handling subscriptions,


832
00:36:18,566 --> 00:36:20,446
how you're going to handle
pushes as they come in.


833
00:36:20,946 --> 00:36:23,676
If you've used APS in the
past, you're probably familiar


834
00:36:23,676 --> 00:36:24,536
with this code snippet.


835
00:36:25,116 --> 00:36:27,216
This is your application
delegate implementing the


836
00:36:27,216 --> 00:36:30,306
ApplicationDidReceive
from notification method.


837
00:36:31,436 --> 00:36:34,406
Now in most scenarios
if you know the format


838
00:36:34,406 --> 00:36:36,206
of the push payload
that's coming in,


839
00:36:36,496 --> 00:36:38,666
you would just then iterate
through that dictionary pulling


840
00:36:38,666 --> 00:36:40,236
out the key value pairs
that you care about.


841
00:36:41,076 --> 00:36:42,656
However, because
CloudKit was the one


842
00:36:42,656 --> 00:36:43,846
that generated this push,


843
00:36:44,376 --> 00:36:46,366
we ask that you let
CloudKit do that parsing.


844
00:36:47,026 --> 00:36:50,346
So the way you would do that
is via CKNotification then


845
00:36:50,346 --> 00:36:53,186
that really long one
I'm not going to name.


846
00:36:53,396 --> 00:36:55,026
Once we've actually parsed


847
00:36:55,026 --> 00:36:58,326
out a CKNotification you can
pull off APS level information


848
00:36:58,326 --> 00:37:02,126
from it and you can also pull
off CloudKit level information


849
00:37:02,126 --> 00:37:02,966
from it.


850
00:37:03,186 --> 00:37:06,486
Here we're taking the
RecordID of the saved record


851
00:37:06,876 --> 00:37:08,036
that caused the push to happen.


852
00:37:09,476 --> 00:37:12,626
So between queries and
subscriptions we have an answer


853
00:37:12,626 --> 00:37:14,506
to the big data,
tiny phone problem.


854
00:37:14,796 --> 00:37:17,036
You're going to leave your
large data up in the cloud


855
00:37:17,336 --> 00:37:19,816
and you're going to use
these two capabilities


856
00:37:19,816 --> 00:37:24,016
to give your users a quick
view into that large dataset.


857
00:37:24,146 --> 00:37:28,846
Now, I want to talk about
CloudKit user accounts.


858
00:37:30,986 --> 00:37:33,926
As Olivier mentioned,
CloudKit is built on top


859
00:37:33,926 --> 00:37:35,526
of the iCloud account
infrastructure.


860
00:37:36,026 --> 00:37:37,036
So what does that mean?


861
00:37:37,036 --> 00:37:41,466
I want to focus a little bit
on how accounts are exposed


862
00:37:41,466 --> 00:37:43,626
to you explicitly
throughout the API.


863
00:37:44,546 --> 00:37:46,116
When you think about
an account system,


864
00:37:46,426 --> 00:37:48,036
the first thing you think
about is authentication


865
00:37:48,546 --> 00:37:50,936
and CloudKit supports
authentication via the logged


866
00:37:50,936 --> 00:37:53,096
in iCloud user, but
that's not, you know,


867
00:37:53,096 --> 00:37:54,886
that's sort of behind the
scenes and you guys don't care


868
00:37:54,886 --> 00:37:55,866
about that, that's implicit.


869
00:37:55,976 --> 00:37:57,626
Let's talk about
the explicit things.


870
00:37:58,286 --> 00:38:00,556
What do we give you
because we're built


871
00:38:00,556 --> 00:38:01,746
on top of iCloud accounts?


872
00:38:02,436 --> 00:38:05,006
We give you identity; a way
of identifying the user.


873
00:38:05,716 --> 00:38:08,076
We give you metadata;
the ability to save


874
00:38:08,076 --> 00:38:09,816
and retrieve information
about users.


875
00:38:10,776 --> 00:38:13,186
We do all of this in a
privacy conscientious manner


876
00:38:13,186 --> 00:38:14,476
and we don't want
to disclose anything


877
00:38:14,476 --> 00:38:16,736
if the user hasn't agreed to it


878
00:38:17,126 --> 00:38:19,066
and lastly we give
users the ability


879
00:38:19,066 --> 00:38:21,856
to discover their friends that
are using your application.


880
00:38:22,506 --> 00:38:24,336
Let's dive into each
one of these.


881
00:38:24,566 --> 00:38:26,346
First of all we're going
to talk about identity.


882
00:38:27,436 --> 00:38:29,076
So, here's our model.


883
00:38:29,076 --> 00:38:30,836
We've got our client,
our application running


884
00:38:30,836 --> 00:38:32,966
on the client, and all
of these different users


885
00:38:32,966 --> 00:38:34,786
and their private databases
up in the container.


886
00:38:36,376 --> 00:38:39,536
Your specific client is
going to be linked to one


887
00:38:39,536 --> 00:38:40,856
and only one of those users.


888
00:38:41,036 --> 00:38:45,396
This is related to
the user that's logged


889
00:38:45,396 --> 00:38:47,496
in via iCloud locally
on your device.


890
00:38:48,546 --> 00:38:51,556
Because this is iCloud we've
got a rich backing store


891
00:38:51,556 --> 00:38:54,756
of user information and
because iCloud is the one


892
00:38:55,136 --> 00:38:59,386
that is hosting your container
we can correlate users.


893
00:38:59,636 --> 00:39:01,776
For example, here we
see that the user,


894
00:39:01,776 --> 00:39:04,116
whose email address is
c at iCloud dot com,


895
00:39:04,536 --> 00:39:06,246
is linked to your
current client.


896
00:39:07,366 --> 00:39:11,166
So given this setup how are we
going to present an identity?


897
00:39:11,166 --> 00:39:13,356
How are we going to let
you know, your client,


898
00:39:13,356 --> 00:39:16,436
your application, know
what user is logged in?


899
00:39:16,926 --> 00:39:19,266
Well, natively you might
think let's give them an


900
00:39:19,266 --> 00:39:19,916
email address.


901
00:39:20,156 --> 00:39:21,876
We're not going to
do that obviously.


902
00:39:22,446 --> 00:39:25,376
That's private user
identifiable information


903
00:39:25,376 --> 00:39:26,636
and we don't want
to give that out.


904
00:39:27,446 --> 00:39:29,416
So, instead what we
do is on a container


905
00:39:29,416 --> 00:39:33,036
by container basis we
come up with a random ID.


906
00:39:33,366 --> 00:39:35,586
This is an identifier
that is stable


907
00:39:35,656 --> 00:39:39,036
so that is your application no
matter what client it's running


908
00:39:39,036 --> 00:39:42,676
on talking to this container
will get the same identifier,


909
00:39:43,096 --> 00:39:46,306
but it's not identifying
the user via any


910
00:39:46,306 --> 00:39:47,166
personal information.


911
00:39:48,056 --> 00:39:51,706
So we feel confident
giving you this identifier.


912
00:39:52,066 --> 00:39:54,316
You can take this identifier
and do with it what you will.


913
00:39:55,276 --> 00:39:58,796
Note that different applications
running on your phone


914
00:39:58,796 --> 00:40:03,426
because they're talking to
different containers are going


915
00:40:03,426 --> 00:40:06,256
to get back different container
scoped RecordIdentifiers


916
00:40:06,476 --> 00:40:07,286
for the same user.


917
00:40:08,146 --> 00:40:09,976
This goes back to what we
talked about in the beginning


918
00:40:09,976 --> 00:40:14,926
that we've got user
encapsulation.


919
00:40:15,046 --> 00:40:15,556
So user identity.


920
00:40:15,676 --> 00:40:19,346
We expose user identity
via API as a user RecordID.


921
00:40:20,016 --> 00:40:22,216
It is a stable identifier
for this user.


922
00:40:22,606 --> 00:40:24,796
It will be the same for
your application no matter


923
00:40:24,796 --> 00:40:26,086
where your application
is running.


924
00:40:26,716 --> 00:40:29,296
It's scoped to the container


925
00:40:29,576 --> 00:40:31,446
so 2 different applications
are going to come


926
00:40:31,446 --> 00:40:33,726
up with different
identifiers for the same user.


927
00:40:34,096 --> 00:40:36,196
This is a feature.


928
00:40:36,196 --> 00:40:37,986
Lastly this is an
independent API.


929
00:40:38,156 --> 00:40:40,006
This is a section of
the CloudKit framework.


930
00:40:40,646 --> 00:40:42,076
You can use this
in collaboration


931
00:40:42,076 --> 00:40:45,496
with the database API or you can
use this completely separately.


932
00:40:45,756 --> 00:40:48,006
We've given you enough
support that if you wanted


933
00:40:48,006 --> 00:40:51,076
to you could implement
a login via iCloud flow


934
00:40:51,336 --> 00:40:53,496
in your application using
the CloudKit framework.


935
00:40:54,426 --> 00:40:56,846
Let's have a look at the code.


936
00:40:57,516 --> 00:41:00,806
[ Applause ]


937
00:41:01,306 --> 00:41:02,746
All right let's have
a look at the code.


938
00:41:03,396 --> 00:41:06,106
Because identity is a
container-scoped notion


939
00:41:06,246 --> 00:41:09,396
and not a database-scoped
notion, we go to our container


940
00:41:09,396 --> 00:41:10,356
to learn about our user.


941
00:41:11,116 --> 00:41:13,946
Here we're asking our container
to fetch the user RecordID.


942
00:41:15,276 --> 00:41:18,116
Now because we may have
to talk to the server


943
00:41:18,116 --> 00:41:20,666
to figure this out, for example,
the first time you access


944
00:41:20,666 --> 00:41:22,886
and try to learn about
a RecordID we have to go


945
00:41:22,886 --> 00:41:25,376
to the server to do that
translation and come


946
00:41:25,376 --> 00:41:26,626
up with a container-scoped info.


947
00:41:27,086 --> 00:41:29,566
So, asynchronous and we
have to do error handling.


948
00:41:31,296 --> 00:41:32,666
That's user identity.


949
00:41:32,966 --> 00:41:35,576
Let's talk about user
metadata and quickly


950
00:41:35,576 --> 00:41:38,996
to recap the problem what we
have here is we have a stable


951
00:41:38,996 --> 00:41:40,946
identifier and we've
got a desire


952
00:41:41,006 --> 00:41:44,476
to set key value pairs
based on that identifier.


953
00:41:45,106 --> 00:41:47,776
I don't know about you but
to me that sounds very much


954
00:41:47,776 --> 00:41:49,326
like what a record
was built to do.


955
00:41:49,906 --> 00:41:53,086
So we expose users
as user records.


956
00:41:55,036 --> 00:41:56,086
Looking inside a container


957
00:41:56,086 --> 00:41:58,696
within a database we see
there is one user record


958
00:41:58,696 --> 00:41:59,886
in the private database


959
00:42:00,296 --> 00:42:02,656
that user record
represents your user.


960
00:42:03,576 --> 00:42:06,376
There are many user records
inside the public database


961
00:42:06,656 --> 00:42:09,136
representing each one of the
users of your application.


962
00:42:10,166 --> 00:42:11,886
One of them will have a RecordID


963
00:42:12,096 --> 00:42:13,916
that matches your
currently logged


964
00:42:13,916 --> 00:42:15,476
in iCloud user's RecordID.


965
00:42:17,036 --> 00:42:18,666
So, user metadata.


966
00:42:18,666 --> 00:42:21,166
Exposed via our framework
as a user record.


967
00:42:21,666 --> 00:42:24,976
There's one per database that
represents your current user.


968
00:42:26,356 --> 00:42:27,936
User records in the
public database


969
00:42:27,936 --> 00:42:30,836
like any other default
record are world readable.


970
00:42:32,446 --> 00:42:35,506
They're treated mostly
like an ordinary record


971
00:42:35,776 --> 00:42:37,136
with a record type
that we exposed


972
00:42:37,136 --> 00:42:39,386
in the framework
CKRecord TypeUserRecord,


973
00:42:39,906 --> 00:42:41,786
but there are a couple
of caveats.


974
00:42:42,666 --> 00:42:46,176
First off these records
are reserved by the system.


975
00:42:46,486 --> 00:42:48,726
You do not create a user record.


976
00:42:49,046 --> 00:42:51,136
Rather you fetch an
existing one from the server.


977
00:42:51,896 --> 00:42:53,996
What that means is
that you can be assured


978
00:42:53,996 --> 00:42:56,406
that when you fetch a
record for your current user


979
00:42:56,586 --> 00:42:57,846
but it has not been spoofed.


980
00:42:58,356 --> 00:42:59,996
It was, indeed, iCloud
that created


981
00:42:59,996 --> 00:43:01,166
that record in the first place.


982
00:43:02,116 --> 00:43:04,526
Secondly, we think that it
doesn't make sense for you


983
00:43:04,526 --> 00:43:06,916
to be able to query the
entire set of user records


984
00:43:06,916 --> 00:43:07,986
in the public database.


985
00:43:08,106 --> 00:43:10,496
It doesn't really make sense to
be able to say I want to look


986
00:43:10,496 --> 00:43:12,936
at all users whose first
name begins with A.


987
00:43:12,936 --> 00:43:17,176
It's a little bit too course
grained for something that's so,


988
00:43:17,266 --> 00:43:19,076
that we want to protect
privacy around.


989
00:43:19,636 --> 00:43:22,306
So we don't allow you
to query user records.


990
00:43:22,996 --> 00:43:25,446
Don't worry we're going to fix
that in a couple of slides.


991
00:43:26,396 --> 00:43:27,826
All right so what
does it look like?


992
00:43:28,506 --> 00:43:30,566
Here we have the same
code that we saw earlier


993
00:43:30,676 --> 00:43:32,196
and we're fetching
a user RecordID.


994
00:43:32,716 --> 00:43:36,236
Once I have that CKRecordID I
can go ahead and I can fetch


995
00:43:36,236 --> 00:43:38,896
that record from either
database that I choose.


996
00:43:39,306 --> 00:43:41,866
Here I'm choosing to fetch a
record with that identifier


997
00:43:42,006 --> 00:43:43,406
from the public database.


998
00:43:44,326 --> 00:43:48,506
Assuming that I don't get an
error I now had a live CKRecord


999
00:43:48,506 --> 00:43:51,306
that represents this
user and I can treat it


1000
00:43:51,306 --> 00:43:52,936
like I would any other CKRecord.


1001
00:43:53,616 --> 00:43:57,206
I can pull records, excuse me,
I can pull key value pairs off


1002
00:43:57,206 --> 00:44:00,376
of it, I can set key value
pairs on it, and if I wanted to,


1003
00:44:00,376 --> 00:44:02,176
I could go ahead and save
it back to the server.


1004
00:44:02,176 --> 00:44:05,566
Now let's talk about privacy.


1005
00:44:06,246 --> 00:44:08,056
We care very much about
our user's privacy.


1006
00:44:09,956 --> 00:44:12,156
Therefore, we disclose
no information,


1007
00:44:12,276 --> 00:44:14,376
no personally identifying
user information


1008
00:44:14,766 --> 00:44:16,616
about the current
user by default.


1009
00:44:17,606 --> 00:44:21,446
Now we recognize that in some
cases your application is going


1010
00:44:21,446 --> 00:44:25,296
to want to have limited access
to metadata about the user.


1011
00:44:26,636 --> 00:44:30,766
So, if you want that data, you
can request that from CloudKit.


1012
00:44:31,546 --> 00:44:33,726
When you do, we're going to
go to the user to make sure


1013
00:44:33,726 --> 00:44:34,986
that they're okay with that.


1014
00:44:35,476 --> 00:44:36,326
Here we see an example


1015
00:44:36,326 --> 00:44:38,856
of the party application
requesting the ability


1016
00:44:38,896 --> 00:44:40,936
for my user account
to be discoverable


1017
00:44:40,936 --> 00:44:41,776
within the application.


1018
00:44:42,006 --> 00:44:45,256
The user can either choose
to allow or deny that.


1019
00:44:46,256 --> 00:44:48,796
Assuming that the
user has acquiesced


1020
00:44:48,866 --> 00:44:50,426
to this privacy request,


1021
00:44:50,876 --> 00:44:53,266
we can go on to the next
phase, which is discovery.


1022
00:44:53,536 --> 00:44:55,446
So let's talk a little
bit about user discovery.


1023
00:44:57,146 --> 00:44:57,706
Here's our image.


1024
00:44:57,706 --> 00:44:59,556
We've got our client
talking to a container


1025
00:44:59,556 --> 00:45:01,436
and the container
is backed by iCloud


1026
00:45:01,496 --> 00:45:03,676
and iCloud has all this
rich user information.


1027
00:45:05,156 --> 00:45:07,806
If we look a little bit
more on the client side,


1028
00:45:07,956 --> 00:45:09,956
we see there's actually
two different processes


1029
00:45:09,956 --> 00:45:10,586
involved here.


1030
00:45:11,056 --> 00:45:12,376
There's your client process


1031
00:45:12,376 --> 00:45:14,426
and then there's
the CloudKit process


1032
00:45:14,426 --> 00:45:16,886
and it's the CloudKit process
that's the one that's actually


1033
00:45:16,886 --> 00:45:18,496
talking over the wire.


1034
00:45:19,476 --> 00:45:22,066
So let's examine what
user discovery would look


1035
00:45:22,066 --> 00:45:24,226
like if you want to
discover information


1036
00:45:24,226 --> 00:45:25,856
about a user given a RecordID.


1037
00:45:26,646 --> 00:45:30,076
You take that RecordID and you
can send it off to CloudKit.


1038
00:45:30,696 --> 00:45:33,116
CloudKit is going to in turn
send it up to the container.


1039
00:45:34,546 --> 00:45:36,156
Once it hits the
container we're going


1040
00:45:36,156 --> 00:45:38,626
to ask the iCloud
account info to exchange


1041
00:45:38,626 --> 00:45:41,286
out for different information
for information about that user.


1042
00:45:42,356 --> 00:45:45,396
If that user has opted
in to discoverability,


1043
00:45:45,516 --> 00:45:46,846
we're going to get
information back.


1044
00:45:47,616 --> 00:45:49,566
That information can
traverse back to CloudKit


1045
00:45:49,666 --> 00:45:52,406
and back via the process
boundary over to your client,


1046
00:45:53,686 --> 00:45:55,606
but we're not restricted
to just RecordIDs.


1047
00:45:56,216 --> 00:45:58,336
If your user enters
in an email address,


1048
00:45:58,336 --> 00:45:59,786
we can do the same
sort of dance.


1049
00:46:00,166 --> 00:46:02,716
This email address is sent from
your client over to CloudKit


1050
00:46:02,716 --> 00:46:05,416
and CloudKit is then going
to hash it out a whole bunch


1051
00:46:05,416 --> 00:46:08,776
of times so that we're not
sending personal info off the


1052
00:46:08,776 --> 00:46:10,946
client, and we'll send
that up to the container.


1053
00:46:11,836 --> 00:46:14,786
That container exchanges it
with iCloud and if the target


1054
00:46:14,786 --> 00:46:17,406
of this discovery has opted
in to discoverability,


1055
00:46:17,406 --> 00:46:19,616
we're going to get
a result sent back.


1056
00:46:20,056 --> 00:46:21,536
Those results can
go back to CloudKit


1057
00:46:21,536 --> 00:46:25,276
and can traverse back
up to your client.


1058
00:46:25,696 --> 00:46:26,976
Now, I'd like to think
that are we are pretty good


1059
00:46:26,976 --> 00:46:29,056
about naming things in
CloudKit but this one we sort


1060
00:46:29,056 --> 00:46:30,266
of didn't really do well.


1061
00:46:30,686 --> 00:46:33,496
So we offer a different
way of doing user discovery


1062
00:46:33,496 --> 00:46:35,856
that we call the whole address
book and it's a way for you


1063
00:46:35,856 --> 00:46:38,206
to discover the whole
address book.


1064
00:46:38,466 --> 00:46:41,996
The way this works is that your
client is going to say I would


1065
00:46:41,996 --> 00:46:45,356
like to discover the user
RecordIDs and more information


1066
00:46:45,846 --> 00:46:48,386
about every user that is friends


1067
00:46:48,456 --> 00:46:50,466
with my currently
logged in iCloud user.


1068
00:46:51,516 --> 00:46:53,896
You send that request over
to the CloudKit process.


1069
00:46:54,426 --> 00:46:56,796
The CloudKit process
is then going to pull


1070
00:46:56,796 --> 00:46:57,996
in the user's address book.


1071
00:46:57,996 --> 00:47:00,386
We're going to take all
the emailed addresses


1072
00:47:00,386 --> 00:47:02,246
in that address book and
we're going to hash them up


1073
00:47:02,766 --> 00:47:04,096
and we're going to
send, you know,


1074
00:47:04,096 --> 00:47:05,986
a non-personally
identifying version


1075
00:47:05,986 --> 00:47:08,116
of that address book
up to the container.


1076
00:47:09,366 --> 00:47:11,076
The container is going
to send it off to iCloud


1077
00:47:11,606 --> 00:47:14,986
and for those members of my
address book that have opted


1078
00:47:14,986 --> 00:47:17,886
into discoverability I'm going
to learn information about them.


1079
00:47:18,846 --> 00:47:20,576
That information is going
to come back to CloudKit


1080
00:47:20,666 --> 00:47:21,426
and it's going to be sent


1081
00:47:21,426 --> 00:47:23,726
over the process
boundary to your client.


1082
00:47:24,776 --> 00:47:27,256
Now if you'll note at
no point did your client


1083
00:47:27,456 --> 00:47:30,706
in this little flow have access
to the user's address book.


1084
00:47:31,506 --> 00:47:34,046
What this means is that we
can give you the support


1085
00:47:34,346 --> 00:47:37,766
without requiring that your
user allows your application


1086
00:47:37,766 --> 00:47:40,186
to the address book meaning
that you don't have to have


1087
00:47:40,186 --> 00:47:41,776
that blue alert, which
is now the white alert,


1088
00:47:42,186 --> 00:47:44,466
giving your application
access to the address book.


1089
00:47:45,006 --> 00:47:47,326
You can leverage it
without access to it.


1090
00:47:48,516 --> 00:47:53,896
[ Applause ]


1091
00:47:54,396 --> 00:47:55,456
So user discovery.


1092
00:47:55,886 --> 00:47:57,326
These are the three
different kinds of inputs


1093
00:47:57,326 --> 00:47:58,656
that we can have
for user discovery.


1094
00:47:58,656 --> 00:48:01,506
You can start off with a user
RecordID, an email address


1095
00:48:01,586 --> 00:48:04,076
or request to view the
entire address book.


1096
00:48:04,936 --> 00:48:06,376
What do you get back
from user discovery?


1097
00:48:06,866 --> 00:48:08,366
Well, you'll get
back a user RecordID.


1098
00:48:08,366 --> 00:48:10,956
In the latter two cases,
that's new information.


1099
00:48:11,816 --> 00:48:14,376
You also get back the first
and last name of this user.


1100
00:48:15,346 --> 00:48:18,356
Of course it bears
repeating first


1101
00:48:18,356 --> 00:48:20,766
and last name is personally
identifying information


1102
00:48:21,116 --> 00:48:23,936
so you're only going to get
discovery results for users


1103
00:48:23,936 --> 00:48:25,856
that have opted into
discoverability.


1104
00:48:26,386 --> 00:48:30,086
Let's have a look
at some code here.


1105
00:48:31,906 --> 00:48:35,976
Here we are asking our default
container to discover all


1106
00:48:35,976 --> 00:48:39,606
of my users that are
part of my address book.


1107
00:48:41,486 --> 00:48:43,916
In the response, again,
asynchronous error handling


1108
00:48:44,506 --> 00:48:47,686
in the successful response
case what we see is


1109
00:48:47,686 --> 00:48:50,776
that we get back a
CKDiscoveredUserInfo object


1110
00:48:51,086 --> 00:48:54,316
and that user info from that
I can pull a user RecordID


1111
00:48:54,446 --> 00:48:55,546
and a first and last name.


1112
00:48:56,946 --> 00:48:59,046
So these are really
the four tent poles


1113
00:48:59,046 --> 00:49:01,286
of how we do user accounts.


1114
00:49:01,286 --> 00:49:05,196
We give you a stable identifier,
we give you the ability to store


1115
00:49:05,196 --> 00:49:09,946
and retrieve metadata about
users, we protect user's privacy


1116
00:49:10,506 --> 00:49:12,176
and we give your
users the ability


1117
00:49:12,176 --> 00:49:13,856
to discover their friends
in your application.


1118
00:49:14,856 --> 00:49:17,396
Now, to tell you when it's
appropriate to use CloudKit


1119
00:49:17,396 --> 00:49:19,166
versus some of the other
iCloud technologies


1120
00:49:19,166 --> 00:49:20,406
that we already have exposed,


1121
00:49:20,746 --> 00:49:22,256
I'd like to invite
back up Olivier Bonnet.


1122
00:49:23,516 --> 00:49:29,776
[ Applause ]


1123
00:49:30,276 --> 00:49:30,806
>> Thank you, Paul.


1124
00:49:32,216 --> 00:49:37,726
So CloudKit is the new framework
but it doesn't obsolete


1125
00:49:37,726 --> 00:49:40,406
or deprecate any of
the existing tools.


1126
00:49:40,546 --> 00:49:43,736
It's really just a new
tool in your toolbox.


1127
00:49:44,256 --> 00:49:49,276
Let's look at all the four
tools you now have and look


1128
00:49:49,276 --> 00:49:52,416
at where different use cases
where we think they make sense


1129
00:49:52,416 --> 00:49:54,696
and they're appropriate to use.


1130
00:49:54,916 --> 00:49:57,036
So, first, iCloud
Key Value Store.


1131
00:49:57,036 --> 00:50:03,126
iCloud Key Value Store keeps
small piles of data up to date


1132
00:50:03,126 --> 00:50:05,666
between your app and
the iCloud servers.


1133
00:50:06,106 --> 00:50:07,876
This is done asynchronously.


1134
00:50:08,036 --> 00:50:09,736
Your app doesn't
really need to care


1135
00:50:09,736 --> 00:50:11,966
about when and how this is done.


1136
00:50:12,376 --> 00:50:14,936
We think this is great
for small amounts of data


1137
00:50:14,936 --> 00:50:18,526
like application
preferences game states.


1138
00:50:19,056 --> 00:50:22,996
Conflict resolution is pretty
simple, last writer wins.


1139
00:50:23,136 --> 00:50:26,276
So, that's iCloud
Key Value Store.


1140
00:50:27,836 --> 00:50:31,376
iCloud Drive builds on top


1141
00:50:31,376 --> 00:50:35,436
of the existing iCloud
document APIs.


1142
00:50:35,576 --> 00:50:38,446
Doing so it provides full
offline cache on OS X;


1143
00:50:38,826 --> 00:50:40,926
all the files on
the iCloud drive


1144
00:50:40,926 --> 00:50:43,506
of the user are downloaded
on the OS X.


1145
00:50:43,506 --> 00:50:44,796
It's completely unstructured


1146
00:50:44,796 --> 00:50:46,746
and internally tied
to the file system.


1147
00:50:46,746 --> 00:50:51,246
You use the file coordination
APIs to read and write data


1148
00:50:51,756 --> 00:50:54,846
in your application iCloud
container on the file system


1149
00:50:54,846 --> 00:50:58,636
and the iCloud Drive daemon
takes care of uploading


1150
00:50:58,636 --> 00:51:05,176
and downloading those changes
up and from the iCloud servers.


1151
00:51:06,156 --> 00:51:09,776
We think it's great for document
centric apps or apps that need


1152
00:51:09,806 --> 00:51:11,826
to deal with an existing
file formats.


1153
00:51:13,236 --> 00:51:16,006
ICloud Core Data built on top


1154
00:51:16,006 --> 00:51:21,056
of iCloud Drive replicates
off specific user data


1155
00:51:22,016 --> 00:51:23,886
between all the user's devices.


1156
00:51:24,416 --> 00:51:27,176
It's great for keeping
private structured data in sync


1157
00:51:27,486 --> 00:51:30,636
but because it downloads
all the data


1158
00:51:30,636 --> 00:51:34,356
to all devices you're also
constrained to the size


1159
00:51:34,356 --> 00:51:36,426
of the smallest device
in that case.


1160
00:51:37,656 --> 00:51:40,276
Enters CloudKit, the
new kid on the block


1161
00:51:40,276 --> 00:51:43,546
and we think there are a
number of interesting use cases


1162
00:51:43,546 --> 00:51:45,716
where CloudKit makes sense


1163
00:51:45,716 --> 00:51:50,846
and complements pretty well
the existing technologies.


1164
00:51:50,956 --> 00:51:52,816
So first any public data.


1165
00:51:53,786 --> 00:51:57,476
If your app, if you need to
give access to all the users


1166
00:51:57,476 --> 00:52:00,046
of your app to large datasets,


1167
00:52:00,046 --> 00:52:05,536
CloudKit public databases are
pretty good compiling tool.


1168
00:52:07,136 --> 00:52:09,796
CloudKit supports both
structured and bulk data.


1169
00:52:10,276 --> 00:52:14,496
So you can use it to store large
files on iCloud and we take care


1170
00:52:14,496 --> 00:52:19,886
of downloading and uploading
them to the iCloud servers.


1171
00:52:20,806 --> 00:52:25,556
As Paul described, CloudKit has
good support for large datasets


1172
00:52:25,556 --> 00:52:28,706
where your app will want
to give a specific slice,


1173
00:52:28,706 --> 00:52:32,526
a specific view of large
data set to the user


1174
00:52:32,526 --> 00:52:35,426
at a giver point in time.


1175
00:52:35,616 --> 00:52:43,736
CloudKit lets you use the
existing accounts infrastructure


1176
00:52:43,736 --> 00:52:46,236
whether you need to
identify the user


1177
00:52:46,666 --> 00:52:52,766
or to let the user discover his
friends using your app CloudKit


1178
00:52:53,006 --> 00:52:55,886
enables you to do that.


1179
00:52:56,746 --> 00:52:58,486
Last but not least compared


1180
00:52:58,486 --> 00:53:03,246
to the other three technologies
we think CloudKit is closer


1181
00:53:03,246 --> 00:53:04,426
to the middle in some way.


1182
00:53:05,086 --> 00:53:08,906
In this case when you're using
CloudKit, your app is really


1183
00:53:08,906 --> 00:53:12,756
in control of when
the app is uploaded


1184
00:53:12,756 --> 00:53:14,316
or downloaded from the server.


1185
00:53:14,566 --> 00:53:17,706
Your app is controllng
the operations


1186
00:53:17,706 --> 00:53:22,076
and that is also why you need
to do this [inaudible] will do.


1187
00:53:24,736 --> 00:53:28,266
So, in summary, what
have we covered today?


1188
00:53:29,076 --> 00:53:32,106
CloudKit gives you
access to iCloud servers.


1189
00:53:33,186 --> 00:53:36,366
It supports both
public and private data.


1190
00:53:37,576 --> 00:53:39,526
It supports both
structured and bulk data.


1191
00:53:39,526 --> 00:53:42,766
You can use it for large files.


1192
00:53:42,896 --> 00:53:46,056
It leverages the existing
iCloud account infrastructure


1193
00:53:46,056 --> 00:53:50,716
which means that the over
400 million iCloud accounts


1194
00:53:50,716 --> 00:53:53,716
out there are here for
you to take advantage of.


1195
00:53:54,426 --> 00:53:56,896
Apple is building
on it in a big way.


1196
00:53:57,146 --> 00:54:00,916
Both iCloud Drive and iCloud
file Library were built


1197
00:54:00,916 --> 00:54:02,656
from scratch on top of CloudKit.


1198
00:54:04,426 --> 00:54:08,036
We're super excited to see what
you're going to build on top


1199
00:54:08,036 --> 00:54:08,996
of this new framework.


1200
00:54:10,766 --> 00:54:14,286
So for more information
Dave is our evangelist.


1201
00:54:14,286 --> 00:54:16,556
We have some awesome
framework reference


1202
00:54:16,556 --> 00:54:20,176
on developer.apple.com website
as well as developer forums.


1203
00:54:21,176 --> 00:54:24,036
We have an advanced
CloudKit session on Thursday


1204
00:54:24,036 --> 00:54:26,526
and Jacob is going to tell you
everything you want to know


1205
00:54:26,526 --> 00:54:30,226
about that, Data Modeling and
Advanced Record Manipulations.


1206
00:54:30,996 --> 00:54:32,276
Thank you very much
for being here


1207
00:54:32,276 --> 00:54:32,976
and thank you for
your attention.


1208
00:54:33,508 --> 00:54:35,508
[ Applause ]

