1
00:00:27,516 --> 00:00:32,665
[ Applause ]


2
00:00:33,166 --> 00:00:34,366
>> BRUCE STADNYK:
Good afternoon!


3
00:00:34,826 --> 00:00:38,516
I am Bruce Stadnyk from the iOS
contacts team and I'm excited


4
00:00:38,516 --> 00:00:41,646
to introduce the new
Contacts Framework to you.


5
00:00:42,516 --> 00:00:45,896
[ Applause ]


6
00:00:46,396 --> 00:00:47,276
>> BRUCE STADNYK: If you are new


7
00:00:47,276 --> 00:00:50,196
to Apple's platforms you
will learn how easy it is


8
00:00:50,196 --> 00:00:52,266
to use contacts in your app.


9
00:00:52,896 --> 00:00:54,876
If you are an experienced
developer with Address Book,


10
00:00:55,166 --> 00:00:56,546
you will love this
new Framework.


11
00:00:59,756 --> 00:01:02,716
So what is this new
Contacts Framework?


12
00:01:03,766 --> 00:01:06,696
Well, we have been listening
to your Address Book feedback


13
00:01:06,696 --> 00:01:09,546
and today we are addressing
the most frequent request.


14
00:01:09,776 --> 00:01:13,946
The Address Book Framework
provides an Objective-C API


15
00:01:13,946 --> 00:01:18,556
to access contacts,
and the API is designed


16
00:01:18,556 --> 00:01:19,676
to work well with Swift


17
00:01:20,516 --> 00:01:22,926
[ Applause ]


18
00:01:23,426 --> 00:01:25,336
>> BRUCE STADNYK: We are as
excited about this as you are.


19
00:01:27,356 --> 00:01:30,306
There are many design goals with
this new Contacts Framework.


20
00:01:30,796 --> 00:01:35,116
I'm going to review a few of
the key ones with you now.


21
00:01:35,346 --> 00:01:38,316
One, to address the
majority of apps


22
00:01:38,746 --> 00:01:42,716
that are mostly get contacts
and do not modify contacts,


23
00:01:43,496 --> 00:01:46,926
we have designed the API for
thread safe read-only usage.


24
00:01:48,656 --> 00:01:51,756
This is done mostly with
immutable value objects


25
00:01:51,916 --> 00:01:53,476
that do not reference
a data store.


26
00:01:55,476 --> 00:01:59,376
This allows you to pass
contacts easily between queues


27
00:01:59,376 --> 00:02:05,036
on your app and not have
unexpected I/O occur on them.


28
00:02:05,246 --> 00:02:07,966
Another is to have
the same contacts API


29
00:02:07,966 --> 00:02:11,616
on OS X, iOS and watchOS.


30
00:02:12,516 --> 00:02:15,026
[ Applause ]


31
00:02:15,526 --> 00:02:18,486
>> BRUCE STADNYK: You learn one
API and then use the same code


32
00:02:18,486 --> 00:02:21,186
to access contacts across
multiple Apple platforms.


33
00:02:23,076 --> 00:02:26,386
And, Address Book,
if you are using it,


34
00:02:26,856 --> 00:02:27,976
it is being deprecated.


35
00:02:28,516 --> 00:02:35,676
[ Cheers and applause ]


36
00:02:36,176 --> 00:02:39,106
>> BRUCE STADNYK: We don't
realize how much we take


37
00:02:39,106 --> 00:02:41,186
for granted the contacts
on our devices.


38
00:02:42,296 --> 00:02:44,696
For example when we
receive a phone call


39
00:02:45,036 --> 00:02:48,336
and we only see a phone number,
we ask ourselves: Who is that?


40
00:02:49,396 --> 00:02:50,996
Is it someone from our family?


41
00:02:51,776 --> 00:02:52,556
Is it a friend?


42
00:02:53,326 --> 00:02:54,436
Another telemarketer?


43
00:02:56,136 --> 00:02:58,936
It is a much better experience
when a contact is displayed.


44
00:02:59,846 --> 00:03:02,396
Oh, it's John Apleseed,
one of my best friends.


45
00:03:05,076 --> 00:03:07,836
So everyone has contacts
on their devices.


46
00:03:08,616 --> 00:03:11,236
They help us to identify who
we are communicating with


47
00:03:11,836 --> 00:03:14,816
and also help us to make
phone calls, send e-mails,


48
00:03:15,126 --> 00:03:17,046
and initiate other
means of communication.


49
00:03:17,706 --> 00:03:21,836
For example, I can speak
to my device and say: Hey,


50
00:03:21,836 --> 00:03:23,946
Siri, call John Appleseed.


51
00:03:24,696 --> 00:03:26,206
Okay. There we go.


52
00:03:26,206 --> 00:03:28,736
>> SIRI: Calling John
Appleseed, iPhone on speaker.


53
00:03:29,716 --> 00:03:32,206
>> BRUCE STADNYK: So
contacts are a central part


54
00:03:32,206 --> 00:03:33,976
of the user experience
on our devices.


55
00:03:37,726 --> 00:03:40,566
So how does the Contacts
Framework handle this


56
00:03:40,566 --> 00:03:41,566
contact information?


57
00:03:42,566 --> 00:03:44,886
Let's take a look at an
example with John Appleseed.


58
00:03:46,186 --> 00:03:47,726
For those of you
experienced with Address Book,


59
00:03:47,956 --> 00:03:48,896
this is a quick review.


60
00:03:51,156 --> 00:03:54,996
Here we have John's profile
picture, his first name,


61
00:03:56,146 --> 00:04:05,286
last name, his home e-mail
address, work e-mail address,


62
00:04:06,276 --> 00:04:07,786
and the phone number
for his iPhone.


63
00:04:11,636 --> 00:04:14,546
These contact properties
represent this


64
00:04:14,576 --> 00:04:15,536
contact information.


65
00:04:16,995 --> 00:04:19,416
The profile image is
represented by image data.


66
00:04:21,086 --> 00:04:22,976
The name is broken
into components.


67
00:04:23,516 --> 00:04:25,646
So the first name is
represented by given name


68
00:04:25,646 --> 00:04:29,626
and the last name
by family name.


69
00:04:29,836 --> 00:04:32,776
Both the home and work e-mail
addresses are represented


70
00:04:32,776 --> 00:04:33,736
by e-mail addresses.


71
00:04:34,316 --> 00:04:38,886
And the phone number is
represented by phone numbers.


72
00:04:40,736 --> 00:04:42,866
There are many more
contact properties.


73
00:04:43,186 --> 00:04:45,756
You can refer to the contacts
documentation for more details.


74
00:04:48,496 --> 00:04:50,546
Now, let's talk more
about this object.


75
00:04:52,976 --> 00:04:55,066
This is the CNContact object.


76
00:04:56,776 --> 00:05:00,906
It is an immutable value
object of contact properties.


77
00:05:02,126 --> 00:05:04,196
It is modeled like NSDictionary.


78
00:05:05,176 --> 00:05:08,736
It has a mutable
subclass, CNMuteableContact,


79
00:05:09,236 --> 00:05:11,186
that you modify the
contact properties with.


80
00:05:12,616 --> 00:05:13,996
You will see this
pattern throughout the


81
00:05:13,996 --> 00:05:14,906
Contacts Framework.


82
00:05:18,556 --> 00:05:21,516
For contact properties that
can have multiple values


83
00:05:21,876 --> 00:05:23,856
like e-mail addresses,
or phone numbers,


84
00:05:24,606 --> 00:05:27,446
an array of CNLabeledValue
is used.


85
00:05:28,996 --> 00:05:33,976
CNLabeledValue is an immutable
Tuple of label and value,


86
00:05:35,256 --> 00:05:38,276
where the label is a string,
and the value is an object.


87
00:05:38,726 --> 00:05:40,416
Like string for an
e-mail address.


88
00:05:42,596 --> 00:05:45,906
The value can be labeled
to help differentiate it


89
00:05:46,106 --> 00:05:47,806
from the multiple
values for a property,


90
00:05:48,916 --> 00:05:52,116
such as a home e-mail address,
or a work e-mail address.


91
00:05:53,096 --> 00:05:57,266
For those of you
experienced with Address Book,


92
00:05:58,036 --> 00:06:02,496
AB multivalue is replaced by
this array of CNLabeledValue.


93
00:06:03,526 --> 00:06:06,306
Yes, you heard that correctly,
AB multivalue is dead.


94
00:06:07,516 --> 00:06:11,546
[ Applause ]


95
00:06:12,046 --> 00:06:12,936
>> BRUCE STADNYK: Now I
would like to take a look


96
00:06:12,936 --> 00:06:15,656
at an example of creating a new
contact with John Appleseed.


97
00:06:16,606 --> 00:06:18,146
So first we import Contacts,


98
00:06:19,576 --> 00:06:21,596
then we create a
mutable contact,


99
00:06:21,596 --> 00:06:25,136
as we are going to
be adding to it.


100
00:06:25,386 --> 00:06:30,036
We then set John's profile
picture as NSData to imageData,


101
00:06:30,836 --> 00:06:35,116
and then we set his name to
givenName and familyName.


102
00:06:39,066 --> 00:06:41,106
Now, for John's two
e-mail addresses,


103
00:06:41,276 --> 00:06:45,816
we create two CNLabeled
values, one with CNLabelHome,


104
00:06:46,336 --> 00:06:47,816
the other with CNLabelWork.


105
00:06:48,816 --> 00:06:50,606
These are some of
the predefined labels


106
00:06:50,606 --> 00:06:51,766
in the Contacts Framework.


107
00:06:53,356 --> 00:06:55,576
These predefined labels
have localized strings


108
00:06:55,576 --> 00:06:57,316
that you can use
in your apps UI.


109
00:06:58,626 --> 00:07:00,536
You can also create
your own custom labels.


110
00:07:01,096 --> 00:07:05,766
We take these two label values,
home e-mail and work e-mail,


111
00:07:06,236 --> 00:07:09,156
place them in an array, and
set them on e-mail addresses.


112
00:07:09,776 --> 00:07:10,566
It's that simple.


113
00:07:13,166 --> 00:07:15,496
And we can do the same thing
with John's phone number.


114
00:07:16,056 --> 00:07:17,676
Again, we create
a CNLabeled value,


115
00:07:18,506 --> 00:07:23,526
use the iPhone predefined label,
create a CNPhoneNumber object


116
00:07:23,676 --> 00:07:27,376
as the value, place the
label value in array,


117
00:07:27,636 --> 00:07:28,896
and set that to phone numbers.


118
00:07:32,636 --> 00:07:35,536
I also know John's home address,
so I can add that as well.


119
00:07:35,536 --> 00:07:39,256
I create a
CNMuteablePostalAddress,


120
00:07:39,866 --> 00:07:42,306
set the appropriate information,


121
00:07:43,506 --> 00:07:46,056
again create a labeled
value using LabelHome,


122
00:07:46,726 --> 00:07:49,376
place that in array, and set
that to postal addresses.


123
00:07:53,296 --> 00:07:55,356
Finally, I also know
his birthday,


124
00:07:55,416 --> 00:07:58,696
so I can create an
NSDateComponent, set the day,


125
00:07:58,696 --> 00:07:59,816
month, and year component,


126
00:08:00,446 --> 00:08:01,886
and set that to the
birthday property.


127
00:08:03,156 --> 00:08:05,996
Note that all date-related
properties


128
00:08:06,076 --> 00:08:09,386
in the Contacts Framework
are NSDate components.


129
00:08:10,426 --> 00:08:14,366
This allows flexibility
to have dates


130
00:08:14,366 --> 00:08:15,596
such as year-less birthdays,


131
00:08:15,896 --> 00:08:17,366
where you would omit
the year component.


132
00:08:22,076 --> 00:08:25,456
The Contacts Framework is also
able to perform operations


133
00:08:25,456 --> 00:08:26,826
on these contact objects.


134
00:08:27,806 --> 00:08:30,966
Of interest here is
formatting contact data.


135
00:08:32,616 --> 00:08:35,956
The CNContactFormatter will
format a contact's name.


136
00:08:35,956 --> 00:08:38,905
In this example, we're
formatting the full name,


137
00:08:38,986 --> 00:08:40,275
and get back John Appleseed.


138
00:08:41,775 --> 00:08:44,486
CNContact Formatter
will correctly format


139
00:08:44,486 --> 00:08:45,486
international names.


140
00:08:48,036 --> 00:08:51,366
We also have a formatter,
CNPostalAddressFormatter


141
00:08:51,786 --> 00:08:54,496
for formatting mailing
labels for postal addresses.


142
00:08:55,816 --> 00:08:57,726
That returns back...that.


143
00:08:58,986 --> 00:09:02,896
CNPostalAddressFormatter will
correctly format international


144
00:09:03,276 --> 00:09:04,086
postal addresses.


145
00:09:05,186 --> 00:09:06,936
We recommend that you
use these Formatters


146
00:09:06,936 --> 00:09:08,356
in your app when appropriate.


147
00:09:11,676 --> 00:09:14,126
Now, I would like to
invite Dave up to the stage


148
00:09:14,126 --> 00:09:16,216
to show you how you can
use Contacts in your app.


149
00:09:17,516 --> 00:09:22,696
[ Applause ]


150
00:09:23,196 --> 00:09:23,906
>> DAVE DRIBIN: Thank
you, Bruce.


151
00:09:24,296 --> 00:09:29,516
My name is Dave Dribin, and I
work on the OS X Contacts team.


152
00:09:29,716 --> 00:09:33,716
Sorry. So Bruce just
showed you how to create


153
00:09:33,716 --> 00:09:35,976
and modify CNContact
objects in code.


154
00:09:36,896 --> 00:09:39,346
However, these already
has many contacts as part


155
00:09:39,346 --> 00:09:43,196
of the Contacts app of
OS X, iOS and watchOS.


156
00:09:44,086 --> 00:09:46,446
And Bruce also showed how
system apps can integrate


157
00:09:46,446 --> 00:09:49,816
with these contacts to provide
a richer user experience.


158
00:09:50,366 --> 00:09:53,116
For example, the phone app
can show the person's name


159
00:09:53,116 --> 00:09:54,636
and photo instead of
just a phone number,


160
00:09:55,326 --> 00:09:57,596
for an incoming phone call.


161
00:09:58,186 --> 00:10:00,096
The Contacts Framework
allows you to provide


162
00:10:00,096 --> 00:10:01,976
that same rich experience
for your app.


163
00:10:05,126 --> 00:10:06,116
So the class you
are going to use


164
00:10:06,116 --> 00:10:09,096
to access a user's contacts
is called CNContactStore.


165
00:10:09,096 --> 00:10:11,096
We are going to talk
about how to fetch


166
00:10:11,096 --> 00:10:12,596
and save users' contacts.


167
00:10:13,476 --> 00:10:14,406
Let's start off with fetching.


168
00:10:16,346 --> 00:10:17,216
The main method you are going


169
00:10:17,216 --> 00:10:20,926
to use is called unified
ContactsMatchingPredicate,


170
00:10:20,926 --> 00:10:21,636
keysToFetch.


171
00:10:22,226 --> 00:10:25,406
This is going to return an
array of CNContact objects.


172
00:10:25,956 --> 00:10:29,626
The predicate in Keys to
Fetch are there in order


173
00:10:29,626 --> 00:10:32,126
to help your app fetch as
efficiently as possible.


174
00:10:33,446 --> 00:10:34,526
Let's start off with
the predicate.


175
00:10:35,736 --> 00:10:38,636
The user might have hundreds,
or even thousands of contacts.


176
00:10:38,716 --> 00:10:41,486
You might only be interested
in a small subset of those.


177
00:10:42,566 --> 00:10:44,686
The predicate allows you to, ah,


178
00:10:44,686 --> 00:10:46,676
helps you limit the
number of results returned.


179
00:10:48,086 --> 00:10:49,276
Now, for those that don't know,


180
00:10:49,366 --> 00:10:51,896
NSPredicate is a standard
foundation-level object


181
00:10:51,896 --> 00:10:54,556
that presents criteria
to be matched


182
00:10:54,556 --> 00:10:55,956
against an object
while searching.


183
00:10:59,536 --> 00:11:02,936
The Contacts Framework
provides predicates you can use


184
00:11:02,936 --> 00:11:03,926
with the contact store.


185
00:11:03,986 --> 00:11:06,266
And the contacts store
will evaluate these


186
00:11:06,266 --> 00:11:08,166
against the predicate,
or the contact.


187
00:11:08,916 --> 00:11:12,066
The example here is predicate
ForContactsMatchingName.


188
00:11:13,046 --> 00:11:15,966
And this will match
each of the contacts


189
00:11:15,966 --> 00:11:18,146
against the specified name,
in this case Appleseed.


190
00:11:19,016 --> 00:11:19,936
Let's see a quick example.


191
00:11:23,226 --> 00:11:25,026
Say the user has
these three contacts.


192
00:11:25,196 --> 00:11:28,236
John Appleseed, Jane
Appleseed, and Craig Bromley.


193
00:11:29,556 --> 00:11:31,626
The contacts store can
effectively evaluate this


194
00:11:31,686 --> 00:11:33,646
predicate [John Appleseed]
against each


195
00:11:33,646 --> 00:11:34,356
of the contacts [Jane
Appleseed; Craig Bromley]


196
00:11:34,356 --> 00:11:36,256
and only return the
matching ones.


197
00:11:36,566 --> 00:11:38,036
In this case John
and Jane are going


198
00:11:38,036 --> 00:11:39,616
to be returned, but not Craig.


199
00:11:43,266 --> 00:11:45,336
So the predicate allows
you to limit the number


200
00:11:45,466 --> 00:11:47,416
of contacts returned,
but there's still a lot


201
00:11:47,416 --> 00:11:49,226
of contact information
on a contact,


202
00:11:49,226 --> 00:11:51,496
and you might only be interested
in a small subset of that,


203
00:11:52,436 --> 00:11:53,976
and that's where
keysToFetch comes in.


204
00:11:57,596 --> 00:12:00,246
KeysToFetch is an
array of strings.


205
00:12:00,606 --> 00:12:03,676
And these are strings of keys,
in the key-value-coding sense.


206
00:12:04,216 --> 00:12:06,466
So if you are just interested in
the given name and family name,


207
00:12:06,616 --> 00:12:08,446
you could set up your
keysToFetch like this.


208
00:12:09,256 --> 00:12:11,656
Of course, using string
literals is error prone.


209
00:12:11,786 --> 00:12:13,716
We provide constants for this.


210
00:12:16,346 --> 00:12:18,206
And what the Contact Store is
going to do is it's only going


211
00:12:18,206 --> 00:12:20,546
to fetch the properties
that you specify.


212
00:12:21,646 --> 00:12:23,636
In this case, given
name and family name.


213
00:12:24,626 --> 00:12:26,256
So you can really
see how the predicate


214
00:12:26,256 --> 00:12:28,386
in keysToFetch allows you
to scope down the amount


215
00:12:28,386 --> 00:12:30,256
of information to returned
so that your app can be


216
00:12:30,256 --> 00:12:31,486
as efficient as possible.


217
00:12:32,826 --> 00:12:33,876
Let's go over a full example.


218
00:12:33,876 --> 00:12:37,866
So here we are going to
start off with a predicate


219
00:12:37,866 --> 00:12:39,586
and keysToFetch as
we had earlier,


220
00:12:40,846 --> 00:12:42,606
but now you need a contacts
store to use these on.


221
00:12:42,976 --> 00:12:44,526
And this is easy, you
can just create one


222
00:12:44,626 --> 00:12:45,826
with the default initializer.


223
00:12:47,236 --> 00:12:49,716
Then you call unified
ContactsMatchingPredicate,


224
00:12:49,716 --> 00:12:52,366
keysToFetch with those values,
and assuming this works,


225
00:12:52,476 --> 00:12:55,016
you're going to get back
an array of contacts,


226
00:12:55,956 --> 00:12:57,286
and then you can use
them however you want.


227
00:12:57,286 --> 00:12:58,436
Here we are just going to print


228
00:12:58,436 --> 00:12:59,876
out the given name
and family name.


229
00:13:01,266 --> 00:13:02,576
There's a couple of
important things I want


230
00:13:02,576 --> 00:13:03,406
to talk about, about fetching.


231
00:13:04,036 --> 00:13:06,986
The first one is
that the lifetime


232
00:13:06,986 --> 00:13:08,676
of a CNContact is not tied


233
00:13:08,676 --> 00:13:10,586
to the lifetime of
a CNContact store.


234
00:13:10,586 --> 00:13:13,296
There is no need to keep a
strong reference to the Store


235
00:13:13,296 --> 00:13:15,256
around after the
fetch completes.


236
00:13:16,066 --> 00:13:19,096
It means the data on
the CNContact is, ah,


237
00:13:19,096 --> 00:13:22,166
valid and it is from the time of
the fetch, basically a snapshot


238
00:13:22,166 --> 00:13:23,976
from the time of the
fetch, and it is valid


239
00:13:23,976 --> 00:13:26,146
for the lifetime
of that CNContact.


240
00:13:27,116 --> 00:13:28,506
And the second important thing,


241
00:13:28,506 --> 00:13:30,006
is that this is a
synchronous method,


242
00:13:30,076 --> 00:13:32,906
and fetching contacts is a
relatively slow operation.


243
00:13:34,326 --> 00:13:37,826
As such, you should really fetch
these on a background queue,


244
00:13:38,986 --> 00:13:40,646
to keep your user
interface responsive.


245
00:13:41,896 --> 00:13:43,046
And as Bruce mentioned earlier,


246
00:13:43,046 --> 00:13:46,786
CNContacts are completely thread
safe, so it's safe to take these


247
00:13:46,786 --> 00:13:49,276
from the background queue, and
move them over to the main queue


248
00:13:49,276 --> 00:13:51,106
to update your user interface.


249
00:13:54,046 --> 00:13:55,376
And another really
good reason to fetch


250
00:13:55,376 --> 00:13:57,536
on a background queue
is data privacy.


251
00:14:02,796 --> 00:14:07,146
So, users take the privacy of
their contacts very seriously.


252
00:14:07,676 --> 00:14:10,886
And as such, we want to put
up a barrier between your app,


253
00:14:10,886 --> 00:14:12,006
and the users contacts.


254
00:14:13,476 --> 00:14:17,206
The very first time your
app accesses contacts


255
00:14:17,206 --> 00:14:20,236
through the API, the OS is
going to show a dialogue box


256
00:14:20,236 --> 00:14:22,836
or alert asking the user
to allow or deny access.


257
00:14:22,836 --> 00:14:23,986
You have probably
seen these before.


258
00:14:25,356 --> 00:14:27,666
This means that the first
time you call a method


259
00:14:27,666 --> 00:14:30,086
on the contacts store, it
cannot provide the results


260
00:14:30,446 --> 00:14:33,636
until the user responds,
and that can be a long time.


261
00:14:34,696 --> 00:14:38,006
So while you can move your
contacts store access off


262
00:14:38,006 --> 00:14:41,076
to a background queue
using GCD or NS operation,


263
00:14:41,526 --> 00:14:42,836
we provide a helper method here,


264
00:14:42,836 --> 00:14:44,726
an async method called
request access


265
00:14:44,726 --> 00:14:46,226
for entity type completion
handler.


266
00:14:46,756 --> 00:14:51,006
Now the user may deny access,
and your app should be able


267
00:14:51,006 --> 00:14:51,996
to handle this gracefully.


268
00:14:51,996 --> 00:14:54,526
And if the user allows access,


269
00:14:54,706 --> 00:14:56,766
be sure to handle this
contact data with care.


270
00:14:57,626 --> 00:14:59,356
Please see the privacy
in your app session


271
00:14:59,356 --> 00:14:59,906
for more information.


272
00:15:02,256 --> 00:15:05,156
I would like to talk a little
bit more about keysToFetch


273
00:15:05,156 --> 00:15:06,946
and how they return
partial contacts.


274
00:15:09,206 --> 00:15:11,636
So as I showed previously,
the keysToFetch allows you


275
00:15:11,636 --> 00:15:14,176
to only fetch the properties
you are interested in.


276
00:15:14,716 --> 00:15:17,526
In this case the given
name and family name.


277
00:15:17,676 --> 00:15:19,926
What if you tried to access a
property you didn't request--


278
00:15:20,036 --> 00:15:20,986
for example a phone number?


279
00:15:24,196 --> 00:15:26,086
It's going to throw
an exception,


280
00:15:26,166 --> 00:15:27,766
because that data is not there,


281
00:15:27,766 --> 00:15:30,336
and we call these partial
contacts because only some


282
00:15:30,336 --> 00:15:31,616
of the properties are available.


283
00:15:33,156 --> 00:15:35,086
Now normally this isn't
a problem if you set


284
00:15:35,086 --> 00:15:37,536
up your keysToFetch properly,as
we did in the previous examples,


285
00:15:38,086 --> 00:15:41,176
but there are times you
are going to get a contact,


286
00:15:41,176 --> 00:15:42,146
and you are unsure


287
00:15:42,146 --> 00:15:44,846
which keysToFetch was
used when it was fetched.


288
00:15:45,506 --> 00:15:47,356
In those cases, you are
going to want to check to see


289
00:15:47,356 --> 00:15:49,906
if the key is available
before accessing the property,


290
00:15:50,526 --> 00:15:51,726
just as you would
check the length


291
00:15:51,726 --> 00:15:54,096
of an array before indexing
into it, to avoid an exception.


292
00:15:55,186 --> 00:15:57,986
Here this example is using the
isKeyAvailable method to see


293
00:15:57,986 --> 00:15:59,596
if the PhoneNumbers
key is available


294
00:15:59,596 --> 00:16:01,216
for accessing the
phone numbers property.


295
00:16:01,216 --> 00:16:04,106
You might be thinking
"well, that's great,


296
00:16:04,106 --> 00:16:06,066
but I really wanted to
access those phone numbers."


297
00:16:06,836 --> 00:16:08,606
In those cases, you can
re-fetch the contact


298
00:16:08,606 --> 00:16:09,866
with the additional keysToFetch.


299
00:16:10,436 --> 00:16:11,536
Let's see how that would work.


300
00:16:12,406 --> 00:16:15,156
So, here we are setting
up keysToFetch,


301
00:16:15,156 --> 00:16:16,886
but this time we're using
the phone numbers key,


302
00:16:17,896 --> 00:16:21,206
and using a method called
unifiedContactWithIdentifier.


303
00:16:21,556 --> 00:16:23,776
Now each contact
has a identifier


304
00:16:23,776 --> 00:16:26,416
that uniquely identifies it,
and you can use to re-fetch


305
00:16:26,416 --> 00:16:29,336
at a later point in time.


306
00:16:29,336 --> 00:16:31,026
And then, once you re-fetch,


307
00:16:31,296 --> 00:16:32,696
you can safely access
the phone numbers


308
00:16:32,696 --> 00:16:33,796
on this re-fetched contact.


309
00:16:34,276 --> 00:16:37,306
In partial contacts
it's important


310
00:16:37,306 --> 00:16:39,746
to understand how they work
with the rest of the framework.


311
00:16:43,046 --> 00:16:45,476
Now, the previous example showed
how we fetched the given name


312
00:16:45,476 --> 00:16:46,836
and family name and
then printed them out,


313
00:16:47,256 --> 00:16:49,426
to print the full name, but
that's really not ideal.


314
00:16:49,426 --> 00:16:51,626
We should really use one
of the formatters, sorry,


315
00:16:51,776 --> 00:16:54,546
the CNContact formatter
that Bruce showed earlier,


316
00:16:54,586 --> 00:16:57,276
and the formatter may
access other properties


317
00:16:57,276 --> 00:16:59,496
that you haven't fetched,
like name, prefix, or suffix.


318
00:16:59,936 --> 00:17:01,766
If they're not there, it's
going to throw an exception.


319
00:17:02,406 --> 00:17:06,356
So, we could document all
the keys you need in order


320
00:17:06,356 --> 00:17:08,546
to use the formatter, but that's
rather tedious and error prone.


321
00:17:09,016 --> 00:17:11,306
So we've come up with the
concept of key descriptors.


322
00:17:12,556 --> 00:17:15,886
And key descriptors
represent a set of keys


323
00:17:16,165 --> 00:17:18,126
for a particular operation.


324
00:17:18,626 --> 00:17:20,736
In this case, the formatter
knows which keys it needs


325
00:17:20,736 --> 00:17:23,226
to do its job, so it is
providing the key descriptors


326
00:17:23,705 --> 00:17:26,175
with the descriptor
ForRequiredKeysForStyle method,


327
00:17:26,376 --> 00:17:28,396
and you can include this
directly in your keys to fetch.


328
00:17:29,346 --> 00:17:32,736
And this tells the contact
store all of the properties


329
00:17:32,736 --> 00:17:34,146
that it needs to fetch
for the formatter.


330
00:17:35,046 --> 00:17:36,226
Let's see an example of this.


331
00:17:36,226 --> 00:17:40,676
So in this example, we
want to fetch all contacts


332
00:17:40,676 --> 00:17:41,626
with the name Appleseed,


333
00:17:41,796 --> 00:17:44,356
and we want to print their
full name and e-mail addresses.


334
00:17:44,356 --> 00:17:47,336
We are going to set up the
predicate as we did before,


335
00:17:47,396 --> 00:17:49,526
and set up the keysToFetch
a little bit differently.


336
00:17:49,566 --> 00:17:53,686
We are going to start off with
descriptor for required keys


337
00:17:53,686 --> 00:17:55,156
for style (.FullName).


338
00:17:55,156 --> 00:17:58,066
And this is going to, uh,
allows us to get the full name,


339
00:17:58,106 --> 00:18:00,216
using the Contact
Formatter later on.


340
00:18:01,206 --> 00:18:04,816
You can also include the
CNContact e-mail addresses key,


341
00:18:04,816 --> 00:18:06,366
because we want to print
the e-mail addresses.


342
00:18:06,836 --> 00:18:09,116
You can intermix key descriptors


343
00:18:09,386 --> 00:18:11,786
and CNContact keys
in the same array.


344
00:18:12,416 --> 00:18:16,476
With this setup, you fetch,
just as we did before,


345
00:18:16,476 --> 00:18:18,516
calling unified contacts
matching predicate,


346
00:18:18,516 --> 00:18:21,886
and then with the results,
you can get the full name


347
00:18:21,886 --> 00:18:23,906
with the formatter and
the e-mail addresses.


348
00:18:26,476 --> 00:18:27,946
So one other important point


349
00:18:28,066 --> 00:18:30,216
about fetching is
unified contacts.


350
00:18:31,286 --> 00:18:33,676
You may have the same
contact in multiple accounts.


351
00:18:33,676 --> 00:18:35,096
For example, you might
have a John Appleseed


352
00:18:35,206 --> 00:18:37,506
in your iCloud account with
his work e-mail address


353
00:18:37,506 --> 00:18:39,536
and phone number, but
you might also be friends


354
00:18:39,536 --> 00:18:40,416
with John on Facebook.


355
00:18:40,416 --> 00:18:42,516
And that is going
to have an image,


356
00:18:42,966 --> 00:18:44,986
home e-mail address,
and birthday.


357
00:18:45,596 --> 00:18:48,056
So rather than display two
separate contacts there,


358
00:18:48,656 --> 00:18:51,256
the contacts app is going
to use some heuristics


359
00:18:51,256 --> 00:18:54,426
to link these together, and
display a single contact


360
00:18:54,426 --> 00:18:55,706
with the union of
the information,


361
00:18:55,706 --> 00:18:57,376
and we call these
unified contacts.


362
00:18:57,936 --> 00:19:00,286
And contacts apps
have been doing this


363
00:19:00,286 --> 00:19:01,186
for a few releases now.


364
00:19:02,206 --> 00:19:05,066
The Contacts Framework will
return unified contacts


365
00:19:05,066 --> 00:19:07,546
by default, as you may have
guessed from the method names.


366
00:19:08,806 --> 00:19:10,776
So the good news is, that
means that you're going


367
00:19:10,776 --> 00:19:13,166
to get the data back that
the user sees in the app.


368
00:19:14,276 --> 00:19:15,166
The really great thing here is


369
00:19:15,166 --> 00:19:17,676
that these are ordinary
CNContact objects, and they work


370
00:19:17,676 --> 00:19:19,736
and act just like any
other CNContact object.


371
00:19:20,526 --> 00:19:24,026
you can even modify them and
save them and it will just work.


372
00:19:25,456 --> 00:19:27,936
So speaking of saving, let's
go over a few code examples


373
00:19:28,366 --> 00:19:29,656
on how to save contacts.


374
00:19:29,916 --> 00:19:33,296
I'm going to start off
by adding a new contact.


375
00:19:35,086 --> 00:19:37,046
So let's say you've got
a C immutable contact,


376
00:19:37,046 --> 00:19:39,016
and you set it up with data,
as Bruce showed you earlier.


377
00:19:39,566 --> 00:19:41,996
In order to get this into the
user's contacts, you are going


378
00:19:41,996 --> 00:19:44,036
to use what's called a save
request, and you are going


379
00:19:44,036 --> 00:19:46,356
to execute that save
request on a contact store.


380
00:19:46,976 --> 00:19:51,496
The first thing you do is create
a new CNSaveRequest object,


381
00:19:51,496 --> 00:19:54,146
and then you are going
to call add contact,


382
00:19:54,146 --> 00:19:55,656
to container with identifier.


383
00:19:56,866 --> 00:19:58,726
Now we don't have time
to talk about containers,


384
00:19:59,216 --> 00:20:01,696
but the nil container identifier
means the default container,


385
00:20:02,066 --> 00:20:02,836
and, so please refer


386
00:20:02,836 --> 00:20:04,326
to the documentation
for more information.


387
00:20:04,606 --> 00:20:08,056
And save request just marks
a contact for being added.


388
00:20:08,056 --> 00:20:10,106
It doesn't actually
apply this change yet.


389
00:20:10,476 --> 00:20:12,296
For that you need to
call execute SaveRequest


390
00:20:12,326 --> 00:20:13,296
on a contacts store.


391
00:20:13,796 --> 00:20:16,446
Assuming this completes
successfully, this will be added


392
00:20:16,446 --> 00:20:17,406
to the user's contacts.


393
00:20:21,076 --> 00:20:23,696
Updating an existing
contact is very similar,


394
00:20:23,696 --> 00:20:25,476
but now you are going to
be starting off with, say,


395
00:20:25,476 --> 00:20:27,656
an immutable contact that
you got from a fetch.


396
00:20:29,136 --> 00:20:30,206
So, the first thing
you are going to want


397
00:20:30,206 --> 00:20:32,236
to do is create a mutable copy,


398
00:20:32,816 --> 00:20:34,286
and then make any
changes you want.


399
00:20:34,286 --> 00:20:36,846
For example, here we are
adding in a new e-mail address.


400
00:20:36,846 --> 00:20:39,066
Now, it is important
to note that,


401
00:20:39,066 --> 00:20:41,706
when you make a mutable
copy of a partial contact,


402
00:20:42,096 --> 00:20:45,536
only modify the property
that you had fetched.


403
00:20:49,086 --> 00:20:51,366
And just as before, we
need to use a save request.


404
00:20:52,276 --> 00:20:54,036
Create a new save request,
but this time we are going


405
00:20:54,036 --> 00:20:55,486
to use the updateContact method.


406
00:20:56,616 --> 00:20:58,816
And again, this just marks
the contact for being updated,


407
00:20:58,816 --> 00:21:00,266
and doesn't actually
apply those changes


408
00:21:00,976 --> 00:21:02,676
until you call
executeSaveRequest.


409
00:21:03,276 --> 00:21:07,036
And, a couple of important
things about saving.


410
00:21:07,606 --> 00:21:10,786
Number one is that the save
request can include multiple


411
00:21:10,786 --> 00:21:12,686
changes, and when
you execute it,


412
00:21:12,686 --> 00:21:14,896
all of them will be
applied during, um,


413
00:21:14,896 --> 00:21:15,836
when it gets executed.


414
00:21:16,406 --> 00:21:21,336
And the second is that the
save request requires mutable


415
00:21:21,336 --> 00:21:23,566
contacts, so you want
to be careful not


416
00:21:23,566 --> 00:21:25,966
to access these mutable
contacts on another thread,


417
00:21:26,056 --> 00:21:26,976
while a save is in process.


418
00:21:29,316 --> 00:21:30,966
So now that you know
how to fetch


419
00:21:31,256 --> 00:21:34,976
and save a user's contacts,
I'll invite Julien up on stage


420
00:21:34,976 --> 00:21:37,456
to talk about using contacts
in the user interface.


421
00:21:39,516 --> 00:21:43,106
[ Applause ]


422
00:21:43,606 --> 00:21:45,166
>> JULIEN ROBERT:
Thank you, Dave.


423
00:21:47,356 --> 00:21:48,606
Good afternoon.


424
00:21:48,606 --> 00:21:51,686
I'm Julien and I'm an engineer
in the iOS contacts team.


425
00:21:52,676 --> 00:21:57,296
And now that Bruce and
Dave made you experts


426
00:21:57,296 --> 00:22:00,886
in the Contacts Framework, I
will talk about user interface


427
00:22:01,616 --> 00:22:06,186
and show you how to pick and
display contacts in your app.


428
00:22:07,576 --> 00:22:10,276
Coming along with Contacts
Framework we have a new UI


429
00:22:10,366 --> 00:22:13,416
Framework called contacts UI.


430
00:22:13,416 --> 00:22:17,946
It is available on both
iOS 9 and OS X El Capitan.


431
00:22:18,996 --> 00:22:23,406
This provides you with two
clusters, first the picker,


432
00:22:23,646 --> 00:22:27,146
which displays a list of
all the users contacts,


433
00:22:27,146 --> 00:22:30,136
to let him selectively
import contact information


434
00:22:30,136 --> 00:22:31,586
into your app.


435
00:22:32,286 --> 00:22:35,136
And secondly, the
contact view controller,


436
00:22:35,546 --> 00:22:37,186
which is used to
display a contact.


437
00:22:37,846 --> 00:22:40,536
In the rest of this
presentation I will talk


438
00:22:40,536 --> 00:22:42,846
about the iOS version
of the classes,


439
00:22:43,696 --> 00:22:46,626
but the OS X counterparts
are pretty similar.


440
00:22:47,306 --> 00:22:50,846
Let's talk about
picking contact first.


441
00:22:51,756 --> 00:22:54,416
The class you use for
that is CNContact Picker


442
00:22:54,416 --> 00:22:55,166
View Controller.


443
00:22:56,016 --> 00:22:58,896
It is a direct replacement
of the class we had


444
00:22:58,946 --> 00:23:03,276
in Address Book UI, AB People
Picker Navigation Controller.


445
00:23:04,616 --> 00:23:08,206
As you can guess by its
name, it is a direct subclass


446
00:23:08,206 --> 00:23:11,546
of UA View Controller but
you still must present it,


447
00:23:11,646 --> 00:23:13,696
and not push it in a
navigation controller.


448
00:23:15,296 --> 00:23:17,736
It is always out of process.


449
00:23:18,076 --> 00:23:22,186
It has the great advantage
of not requiring the user


450
00:23:22,246 --> 00:23:25,146
to let your app access
its contacts.


451
00:23:26,196 --> 00:23:29,266
So when you present
a contact picker,


452
00:23:29,266 --> 00:23:32,976
you will never see the dialogue
that Bruce -- that Dave showed.


453
00:23:35,656 --> 00:23:36,866
One thing that is important is


454
00:23:36,866 --> 00:23:39,566
that the contact picker may
return partial contacts.


455
00:23:40,016 --> 00:23:42,996
For example, if you
set a limited set


456
00:23:43,426 --> 00:23:47,506
of displayed property keys,
you will only get those keys


457
00:23:47,986 --> 00:23:49,516
in the contact that
you get back.


458
00:23:50,256 --> 00:23:54,556
And the behavior of the picker
is defined by two things,


459
00:23:55,166 --> 00:23:58,656
first the delegate method that
you implement, and second,


460
00:23:58,656 --> 00:24:00,636
the predicate that
you set on it.


461
00:24:00,946 --> 00:24:03,486
And we are going to talk
about those just after.


462
00:24:04,386 --> 00:24:06,536
But last but not
least the picker must


463
00:24:06,536 --> 00:24:07,856
support multiselection.


464
00:24:09,516 --> 00:24:13,246
[ Applause ]


465
00:24:13,746 --> 00:24:16,016
>> JULIEN ROBERT: Let's talk
about the delegate method first.


466
00:24:17,336 --> 00:24:20,326
So if your app is interested
by a single contact,


467
00:24:20,326 --> 00:24:23,856
and you want have this
familiar look of the picker,


468
00:24:24,856 --> 00:24:28,516
you simply need to implement
the didSelectContact delegate


469
00:24:28,516 --> 00:24:31,596
method, and you get
a CNContact back.


470
00:24:32,286 --> 00:24:34,496
So again, these contacts
may be partial.


471
00:24:35,116 --> 00:24:38,536
If you are interested
in a single property,


472
00:24:39,086 --> 00:24:41,646
you implement a did Select
Contact Property delegate


473
00:24:41,646 --> 00:24:44,546
method, and you get a
CNContactProperty object.


474
00:24:45,536 --> 00:24:48,016
So, this object is actually
from the Contacts Framework


475
00:24:48,016 --> 00:24:50,876
but we haven't seen it
before, so let's take a look.


476
00:24:52,386 --> 00:24:55,506
It is a simple wrapper class
that contains the contact


477
00:24:55,536 --> 00:24:59,266
that was selected, as well
as the key of the property


478
00:24:59,266 --> 00:25:00,886
that was selected by the user.


479
00:25:01,606 --> 00:25:04,786
Its value and potentially,
the identifier,


480
00:25:04,786 --> 00:25:07,736
is the property,
is labeled value.


481
00:25:10,046 --> 00:25:15,716
But you may also be interested
in having multiple contacts.


482
00:25:15,716 --> 00:25:18,256
And you would get
this appearance.


483
00:25:19,366 --> 00:25:20,666
To do that is very simple.


484
00:25:20,666 --> 00:25:24,566
You just implement the
didSelectContact delegate


485
00:25:24,566 --> 00:25:26,776
method, and you get as expected,


486
00:25:26,776 --> 00:25:28,676
an array of sent
contact objects.


487
00:25:30,056 --> 00:25:34,776
This also works for properties,
you can get multiple of them


488
00:25:34,776 --> 00:25:37,446
by implementing the
didSelectContactProperties


489
00:25:38,186 --> 00:25:41,626
delegate method, and get an
array of CNContact properties.


490
00:25:43,186 --> 00:25:43,486
All right.


491
00:25:44,766 --> 00:25:46,326
So now let's talk
about predicates.


492
00:25:46,906 --> 00:25:50,766
Predicates lets you customize
the behavior of the panel


493
00:25:50,766 --> 00:25:53,206
and we have three of them.


494
00:25:53,706 --> 00:25:56,356
The first one is predicate
for enabling contact.


495
00:25:57,066 --> 00:26:01,326
This lets you decide which
contacts are available


496
00:26:01,326 --> 00:26:02,706
to the user and which are not.


497
00:26:03,426 --> 00:26:05,946
If I take the example
that we've seen earlier,


498
00:26:05,946 --> 00:26:09,716
and if you want a user
to only select members


499
00:26:09,716 --> 00:26:12,176
of the Parker family,
for example,


500
00:26:12,676 --> 00:26:16,026
you would create a predicate
where you want to match contacts


501
00:26:16,026 --> 00:26:17,826
with the Parker family name.


502
00:26:17,896 --> 00:26:22,136
You set it as a
predicateForEnablingContact.


503
00:26:22,756 --> 00:26:24,606
And once the picker
is represented,


504
00:26:24,606 --> 00:26:28,326
you can see that you
can only select people


505
00:26:28,326 --> 00:26:30,486
with the Parker family name.


506
00:26:31,636 --> 00:26:36,526
The second one that we have is
predicate ForSelectionOfContact.


507
00:26:37,366 --> 00:26:41,706
This one is evaluated when the
user will tap on the contact.


508
00:26:42,306 --> 00:26:43,866
And if it evaluates to true,


509
00:26:43,866 --> 00:26:46,166
then the contact is
returned to your app.


510
00:26:46,596 --> 00:26:50,576
Otherwise we will
display the contact card.


511
00:26:50,806 --> 00:26:52,876
Similarly for properties
we have predicate


512
00:26:52,876 --> 00:26:54,286
ForSelectionOf Property.


513
00:26:55,386 --> 00:26:58,916
And if it evaluates to true,
the property that is tapped


514
00:26:58,916 --> 00:27:01,246
by the user will be
returned to your app,


515
00:27:01,566 --> 00:27:03,646
otherwise the default
action will be performed,


516
00:27:04,006 --> 00:27:06,826
such as making a phone call
or creating a new e-mail.


517
00:27:08,026 --> 00:27:11,376
One thing to note is that this
last predicate is evaluated


518
00:27:11,376 --> 00:27:13,186
on [the] CNContactProperty
object,


519
00:27:13,726 --> 00:27:17,456
whereas the first two are
evaluated on CNContact objects.


520
00:27:17,456 --> 00:27:22,586
I would like to point out
that you need to be coherent


521
00:27:23,026 --> 00:27:24,916
between the predicates you set


522
00:27:24,916 --> 00:27:26,766
and the delegate methods
that you implement.


523
00:27:27,226 --> 00:27:29,796
For example, you should only
implement the didSelectContact


524
00:27:29,796 --> 00:27:33,726
delegate method, but set
the predicate for selection


525
00:27:33,876 --> 00:27:37,816
of property predicate, then,
doesn't really make sense,


526
00:27:37,816 --> 00:27:40,406
and you would see a log, and
your predicate will be ignored.


527
00:27:44,046 --> 00:27:46,956
Right, so now that you
know how to pick contacts,


528
00:27:46,956 --> 00:27:48,806
let's talk about
viewing them in your app.


529
00:27:49,946 --> 00:27:51,886
So we now have just one class


530
00:27:51,886 --> 00:27:56,796
to replace the three classes
what we had in Address Book UI.


531
00:27:56,996 --> 00:27:59,856
But you can still get the
behavior that you want


532
00:28:00,446 --> 00:28:02,726
by using the appropriate
creation method.


533
00:28:04,336 --> 00:28:07,546
The first one is
viewControllerForContact,


534
00:28:07,916 --> 00:28:11,646
which would give you a view
controller that is the same


535
00:28:11,706 --> 00:28:14,946
as in contacts app, iPhone app.


536
00:28:15,856 --> 00:28:18,386
If you want to create
a new contact,


537
00:28:18,386 --> 00:28:20,266
you can use
viewControllerForNewContact,


538
00:28:20,266 --> 00:28:24,416
and you get this View Controller
which is always in editing mode.


539
00:28:25,106 --> 00:28:28,906
And lastly, if you
have a contact that is


540
00:28:28,906 --> 00:28:32,296
from an unknown origin, such
as a vCard, for example,


541
00:28:32,656 --> 00:28:34,496
you use
viewControllerForUnknownContact.


542
00:28:35,506 --> 00:28:40,056
One thing we've added in iOS 9
is this update contact button


543
00:28:40,666 --> 00:28:42,816
which will be displayed
automatically


544
00:28:43,046 --> 00:28:44,606
if there is already a contact


545
00:28:44,606 --> 00:28:46,906
in the user's contact
matching the name


546
00:28:47,326 --> 00:28:48,666
of the contact you
are displaying.


547
00:28:49,056 --> 00:28:53,056
And if the user taps on
it, it will display the UI


548
00:28:53,056 --> 00:28:55,266
to update the existing contact
with the new information.


549
00:28:55,766 --> 00:29:01,156
This Contact View Controller
is now always out of process,


550
00:29:01,806 --> 00:29:03,036
and the reason for that is


551
00:29:03,476 --> 00:29:05,796
that we may add some
additional information


552
00:29:06,216 --> 00:29:11,046
such as contacts data
that was found in mail.


553
00:29:11,246 --> 00:29:14,246
And as Dave pointed
out, it is important


554
00:29:14,436 --> 00:29:17,636
to fetch the contacts
using the right keys.


555
00:29:18,456 --> 00:29:21,006
So if you want to display it in
the Contacts View Controller,


556
00:29:21,006 --> 00:29:24,496
it must be fetched using the
descriptorForRequiredKeys


557
00:29:24,636 --> 00:29:25,856
of the Contacts View Controller.


558
00:29:28,536 --> 00:29:32,076
So let's look at a quick
code example on how


559
00:29:32,076 --> 00:29:34,496
to display a contact
from an identifier.


560
00:29:35,456 --> 00:29:37,566
First you would fetch
the contact


561
00:29:37,566 --> 00:29:39,626
with the
descriptorForRequiredKeys


562
00:29:39,826 --> 00:29:41,166
of the Contact View Controller.


563
00:29:42,746 --> 00:29:47,406
Then you create the Contact
View Controller with forContact,


564
00:29:47,506 --> 00:29:51,846
because we want a regular look
at the Contact View Controller.


565
00:29:51,846 --> 00:29:55,386
If you already have a contact
store, you should set it


566
00:29:55,386 --> 00:29:58,736
to the Contacts View Controller
so that we can reuse it.


567
00:29:59,286 --> 00:30:01,086
Set self as a delegate.


568
00:30:02,326 --> 00:30:03,816
Push the View Controller.


569
00:30:04,306 --> 00:30:07,706
And then in your delegate
method you will get called


570
00:30:07,706 --> 00:30:09,136
when the contact is modified.


571
00:30:09,766 --> 00:30:13,556
Alright, so it is nice
to look at a code sample,


572
00:30:13,556 --> 00:30:17,846
but what is better is [to]
build an app together,


573
00:30:18,556 --> 00:30:19,746
let's do that now.


574
00:30:24,046 --> 00:30:27,006
And the app we are going
to build is called Meow.


575
00:30:27,946 --> 00:30:32,406
And it's an app that lets
you share your emotions


576
00:30:32,566 --> 00:30:35,976
with your friends by
sending them cat sounds.


577
00:30:38,046 --> 00:30:43,086
So if I run the app, you can see
at the top is a mood selector.


578
00:30:43,086 --> 00:30:47,276
And then at the bottom is your
friends list, which is empty


579
00:30:47,276 --> 00:30:49,386
for now, and this is what
we are going to build now.


580
00:30:50,836 --> 00:30:54,386
The app is using an e-mail
address to send the cat sounds.


581
00:30:55,556 --> 00:31:00,026
So what we need is just a
nickname and e-mail address.


582
00:31:00,026 --> 00:31:04,716
So if I hit save,
nothing happens


583
00:31:04,716 --> 00:31:06,666
because it is not
implemented yet.


584
00:31:06,976 --> 00:31:09,996
So this is what we
are going to do.


585
00:31:10,236 --> 00:31:14,616
When I hit save, this
addBuddy function is called,


586
00:31:14,616 --> 00:31:16,566
and we will implement it now.


587
00:31:17,836 --> 00:31:19,816
First we create a
mutable contact


588
00:31:19,816 --> 00:31:21,596
because we are going
to modify it.


589
00:31:22,066 --> 00:31:25,186
Then we set the nickname to be
the value from the text field.


590
00:31:25,186 --> 00:31:30,736
The emailAddresses
property is set as an array


591
00:31:31,366 --> 00:31:33,316
of a single label value.


592
00:31:33,846 --> 00:31:36,386
We have the value being
from the text field.


593
00:31:36,386 --> 00:31:41,306
And finally we add this new
contact to our list of contacts.


594
00:31:42,326 --> 00:31:45,686
So let's run and see
how it works now.


595
00:31:48,406 --> 00:31:51,756
So I'm going to use prefilled
values, and add Emily


596
00:31:51,756 --> 00:31:55,096
to my friends, OK, my family.


597
00:31:55,986 --> 00:31:58,246
You can notice this
info button here.


598
00:31:58,246 --> 00:32:00,656
And we want to show
the contact view


599
00:32:01,036 --> 00:32:02,866
when we click on
this info button.


600
00:32:04,156 --> 00:32:05,946
So this is what we are
going to implement now.


601
00:32:09,056 --> 00:32:13,866
So when I tap this button, the
showContact function is called.


602
00:32:14,516 --> 00:32:17,006
So let's fill it in.


603
00:32:17,836 --> 00:32:21,106
First we create a Contact View
Controller for the contact


604
00:32:21,416 --> 00:32:24,646
that was, ah, that
we want to show.


605
00:32:25,236 --> 00:32:28,126
Then we set the contacts store
to the one we already have.


606
00:32:28,126 --> 00:32:30,906
And finally, we push
the View Controller.


607
00:32:34,836 --> 00:32:39,826
Let's just try, and okay, we
can see the info for Emily.


608
00:32:40,596 --> 00:32:44,266
Great. But what if we want
to add a contact in our list,


609
00:32:44,596 --> 00:32:46,326
that is already in
the user's contacts?


610
00:32:47,436 --> 00:32:49,366
So this is what we
are going to do here.


611
00:32:49,366 --> 00:32:52,516
And for that we are going
to use the contact picker.


612
00:32:53,226 --> 00:32:58,896
So this function is called
when I tap on addFromContacts.


613
00:32:58,896 --> 00:33:01,226
And I am going to
implement it now.


614
00:33:01,696 --> 00:33:07,566
First thing I'm doing is create
the contact picker controller.


615
00:33:08,206 --> 00:33:10,956
Then since we are only
interested in e-mail addresses,


616
00:33:11,666 --> 00:33:14,636
I limit the properties
to e-mail addresses.


617
00:33:16,256 --> 00:33:23,386
Then we want, ah, to, the user
to select contacts who have only


618
00:33:23,896 --> 00:33:25,756
at least one e-mail address.


619
00:33:25,886 --> 00:33:29,056
We see this is the part of the
predicate that is doing that.


620
00:33:29,546 --> 00:33:32,406
And who are not already
in our list of friends,


621
00:33:32,606 --> 00:33:36,046
because we don't
want duplicates.


622
00:33:36,046 --> 00:33:38,916
Finally, is the user,
is contact already,


623
00:33:39,206 --> 00:33:42,566
[who] has exactly one e-mail
address, we don't need


624
00:33:42,566 --> 00:33:45,216
to push the [card?], We want
it to be written directly.


625
00:33:46,026 --> 00:33:48,436
This is what this
predicate is doing.


626
00:33:48,876 --> 00:33:53,616
We set ourself as a delegate and
we present the View Controller.


627
00:33:55,356 --> 00:34:01,206
We also need delegate methods
where we add the new contact


628
00:34:01,206 --> 00:34:02,326
to our list of contacts.


629
00:34:03,596 --> 00:34:04,976
So it is straight now.


630
00:34:05,456 --> 00:34:11,676
And if I select John Appleseed,
I know he has two e-mails.


631
00:34:12,366 --> 00:34:14,396
So the contact card is pushed.


632
00:34:14,956 --> 00:34:17,556
I would select one e-mail,
and we have John in our list.


633
00:34:19,016 --> 00:34:22,166
If I add a new contact,
first you can see


634
00:34:22,166 --> 00:34:24,456
that now John Appleseed
is unavailable


635
00:34:24,456 --> 00:34:26,396
because he is already
in my friends list.


636
00:34:27,306 --> 00:34:31,116
But if I select David, he
just has one e-mail address.


637
00:34:31,116 --> 00:34:32,696
So the contact is
returned directly.


638
00:34:33,266 --> 00:34:38,456
So what happens if I want
to show the card for John?


639
00:34:39,696 --> 00:34:41,045
So we have an exception.


640
00:34:41,545 --> 00:34:44,876
And the reason is that
because we were not careful


641
00:34:45,306 --> 00:34:48,815
when presenting the
contact here,


642
00:34:49,056 --> 00:34:53,456
because the contact picker
returned the partial contacts,


643
00:34:53,456 --> 00:34:56,146
it is missing some keys for
the Contact View Controller.


644
00:34:56,146 --> 00:35:03,266
So we are going to fix
that by first checking


645
00:35:03,266 --> 00:35:05,836
if the contact has the
required keys to be used


646
00:35:06,296 --> 00:35:07,996
in the Contact View Controller.


647
00:35:08,426 --> 00:35:12,516
And if he does, we just use
the code that we had before.


648
00:35:13,306 --> 00:35:16,586
But if he does not, we
will first ask the Store


649
00:35:16,586 --> 00:35:18,626
to request access for contacts.


650
00:35:19,846 --> 00:35:23,426
If the user grants access,
we are going to have


651
00:35:23,526 --> 00:35:27,026
to re-fetch the contact
using its identifier.


652
00:35:27,026 --> 00:35:32,236
And this time using the
keysToFetch, the descriptor


653
00:35:32,236 --> 00:35:35,536
for recorded keys of the
CNContactViewController.


654
00:35:36,766 --> 00:35:40,306
Then we call the same
function again but this time


655
00:35:40,306 --> 00:35:45,266
with our complete
contacts ready to be used.


656
00:35:45,266 --> 00:35:48,966
So let's try again.


657
00:35:48,966 --> 00:35:52,136
So if I view the
contact card for Emily,


658
00:35:52,886 --> 00:35:54,186
we have no dialogue showing


659
00:35:54,186 --> 00:35:58,936
up because Emily
was created in code.


660
00:35:58,936 --> 00:36:00,366
So she has all the fetch keys.


661
00:36:00,946 --> 00:36:04,776
If I do the same on John,
I re-fetch is necessary.


662
00:36:05,526 --> 00:36:08,206
So at this point your app will
access the user's contact.


663
00:36:09,476 --> 00:36:12,846
So we say okay, and we can see
all the contact information


664
00:36:12,906 --> 00:36:13,306
for John.


665
00:36:13,306 --> 00:36:13,946
All right.


666
00:36:15,736 --> 00:36:19,276
So this concludes our demo.


667
00:36:19,546 --> 00:36:20,946
Which makes me a bit sad.


668
00:36:20,946 --> 00:36:24,246
So I will share my
emotions with John.


669
00:36:24,246 --> 00:36:25,976
(Sound of cat crying.)


670
00:36:26,516 --> 00:36:31,946
[ Applause ]


671
00:36:32,446 --> 00:36:33,936
>> JULIEN ROBERT: And
I will call Bruce back


672
00:36:34,236 --> 00:36:35,416
to conclude this presentation.


673
00:36:39,576 --> 00:36:40,926
>> BRUCE STADNYK: Thank
you, Dave and Julien


674
00:36:40,926 --> 00:36:44,626
for showing us how to
use contacts in our apps.


675
00:36:45,676 --> 00:36:49,396
So you now have an Objective-C
API to access contacts,


676
00:36:49,856 --> 00:36:53,406
and it works well with Swift.


677
00:36:54,056 --> 00:36:58,116
The Contacts API is the same
across multiple Apple platforms.


678
00:36:58,916 --> 00:37:01,976
Address book is being
deprecated,


679
00:37:02,116 --> 00:37:03,446
so start adopting now.


680
00:37:07,456 --> 00:37:10,296
For more information you
can refer to the contacts


681
00:37:10,296 --> 00:37:12,306
in ContactsUI Framework
References


682
00:37:12,816 --> 00:37:13,976
on the developer library.


683
00:37:13,976 --> 00:37:18,966
For technical support you can
go to the Developer Forums,


684
00:37:20,036 --> 00:37:22,186
and for general inquiries,
Paul loves e-mail,


685
00:37:22,186 --> 00:37:25,536
so you can e-mail him, and he's
our app Frameworks evangelist.


686
00:37:26,106 --> 00:37:26,526
Thank you


687
00:37:27,016 --> 00:37:29,000
[ Applause ]

