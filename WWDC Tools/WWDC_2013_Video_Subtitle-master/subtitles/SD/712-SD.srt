1
00:00:00,506 --> 00:00:09,856
[ Silence ]


2
00:00:10,356 --> 00:00:13,816
>> Good morning.


3
00:00:13,886 --> 00:00:15,026
My name is Matt Jacobson.


4
00:00:15,026 --> 00:00:17,716
I'm on the OS X Performance Team
at Apple, and I want to talk


5
00:00:17,716 --> 00:00:21,096
to you today about
Energy and Battery Life.


6
00:00:21,636 --> 00:00:23,046
You've probably heard a lot


7
00:00:23,046 --> 00:00:26,136
about battery life
this week at WWDC.


8
00:00:26,946 --> 00:00:28,936
Battery life is really
important to us.


9
00:00:28,936 --> 00:00:31,666
And hopefully by now
we've convinced you


10
00:00:31,666 --> 00:00:35,326
that not only do you want
your apps to work great


11
00:00:35,326 --> 00:00:39,666
and look great and for your
users to love how they work


12
00:00:39,666 --> 00:00:42,906
and feel, but you want
them to be able to use them


13
00:00:42,906 --> 00:00:45,786
and still get great
battery life.


14
00:00:47,006 --> 00:00:51,526
And here's something
you probably don't want.


15
00:00:51,696 --> 00:00:55,696
Users using their machine on
battery, as I see a lot of you


16
00:00:55,846 --> 00:00:58,486
out there are right now.


17
00:00:58,526 --> 00:01:02,716
If it's the middle of the week,
they see "Oh, the battery is low


18
00:01:02,766 --> 00:01:05,946
and I'll open up the battery
status menu and see what's going


19
00:01:05,946 --> 00:01:08,736
on and there's some app that's
hogging all the energy."


20
00:01:09,226 --> 00:01:12,836
Well, you really don't
want that to be your app.


21
00:01:14,936 --> 00:01:19,126
So, I want to talk to you
about some simple ways


22
00:01:19,276 --> 00:01:22,066
that you can make sure your
app is as energy efficient


23
00:01:22,066 --> 00:01:25,246
as possible so you can avoid
being the energy hogger


24
00:01:25,246 --> 00:01:25,896
on the system.


25
00:01:25,896 --> 00:01:30,336
I want to talk about some new
tools and features in Mavericks


26
00:01:30,336 --> 00:01:34,126
and Xcode 5 to help
recognize energy issues.


27
00:01:34,316 --> 00:01:37,006
I want to talk about how


28
00:01:37,006 --> 00:01:39,146
to diagnose those issues
once you've found them.


29
00:01:39,226 --> 00:01:44,326
I want to talk about
a few common mistakes


30
00:01:44,326 --> 00:01:47,846
that you can make that make
your app less energy efficient,


31
00:01:48,606 --> 00:01:49,506
and how to avoid them.


32
00:01:49,506 --> 00:01:54,776
And I want to talk about how
to adopt some best practices


33
00:01:54,776 --> 00:01:57,306
and new APIs for
energy efficiency.


34
00:01:57,836 --> 00:02:02,606
But first, let's start
with some background.


35
00:02:03,206 --> 00:02:07,626
What are the things that your
app can do to use energy?


36
00:02:08,446 --> 00:02:11,826
Well there are mainly
three, running on the CPU,


37
00:02:13,536 --> 00:02:18,236
doing I/O to the
network or a local disk,


38
00:02:18,406 --> 00:02:19,726
or using the graphic system.


39
00:02:20,516 --> 00:02:24,356
Now, the distribution
of how much power each


40
00:02:24,356 --> 00:02:27,026
of these uses varies
from system to system.


41
00:02:27,306 --> 00:02:31,076
But in all cases,
the CPU can dominate.


42
00:02:32,376 --> 00:02:36,596
So let's talk about the CPU.


43
00:02:37,826 --> 00:02:43,346
Now, you might think that with
our CPUs and our modern Macs


44
00:02:43,346 --> 00:02:46,356
with really high clock
speeds and lots of cores


45
00:02:46,356 --> 00:02:48,166
and multiple threads per core


46
00:02:48,476 --> 00:02:50,846
that CPU time is
basically unlimited,


47
00:02:50,846 --> 00:02:52,756
and in a lot of ways
that's true.


48
00:02:54,086 --> 00:02:57,666
But CPU time is still
limited in one major way,


49
00:02:57,706 --> 00:03:00,266
and that's by the
size of the battery.


50
00:03:01,156 --> 00:03:05,446
And this is important
for two reasons.


51
00:03:05,566 --> 00:03:09,566
One, the OS is designed
to give you basically


52
00:03:09,566 --> 00:03:12,046
as much CPU time as you ask for.


53
00:03:12,616 --> 00:03:20,596
And a single bad app, a single
app that is using too much CPU,


54
00:03:20,596 --> 00:03:21,946
it is not energy efficient,


55
00:03:22,596 --> 00:03:27,616
can totally ruin the user's
battery life and here's why.


56
00:03:29,096 --> 00:03:34,206
The CPUs in our Macs, especially
the new Haswell ULT CPUs


57
00:03:34,206 --> 00:03:38,206
in our new MacBook Airs
use a lot more power


58
00:03:38,696 --> 00:03:40,426
when they're running
compared to when they're idle.


59
00:03:40,426 --> 00:03:41,096
We're really good


60
00:03:41,096 --> 00:03:44,516
about aggressively power
managing these CPUs.


61
00:03:44,516 --> 00:03:46,156
But when they have to run code,


62
00:03:46,466 --> 00:03:48,506
they run at a much
higher power state.


63
00:03:49,106 --> 00:03:52,706
For example, if your app
is using 1 percent CPU,


64
00:03:53,456 --> 00:03:57,036
the power draw from the CPU
increases by 10 percent.


65
00:03:58,196 --> 00:03:59,376
That's just for 1 percent.


66
00:04:00,666 --> 00:04:04,966
If you're using 10 percent, the
power draw from the CPU doubles.


67
00:04:05,556 --> 00:04:10,516
And if you have a thread that's
going full bore using 100


68
00:04:10,516 --> 00:04:14,276
percent CPU time, the
CPU can draw 10 times


69
00:04:14,276 --> 00:04:19,495
as much power compared
to idle or more.


70
00:04:19,716 --> 00:04:24,436
So, how do you use the CPU
responsibly in your app?


71
00:04:25,846 --> 00:04:27,636
Well, the main thing is this.


72
00:04:28,766 --> 00:04:30,256
You should strive for your app


73
00:04:30,426 --> 00:04:34,506
to be absolutely idle
when it's not in use.


74
00:04:35,806 --> 00:04:39,876
So, that means eliminating
any work that's not driven


75
00:04:39,876 --> 00:04:40,336
by the user.


76
00:04:40,336 --> 00:04:45,406
So work done in response to
timers, work done in response


77
00:04:45,406 --> 00:04:48,206
to chatting network,
work done in response


78
00:04:48,206 --> 00:04:50,396
to inter-process
communication of any kind.


79
00:04:50,976 --> 00:04:57,086
It means eliminating things
like persistent animations.


80
00:04:58,106 --> 00:04:59,816
These things are
relatively cheap


81
00:04:59,816 --> 00:05:02,986
but over the long term it
adds up to a lot of energy.


82
00:05:03,586 --> 00:05:11,586
And then when the user
requests action, you want to be


83
00:05:11,586 --> 00:05:13,506
as efficient as possible.


84
00:05:14,096 --> 00:05:16,986
And the best way to
do this is to remember


85
00:05:16,986 --> 00:05:20,456
that fast code is
usually efficient code.


86
00:05:21,706 --> 00:05:26,176
So go back, look
at your algorithms,


87
00:05:26,836 --> 00:05:29,656
make sure that they are
as efficient as possible.


88
00:05:30,136 --> 00:05:33,816
If it makes sense to do
so, parallelize your work,


89
00:05:33,816 --> 00:05:37,666
use Grand Central Dispatch,
harness the power of multicore,


90
00:05:38,196 --> 00:05:41,376
and then race back to idle.


91
00:05:41,426 --> 00:05:44,666
And the reason this
is important is


92
00:05:44,666 --> 00:05:47,846
that the faster you guys
can get your apps idle,


93
00:05:48,476 --> 00:05:50,516
the faster we can
get the system idle


94
00:05:50,516 --> 00:05:53,606
and the less energy
we use overall.


95
00:05:54,216 --> 00:05:59,586
If you want to know how much
CPU time your app is using,


96
00:05:59,586 --> 00:06:01,286
just look at the energy tab


97
00:06:01,936 --> 00:06:03,616
in the Activity Monitor
in Mavericks.


98
00:06:04,246 --> 00:06:06,506
Just look at the
percent CPU column.


99
00:06:08,216 --> 00:06:11,556
Again, you guys should
strive for this number


100
00:06:11,556 --> 00:06:14,816
to be absolutely zero when
your app is not in use.


101
00:06:14,816 --> 00:06:18,486
So 0.0. Even a small value


102
00:06:18,486 --> 00:06:24,536
like 2.7 percent can cause a
significant power draw increase


103
00:06:24,716 --> 00:06:25,566
from the CPU.


104
00:06:25,796 --> 00:06:27,166
And so it's worth investigating.


105
00:06:30,316 --> 00:06:36,246
If you're debugging in Xcode you
can go to the debug navigator


106
00:06:36,246 --> 00:06:38,716
and look at the CPU gauge.


107
00:06:39,256 --> 00:06:43,696
There's the debug
navigator, the CPU gauge,


108
00:06:43,926 --> 00:06:47,076
and it will tell you how
much CPU time you're using


109
00:06:47,076 --> 00:06:51,766
instantaneously as
well as a history


110
00:06:51,766 --> 00:06:56,696
of how much you've
used over time.


111
00:06:56,916 --> 00:06:59,586
And if you are the kind of
person who's more familiar


112
00:06:59,586 --> 00:07:02,436
with the Unix shell, you can
run the top command of course,


113
00:07:02,666 --> 00:07:05,136
look at the percent CPU column.


114
00:07:05,136 --> 00:07:12,006
Or if you pass -A, put
top into accumulator mode,


115
00:07:12,476 --> 00:07:15,496
what this does is it allows
you to watch the CPU time


116
00:07:15,496 --> 00:07:17,926
of your app accumulate
starting at 0,


117
00:07:18,236 --> 00:07:20,596
so you can see here
I launched top


118
00:07:20,596 --> 00:07:24,526
and Stock Watcher
has used 0.2 seconds


119
00:07:24,526 --> 00:07:26,986
of CPU time since
I launched top.


120
00:07:27,906 --> 00:07:29,626
So this allows you
to get an idea


121
00:07:29,626 --> 00:07:33,136
of how much CPU time a
particular scenario takes


122
00:07:33,566 --> 00:07:37,236
or just to watch your
app accumulate CPU time


123
00:07:37,236 --> 00:07:37,976
in real time.


124
00:07:38,516 --> 00:07:45,316
[ Pause ]


125
00:07:45,816 --> 00:07:47,516
Now, if you see your
app using CPU,


126
00:07:47,576 --> 00:07:49,146
you probably want to know why.


127
00:07:49,146 --> 00:07:54,186
And this is where Instruments
Time Profiler comes in handy.


128
00:07:54,666 --> 00:07:55,976
A lot of you are
probably familiar


129
00:07:55,976 --> 00:07:58,856
with Instruments
having used it hopefully


130
00:07:58,856 --> 00:08:00,766
to diagnose performance
problems.


131
00:08:01,046 --> 00:08:03,316
If you haven't used
Time Profiler,


132
00:08:03,316 --> 00:08:08,266
what it does is it takes a
really high frequency sample


133
00:08:08,406 --> 00:08:08,966
of your app.


134
00:08:08,966 --> 00:08:12,156
So it's really quickly
seeing exactly


135
00:08:12,156 --> 00:08:14,866
where it's executing all
the different call stacks,


136
00:08:15,186 --> 00:08:17,526
and then it aggregates
all the call stacks


137
00:08:17,526 --> 00:08:21,716
into a Call Tree view that
will show you what percent


138
00:08:21,716 --> 00:08:24,196
of the time is spent where,
under which functions,


139
00:08:24,506 --> 00:08:26,346
which libraries, which
frameworks, et cetera.


140
00:08:26,446 --> 00:08:27,526
I'll show you a little
more on how


141
00:08:27,526 --> 00:08:29,876
to use Instruments
a little later.


142
00:08:33,635 --> 00:08:35,756
One thing that's
new in Mavericks is


143
00:08:35,756 --> 00:08:39,155
that the system will also
automatically monitor your


144
00:08:39,155 --> 00:08:40,166
CPU usage.


145
00:08:40,405 --> 00:08:43,796
So you may see a line in the
console that looks like this.


146
00:08:44,356 --> 00:08:47,606
You've got some app
caught burning CPU.


147
00:08:47,606 --> 00:08:50,716
It's used a lot of CPU
over this much time.


148
00:08:51,846 --> 00:08:53,076
And when this happens,


149
00:08:54,276 --> 00:08:56,686
the system will automatically
drop a log


150
00:08:56,686 --> 00:08:59,786
into
/Library/Logs/DiagnosticReports


151
00:09:00,196 --> 00:09:03,766
with the CPU resource.spin
extension.


152
00:09:03,766 --> 00:09:10,816
And what this log contains is a
historical sample of your app,


153
00:09:11,286 --> 00:09:13,266
where it's been using CPU time.


154
00:09:13,776 --> 00:09:15,466
And this is automatically
done for you


155
00:09:15,776 --> 00:09:17,446
without having to
set up anything.


156
00:09:17,996 --> 00:09:20,916
And so this is basically
the same thing


157
00:09:20,916 --> 00:09:23,236
that Instrument is
getting, just in text form.


158
00:09:24,906 --> 00:09:29,026
Now, it's important to
remember that the threshold


159
00:09:29,026 --> 00:09:31,256
for triggering these
is relatively high.


160
00:09:31,256 --> 00:09:33,426
Here it says 50 percent CPU.


161
00:09:33,426 --> 00:09:38,306
So, you should really treat
these as a real red flag


162
00:09:38,546 --> 00:09:40,646
when you see them,
if you see them,


163
00:09:41,996 --> 00:09:46,446
because they can cause a
significant battery life


164
00:09:46,506 --> 00:09:49,016
decrease for your users.


165
00:09:49,016 --> 00:09:54,176
So go through and make sure that
these reports represent work


166
00:09:54,176 --> 00:09:59,236
that you know the user
is aware of and ask for.


167
00:10:00,696 --> 00:10:04,606
Another way to diagnose
CPU time is to look


168
00:10:04,606 --> 00:10:06,946
for what I call secondary
indicators.


169
00:10:07,236 --> 00:10:08,776
So what do I mean by this?


170
00:10:08,776 --> 00:10:10,666
Well, we talked about
the three ways


171
00:10:10,726 --> 00:10:13,896
that apps can use
the-- or use energy.


172
00:10:14,476 --> 00:10:16,846
We talked about CPU.


173
00:10:17,736 --> 00:10:21,796
But of course using
the I/O system,


174
00:10:22,346 --> 00:10:25,816
using the graphic system
also involve using the CPU


175
00:10:25,816 --> 00:10:26,346
to do that.


176
00:10:27,156 --> 00:10:30,206
So looking at where
you use the I/O system


177
00:10:30,206 --> 00:10:34,146
or the graphic system can
give you a good pointer as to


178
00:10:34,146 --> 00:10:35,836
where you're using CPU time.


179
00:10:36,276 --> 00:10:37,366
So let's look at I/O.


180
00:10:37,946 --> 00:10:43,516
This little tool called
fs usage that has shipped


181
00:10:43,516 --> 00:10:49,526
on OS X forever, and what it
does is it tells you all the


182
00:10:49,666 --> 00:10:56,626
places where your app is
interacting with the file system


183
00:10:56,626 --> 00:10:58,416
and network layers
of the Kernel.


184
00:10:59,266 --> 00:11:02,966
So these are things like, you
know, open/closed system calls,


185
00:11:03,666 --> 00:11:08,216
read/writes from the network,
disk I/Os, things like that.


186
00:11:08,366 --> 00:11:10,166
So let's run it on an app.


187
00:11:11,416 --> 00:11:17,976
Here you can see my app is
making a lot of calls to stat


188
00:11:18,156 --> 00:11:23,736
for a file called myicon.png.


189
00:11:23,966 --> 00:11:27,486
It's also actually writing to
a file called downloads.plist.


190
00:11:27,486 --> 00:11:29,736
So, there's no magic
bullet here,


191
00:11:29,736 --> 00:11:33,116
but this can often give
you a pretty good sense


192
00:11:33,216 --> 00:11:37,536
of where you're using
CPU, at least what kind


193
00:11:37,536 --> 00:11:39,056
of processing you're doing.


194
00:11:39,676 --> 00:11:45,106
If you're interested in fs
usage or performance in general,


195
00:11:45,166 --> 00:11:48,296
there was a great
session earlier this week,


196
00:11:48,296 --> 00:11:51,086
Building Efficient OS X
Apps that talks a lot more


197
00:11:51,086 --> 00:11:53,186
about fs usage, talks a lot more


198
00:11:53,186 --> 00:11:56,326
about being a good
system citizen


199
00:11:56,616 --> 00:11:58,896
with respect to system
resources.


200
00:11:59,366 --> 00:12:01,976
So I highly recommend you
go back, give that a watch


201
00:12:02,076 --> 00:12:02,996
when you get a chance.


202
00:12:03,556 --> 00:12:06,756
OK, so that was I/O.


203
00:12:06,756 --> 00:12:07,946
Let's talk about graphics.


204
00:12:08,646 --> 00:12:14,476
So for graphics we have a
little app called QuartzDebug,


205
00:12:14,766 --> 00:12:17,016
and this ships in our
developer toolkit.


206
00:12:18,166 --> 00:12:19,626
And if you launch this app


207
00:12:20,886 --> 00:12:24,226
and check the little
Flash screen updates box,


208
00:12:24,786 --> 00:12:29,806
what this will do is it will
cause all draws to the screen


209
00:12:29,996 --> 00:12:31,566
to be flashed in yellow.


210
00:12:31,566 --> 00:12:35,656
So I check this box, put
up the OS X shutdown panel,


211
00:12:36,256 --> 00:12:38,356
and the Shutdown button
was covered in yellow.


212
00:12:39,266 --> 00:12:42,966
And this makes sense because
the button is pulsing.


213
00:12:42,966 --> 00:12:43,996
I expect it to be drawing.


214
00:12:44,966 --> 00:12:48,196
But if you have a UI
that looks pretty static,


215
00:12:48,466 --> 00:12:51,486
you might be surprised to
see that, in some cases,


216
00:12:51,696 --> 00:12:53,516
it's actually drawing.


217
00:12:53,516 --> 00:12:56,586
And of course drawing
uses energy just


218
00:12:56,586 --> 00:12:59,036
because it's using the
graphic system, it uses energy


219
00:12:59,036 --> 00:13:00,426
because it's using the CPU.


220
00:13:01,136 --> 00:13:04,956
And in a lot of cases, this
drawing could be invisible


221
00:13:04,956 --> 00:13:06,586
or almost invisible
to the naked eye.


222
00:13:06,586 --> 00:13:09,456
So what QuartzDebug
does is allows you


223
00:13:09,456 --> 00:13:11,656
to see it a lot more clearly.


224
00:13:14,676 --> 00:13:18,886
QuartzDebug is available in our
Graphics Tools for Xcode package


225
00:13:18,976 --> 00:13:22,586
on developer.apple.com.


226
00:13:22,776 --> 00:13:24,376
So, CPU usage.


227
00:13:25,276 --> 00:13:30,366
Remember that a little bit of
CPU usage, even like 1 percent,


228
00:13:30,756 --> 00:13:35,836
causes a significant power
draw increase from the CPU.


229
00:13:36,896 --> 00:13:41,136
So, it's important to make sure
your app is absolutely idle


230
00:13:41,886 --> 00:13:42,956
when it's not in use.


231
00:13:43,226 --> 00:13:45,456
Go through, watch it
with Activity Monitor,


232
00:13:45,816 --> 00:13:47,746
make sure it's idle
when it should be.


233
00:13:48,336 --> 00:13:53,416
All right, let's
talk about timers.


234
00:13:55,006 --> 00:13:58,596
I'm sure you use timers in
your app in a lot of places.


235
00:13:59,006 --> 00:14:02,466
Timers are used to schedule
periodic events or future events


236
00:14:02,466 --> 00:14:06,306
and drive animations,
you use timers.


237
00:14:06,306 --> 00:14:10,396
So why are timers interesting
from an energy perspective?


238
00:14:11,306 --> 00:14:14,476
Well, timers keep
your app out of idle.


239
00:14:15,686 --> 00:14:19,106
When you have a timer and it
wakes up and it runs some code,


240
00:14:19,806 --> 00:14:21,666
that's keeping your
app out of idle.


241
00:14:21,666 --> 00:14:23,356
That's bringing the
system out of idle.


242
00:14:24,476 --> 00:14:26,696
And perhaps more importantly,


243
00:14:27,176 --> 00:14:30,846
timers can have an
outsize effect on energy.


244
00:14:31,806 --> 00:14:33,656
So what do I mean by this?


245
00:14:34,866 --> 00:14:38,086
Imagine you have an app, and
it's got some repeating timer,


246
00:14:41,896 --> 00:14:46,356
here are all the places
where it's firing.


247
00:14:46,506 --> 00:14:49,986
Now, every time one
of these timers fires,


248
00:14:50,306 --> 00:14:55,986
there's a little bit of overhead
involved in bringing the CPU


249
00:14:55,986 --> 00:15:00,626
out of idle, bringing
your app out of idle,


250
00:15:00,626 --> 00:15:03,186
getting your app
context switched to,


251
00:15:03,186 --> 00:15:04,726
getting your app
back to userland.


252
00:15:04,866 --> 00:15:08,926
So, there's a little extra wake
up cost associated with that.


253
00:15:09,236 --> 00:15:14,186
But it gets worse
because we need more


254
00:15:14,186 --> 00:15:17,066
than just the CPU
to run your timer.


255
00:15:17,066 --> 00:15:18,906
We need all the supporting
chipset.


256
00:15:18,906 --> 00:15:20,506
So we need the memory
controller,


257
00:15:20,606 --> 00:15:22,986
we need the bus controller
and all that.


258
00:15:22,986 --> 00:15:24,346
And we really try


259
00:15:24,346 --> 00:15:26,896
and aggressively power
manage these chips.


260
00:15:27,486 --> 00:15:31,326
But they take a little
longer to go back into idle


261
00:15:31,326 --> 00:15:32,346
and to come out of idle.


262
00:15:32,816 --> 00:15:35,306
So if you have really
frequent timers like this,


263
00:15:35,906 --> 00:15:38,556
the system might decide,
"Well, I don't really have time


264
00:15:38,556 --> 00:15:40,626
to put those chips
back into idle.


265
00:15:40,776 --> 00:15:42,066
I'm just going to
leave them on."


266
00:15:42,066 --> 00:15:45,936
So you incur all of this
energy overhead, all this red,


267
00:15:46,286 --> 00:15:49,846
even if this timer is just
doing a little bit of work.


268
00:15:52,576 --> 00:15:54,916
By the way, what do
I mean by timers?


269
00:15:54,916 --> 00:16:01,426
Of course we have explicit timer
APIs in Grand Central Dispatch,


270
00:16:01,646 --> 00:16:03,706
Core Foundation -- foundation.


271
00:16:06,436 --> 00:16:09,826
There are low level APIs
like sleep and usleep


272
00:16:11,066 --> 00:16:12,796
that are implemented
with timers,


273
00:16:12,936 --> 00:16:15,126
also things like
pthread cond timedwait


274
00:16:15,126 --> 00:16:17,656
if you're using pthreads
or dispatch semaphore wait,


275
00:16:18,046 --> 00:16:19,746
if you're using libdispatch.


276
00:16:21,026 --> 00:16:25,046
Even a lot of low level APIs
that take timeouts like select


277
00:16:25,046 --> 00:16:27,636
and poll, even MockMessage
takes a timeout.


278
00:16:28,156 --> 00:16:32,106
So these can all, if those
timeouts fire, cause timers.


279
00:16:32,636 --> 00:16:36,006
And there are a lot
of high level APIs


280
00:16:36,006 --> 00:16:37,026
that are built on timers.


281
00:16:37,026 --> 00:16:40,866
So if you use dispatch after
or NSObject performSelector:


282
00:16:40,866 --> 00:16:42,326
withObject:afterDelay.


283
00:16:42,896 --> 00:16:45,296
Even things like an
NSProgressIndicator is


284
00:16:45,296 --> 00:16:46,326
implemented with timers


285
00:16:46,356 --> 00:16:49,276
to advance the little spinny
wheel or the barber pole.


286
00:16:50,066 --> 00:16:53,846
Or if you use CVDisplayLink,
that is a timer as well.


287
00:16:55,616 --> 00:17:01,206
In Mavericks, it's a lot
easier to see the timer usage


288
00:17:01,206 --> 00:17:03,906
of your app if you go back
to Activity Monitor and look


289
00:17:03,906 --> 00:17:05,376
at the Idle Wakeups column.


290
00:17:05,715 --> 00:17:08,826
This will show you the
number of times a timer fired


291
00:17:08,826 --> 00:17:11,336
in your app in the last second.


292
00:17:11,796 --> 00:17:14,996
So in this case, this app fired
10 timers in the last second.


293
00:17:16,435 --> 00:17:19,136
There's also a new column
called Energy Impact,


294
00:17:19,656 --> 00:17:21,826
and this is a measure


295
00:17:21,826 --> 00:17:25,376
of the overall energy
impact of your app.


296
00:17:25,376 --> 00:17:28,956
So that includes CPU
usage, timer wakeups


297
00:17:28,956 --> 00:17:31,586
and all the overhead
associated with that,


298
00:17:31,666 --> 00:17:32,986
and some other factors too.


299
00:17:33,566 --> 00:17:35,966
So this is a good way
to get a quick view


300
00:17:36,106 --> 00:17:38,436
of whether you're using
energy on the system.


301
00:17:38,546 --> 00:17:40,426
If you're using zero,
that's great.


302
00:17:40,426 --> 00:17:43,806
If you're using nonzero,
well, you want to know why.


303
00:17:44,396 --> 00:17:50,196
You can get the same stuff
right in Xcode and Xcode 5.


304
00:17:50,586 --> 00:17:52,736
Go back to the Debug
Navigator and look


305
00:17:52,916 --> 00:17:55,926
at the Energy Impact Gauge.


306
00:17:56,546 --> 00:18:00,226
This will give you the number
of wakes over the last second


307
00:18:00,876 --> 00:18:06,246
and a readout of your
energy utilization.


308
00:18:10,696 --> 00:18:14,066
So once you see that you're
incurring a lot of wakeups,


309
00:18:14,496 --> 00:18:16,296
you probably want to know why.


310
00:18:16,296 --> 00:18:19,756
And there's a new tool in
Mavericks called Timer Fires


311
00:18:19,836 --> 00:18:21,946
that will help you
figure this out.


312
00:18:21,946 --> 00:18:25,996
If you just run it, give it the
process ID you're interested in,


313
00:18:26,236 --> 00:18:29,196
and -s to enable stack traces.


314
00:18:30,116 --> 00:18:33,406
What this will do is it
will log all the places


315
00:18:33,536 --> 00:18:36,256
where your app has
woken up due to a timer.


316
00:18:36,906 --> 00:18:39,366
So let's look at this.


317
00:18:39,366 --> 00:18:45,496
Here it looks like my
app has a 2 hertz timer.


318
00:18:46,386 --> 00:18:49,306
That's a CF timer
that's executing routine


319
00:18:49,306 --> 00:18:51,676
in its app delegate
called timer fired.


320
00:18:52,256 --> 00:18:58,036
And here it looks like we've
got a libdispatch timer,


321
00:18:58,156 --> 00:18:59,746
a Grand Central Dispatch timer


322
00:19:00,156 --> 00:19:02,686
that is executing a routine
called updateWidgets.


323
00:19:03,206 --> 00:19:08,116
And here's where the app
actually just call usleep.


324
00:19:08,576 --> 00:19:11,886
So you can see the full stack
trace of where it called usleep.


325
00:19:15,476 --> 00:19:17,956
All right, so let's
talk about some ways


326
00:19:18,226 --> 00:19:19,966
that you don't want
to be using timers.


327
00:19:20,656 --> 00:19:26,576
Here's a pretty naive example,
but it's one that we have seen.


328
00:19:27,496 --> 00:19:30,726
Say you've got a thread that's
doing some long-running work


329
00:19:30,726 --> 00:19:31,966
like waiting on the network.


330
00:19:33,226 --> 00:19:34,586
And once it's done it's going


331
00:19:34,586 --> 00:19:36,926
to set a global Boolean
to say "I'm done."


332
00:19:37,156 --> 00:19:41,036
And then you've got a second
thread that wants to know


333
00:19:41,036 --> 00:19:45,166
when that work is done and
then run a completion block


334
00:19:45,166 --> 00:19:46,166
or a completion handler.


335
00:19:47,286 --> 00:19:49,746
And the way it's going to do
that right now is it's going


336
00:19:49,746 --> 00:19:55,226
to say, "OK, I'll
check 10 times a second


337
00:19:55,266 --> 00:19:57,996
to see whether the work is
done," and a little loop there.


338
00:19:58,066 --> 00:20:01,326
"And then once it's done, I'll
just run the completion block."


339
00:20:01,876 --> 00:20:04,776
Well, first of all, this doesn't
work for several reasons.


340
00:20:04,826 --> 00:20:09,066
But the reason it's bad for
energy is that most of the time,


341
00:20:09,396 --> 00:20:11,236
this timer is going to wake up.


342
00:20:11,236 --> 00:20:12,706
It's going to check
whether the work is done,


343
00:20:13,126 --> 00:20:14,336
and the work is not
going to be done.


344
00:20:14,336 --> 00:20:15,526
And so it's going
to go back to sleep.


345
00:20:15,696 --> 00:20:16,876
Come back up and say,
"Is the work done?


346
00:20:16,876 --> 00:20:17,816
No. Is the work done?


347
00:20:17,816 --> 00:20:18,646
No. Is the work done?


348
00:20:18,646 --> 00:20:18,886
No."


349
00:20:19,056 --> 00:20:23,136
So, every time you wake
up, you're incurring all


350
00:20:23,136 --> 00:20:25,066
of that red energy
we saw before.


351
00:20:25,646 --> 00:20:27,306
So this is no good.


352
00:20:28,706 --> 00:20:32,846
Instead, in this case, in
this kind of case you want


353
00:20:32,846 --> 00:20:35,496
to use an explicit
synchronization method.


354
00:20:36,206 --> 00:20:38,906
For most of you the best option
is Grand Central Dispatch,


355
00:20:39,216 --> 00:20:41,846
so you can use a serial
dispatch queue or a semaphore.


356
00:20:42,906 --> 00:20:45,206
If you're using pthreads
there are condition variables


357
00:20:45,206 --> 00:20:46,216
that will do this for you.


358
00:20:46,216 --> 00:20:51,686
So in this kind of case
what we'll do is I'll put


359
00:20:51,686 --> 00:20:54,136
that long-running work
on to a serial queue,


360
00:20:54,136 --> 00:20:56,786
and then I'll make sure I
put the completion block


361
00:20:56,786 --> 00:20:58,236
on to the queue afterwards.


362
00:20:58,676 --> 00:21:01,566
And then the completion block
will just automatically run


363
00:21:01,896 --> 00:21:04,546
when the work is done, no
need to wake up and check.


364
00:21:05,286 --> 00:21:08,046
Grand Central Dispatch
will just handle it for me.


365
00:21:10,436 --> 00:21:12,026
Here's another example.


366
00:21:12,786 --> 00:21:20,756
Here we've got a 2 hertz timer,
an NSTimer, that is trying


367
00:21:20,756 --> 00:21:23,036
to find out whether
a file has changed.


368
00:21:23,426 --> 00:21:26,746
So it's waking up saying
"Did this file change?


369
00:21:27,176 --> 00:21:28,626
No. Did this file change?


370
00:21:28,906 --> 00:21:30,176
No. Did this file change?


371
00:21:30,296 --> 00:21:35,476
No." And the common case is that
the file is not going to change.


372
00:21:35,536 --> 00:21:37,786
The user is not changing
their files very much.


373
00:21:39,416 --> 00:21:42,336
So this is really
inefficient obviously


374
00:21:42,336 --> 00:21:43,896
because we're incurring all


375
00:21:43,896 --> 00:21:46,186
that wakeup overhear every
time we have to wake up.


376
00:21:46,696 --> 00:21:48,906
In this kind of case, you want


377
00:21:49,356 --> 00:21:51,916
to consider using an
explicit event stream.


378
00:21:51,916 --> 00:21:54,636
And there are tons of
them on OS X and iOS.


379
00:21:55,496 --> 00:21:57,126
In this kind of case,
I'm interested


380
00:21:57,126 --> 00:21:59,566
in the File System Event
so I can use something


381
00:21:59,566 --> 00:22:01,256
like DISPATCH SOURCE TYPE VNODE


382
00:22:02,306 --> 00:22:05,276
for a small scale
particular file update.


383
00:22:05,626 --> 00:22:09,216
If you're interested in multiple
directories you can use the


384
00:22:09,216 --> 00:22:11,916
FSEvents framework
for file system-wide


385
00:22:11,916 --> 00:22:13,876
or directory-wide events.


386
00:22:15,476 --> 00:22:18,626
If you are interested in
events from other processes,


387
00:22:18,746 --> 00:22:19,886
of course there's XPC.


388
00:22:19,916 --> 00:22:23,776
Or if you want to use a
distributed notification,


389
00:22:24,476 --> 00:22:25,926
there are distributed
notifications


390
00:22:25,926 --> 00:22:28,976
at the foundation level and its
distributed notification center,


391
00:22:28,976 --> 00:22:31,376
as well as BSD notifications.


392
00:22:31,946 --> 00:22:37,276
If you're interested in device
notifications, there are a lot


393
00:22:37,276 --> 00:22:38,966
of different ways to do that.


394
00:22:38,966 --> 00:22:40,556
For example if you
are interested


395
00:22:40,556 --> 00:22:44,416
in when a mass storage volume
is attached or removed,


396
00:22:44,646 --> 00:22:46,626
there are disk arbitration
notifications.


397
00:22:46,996 --> 00:22:50,186
I/O Kit publishes
notifications on when certain --


398
00:22:50,236 --> 00:22:52,406
other types of devices
are attached.


399
00:22:52,956 --> 00:22:55,286
And if you're interested
in events from the network,


400
00:22:55,616 --> 00:22:57,856
of course there's Apple
Push Notifications,


401
00:22:58,166 --> 00:22:59,456
there's also Bonjour,


402
00:22:59,626 --> 00:23:02,586
and network reachability
notification, so you don't have


403
00:23:02,646 --> 00:23:04,406
to wake up and say,
"Can I reach the server?


404
00:23:04,546 --> 00:23:07,826
No. Can I reach the server?


405
00:23:08,016 --> 00:23:12,446
No." So in this case, I
will replace the timer


406
00:23:12,506 --> 00:23:13,696
with a dispatch source.


407
00:23:14,846 --> 00:23:16,686
I'll give it DISPATCH
SOURCE TYPE VNODE


408
00:23:16,686 --> 00:23:18,536
and the file descriptor
I'm interested in.


409
00:23:19,116 --> 00:23:25,206
And then when the event fires,
I'll just say, "OK, go ahead


410
00:23:25,206 --> 00:23:25,986
and check for the file.


411
00:23:25,986 --> 00:23:27,716
The system told me
that the file changed.


412
00:23:27,906 --> 00:23:29,966
I'll go ahead and
run my handler."


413
00:23:34,836 --> 00:23:36,646
OK, here's another common case.


414
00:23:37,296 --> 00:23:42,526
This is a basic run loop type
construct where we're waiting


415
00:23:42,526 --> 00:23:45,966
for an event, and we're doing
that by waiting on a semaphore


416
00:23:45,966 --> 00:23:49,506
in this case, and then we're --
when we get an event we'll see


417
00:23:49,506 --> 00:23:50,806
if we have work to do.


418
00:23:51,306 --> 00:23:55,916
The problem here is
I've specified a timeout


419
00:23:56,276 --> 00:23:57,526
to dispatch semaphore wait,


420
00:23:58,116 --> 00:24:00,906
but I'm not really
doing anything special


421
00:24:01,206 --> 00:24:03,316
if dispatch semaphore
wait times out.


422
00:24:04,696 --> 00:24:09,106
So this is a common mistake
because dispatch semaphore wait,


423
00:24:09,106 --> 00:24:12,116
and a lot of APIs like it,
take a timeout parameter.


424
00:24:12,336 --> 00:24:13,826
So a lot of people say, "Well,


425
00:24:13,826 --> 00:24:15,966
I better specify
a timeout anyway."


426
00:24:17,376 --> 00:24:21,686
Actually in most cases you
can specify a special argument


427
00:24:21,686 --> 00:24:24,606
that says "No, just go
ahead and block forever.


428
00:24:24,606 --> 00:24:26,206
Don't make this into
a timer at all.


429
00:24:26,406 --> 00:24:30,326
Just block until I get an event,
or indefinitely otherwise."


430
00:24:31,676 --> 00:24:34,416
And if you do specify a timeout,


431
00:24:34,836 --> 00:24:38,016
make sure it represents a
meaningful state change to you,


432
00:24:38,016 --> 00:24:39,146
something that you're
going to check


433
00:24:39,246 --> 00:24:42,026
for like an error condition
or a timeout, you know,


434
00:24:42,026 --> 00:24:43,216
like a network timeout.


435
00:24:47,976 --> 00:24:49,356
Here's another case.


436
00:24:49,356 --> 00:24:51,956
You probably know a
lot about memory leaks.


437
00:24:52,566 --> 00:24:56,506
But you're going to
have energy leaks too.


438
00:24:56,626 --> 00:24:58,346
So this is a case where I've set


439
00:24:58,346 --> 00:25:00,896
up a recurring timer
to do some work.


440
00:25:01,946 --> 00:25:03,686
And it's doing some
valuable work for me,


441
00:25:04,276 --> 00:25:06,866
but then I don't
need it anymore,


442
00:25:06,866 --> 00:25:09,226
but I don't invalidate it.


443
00:25:09,226 --> 00:25:12,196
And so what's going to happen
is for the rest of the lifetime


444
00:25:12,196 --> 00:25:15,096
of my app, I'm going to have
this timer that's waking up,


445
00:25:15,766 --> 00:25:18,556
probably doing no work,
using lots of energy,


446
00:25:18,556 --> 00:25:19,976
hurting the user's battery life.


447
00:25:20,986 --> 00:25:23,566
This is no good.


448
00:25:23,776 --> 00:25:25,496
So go through, make sure


449
00:25:25,496 --> 00:25:29,126
that all the repeating timers
you have are invalidated


450
00:25:29,126 --> 00:25:36,166
or cancelled correctly when
you no longer need them.


451
00:25:36,356 --> 00:25:40,126
Finally, you really want
to specify timer tolerance.


452
00:25:40,126 --> 00:25:42,566
You may have heard a little
bit about tolerance this week.


453
00:25:43,746 --> 00:25:46,466
Tolerance is a hint
to the system


454
00:25:46,586 --> 00:25:49,686
as to how much it can
batch work together.


455
00:25:51,036 --> 00:25:54,776
And this is good because the
more we batch work together,


456
00:25:55,856 --> 00:25:58,216
the less wakeup overhead
we have,


457
00:25:58,216 --> 00:26:02,546
and the more the system is
idle in its low power state.


458
00:26:03,086 --> 00:26:08,426
So it's really easy to specify
a tolerance for all your timers


459
00:26:08,426 --> 00:26:10,846
if you have dispatch timers.


460
00:26:11,126 --> 00:26:14,766
It's just the final parameter
to dispatch source set timer.


461
00:26:16,016 --> 00:26:18,056
This is in nanoseconds.


462
00:26:18,676 --> 00:26:24,686
If you have CFRunLoop timers,
there is new API in Mavericks,


463
00:26:24,936 --> 00:26:29,616
CFRunLoopTimerSetTolerance, and
that takes a value in seconds.


464
00:26:30,196 --> 00:26:35,096
And similarly for NSTimers.


465
00:26:35,696 --> 00:26:39,756
OK, I want to show
you a quick demo now


466
00:26:40,316 --> 00:26:45,526
on how this all works together.


467
00:26:45,526 --> 00:26:48,956
So, I'm running Mavericks
here and Xcode 5,


468
00:26:48,956 --> 00:26:52,816
and I've got this little
app called Stock Watcher


469
00:26:53,246 --> 00:26:53,936
that I'm working on.


470
00:26:54,326 --> 00:26:57,876
And it's just a little
stock ticker app.


471
00:26:57,876 --> 00:26:59,666
It shows me the price and change


472
00:26:59,666 --> 00:27:01,776
of all the stocks
I'm interested in.


473
00:27:02,736 --> 00:27:04,966
And look, it's even
a good energy citizen


474
00:27:04,966 --> 00:27:07,326
because it suspends
its animations


475
00:27:08,096 --> 00:27:09,816
when it's not in the foreground.


476
00:27:10,786 --> 00:27:14,286
But I'm really interested in
the energy efficiency of my app.


477
00:27:14,286 --> 00:27:18,886
So let me go to the Debug
Navigator and I'll look


478
00:27:18,886 --> 00:27:20,756
at the CPU gauge first.


479
00:27:22,686 --> 00:27:28,986
OK, so my app appears to be
idle, but it says it's using 2


480
00:27:28,986 --> 00:27:30,646
to 3 percent CPU time.


481
00:27:31,166 --> 00:27:34,666
What I really want is for
my app to be absolutely idle


482
00:27:35,146 --> 00:27:36,726
when it's not doing
any work for me.


483
00:27:37,776 --> 00:27:41,396
So let me just click
Profile in Instruments.


484
00:27:41,886 --> 00:27:45,586
This will take me
right into Instruments


485
00:27:46,286 --> 00:27:48,986
and start running
a time profiler.


486
00:27:49,996 --> 00:27:52,946
So, again, what Instruments is
doing is it's taking a really


487
00:27:52,946 --> 00:27:57,486
high frequency sample of my
app, seeing exactly the stacks


488
00:27:57,486 --> 00:28:01,836
where it's executing, and
then it will show me those


489
00:28:01,836 --> 00:28:02,816
in the call to review.


490
00:28:02,856 --> 00:28:04,216
So I'll stop it now.


491
00:28:08,496 --> 00:28:12,056
And if I just option click
on this disclosure triangle,


492
00:28:12,056 --> 00:28:15,286
I can see the full
call tree hierarchy


493
00:28:15,346 --> 00:28:16,506
of where it's executing.


494
00:28:17,216 --> 00:28:19,996
And in this case
it looks like, OK,


495
00:28:19,996 --> 00:28:23,826
it's doing a lot
of drawing work.


496
00:28:23,826 --> 00:28:31,566
OK. I can also open up
the Extended Detail View,


497
00:28:31,896 --> 00:28:37,146
this will also show me the
heaviest stack during the


498
00:28:37,146 --> 00:28:38,046
sample period.


499
00:28:39,086 --> 00:28:42,836
OK, it's doing a lot of views,
view drawing, control drawing.


500
00:28:43,226 --> 00:28:45,866
OK, so I know this has
something to do with drawing.


501
00:28:46,216 --> 00:28:49,016
So let me try a different
method.


502
00:28:49,676 --> 00:28:51,156
I'll close out Instruments.


503
00:28:51,716 --> 00:29:01,086
If I run this again, I'll turn


504
00:29:01,086 --> 00:29:04,366
on show view drawing
here in Xcode.


505
00:29:04,366 --> 00:29:06,876
And this is basically the
same thing as QuartzDebug


506
00:29:06,876 --> 00:29:08,236
like we talked about before.


507
00:29:09,286 --> 00:29:11,726
And what this does is
it cause all views,


508
00:29:11,726 --> 00:29:15,566
right when they draw rect to
show yellow right beforehand.


509
00:29:15,566 --> 00:29:17,706
And we can see almost
immediately,


510
00:29:17,706 --> 00:29:21,826
it's this top S&P 500 view
that's blinking out of control.


511
00:29:22,266 --> 00:29:24,816
OK, so that gives us
a pretty good idea.


512
00:29:25,386 --> 00:29:31,396
Let me show you one more thing.


513
00:29:31,606 --> 00:29:34,336
So I'll go into terminal


514
00:29:34,386 --> 00:29:37,316
and I'll run fs usage
on Stock Watcher.


515
00:29:39,136 --> 00:29:42,016
OK, so immediately we
see lots of output.


516
00:29:42,586 --> 00:29:43,696
What's happening here it looks


517
00:29:43,696 --> 00:29:47,426
like is my app is
calling a few system calls


518
00:29:47,426 --> 00:29:49,606
on this stocks.plist file.


519
00:29:49,606 --> 00:29:53,656
So list xsetter,
get xsetter, lstat.


520
00:29:54,196 --> 00:29:57,376
OK, so I happen to
know what this is.


521
00:29:57,376 --> 00:29:58,926
This is a beta version
of my app.


522
00:29:58,926 --> 00:30:00,636
It's not getting data
from the network,


523
00:30:00,636 --> 00:30:03,546
it's getting data
from a local plist.


524
00:30:04,066 --> 00:30:10,636
So let me stop Stock
Watcher and go to there.


525
00:30:10,636 --> 00:30:13,096
So I know this is in
a routine called check


526
00:30:13,616 --> 00:30:15,766
for stock.plist update.


527
00:30:16,566 --> 00:30:19,506
OK. I actually did some
debugging in here before,


528
00:30:19,506 --> 00:30:23,716
and I noticed that even
if the file I'm interested


529
00:30:23,716 --> 00:30:28,646
in didn't change, I'm still
updating the S&P 500 view.


530
00:30:29,186 --> 00:30:33,766
So let me just move this
into my IF statement here.


531
00:30:35,556 --> 00:30:39,886
And I'll build and run.


532
00:30:40,006 --> 00:30:46,206
OK. So let's go back
into the CPU column.


533
00:30:46,526 --> 00:30:50,026
Great. The CPU Gauge says
I'm using 0 percent CPU.


534
00:30:50,026 --> 00:30:52,516
We can even turn on
Show View Drawing.


535
00:30:53,276 --> 00:30:53,986
OK, awesome.


536
00:30:54,346 --> 00:30:56,846
No View Drawing.


537
00:31:01,116 --> 00:31:05,586
Great. But let's look at
the Energy Impact Gauge.


538
00:31:06,796 --> 00:31:09,966
So my app is idle.


539
00:31:09,966 --> 00:31:13,776
I really want my energy impact--
my energy utilization to be 0.


540
00:31:13,776 --> 00:31:15,606
But right now it's low


541
00:31:15,606 --> 00:31:19,606
and it also says my app is
waking up 10 times a second.


542
00:31:20,646 --> 00:31:29,606
All right, so what I'll do is
let's run Timer Fires on it.


543
00:31:29,866 --> 00:31:33,136
OK, so Timer Fires is telling
me that that same routine,


544
00:31:33,136 --> 00:31:36,036
check for stock.plist
update is firing--


545
00:31:36,036 --> 00:31:39,016
and it looks like it
ran 10 times a second.


546
00:31:39,846 --> 00:31:42,066
So let's go back.


547
00:31:45,286 --> 00:31:48,206
Check for stock.plist update.


548
00:31:48,766 --> 00:31:54,586
OK. So this is actually
called on a timer up here.


549
00:31:54,586 --> 00:31:57,616
So this is a timer--
and this is checking


550
00:31:57,616 --> 00:31:59,816
to see whether the
plist file changes.


551
00:32:00,286 --> 00:32:03,226
But it's firing 10 times
a second, and of course,


552
00:32:03,226 --> 00:32:04,986
we're not changing
the plist file.


553
00:32:04,986 --> 00:32:06,286
So this is a waste of energy.


554
00:32:06,286 --> 00:32:12,836
So I'm going to rip this timer
out and I'm going to replace it


555
00:32:12,836 --> 00:32:14,306
with a dispatch source.


556
00:32:15,516 --> 00:32:19,466
[ Pause ]


557
00:32:19,966 --> 00:32:25,026
OK. So what this is saying
is I'll get a file descriptor


558
00:32:26,196 --> 00:32:27,066
for the plist.


559
00:32:27,386 --> 00:32:30,986
I'll set up a Dispatch
Source type of VNODE,


560
00:32:32,066 --> 00:32:34,006
say "Fire this on
my main queue."


561
00:32:34,146 --> 00:32:38,006
And when it does fire,
I'll just run check


562
00:32:38,006 --> 00:32:39,196
for stock.plist update.


563
00:32:39,566 --> 00:32:42,496
Great. So let's build and run.


564
00:32:43,516 --> 00:32:48,196
[ Pause ]


565
00:32:48,696 --> 00:32:51,566
And if go back to the
Energy Impact Gauge,


566
00:32:52,256 --> 00:32:58,686
you can see my energy
utilization is 0 most


567
00:32:58,686 --> 00:32:59,126
of the time.


568
00:32:59,126 --> 00:33:01,576
I still have a few other
things to debug, it looks like.


569
00:33:02,186 --> 00:33:05,816
So-- but let me show
you one more thing.


570
00:33:06,526 --> 00:33:10,666
So it's really important
to not just test your app


571
00:33:10,926 --> 00:33:14,996
when it launches but also test
all the paths your app can go


572
00:33:14,996 --> 00:33:17,306
down because your user is
going to hit those paths.


573
00:33:17,306 --> 00:33:19,806
So I actually recently
noticed that, you know,


574
00:33:19,806 --> 00:33:23,166
you saw that Stock Watcher
turns off its animation


575
00:33:23,426 --> 00:33:24,426
when it's in the background.


576
00:33:25,186 --> 00:33:28,836
If I switch away from Stock
Watcher during an animation,


577
00:33:29,416 --> 00:33:33,006
the energy utilization
remains at high,


578
00:33:33,006 --> 00:33:37,576
and Xcode is telling me
it has 90 wakes a second.


579
00:33:37,576 --> 00:33:39,036
So this is really bad.


580
00:33:39,966 --> 00:33:44,726
OK, I'll go back and do the
[inaudible] Timer Fires again.


581
00:33:45,336 --> 00:33:50,356
OK, so it looks like the
timer that I'm interested


582
00:33:50,356 --> 00:33:55,206
in is firing a routine called
SWT stock table view animator


583
00:33:55,566 --> 00:33:56,506
animation step.


584
00:33:57,146 --> 00:34:05,546
So let me go back in Xcode.


585
00:34:05,706 --> 00:34:10,966
OK, so this is the timer that
is actually moving all the stock


586
00:34:10,966 --> 00:34:14,946
quotes when they animate,
and when it's over,


587
00:34:14,946 --> 00:34:17,136
it's supposed to
end the animation.


588
00:34:17,786 --> 00:34:20,866
Oh, OK. So what's
happening here is


589
00:34:22,186 --> 00:34:26,956
if the animation is
still running then--


590
00:34:27,065 --> 00:34:30,406
excuse me, if the animation is
not running, then we don't end


591
00:34:30,406 --> 00:34:32,076
up invalidating that timer.


592
00:34:32,496 --> 00:34:34,886
So let me just move this out.


593
00:34:35,516 --> 00:34:39,416
[ Pause ]


594
00:34:39,916 --> 00:34:41,235
I'll build and run.


595
00:34:41,926 --> 00:34:43,025
All right, let's try again.


596
00:34:43,456 --> 00:34:45,326
I'll switch away
right in the middle


597
00:34:45,806 --> 00:34:47,565
of one of those animations.


598
00:34:48,766 --> 00:34:50,426
Let's look at the
Energy Impact Gauge.


599
00:34:51,596 --> 00:34:52,106
All right.


600
00:34:52,106 --> 00:34:55,226
So, for the most part,
my energy impact is 0.


601
00:34:55,226 --> 00:34:57,045
Great. This is exactly
what I want.


602
00:34:57,736 --> 00:35:01,546
My app is absolutely idle
when it's not in use.


603
00:35:02,936 --> 00:35:07,866
OK, let's go back to the slides.


604
00:35:08,536 --> 00:35:10,226
So timers.


605
00:35:11,276 --> 00:35:15,776
Remember that timers involve
a lot of wakeup overhead.


606
00:35:16,026 --> 00:35:20,496
So you want to make sure that
you don't have a high rate


607
00:35:20,546 --> 00:35:25,286
of idle wakeups especially
when your app is idle,


608
00:35:25,286 --> 00:35:28,206
not doing any useful works for
the user, not doing anything


609
00:35:28,206 --> 00:35:29,676
that the user expects.


610
00:35:30,646 --> 00:35:35,176
And if it is, use our new
tools and features in Xcode 5


611
00:35:35,176 --> 00:35:37,866
and Mavericks to help debug it.


612
00:35:39,176 --> 00:35:39,796
All right.


613
00:35:39,796 --> 00:35:41,526
I want to talk about
one more things,


614
00:35:41,526 --> 00:35:43,286
and that's background work.


615
00:35:43,286 --> 00:35:49,376
So we talked a lot about
making sure your app is idle,


616
00:35:49,376 --> 00:35:52,926
no CPU usage, no wakeups
when it's not in use.


617
00:35:52,996 --> 00:35:57,506
But you probably have
some periodic work


618
00:35:57,796 --> 00:36:00,156
that you know you have
to do every so often.


619
00:36:00,916 --> 00:36:02,426
And I want to show
you how you can do it


620
00:36:02,426 --> 00:36:03,906
in an energy-efficient way.


621
00:36:04,546 --> 00:36:09,606
So, one example of this
is periodic animations.


622
00:36:10,526 --> 00:36:14,576
We saw that Stock Watcher
is stopping its animations


623
00:36:14,576 --> 00:36:16,026
when it goes into
the background.


624
00:36:16,816 --> 00:36:21,396
Animations are-- can be
relatively inexpensive,


625
00:36:21,396 --> 00:36:24,946
you know, optimized drawing
routines, low frame rate.


626
00:36:25,196 --> 00:36:28,586
But remember that even a
small amount of CPU usage,


627
00:36:29,126 --> 00:36:33,046
like an animation, can cause a
significant power draw increase.


628
00:36:33,566 --> 00:36:35,416
So-- and in a lot of cases,


629
00:36:36,386 --> 00:36:39,586
these animations might not
even be visible to the user.


630
00:36:39,846 --> 00:36:45,126
So what Stock Watcher was doing
was disabling its animation


631
00:36:45,126 --> 00:36:45,826
in the background.


632
00:36:46,176 --> 00:36:48,076
It's just doing that
by implementing the


633
00:36:48,076 --> 00:36:49,836
ApplicationDidResignActive,


634
00:36:49,836 --> 00:36:51,596
and the
ApplicationDidBecomeActive


635
00:36:51,916 --> 00:36:53,626
methods in its app delegate.


636
00:36:54,816 --> 00:36:57,586
Or if you just need
to check at runtime,


637
00:36:57,586 --> 00:36:59,826
you can ask NSApp is active.


638
00:37:00,546 --> 00:37:04,276
But in some cases, you
might actually only want


639
00:37:04,276 --> 00:37:05,946
to disable certain animations


640
00:37:05,946 --> 00:37:08,636
when the window you're
looking at is occluded.


641
00:37:09,316 --> 00:37:11,926
So something like that.


642
00:37:13,396 --> 00:37:18,076
In that case, there's new API
in Mavericks to notify you


643
00:37:18,076 --> 00:37:20,536
when an application or
window has become occluded.


644
00:37:21,696 --> 00:37:23,706
If you're interested
in the application,


645
00:37:23,936 --> 00:37:25,766
just implement the
applicationDid


646
00:37:25,766 --> 00:37:31,016
ChangeOcclusionState
routine in your app delegate.


647
00:37:31,106 --> 00:37:32,826
For Windows, just check


648
00:37:33,506 --> 00:37:37,426
or implement rather
WindowDidChangeOcclusionState


649
00:37:37,426 --> 00:37:38,406
in your window delegate.


650
00:37:39,096 --> 00:37:42,916
If you want to see a
great example of this,


651
00:37:43,376 --> 00:37:45,086
there's talk earlier this week


652
00:37:45,086 --> 00:37:48,276
about App Nap called
Improving Power Efficiency


653
00:37:48,276 --> 00:37:49,926
with App Nap, that
was yesterday.


654
00:37:50,436 --> 00:37:53,856
Go back and watch
that in the WWDC app.


655
00:37:54,146 --> 00:37:56,466
There's a great example
of how you can use these


656
00:37:56,916 --> 00:37:58,746
to be a lot more
power-efficient.


657
00:38:02,416 --> 00:38:06,046
Another way you can improve
the energy efficiency


658
00:38:06,046 --> 00:38:09,256
of your background work
is to batch it together.


659
00:38:10,036 --> 00:38:13,716
So if you have background
work that's really spread


660
00:38:13,716 --> 00:38:17,906
out over time, this
decreases the amount of time


661
00:38:17,906 --> 00:38:19,866
that we can get the
machine idle.


662
00:38:20,376 --> 00:38:24,366
So batching it all together
improves the idleness


663
00:38:24,366 --> 00:38:28,236
of the machine, reduces
wakeup costs, and allows us


664
00:38:28,236 --> 00:38:30,306
to be overall more
energy-efficient.


665
00:38:30,846 --> 00:38:34,256
So here's an example
of batching.


666
00:38:35,336 --> 00:38:39,146
Say I have an image cache
in my app and I want


667
00:38:39,146 --> 00:38:42,086
to make sure there
weren't stale images in it.


668
00:38:42,136 --> 00:38:45,156
So every time I add
an image to it,


669
00:38:45,776 --> 00:38:49,656
I also set a little timer
saying "OK, in 5 seconds,


670
00:38:49,786 --> 00:38:53,776
run this routine to make sure
this image is not stale anymore,


671
00:38:54,376 --> 00:38:55,356
or is not stale.


672
00:38:56,336 --> 00:38:59,296
And if it is then remove it."


673
00:38:59,526 --> 00:39:02,996
And then in that routine I
say, "OK, is the image stale?


674
00:39:03,206 --> 00:39:04,366
If so, remove it.


675
00:39:04,466 --> 00:39:06,836
If not, check again
in another 5 seconds."


676
00:39:07,776 --> 00:39:13,326
Well, this is kind of bad
if I just have one image


677
00:39:13,326 --> 00:39:17,686
in my cache then I'm going to
be waking up every 5 seconds,


678
00:39:17,686 --> 00:39:19,996
making sure that the
image isn't stale.


679
00:39:20,116 --> 00:39:22,726
If I have lots of images in my
cache, I'm going to be waking


680
00:39:22,726 --> 00:39:24,786
up all the time at all sorts


681
00:39:24,786 --> 00:39:26,846
of different time saying,
"Is this image stale?


682
00:39:26,846 --> 00:39:27,546
Is this image stale?"


683
00:39:27,916 --> 00:39:30,976
So this work can be
batched together.


684
00:39:31,746 --> 00:39:36,426
So I could change this code to
say, "OK, when I cache an image,


685
00:39:36,426 --> 00:39:38,286
just add it to the
list of images."


686
00:39:38,796 --> 00:39:42,006
And then when I know I'm going
to have to do some other work


687
00:39:42,006 --> 00:39:45,206
like handling a user
event, I can just go ahead


688
00:39:45,206 --> 00:39:49,876
and kick off this cache checking
work to another dispatch queue.


689
00:39:49,876 --> 00:39:52,216
That way, it doesn't interfere
with the user interaction.


690
00:39:52,936 --> 00:39:53,906
Go through each of them.


691
00:39:54,746 --> 00:39:55,976
Prune all the stale ones.


692
00:39:56,516 --> 00:40:00,026
[ Pause ]


693
00:40:00,526 --> 00:40:05,266
And you may have some periodic
work that is even lower priority


694
00:40:05,266 --> 00:40:07,106
that can wait even longer.


695
00:40:07,106 --> 00:40:08,586
And for that, we have a new API


696
00:40:08,586 --> 00:40:12,066
in Mavericks called
Centralized Task Scheduling.


697
00:40:13,026 --> 00:40:16,106
And what this does is it allows
you to tell the system, "Here,


698
00:40:16,106 --> 00:40:19,286
I've got this bit of work
that is really low priority,


699
00:40:19,286 --> 00:40:22,796
and it's actually-- it's a low
priority that I'm OK waiting


700
00:40:22,796 --> 00:40:25,036
for the user to plug
their machine back


701
00:40:25,036 --> 00:40:26,096
in before I start it."


702
00:40:27,226 --> 00:40:30,296
So this is stuff like
cleaning up temporary files,


703
00:40:30,296 --> 00:40:31,726
maybe sinking or indexing,


704
00:40:31,946 --> 00:40:34,696
checking for new
updates is a common one.


705
00:40:35,566 --> 00:40:38,906
So new API in XPC that
allows you to do it,


706
00:40:38,906 --> 00:40:40,066
and I'll show you
how to use it now.


707
00:40:41,466 --> 00:40:45,496
So first, you just create
a new empty XPC dictionary.


708
00:40:47,246 --> 00:40:52,056
You say, "OK, this is a one-time
event," so you're telling XPC,


709
00:40:52,106 --> 00:40:53,726
"This doesn't have to repeat.


710
00:40:53,726 --> 00:40:55,156
It's just once."


711
00:40:56,246 --> 00:41:00,656
I want this to happen in
an hour, 3,600 seconds,


712
00:41:00,706 --> 00:41:04,916
but I'm OK if it doesn't start
for another 6 hours after that,


713
00:41:04,916 --> 00:41:07,616
or even longer, maybe
even 24 hours.


714
00:41:07,616 --> 00:41:13,016
So-- and then I tell
XPC that the priority


715
00:41:13,186 --> 00:41:15,176
of this activity is maintenance.


716
00:41:16,006 --> 00:41:20,616
And what this means is
"Hey, XPC, try to do this


717
00:41:20,616 --> 00:41:22,956
when the user has plugged
back in their machine,


718
00:41:22,956 --> 00:41:26,006
and also when they're not using
their machine so it doesn't get


719
00:41:26,006 --> 00:41:27,436
in the way of responsiveness."


720
00:41:29,136 --> 00:41:31,766
Then you just go ahead,
register your activity,


721
00:41:31,766 --> 00:41:35,286
pass that dictionary in, give
it a label, and give it a block


722
00:41:35,566 --> 00:41:36,696
with the work you want to do.


723
00:41:37,016 --> 00:41:39,056
XPC will take care of the rest.


724
00:41:39,336 --> 00:41:42,076
It'll run your block
on its own queue.


725
00:41:42,366 --> 00:41:44,906
It'll, you know, you'll
have the work done for you


726
00:41:44,906 --> 00:41:48,086
at an appropriate time,
and you won't interfere


727
00:41:48,086 --> 00:41:49,386
with the user's battery life.


728
00:41:49,916 --> 00:41:57,196
There's a lot more to XPC
activity, and XPC in general,


729
00:41:57,196 --> 00:42:00,686
there's a session earlier this
week, Efficient Design with XPC.


730
00:42:00,766 --> 00:42:04,116
If you're interested, go ahead
and give that a watch online.


731
00:42:05,566 --> 00:42:09,756
So if you only remember
one thing from today,


732
00:42:09,756 --> 00:42:14,176
let it be this, that
a small amount


733
00:42:14,176 --> 00:42:20,076
of CPU usage causes a large
power increase from the CPU.


734
00:42:20,786 --> 00:42:25,436
So you want your apps
to achieve absolute idle


735
00:42:26,146 --> 00:42:27,196
when they're not in use.


736
00:42:29,416 --> 00:42:33,606
Now, I know you guys can
take this advice and go back


737
00:42:33,606 --> 00:42:36,766
and make your apps as
energy-efficient as possible,


738
00:42:36,766 --> 00:42:40,576
and I can't wait for that,
but I also want you guys


739
00:42:41,166 --> 00:42:43,746
to integrate this into
your release process.


740
00:42:44,436 --> 00:42:48,926
So test for energy efficiency
just like you would test


741
00:42:48,926 --> 00:42:52,666
for performance or
reliability or correctness.


742
00:42:56,616 --> 00:42:59,126
If you have any questions
about energy efficiency,


743
00:42:59,126 --> 00:43:01,936
you can contact our Core
S Technologies Evangelist,


744
00:43:01,936 --> 00:43:02,976
that's Paul Denbaum.


745
00:43:03,706 --> 00:43:05,656
If you have questions
about Instruments,


746
00:43:05,656 --> 00:43:07,406
you can contact Dave
DeLong or look


747
00:43:07,406 --> 00:43:11,496
at the Instruments User
Guide on developer.apple.com.


748
00:43:11,856 --> 00:43:14,696
And of course, you
can ask questions


749
00:43:14,696 --> 00:43:16,536
on the Apple developer forums.


750
00:43:17,686 --> 00:43:21,246
We've had a ton of
great sessions this week


751
00:43:21,816 --> 00:43:27,006
about battery life and
energy, so definitely go back


752
00:43:27,006 --> 00:43:30,846
if you're interested and watch
these, especially, you know,


753
00:43:30,846 --> 00:43:34,386
Maximizing Battery Life on OS
X will give you a great sort


754
00:43:34,386 --> 00:43:37,176
of overview of everything
we've done and everything we'd


755
00:43:37,176 --> 00:43:40,116
like you to do for energy
efficiency and battery life.


756
00:43:40,506 --> 00:43:46,076
If you're interested in App
Nap and most of you should be,


757
00:43:46,076 --> 00:43:48,646
look at the Improving Power
Efficiency with App Nap session.


758
00:43:49,336 --> 00:43:52,056
If you write for the web,


759
00:43:52,056 --> 00:43:54,206
there's a great session
yesterday


760
00:43:54,206 --> 00:43:56,836
about how you can make an
energy efficient website.


761
00:43:57,226 --> 00:44:01,216
Of course there was
the XPC session,


762
00:44:01,216 --> 00:44:05,966
and I highly recommend the
Building Efficient OS X session


763
00:44:05,966 --> 00:44:08,816
which was on Tuesday
if you are interested


764
00:44:08,816 --> 00:44:11,816
in just being a good system
citizen in general with respect


765
00:44:11,816 --> 00:44:13,746
to energy performance
and everything.


766
00:44:14,186 --> 00:44:15,436
Thank you so much for coming.


767
00:44:15,436 --> 00:44:16,466
Enjoy the rest of the week.


768
00:44:16,466 --> 00:44:17,416
Enjoy the bash.


769
00:44:18,006 --> 00:44:19,096
Happy WWDC.


770
00:44:19,596 --> 00:44:23,590
[Applause]

