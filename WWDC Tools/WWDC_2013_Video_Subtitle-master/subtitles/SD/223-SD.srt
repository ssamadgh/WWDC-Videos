1
00:00:00,506 --> 00:00:08,516
[ Silence ]


2
00:00:09,016 --> 00:00:14,000
[ Applause ]


3
00:00:14,786 --> 00:00:15,206
>> Thank you.


4
00:00:15,206 --> 00:00:15,826
Good morning.


5
00:00:16,476 --> 00:00:20,626
I'm Ned Holbrook and this
is Session 223 Using Fonts


6
00:00:20,626 --> 00:00:21,186
of Text Kit.


7
00:00:21,886 --> 00:00:23,296
So let me give you an
overview of what we're going


8
00:00:23,296 --> 00:00:24,726
to be talking about
during this session.


9
00:00:25,716 --> 00:00:27,256
First we're going
to talk about how


10
00:00:27,256 --> 00:00:28,636
to specify fonts in your app.


11
00:00:30,706 --> 00:00:32,606
We're going to be
talking in particular


12
00:00:32,606 --> 00:00:35,926
about the new Dynamic
Type technology in iOS 7.


13
00:00:35,996 --> 00:00:39,016
We're going to be talking
about font descriptors.


14
00:00:39,766 --> 00:00:41,796
We're going to be talking
about the techniques


15
00:00:41,906 --> 00:00:44,236
for adding fonts to
your application.


16
00:00:45,266 --> 00:00:48,356
And we're also going to be
talking about a couple of topics


17
00:00:48,476 --> 00:00:50,226
that are going to be
particularly relevant


18
00:00:50,476 --> 00:00:52,836
to developers of
multilingual applications.


19
00:00:53,766 --> 00:00:56,246
Language tagging, a
new mechanism available


20
00:00:56,246 --> 00:01:00,316
in both iOS X and iOS 7,
and modifying fallbacks,


21
00:01:00,606 --> 00:01:03,826
also available on
both platforms.


22
00:01:03,826 --> 00:01:07,376
Now, some of the material for
specifying fonts is also going


23
00:01:07,376 --> 00:01:10,616
to be relevant for OS X as well.


24
00:01:10,616 --> 00:01:12,546
So if you manage to
straggle in with --


25
00:01:13,026 --> 00:01:14,706
in hopes of hearing
something about OS X,


26
00:01:15,006 --> 00:01:18,396
you came to the right place.


27
00:01:18,576 --> 00:01:22,566
First, I'd like to
talk about Text Kit.


28
00:01:22,766 --> 00:01:24,046
I hope you've gone to some


29
00:01:24,046 --> 00:01:26,356
of the other sessions
introducing you


30
00:01:26,356 --> 00:01:29,156
to this great new
technology available in iOS 7.


31
00:01:29,776 --> 00:01:31,686
But since this Friday
morning after the beer bash,


32
00:01:31,736 --> 00:01:33,446
let's have a quick review.


33
00:01:33,946 --> 00:01:40,096
Text Kit is the great new text
framework based on Cocoa text


34
00:01:40,666 --> 00:01:42,006
and brand new to iOS 7.


35
00:01:42,636 --> 00:01:47,616
It allows you to get
amazing control and precision


36
00:01:48,016 --> 00:01:50,086
when it comes to
typography in your app.


37
00:01:51,686 --> 00:01:53,946
And what's most interesting
for this session is


38
00:01:53,996 --> 00:01:57,286
that both Text Kit and
WebKit are built in Core Text


39
00:01:57,926 --> 00:02:01,916
which is our low level unit
code layout engine available


40
00:02:02,186 --> 00:02:04,976
on both iOS and OS X.


41
00:02:05,196 --> 00:02:07,886
Now, Core Text is
still available to you


42
00:02:08,006 --> 00:02:11,576
if you've been making
use of it in the past.


43
00:02:11,576 --> 00:02:14,646
And in particular, we think it's
best for very specialized tasks.


44
00:02:15,846 --> 00:02:18,436
In fact, there's one task
that it was built for


45
00:02:18,436 --> 00:02:20,856
and that was enabling
the development


46
00:02:20,916 --> 00:02:24,506
of higher level Text Kit --
text frameworks like Text Kit


47
00:02:24,506 --> 00:02:27,536
and WebKit, maybe you've
even have to build your own.


48
00:02:28,086 --> 00:02:31,356
But really when it comes
down to it, we encourage you


49
00:02:31,356 --> 00:02:34,176
to use the highest level
framework available


50
00:02:34,846 --> 00:02:35,676
that suits your needs.


51
00:02:36,406 --> 00:02:40,946
And particularly with iOS 7,
we hope that will be Text Kit.


52
00:02:41,166 --> 00:02:43,296
Now, no matter which
framework you're making use


53
00:02:43,296 --> 00:02:46,636
of for advanced typography
in your app.


54
00:02:47,356 --> 00:02:49,646
At the heart of it
all, we're dealing


55
00:02:49,646 --> 00:02:50,826
with Unicode text layout.


56
00:02:51,896 --> 00:02:53,736
Now, this is represented


57
00:02:53,736 --> 00:02:58,266
by the equation String
plus Font equals Glyphs.


58
00:02:58,406 --> 00:03:02,996
And when dealing with user
content, there's really only one


59
00:03:02,996 --> 00:03:05,006
of those variables
that you have control


60
00:03:05,006 --> 00:03:05,986
over and that's the font.


61
00:03:06,546 --> 00:03:08,866
The string is likely going
to be the user's content.


62
00:03:09,716 --> 00:03:13,766
But we're going to talk
about how you can choose


63
00:03:13,766 --> 00:03:17,286
that font correctly in order


64
00:03:17,286 --> 00:03:20,986
to get the best possible
display of text in your app.


65
00:03:22,596 --> 00:03:25,956
So let's find out
how to do that.


66
00:03:26,106 --> 00:03:27,736
Well you've got a number
of choices when it comes


67
00:03:27,766 --> 00:03:32,146
to choosing a font
for use in your app.


68
00:03:32,456 --> 00:03:34,596
The most exciting one
to me and I hope to you


69
00:03:34,596 --> 00:03:36,986
as well is dynamic
type which is available


70
00:03:37,366 --> 00:03:39,156
for the first time in iOS 7.


71
00:03:40,516 --> 00:03:44,046
There's also the system font
that you are probably familiar


72
00:03:44,046 --> 00:03:48,756
with and you may still may
need to make use of in iOS 7.


73
00:03:49,746 --> 00:03:51,526
We're going to be talking
about UIFontDescriptor


74
00:03:51,526 --> 00:03:56,906
which is the class I use to
identify fonts on the system.


75
00:03:57,896 --> 00:04:00,226
And as I mentioned, we're
also going to talk about how


76
00:04:00,226 --> 00:04:05,586
to bring your own apps to your
application or fonts, excuse me.


77
00:04:06,396 --> 00:04:08,366
First, I'd like to
show you an example


78
00:04:08,616 --> 00:04:12,806
of the new dynamic type
technology in iOS 7.


79
00:04:12,956 --> 00:04:16,875
I hope you've seen some really
wonderful examples of this


80
00:04:16,986 --> 00:04:20,446
in previous sessions, but
since I'm going to be talking


81
00:04:20,446 --> 00:04:22,506
about some of the more
technical aspects,


82
00:04:22,506 --> 00:04:25,596
so I thought I'd give you a
quick refresher of this as well.


83
00:04:26,386 --> 00:04:32,556
Here we see the same Mailbox
presented in mail on iOS 7


84
00:04:32,856 --> 00:04:35,736
in three different
content sizes.


85
00:04:37,426 --> 00:04:41,036
Now, this is just three
out of a total of seven


86
00:04:41,606 --> 00:04:43,186
that a user can choose from.


87
00:04:44,096 --> 00:04:46,786
But I wanted to point out here


88
00:04:46,786 --> 00:04:48,696
that on the left I
have the smallest size,


89
00:04:49,476 --> 00:04:51,026
in the middle I have
the middle size,


90
00:04:51,206 --> 00:04:52,536
and then on the right
we're looking


91
00:04:52,536 --> 00:04:56,626
at the largest user
selectable dynamic type size.


92
00:04:57,746 --> 00:05:01,486
So, as we can see, mail is a
very text heavy application.


93
00:05:02,486 --> 00:05:04,816
But it still has what
we'd like to display


94
00:05:04,886 --> 00:05:09,236
as sort of hierarchy of type.


95
00:05:09,296 --> 00:05:14,456
So, you'll note that there're
several different weights


96
00:05:14,866 --> 00:05:18,556
of type visible in
this situation.


97
00:05:19,366 --> 00:05:22,306
But you'll note that regardless
of the size of that type,


98
00:05:22,826 --> 00:05:24,476
there's a very clear
relationship


99
00:05:24,476 --> 00:05:28,576
between the different
pieces of text on screen.


100
00:05:28,756 --> 00:05:31,146
And one of the great
things about dynamic type is


101
00:05:31,206 --> 00:05:34,436
that it gives you the
tools you need in order


102
00:05:34,436 --> 00:05:38,906
to present information
using the same types


103
00:05:38,906 --> 00:05:43,486
of semantic distinctions in
the text, and we'll be talking


104
00:05:43,486 --> 00:05:46,136
about exactly how to do that.


105
00:05:46,356 --> 00:05:51,546
Note also that as the type size
changes, it's not all being fit


106
00:05:51,546 --> 00:05:52,736
into the same size box.


107
00:05:53,436 --> 00:05:55,666
Mail has a really great
dynamic type citizen


108
00:05:55,666 --> 00:05:58,426
and it's actually
reacting to the size


109
00:05:58,606 --> 00:06:00,506
of the user's preference


110
00:06:01,046 --> 00:06:05,116
and resizing the table
view cells to match.


111
00:06:05,976 --> 00:06:09,896
So even though by its very
nature as the type gets larger,


112
00:06:10,406 --> 00:06:12,066
the information density
decreases.


113
00:06:13,336 --> 00:06:16,346
Mail itself is reacting to that


114
00:06:16,566 --> 00:06:18,196
and responding to
the user's choice.


115
00:06:19,296 --> 00:06:21,646
Note also that in
addition to the seven sizes


116
00:06:21,646 --> 00:06:23,676
that are available, three
of which I've shown here,


117
00:06:24,166 --> 00:06:31,376
there's also a switch that
can add a bit of weight


118
00:06:31,376 --> 00:06:36,386
to those type styles,
and that's available via


119
00:06:36,386 --> 00:06:37,986
accessibility settings.


120
00:06:39,756 --> 00:06:45,796
So dynamic type is organized by
what we consider to be usage.


121
00:06:46,346 --> 00:06:52,526
Each one of these is a text
style as we like to call it.


122
00:06:52,716 --> 00:06:56,876
As you've seen in the previous
session, there are, I believe,


123
00:06:56,876 --> 00:07:00,546
eight of these different
usage categories


124
00:07:00,726 --> 00:07:01,966
for use with text styles.


125
00:07:02,516 --> 00:07:06,826
These are things like
Body, Headline 1, Caption.


126
00:07:07,386 --> 00:07:12,746
And every one of these different
text styles is optimized


127
00:07:12,746 --> 00:07:13,466
for legibility.


128
00:07:14,306 --> 00:07:16,916
We'll be showing you an example
of one of this in particular.


129
00:07:18,196 --> 00:07:20,866
But, again, remember that
the user is responsible


130
00:07:20,866 --> 00:07:22,956
for picking the size
of these text styles.


131
00:07:23,906 --> 00:07:27,996
So, for any given text
style, you're going to see it


132
00:07:28,276 --> 00:07:30,546
in a number of different sizes.


133
00:07:30,666 --> 00:07:32,316
The metrics are going
to change based


134
00:07:32,316 --> 00:07:34,226
on something that's
out of your control.


135
00:07:34,346 --> 00:07:35,606
That is the user
is going to choose.


136
00:07:36,556 --> 00:07:38,436
And so, of course,
we highly encourage


137
00:07:38,516 --> 00:07:44,416
that you adopt auto layout
constraints for resizing your UI


138
00:07:44,646 --> 00:07:48,326
to adapt to the user's content.


139
00:07:48,546 --> 00:07:51,196
But even if you're
not doing that,


140
00:07:51,196 --> 00:07:52,446
you may have some
other techniques.


141
00:07:53,076 --> 00:07:56,226
You should be aware that these
metrics are going to change.


142
00:07:57,486 --> 00:08:00,416
And as I'm sure you've
already seen Interface Builder


143
00:08:00,416 --> 00:08:03,136
with Xcode 5 has a great
support for these text styles,


144
00:08:03,136 --> 00:08:04,786
so you can specify
them right in line


145
00:08:05,106 --> 00:08:06,546
where you're designing
your user interface.


146
00:08:06,706 --> 00:08:11,056
Now, let's take a look at one of
these text styles in particular.


147
00:08:12,126 --> 00:08:15,796
On the slide, I've chosen one
of the subhead text styles


148
00:08:16,486 --> 00:08:20,066
and what I have here is what's
called the waterfall chart


149
00:08:20,636 --> 00:08:25,416
which is simply the same
sample text set in all


150
00:08:25,416 --> 00:08:27,036
of the different user
selectable sizes.


151
00:08:27,586 --> 00:08:31,616
Now, you don't have to
be a typographer to see


152
00:08:31,616 --> 00:08:34,785
that this text is
clearly related,


153
00:08:34,785 --> 00:08:37,676
all these different sizes
probably meaning the same thing.


154
00:08:38,366 --> 00:08:41,006
But again, not just sizes.


155
00:08:41,436 --> 00:08:43,506
We have a type system involved


156
00:08:43,856 --> 00:08:48,976
where this particular text style
subhead is related visually


157
00:08:48,976 --> 00:08:53,226
to the other text styles and
so one of these in conjunction


158
00:08:53,226 --> 00:08:57,266
with other text styles
allows you to present a very,


159
00:08:57,266 --> 00:09:01,316
very rich information hierarchy.


160
00:09:02,426 --> 00:09:05,456
You'll also note that this
particular text style --


161
00:09:05,716 --> 00:09:07,606
all these different sizes
have a very consistent --


162
00:09:07,656 --> 00:09:09,306
what typographers call color.


163
00:09:10,656 --> 00:09:14,736
But let's zoom in and take a
look at what I mean when I say


164
00:09:14,736 --> 00:09:16,606
that these are optimized
for legibility.


165
00:09:17,246 --> 00:09:21,386
So, we're going take
a look at the smallest


166
00:09:21,896 --> 00:09:25,666
and the largest text
styles sizes zoomed


167
00:09:25,666 --> 00:09:27,626
in to the same point size.


168
00:09:28,206 --> 00:09:32,476
And here I've taken the liberty
of annotating the white space


169
00:09:32,956 --> 00:09:37,926
in this example to show you that
besides having different weights


170
00:09:38,496 --> 00:09:40,906
of type in this particular
example,


171
00:09:41,886 --> 00:09:43,746
we've also adjusted
the letter spacing


172
00:09:44,226 --> 00:09:48,626
because a smaller text needs
more room to breathe in order


173
00:09:48,626 --> 00:09:52,306
for us to ingest it
with our brains and eyes


174
00:09:52,656 --> 00:09:55,326
to really dig into the context.


175
00:09:55,476 --> 00:09:57,586
These sizes adjust
both the letter spacing


176
00:09:57,936 --> 00:10:01,156
and also the line spacing
which is hard to show


177
00:10:01,156 --> 00:10:01,976
on this particular example.


178
00:10:03,296 --> 00:10:06,846
But -- So, if you can
consider that we have this grid


179
00:10:06,846 --> 00:10:09,866
of these different sizes,
these different styles,


180
00:10:09,906 --> 00:10:12,346
there's really a huge amount
of design effort that went


181
00:10:12,346 --> 00:10:15,586
into these typefaces
and the great part is


182
00:10:15,686 --> 00:10:18,106
that they're all
available to you.


183
00:10:18,666 --> 00:10:24,326
So in order to make use of these
text styles, this huge amount


184
00:10:24,326 --> 00:10:28,026
of design for this
beautiful type,


185
00:10:28,026 --> 00:10:29,416
you'll probably been making use


186
00:10:29,416 --> 00:10:32,036
of UIFont
preferredFontForTextStyle


187
00:10:33,046 --> 00:10:35,236
which is a class
factory method on UIFont


188
00:10:35,476 --> 00:10:38,346
that takes a single
argument which is one


189
00:10:38,346 --> 00:10:40,056
of those text style identifiers


190
00:10:40,296 --> 00:10:42,256
that you can find
in UIFontDescriptor.


191
00:10:44,496 --> 00:10:48,126
Besides the base text
style categories,


192
00:10:48,126 --> 00:10:51,376
you can also make
some changes to those


193
00:10:51,466 --> 00:10:54,036
by modifying them
with symbolic traits.


194
00:10:54,816 --> 00:10:57,226
So the ones in particular
that you're likely


195
00:10:57,226 --> 00:11:00,546
to find useful are Bold, Italic,
and we also have special traits


196
00:11:00,616 --> 00:11:02,326
for adjusting the line spacing.


197
00:11:02,856 --> 00:11:07,796
So depending on the content
being presented, you may be able


198
00:11:07,906 --> 00:11:12,586
to tighten the line spacing
a bit if you're dealing


199
00:11:12,586 --> 00:11:14,746
with say a single label.


200
00:11:16,066 --> 00:11:19,596
Or for longer line lengths,
you may find it necessary


201
00:11:19,596 --> 00:11:21,926
to actually loosen the line
spacing to give a bit more


202
00:11:21,926 --> 00:11:25,206
of that white space that's
needed for best legibility,


203
00:11:25,886 --> 00:11:27,286
and we'll be showing
you an example of how


204
00:11:27,286 --> 00:11:28,626
to do that in code shortly.


205
00:11:29,946 --> 00:11:33,006
Note also that all of this
amazing technology is available


206
00:11:33,556 --> 00:11:34,766
in CSS as well.


207
00:11:35,426 --> 00:11:38,346
One of the earlier sessions,
the Intro to Text Kit Session


208
00:11:38,896 --> 00:11:41,096
and you may have also heard
in the WebKit session,


209
00:11:41,436 --> 00:11:44,506
there are properties
corresponding to each one


210
00:11:44,506 --> 00:11:48,096
of these type styles -- text
styles, they're prefixed


211
00:11:48,096 --> 00:11:51,516
with -apple-system, and
so you can find the list


212
00:11:51,516 --> 00:11:53,546
of those elsewhere, but --


213
00:11:54,086 --> 00:11:58,416
so if any part of your UI is
still built using a WebView,


214
00:11:58,686 --> 00:11:59,966
that's all right.


215
00:12:00,486 --> 00:12:00,886
That's great.


216
00:12:00,886 --> 00:12:03,006
You can still access
this great technology.


217
00:12:03,626 --> 00:12:12,706
Now, text styles are part of a
larger category of fonts that I


218
00:12:13,186 --> 00:12:15,486
like to think of as
being sort of a metafont.


219
00:12:16,496 --> 00:12:19,716
So, you'll note that with
text styles in particular,


220
00:12:20,296 --> 00:12:24,826
as you may have seen in that
example, I know that the weight


221
00:12:24,926 --> 00:12:27,086
of the type was actually
changing in response


222
00:12:27,186 --> 00:12:29,546
to the user preference.


223
00:12:29,786 --> 00:12:34,346
And so naturally, you can assume
that for a given text style,


224
00:12:34,396 --> 00:12:38,386
the actual font that's
used to render that text


225
00:12:38,926 --> 00:12:42,186
to screen may not be the
same in all situations.


226
00:12:42,646 --> 00:12:46,456
And so, we've also
seen this on OS X


227
00:12:47,356 --> 00:12:52,756
where Mavericks brings a new
system UIFont that's optimized


228
00:12:52,756 --> 00:12:55,146
for Retina Displays.


229
00:12:55,716 --> 00:12:59,726
And so, as OS X developers,
those of you in the audience


230
00:12:59,726 --> 00:13:03,186
who have done programming
in OS X, you may be familiar


231
00:13:03,186 --> 00:13:06,846
with the various NSFont class
factory methods for getting


232
00:13:06,886 --> 00:13:10,686
at what I would consider
to be this system font,


233
00:13:10,746 --> 00:13:13,466
this semantic notions
of what a font may be.


234
00:13:14,096 --> 00:13:17,326
You may have seen menu font
of size, control font of size,


235
00:13:17,326 --> 00:13:17,976
these types of things.


236
00:13:18,766 --> 00:13:21,826
But, many of you may
have also noticed


237
00:13:21,896 --> 00:13:24,106
that in the past whenever
you used one of these,


238
00:13:24,106 --> 00:13:28,176
you typically got back the same
thing every time, Lucida Grande.


239
00:13:29,946 --> 00:13:32,446
And so you may have said, "well,
you know, I mean this is great,


240
00:13:32,496 --> 00:13:35,376
but I know it's just
going to end


241
00:13:35,376 --> 00:13:36,536
up being the same
thing in the end.


242
00:13:36,976 --> 00:13:40,086
So I may as well just
specify that in my code


243
00:13:40,086 --> 00:13:42,016
or in my zeb [phonetic]
or whatever".


244
00:13:43,456 --> 00:13:50,826
But by doing so, you lose the
ability to adapt to improvements


245
00:13:50,826 --> 00:13:54,596
that are made in the
system font technologies.


246
00:13:55,936 --> 00:13:58,736
You'll note that this is
particularly so when it comes


247
00:13:58,776 --> 00:14:01,656
to text styles because
it's not just


248
00:14:01,696 --> 00:14:04,296
that the font may be changing
across releases, they're going


249
00:14:04,296 --> 00:14:07,056
to be changing dynamically
and in the Intro


250
00:14:07,056 --> 00:14:10,446
to Text Kit Session, you saw how
to adapt to that dynamically.


251
00:14:11,486 --> 00:14:17,416
But one thing that's shared
with all of these fonts is


252
00:14:17,416 --> 00:14:20,856
that when you poke around, you
may end up seeing font names


253
00:14:20,966 --> 00:14:21,966
that start with a period.


254
00:14:23,556 --> 00:14:26,386
And, as we all know from
our grand UNIX history,


255
00:14:26,746 --> 00:14:29,896
something that begins with a
period is not meant to be seen.


256
00:14:30,916 --> 00:14:34,296
And so when you're dealing
with these system fonts,


257
00:14:34,676 --> 00:14:38,756
if you find one of these, that's
a sign to you, the developer,


258
00:14:38,756 --> 00:14:41,656
that not only are you not
be presenting those names


259
00:14:42,126 --> 00:14:45,336
to the user directly,
but it's also a note


260
00:14:45,966 --> 00:14:47,696
that there's magic involved.


261
00:14:48,566 --> 00:14:51,076
And so really you should
be dealing with these


262
00:14:51,136 --> 00:14:55,326
by identifying these system
fonts using their semantic


263
00:14:55,326 --> 00:14:57,946
identifiers, this class factory
methods, these text styles.


264
00:14:58,666 --> 00:15:02,366
And never -- would it be
appropriate to drop down


265
00:15:02,836 --> 00:15:08,016
and grab a CD font and deal
with that moving onwards.


266
00:15:08,826 --> 00:15:12,786
So, UIFont does have one of
these class factory methods


267
00:15:13,126 --> 00:15:15,486
that you've seen
before, systemFontOfSize,


268
00:15:15,836 --> 00:15:19,396
also Bold and Italic variants.


269
00:15:19,846 --> 00:15:22,346
But this is -- there's
a clear distinction


270
00:15:22,346 --> 00:15:23,756
to be made now in iOS 7.


271
00:15:24,416 --> 00:15:26,986
The system font is not meant
to be used for user content,


272
00:15:27,576 --> 00:15:30,066
that's what text styles are for.


273
00:15:30,126 --> 00:15:33,146
And in addition, only if
you recompiled your app


274
00:15:33,386 --> 00:15:37,966
for iOS 7 will that
system font be adopting any


275
00:15:37,966 --> 00:15:41,936
of the new improvements
made to the typography.


276
00:15:42,936 --> 00:15:46,216
So, keep this in mind when
you're designing your app


277
00:15:46,216 --> 00:15:48,196
and your users will thank you.


278
00:15:49,576 --> 00:15:56,076
So UIFontDescriptor or -- also a
very similar technology on OS X,


279
00:15:56,076 --> 00:15:58,546
NSFont Descriptor, is the class


280
00:15:58,546 --> 00:16:02,456
that we use for describing
fonts.


281
00:16:02,456 --> 00:16:04,766
It's a very, very
lightweight mechanism.


282
00:16:05,186 --> 00:16:09,196
It doesn't involve spooling up
any rendering system in order


283
00:16:09,196 --> 00:16:10,926
to have an actual font on hand.


284
00:16:11,386 --> 00:16:14,436
It's simply the mechanism we
use for getting up that font.


285
00:16:15,366 --> 00:16:16,536
It allows you to access


286
00:16:16,536 --> 00:16:18,586
and in some cases
modify font properties.


287
00:16:18,586 --> 00:16:20,016
We'll be showing
you that as well.


288
00:16:20,756 --> 00:16:24,086
UIFontDescriptor is the
base technology for finding


289
00:16:24,086 --> 00:16:27,126
out what fonts are
available to your app


290
00:16:27,626 --> 00:16:29,146
and it's also the mechanism


291
00:16:29,146 --> 00:16:30,886
by which you can
specify your own fonts


292
00:16:31,046 --> 00:16:34,846
if you've licensed them for
use in your user interface.


293
00:16:35,966 --> 00:16:41,606
So the way we use a descriptor
is by noting that it looks a lot


294
00:16:41,606 --> 00:16:44,986
like a dictionary
with key value pairs.


295
00:16:46,166 --> 00:16:48,866
In this case, those key
value pairs are called


296
00:16:48,866 --> 00:16:50,066
font attributes.


297
00:16:50,876 --> 00:16:53,456
They correspond to any number


298
00:16:53,456 --> 00:16:56,216
of particular properties
that fonts have.


299
00:16:56,496 --> 00:16:58,686
It bears the names, the size,


300
00:16:59,086 --> 00:17:01,116
what typographic
features might be enabled.


301
00:17:01,886 --> 00:17:06,056
And you'll note that using
a descriptor, it's very easy


302
00:17:06,056 --> 00:17:09,685
to create one for a
font that doesn't exist.


303
00:17:10,906 --> 00:17:13,955
For instance, I could use
a descriptor to specify


304
00:17:13,955 --> 00:17:19,596
that I want a font that's
in the Helvetica family


305
00:17:20,796 --> 00:17:26,836
and that its style is purp --
well, until type designers sort


306
00:17:27,046 --> 00:17:30,576
of embrace their
synesthetic side when it comes


307
00:17:30,576 --> 00:17:32,466
to designing fonts,
I doubt we're going


308
00:17:32,466 --> 00:17:36,616
to see purple being a
commonly use style for a font.


309
00:17:37,196 --> 00:17:40,716
But, we're going to need
a mechanism for finding


310
00:17:40,716 --> 00:17:42,546
out whether or not these
descriptors correspond


311
00:17:42,546 --> 00:17:45,866
to actual fonts in the system,
and then the mechanism we use


312
00:17:45,866 --> 00:17:47,446
for that is called matching.


313
00:17:48,026 --> 00:17:53,136
So there's two types of
descriptor matching when we want


314
00:17:53,196 --> 00:17:55,926
to take an abstract
descriptor and turn


315
00:17:55,926 --> 00:17:57,096
into something more concrete,


316
00:17:57,096 --> 00:17:59,226
that is something that's
based on the real font.


317
00:17:59,746 --> 00:18:04,446
And the first is
explicit matching.


318
00:18:05,356 --> 00:18:07,456
You can invoke
matchingFontDescriptors


319
00:18:07,456 --> 00:18:09,236
WithMandatoryKeys
on a descriptor.


320
00:18:10,096 --> 00:18:13,366
And you'll get back an
array of potentially many --


321
00:18:13,366 --> 00:18:18,106
potentially no font descriptors
that correspond to fonts


322
00:18:18,106 --> 00:18:20,046
that are actually
available to your application


323
00:18:20,046 --> 00:18:20,866
at the time of that call.


324
00:18:21,686 --> 00:18:26,746
There're also various methods
that perform this matching


325
00:18:26,796 --> 00:18:29,406
on your behalf and so this I


326
00:18:29,406 --> 00:18:32,036
like to consider
implicit matching.


327
00:18:32,976 --> 00:18:35,976
So, for instance,
fontDescriptorWithSymbolicTraits


328
00:18:36,456 --> 00:18:39,736
which we'll have a code
example of in just a moment,


329
00:18:39,736 --> 00:18:41,616
when you invoke this method,


330
00:18:42,116 --> 00:18:44,086
it will be using
matchingFontDescriptors


331
00:18:44,086 --> 00:18:46,726
WithMandatoryKeys under the hood


332
00:18:47,366 --> 00:18:51,176
and so the results you get
back will correspond to fonts


333
00:18:51,176 --> 00:18:53,806
that are actually available,
and so in that sense,


334
00:18:54,016 --> 00:18:56,816
it's being done implicitly
on your behalf.


335
00:18:57,426 --> 00:18:58,966
In addition, you
can create a font


336
00:18:58,966 --> 00:19:02,476
from a descriptor directly
because, of course, when we want


337
00:19:02,476 --> 00:19:04,836
to materialize that
descriptor into a font,


338
00:19:05,256 --> 00:19:07,836
we need to have something
to use in that case.


339
00:19:08,416 --> 00:19:12,816
And so this method will also
perform matching on your behalf


340
00:19:13,336 --> 00:19:16,566
but it also means that if
you didn't explicitly make


341
00:19:16,596 --> 00:19:20,976
that match before hand, it might
not be exactly what you expected


342
00:19:21,556 --> 00:19:24,926
due to having specified a
font that doesn't exist.


343
00:19:25,916 --> 00:19:28,326
So let's go ahead
and make a match.


344
00:19:28,656 --> 00:19:32,036
On this code example, I'm
creating a UIFrontDescriptor


345
00:19:32,426 --> 00:19:34,416
from a dictionary
of font attributes.


346
00:19:34,886 --> 00:19:39,246
In this case, I'm specifying the
family attribute with the value


347
00:19:39,246 --> 00:19:42,776
of Helvetica Neue, and I want
to see what's available to me.


348
00:19:44,156 --> 00:19:46,516
So, as I mentioned, I invoked
matchingFontDescriptors


349
00:19:46,516 --> 00:19:47,466
WithMandatoryKeys.


350
00:19:48,406 --> 00:19:50,006
In this case, I'm
going to pass nill.


351
00:19:50,006 --> 00:19:52,426
This is the most common
situation, passing nill means


352
00:19:52,426 --> 00:19:55,476
to use all of the keys,
all of the font attributes


353
00:19:55,476 --> 00:19:56,176
in the dictionary


354
00:19:56,596 --> 00:19:58,886
when considering what
constitutes a match.


355
00:19:59,196 --> 00:20:03,556
But if you would like to only
consider certain attributes


356
00:20:03,786 --> 00:20:06,646
in the font descriptor, you
can use the mandatory keys


357
00:20:06,696 --> 00:20:07,586
to narrow that down.


358
00:20:07,806 --> 00:20:09,846
But, as I mentioned,
in most cases,


359
00:20:09,846 --> 00:20:11,346
we'll just be passing
nill to use all.


360
00:20:12,076 --> 00:20:14,386
If I run this on iOS 7,
I'll get back an array


361
00:20:14,826 --> 00:20:19,246
with the number descriptors, 14,
I believe, for various members


362
00:20:19,296 --> 00:20:20,986
of the Helvetica Neue family.


363
00:20:21,906 --> 00:20:24,126
I mentioned also that
we can use descriptors


364
00:20:24,626 --> 00:20:28,836
to modify text styles
and other fonts as well.


365
00:20:29,596 --> 00:20:34,646
So in this case, I'd like to
get at a Bold body text style


366
00:20:35,896 --> 00:20:37,616
and there's no category,


367
00:20:37,736 --> 00:20:41,376
no constant for specifying
a Bold body text style,


368
00:20:42,196 --> 00:20:45,786
but I can apply the
Bold symbolic trait


369
00:20:46,416 --> 00:20:48,756
to the standard body text style


370
00:20:48,756 --> 00:20:51,926
if I need some emphasis
in my body text.


371
00:20:52,716 --> 00:20:55,626
In this particular example,
since I'm not starting


372
00:20:55,626 --> 00:20:59,816
from a UIFont, I don't need to
spend everything up just to get


373
00:20:59,816 --> 00:21:02,706
at a font -- just to get another
font, so I'm going to start


374
00:21:02,706 --> 00:21:05,946
by getting a UIFontDescriptor
using preferredFontDescriptor


375
00:21:05,946 --> 00:21:06,716
WithTextStyle.


376
00:21:07,696 --> 00:21:09,686
I'm passing in the
relevant constant,


377
00:21:09,816 --> 00:21:11,556
in this case, text style body.


378
00:21:12,126 --> 00:21:14,656
And then we're going
to modify it


379
00:21:14,656 --> 00:21:16,296
with the symbolic
trait for Bold.


380
00:21:16,296 --> 00:21:18,436
In this case, I know
that there's going


381
00:21:18,436 --> 00:21:21,226
to be Bold variant available
but, again, if there's --


382
00:21:21,476 --> 00:21:23,816
if I were using a different font


383
00:21:23,816 --> 00:21:26,246
and they weren't a Bold
style available to me,


384
00:21:26,246 --> 00:21:29,976
then I would be left with
the original descriptor,


385
00:21:29,976 --> 00:21:33,076
but that's OK because
then I'll go ahead


386
00:21:33,076 --> 00:21:36,416
and create the relevant font, in
this case, from that descriptor.


387
00:21:37,176 --> 00:21:40,036
You'll note also that
the size parameter


388
00:21:40,546 --> 00:21:42,826
that I'm passing in is zero.


389
00:21:44,086 --> 00:21:47,846
And that indicates that
when using the descriptor,


390
00:21:47,906 --> 00:21:52,166
I'd like to not override the
size that it itself specified.


391
00:21:53,046 --> 00:21:56,126
So, in this case, zero
simply means don't change.


392
00:21:56,426 --> 00:22:01,436
And now I have my Bold text
style for use in bodies.


393
00:22:03,016 --> 00:22:05,436
Descriptors are also
the preferred mechanism


394
00:22:05,536 --> 00:22:07,446
for serializing font data.


395
00:22:08,026 --> 00:22:10,656
So, of course, from a font
descriptor, we can coerce


396
00:22:10,656 --> 00:22:12,856
to a font and for
any given font,


397
00:22:13,036 --> 00:22:15,066
we can get a font
descriptor that describes it.


398
00:22:15,676 --> 00:22:19,346
So this is relevant when
we have a font that we'd


399
00:22:19,346 --> 00:22:21,116
like to serialize, we'll
use this descriptor.


400
00:22:21,626 --> 00:22:25,966
This is very easy since
font descriptors can form


401
00:22:25,966 --> 00:22:28,806
to the UI -- to the
NSCoding protocol,


402
00:22:29,876 --> 00:22:34,736
but you may have a
mechanism for archiving


403
00:22:35,096 --> 00:22:37,636
and unarchiving objects
that doesn't use NSCoding.


404
00:22:38,146 --> 00:22:40,726
In this case, you should
be accessing the dictionary


405
00:22:40,726 --> 00:22:42,616
of font attributes
on a descriptor.


406
00:22:43,376 --> 00:22:47,646
But note that because of all
of the various possibilities


407
00:22:47,646 --> 00:22:48,546
when describing fonts,


408
00:22:48,546 --> 00:22:52,516
you should be using those
attributes as an atomic entity.


409
00:22:52,516 --> 00:22:55,726
You shouldn't be trying to pick
various attributes out of it


410
00:22:55,726 --> 00:23:00,206
and assume that that's going to
be able to reconstitute a font


411
00:23:00,636 --> 00:23:02,916
on the other end, so
just use all of these


412
00:23:02,916 --> 00:23:05,906
and serialize them as necessary.


413
00:23:05,906 --> 00:23:08,456
Descriptors can also be used
to modify font instances.


414
00:23:09,396 --> 00:23:13,076
Now, when I say modify, it don't
mean that you're able to go in


415
00:23:13,076 --> 00:23:14,476
and change the font
data on disk.


416
00:23:15,166 --> 00:23:18,566
But what you can do is
change the behavior of a font


417
00:23:18,566 --> 00:23:22,126
when you make use
of it in your app.


418
00:23:22,126 --> 00:23:25,316
Two examples in particular
that we're going to see are how


419
00:23:25,316 --> 00:23:27,956
to activate typographic
features and how


420
00:23:27,956 --> 00:23:29,976
to remove unwanted characters


421
00:23:30,016 --> 00:23:31,786
to limit the character
coverage of a font.


422
00:23:32,636 --> 00:23:34,436
So, as I mentioned
earlier, of course,


423
00:23:34,616 --> 00:23:37,936
String plus Font equals
Glyphs, Unicode text layout.


424
00:23:39,226 --> 00:23:41,066
Well one of the neat
things about fonts is


425
00:23:41,126 --> 00:23:46,206
that they can often implement
special features that modify


426
00:23:46,206 --> 00:23:47,206
that process in somehow


427
00:23:47,776 --> 00:23:53,576
and these features are
called typographic features,


428
00:23:53,956 --> 00:23:59,516
and in this particular example,
I have a font where normally


429
00:23:59,776 --> 00:24:03,586
when I layout text using this
font, I get one appearance


430
00:24:03,876 --> 00:24:05,206
as you can see on the top here.


431
00:24:06,566 --> 00:24:07,906
It says 11:15.


432
00:24:08,726 --> 00:24:12,416
And you'll note that even
though this particular font, 12,


433
00:24:12,476 --> 00:24:15,066
you can't really see it, but
this font is a proportional font


434
00:24:15,066 --> 00:24:17,186
that is it's not monospaced,


435
00:24:17,386 --> 00:24:19,406
different characters
have different widths.


436
00:24:19,816 --> 00:24:22,236
You'll note that the
digits in this font,


437
00:24:22,336 --> 00:24:25,786
they're all monospaced, the
ones the same width as the five.


438
00:24:25,786 --> 00:24:29,906
And this is a very common design
that you'll see from fonts


439
00:24:30,406 --> 00:24:34,156
because it makes it easy to
line up figures in columns,


440
00:24:34,606 --> 00:24:38,646
but I'm no accountant and
I know that in this case,


441
00:24:38,646 --> 00:24:40,996
this particular string
means that I'm trying


442
00:24:40,996 --> 00:24:43,906
to display a font --
a time to the user,


443
00:24:44,386 --> 00:24:48,896
let's say for time stamp
in a table that I have data


444
00:24:48,896 --> 00:24:51,426
that I'd like to present.


445
00:24:51,426 --> 00:24:53,606
And so I've been
told by my designer


446
00:24:53,606 --> 00:24:58,446
that this particular font
has typographic features


447
00:24:58,556 --> 00:25:02,126
that allow me to apply
a time appearance to it.


448
00:25:02,126 --> 00:25:05,646
And one of those is one that I
can use in other cases as well


449
00:25:06,186 --> 00:25:09,066
and that's to make these
digits proportional.


450
00:25:09,846 --> 00:25:11,126
And so in this particular
example,


451
00:25:11,126 --> 00:25:15,826
you can see very clearly how the
ones now have a narrower width


452
00:25:17,016 --> 00:25:22,426
and since I'm dealing with
time, this font, I've been told,


453
00:25:22,426 --> 00:25:24,356
has another great
feature that I can use


454
00:25:24,356 --> 00:25:27,416
and that's an alternate
set of glyphs.


455
00:25:27,946 --> 00:25:32,156
In this case, the alternate
set includes a different colon


456
00:25:32,686 --> 00:25:35,836
that clearly looks
like a time separator.


457
00:25:35,836 --> 00:25:40,706
Rather than being rectangular,
you can see that it's circular


458
00:25:40,706 --> 00:25:44,096
and it's brought up
off the baseline a bit.


459
00:25:44,316 --> 00:25:46,216
So -- And this is
what I'd like to use,


460
00:25:46,896 --> 00:25:48,406
how can I do this in code?


461
00:25:48,796 --> 00:25:54,436
Well, first I'd like to build
up an array of feature settings.


462
00:25:55,146 --> 00:25:58,606
So feature settings are
these -- are the identifiers,


463
00:25:58,606 --> 00:26:01,836
the handles onto these
typographic features


464
00:26:01,996 --> 00:26:03,476
that can be implemented
by a font


465
00:26:04,096 --> 00:26:06,406
and you can programatically
query the fonts to find


466
00:26:06,406 --> 00:26:09,396
out what's available,
but in this case,


467
00:26:09,396 --> 00:26:12,106
I've been told specifically
which ones I need to use.


468
00:26:13,026 --> 00:26:15,816
I'm using the Objective-C
literal syntax for doing that,


469
00:26:15,896 --> 00:26:20,176
and so if we unpack this,
you can see it's an array


470
00:26:20,176 --> 00:26:23,366
of two dictionaries and each


471
00:26:23,366 --> 00:26:26,616
of those dictionaries is
specifying both the type


472
00:26:26,856 --> 00:26:30,816
and a selector as the key
and the values are relevant


473
00:26:30,816 --> 00:26:33,316
to those particular
features that I'm trying


474
00:26:33,316 --> 00:26:36,086
to enable on this font.


475
00:26:36,276 --> 00:26:37,516
So, the first one you can see,


476
00:26:37,516 --> 00:26:40,596
it's very clearly
described number spacing type


477
00:26:41,096 --> 00:26:43,176
which is kind of a
grouping of features


478
00:26:43,176 --> 00:26:46,236
and then the proportional
numbers is what I'm going


479
00:26:46,236 --> 00:26:46,776
to be enabling.


480
00:26:48,166 --> 00:26:50,266
And this other one, this
character alternatives,


481
00:26:51,066 --> 00:26:54,736
you'll note this pesky little
magic value, magic constant 1.


482
00:26:55,476 --> 00:27:01,366
Well, so there are a number of
predefined typographic features,


483
00:27:01,846 --> 00:27:04,936
names that we've given
because we have seen them


484
00:27:04,936 --> 00:27:06,926
in so many fonts, but remember


485
00:27:06,926 --> 00:27:10,286
that typographic features are
kind of like an API to a font.


486
00:27:10,766 --> 00:27:15,286
And so a font is free to define
its own typographic features


487
00:27:16,056 --> 00:27:17,826
and that's exactly what
this font has done.


488
00:27:19,256 --> 00:27:21,366
It's defined a particular
selector


489
00:27:21,366 --> 00:27:23,916
in that character
alternatives type of 1.


490
00:27:24,606 --> 00:27:27,206
And so if that font came with
a header, somehow we could,


491
00:27:27,206 --> 00:27:28,246
you know, give it
a magic cons --


492
00:27:28,246 --> 00:27:30,466
maybe we'll give it
a name in your code


493
00:27:30,516 --> 00:27:33,206
so we know what's going
on, but in this case,


494
00:27:33,206 --> 00:27:36,526
our designer has told
us this is how to enable


495
00:27:36,526 --> 00:27:39,186
that particular change
that you'd like to make


496
00:27:39,186 --> 00:27:41,076
in the appearance of the glyphs.


497
00:27:41,986 --> 00:27:43,736
So once we have that
array of feature settings,


498
00:27:43,736 --> 00:27:45,836
what we're going to do
is we're going to assume


499
00:27:45,836 --> 00:27:48,706
that we've started with the
font already, that original font


500
00:27:48,986 --> 00:27:51,226
in the original appearance
that you saw in the example.


501
00:27:52,606 --> 00:27:53,906
We're going to get
its descriptor.


502
00:27:54,916 --> 00:27:56,636
Now, we're going to
create a new descriptor


503
00:27:57,236 --> 00:27:59,026
by modifying the
original descriptor


504
00:27:59,596 --> 00:28:02,166
by adding attributes to it.


505
00:28:02,596 --> 00:28:04,366
In this case, there's
just one attribute,


506
00:28:04,366 --> 00:28:07,296
it's the feature settings
attribute and the value


507
00:28:07,296 --> 00:28:10,276
for that is going to be the
array of feature settings


508
00:28:10,386 --> 00:28:11,216
that we defined above.


509
00:28:12,296 --> 00:28:16,066
And then finally, we're going to
say, UIFont, fontWithDescriptor.


510
00:28:16,446 --> 00:28:19,076
We're going to pass that
descriptor that we just created


511
00:28:19,076 --> 00:28:20,056
with those feature settings.


512
00:28:20,746 --> 00:28:22,566
Again, we're going to
pass zero for the size,


513
00:28:22,566 --> 00:28:23,506
meaning don't change it.


514
00:28:24,266 --> 00:28:27,086
And so now, the only difference
between the original font


515
00:28:27,166 --> 00:28:30,446
and time font that we've
made here is it's going


516
00:28:30,446 --> 00:28:33,836
to be the same font but it has
these new features enabled.


517
00:28:34,046 --> 00:28:35,756
And so the font gets
to participate


518
00:28:35,756 --> 00:28:40,706
in that glyph selection process
and during layout it will say,


519
00:28:40,706 --> 00:28:42,546
"oh, I know exactly
what you want


520
00:28:42,546 --> 00:28:44,206
for those ones and that colon.


521
00:28:44,206 --> 00:28:46,306
I know you want this
other glyphs instead."


522
00:28:46,426 --> 00:28:50,436
And these feature settings can
be quite amazingly powerful.


523
00:28:50,836 --> 00:28:53,646
Not only can they change
which glyphs are selected


524
00:28:53,646 --> 00:28:56,476
for certain characters, but they
can also change the interaction


525
00:28:56,816 --> 00:28:58,046
between various glyphs,


526
00:28:58,166 --> 00:29:00,306
ligatures are a great
example of this.


527
00:29:01,756 --> 00:29:04,136
So another example,
as I mentioned,


528
00:29:04,136 --> 00:29:05,996
is limiting the character
coverage of the font.


529
00:29:07,316 --> 00:29:08,846
So, I've got this
really great app.


530
00:29:09,526 --> 00:29:12,536
It's kind of technical and so
I think Menlo is a great choice


531
00:29:12,536 --> 00:29:16,566
of a font for my --
presenting my user's content.


532
00:29:16,566 --> 00:29:19,986
And as I'm sure it happens
to you a lot -- I --


533
00:29:20,726 --> 00:29:23,816
so many at my documents include
the Unicode snowman character,


534
00:29:23,996 --> 00:29:24,396
of course.


535
00:29:24,996 --> 00:29:27,676
You know, again, I think
I've picked the right font


536
00:29:28,276 --> 00:29:30,576
for this particular
very specialized app,


537
00:29:30,706 --> 00:29:33,526
but I don't know about you, but
I think it's kind of a bit early


538
00:29:33,526 --> 00:29:39,256
in the morning for Menlo
snowman, he's just too happy.


539
00:29:40,636 --> 00:29:43,186
So really what I'd like to
do is I want to use Menlo,


540
00:29:43,186 --> 00:29:45,966
but I don't want to
ever see Menlo snowman.


541
00:29:46,116 --> 00:29:49,286
And so I want to create
a font instance that acts


542
00:29:49,476 --> 00:29:52,006
as if it doesn't
even exist and I'd


543
00:29:52,006 --> 00:29:55,476
like to just let the system
pick a different font,


544
00:29:55,686 --> 00:29:57,736
follow back to different font
whenever it sees a snowman.


545
00:29:58,406 --> 00:30:01,966
Anything will be
better right now.


546
00:30:02,456 --> 00:30:04,706
So I mentioned earlier
in passing


547
00:30:04,706 --> 00:30:07,276
that UIFontDescriptor can be
used to access font properties.


548
00:30:08,596 --> 00:30:09,846
And so in this example,


549
00:30:09,846 --> 00:30:13,476
I am going to be ultimately
creating a new descriptor


550
00:30:13,476 --> 00:30:17,086
by modifying an existing one,
but the value of the attribute


551
00:30:17,086 --> 00:30:18,226
that I'm going to be modifying.


552
00:30:18,306 --> 00:30:21,006
First, I want to get from
my original descriptor.


553
00:30:21,006 --> 00:30:22,366
Let me show you how that works.


554
00:30:23,396 --> 00:30:25,166
So, again, we're going to
assume that we have our font,


555
00:30:25,166 --> 00:30:27,596
in this case, in
the example I gave,


556
00:30:27,596 --> 00:30:31,126
it's going to be
a font for Menlo.


557
00:30:31,716 --> 00:30:34,546
We're going to get
this descriptor again,


558
00:30:34,856 --> 00:30:37,586
the original descriptor.


559
00:30:37,636 --> 00:30:41,906
Now, in order to compute what
its character set is going


560
00:30:41,906 --> 00:30:44,516
to be, first we're going to
get its original character set


561
00:30:44,926 --> 00:30:47,266
by invoking object for key


562
00:30:47,266 --> 00:30:50,806
on the original descriptor
getting the character set.


563
00:30:51,916 --> 00:30:56,666
We're going to mutate that by
removing that one character,


564
00:30:56,666 --> 00:30:57,836
just that one snowman character.


565
00:30:58,376 --> 00:31:01,246
And so now we have a character
set which is exactly identical


566
00:31:01,246 --> 00:31:07,146
to the original font's character
set minus that one character.


567
00:31:07,696 --> 00:31:11,636
And then just as before, we're
going to make a new descriptor


568
00:31:12,966 --> 00:31:17,026
by adding an attribute and the
nice thing about this method is


569
00:31:17,026 --> 00:31:23,856
that it's defined as using the
new values to override anything


570
00:31:23,856 --> 00:31:26,516
that is already in the font.


571
00:31:26,566 --> 00:31:28,046
So there is no conflict here.


572
00:31:28,366 --> 00:31:31,386
It's going to know that this new
character set attribute is going


573
00:31:31,386 --> 00:31:34,326
to be the one that I want
and when I create a font


574
00:31:34,326 --> 00:31:37,286
with that descriptor -- now
whenever I use that font


575
00:31:37,286 --> 00:31:41,526
in my app, it will use Menlo
for all the text except


576
00:31:41,526 --> 00:31:43,216
that snowman character and in


577
00:31:43,316 --> 00:31:48,966
that case the font subsystem is
going to pick up fallback fonts


578
00:31:49,056 --> 00:31:51,366
to use that to run to
that character instead.


579
00:31:52,496 --> 00:31:56,096
So there're also some
great opportunities for you


580
00:31:56,096 --> 00:31:59,926
to bring your own fonts to
your designs, your app design,


581
00:31:59,926 --> 00:32:02,886
and this goes not
only for iOS but also


582
00:32:03,096 --> 00:32:04,526
for OS X Mavericks as well.


583
00:32:05,176 --> 00:32:09,006
So, if you're design
includes something custom,


584
00:32:09,476 --> 00:32:10,736
this is how we'll make it work.


585
00:32:11,136 --> 00:32:14,166
So bringing your own font
to the table is pretty easy.


586
00:32:14,166 --> 00:32:15,386
We've got lots of options.


587
00:32:15,636 --> 00:32:18,806
So when you're talking to
your designers or the foundry


588
00:32:18,806 --> 00:32:20,266
from what you're going
to license your font,


589
00:32:20,746 --> 00:32:22,306
they may ask you some
of these questions.


590
00:32:22,306 --> 00:32:24,356
And so, these are the answers
you're going to need to know.


591
00:32:25,796 --> 00:32:29,026
We support both -- two type,
an OpenType font containers,


592
00:32:29,366 --> 00:32:34,126
both individual fonts and
as collections and in terms


593
00:32:34,126 --> 00:32:40,356
of the layout information in
those fonts, we support both AAT


594
00:32:40,756 --> 00:32:43,216
and OpenType layout information.


595
00:32:44,436 --> 00:32:48,496
So, really, you shouldn't
have any problem being able


596
00:32:48,526 --> 00:32:51,766
to get the font in a
format that we can support.


597
00:32:52,736 --> 00:32:57,556
And then in order to make use
of that, it's very simple,


598
00:32:57,556 --> 00:32:58,996
you simply place
in your app bundle


599
00:32:58,996 --> 00:33:03,216
because that's how your
resources are bundled.


600
00:33:04,856 --> 00:33:07,326
And then the system can
automatically make those


601
00:33:07,326 --> 00:33:09,736
available to your app on iOS


602
00:33:09,926 --> 00:33:13,546
by using the UIAppFonts
Info.plist key


603
00:33:13,546 --> 00:33:15,866
to specify the location on
those fonts and your bundle.


604
00:33:16,496 --> 00:33:20,006
There's also a corresponding
Info.plist key with us,


605
00:33:20,226 --> 00:33:25,446
different name on OS X, but
you may find, and I should say


606
00:33:25,446 --> 00:33:28,066
that once you've
done this, it's --


607
00:33:28,206 --> 00:33:29,716
it acts like any other font


608
00:33:29,796 --> 00:33:31,046
that was previously
installed in the system.


609
00:33:31,076 --> 00:33:34,456
So you can say, "UIFont
fontWithName and the name


610
00:33:34,546 --> 00:33:40,146
of that font that you've
added and there will be.


611
00:33:40,426 --> 00:33:43,796
But we found in some cases
that for various reasons,


612
00:33:44,006 --> 00:33:47,366
this isn't what you want to use.


613
00:33:47,696 --> 00:33:51,016
And some cases, we found that
foundries asked the developers


614
00:33:51,016 --> 00:33:54,676
like you, you know, not have
their fonts just sitting


615
00:33:54,676 --> 00:33:56,696
on unencumbered in
the app bundle


616
00:33:57,306 --> 00:33:58,476
to prevent casual snooping.


617
00:33:59,796 --> 00:34:02,236
And so in these cases,
you might want


618
00:34:02,236 --> 00:34:05,736
to have [inaudible] the font
data in some way and in fact,


619
00:34:05,736 --> 00:34:08,346
we have code example
available online


620
00:34:08,436 --> 00:34:10,116
for how you might
accomplish this on your app.


621
00:34:11,485 --> 00:34:13,476
But once you've done
that, of course,


622
00:34:13,616 --> 00:34:16,366
the system can no
longer automatically make


623
00:34:16,366 --> 00:34:18,755
that font available to
you, and so you may need


624
00:34:18,755 --> 00:34:19,946
to add that font manually.


625
00:34:20,386 --> 00:34:22,335
There're two different types --


626
00:34:22,485 --> 00:34:26,116
there're two different ways
in which you can do that.


627
00:34:26,315 --> 00:34:29,216
The first is by adding the font


628
00:34:29,286 --> 00:34:32,116
as what we call a
registered font.


629
00:34:32,116 --> 00:34:35,485
Using one of these
CT font manager APIs,


630
00:34:35,485 --> 00:34:40,525
you can specify the location
of font data to be referenced


631
00:34:40,576 --> 00:34:42,696
by name after it's been added.


632
00:34:43,696 --> 00:34:47,166
These registered fonts, again,
behave just as if they had been


633
00:34:47,166 --> 00:34:49,496
in your app bundle and
activated automatically,


634
00:34:50,116 --> 00:34:51,826
so you just referenced
them by name.


635
00:34:52,226 --> 00:34:54,366
There's another way in which
you can add fonts however


636
00:34:54,826 --> 00:34:56,146
in which they're unregistered.


637
00:34:56,866 --> 00:35:00,416
In this case, the font's
names can never be matched.


638
00:35:01,646 --> 00:35:04,756
And you might say, "well,
how was that even useful?"


639
00:35:05,096 --> 00:35:09,336
Well, it's really great actually
because what you get back


640
00:35:09,926 --> 00:35:14,486
from these CT font manager
APIs are new font descriptors.


641
00:35:15,266 --> 00:35:17,836
Now, of course, these
are CT font descriptors,


642
00:35:17,836 --> 00:35:20,186
cortex font descriptors, but
they are toll-free bridged


643
00:35:20,186 --> 00:35:22,826
with UIFontDescriptor on iOS.


644
00:35:23,506 --> 00:35:25,396
So, just a little bit of
casting is all you're going


645
00:35:25,396 --> 00:35:26,186
to need to make this work.


646
00:35:26,736 --> 00:35:28,646
Once you have one of these
descriptors, of course,


647
00:35:28,646 --> 00:35:31,666
we've seen several times now
how you can create a font


648
00:35:31,666 --> 00:35:34,106
from a descriptor, and that's
exactly what you can do


649
00:35:34,106 --> 00:35:34,476
with these.


650
00:35:35,436 --> 00:35:39,626
So even though you can't say
font with name, your fonts name


651
00:35:39,746 --> 00:35:41,046
and get back the fonts.


652
00:35:41,276 --> 00:35:43,046
In this case, you can
create a font directly


653
00:35:43,046 --> 00:35:43,876
from a font descriptor.


654
00:35:45,206 --> 00:35:46,826
This could also be
helpful for instance


655
00:35:47,276 --> 00:35:51,846
if you license a
particular version of a font


656
00:35:51,846 --> 00:35:54,026
that already exists
on the system.


657
00:35:54,086 --> 00:35:57,016
And so, if you for some
reason has special layout


658
00:35:57,016 --> 00:36:01,406
considerations and need to
use your own copy of one


659
00:36:01,406 --> 00:36:03,756
of our fonts, this is a great
way to make that happen.


660
00:36:04,586 --> 00:36:07,446
Now, for making it this far in
the conference, in the session,


661
00:36:07,766 --> 00:36:12,426
we'd like to show you
another little surprise here.


662
00:36:12,616 --> 00:36:15,336
So in iOS 7 -- well,
iOS in general,


663
00:36:15,336 --> 00:36:18,716
we've long had the problem
where on OS X, we have a bunch


664
00:36:18,716 --> 00:36:22,496
of really amazing
beautiful fonts.


665
00:36:22,576 --> 00:36:26,466
But until we can get that shrink
ray working, it's really hard


666
00:36:26,466 --> 00:36:30,356
to squeeze a terabyte of storage
into a little phone that goes


667
00:36:30,356 --> 00:36:34,226
in your pocket and so many of
these fonts we've had to leave


668
00:36:34,226 --> 00:36:37,986
out of iOS because there's
just not enough room.


669
00:36:38,526 --> 00:36:42,256
But there are cases when you
might know that you just need


670
00:36:42,256 --> 00:36:43,586
to use a particular font.


671
00:36:44,406 --> 00:36:49,546
And so, what we've done for iOS
7 is we've made a huge number


672
00:36:49,626 --> 00:36:51,426
of fonts available to you.


673
00:36:52,126 --> 00:36:53,896
We've licensed and hosted these


674
00:36:54,016 --> 00:36:55,556
so that you can make
use of them.


675
00:36:55,556 --> 00:36:57,506
These include literally
hundreds of fonts,


676
00:36:57,956 --> 00:37:01,466
all of the fonts installed in
OS X as well as additional fonts


677
00:37:01,666 --> 00:37:04,886
for particular support
of international scripts.


678
00:37:05,736 --> 00:37:07,426
And the way -- thank
you [applause].


679
00:37:10,866 --> 00:37:12,606
So the way you take
advantage of this is


680
00:37:12,606 --> 00:37:17,546
by using a very long
API CTFontDescriptor


681
00:37:17,546 --> 00:37:19,696
CreateMatchingFont
DescriptorsWithProgressHandler.


682
00:37:20,866 --> 00:37:25,306
And really, what this is,
is it's a very special type


683
00:37:25,346 --> 00:37:26,576
of descriptor matching.


684
00:37:26,866 --> 00:37:28,066
So we've talked about
this already


685
00:37:28,626 --> 00:37:31,856
and before we saw how
simple it was to match


686
00:37:31,856 --> 00:37:33,046
on a descriptor and
get the results.


687
00:37:33,946 --> 00:37:35,636
Well, with downloadable
fonts of course,


688
00:37:36,916 --> 00:37:39,636
were at the mercy
of the network.


689
00:37:40,746 --> 00:37:45,226
And so essentially what this is
API let's you do is it lets you


690
00:37:45,266 --> 00:37:48,396
perform that descriptor
matching asynchronously.


691
00:37:49,116 --> 00:37:51,436
And so the progress handler
is a block that you pass


692
00:37:51,436 --> 00:37:54,716
in that gets called to handle
the various states during


693
00:37:54,716 --> 00:37:55,246
the download.


694
00:37:55,926 --> 00:37:59,106
And so what this means is that
in order to make effective use


695
00:37:59,106 --> 00:38:00,226
of these downloadable fonts,


696
00:38:00,676 --> 00:38:04,316
your app will probably have the
design some UI to allow the user


697
00:38:04,316 --> 00:38:06,306
to recover from various
failure states.


698
00:38:07,076 --> 00:38:10,396
But with that in
mind, it's very simple


699
00:38:10,396 --> 00:38:14,166
to query fonts are available
via this download mechanism


700
00:38:14,536 --> 00:38:17,676
by matching on the
downloadable attribute.


701
00:38:18,936 --> 00:38:20,436
And we'll also be
publishing a list


702
00:38:20,436 --> 00:38:22,556
of those fonts online as well.


703
00:38:23,326 --> 00:38:26,526
So, to make use of
one these fonts, I --


704
00:38:26,686 --> 00:38:27,976
your app can simply download it


705
00:38:27,976 --> 00:38:30,176
and then the user's
content is available


706
00:38:30,336 --> 00:38:31,296
in that particular app.


707
00:38:32,666 --> 00:38:34,506
Note also that with iOS 7,


708
00:38:34,606 --> 00:38:38,196
fonts can be installed
by managed profiles.


709
00:38:38,506 --> 00:38:40,016
This could be great if you're


710
00:38:40,016 --> 00:38:42,546
in an enterprise
distribution scenario


711
00:38:42,546 --> 00:38:45,176
and you have multiple
apps that you want


712
00:38:45,176 --> 00:38:46,646
to conform to a house style.


713
00:38:48,096 --> 00:38:51,046
And so, those fonts can be
included in the profiles


714
00:38:51,166 --> 00:38:53,056
and activated in that way.


715
00:38:54,196 --> 00:38:57,626
Note however that this is
the first time in which fonts


716
00:38:57,626 --> 00:39:00,976
on iOS can change while
your app is running.


717
00:39:01,436 --> 00:39:03,556
And so, if you'd like to react


718
00:39:03,556 --> 00:39:05,666
to fonts becoming
available via a profile,


719
00:39:06,316 --> 00:39:07,356
you'll want to subscribe


720
00:39:07,386 --> 00:39:10,136
to the registered fonts
changed notification


721
00:39:10,696 --> 00:39:12,786
so that you can react
when that happens.


722
00:39:13,746 --> 00:39:16,866
So, as I've been talking,
we've been focusing


723
00:39:16,866 --> 00:39:17,816
on Unicode text layout.


724
00:39:18,226 --> 00:39:20,836
And Unicode is really
an amazing specification


725
00:39:20,836 --> 00:39:24,136
because it allows us to
communicate using nearly any


726
00:39:24,136 --> 00:39:27,596
of the world's languages on a
computer which is no small task.


727
00:39:28,106 --> 00:39:33,456
But one of the sort of
problems with Unicode is for --


728
00:39:33,596 --> 00:39:36,796
in certain situations, the
characters themselves --


729
00:39:37,306 --> 00:39:38,756
we know that they can take


730
00:39:38,756 --> 00:39:40,686
on different appearances
via the font


731
00:39:41,136 --> 00:39:45,546
but there're also situations in
which the appropriate appearance


732
00:39:45,546 --> 00:39:47,906
of that character is
dictated by the language.


733
00:39:48,306 --> 00:39:52,366
That is its information that the
user has that isn't reflected


734
00:39:52,366 --> 00:39:54,866
in the text, can't be.


735
00:39:54,866 --> 00:40:00,066
And so, the system by default
does the very best job it can


736
00:40:00,066 --> 00:40:01,976
in resolving these scenarios.


737
00:40:02,596 --> 00:40:04,186
Typically, it does
solve by looking


738
00:40:04,186 --> 00:40:06,346
at the user's preferred
language.


739
00:40:06,806 --> 00:40:10,716
So, if the user is using
her phone in Japanese,


740
00:40:10,976 --> 00:40:12,346
in the text appearing
in Japanese,


741
00:40:12,826 --> 00:40:16,166
the system will select
appropriate Japanese behaviors


742
00:40:16,166 --> 00:40:16,456
for text.


743
00:40:17,236 --> 00:40:21,246
But there are cases in which you
or your content may know more


744
00:40:21,246 --> 00:40:25,296
about what the appropriate
language is and the mechanism


745
00:40:25,296 --> 00:40:27,886
for doing that is
by language tagging.


746
00:40:28,286 --> 00:40:31,086
So, there's -- on
Mavericks and iOS 7,


747
00:40:31,086 --> 00:40:33,586
there's a new string
attribute that allows you


748
00:40:33,586 --> 00:40:37,156
to specify the language
as an ISO language tag.


749
00:40:37,156 --> 00:40:40,386
And the presence of this
attribute indicates that,


750
00:40:40,666 --> 00:40:43,916
that particular language
should be used


751
00:40:43,916 --> 00:40:48,646
to override the default system
behavior in various ways.


752
00:40:49,306 --> 00:40:51,376
You're going to be looking
at glyph substitution,


753
00:40:51,376 --> 00:40:52,816
line breaking, and
font fallbacks.


754
00:40:54,156 --> 00:40:58,186
So the first example is
one that's kind of --


755
00:40:58,186 --> 00:41:00,036
may not be a particularly useful


756
00:41:00,036 --> 00:41:01,886
because this relies
on a particular font.


757
00:41:02,586 --> 00:41:05,136
But this is another example
of how fonts can participate


758
00:41:05,136 --> 00:41:06,906
in the layout process.


759
00:41:07,156 --> 00:41:11,816
In this case, I'm going to be
displaying a particular string


760
00:41:11,816 --> 00:41:15,566
with two very specific Unicode
characters and I'm going


761
00:41:15,566 --> 00:41:17,986
to be showing you the appearance
of that string when laid


762
00:41:17,986 --> 00:41:21,086
out using one of two
different languages


763
00:41:21,196 --> 00:41:22,376
that I've tagged
the string with.


764
00:41:23,296 --> 00:41:25,616
In the case where I specified
English as the language,


765
00:41:25,746 --> 00:41:28,886
we'll get, for these characters,
their default appearance


766
00:41:28,886 --> 00:41:32,676
which you can see kind of looks
like a little hook or tail


767
00:41:32,676 --> 00:41:36,426
on the bottom of each of
these, the S and the T.


768
00:41:36,676 --> 00:41:38,686
But what's interesting
about these characters is


769
00:41:38,686 --> 00:41:44,146
that when use for Romanian
text, they actually take


770
00:41:44,146 --> 00:41:45,036
on a different appearance.


771
00:41:45,586 --> 00:41:48,656
In this font, Verdana, actually
implements that appearance.


772
00:41:49,286 --> 00:41:52,006
And so if I specified that
language as being Romanian,


773
00:41:52,486 --> 00:41:55,346
you'll see that rather than
having a little hook or tail


774
00:41:55,346 --> 00:41:58,266
on each of those glyphs,
we have what looks more


775
00:41:58,266 --> 00:41:59,556
like a comma or a stroke.


776
00:41:59,556 --> 00:42:06,036
And this is great as a
feature because it allows fonts


777
00:42:06,446 --> 00:42:10,876
to be more responsive
to the user's languages.


778
00:42:11,746 --> 00:42:15,766
Another way in which language
tagging can affect the behavior


779
00:42:15,866 --> 00:42:18,076
of text is in line breaking.


780
00:42:18,536 --> 00:42:21,616
So here we have an example
where I have a Japanese string.


781
00:42:22,256 --> 00:42:27,596
You'll note that I've asked to
lay this out in the space up to


782
00:42:27,596 --> 00:42:30,136
that dotted red line
on the right there.


783
00:42:30,136 --> 00:42:34,276
And you'll note that when
I'm doing so in the context


784
00:42:34,276 --> 00:42:37,766
of an English user, the line
break position is actually


785
00:42:37,766 --> 00:42:39,156
different than for Japanese.


786
00:42:39,886 --> 00:42:42,346
That's because in the
absence of any information


787
00:42:42,346 --> 00:42:45,556
about Japanese --
the Japanese text,


788
00:42:45,766 --> 00:42:49,546
the system uses the default
Unicode character properties


789
00:42:49,606 --> 00:42:52,336
which isn't really
appropriate for Japanese text.


790
00:42:52,876 --> 00:42:56,136
Now, again, as I mentioned
earlier, if the user is running


791
00:42:56,516 --> 00:42:58,106
with Japanese as their
primary language,


792
00:42:58,106 --> 00:43:00,526
they'll get the correct
behavior by defaults


793
00:43:00,996 --> 00:43:03,726
but you may be writing
an app in which you know


794
00:43:03,726 --> 00:43:06,676
that text should always have --


795
00:43:06,676 --> 00:43:08,586
should always be
treated as Japanese text.


796
00:43:08,886 --> 00:43:10,866
Maybe you're writing
a dictionary app


797
00:43:11,276 --> 00:43:15,436
or maybe the content is
being specified using HTML


798
00:43:15,436 --> 00:43:16,976
and tagged as Japanese.


799
00:43:17,436 --> 00:43:20,276
And so in these cases, the
system can adapt accordingly.


800
00:43:20,276 --> 00:43:25,626
And one of the most common
examples when dealing


801
00:43:25,686 --> 00:43:30,306
with this quirk of Unicode
is for languages like Chinese


802
00:43:30,306 --> 00:43:31,926
and Japanese where many


803
00:43:31,926 --> 00:43:34,826
of the characters actually
overlap in Unicode.


804
00:43:34,976 --> 00:43:38,566
They can have the same character
but different appearances.


805
00:43:39,416 --> 00:43:43,006
In this particular example, we
have a very obvious difference


806
00:43:43,146 --> 00:43:48,906
of appearance when we're dealing
with either Japanese or Chinese


807
00:43:49,126 --> 00:43:50,826
as the language for this
particular character.


808
00:43:51,456 --> 00:43:55,076
So in this case, what the
system actually does is --


809
00:43:55,076 --> 00:43:58,386
note that I haven't specified
a font on my attributed string


810
00:43:58,386 --> 00:44:01,796
and so this is going to
immediately trigger fallback


811
00:44:01,796 --> 00:44:03,336
which is the process
of finding a font


812
00:44:03,826 --> 00:44:06,066
that can actually
render that character.


813
00:44:06,616 --> 00:44:09,356
And by specifying the
language attribute,


814
00:44:09,596 --> 00:44:11,646
I've told the system
exactly what it needs to know


815
00:44:11,676 --> 00:44:12,826
to make the right choice,


816
00:44:12,826 --> 00:44:15,996
not just a good choice
but the right choice.


817
00:44:16,636 --> 00:44:20,166
And in this case, it's going
to select one font for Japanese


818
00:44:21,206 --> 00:44:23,586
and a different font
completely for Chinese.


819
00:44:24,366 --> 00:44:27,146
So beside the appearance
of just this one character


820
00:44:27,146 --> 00:44:30,926
in a real world situation,
the user would notice


821
00:44:31,226 --> 00:44:34,126
that there're other
stylistic differences


822
00:44:34,126 --> 00:44:37,486
or even other glyph differences
between those two fonts


823
00:44:37,486 --> 00:44:38,836
and so this can be
done automatically.


824
00:44:39,296 --> 00:44:42,786
So on that note, I'd like to
talk about one other technique


825
00:44:42,856 --> 00:44:46,576
for changing the behavior
of fallbacks and that's


826
00:44:46,626 --> 00:44:48,766
by making use of a
custom cascade list.


827
00:44:49,386 --> 00:44:52,386
We've seen how an
app can tag a string


828
00:44:52,456 --> 00:44:55,666
with the appropriate language to
get language specific behavior


829
00:44:56,236 --> 00:45:00,516
but there are other cases beyond
just that when we might want


830
00:45:00,516 --> 00:45:02,546
to make a change to
the fallback behavior.


831
00:45:03,076 --> 00:45:07,316
The cascade list attribute is
a font descriptor attribute


832
00:45:07,356 --> 00:45:11,036
that you can add that allows
you to specify an array


833
00:45:11,036 --> 00:45:16,006
of font descriptors that will
be used before the default list


834
00:45:17,426 --> 00:45:18,326
when performing fallbacks.


835
00:45:18,676 --> 00:45:19,466
So, what does that mean?


836
00:45:19,906 --> 00:45:21,266
Well -- so remember, I mentioned


837
00:45:21,266 --> 00:45:24,116
that the system has
a default behavior


838
00:45:24,116 --> 00:45:26,916
that works as best it can.


839
00:45:27,676 --> 00:45:30,836
But in this case, you have
the flexibility and the power


840
00:45:30,866 --> 00:45:34,246
to insert something that's going
to be checked before that list.


841
00:45:34,376 --> 00:45:37,306
So let's take a look an
example to try to clarify this.


842
00:45:38,026 --> 00:45:40,846
So let's say I'm marking
on an Arabic dictionary app


843
00:45:41,686 --> 00:45:46,816
and I have a -- I've specified
a really great font in my design


844
00:45:46,946 --> 00:45:52,176
for the English headwords but
the behavior I'm seeing is


845
00:45:52,236 --> 00:45:56,666
that when the text system
encounters the Arabic characters


846
00:45:57,206 --> 00:46:00,786
in that string, they're
falling back --


847
00:46:00,786 --> 00:46:02,066
the fallback font
that's selected


848
00:46:02,066 --> 00:46:04,366
to render those characters
is Geeza Pro.


849
00:46:05,606 --> 00:46:07,606
Now, some people will call
Geeza Pro time tested.


850
00:46:08,216 --> 00:46:09,606
Others would call it
long in the tooth.


851
00:46:10,346 --> 00:46:14,706
But more importantly, I think
what's important to note here is


852
00:46:14,746 --> 00:46:17,736
that Arabic is a writing system


853
00:46:17,736 --> 00:46:20,626
with a very rich
calligraphic history


854
00:46:20,966 --> 00:46:23,626
and so there are a
number of different styles


855
00:46:23,626 --> 00:46:26,466
in which I could expect
this text to appear


856
00:46:26,966 --> 00:46:29,576
and Geeza Pro is just
obviously one style.


857
00:46:31,076 --> 00:46:33,166
So what I've done is I've
licensed a really beautiful


858
00:46:33,336 --> 00:46:35,516
Arabic font for use in
my dictionary and I'd


859
00:46:35,516 --> 00:46:38,576
like the system to
manage the transition


860
00:46:38,576 --> 00:46:39,906
between those fonts
automatically.


861
00:46:40,816 --> 00:46:42,526
And so what I'd like instead is


862
00:46:42,526 --> 00:46:45,496
when I specified my original
font from my headwords,


863
00:46:46,066 --> 00:46:48,626
I'd like to let the system
take care of the fallback


864
00:46:49,026 --> 00:46:53,206
by overriding the default
behavior, not going to Geeza Pro


865
00:46:53,476 --> 00:46:54,846
and selecting my font instead.


866
00:46:55,696 --> 00:46:58,146
So in order to do
that, I'm going to want


867
00:46:58,146 --> 00:46:59,646
to specify my own cascade list.


868
00:47:00,616 --> 00:47:01,626
So I've got a font descriptor.


869
00:47:01,626 --> 00:47:03,776
We'll, assuming that I've
constructed font descriptor


870
00:47:04,016 --> 00:47:08,366
for my licensed Arabic
font and then I'm going


871
00:47:08,366 --> 00:47:12,276
to build a cascade list which is
pretty simple using Objective-C


872
00:47:12,276 --> 00:47:14,126
literal syntax, I'm just
going to have an array


873
00:47:14,126 --> 00:47:16,196
with this single
object and that's going


874
00:47:16,196 --> 00:47:17,136
to be that descriptor.


875
00:47:18,136 --> 00:47:21,366
I'll assume that I have my
font for my English text.


876
00:47:22,566 --> 00:47:23,846
Again, like we've seen before,


877
00:47:23,846 --> 00:47:26,766
I'm going to get the original
descriptor and I'm going


878
00:47:26,766 --> 00:47:27,726
to create a new descriptor


879
00:47:27,726 --> 00:47:31,566
by adding my cascade list
attribute to that descriptor.


880
00:47:32,186 --> 00:47:35,026
Now, whenever I make use
of the font that I can make


881
00:47:35,256 --> 00:47:37,406
from that descriptor,
what will happen is --


882
00:47:37,676 --> 00:47:42,076
I know that this font doesn't
support Arabic characters.


883
00:47:42,116 --> 00:47:44,466
And so whenever the string
contains those characters,


884
00:47:44,466 --> 00:47:46,336
the system is going to need
to consult the fallback


885
00:47:46,566 --> 00:47:48,546
to find an appropriate
font to render that.


886
00:47:49,256 --> 00:47:50,686
And so, this cascade list --


887
00:47:51,316 --> 00:47:55,436
since I know this covers Arabic
characters, it'll be used rather


888
00:47:55,436 --> 00:47:57,566
than the default fallback
which is Geeza Pro.


889
00:47:58,796 --> 00:48:04,166
So, you may note also that this
particular example could be


890
00:48:04,166 --> 00:48:07,396
quite powerful when combined
with a previous example


891
00:48:07,396 --> 00:48:08,636
of modifying the character set.


892
00:48:09,236 --> 00:48:12,756
And so they're depending
on the needs of your app.


893
00:48:12,756 --> 00:48:16,236
You may even be able to
combine the various techniques


894
00:48:16,266 --> 00:48:18,616
that I've shown you for
a very precise control


895
00:48:18,696 --> 00:48:19,756
of the fallback behavior.


896
00:48:21,016 --> 00:48:25,036
For more information, there
are various resources available


897
00:48:25,036 --> 00:48:25,356
to you.


898
00:48:25,356 --> 00:48:28,606
There are a couple of
sessions that are available


899
00:48:28,606 --> 00:48:32,156
on instant replay to you and I
encourage you to review those


900
00:48:32,186 --> 00:48:36,216
because there're some really
fascinating concepts in there


901
00:48:36,626 --> 00:48:39,916
as well as several of
the design sessions


902
00:48:39,956 --> 00:48:43,286
on designing your user
interface for iOS 7


903
00:48:43,726 --> 00:48:46,016
because that will give you I
think some really great ideas


904
00:48:46,076 --> 00:48:47,526
for adapting text
style in your apps.


905
00:48:47,986 --> 00:48:49,656
And I, as a user,
I'm really excited


906
00:48:49,656 --> 00:48:52,336
to see what you guys
can come up with.


907
00:48:52,526 --> 00:48:55,176
In summary, I just like
to drive home a couple


908
00:48:55,176 --> 00:48:56,166
of points one more time.


909
00:48:56,456 --> 00:49:00,756
The first is to -- in
order to adapt dynamic type


910
00:49:01,006 --> 00:49:04,676
in your iOS 7 app, you'll
do so using text styles.


911
00:49:04,676 --> 00:49:08,456
Remember that this is -- this
requires a bit of flexibility


912
00:49:08,456 --> 00:49:11,446
on your part in order
to adapt appropriately


913
00:49:11,446 --> 00:49:14,286
to the user's desired
content size.


914
00:49:14,786 --> 00:49:18,836
So please investigate using
auto layout but keep in mind


915
00:49:18,836 --> 00:49:20,596
that those font metrics
are going


916
00:49:20,596 --> 00:49:22,146
to change based on
user preference.


917
00:49:22,656 --> 00:49:25,906
For developers in
multilingual situations,


918
00:49:26,406 --> 00:49:30,616
language tagging is a great
feature that allows you


919
00:49:30,616 --> 00:49:33,746
to specify language
sensitive behavior.


920
00:49:34,506 --> 00:49:37,336
And what's really great
about it is that --


921
00:49:37,886 --> 00:49:41,466
in those examples I showed you,
that attribute will flow right


922
00:49:41,466 --> 00:49:43,726
up to your Text Kit and
you'll get perfect behavior.


923
00:49:43,986 --> 00:49:46,556
For various specific
needs involving fallbacks,


924
00:49:46,556 --> 00:49:49,646
you can influence the
systems fallback behavior


925
00:49:49,646 --> 00:49:51,246
by adding a cascade descriptor.


926
00:49:51,646 --> 00:49:54,976
Remember also that
profiles can install fonts


927
00:49:55,026 --> 00:49:57,666
and so this is a new tool
available to you as well


928
00:49:58,056 --> 00:50:00,136
and those fonts are
available systemwide.


929
00:50:01,496 --> 00:50:05,006
So with that, I'd like to say
thank you very much for coming


930
00:50:05,006 --> 00:50:08,036
to hear about fonts and Text
Kit and a little bit of OS X.


931
00:50:08,036 --> 00:50:09,286
Thank you very much.


932
00:50:09,286 --> 00:50:09,976
Enjoy the rest of
the conference.


933
00:50:10,516 --> 00:50:12,780
[ Applause ]

