1
00:00:29,206 --> 00:00:31,206
[Applause]


2
00:00:31,396 --> 00:00:33,876
>> MICHAEL TURNER: Welcome
to the final day of WWDC,


3
00:00:34,636 --> 00:00:37,006
and 'What's New in UIKit
Dynamics and Visual Effects.'


4
00:00:37,346 --> 00:00:38,296
My name is Michael Turner,


5
00:00:38,706 --> 00:00:40,186
joined by my colleague
David Duncan.


6
00:00:40,536 --> 00:00:42,216
We are both on the UIKit
team here at Apple.


7
00:00:43,696 --> 00:00:45,176
So before we get started today,


8
00:00:45,406 --> 00:00:47,286
I just want to recommend
some great sessions.


9
00:00:47,286 --> 00:00:48,846
Since this is an
introductory talk,


10
00:00:49,076 --> 00:00:49,946
we have some great sessions


11
00:00:49,946 --> 00:00:52,826
from years past covering UIKit
Dynamics and visual effects.


12
00:00:53,686 --> 00:00:56,486
So today we are going to
start with a brief overview


13
00:00:56,706 --> 00:00:58,736
of the dynamic animation
system, and we'll do


14
00:00:58,736 --> 00:01:01,226
that with a basic example, and
then we are going to dive right


15
00:01:01,226 --> 00:01:03,656
into what's new this
year with UIKit Dynamics.


16
00:01:04,215 --> 00:01:06,106
Then David's going to
come up and talk to us


17
00:01:06,276 --> 00:01:11,286
about visual effects, and
how you can utilize those


18
00:01:11,286 --> 00:01:12,096
in your application.


19
00:01:12,726 --> 00:01:14,466
And finally, we are going
to talk a little bit


20
00:01:14,466 --> 00:01:16,676
about best practices
using UIKit Dynamics


21
00:01:17,166 --> 00:01:18,756
and auto layout in
your application.


22
00:01:20,296 --> 00:01:23,186
So when we talk about UIKit
Dynamics we are talking


23
00:01:23,186 --> 00:01:26,526
about a 2D, physics-inspired
animation interaction system.


24
00:01:27,406 --> 00:01:29,746
This has a very composable
and declarative API


25
00:01:30,376 --> 00:01:32,876
for exposing high level
animations in your app.


26
00:01:33,756 --> 00:01:36,346
We are not talking about
replacement for Core Animation


27
00:01:36,586 --> 00:01:39,206
or UIView animations,
rather another tool


28
00:01:39,206 --> 00:01:41,606
to help you create great
custom effects in your app.


29
00:01:42,176 --> 00:01:43,436
So let's look at an example.


30
00:01:44,276 --> 00:01:46,636
So here we have a
basic sliding view


31
00:01:46,636 --> 00:01:51,286
and the user can pan the view,
but if you let go it falls back


32
00:01:51,286 --> 00:01:53,216
down as if under the
influence of gravity.


33
00:01:53,216 --> 00:01:56,426
Now, it doesn't fall through
the bottom of the phone.


34
00:01:56,426 --> 00:01:58,636
Rather, it stops on the
bottom edge, bounces a bit,


35
00:01:58,636 --> 00:01:59,376
and then comes to rest.


36
00:01:59,596 --> 00:02:02,726
So let's look at how we can
create this basic example.


37
00:02:03,496 --> 00:02:04,296
First you need to start


38
00:02:04,296 --> 00:02:06,016
by determining a
great reference view.


39
00:02:06,316 --> 00:02:08,216
Here, we've chosen the
view controller's view


40
00:02:08,356 --> 00:02:09,506
that contains our sliding view.


41
00:02:10,116 --> 00:02:12,826
And once we have a
reference view, we then need


42
00:02:12,826 --> 00:02:15,596
to create a dynamic animator and
associate that reference view.


43
00:02:16,136 --> 00:02:18,716
The dynamic animator will
hold the overall context


44
00:02:18,716 --> 00:02:21,846
for our animations, and its
main job is to keep track


45
00:02:21,846 --> 00:02:23,536
of behaviors and dynamic items.


46
00:02:24,726 --> 00:02:27,296
So for our sliding example,
we have a sliding behavior.


47
00:02:27,716 --> 00:02:30,046
And one of the great things
about UI dynamic behavior,


48
00:02:30,466 --> 00:02:32,336
is that higher-level
behaviors can be composed


49
00:02:32,336 --> 00:02:33,206
of more primitive ones.


50
00:02:34,076 --> 00:02:36,516
So our sliding behavior is
nothing more than a composition


51
00:02:36,516 --> 00:02:38,776
of gravity, collision,
and attachment.


52
00:02:39,766 --> 00:02:42,426
And later on, we will show you
how we used UIAttachmentBehavior


53
00:02:42,426 --> 00:02:44,966
and the new things we've added
there to make this even simpler


54
00:02:45,076 --> 00:02:47,376
than it would have
been in the past.


55
00:02:47,526 --> 00:02:48,926
So once we have our
sliding behavior,


56
00:02:49,036 --> 00:02:50,516
we now need a dynamic item.


57
00:02:50,966 --> 00:02:53,586
Here we've chosen the
sliding view, just a UIView


58
00:02:53,936 --> 00:02:56,276
which automatically conforms
to the dynamic item protocol,


59
00:02:56,396 --> 00:02:57,156
so it's a great option.


60
00:02:57,846 --> 00:03:00,126
So we take our dynamic
item, associate it


61
00:03:00,126 --> 00:03:01,076
with the sliding behavior,


62
00:03:01,076 --> 00:03:02,746
and the sliding behavior
to the animator.


63
00:03:02,746 --> 00:03:05,966
Now the animator will
automatically determine


64
00:03:05,966 --> 00:03:08,636
when the system is at rest or in
motion, so this is all you need


65
00:03:08,636 --> 00:03:10,346
to create this great effect.


66
00:03:11,056 --> 00:03:13,336
So now we have seen
a basic example.


67
00:03:14,496 --> 00:03:16,726
This is what's new this
year in UIKit dynamics.


68
00:03:17,216 --> 00:03:17,986
We have support


69
00:03:17,986 --> 00:03:20,816
for non-rectangular collision
bounds on UIDynamicItem.


70
00:03:20,816 --> 00:03:24,166
We have a brand new
UIDynamicItemGroup


71
00:03:24,316 --> 00:03:26,496
that allows multiple items
to behave like one item


72
00:03:26,496 --> 00:03:29,456
in the engine, and we
have a brand new behavior


73
00:03:29,766 --> 00:03:31,166
that models vector force fields.


74
00:03:32,766 --> 00:03:35,876
We have some basic enhancements
to UIDynamicItemBehavior,


75
00:03:36,076 --> 00:03:39,226
as well as UISnapBehavior, and
we'll see some great additions


76
00:03:39,226 --> 00:03:42,006
to UIAttachmentBehavior,
and we will finish


77
00:03:42,006 --> 00:03:44,066
up with some new
ways that you can use


78
00:03:44,066 --> 00:03:46,106
to debug your dynamic
animations.


79
00:03:46,906 --> 00:03:52,566
So, in iOS 9, we
added UIDynamicItem


80
00:03:52,566 --> 00:03:55,556
CollisionBoundsType which
offers you three new ways


81
00:03:55,906 --> 00:03:58,406
to specify the collision
bounds for your dynamic item.


82
00:03:59,246 --> 00:04:02,306
And by default your collision
bounds will be rectangular


83
00:04:02,496 --> 00:04:04,796
matching what's returned
from the bounds accesser


84
00:04:05,076 --> 00:04:06,236
on the dynamic item protocol.


85
00:04:07,396 --> 00:04:10,486
And now you can specify an
ellipse type, which will derive


86
00:04:10,486 --> 00:04:12,906
from the bounds width and
bounds height on the protocol.


87
00:04:13,836 --> 00:04:17,076
And finally, you can specify
a UI BezierPath to use


88
00:04:17,076 --> 00:04:18,536
for the collision bounds
of your dynamic item.


89
00:04:20,755 --> 00:04:23,666
Now, to accomplish this, we have
taken the existing dynamic item


90
00:04:23,666 --> 00:04:27,056
protocol and we have extended
it with two optional properties.


91
00:04:27,416 --> 00:04:28,506
And if you don't
implement either


92
00:04:28,506 --> 00:04:30,936
of these optional properties
you will receive rectangular


93
00:04:30,936 --> 00:04:32,386
collision bounds, as
you have in the past.


94
00:04:33,286 --> 00:04:35,396
If you implement the first
collision bounding type


95
00:04:35,556 --> 00:04:37,416
and return ellipse,
will derive one,


96
00:04:37,506 --> 00:04:39,356
an ellipse from the bounds
width, bounds height.


97
00:04:39,356 --> 00:04:42,146
If you implement the
first and return a path,


98
00:04:42,146 --> 00:04:43,926
we will then call you
back for the second


99
00:04:43,966 --> 00:04:46,886
at which point you will need to
provide a UI BezierPath to use


100
00:04:46,886 --> 00:04:47,766
for the collision bounds.


101
00:04:48,806 --> 00:04:51,526
So if we were to model a
collision between items


102
00:04:51,526 --> 00:04:53,966
with different collision bounds,
and let's add a few more here


103
00:04:53,966 --> 00:04:56,116
for good measure, it might
look something like this,


104
00:04:56,626 --> 00:04:58,986
where this collision
looks a lot more realistic


105
00:04:58,986 --> 00:04:59,796
than it would have in the past,


106
00:05:00,066 --> 00:05:03,236
had all the items had
rectangular collision bounds.


107
00:05:04,476 --> 00:05:07,886
Now, there are a few
restrictions when using a path


108
00:05:08,116 --> 00:05:10,016
for collision bounds
and in particular,


109
00:05:10,016 --> 00:05:13,186
the BezierPath must be convex,
counter-clockwise wound,


110
00:05:13,576 --> 00:05:14,806
and non-self-intersecting.


111
00:05:15,416 --> 00:05:17,996
And these are pretty basic
if you think about it,


112
00:05:18,796 --> 00:05:19,996
nothing too fancy there.


113
00:05:20,056 --> 00:05:23,536
We also need to keep in
mind that the point 00


114
00:05:23,536 --> 00:05:26,946
in the BezierPath will represent
the dynamic item's center point


115
00:05:27,466 --> 00:05:28,456
when the item is on screen.


116
00:05:29,066 --> 00:05:31,526
So that's what's new
in collision bounds.


117
00:05:31,526 --> 00:05:33,346
Let's talk about
dynamic item groups.


118
00:05:33,566 --> 00:05:35,936
And this is a basic way
to take multiple items


119
00:05:36,176 --> 00:05:38,406
and make them behave as one
item in the underlying engine.


120
00:05:39,096 --> 00:05:41,826
And the group preserves
respective positions


121
00:05:42,036 --> 00:05:45,256
and each individual collision
bounds for each item.


122
00:05:45,476 --> 00:05:49,556
So for this reason, you should
associate items with a group


123
00:05:49,836 --> 00:05:51,296
and not with behaviors
individually.


124
00:05:51,296 --> 00:05:53,526
Instead associate them with
the group and the group


125
00:05:53,526 --> 00:05:54,496
with any behaviors you would


126
00:05:54,496 --> 00:05:55,676
like to associate
with the animator.


127
00:05:56,206 --> 00:05:57,966
And this will impose
those behaviors


128
00:05:57,966 --> 00:05:58,976
on the items as a whole.


129
00:05:59,876 --> 00:06:02,526
And a group cannot be
added to other groups.


130
00:06:02,526 --> 00:06:03,886
This is a one-level abstraction.


131
00:06:04,606 --> 00:06:07,026
So this can be a great
way to create concave


132
00:06:07,026 --> 00:06:09,266
or other complex
geometry not capable


133
00:06:09,266 --> 00:06:12,336
with the dynamic item
bounds path, and also have


134
00:06:12,336 --> 00:06:15,626
that influenceable by
behaviors as a whole.


135
00:06:16,316 --> 00:06:19,306
So, let's return to that
sliding example for a moment.


136
00:06:21,496 --> 00:06:24,216
So instead of just panning and
having it to fall back down,


137
00:06:24,216 --> 00:06:27,206
let's say we want it to bounce
slightly when the user taps,


138
00:06:27,206 --> 00:06:28,536
maybe to indicate
that we can pan.


139
00:06:29,286 --> 00:06:31,196
And to do this, we just need


140
00:06:31,196 --> 00:06:33,296
to add a brief force
to the sliding view.


141
00:06:33,896 --> 00:06:35,006
So let's take a look
at that force.


142
00:06:37,116 --> 00:06:40,066
So we can model the force as
a vector at the item's center


143
00:06:40,346 --> 00:06:44,536
where the length of the vector
corresponds to the magnitude


144
00:06:44,536 --> 00:06:47,456
of the force and the
vector points up to indicate


145
00:06:47,456 --> 00:06:49,816
that the direction of the force,
in this case we are trying


146
00:06:49,816 --> 00:06:51,576
to move the view
up, so it points up.


147
00:06:52,366 --> 00:06:55,386
And to apply the force, we're
going to use UIPushBehavior --


148
00:06:56,076 --> 00:06:59,476
where UIPushBehavior, if you
recall, has two distinct modes.


149
00:06:59,896 --> 00:07:03,046
It has a continuous mode that
represents a constant force


150
00:07:03,046 --> 00:07:05,476
over time, and an
instantaneous mode


151
00:07:05,976 --> 00:07:08,386
which represents a brief
force at an instant in time,


152
00:07:08,536 --> 00:07:09,726
otherwise known as an impulse.


153
00:07:10,606 --> 00:07:13,746
So for this interaction, we just
want a brief force so it bounces


154
00:07:13,746 --> 00:07:15,216
and comes back to
rest, so we're going


155
00:07:15,216 --> 00:07:16,126
to use the instantaneous mode.


156
00:07:16,536 --> 00:07:18,006
So we do that; we
get a brief force.


157
00:07:18,066 --> 00:07:20,406
But what is causing the
view to come back down?


158
00:07:20,486 --> 00:07:22,556
We are putting a force on
it that causes it to move up


159
00:07:22,556 --> 00:07:24,016
but it's falling back down.


160
00:07:24,766 --> 00:07:28,426
This is our composite behavior
that was composed of a gravity,


161
00:07:28,456 --> 00:07:29,736
a collision, and attachment.


162
00:07:30,086 --> 00:07:31,876
And so gravity is causing
it to move back down


163
00:07:31,876 --> 00:07:33,556
and then it bounces with
the collision behavior.


164
00:07:33,556 --> 00:07:35,916
But let's look at a
little bit more at gravity


165
00:07:35,916 --> 00:07:37,106
and how that's affecting
our item.


166
00:07:37,276 --> 00:07:39,986
So we look at the
vertical motion over time


167
00:07:40,666 --> 00:07:43,036
of the sliding view,
starting with the instant


168
00:07:43,036 --> 00:07:44,486
that we apply the impulse force.


169
00:07:44,926 --> 00:07:47,386
You will notice that the
force is applied at one point


170
00:07:47,606 --> 00:07:50,086
and then the item kind of moves
up and then arcs back down.


171
00:07:50,806 --> 00:07:53,126
This is because gravity is
affecting it at all positions


172
00:07:53,126 --> 00:07:54,566
and all times in
our diagram here.


173
00:07:54,886 --> 00:07:57,656
If we add those forces in from
gravity, it might look something


174
00:07:57,656 --> 00:08:01,826
like this, where
the force is applied


175
00:08:01,866 --> 00:08:03,406
at all positions and all times.


176
00:08:03,616 --> 00:08:04,976
So this is tricky to model.


177
00:08:05,426 --> 00:08:07,346
Maybe we could try and
use UI push behavior,


178
00:08:07,446 --> 00:08:09,286
but it would be pretty
complex, pretty quickly.


179
00:08:09,976 --> 00:08:12,476
So we really need to think of
gravity as more of a field.


180
00:08:13,376 --> 00:08:15,506
And a field's quite
simple, it's just a function


181
00:08:15,716 --> 00:08:18,816
that assigns a vector to each
point within a given domain,


182
00:08:18,986 --> 00:08:20,776
where our domain,
in this example,


183
00:08:20,776 --> 00:08:21,946
is the entire reference view.


184
00:08:22,236 --> 00:08:24,596
So we want gravity to
affect our sliding view


185
00:08:24,946 --> 00:08:25,996
in the entire reference view.


186
00:08:26,846 --> 00:08:27,276
Pretty simple.


187
00:08:27,276 --> 00:08:30,666
So we have taken this idea of a
field and we have extended it.


188
00:08:31,026 --> 00:08:33,846
In iOS 9, we are
introducing UIFieldBehavior.


189
00:08:33,846 --> 00:08:38,206
And UIFieldBehavior is a way
that can be added to a region


190
00:08:38,206 --> 00:08:42,296
of your reference view, and the
field is evaluated at each point


191
00:08:42,296 --> 00:08:43,285
within the reference view,


192
00:08:43,285 --> 00:08:46,456
and any resulting forces
are automatically applied


193
00:08:46,456 --> 00:08:48,246
by the dynamic animator
to the items


194
00:08:48,246 --> 00:08:51,006
that have been associated
with the field.


195
00:08:51,166 --> 00:08:52,136
And if you are wondering,


196
00:08:52,136 --> 00:08:55,236
our existing UIGravityBehavior
has been implemented


197
00:08:55,236 --> 00:08:58,866
as a field all along, and
it's important to keep in mind


198
00:08:58,866 --> 00:09:00,146
that this is simplified physics.


199
00:09:00,146 --> 00:09:01,626
It's been well tuned
for performance.


200
00:09:02,016 --> 00:09:04,626
I wouldn't use it for building
interstellar space stations


201
00:09:04,626 --> 00:09:05,306
or anything like that.


202
00:09:06,606 --> 00:09:09,286
So let's look at the built-in
field types that we offer.


203
00:09:09,476 --> 00:09:10,686
We've got a rich variety here.


204
00:09:10,776 --> 00:09:13,846
We have linear and
radial gravity, velocity


205
00:09:13,846 --> 00:09:17,266
and drag fields, a vortex field,
we have got a great spring field


206
00:09:17,266 --> 00:09:19,326
that models Hooke's
law, we've got electric


207
00:09:19,326 --> 00:09:20,476
and magnetic field types.


208
00:09:21,086 --> 00:09:23,176
And if these all don't
quite meet your needs,


209
00:09:23,176 --> 00:09:25,036
we also offer a custom
force evaluator,


210
00:09:25,036 --> 00:09:26,006
and we'll see this in a moment.


211
00:09:26,486 --> 00:09:28,346
But let's start with
linear gravity here first.


212
00:09:29,356 --> 00:09:31,336
So the first thing you will
notice is it exists in a region,


213
00:09:31,676 --> 00:09:34,806
in a domain as we previously
said, and it has a strength,


214
00:09:34,806 --> 00:09:36,386
we've used the default
strength of one here,


215
00:09:36,846 --> 00:09:38,406
but it's also a directional
force,


216
00:09:38,486 --> 00:09:40,236
and then we have used
the familiar direction


217
00:09:40,236 --> 00:09:43,246
of gravity here, down,
to show this example,


218
00:09:43,566 --> 00:09:46,056
but this can be directed
anywhere, really.


219
00:09:46,776 --> 00:09:48,996
So let's look at how
radial gravity differs


220
00:09:48,996 --> 00:09:50,236
from that of linear gravity.


221
00:09:51,096 --> 00:09:55,896
And along with existing in a
domain and having a strength,


222
00:09:55,896 --> 00:09:58,256
this has a position
which can be modeled


223
00:09:58,256 --> 00:10:00,796
with radial gravity
as a point mass.


224
00:10:01,266 --> 00:10:03,826
And if you recall, the
gravitational force


225
00:10:03,826 --> 00:10:06,526
between two masses is
inversely proportional


226
00:10:06,876 --> 00:10:08,946
to the distance squared
between the two masses.


227
00:10:09,446 --> 00:10:12,016
So, here, that distance
squared between the masses,


228
00:10:12,016 --> 00:10:14,646
that exponent, this is the
fall off value of the field.


229
00:10:15,216 --> 00:10:17,276
So as you get farther away
from the position of the field,


230
00:10:17,886 --> 00:10:21,126
the force due to the
field, it gets -- decreases.


231
00:10:21,126 --> 00:10:23,796
And we also have a minimum
radius property here,


232
00:10:23,796 --> 00:10:26,576
and this is just a
way to specify how far


233
00:10:26,576 --> 00:10:29,646
from the position point
an item must be in order


234
00:10:29,646 --> 00:10:31,706
to feel a resulting
force due to this field.


235
00:10:33,386 --> 00:10:34,986
So we also have a noise field,


236
00:10:35,516 --> 00:10:37,456
and the first thing you will
notice about a noise field is,


237
00:10:37,456 --> 00:10:40,876
it's time varying, and you can
adjust this using the animation


238
00:10:40,926 --> 00:10:42,466
speed with a default
value of one,


239
00:10:42,816 --> 00:10:44,296
and zero would indicate
a static field.


240
00:10:44,996 --> 00:10:46,976
You can also adjust
the level of noise


241
00:10:46,976 --> 00:10:48,446
in the field using the
smoothness property.


242
00:10:50,726 --> 00:10:52,486
So let's look at a
custom field evaluator.


243
00:10:53,296 --> 00:10:54,796
And this is really
quite easy to use.


244
00:10:54,796 --> 00:10:57,406
You create a UIFieldBehavior
and initialize it


245
00:10:57,686 --> 00:10:58,856
with a field evaluation block.


246
00:10:59,356 --> 00:11:00,666
We will then call your block


247
00:11:00,666 --> 00:11:02,856
with several field samples
containing the position,


248
00:11:03,176 --> 00:11:06,056
velocity, mass, and
charge, and time associated


249
00:11:06,056 --> 00:11:08,436
with that field sample
and then you can use


250
00:11:08,436 --> 00:11:10,546
that to determine
any resulting forces.


251
00:11:11,016 --> 00:11:13,566
Here all we did was take the
position, the x position,


252
00:11:13,956 --> 00:11:15,076
and map it to a sin wave.


253
00:11:15,666 --> 00:11:16,346
Pretty cool result.


254
00:11:16,346 --> 00:11:20,456
So these are the -- some of
the basic built-in fields


255
00:11:20,456 --> 00:11:22,386
and a basic overview
of UIFieldBehavior.


256
00:11:22,606 --> 00:11:25,006
I would like to invite up David
to give you a quick example


257
00:11:25,246 --> 00:11:26,096
of showing an inaction.


258
00:11:27,516 --> 00:11:32,726
[Applause]


259
00:11:33,226 --> 00:11:35,056
>> DAVID DUNCAN: Hello,
everybody, and we are going


260
00:11:35,056 --> 00:11:36,666
to take you through an
example of something


261
00:11:36,666 --> 00:11:38,636
that I'm certain you
have all seen before.


262
00:11:40,136 --> 00:11:42,726
As I'm sure you have all
used FaceTime at some point


263
00:11:42,726 --> 00:11:45,576
or another, and so we
just have an example


264
00:11:45,666 --> 00:11:47,266
of building a very similar UI


265
00:11:47,266 --> 00:11:50,056
for managing your
face in the screen.


266
00:11:50,056 --> 00:11:52,806
As you have been able to see
as I have gone through here,


267
00:11:53,306 --> 00:11:55,786
the square moves very nicely
as I move it around the screen,


268
00:11:55,786 --> 00:11:59,006
and if I pull it a little away
from the corner it bounces back.


269
00:11:59,006 --> 00:12:01,096
If I pull farther, it has


270
00:12:01,096 --> 00:12:02,836
that nice ease-in
curve as we are going.


271
00:12:02,836 --> 00:12:05,496
And if I throw it down, it kind


272
00:12:05,496 --> 00:12:07,616
of bounces off very playfully
all around the edges.


273
00:12:08,056 --> 00:12:10,376
And you will note when I threw
it down, it didn't just kind


274
00:12:10,376 --> 00:12:12,436
of go straight to where
it was supposed to go,


275
00:12:12,676 --> 00:12:14,796
it actually had a little
physics, it bounced off the side


276
00:12:14,796 --> 00:12:16,506
of the screen and came
back into position.


277
00:12:17,716 --> 00:12:22,096
Now, I can do a little thing
and trigger a debugging view


278
00:12:22,096 --> 00:12:23,976
of what those forces
fields look like.


279
00:12:24,576 --> 00:12:25,716
In this case you
can see that we --


280
00:12:26,516 --> 00:12:31,196
[Applause]


281
00:12:31,696 --> 00:12:34,026
In case, you can see that we
have four spring fields running


282
00:12:34,026 --> 00:12:38,236
around here, and we have got an
easy way to explain what's going


283
00:12:38,236 --> 00:12:40,256
on so if we put this
right on the edge,


284
00:12:40,306 --> 00:12:41,576
we know it is going
to bounce back.


285
00:12:42,446 --> 00:12:44,926
And if we kind of straddle
two, then depending


286
00:12:44,926 --> 00:12:47,016
on where we straddle it will
pick one side or the other.


287
00:12:47,796 --> 00:12:49,336
And go through the middle,


288
00:12:49,696 --> 00:12:50,976
and it just picks
whichever is closest.


289
00:12:51,536 --> 00:12:53,016
So let's see how we set this up,


290
00:12:53,016 --> 00:12:55,916
and how we can actually
set this all ourselves.


291
00:12:56,696 --> 00:13:00,836
So the first thing that we have
is this StickyCorners behavior,


292
00:13:01,286 --> 00:13:03,826
and as Mike mentioned, it's
built up of other behaviors


293
00:13:03,826 --> 00:13:06,336
to form this complex behavior
that does everything we want.


294
00:13:06,706 --> 00:13:08,446
In this case, it has got
a collision behavior,


295
00:13:08,446 --> 00:13:09,536
because we wouldn't
want your face


296
00:13:09,536 --> 00:13:11,096
to rocket off the
side of the screen.


297
00:13:11,826 --> 00:13:14,236
And we have a dynamic
item behavior,


298
00:13:14,236 --> 00:13:16,296
that affects the
properties of that face.


299
00:13:16,636 --> 00:13:18,216
In this case, we
reduce its density


300
00:13:18,216 --> 00:13:19,966
to it's really light
feeling in the engine,


301
00:13:19,966 --> 00:13:22,946
but we increase its
resistance to motion so that


302
00:13:22,946 --> 00:13:25,346
when it finds a place to
settle it doesn't keep spinning


303
00:13:25,346 --> 00:13:26,366
around in that location.


304
00:13:27,136 --> 00:13:28,866
And finally we disable rotation,


305
00:13:28,866 --> 00:13:29,986
because that wouldn't
make any sense.


306
00:13:29,986 --> 00:13:30,906
You don't want your
face spinning


307
00:13:30,906 --> 00:13:32,146
around as it's going
around the screen.


308
00:13:33,556 --> 00:13:35,826
Finally, we have
these field behaviors,


309
00:13:35,826 --> 00:13:38,856
the four spring fields that
map out the four corners,


310
00:13:38,956 --> 00:13:40,586
and we add those to
the behavior too.


311
00:13:40,996 --> 00:13:44,536
Now whenever somebody adds
this StickyCorners behavior,


312
00:13:44,636 --> 00:13:48,396
they get all of this
behavior for free.


313
00:13:48,616 --> 00:13:50,406
Next, over here in
the view controller,


314
00:13:50,966 --> 00:13:52,626
we go to all the usual
stuff where we set


315
00:13:52,626 --> 00:13:56,396
up our view hierarchy, but
then we also add a pan gesture


316
00:13:56,396 --> 00:13:58,676
recognizer so that the
user can pick up the face


317
00:13:58,676 --> 00:13:59,766
and move it around the screen.


318
00:14:00,966 --> 00:14:03,486
This long press gesture
recognizer we have here lets me


319
00:14:03,486 --> 00:14:05,296
actually toggle on and
off the debug interface.


320
00:14:05,916 --> 00:14:07,296
We create our dynamic animator


321
00:14:07,456 --> 00:14:09,776
and add the StickyCorners
behavior to it.


322
00:14:10,196 --> 00:14:12,256
So how does that
gesture recognizer work?


323
00:14:12,746 --> 00:14:15,306
Well, as usual, the gesture
recognizer goes between states.


324
00:14:15,366 --> 00:14:20,046
It starts at begin, and when we
begin, we do some bookkeeping


325
00:14:20,046 --> 00:14:21,326
so that we can keep
track of the item,


326
00:14:21,326 --> 00:14:23,186
but we also disable
the sticky behavior.


327
00:14:23,186 --> 00:14:24,706
And I will show you how
we do that in a second.


328
00:14:25,376 --> 00:14:27,826
Similarly, when it's changed
we just move the item around.


329
00:14:28,506 --> 00:14:30,146
And when it cancels or ends,


330
00:14:30,516 --> 00:14:32,066
this is where we do
something really special.


331
00:14:32,586 --> 00:14:35,506
We check the velocity that
the pan gesture recognizer had


332
00:14:35,506 --> 00:14:37,376
when the user stopped
interacting with it,


333
00:14:37,926 --> 00:14:40,316
and we use that to
add velocity back


334
00:14:40,316 --> 00:14:41,706
into our dynamic item system.


335
00:14:41,776 --> 00:14:44,546
And this is so that when the
user throws that view around,


336
00:14:44,726 --> 00:14:47,516
it continues moving with the
force of the user's action,


337
00:14:47,756 --> 00:14:49,706
rather than just suddenly
stopping and being taken


338
00:14:49,706 --> 00:14:51,046
over entirely by the field.


339
00:14:51,736 --> 00:14:53,086
And the whole reason
why we disabled


340
00:14:53,086 --> 00:14:54,486
and enabled it is
for the same reason.


341
00:14:54,826 --> 00:14:56,226
We don't want the fields


342
00:14:56,276 --> 00:14:58,016
to be active while the
user is moving it around,


343
00:14:58,016 --> 00:14:58,976
otherwise it is going to slip


344
00:14:58,976 --> 00:15:00,116
out from underneath
their finger.


345
00:15:00,666 --> 00:15:03,026
So we can go back
over here briefly


346
00:15:03,026 --> 00:15:05,226
and see how the enabled works,


347
00:15:05,796 --> 00:15:07,556
and as you can see,
it's really simple.


348
00:15:07,936 --> 00:15:10,596
When it's enabled, we
add all of the items back


349
00:15:10,596 --> 00:15:13,086
into the behaviors, and when
it's disabled, we take them out.


350
00:15:13,396 --> 00:15:16,386
It's really that easy to
create a system like this,


351
00:15:16,386 --> 00:15:18,526
and you can have your own
FaceTime-like behavior


352
00:15:18,796 --> 00:15:19,676
in your applications.


353
00:15:20,296 --> 00:15:23,006
And so to show you how
to put that debug UI


354
00:15:23,186 --> 00:15:24,316
into your own applications,


355
00:15:24,316 --> 00:15:25,736
I am going to bring
Mike back up on stage.


356
00:15:26,516 --> 00:15:32,246
[Applause]


357
00:15:32,746 --> 00:15:33,326
>> MICHAEL TURNER:
Thanks, David.


358
00:15:34,086 --> 00:15:37,056
So it's really, really quite
cool, in David's example,


359
00:15:37,056 --> 00:15:38,786
to visualize those field lines,


360
00:15:38,966 --> 00:15:41,516
to understand what
was actually going on.


361
00:15:41,896 --> 00:15:43,796
This is pretty mysterious
until he turned that on.


362
00:15:44,596 --> 00:15:47,956
So those lines were basically
an overlay that shows the field


363
00:15:48,506 --> 00:15:50,166
in your animators'
reference view.


364
00:15:51,136 --> 00:15:54,696
And specifically, this overlay
can help you visualize fields,


365
00:15:54,696 --> 00:15:56,996
collision bounds,
attachments, and whether


366
00:15:56,996 --> 00:16:00,106
or not a particular item
is in motion or at rest.


367
00:16:00,656 --> 00:16:02,926
Now, you might be wondering,
it's not going to be API.


368
00:16:03,866 --> 00:16:06,826
But it will be accessible in
LLDB, and we are advertising it


369
00:16:06,826 --> 00:16:09,376
as an available debug
feature on UIDynamicAnimator.


370
00:16:09,866 --> 00:16:10,946
And it's really simple to use.


371
00:16:11,276 --> 00:16:13,256
Just pause the debugger,
find a reference


372
00:16:13,256 --> 00:16:15,956
to your dynamic animator,
set debug enabled to true,


373
00:16:15,956 --> 00:16:18,156
and you will have this
great overlay depicting all


374
00:16:18,156 --> 00:16:18,526
the physics.


375
00:16:19,516 --> 00:16:23,546
[Applause]


376
00:16:24,046 --> 00:16:27,346
Now in addition to debug
enabled and disabled,


377
00:16:27,346 --> 00:16:28,966
we are also offering
debug interval.


378
00:16:29,056 --> 00:16:32,086
And this is a way that you
can tune how often we update


379
00:16:32,086 --> 00:16:33,166
that debug overlay.


380
00:16:33,456 --> 00:16:35,286
So, by default, that
will be updated


381
00:16:35,286 --> 00:16:37,106
on every animation frame,
but if you have a lot


382
00:16:37,106 --> 00:16:39,926
of complex physics, it might
be beneficial to change


383
00:16:39,926 --> 00:16:41,116
that to five, for example,


384
00:16:41,116 --> 00:16:43,246
to only update the overlay
on every fifth frame.


385
00:16:44,236 --> 00:16:47,326
And, we're also allowing you
to adjust the animation speed


386
00:16:47,326 --> 00:16:48,236
of the dynamic animator.


387
00:16:48,896 --> 00:16:51,076
Now this might be helpful
for slowing down things


388
00:16:51,196 --> 00:16:52,746
to observe what's
actually going on.


389
00:16:53,046 --> 00:16:55,566
And then it's important to
keep in mind when using this,


390
00:16:56,126 --> 00:16:57,946
this can affect the
results of the simulation,


391
00:16:58,246 --> 00:16:59,126
when you slow things down.


392
00:16:59,176 --> 00:17:00,866
So always ensure
correction at 1x.


393
00:17:03,506 --> 00:17:06,215
So, next, let's talk about
UIDynamicItemBehavior.


394
00:17:06,836 --> 00:17:08,195
Now, if you recall,
this is a way


395
00:17:08,195 --> 00:17:11,486
to alter the physical properties
of your view or a dynamic item,


396
00:17:12,046 --> 00:17:14,546
and it can be applied to
one or more dynamic items.


397
00:17:15,026 --> 00:17:18,556
And in David's example,
he applied a lower density


398
00:17:18,556 --> 00:17:20,656
and a higher resistance
to the FaceTime square


399
00:17:20,935 --> 00:17:22,776
to make it really stick
to the field corners.


400
00:17:23,516 --> 00:17:26,096
So a few more examples of
the existing properties here.


401
00:17:26,096 --> 00:17:29,946
We have elasticity, friction,
we saw density and resistance,


402
00:17:29,946 --> 00:17:32,066
we have angular resistance,
and these are all great ways


403
00:17:32,376 --> 00:17:34,836
to adjust how your item feels
in the animation engine.


404
00:17:35,536 --> 00:17:38,806
In iOS 9, we have added two
additional properties: charge --


405
00:17:38,946 --> 00:17:42,066
this affects the degree to
which your item participates


406
00:17:42,066 --> 00:17:44,126
in our new electric and
magnetic field types;


407
00:17:44,456 --> 00:17:46,466
and we also added an
anchored property.


408
00:17:47,036 --> 00:17:48,006
This one is a little
bit different.


409
00:17:48,486 --> 00:17:51,096
But what it does is it allows
your item to participate


410
00:17:51,096 --> 00:17:54,556
in the dynamic system, and
participate in collisions,


411
00:17:54,556 --> 00:17:56,736
but it will obtain no
velocity of its own.


412
00:17:56,736 --> 00:17:59,126
So it really behaves more
like a collision boundary.


413
00:17:59,636 --> 00:18:03,506
So next, I would like to talk
about UIAttachmentBehavior.


414
00:18:03,926 --> 00:18:06,386
And this allow you to
constrain two dynamic items


415
00:18:06,446 --> 00:18:08,786
such that they maintain
a particular distance


416
00:18:08,786 --> 00:18:09,236
from each other.


417
00:18:09,236 --> 00:18:13,066
And you can configure this
with the damping and frequency


418
00:18:13,366 --> 00:18:16,136
to make it behave more like
a spring as opposed to a rod.


419
00:18:16,246 --> 00:18:18,176
And this is a great attachment.


420
00:18:18,176 --> 00:18:20,966
You know, it's very useful,
but it's really only one way


421
00:18:20,966 --> 00:18:23,196
to constrain two items
with respect to each other.


422
00:18:23,846 --> 00:18:27,686
So, in iOS 9, we have added some
additional attachment types.


423
00:18:28,306 --> 00:18:29,866
The first of which is
a limit attachment.


424
00:18:30,476 --> 00:18:32,516
This is quite similar to
the distance attachment


425
00:18:32,516 --> 00:18:35,486
that we just described, however,
instead of being constrained


426
00:18:35,486 --> 00:18:37,746
by what could be thought
of as a rod or a spring,


427
00:18:38,246 --> 00:18:40,816
this one behaves more like a
rope between the two items,


428
00:18:40,946 --> 00:18:43,156
where the only constraint
is a maximum distance


429
00:18:43,156 --> 00:18:43,616
from each other.


430
00:18:44,656 --> 00:18:46,836
And you configure this similar
to the distance attachment


431
00:18:47,166 --> 00:18:49,776
by specifying two points
offset from each item's center.


432
00:18:50,646 --> 00:18:51,106
Very simple.


433
00:18:51,996 --> 00:18:53,466
Next, we have a fixed
attachment.


434
00:18:53,876 --> 00:18:56,126
And this one is a little
bit different than the limit


435
00:18:56,126 --> 00:18:57,096
or the distance attachment.


436
00:18:57,726 --> 00:18:59,316
And you create this
type of attachment


437
00:18:59,316 --> 00:19:01,056
by first specifying
an anchor point.


438
00:19:01,396 --> 00:19:03,336
This anchor point is
in the coordinate space


439
00:19:03,336 --> 00:19:07,066
of your reference view, with
respect to each item's center.


440
00:19:08,176 --> 00:19:11,156
And this type of attachment
offers no movement whatsoever


441
00:19:11,196 --> 00:19:12,216
between the two items.


442
00:19:12,776 --> 00:19:16,556
It's much like a welded rod
between both items as opposed


443
00:19:16,556 --> 00:19:18,636
to a rod that allows
them to spin on the ends.


444
00:19:19,026 --> 00:19:22,446
And we have also added
a pin attachment type.


445
00:19:23,396 --> 00:19:26,026
This one is similar to the
fixed attachment where you start


446
00:19:26,026 --> 00:19:28,966
by specifying an anchor
point between two items.


447
00:19:29,946 --> 00:19:32,776
But this type allows two
items to rotate with respect


448
00:19:32,776 --> 00:19:34,446
to each other, about
this anchor point.


449
00:19:34,836 --> 00:19:37,876
And this allows you to
specify a rotatable range,


450
00:19:37,936 --> 00:19:40,526
which by default would be
unbounded but we could bound it


451
00:19:40,526 --> 00:19:42,406
down to something
smaller like so.


452
00:19:43,436 --> 00:19:46,186
And finally we have added
a sliding attachment.


453
00:19:46,786 --> 00:19:49,616
Now the sliding attachment is
a little bit more complicated.


454
00:19:49,676 --> 00:19:51,066
We'll look at an
example in just a second.


455
00:19:51,556 --> 00:19:53,696
but just like the fixed
and the pin types,


456
00:19:53,696 --> 00:19:56,146
we first specify this
attachment anchor point that's


457
00:19:56,146 --> 00:19:57,616
in the coordinate space
of the reference view.


458
00:19:58,876 --> 00:20:00,396
But unlike those
types, we also need


459
00:20:00,396 --> 00:20:02,436
to specify an axis
of translation.


460
00:20:02,906 --> 00:20:04,866
And this is where
all relative movement


461
00:20:04,866 --> 00:20:07,586
between two items will be
along the axis of translation.


462
00:20:08,336 --> 00:20:10,516
And this type prevents
all relative rotation


463
00:20:10,516 --> 00:20:11,306
of the two items.


464
00:20:11,306 --> 00:20:13,666
So they are really fixed
rotationally with respect


465
00:20:13,666 --> 00:20:15,946
to each other and they can
only move along the axis


466
00:20:15,946 --> 00:20:16,566
of translation.


467
00:20:17,826 --> 00:20:18,836
But just like the pin type,


468
00:20:19,196 --> 00:20:21,126
you can limit this
translatable range.


469
00:20:21,286 --> 00:20:23,106
So if you do specify
a translatable range,


470
00:20:23,426 --> 00:20:25,556
it needs to include the
attachment anchor point,


471
00:20:26,096 --> 00:20:27,566
where the anchor
point is defined


472
00:20:27,566 --> 00:20:29,166
as the point zero in the range.


473
00:20:29,896 --> 00:20:32,126
So if we set this system up
with this type of attachment,


474
00:20:32,806 --> 00:20:34,026
we can have linear motion


475
00:20:34,026 --> 00:20:35,566
between the two items,
like that.


476
00:20:36,456 --> 00:20:37,516
So that's pretty complicated.


477
00:20:37,516 --> 00:20:38,896
Let's look at a basic example.


478
00:20:39,926 --> 00:20:41,376
And to do that, I want to return


479
00:20:41,376 --> 00:20:43,256
to our sliding example
one more time.


480
00:20:44,476 --> 00:20:46,666
Now, I mentioned in the
past, that had we tried


481
00:20:46,706 --> 00:20:49,666
to make this slidable
behavior, we would have had


482
00:20:49,666 --> 00:20:51,996
to add a collision on the
bottom and on each side


483
00:20:52,066 --> 00:20:53,886
and somewhere off the
screen above on the top,


484
00:20:54,186 --> 00:20:55,206
to constrain the motion


485
00:20:55,446 --> 00:20:57,426
of the sliding view
along the vertical axis.


486
00:20:58,036 --> 00:21:00,366
Well, with UI attachment
behavior, we don't need to do


487
00:21:00,366 --> 00:21:02,776
that anymore, we can use a
sliding attachment to do that.


488
00:21:03,026 --> 00:21:04,786
So we limit the system
to one collision,


489
00:21:05,176 --> 00:21:06,176
making the performance better,


490
00:21:06,436 --> 00:21:08,126
and the code actually
quite a bit more readable.


491
00:21:08,916 --> 00:21:10,546
So if we enable our
debug view here,


492
00:21:10,956 --> 00:21:13,366
you can see the sliding
attachment depicted


493
00:21:13,366 --> 00:21:15,426
by the straight line
along the vertical axis.


494
00:21:15,426 --> 00:21:18,406
It expands and contracts
as we slide the view,


495
00:21:18,876 --> 00:21:20,476
but there's also
another attachment there,


496
00:21:20,846 --> 00:21:23,776
and that's a distance
attachment that we use to attach


497
00:21:23,776 --> 00:21:25,636
to an anchor point
that's manipulated


498
00:21:25,636 --> 00:21:26,826
by a pan gesture recognizer.


499
00:21:27,306 --> 00:21:29,636
So, unlike David's demo,
this one's entirely


500
00:21:29,636 --> 00:21:30,706
within the dynamics system.


501
00:21:30,706 --> 00:21:32,646
We don't disable
or enable anything.


502
00:21:32,826 --> 00:21:33,776
We just stay in dynamics.


503
00:21:34,376 --> 00:21:34,746
Pretty cool.


504
00:21:35,836 --> 00:21:39,086
So, finally, let me give you a
quick update on UISnapBehavior.


505
00:21:39,786 --> 00:21:42,356
If you recall, UISnapBehavior
is a higher level behavior.


506
00:21:42,796 --> 00:21:45,426
And it can be used to move
a view from one location


507
00:21:45,426 --> 00:21:46,896
to another with a
snap-like effect.


508
00:21:47,956 --> 00:21:50,296
And SnapBehavior allows you
to customize the damping


509
00:21:50,296 --> 00:21:53,196
of the snap, which can
really adjust, you know,


510
00:21:53,196 --> 00:21:54,816
the snappiness of how it feels.


511
00:21:55,616 --> 00:21:58,096
In iOS 9, we've added
the ability


512
00:21:58,096 --> 00:22:00,296
to customize the snap
point after init time


513
00:22:00,296 --> 00:22:01,816
as well, which is pretty cool.


514
00:22:02,076 --> 00:22:03,366
So let's look at a
quick example, here.


515
00:22:04,006 --> 00:22:08,246
So if we try to pan the view,
here, with our debug on,


516
00:22:08,616 --> 00:22:11,586
it will fall back to the screen,
like the original snap point.


517
00:22:12,016 --> 00:22:14,596
If we tap in another location,
it will snap to the new point


518
00:22:14,686 --> 00:22:16,196
and that's just adjusting
the snap point


519
00:22:16,516 --> 00:22:18,106
on an existing dynamic behavior.


520
00:22:18,486 --> 00:22:18,896
Pretty cool.


521
00:22:19,626 --> 00:22:22,976
And you will also notice
that with the debug overlay,


522
00:22:23,546 --> 00:22:25,706
this is actually a
composite behavior of its own.


523
00:22:25,706 --> 00:22:29,086
There's four attachments
here, configured as springs,


524
00:22:29,516 --> 00:22:31,956
just that snap the view
to the new position.


525
00:22:31,956 --> 00:22:32,746
It's really quite cool.


526
00:22:33,546 --> 00:22:36,626
So that's what's new in
UIKit Dynamics and iOS 9.


527
00:22:37,406 --> 00:22:38,816
I would like to turn
it over to David


528
00:22:38,816 --> 00:22:39,936
to talk about visual effects.


529
00:22:41,516 --> 00:22:45,996
[Applause]


530
00:22:46,496 --> 00:22:47,266
>> DAVID DUNCAN: Good
evening, everybody.


531
00:22:47,266 --> 00:22:49,936
So we are going to talk
about using visual effects


532
00:22:49,936 --> 00:22:51,456
to add style to your
application.


533
00:22:52,256 --> 00:22:54,136
So we are going to motivate this


534
00:22:54,136 --> 00:22:57,006
with just a simple image viewer
application, where what we want


535
00:22:57,006 --> 00:23:00,256
to do is show the user
some extra information


536
00:23:00,256 --> 00:23:01,756
about the photo they are
currently looking at.


537
00:23:02,316 --> 00:23:05,596
And so as you see right
there, this image happens


538
00:23:05,596 --> 00:23:06,606
to have a little overlay


539
00:23:06,606 --> 00:23:09,126
that tells us what the
file name is of the image.


540
00:23:09,676 --> 00:23:11,896
So we are going to walk through
how we actually create that.


541
00:23:13,176 --> 00:23:15,306
And so, the first
step is that you need


542
00:23:15,306 --> 00:23:16,336
to create a blur effect.


543
00:23:16,866 --> 00:23:19,206
And we have three different
styles, the extra light,


544
00:23:19,286 --> 00:23:20,456
light, and dark styles.


545
00:23:20,946 --> 00:23:25,156
And then you create a blur
effect from those styles.


546
00:23:25,566 --> 00:23:27,356
And that's just how you
do that right there.


547
00:23:27,896 --> 00:23:30,446
And finally, you create
your visual effect view


548
00:23:30,626 --> 00:23:31,696
with that blur style.


549
00:23:32,306 --> 00:23:34,256
Then you just add whatever
layout you need to do


550
00:23:34,546 --> 00:23:36,406
and you can get the blur
that you see on screen there.


551
00:23:36,406 --> 00:23:39,886
The next step is we are going
to add a vibrancy effect.


552
00:23:39,886 --> 00:23:42,596
And what vibrancy does is, it
really makes something pop,


553
00:23:42,596 --> 00:23:44,286
stand out from when
it's over a blur.


554
00:23:44,286 --> 00:23:47,986
And so what we are going to do
is we are just going to create


555
00:23:47,986 --> 00:23:49,766
that vibrancy effect
from a blur effect.


556
00:23:49,926 --> 00:23:51,776
As mentioned, it's really
intended to be overlayed


557
00:23:51,776 --> 00:23:54,316
from a blur, so we start
with that blur effect


558
00:23:54,316 --> 00:23:55,526
to create the vibrancy effect.


559
00:23:56,616 --> 00:23:57,966
We create our vibrancy effect,


560
00:23:57,966 --> 00:23:59,166
just like we did
before with the blur.


561
00:24:00,026 --> 00:24:01,806
And then, in this case
we're going to add it


562
00:24:01,806 --> 00:24:04,336
to the content view
of the blur view.


563
00:24:04,336 --> 00:24:07,226
Now, it doesn't have to be
directly added to the blur,


564
00:24:07,226 --> 00:24:10,406
but there should be a
blur that you see behind


565
00:24:10,466 --> 00:24:11,356
that visual effect view.


566
00:24:12,416 --> 00:24:14,356
And finally, we add the label


567
00:24:14,356 --> 00:24:16,226
to the content view
of the vibrancy view.


568
00:24:16,416 --> 00:24:19,396
And the reason we are adding
these things to the content view


569
00:24:19,396 --> 00:24:21,356
of the visual effects view,
is because that ensures


570
00:24:21,356 --> 00:24:23,856
that we get the correct
effect for all the content


571
00:24:23,856 --> 00:24:24,696
that you are presenting.


572
00:24:25,216 --> 00:24:27,436
And so, when you have
done all of that,


573
00:24:27,916 --> 00:24:30,316
you get the lovely
label on top of the blur


574
00:24:30,406 --> 00:24:31,226
as you see on the screen.


575
00:24:32,406 --> 00:24:33,906
So what's new in iOS 9 here?


576
00:24:34,526 --> 00:24:37,146
Well, the first thing we have
done is we have made it really


577
00:24:37,146 --> 00:24:40,446
easy to cleanly animate
the bounds of your view.


578
00:24:40,446 --> 00:24:42,836
So that you can show more
information in that blur view


579
00:24:42,836 --> 00:24:45,916
to the user without having to
do anything really complex.


580
00:24:46,876 --> 00:24:48,746
But, in addition, we
have made it possible


581
00:24:48,746 --> 00:24:51,986
for you to animate the blur.


582
00:24:52,136 --> 00:24:54,796
And so now, if you have a night
load in your app, for example,


583
00:24:54,796 --> 00:24:56,996
you can do a really clean
animation from day to night


584
00:24:56,996 --> 00:24:58,966
in your application and
move the user along.


585
00:25:00,276 --> 00:25:02,176
Now, the next thing we are
going to talk through, briefly,


586
00:25:02,176 --> 00:25:04,966
is how do we actually get
these effects to the screen?


587
00:25:05,076 --> 00:25:08,086
What does it do and why
do you need to know?


588
00:25:08,086 --> 00:25:09,906
It's important because
this all has impacts


589
00:25:09,906 --> 00:25:11,426
on both performance
and correctness.


590
00:25:11,426 --> 00:25:13,936
So little baby Sophia
here is going to walk us


591
00:25:13,936 --> 00:25:18,316
through adding a little
overlay to her little UI here.


592
00:25:19,246 --> 00:25:20,906
So the first thing
to do is figure out,


593
00:25:20,906 --> 00:25:21,836
where are we capturing?


594
00:25:22,496 --> 00:25:23,946
Whenever we see a visual effect,


595
00:25:24,016 --> 00:25:26,426
we figure out what the capture
content we need for it is


596
00:25:26,866 --> 00:25:27,906
and we move it offscreen.


597
00:25:28,726 --> 00:25:30,026
So we copy that little
piece out.


598
00:25:30,966 --> 00:25:33,306
And now that it's offscreen,
we can actually work with it,


599
00:25:33,306 --> 00:25:34,636
but why did we take
it offscreen?


600
00:25:35,116 --> 00:25:37,536
Well, for one reason is
that we need to make sure


601
00:25:37,536 --> 00:25:39,196
that we get the correct
effects and in this case


602
00:25:39,196 --> 00:25:41,216
that we capture everything
we need to blur


603
00:25:41,216 --> 00:25:44,156
for that blur effect, but
also we often do these things


604
00:25:44,156 --> 00:25:46,616
offscreen so that we don't mess
up the content that's already


605
00:25:46,646 --> 00:25:48,556
on screen when we are
doing effects like this.


606
00:25:49,776 --> 00:25:50,976
So we apply the blur to it.


607
00:25:52,406 --> 00:25:54,636
And finally we copy
it back into position


608
00:25:54,636 --> 00:25:55,846
where the effect
view desired it,


609
00:25:56,836 --> 00:25:58,896
and all of this is
the definition


610
00:25:58,896 --> 00:26:00,506
of something you might
have heard before called an


611
00:26:00,506 --> 00:26:01,936
offscreen pass.


612
00:26:02,006 --> 00:26:05,456
It's whenever we take content,
we copy it into an offscreen,


613
00:26:05,876 --> 00:26:07,826
do work, and then bring
it back on screen.


614
00:26:09,326 --> 00:26:12,376
So what are some other ways that
we can get offscreen passes?


615
00:26:12,866 --> 00:26:15,266
Well, as you can see,
we have got alpha,


616
00:26:15,546 --> 00:26:17,376
and you can see the
way you do that because


617
00:26:17,376 --> 00:26:19,916
if you have a complex view
hierarchy that needs alpha


618
00:26:19,916 --> 00:26:23,286
in it, then we can't just apply
the alpha to individual views,


619
00:26:23,286 --> 00:26:24,556
because you won't get
the correct effect.


620
00:26:25,166 --> 00:26:28,186
Instead we need to take the
entire complex hierarchy


621
00:26:28,236 --> 00:26:30,806
offscreen, render it,
and then apply the alpha


622
00:26:30,806 --> 00:26:31,406
to the whole thing.


623
00:26:32,026 --> 00:26:34,346
Masking has a very similar
reasoning behind it,


624
00:26:34,346 --> 00:26:38,986
in that we need to have all
the pixels for the mask.


625
00:26:39,166 --> 00:26:42,326
As we just mentioned, blur and
vibrancy also go offscreen,


626
00:26:43,296 --> 00:26:44,926
but snapshotting,
why is that up there?


627
00:26:44,926 --> 00:26:45,806
You might ask yourself.


628
00:26:46,566 --> 00:26:48,206
Well, first off,
what is snapshotting?


629
00:26:48,506 --> 00:26:51,416
We have got these two UIView
methods, snapshot view


630
00:26:51,416 --> 00:26:53,616
after screen updates and draw
view hierarchy in rect and


631
00:26:54,166 --> 00:26:57,136
and the UIScreen method snapshot
view after screen updates,


632
00:26:57,656 --> 00:27:00,636
and these all hand you back
content from a snapshot.


633
00:27:01,306 --> 00:27:03,936
Well, a snapshot is
basically doing the same thing


634
00:27:03,936 --> 00:27:07,026
as an offscreen pass but giving
you control over the final step


635
00:27:07,026 --> 00:27:08,196
of copying it back to screen.


636
00:27:09,246 --> 00:27:11,846
We take all content that
you asked us to snapshot,


637
00:27:11,966 --> 00:27:14,346
render it offscreen, and
then hand you back a view


638
00:27:14,346 --> 00:27:17,266
or pixel content
representing that image.


639
00:27:18,656 --> 00:27:21,056
But, again, what does this
have to do with making sure


640
00:27:21,056 --> 00:27:22,856
that your effects are correct.?


641
00:27:22,856 --> 00:27:27,186
Well, unfortunately, if you get
a visual effect caught in all


642
00:27:27,186 --> 00:27:29,656
of this, as you can see,
Sophia has lost her blur.


643
00:27:30,036 --> 00:27:33,306
And that's what you will see on
screen if a visual effect ends


644
00:27:33,306 --> 00:27:34,836
up getting caught
in an offscreen


645
00:27:34,836 --> 00:27:38,866
that you didn't expect
it to go into.


646
00:27:38,866 --> 00:27:41,606
So back to motivating this,
I'm sure you have all been


647
00:27:41,606 --> 00:27:43,686
to the multitasking sessions
this year, and if not,


648
00:27:43,686 --> 00:27:45,186
you should watch them
on video afterwards.


649
00:27:45,606 --> 00:27:47,056
But one the key things
that you need


650
00:27:47,056 --> 00:27:48,616
to have a great app
participating


651
00:27:48,616 --> 00:27:51,146
in multitasking is good
performance on screen.


652
00:27:51,406 --> 00:27:52,536
Because now the performance


653
00:27:52,536 --> 00:27:54,346
of your app also affects
the other side app.


654
00:27:55,066 --> 00:27:56,866
And so, since we don't
have any scrolling


655
00:27:56,866 --> 00:27:59,576
in this particular example,
we have decided, let's instead


656
00:27:59,576 --> 00:28:01,106
of keeping the blur
rendering all the time,


657
00:28:01,106 --> 00:28:02,896
let's just take a
snapshot of it.


658
00:28:02,896 --> 00:28:04,616
And so we decided
to take a snapshot


659
00:28:04,616 --> 00:28:06,266
of that particular
visual effect view.


660
00:28:07,526 --> 00:28:10,656
But then what happens
is the capture area is


661
00:28:10,656 --> 00:28:11,666
happening offscreen.


662
00:28:12,086 --> 00:28:14,546
And since you only snapshotted
the visual effect view,


663
00:28:15,526 --> 00:28:17,216
there's nothing in
that capture area.


664
00:28:17,896 --> 00:28:19,496
And so the capture
gives you back nothing,


665
00:28:19,616 --> 00:28:20,836
and the blur has
nothing to blur,


666
00:28:21,136 --> 00:28:22,806
and you get the broken
effect you saw before.


667
00:28:23,776 --> 00:28:27,396
So, now that we have seen how
you can have your effect broken,


668
00:28:27,626 --> 00:28:28,506
what can we do to fix it?


669
00:28:29,276 --> 00:28:32,346
Well, first thing is, we
have this handy method


670
00:28:32,536 --> 00:28:35,156
on visual effect view, called,
what's wrong with this effect?


671
00:28:36,016 --> 00:28:38,016
[Laughter]


672
00:28:38,016 --> 00:28:43,000
[Applause]


673
00:28:43,396 --> 00:28:46,916
Just like with the dynamics
debugging flags this isn't


674
00:28:46,916 --> 00:28:50,136
available in the SDK as
such, but you can call it


675
00:28:50,136 --> 00:28:51,766
from in the debugger,
just like this,


676
00:28:52,446 --> 00:28:55,746
and you will get back a string
that looks kind of like this.


677
00:28:56,286 --> 00:28:58,936
In this case, we found that
there was a mask view somewhere


678
00:28:58,936 --> 00:29:01,686
up in the hierarchy that was
causing the visual effect


679
00:29:01,716 --> 00:29:04,566
to go offscreen, and thus
not capture as much content


680
00:29:04,566 --> 00:29:06,286
as it needed to,
to render properly.


681
00:29:06,846 --> 00:29:09,986
So how can you fix this?


682
00:29:10,746 --> 00:29:13,036
First way that this works,
if you are using either alpha


683
00:29:13,036 --> 00:29:15,076
or masking, is to rearrange
your view hierarchy.


684
00:29:15,076 --> 00:29:18,806
What we have here is just some
container, maybe the window,


685
00:29:19,036 --> 00:29:20,016
and a container view


686
00:29:20,016 --> 00:29:22,146
that contains a blur
and further contents.


687
00:29:22,576 --> 00:29:24,686
Well, in this case the
blur doesn't actually need


688
00:29:24,686 --> 00:29:26,736
to participate in the
alpha or masking we have,


689
00:29:27,496 --> 00:29:30,626
so we just rearrange to have
the blur as the first subview,


690
00:29:30,776 --> 00:29:33,346
the container as the second
subview, and thus the container


691
00:29:33,346 --> 00:29:35,606
and everything in it will
render on top of the blur,


692
00:29:35,906 --> 00:29:38,276
and we can apply alpha or
masking to the container view


693
00:29:38,446 --> 00:29:39,496
without messing up our blur.


694
00:29:40,936 --> 00:29:43,666
A second thing that we
can do for masking is,


695
00:29:43,956 --> 00:29:47,856
instead of masking the container
view, we can move that mask


696
00:29:48,036 --> 00:29:51,086
down into the content that
we actually need masking for.


697
00:29:51,966 --> 00:29:53,166
Now, as we mentioned before,


698
00:29:53,166 --> 00:29:55,006
masking will often
take an offscreen pass,


699
00:29:55,206 --> 00:29:56,756
so you should be very
careful about performance


700
00:29:56,756 --> 00:30:00,066
when do a transformation
like this.


701
00:30:00,656 --> 00:30:02,816
Finally, with snapshotting,
as we mentioned before,


702
00:30:02,816 --> 00:30:05,086
snapshotting is only going to
capture what you tell it to.


703
00:30:05,666 --> 00:30:07,976
So, in this case, that
content view that we are asking


704
00:30:07,976 --> 00:30:10,216
to snapshot has transparency
in it.


705
00:30:10,216 --> 00:30:11,526
So we can see things behind it.


706
00:30:11,746 --> 00:30:14,066
But if we snapshot just that
view, we aren't going to get


707
00:30:14,066 --> 00:30:15,886
that in the blur and it is
going to look a little funny.


708
00:30:16,536 --> 00:30:17,766
So if we move the snapshot up,


709
00:30:17,766 --> 00:30:20,636
all the way to the window is
usually the easiest thing to do,


710
00:30:21,206 --> 00:30:22,086
but sometimes you might need


711
00:30:22,086 --> 00:30:23,346
to move it all the
way up to the screen.


712
00:30:23,916 --> 00:30:26,066
So if you are going to snapshot
blurs, you should make sure


713
00:30:26,066 --> 00:30:28,506
that you snapshot as far
away from the blur content


714
00:30:28,506 --> 00:30:30,656
as possible so that you are
sure you get everything you need


715
00:30:30,656 --> 00:30:31,606
for it.


716
00:30:32,266 --> 00:30:36,006
And so with that, let's switch
over to some best practices


717
00:30:36,006 --> 00:30:37,386
with dynamics and AutoLayout.


718
00:30:41,016 --> 00:30:44,816
So, the first thing you might do
is you might have fairly complex


719
00:30:44,816 --> 00:30:46,846
view hierarchies working
inside of dynamics.


720
00:30:47,926 --> 00:30:50,226
And what you want is for the
outer view to participate


721
00:30:50,226 --> 00:30:52,716
in the dynamic system
but not the inner views.


722
00:30:52,766 --> 00:30:53,866
They are just going to be laid


723
00:30:53,866 --> 00:30:55,806
out like you would
with any other thing.


724
00:30:56,056 --> 00:30:59,746
So you can use UIKit
Dynamics for the outside view,


725
00:30:59,946 --> 00:31:02,536
just by turning translate
auto resizing mask


726
00:31:02,536 --> 00:31:03,936
into constraints to true.


727
00:31:04,096 --> 00:31:06,356
And, yes, in the only slide
at WWDC that says true.


728
00:31:07,586 --> 00:31:10,816
And then you can use AutoLayout


729
00:31:10,816 --> 00:31:12,586
to just position
everything else inside,


730
00:31:12,586 --> 00:31:14,756
just like you always have,
or using the new syntax


731
00:31:14,756 --> 00:31:17,226
as shown on the slide.


732
00:31:17,406 --> 00:31:20,326
Another thing you can do is,
often you will have items


733
00:31:20,326 --> 00:31:23,486
in the dynamic system but you
might have labels for them


734
00:31:23,536 --> 00:31:25,806
that shouldn't participate,
but they need to follow.


735
00:31:26,256 --> 00:31:28,516
And so Lola here
has her little tag


736
00:31:28,866 --> 00:31:31,526
that says what the file name
is, and we just have this anchor


737
00:31:31,526 --> 00:31:33,416
that represents our
AutoLayout constraints,


738
00:31:33,786 --> 00:31:36,816
and then when dynamics comes in
and wants to move Lola around,


739
00:31:37,026 --> 00:31:39,586
the label moves with it,
but the label does not end


740
00:31:39,586 --> 00:31:40,996
up interacting with dynamics.


741
00:31:42,656 --> 00:31:45,506
Finally you can work
with dynamics


742
00:31:45,536 --> 00:31:47,316
by creating a custom
dynamic item,


743
00:31:47,436 --> 00:31:48,676
just as Mike mentioned earlier.


744
00:31:49,846 --> 00:31:51,216
You just subclass NSObject


745
00:31:51,216 --> 00:31:53,576
or some other appropriate
object class,


746
00:31:55,046 --> 00:31:57,096
conform to the UI
Dynamic Item protocol


747
00:31:58,136 --> 00:31:59,756
and provide the required
methods.


748
00:32:00,666 --> 00:32:02,036
A bounds some of size --


749
00:32:02,156 --> 00:32:04,126
it can't be 00, or the
dynamic system is going


750
00:32:04,126 --> 00:32:08,246
to throw an exception -- and you
implement center and transform,


751
00:32:08,376 --> 00:32:10,826
and you use the values
of those in order


752
00:32:10,826 --> 00:32:13,016
to construct AutoLayout
constraints


753
00:32:13,226 --> 00:32:15,326
or otherwise change something
outside of your system.


754
00:32:16,466 --> 00:32:20,216
And so to close out, we are
going to show you a demo


755
00:32:20,736 --> 00:32:25,436
of how you can do just that.


756
00:32:25,806 --> 00:32:29,786
So what we have got here, is,
again, a simple application


757
00:32:30,266 --> 00:32:31,666
that just shows a photo.


758
00:32:31,666 --> 00:32:34,116
But we want to be able to
show the user the faces


759
00:32:34,116 --> 00:32:35,776
in the photo with some style.


760
00:32:36,056 --> 00:32:40,076
And so when we click our dynamic
item system stretches out


761
00:32:40,076 --> 00:32:41,386
and animates in that blur.


762
00:32:42,126 --> 00:32:43,896
And if you click again,
of course, it will move


763
00:32:43,896 --> 00:32:45,446
out with a nice little effect.


764
00:32:46,426 --> 00:32:49,106
But if you keep clicking,
then you can see


765
00:32:49,106 --> 00:32:51,636
that it responds very
fluidly to the dynamic system


766
00:32:52,146 --> 00:32:54,746
and doesn't have
very set, rigid path.


767
00:32:55,466 --> 00:32:58,886
So it's very reactive to
exactly what the user is doing.


768
00:32:59,726 --> 00:33:01,066
So how do we get that to work?


769
00:33:01,966 --> 00:33:05,496
So, the first thing we do is
we have this face layout guide,


770
00:33:06,006 --> 00:33:07,996
and that's just a subclass
of UI layout guide,


771
00:33:08,296 --> 00:33:11,396
and inside of it is a
little bit of dynamics.


772
00:33:11,836 --> 00:33:14,626
We have this face layout guide
dynamic item, that, again,


773
00:33:14,626 --> 00:33:17,436
subclass as NSObject and
conforms to UI Dynamic Item,


774
00:33:18,256 --> 00:33:19,896
and it's going to
manage a constraint,


775
00:33:20,306 --> 00:33:24,116
and by setting the constant of
that constraint to either the x


776
00:33:24,116 --> 00:33:27,396
or y value of the center
point, whenever that changes.


777
00:33:27,916 --> 00:33:33,676
And then in here, when you
set up the layout guide,


778
00:33:34,016 --> 00:33:35,586
it's got a centerrable position


779
00:33:35,836 --> 00:33:38,376
and it creates four
additional dynamic items


780
00:33:38,646 --> 00:33:40,416
that represent the
top, left, bottom,


781
00:33:40,416 --> 00:33:41,956
and right in that system.


782
00:33:43,146 --> 00:33:45,256
We assign it the constraints
and the constraints just work


783
00:33:45,336 --> 00:33:47,856
from the top left corner
of the dynamic item,


784
00:33:48,496 --> 00:33:50,586
of the dynamic item
reference view,


785
00:33:51,576 --> 00:33:54,146
and we use slider
attachments to limit


786
00:33:54,146 --> 00:33:56,186
where those four
dynamic items can go


787
00:33:56,186 --> 00:33:57,226
with respect to the position.


788
00:33:57,626 --> 00:34:00,036
And this keeps it from
flying outside of the system


789
00:34:00,036 --> 00:34:01,986
or collapsing to too
small of a position.


790
00:34:01,986 --> 00:34:05,096
Now, in the view controller,


791
00:34:05,096 --> 00:34:08,065
the way we get this behavior is
we have a gravity behavior along


792
00:34:08,065 --> 00:34:09,096
with the face layout guide,


793
00:34:09,406 --> 00:34:10,896
and we center them
on top of each other.


794
00:34:10,896 --> 00:34:12,406
So when the gravity changes,


795
00:34:12,406 --> 00:34:13,966
the layout guide will
move appropriately,


796
00:34:15,176 --> 00:34:17,156
and we get the blur
effect from our storyboard,


797
00:34:17,156 --> 00:34:18,866
so that we don't have to
constantly twiddle with it


798
00:34:18,866 --> 00:34:21,196
if we decide we want to
change the style we are using.


799
00:34:21,766 --> 00:34:26,085
And we use constraints
to attach that blur view


800
00:34:26,356 --> 00:34:27,576
to the face layout guide.


801
00:34:27,886 --> 00:34:29,795
So that when that
guide changes size,


802
00:34:29,886 --> 00:34:31,545
the blur view will
also change with it.


803
00:34:33,005 --> 00:34:35,916
Now, in order to make it look
like the blur view is cutting


804
00:34:35,916 --> 00:34:38,416
out everything but the faces,
we actually have a little trick.


805
00:34:38,666 --> 00:34:40,815
We make imposters from
the original image,


806
00:34:40,976 --> 00:34:44,295
just cut out the images that
we want, apply a mask to them,


807
00:34:44,606 --> 00:34:47,815
and create additional UI
Image Views to place on top


808
00:34:47,815 --> 00:34:48,806
of the one that's already there.


809
00:34:49,456 --> 00:34:52,156
And so it looks like the blur
is just dodging the faces


810
00:34:52,156 --> 00:34:54,246
but what is actually happening
is you're seeing the views


811
00:34:54,246 --> 00:34:58,306
that were placed on top that
have the faces cut out on them.


812
00:34:58,496 --> 00:35:01,176
Finally, we have this tap
gesture recognizer that we set,


813
00:35:01,176 --> 00:35:02,336
and it will be the thing


814
00:35:02,336 --> 00:35:04,446
that causes our dynamic
system to change.


815
00:35:04,936 --> 00:35:08,036
When we want to expose
the faces,


816
00:35:08,506 --> 00:35:09,506
we just change the gravity.


817
00:35:09,916 --> 00:35:12,126
So normally the gravity is
causing everything to be pulled


818
00:35:12,126 --> 00:35:14,346
into the center, but
then when we flip it,


819
00:35:14,346 --> 00:35:16,646
it wants to push everything
out like a repulsor.


820
00:35:17,966 --> 00:35:19,696
And then we take
advantage of the fact


821
00:35:19,696 --> 00:35:21,826
that we are always laying
out subviews during this,


822
00:35:22,206 --> 00:35:24,766
to actually trigger the
blur animation in or out.


823
00:35:25,696 --> 00:35:29,066
And that's all it takes in order
to build this really nice effect


824
00:35:29,416 --> 00:35:31,316
from something that
both autolayout


825
00:35:31,316 --> 00:35:33,256
and dynamics can both
provide easily for you.


826
00:35:33,256 --> 00:35:38,666
And so we will go back
to slides to finish out.


827
00:35:39,466 --> 00:35:43,376
So in summary, we want you
to use these technologies


828
00:35:43,376 --> 00:35:45,256
to really improve
the user experience.


829
00:35:45,506 --> 00:35:48,036
So when you add a
blur, you add it


830
00:35:48,036 --> 00:35:50,966
so that you can put
additional information offset


831
00:35:51,026 --> 00:35:51,856
from your content.


832
00:35:52,346 --> 00:35:53,666
When you use dynamics, it's


833
00:35:53,666 --> 00:35:57,056
so that you can have a user
interface that responds nicely


834
00:35:57,056 --> 00:35:59,126
and as the user expects
to their input.


835
00:36:00,016 --> 00:36:01,606
But you also want to
consider performance


836
00:36:01,606 --> 00:36:02,596
when you are doing these things.


837
00:36:03,026 --> 00:36:05,366
Because if you have a lot
of dynamic items on screen,


838
00:36:05,536 --> 00:36:07,406
that can really bog
down the user interface,


839
00:36:07,866 --> 00:36:10,196
and you don't get the nice
physics that you were expecting.


840
00:36:10,536 --> 00:36:11,876
So use it with caution.


841
00:36:12,306 --> 00:36:15,536
But also for visual effects,
if you have a lot of them,


842
00:36:15,536 --> 00:36:17,426
you will end up with
lots of offscreen passes


843
00:36:17,756 --> 00:36:19,436
and that can incur
quite a cost as well.


844
00:36:21,456 --> 00:36:23,156
So these are all
the related sessions


845
00:36:23,156 --> 00:36:24,186
that we have got for you today.


846
00:36:24,186 --> 00:36:26,856
Unfortunately most of
them have occurred before.


847
00:36:26,856 --> 00:36:29,566
There's only one that hasn't
and that's occurring with us,


848
00:36:29,566 --> 00:36:31,366
called "Building Responsive
and Efficient Apps with GCD."


849
00:36:31,366 --> 00:36:34,996
And we will be in the lab
after this to take all


850
00:36:34,996 --> 00:36:37,106
of your questions and
help you get the most


851
00:36:37,106 --> 00:36:38,616
out of what you have
got for this year.


852
00:36:39,176 --> 00:36:43,646
We have got various
documentation, and assemble code


853
00:36:43,646 --> 00:36:45,416
for the StickyCorners
sample that you saw earlier


854
00:36:45,416 --> 00:36:48,346
in the presentation should be up
and available, and, of course,


855
00:36:48,346 --> 00:36:50,596
Curt Rothert to take your
questions through email.


856
00:36:51,106 --> 00:36:53,566
And I'm glad you stuck
with us on Friday.


857
00:36:53,886 --> 00:36:56,486
I hope you had a great
WWDC and a safe trip home.


858
00:36:57,016 --> 00:36:59,000
[Applause]

