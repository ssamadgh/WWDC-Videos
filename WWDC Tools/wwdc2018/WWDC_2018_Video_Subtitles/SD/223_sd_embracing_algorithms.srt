1
00:00:07,516 --> 00:00:15,500
[ Music ]


2
00:00:17,516 --> 00:00:23,056
[ Applause ]


3
00:00:23,556 --> 00:00:24,156
>> Hi, everybody.


4
00:00:24,876 --> 00:00:26,136
It's great to see you all here


5
00:00:26,136 --> 00:00:26,446
today.


6
00:00:27,306 --> 00:00:29,676
I'm Dave, and the next 40


7
00:00:29,676 --> 00:00:32,436
minutes are about understanding


8
00:00:32,485 --> 00:00:33,996
and honoring what makes our


9
00:00:34,036 --> 00:00:35,716
programs actually work.


10
00:00:36,766 --> 00:00:38,286
There will be practical advice,


11
00:00:38,636 --> 00:00:40,986
but this is not a talk about


12
00:00:41,056 --> 00:00:43,116
tips and techniques or any


13
00:00:43,116 --> 00:00:44,876
specific algorithms even, though


14
00:00:44,876 --> 00:00:45,816
we will look at a few.


15
00:00:47,026 --> 00:00:49,156
It's about revealing something


16
00:00:49,296 --> 00:00:50,956
fundamental, the potential of


17
00:00:51,036 --> 00:00:53,076
which is already present in your


18
00:00:53,906 --> 00:00:54,006
code.


19
00:00:54,936 --> 00:00:57,216
I hope that for at least a few


20
00:00:57,216 --> 00:00:58,796
of you it marks the beginning of


21
00:00:58,796 --> 00:01:00,056
a new relationship to the


22
00:01:00,056 --> 00:01:01,056
practice of programming.


23
00:01:02,236 --> 00:01:03,446
Speaking personally, when I


24
00:01:03,446 --> 00:01:05,116
discovered this approach, it


25
00:01:05,116 --> 00:01:06,446
changed the course of my life


26
00:01:06,756 --> 00:01:07,486
and my career.


27
00:01:08,446 --> 00:01:09,926
It's the reason I care so much


28
00:01:09,926 --> 00:01:11,966
about software libraries, but


29
00:01:11,966 --> 00:01:13,786
it's also the source of the


30
00:01:13,786 --> 00:01:15,866
liability, maintainability, and


31
00:01:15,866 --> 00:01:17,976
performance in every piece of


32
00:01:17,976 --> 00:01:19,016
concrete code I've written


33
00:01:19,016 --> 00:01:19,436
since.


34
00:01:20,836 --> 00:01:22,876
But before we get into that, let


35
00:01:22,876 --> 00:01:24,226
me introduce you to a friend of


36
00:01:24,226 --> 00:01:24,396
mine.


37
00:01:26,776 --> 00:01:27,506
This is Crusty.


38
00:01:28,516 --> 00:01:31,616
[ Applause ]


39
00:01:32,116 --> 00:01:34,006
Crusty is old school.


40
00:01:34,896 --> 00:01:37,026
He doesn't trust debuggers or or


41
00:01:37,026 --> 00:01:38,786
mess around with integrated


42
00:01:38,786 --> 00:01:40,016
development environments.


43
00:01:40,806 --> 00:01:43,246
No, he favors an 80 x 24


44
00:01:43,246 --> 00:01:45,436
terminal window in plain text,


45
00:01:45,506 --> 00:01:46,246
thank you very much.


46
00:01:47,516 --> 00:01:49,566
Now, Crusty takes a dim view of


47
00:01:49,566 --> 00:01:51,916
the latest programming fads, so


48
00:01:51,916 --> 00:01:53,476
it can sometimes be an effort to


49
00:01:53,476 --> 00:01:55,166
drag him into the 21st century.


50
00:01:56,126 --> 00:01:57,636
He just thinks different.


51
00:01:58,656 --> 00:02:00,866
But if you listen carefully, you


52
00:02:00,866 --> 00:02:03,336
can learn a thing or two.


53
00:02:03,576 --> 00:02:05,356
Now, sometimes his cryptic


54
00:02:05,356 --> 00:02:07,666
pronouncements like "programming


55
00:02:07,666 --> 00:02:10,156
reveals the real; border on the


56
00:02:10,156 --> 00:02:10,675
mystical."


57
00:02:11,416 --> 00:02:13,576
And to understand him, I found


58
00:02:13,576 --> 00:02:15,096
it helpful to actually write


59
00:02:15,096 --> 00:02:16,286
some code.


60
00:02:17,526 --> 00:02:18,796
So, lately, I've been working on


61
00:02:18,796 --> 00:02:20,586
a little program called Shapes.


62
00:02:21,656 --> 00:02:22,906
I'm hoping to make it into a


63
00:02:22,906 --> 00:02:24,216
full-featured vector drawing


64
00:02:24,216 --> 00:02:26,876
program, but so far it lets you


65
00:02:26,876 --> 00:02:28,336
arrange shapes on an infinite


66
00:02:28,336 --> 00:02:28,836
canvas.


67
00:02:30,416 --> 00:02:31,376
Now, I want to tell you the


68
00:02:31,376 --> 00:02:33,226
story of the delete selection


69
00:02:33,226 --> 00:02:35,526
command because I learned so


70
00:02:35,526 --> 00:02:37,826
much from implementing this one


71
00:02:37,826 --> 00:02:38,266
feature.


72
00:02:39,596 --> 00:02:41,216
I think we've probably all gone


73
00:02:41,216 --> 00:02:43,426
through part of this progression


74
00:02:43,426 --> 00:02:45,436
as programmers as we learn how


75
00:02:45,436 --> 00:02:46,856
to remove things from an array.


76
00:02:47,816 --> 00:02:49,106
Everybody starts out doing


77
00:02:49,106 --> 00:02:51,000
something like this.


78
00:02:53,596 --> 00:02:55,006
That's the delete selection


79
00:02:56,836 --> 00:02:57,026
command.


80
00:02:58,656 --> 00:03:02,316
We loop from 0 to count, and


81
00:03:02,316 --> 00:03:03,326
when we find something to


82
00:03:03,326 --> 00:03:05,126
delete, we [inaudible] remove


83
00:03:05,126 --> 00:03:07,546
that, and then we continue with


84
00:03:07,546 --> 00:03:11,266
our loop until, ouch, we walk


85
00:03:11,266 --> 00:03:11,846
off the end.


86
00:03:13,366 --> 00:03:14,906
The array got shorter, but we


87
00:03:14,906 --> 00:03:16,256
picked the number of iterations


88
00:03:16,256 --> 00:03:17,166
when the loop started.


89
00:03:17,876 --> 00:03:19,196
Fortunately, you can't miss this


90
00:03:19,246 --> 00:03:20,796
bug if you Swift and test your


91
00:03:20,826 --> 00:03:23,436
code because it'll trap.


92
00:03:23,946 --> 00:03:25,226
But if you had to learn this


93
00:03:25,266 --> 00:03:26,996
lesson as a C-programmer, like I


94
00:03:26,996 --> 00:03:28,966
did, you might not be so lucky.


95
00:03:29,926 --> 00:03:30,256
Okay.


96
00:03:30,626 --> 00:03:32,796
So, we can fix it by replacing


97
00:03:32,796 --> 00:03:34,096
the for loop with a somewhat


98
00:03:34,096 --> 00:03:36,346
uglier while loop, which lets us


99
00:03:36,346 --> 00:03:37,516
examine the count at each


100
00:03:37,516 --> 00:03:38,096
iteration.


101
00:03:38,646 --> 00:03:42,156
But there's a subtle bug in this


102
00:03:42,156 --> 00:03:42,736
one too.


103
00:03:43,956 --> 00:03:46,056
If two consecutive elements are


104
00:03:46,056 --> 00:03:48,706
selected, it'll remove the first


105
00:03:48,706 --> 00:03:51,916
one and then immediately hop


106
00:03:51,916 --> 00:03:54,256
over the next one.


107
00:03:54,466 --> 00:03:56,956
Now, this bug is a little more


108
00:03:56,956 --> 00:03:58,496
insidious because it hides from


109
00:03:58,496 --> 00:04:00,286
you unless your tests happen to


110
00:04:00,286 --> 00:04:02,716
exercise it.


111
00:04:02,946 --> 00:04:04,416
But if we're lucky enough to


112
00:04:04,416 --> 00:04:06,496
notice it, we press ahead and we


113
00:04:06,496 --> 00:04:08,826
fix the implementation again by


114
00:04:08,826 --> 00:04:10,026
guarding the increment in an


115
00:04:10,026 --> 00:04:10,586
else block.


116
00:04:11,226 --> 00:04:13,596
So, are we done now?


117
00:04:13,596 --> 00:04:16,476
Are we sure this one is correct?


118
00:04:17,706 --> 00:04:19,906
I think I can prove to myself


119
00:04:19,995 --> 00:04:20,755
that it works.


120
00:04:21,875 --> 00:04:24,106
Anyway, having gone through this


121
00:04:24,106 --> 00:04:25,356
ordeal, what do we do?


122
00:04:25,746 --> 00:04:27,336
Well, of course, we lock this


123
00:04:27,336 --> 00:04:28,696
nine-line pattern into our


124
00:04:28,696 --> 00:04:30,506
brains so we can trot it out


125
00:04:30,506 --> 00:04:32,056
whenever we have to delete


126
00:04:32,056 --> 00:04:32,456
something.


127
00:04:33,026 --> 00:04:35,666
Now, I'm sure many of you have


128
00:04:35,666 --> 00:04:36,676
been holding yourselves back


129
00:04:36,676 --> 00:04:38,566
from screaming at me because


130
00:04:38,656 --> 00:04:40,506
that there's a much more elegant


131
00:04:40,506 --> 00:04:41,906
way to do it.


132
00:04:41,906 --> 00:04:43,206
I still remember the day I


133
00:04:43,206 --> 00:04:44,686
discovered this trick for myself


134
00:04:45,106 --> 00:04:46,666
because once you find it, you


135
00:04:46,666 --> 00:04:48,126
never do this nine-line dance


136
00:04:48,126 --> 00:04:48,456
again.


137
00:04:49,406 --> 00:04:51,496
The iteration limit and the


138
00:04:51,556 --> 00:04:52,786
index of the next item to


139
00:04:52,786 --> 00:04:54,956
examine kept shifting under our


140
00:04:54,956 --> 00:04:56,866
feet because remove(at: i)


141
00:04:57,746 --> 00:04:59,426
changes parts of the array after


142
00:04:59,426 --> 00:04:59,696
i.


143
00:05:00,766 --> 00:05:06,266
But if you go backwards, you


144
00:05:06,266 --> 00:05:07,526
only iterate over the parts of


145
00:05:07,526 --> 00:05:08,376
the array that you haven't


146
00:05:08,376 --> 00:05:08,896
changed yet.


147
00:05:10,056 --> 00:05:10,776
Slick, right?


148
00:05:11,456 --> 00:05:12,556
And this is the pattern I've


149
00:05:12,606 --> 00:05:14,916
used ever since because it's


150
00:05:14,946 --> 00:05:19,476
clean, and it never fails, until


151
00:05:20,086 --> 00:05:21,736
a few months ago.


152
00:05:21,736 --> 00:05:24,056
One morning, I had just finished


153
00:05:24,056 --> 00:05:26,216
my avocado toast, and I was idly


154
00:05:26,306 --> 00:05:28,376
fooling with my app when I tried


155
00:05:28,376 --> 00:05:29,986
deleting about half the shapes


156
00:05:29,986 --> 00:05:31,216
from a really complicated


157
00:05:31,216 --> 00:05:31,686
canvas.


158
00:05:33,016 --> 00:05:35,166
My iPad, it froze up for like


159
00:05:35,526 --> 00:05:36,206
three seconds.


160
00:05:36,886 --> 00:05:40,586
So, I took a sip of my half caf


161
00:05:40,626 --> 00:05:42,746
triple shot latte in its bamboo


162
00:05:43,156 --> 00:05:44,716
thermal commuter cup, and I


163
00:05:44,716 --> 00:05:45,936
considered my options.


164
00:05:47,656 --> 00:05:48,526
This was disturbing.


165
00:05:49,136 --> 00:05:50,006
I mean, it's a pretty


166
00:05:50,006 --> 00:05:51,716
straightforward operation, and


167
00:05:51,716 --> 00:05:53,686
my code was so clean, how could


168
00:05:53,686 --> 00:05:54,286
it be wrong?


169
00:05:56,176 --> 00:05:58,256
Profiling showed me that the hot


170
00:05:58,256 --> 00:06:01,156
spot was right here, but beyond


171
00:06:01,156 --> 00:06:02,056
that, I was stumped.


172
00:06:02,706 --> 00:06:05,636
So, just about then, Crusty


173
00:06:05,636 --> 00:06:07,076
walked up behind me carrying a


174
00:06:07,076 --> 00:06:09,416
can of off-brand coffee grounds


175
00:06:09,416 --> 00:06:10,796
from the local supermarket for


176
00:06:10,796 --> 00:06:11,546
his daily brew.


177
00:06:12,936 --> 00:06:15,876
"Stuck?" he said.


178
00:06:16,086 --> 00:06:18,016
"Yeah," I sighed, and I


179
00:06:18,016 --> 00:06:19,216
explained the situation.


180
00:06:19,706 --> 00:06:24,556
"Well, did you even look at the


181
00:06:24,556 --> 00:06:25,796
documentation for that?"


182
00:06:27,826 --> 00:06:29,916
Well, I hadn't, so I popped up


183
00:06:29,916 --> 00:06:31,516
the Quick Help for Remove At,


184
00:06:31,806 --> 00:06:33,526
and Crusty leaned in.


185
00:06:34,316 --> 00:06:35,856
"There's your problem, right


186
00:06:35,856 --> 00:06:38,986
there," he said, leaving a


187
00:06:38,986 --> 00:06:40,506
smudge on my gorgeous retina


188
00:06:40,506 --> 00:06:41,036
display.


189
00:06:42,906 --> 00:06:45,506
Now, I carefully wiped off the


190
00:06:45,546 --> 00:06:47,216
fingerprint with a handcrafted


191
00:06:47,216 --> 00:06:50,596
Italian microfiber cloth, and


192
00:06:50,596 --> 00:06:53,386
Crusty said, "What's that tell


193
00:06:53,996 --> 00:06:54,856
you, son?"


194
00:06:55,096 --> 00:06:57,516
"Well," I said, "it means that


195
00:06:57,596 --> 00:06:59,056
removing an element takes a


196
00:06:59,056 --> 00:07:01,216
number of steps proportional to


197
00:07:01,216 --> 00:07:02,476
the length of the array."


198
00:07:02,476 --> 00:07:04,456
And it kind of makes sense,


199
00:07:04,456 --> 00:07:06,686
since the array has to slide all


200
00:07:06,686 --> 00:07:08,316
of the following elements into


201
00:07:08,316 --> 00:07:09,186
their new positions.


202
00:07:10,996 --> 00:07:12,466
"So, what's that mean about your


203
00:07:12,466 --> 00:07:13,806
Delete Selection command?"


204
00:07:14,596 --> 00:07:14,996
he asked.


205
00:07:16,166 --> 00:07:17,646
"Uh," I said.


206
00:07:18,186 --> 00:07:21,606
That's when he pulled out a pack


207
00:07:21,606 --> 00:07:22,976
of mentholated lozenges and


208
00:07:22,976 --> 00:07:24,086
lined them up on my desk.


209
00:07:24,756 --> 00:07:25,596
"Try it yourself."


210
00:07:27,246 --> 00:07:29,216
So, I went through the process


211
00:07:29,216 --> 00:07:30,226
as I tried to answer his


212
00:07:30,226 --> 00:07:30,656
question.


213
00:07:30,896 --> 00:07:32,096
"Well, since Delete Selection


214
00:07:32,096 --> 00:07:34,116
has to do order n steps, once


215
00:07:34,116 --> 00:07:35,486
for each selected element, and


216
00:07:35,486 --> 00:07:36,996
you can select up to n elements,


217
00:07:37,276 --> 00:07:38,396
the total number of steps is


218
00:07:38,396 --> 00:07:40,906
proportional to n squared."


219
00:07:42,276 --> 00:07:44,356
Crusty added, "That's quadratic,


220
00:07:44,356 --> 00:07:46,296
son, whether you do it the ugly


221
00:07:46,296 --> 00:07:48,186
forward way or the fancy pants


222
00:07:48,186 --> 00:07:50,346
backward way."


223
00:07:50,976 --> 00:07:54,106
I realized then that for my


224
00:07:54,106 --> 00:07:56,036
little 10 to 20-element test


225
00:07:56,036 --> 00:07:58,006
cases, we'd only been talking


226
00:07:58,006 --> 00:08:00,376
about a few hundred steps, and


227
00:08:00,376 --> 00:08:01,936
since the steps are pretty fast,


228
00:08:02,046 --> 00:08:02,876
it seemed great.


229
00:08:04,116 --> 00:08:05,396
But the problem is that it


230
00:08:05,396 --> 00:08:06,296
doesn't scale well.


231
00:08:06,796 --> 00:08:10,576
Fifty squared is 2,500 and 100


232
00:08:10,576 --> 00:08:11,986
squared is 10,000.


233
00:08:12,546 --> 00:08:15,326
So, if you do all your testing


234
00:08:15,326 --> 00:08:17,186
in this little region down here,


235
00:08:17,476 --> 00:08:18,766
you'll probably never see it,


236
00:08:19,336 --> 00:08:21,746
but scalability matters because


237
00:08:21,746 --> 00:08:23,336
people are using their phones


238
00:08:23,336 --> 00:08:25,626
and iPads to manage more and


239
00:08:25,626 --> 00:08:27,376
more data, and we keep shipping


240
00:08:27,376 --> 00:08:29,096
devices with more memory to help


241
00:08:29,096 --> 00:08:29,586
them do it.


242
00:08:30,606 --> 00:08:32,346
You care about this because


243
00:08:32,346 --> 00:08:34,476
scalability is predictability


244
00:08:34,476 --> 00:08:35,296
for your users.


245
00:08:35,826 --> 00:08:39,946
So, now, I understood the


246
00:08:39,946 --> 00:08:41,986
problem, but I still wasn't sure


247
00:08:41,986 --> 00:08:42,746
what to do about it.


248
00:08:43,326 --> 00:08:43,706
"Now what?"


249
00:08:43,706 --> 00:08:44,446
I asked Crusty.


250
00:08:45,526 --> 00:08:47,056
"You know, kid," he said,


251
00:08:47,496 --> 00:08:49,776
popping a lozenge, "there is an


252
00:08:49,776 --> 00:08:51,466
algorithm for that."


253
00:08:53,056 --> 00:08:56,236
I told him, "Listen, Crusty, I'm


254
00:08:56,236 --> 00:08:57,176
an app developer.


255
00:08:58,226 --> 00:09:00,176
You say you don't do object


256
00:09:00,176 --> 00:09:00,716
oriented.


257
00:09:00,716 --> 00:09:02,646
Well, I don't 'do' algorithms."


258
00:09:03,276 --> 00:09:04,406
You pay attention to your data


259
00:09:04,406 --> 00:09:06,066
structures in algorithms class


260
00:09:06,396 --> 00:09:08,036
because you know when it's time


261
00:09:08,036 --> 00:09:09,806
to get a job, your interviewer


262
00:09:09,806 --> 00:09:10,946
is going to ask you about them.


263
00:09:11,346 --> 00:09:12,776
But in the real programming


264
00:09:12,776 --> 00:09:14,766
world, what separates the elite


265
00:09:14,926 --> 00:09:16,946
from the newbies is the ability


266
00:09:16,946 --> 00:09:18,396
to wire together controllers,


267
00:09:18,396 --> 00:09:19,766
delegates, and responders to


268
00:09:19,766 --> 00:09:22,546
build a working system.


269
00:09:22,996 --> 00:09:24,906
"Bonkey," he said; I don't know


270
00:09:24,906 --> 00:09:27,276
why he calls me that, "What do


271
00:09:27,506 --> 00:09:28,656
computers do?"


272
00:09:30,096 --> 00:09:30,816
"They compute."


273
00:09:31,796 --> 00:09:33,086
"Now, where's the computation in


274
00:09:33,086 --> 00:09:34,286
all that?"


275
00:09:35,356 --> 00:09:37,966
"Well," I replied, "I guess I


276
00:09:37,966 --> 00:09:39,106
don't see anything that looks


277
00:09:39,106 --> 00:09:40,496
like an algorithm in my code."


278
00:09:41,046 --> 00:09:43,296
But Crusty wasn't having it.


279
00:09:43,806 --> 00:09:45,106
"Oh, your app is full of them,"


280
00:09:45,106 --> 00:09:46,646
he said, dropping an old dead


281
00:09:46,646 --> 00:09:47,956
tree dictionary on my desk,


282
00:09:48,526 --> 00:09:50,496
"Look it up."


283
00:09:51,266 --> 00:09:54,066
After I gathered my composure, I


284
00:09:54,066 --> 00:09:55,396
carefully slid the book to one


285
00:09:55,396 --> 00:09:57,226
side and typed Define Algorithm


286
00:09:57,226 --> 00:09:58,886
into Spotlight, which Crusty


287
00:09:58,886 --> 00:10:00,000
thought was a neat trick.


288
00:10:03,976 --> 00:10:04,976
Hmm.


289
00:10:05,046 --> 00:10:06,876
A process or set of rules to be


290
00:10:06,876 --> 00:10:08,656
followed in calculations or


291
00:10:08,656 --> 00:10:09,806
other problem solving


292
00:10:09,806 --> 00:10:10,416
operations.


293
00:10:11,756 --> 00:10:13,356
Well, come to think of it, that


294
00:10:13,806 --> 00:10:16,016
did sound like most code, but I


295
00:10:16,016 --> 00:10:16,906
still wasn't sure.


296
00:10:18,036 --> 00:10:19,446
"You ever do a long division?"


297
00:10:19,596 --> 00:10:20,236
asked Crusty.


298
00:10:20,646 --> 00:10:21,576
"That's an algorithm."


299
00:10:25,766 --> 00:10:27,606
I started to type into Spotlight


300
00:10:27,606 --> 00:10:29,266
again, but he snapped, "On


301
00:10:29,266 --> 00:10:29,646
paper."


302
00:10:30,306 --> 00:10:31,616
And not wanting to embarrass


303
00:10:31,616 --> 00:10:32,746
myself, I turned the subject


304
00:10:32,746 --> 00:10:33,476
back to my code.


305
00:10:35,316 --> 00:10:35,386
"Hmm."


306
00:10:36,256 --> 00:10:39,926
I asked, "So, what is this magic


307
00:10:39,926 --> 00:10:41,666
algorithm that will cure my


308
00:10:41,666 --> 00:10:42,856
performance problem?"


309
00:10:44,126 --> 00:10:45,496
"Well, if you'll just let me at


310
00:10:45,496 --> 00:10:46,976
your TTY there for a minute," he


311
00:10:46,976 --> 00:10:48,446
said, "How do you work this


312
00:10:48,446 --> 00:10:48,626
thing?


313
00:10:48,626 --> 00:10:49,816
Oh, it's a track pad.


314
00:10:49,816 --> 00:10:50,826
I'll try not to touch that.


315
00:10:51,226 --> 00:10:53,356
So, first, you do away with this


316
00:10:53,356 --> 00:10:54,330
foolishness.


317
00:10:57,046 --> 00:11:00,676
Now, shapes.removeallwhere the


318
00:11:00,676 --> 00:11:02,186
shape is selected.


319
00:11:03,146 --> 00:11:03,326
Hmm.


320
00:11:04,026 --> 00:11:05,236
Try that on for size."


321
00:11:06,216 --> 00:11:07,756
Now, Crusty headed off to wash


322
00:11:07,756 --> 00:11:08,856
out the pitcher of his coffee


323
00:11:08,856 --> 00:11:11,066
maker, leaving me to figure out


324
00:11:11,066 --> 00:11:12,816
what had just happened in my


325
00:11:13,666 --> 00:11:13,766
code.


326
00:11:14,736 --> 00:11:17,756
First, I checked, and I found


327
00:11:17,756 --> 00:11:18,936
that the performance problem was


328
00:11:18,996 --> 00:11:19,286
fixed.


329
00:11:19,856 --> 00:11:20,226
Nice.


330
00:11:21,536 --> 00:11:22,886
And I didn't want another earful


331
00:11:22,886 --> 00:11:24,226
from Crusty about looking at the


332
00:11:24,226 --> 00:11:26,626
documentation, so I popped up


333
00:11:26,626 --> 00:11:28,126
Quick Help for removeAll(where:


334
00:11:28,676 --> 00:11:32,856
and I saw that its complexity


335
00:11:32,856 --> 00:11:34,266
scales proportionally to the


336
00:11:34,266 --> 00:11:36,176
length of the collection just


337
00:11:36,176 --> 00:11:36,806
like removeAt.


338
00:11:37,796 --> 00:11:39,656
But since I didn't have to put


339
00:11:39,656 --> 00:11:41,576
it in a loop, that became the


340
00:11:41,576 --> 00:11:42,836
complexity of my whole


341
00:11:42,836 --> 00:11:43,376
operation.


342
00:11:44,576 --> 00:11:46,776
Now, I want to give you some


343
00:11:46,776 --> 00:11:48,026
intuition for the kind of


344
00:11:48,106 --> 00:11:50,106
difference this makes.


345
00:11:50,566 --> 00:11:52,476
What are n means that the time


346
00:11:52,476 --> 00:11:54,216
the algorithm runs scales


347
00:11:54,566 --> 00:11:56,166
linearly with the problem size.


348
00:11:56,696 --> 00:11:57,936
The graph is a straight line.


349
00:11:59,396 --> 00:12:00,826
Now, the orange line is the


350
00:12:00,826 --> 00:12:02,076
shape of order n squared.


351
00:12:03,356 --> 00:12:04,846
As you can see, a linear


352
00:12:04,846 --> 00:12:06,406
algorithm may do worse on a


353
00:12:06,406 --> 00:12:07,956
small problem, but it's


354
00:12:07,956 --> 00:12:09,596
eventually faster than a


355
00:12:09,596 --> 00:12:10,606
quadratic algorithm.


356
00:12:11,926 --> 00:12:13,716
The cool thing is though, it


357
00:12:13,716 --> 00:12:15,546
doesn't matter how expensive you


358
00:12:15,546 --> 00:12:16,856
make the steps of the linear


359
00:12:16,856 --> 00:12:19,226
algorithm, if you keep looking


360
00:12:19,226 --> 00:12:22,456
at larger problem sizes, you'll


361
00:12:22,566 --> 00:12:24,736
always find one where the linear


362
00:12:24,736 --> 00:12:27,206
algorithm wins and continues to


363
00:12:27,206 --> 00:12:28,206
win forever.


364
00:12:29,346 --> 00:12:30,506
So, we're talking about


365
00:12:30,506 --> 00:12:32,356
scalability, not absolute


366
00:12:32,406 --> 00:12:33,000
performance.


367
00:12:36,436 --> 00:12:40,346
Well, my scalability problem was


368
00:12:40,346 --> 00:12:42,316
fixed, but I really wanted to


369
00:12:42,316 --> 00:12:44,196
see how the standard library had


370
00:12:44,196 --> 00:12:46,256
improved on my backward deletion


371
00:12:46,256 --> 00:12:46,616
scheme.


372
00:12:47,886 --> 00:12:49,586
Crusty reminded me that Swift is


373
00:12:49,586 --> 00:12:50,986
open source, so I could pull it


374
00:12:50,986 --> 00:12:53,006
up on what he calls "the hipster


375
00:12:53,006 --> 00:12:53,426
web."


376
00:12:53,816 --> 00:12:54,786
But the rest of us know as


377
00:12:54,786 --> 00:12:55,500
GitHub.


378
00:12:59,266 --> 00:13:00,776
Now, the first thing I noticed


379
00:13:00,776 --> 00:13:03,106
was the dot comment, which was


380
00:13:03,136 --> 00:13:04,456
the source of all that Quick


381
00:13:04,456 --> 00:13:06,636
Help, describing both what the


382
00:13:06,636 --> 00:13:08,556
algorithm does and its


383
00:13:08,556 --> 00:13:09,136
complexity.


384
00:13:09,596 --> 00:13:14,046
Next, it turns out that


385
00:13:14,046 --> 00:13:15,946
removeAll(where) isn't just some


386
00:13:15,946 --> 00:13:18,486
method on a reg; it's a generic


387
00:13:18,486 --> 00:13:20,466
algorithm, which means that it


388
00:13:20,466 --> 00:13:22,126
works on a wide variety of


389
00:13:22,126 --> 00:13:22,926
different collections.


390
00:13:24,286 --> 00:13:25,296
It depends on a couple of


391
00:13:25,296 --> 00:13:28,376
things, the ability to rearrange


392
00:13:28,376 --> 00:13:29,556
elements, which comes from


393
00:13:29,556 --> 00:13:31,636
mutable collection, and the


394
00:13:31,966 --> 00:13:34,626
ability to change the length and


395
00:13:34,626 --> 00:13:36,506
structure, which comes from


396
00:13:36,506 --> 00:13:37,656
range-replaceable collection.


397
00:13:38,186 --> 00:13:41,606
And it's built from a couple of


398
00:13:41,606 --> 00:13:43,206
other order n algorithms.


399
00:13:44,016 --> 00:13:46,126
The first is a half stable


400
00:13:46,126 --> 00:13:48,096
partition, which moves all of


401
00:13:48,096 --> 00:13:49,416
the elements satisfying some


402
00:13:49,416 --> 00:13:53,456
predicate to the end and tells


403
00:13:53,456 --> 00:13:54,846
us where that suffix starts.


404
00:13:56,136 --> 00:13:57,786
The half stable in its name,


405
00:13:58,186 --> 00:14:00,196
that comes, that indicates that


406
00:14:00,196 --> 00:14:02,116
it preserves the order of the


407
00:14:02,116 --> 00:14:03,646
elements that it doesn't move,


408
00:14:04,486 --> 00:14:06,396
but it can scramble the elements


409
00:14:06,436 --> 00:14:09,026
that it moves to the end.


410
00:14:09,206 --> 00:14:10,426
Now, sometimes, that doesn't


411
00:14:10,426 --> 00:14:11,786
matter though; the second


412
00:14:11,786 --> 00:14:13,166
algorithm removes subrange.


413
00:14:13,166 --> 00:14:14,146
It's just going to delete them


414
00:14:14,146 --> 00:14:14,456
anyway.


415
00:14:16,476 --> 00:14:17,956
Have we all seen this partial


416
00:14:17,956 --> 00:14:18,696
range notation?


417
00:14:19,256 --> 00:14:21,426
It's just a really convenient


418
00:14:21,426 --> 00:14:22,656
way of writing a range that


419
00:14:22,656 --> 00:14:23,696
extends to the end of the


420
00:14:23,696 --> 00:14:24,000
collection.


421
00:14:26,896 --> 00:14:27,116
Okay.


422
00:14:27,846 --> 00:14:29,986
Now, remove subrange is part of


423
00:14:29,986 --> 00:14:31,826
the library's public API, so you


424
00:14:31,826 --> 00:14:33,496
can find its documentation


425
00:14:33,496 --> 00:14:36,276
online, but halfStablePartition


426
00:14:36,456 --> 00:14:37,696
is an implementation detail.


427
00:14:38,236 --> 00:14:42,166
Now, we're not going to step


428
00:14:42,166 --> 00:14:43,556
through all of it, but there are


429
00:14:43,556 --> 00:14:44,906
a few things worth noticing


430
00:14:44,906 --> 00:14:45,116
here.


431
00:14:46,516 --> 00:14:48,846
First, it starts by calling yet


432
00:14:48,846 --> 00:14:49,696
another algorithm,


433
00:14:50,486 --> 00:14:52,596
firstIndex(where), to find the


434
00:14:52,856 --> 00:14:54,716
position of the first element


435
00:14:54,716 --> 00:14:55,796
that belongs in the suffix.


436
00:14:57,176 --> 00:14:58,766
Next, it sets up a loop variable


437
00:14:58,766 --> 00:15:01,126
j, and there's a single loop,


438
00:15:01,616 --> 00:15:04,906
and the loop index j moves


439
00:15:05,046 --> 00:15:06,646
forward one on each iteration.


440
00:15:07,696 --> 00:15:09,196
So, it's a sure bet that j makes


441
00:15:09,196 --> 00:15:10,716
just one pass over the elements.


442
00:15:11,116 --> 00:15:14,086
You can almost see the order and


443
00:15:14,086 --> 00:15:20,306
complexity just from that.


444
00:15:20,516 --> 00:15:22,106
Lastly, because this method


445
00:15:22,106 --> 00:15:23,526
needs to rearrange elements but


446
00:15:23,526 --> 00:15:24,726
not change the length or


447
00:15:24,726 --> 00:15:26,396
structure of the collection, it


448
00:15:26,396 --> 00:15:27,506
only depends on mutable


449
00:15:27,506 --> 00:15:28,606
collection conformance.


450
00:15:29,146 --> 00:15:32,366
So, this is the first lesson I


451
00:15:32,366 --> 00:15:32,676
learned.


452
00:15:33,686 --> 00:15:34,966
Become familiar with what's in


453
00:15:34,966 --> 00:15:36,166
the Swift Standard Library.


454
00:15:37,176 --> 00:15:38,606
It contains a suite of


455
00:15:38,606 --> 00:15:40,416
algorithms with documented


456
00:15:40,416 --> 00:15:41,486
meanings and performance


457
00:15:41,486 --> 00:15:42,316
characteristics.


458
00:15:43,406 --> 00:15:45,526
And although we happened to peek


459
00:15:45,526 --> 00:15:47,416
at the implementation, and you


460
00:15:47,416 --> 00:15:49,126
can learn a lot that way, it's


461
00:15:49,156 --> 00:15:50,786
designed so that you do not have


462
00:15:50,836 --> 00:15:50,946
to.


463
00:15:52,426 --> 00:15:53,756
The official documentation


464
00:15:53,756 --> 00:15:55,046
should tell you everything you


465
00:15:55,046 --> 00:15:56,856
need to know in order to use the


466
00:15:56,856 --> 00:15:58,006
library effectively.


467
00:15:58,996 --> 00:16:00,126
You'll even find a playground


468
00:16:00,126 --> 00:16:00,846
tutorial there.


469
00:16:01,906 --> 00:16:03,856
Now, I realize there's a lot in


470
00:16:03,856 --> 00:16:05,436
Swift, so it can look daunting,


471
00:16:06,196 --> 00:16:07,306
but you don't need to remember


472
00:16:07,306 --> 00:16:07,706
everything.


473
00:16:08,696 --> 00:16:10,066
Having an idea of what's there


474
00:16:10,066 --> 00:16:12,156
and how to find it will take you


475
00:16:12,156 --> 00:16:13,326
a long way.


476
00:16:14,396 --> 00:16:16,466
Now, before we move on, I want


477
00:16:16,466 --> 00:16:18,326
to point out something else that


478
00:16:18,326 --> 00:16:19,576
happened in my code when Crusty


479
00:16:19,576 --> 00:16:20,276
made this change.


480
00:16:21,136 --> 00:16:22,816
Which one of these most directly


481
00:16:22,816 --> 00:16:23,776
describes its meaning?


482
00:16:24,346 --> 00:16:27,166
Now, I actually have to read and


483
00:16:27,226 --> 00:16:28,406
think through the first one to


484
00:16:28,406 --> 00:16:29,216
know what it's doing.


485
00:16:30,086 --> 00:16:30,376
Hmm.


486
00:16:30,616 --> 00:16:31,836
Maybe I'd better add a comment.


487
00:16:32,806 --> 00:16:33,026
Okay.


488
00:16:33,026 --> 00:16:33,646
How does that look?


489
00:16:34,196 --> 00:16:35,836
Oh, even with that comment, the


490
00:16:35,836 --> 00:16:37,156
reverse iteration is kind of


491
00:16:37,156 --> 00:16:38,356
tricky, and I don't want


492
00:16:38,356 --> 00:16:39,776
somebody breaking this code


493
00:16:39,776 --> 00:16:40,826
because they don't understand


494
00:16:40,826 --> 00:16:40,946
it.


495
00:16:41,266 --> 00:16:45,046
So, I'd better explain that.


496
00:16:45,256 --> 00:16:45,726
Okay.


497
00:16:46,126 --> 00:16:47,596
While we're clarifying things,


498
00:16:47,656 --> 00:16:49,866
the After code actually reads


499
00:16:49,866 --> 00:16:50,956
better with a trailing closure


500
00:16:50,956 --> 00:16:51,606
syntax.


501
00:16:51,966 --> 00:16:54,896
Now, take a breath and look


502
00:16:54,896 --> 00:16:55,196
again.


503
00:16:56,606 --> 00:16:57,936
Which one is more obviously


504
00:16:57,936 --> 00:16:58,346
correct?


505
00:16:59,526 --> 00:17:00,956
Even with all these comments, I


506
00:17:00,956 --> 00:17:02,016
still need to read through the


507
00:17:02,016 --> 00:17:03,936
first one just to see that it


508
00:17:03,936 --> 00:17:05,886
does inefficiently the same


509
00:17:05,955 --> 00:17:06,976
thing as the second one.


510
00:17:08,056 --> 00:17:09,465
Using the algorithm just made


511
00:17:09,465 --> 00:17:10,955
the code better in every way.


512
00:17:11,526 --> 00:17:15,356
So, this is a guideline, an


513
00:17:15,356 --> 00:17:16,955
aspiration for your code first


514
00:17:16,986 --> 00:17:18,486
put forward by Shawn Perin.


515
00:17:19,636 --> 00:17:20,836
Every time you write a loop,


516
00:17:21,316 --> 00:17:22,526
replace it with a call to an


517
00:17:22,526 --> 00:17:23,046
algorithm.


518
00:17:23,846 --> 00:17:25,955
If you can't find one, make that


519
00:17:25,955 --> 00:17:27,366
algorithm yourself and move the


520
00:17:27,366 --> 00:17:28,656
loop into its implementation.


521
00:17:30,656 --> 00:17:32,496
Actually following this might


522
00:17:32,496 --> 00:17:34,156
seem unrealistic to you now, but


523
00:17:34,196 --> 00:17:36,166
by the end of the talk, I hope


524
00:17:36,516 --> 00:17:37,056
it won't.


525
00:17:38,096 --> 00:17:39,356
For a little motivation though,


526
00:17:39,856 --> 00:17:42,246
think back to the last time you


527
00:17:42,246 --> 00:17:43,536
were looking at spaghetti code.


528
00:17:44,066 --> 00:17:46,296
Was it full of loops?


529
00:17:47,506 --> 00:17:50,276
I bet it was.


530
00:17:50,766 --> 00:17:51,236
All right.


531
00:17:51,386 --> 00:17:52,286
Done and done.


532
00:17:52,506 --> 00:17:53,666
I have just made the code


533
00:17:53,666 --> 00:17:56,066
shorter, faster, and better in


534
00:17:56,066 --> 00:17:56,686
every way.


535
00:17:56,686 --> 00:17:58,726
I was ready to call it a day.


536
00:17:59,376 --> 00:18:00,546
"Thanks for your help, Crusty,"


537
00:18:00,546 --> 00:18:02,576
I said, fastening the titanium


538
00:18:02,576 --> 00:18:05,036
carabiners on my bespoke leather


539
00:18:05,036 --> 00:18:07,336
messenger bag, but he looked at


540
00:18:07,336 --> 00:18:09,586
me suspiciously, and said, "You


541
00:18:09,586 --> 00:18:10,966
suppose you might have made that


542
00:18:10,966 --> 00:18:12,330
mistake anywhere else?"


543
00:18:14,166 --> 00:18:16,746
I sighed, put my bag down and


544
00:18:16,746 --> 00:18:18,156
started hunting down the loops


545
00:18:18,156 --> 00:18:18,746
in my code.


546
00:18:20,016 --> 00:18:21,786
There were lots in the file


547
00:18:22,106 --> 00:18:24,106
[inaudible].


548
00:18:24,426 --> 00:18:28,666
Bring to front, send it back,


549
00:18:29,596 --> 00:18:31,126
bring forward, which sort of


550
00:18:31,126 --> 00:18:32,686
hops the selected shape over the


551
00:18:32,686 --> 00:18:33,486
one in front of it.


552
00:18:34,746 --> 00:18:36,666
Let's do that a couple of more


553
00:18:38,076 --> 00:18:38,206
times.


554
00:18:38,406 --> 00:18:40,536
Send backward with hops, under


555
00:18:40,536 --> 00:18:41,756
the shape, below the selected


556
00:18:41,756 --> 00:18:45,486
shape, and last of all, dragging


557
00:18:45,486 --> 00:18:49,776
in the shape list at the left.


558
00:18:49,776 --> 00:18:52,196
Now, these sound really simple


559
00:18:52,746 --> 00:18:56,126
until you realize that they all


560
00:18:56,126 --> 00:18:57,566
need to operate on multiple


561
00:18:57,566 --> 00:18:59,096
selected shapes that might not


562
00:18:59,096 --> 00:19:01,316
even be contiguous in the list.


563
00:19:05,226 --> 00:19:06,486
So, it turns out that the


564
00:19:06,486 --> 00:19:07,906
behavior that makes sense is to


565
00:19:07,906 --> 00:19:09,166
leave all of the selected


566
00:19:09,166 --> 00:19:10,826
elements next to each other


567
00:19:10,826 --> 00:19:12,126
after the operation is finished.


568
00:19:13,126 --> 00:19:14,176
So, when you're bringing shapes


569
00:19:14,176 --> 00:19:15,596
forward, you hop the front most


570
00:19:15,596 --> 00:19:17,136
selected shape in front of its


571
00:19:17,136 --> 00:19:18,936
neighbor, and then you group all


572
00:19:18,936 --> 00:19:20,566
the other ones behind it.


573
00:19:22,386 --> 00:19:23,736
And when you send shapes


574
00:19:23,776 --> 00:19:25,496
backward, you hop the bottom


575
00:19:25,496 --> 00:19:26,926
most selected shape backward


576
00:19:26,926 --> 00:19:28,396
behind its neighbor and group


577
00:19:28,396 --> 00:19:30,366
the other ones in front of it.


578
00:19:33,756 --> 00:19:36,256
So, if you didn't follow that


579
00:19:36,256 --> 00:19:37,626
completely, don't worry.


580
00:19:37,626 --> 00:19:38,526
We'll come back to it.


581
00:19:38,856 --> 00:19:41,386
But suffice it to say that I had


582
00:19:41,386 --> 00:19:42,836
some pretty carefully worked out


583
00:19:42,836 --> 00:19:44,356
code to get all of these details


584
00:19:44,356 --> 00:19:44,606
right.


585
00:19:45,866 --> 00:19:47,996
For example, this was


586
00:19:47,996 --> 00:19:51,256
bringToFront, and when I looked


587
00:19:51,256 --> 00:19:53,656
at it, sure enough, there was an


588
00:19:53,656 --> 00:19:55,366
order n loop over the shapes


589
00:19:55,956 --> 00:19:57,716
containing two order n


590
00:19:57,716 --> 00:20:00,186
operations, remove(at:) and


591
00:20:00,186 --> 00:20:02,756
insert(at:), which makes this,


592
00:20:03,246 --> 00:20:04,786
you guessed it, n squared.


593
00:20:06,246 --> 00:20:08,526
In fact, that same problem


594
00:20:08,526 --> 00:20:10,076
showed up in every one of my


595
00:20:10,076 --> 00:20:11,076
other four commands.


596
00:20:12,516 --> 00:20:14,046
All of the implementations here


597
00:20:14,386 --> 00:20:16,196
loop over an array, performing


598
00:20:16,196 --> 00:20:17,936
insertions and removals, which


599
00:20:17,936 --> 00:20:19,126
means they're all quadratic.


600
00:20:19,626 --> 00:20:23,096
Now, I was kind of discouraged


601
00:20:23,096 --> 00:20:24,996
at this point, so I asked Crusty


602
00:20:24,996 --> 00:20:26,106
if he'd look at them with me.


603
00:20:27,406 --> 00:20:29,106
He said, "Can't stay too late,"


604
00:20:29,186 --> 00:20:31,156
he said, "I got my ballroom


605
00:20:31,156 --> 00:20:33,096
dancing tonight, but I guess we


606
00:20:33,226 --> 00:20:34,546
better get a move on."


607
00:20:35,306 --> 00:20:37,486
So, I pulled up bringToFront,


608
00:20:38,686 --> 00:20:40,946
and Crusty's first question was,


609
00:20:42,156 --> 00:20:44,546
"What does it actually do?"


610
00:20:45,846 --> 00:20:47,566
"Well," I said, "there's a while


611
00:20:47,566 --> 00:20:49,426
loop and j tracks the insertion


612
00:20:49,426 --> 00:20:51,266
point and i tracks the element


613
00:20:51,266 --> 00:20:51,906
we're looking at."


614
00:20:52,226 --> 00:20:54,216
"In words, not in codes," said


615
00:20:54,246 --> 00:20:54,666
Crusty.


616
00:20:55,706 --> 00:20:57,126
"Describe it."


617
00:20:58,146 --> 00:20:59,286
"Okay. Let's see.


618
00:20:59,776 --> 00:21:01,616
It moves the selected shapes to


619
00:21:01,616 --> 00:21:03,406
the front, maintaining their


620
00:21:03,406 --> 00:21:04,176
relative order."


621
00:21:04,706 --> 00:21:07,136
"Write that down in a dot


622
00:21:07,136 --> 00:21:08,376
comment and read it back to me."


623
00:21:10,406 --> 00:21:13,146
I'm a superfast typist.


624
00:21:15,236 --> 00:21:17,416
"Moves the selected shapes to


625
00:21:17,416 --> 00:21:18,496
the front, maintaining their


626
00:21:18,496 --> 00:21:19,286
relative order."


627
00:21:19,706 --> 00:21:21,766
"Sound familiar?"


628
00:21:22,186 --> 00:21:22,796
said Crusty.


629
00:21:24,066 --> 00:21:25,276
That's when I realized that this


630
00:21:25,276 --> 00:21:26,736
was a lot like half stable


631
00:21:26,766 --> 00:21:29,286
partition, except it's fully


632
00:21:29,286 --> 00:21:29,676
stable.


633
00:21:29,676 --> 00:21:32,046
I was starting to get excited.


634
00:21:32,556 --> 00:21:33,776
And what do you think this one


635
00:21:33,776 --> 00:21:34,226
is called?


636
00:21:34,906 --> 00:21:36,516
So, I had to guess, "Stable


637
00:21:36,516 --> 00:21:37,026
partition?"


638
00:21:37,566 --> 00:21:38,346
"That's right.


639
00:21:38,536 --> 00:21:41,126
One of my old favorites, and you


640
00:21:41,126 --> 00:21:42,426
can find an implementation in


641
00:21:42,426 --> 00:21:43,946
this here file from the Swift


642
00:21:43,946 --> 00:21:45,486
Open Source project."


643
00:21:46,356 --> 00:21:48,396
So, I pulled the file into my


644
00:21:48,396 --> 00:21:50,006
project, while Crusty mumbled


645
00:21:50,006 --> 00:21:51,266
something about how that comment


646
00:21:51,266 --> 00:21:52,206
we added should have been there


647
00:21:52,206 --> 00:21:55,756
all along, and I started coding,


648
00:21:56,936 --> 00:21:59,526
getting about this far before I


649
00:21:59,526 --> 00:22:00,196
had a problem.


650
00:22:01,666 --> 00:22:03,716
You see, stable partition takes


651
00:22:03,716 --> 00:22:06,306
a predicate that says whether to


652
00:22:06,306 --> 00:22:07,966
move an element into the suffix


653
00:22:08,416 --> 00:22:09,126
of the collection.


654
00:22:09,946 --> 00:22:11,326
So, I had to express bring to


655
00:22:11,516 --> 00:22:13,496
front in terms of moving things


656
00:22:13,496 --> 00:22:14,046
to the back.


657
00:22:15,406 --> 00:22:16,256
I looked at Crusty.


658
00:22:17,276 --> 00:22:19,286
"Visualize it," he said.


659
00:22:20,286 --> 00:22:21,986
So, I closed my eyes and watched


660
00:22:22,646 --> 00:22:24,176
as the unselected shapes


661
00:22:24,176 --> 00:22:25,936
gathered at the back, which gave


662
00:22:25,936 --> 00:22:26,616
me my answer.


663
00:22:27,226 --> 00:22:31,096
Now, I guess sendToBack was even


664
00:22:31,096 --> 00:22:32,436
easier because we just need to


665
00:22:32,436 --> 00:22:33,276
invert the predicate.


666
00:22:33,836 --> 00:22:34,996
We're sending the selected ones


667
00:22:35,056 --> 00:22:38,126
to the back.


668
00:22:38,346 --> 00:22:40,566
Now, I was just about to attack


669
00:22:40,566 --> 00:22:42,476
the bring forward command, and I


670
00:22:42,476 --> 00:22:43,986
figured that Crusty would be as


671
00:22:43,986 --> 00:22:46,346
eager to move on as I was, given


672
00:22:46,346 --> 00:22:47,436
his plans for the evening, but


673
00:22:47,756 --> 00:22:48,376
he stopped me.


674
00:22:49,296 --> 00:22:50,446
"Hold your horses, Snuffy.


675
00:22:51,616 --> 00:22:52,856
I don't want to miss the opening


676
00:22:52,856 --> 00:22:54,676
tango, but aren't you going to


677
00:22:54,676 --> 00:22:55,926
check whether it'll scale?"


678
00:22:57,326 --> 00:22:59,776
He had a point, so I popped up


679
00:22:59,776 --> 00:23:00,766
the Quick Help for stable


680
00:23:00,806 --> 00:23:04,196
partition, and I saw that it had


681
00:23:04,416 --> 00:23:06,046
(n log n) complexity.


682
00:23:06,606 --> 00:23:09,356
So, for a way to think about (n


683
00:23:09,356 --> 00:23:11,506
log n) take a look at log n.


684
00:23:12,096 --> 00:23:15,236
It starts to level off really


685
00:23:15,236 --> 00:23:17,246
quickly, and the bigger it gets,


686
00:23:17,496 --> 00:23:19,856
the slower it grows, and the


687
00:23:19,886 --> 00:23:21,246
closer it comes to being a


688
00:23:21,246 --> 00:23:21,716
constant.


689
00:23:22,526 --> 00:23:24,136
So, when you multiply that by n,


690
00:23:24,136 --> 00:23:27,366
you get something that doesn't


691
00:23:27,566 --> 00:23:29,376
scale quite as well as order n


692
00:23:29,876 --> 00:23:31,466
but that gets closer and closer


693
00:23:31,466 --> 00:23:32,946
to linear as it grows.


694
00:23:34,146 --> 00:23:36,696
So, order n login is rightly


695
00:23:36,696 --> 00:23:38,556
often treated as being almost


696
00:23:38,556 --> 00:23:40,066
the same as order n.


697
00:23:40,896 --> 00:23:42,296
I was pretty happy with that.


698
00:23:43,056 --> 00:23:44,326
So, we moved on to bring


699
00:23:44,326 --> 00:23:44,696
forward.


700
00:23:45,246 --> 00:23:49,646
Now, as we said earlier, bring


701
00:23:49,726 --> 00:23:51,626
forward bumps the front most


702
00:23:51,626 --> 00:23:53,006
selected shape forward by one


703
00:23:53,006 --> 00:23:55,296
position and gathers the other


704
00:23:55,296 --> 00:23:56,576
selected shapes behind it.


705
00:23:57,876 --> 00:24:00,156
But Crusty didn't like that way


706
00:24:00,156 --> 00:24:01,506
of thinking about it at all.


707
00:24:02,146 --> 00:24:03,396
"That little do-si-do at the


708
00:24:03,396 --> 00:24:05,026
beginning is making a line dance


709
00:24:05,026 --> 00:24:06,096
look like a Fox Trot."


710
00:24:06,356 --> 00:24:08,466
he said, "You don't need it."


711
00:24:09,096 --> 00:24:10,906
When I looked at him blankly, he


712
00:24:10,906 --> 00:24:12,206
broke out the lozenges again,


713
00:24:13,976 --> 00:24:15,616
and with five of his free


714
00:24:15,616 --> 00:24:17,836
digits, he executed the


715
00:24:17,836 --> 00:24:19,926
bringForward command.


716
00:24:22,556 --> 00:24:23,506
"See it again?"


717
00:24:23,776 --> 00:24:24,226
he asked.


718
00:24:25,416 --> 00:24:26,816
I felt a little like a mark in a


719
00:24:26,816 --> 00:24:29,666
Three-card Monte, but I played


720
00:24:33,826 --> 00:24:33,976
along.


721
00:24:34,256 --> 00:24:35,176
"Look familiar?"


722
00:24:36,336 --> 00:24:36,616
"No."


723
00:24:37,826 --> 00:24:39,296
He threw a hanky over the first


724
00:24:39,876 --> 00:24:40,006
few.


725
00:24:42,296 --> 00:24:46,366
"How about now?"


726
00:24:46,636 --> 00:24:48,876
That's when I realized it was


727
00:24:48,876 --> 00:24:50,226
just another stable partition.


728
00:24:51,416 --> 00:24:51,766
Okay.


729
00:24:52,236 --> 00:24:54,046
I got this, I thought.


730
00:24:55,856 --> 00:24:58,096
If we find the front most


731
00:24:58,096 --> 00:25:01,716
selected shape, then move to its


732
00:25:01,746 --> 00:25:05,326
predecessor, and isolate the


733
00:25:05,606 --> 00:25:07,086
section of the array that starts


734
00:25:07,086 --> 00:25:09,716
there, we could just partition


735
00:25:10,556 --> 00:25:10,666
that.


736
00:25:12,236 --> 00:25:14,166
"But how do you modify just part


737
00:25:14,166 --> 00:25:14,776
of a collection?"


738
00:25:14,976 --> 00:25:15,676
I asked Crusty.


739
00:25:16,876 --> 00:25:17,746
"Ain't you never heard of a


740
00:25:17,746 --> 00:25:18,296
slice?"


741
00:25:18,526 --> 00:25:19,516
he said, taking over the


742
00:25:19,516 --> 00:25:19,946
keyboard.


743
00:25:23,156 --> 00:25:25,106
"Shapes, starting with


744
00:25:25,726 --> 00:25:26,336
predecessor.


745
00:25:27,656 --> 00:25:28,256
There.


746
00:25:28,256 --> 00:25:29,596
Stick that in your algorithm and


747
00:25:29,596 --> 00:25:30,146
mutate it."


748
00:25:30,896 --> 00:25:32,000
Which I promptly did.


749
00:25:37,716 --> 00:25:41,456
So, human knowledge about how to


750
00:25:41,456 --> 00:25:43,096
compute things correctly and


751
00:25:43,096 --> 00:25:44,976
efficiently predates computers


752
00:25:44,976 --> 00:25:47,156
by thousands of years, going


753
00:25:47,156 --> 00:25:48,846
back at least to ancient Egypt,


754
00:25:49,546 --> 00:25:50,656
and since the invention of


755
00:25:50,656 --> 00:25:52,086
computers, there's been an


756
00:25:52,086 --> 00:25:53,696
explosion of work in this area.


757
00:25:55,186 --> 00:25:56,586
If the standard library doesn't


758
00:25:56,586 --> 00:25:58,386
have what you need, what you do


759
00:25:58,386 --> 00:26:00,556
need is probably out there with


760
00:26:00,556 --> 00:26:03,396
tests, with documentation, often


761
00:26:03,396 --> 00:26:04,786
with a proof of correctness.


762
00:26:05,746 --> 00:26:07,436
Learn how to search the web for


763
00:26:07,436 --> 00:26:08,746
research that applies to your


764
00:26:08,746 --> 00:26:10,086
problem domain.


765
00:26:12,716 --> 00:26:12,946
Okay.


766
00:26:12,946 --> 00:26:13,596
Back to the code.


767
00:26:14,076 --> 00:26:15,656
I was intrigued by this slice


768
00:26:15,706 --> 00:26:17,136
thing, and when I checked out


769
00:26:17,136 --> 00:26:19,596
its type, I saw that it wasn't


770
00:26:19,596 --> 00:26:20,156
an array.


771
00:26:20,716 --> 00:26:23,306
Since we had used stable


772
00:26:23,306 --> 00:26:24,876
partition on an array and


773
00:26:24,876 --> 00:26:27,216
bringToFront and sendToBack, and


774
00:26:27,216 --> 00:26:28,776
now we were using it on an array


775
00:26:28,776 --> 00:26:30,876
slice, I guessed out loud that


776
00:26:30,876 --> 00:26:32,496
it must be generic.


777
00:26:32,496 --> 00:26:34,636
"Of course, it is.


778
00:26:35,176 --> 00:26:36,446
What's stable partition got to


779
00:26:36,446 --> 00:26:37,846
do with the specifics of array?"


780
00:26:39,166 --> 00:26:40,436
"That's right, nothing.


781
00:26:41,336 --> 00:26:44,046
Speaking of which, Blonkey, just


782
00:26:44,046 --> 00:26:45,416
what does bringForward have to


783
00:26:45,416 --> 00:26:46,946
do with shapes and selection?"


784
00:26:48,616 --> 00:26:51,166
"Well," I said, "it works on


785
00:26:51,166 --> 00:26:52,876
shapes, and it brings forward


786
00:26:52,876 --> 00:26:53,796
the selected ones."


787
00:26:54,046 --> 00:26:55,936
"That's right, nothing," he went


788
00:26:55,936 --> 00:26:56,736
on without listening.


789
00:26:58,636 --> 00:27:00,006
"Can you run bring forward on a


790
00:27:00,006 --> 00:27:00,926
row of lozenges?


791
00:27:01,926 --> 00:27:03,106
Of course, you can.


792
00:27:04,086 --> 00:27:05,516
So, it's got nothing to do with


793
00:27:06,206 --> 00:27:06,500
shapes."


794
00:27:08,206 --> 00:27:08,446
Hmm.


795
00:27:08,896 --> 00:27:10,916
"Are you suggesting we make it


796
00:27:10,916 --> 00:27:11,376
generic?"


797
00:27:11,556 --> 00:27:12,056
I asked.


798
00:27:12,676 --> 00:27:13,626
"Isn't that premature


799
00:27:13,626 --> 00:27:14,426
generalization?"


800
00:27:15,416 --> 00:27:16,546
Answering a question with a


801
00:27:16,546 --> 00:27:20,866
question, Crusty replied, "Well,


802
00:27:20,866 --> 00:27:22,416
just how do you plan to test


803
00:27:22,416 --> 00:27:23,330
this method?"


804
00:27:24,946 --> 00:27:26,736
"Okay," I said, "I'll create a


805
00:27:26,736 --> 00:27:27,376
canvas.


806
00:27:27,616 --> 00:27:28,726
I'll add a bunch of random


807
00:27:28,726 --> 00:27:29,186
shapes.


808
00:27:29,186 --> 00:27:30,886
I'll select some of them, and


809
00:27:30,886 --> 00:27:31,676
then finally..."


810
00:27:32,466 --> 00:27:33,776
But I didn't even finish the


811
00:27:33,776 --> 00:27:35,506
sentence because I knew it was a


812
00:27:35,506 --> 00:27:36,216
bad idea.


813
00:27:37,076 --> 00:27:39,126
If I did all of that, would I


814
00:27:39,126 --> 00:27:40,456
really be testing my function,


815
00:27:40,966 --> 00:27:42,066
or would I be testing the


816
00:27:42,066 --> 00:27:43,646
initializers of Canvas and


817
00:27:43,646 --> 00:27:45,606
various shapes, the addShape


818
00:27:45,606 --> 00:27:47,776
method, the isSelected property


819
00:27:47,976 --> 00:27:49,136
of the various shapes if it's


820
00:27:49,136 --> 00:27:49,706
computed?


821
00:27:50,106 --> 00:27:52,356
I have to build test cases for


822
00:27:52,356 --> 00:27:54,506
sure, but ideally, that code


823
00:27:54,736 --> 00:27:56,266
shouldn't depend on other code


824
00:27:56,266 --> 00:27:57,826
that I also have to test.


825
00:27:59,126 --> 00:28:00,506
If I can bring the lozenges


826
00:28:00,506 --> 00:28:02,776
forward, it should be possible


827
00:28:02,776 --> 00:28:04,406
to do something casual with


828
00:28:04,866 --> 00:28:05,636
[inaudible] in a playground,


829
00:28:05,986 --> 00:28:08,226
like this, which brings forward


830
00:28:08,226 --> 00:28:09,796
the number divisible by 3.


831
00:28:13,276 --> 00:28:14,596
Now, at the other end of the


832
00:28:14,596 --> 00:28:16,296
spectrum, I should be able to


833
00:28:16,296 --> 00:28:18,116
throw vast quantities of


834
00:28:18,116 --> 00:28:19,856
randomly generated test data at


835
00:28:19,856 --> 00:28:21,256
it and make sure that the


836
00:28:21,256 --> 00:28:22,386
algorithm scales.


837
00:28:23,246 --> 00:28:24,696
Neither of those was going to be


838
00:28:24,696 --> 00:28:26,076
easy as long as the code was


839
00:28:26,116 --> 00:28:27,906
tied to Canvas and shapes.


840
00:28:29,146 --> 00:28:31,506
And so, I admitted to Crusty


841
00:28:32,296 --> 00:28:33,546
that he was right and started


842
00:28:33,546 --> 00:28:34,846
making this non-generic


843
00:28:35,616 --> 00:28:37,106
bringForward into a generic one.


844
00:28:38,436 --> 00:28:40,666
The first step was to decouple


845
00:28:40,666 --> 00:28:44,896
it from Canvas and move it to


846
00:28:44,896 --> 00:28:45,696
arrays of shapes.


847
00:28:47,216 --> 00:28:49,266
Of course, this array is the


848
00:28:49,266 --> 00:28:50,556
shape, so I had to replace


849
00:28:50,556 --> 00:28:54,366
shapes with self, and then I


850
00:28:54,366 --> 00:28:56,866
decoupled it from selection by


851
00:28:56,866 --> 00:28:58,636
passing a predicate indicating


852
00:28:58,736 --> 00:29:00,046
whether a given shape should be


853
00:29:00,046 --> 00:29:00,866
brought forward.


854
00:29:04,716 --> 00:29:06,156
And everything kept compiling.


855
00:29:07,036 --> 00:29:07,386
Awesome!


856
00:29:08,266 --> 00:29:10,826
At that point, I was pleased to


857
00:29:10,826 --> 00:29:12,086
find there were no dependencies


858
00:29:12,086 --> 00:29:14,266
left on shape, and I could just


859
00:29:14,426 --> 00:29:15,406
delete the where clause.


860
00:29:15,956 --> 00:29:18,106
Pretty cool, I thought.


861
00:29:18,106 --> 00:29:20,106
Now, I can bring forward on any


862
00:29:20,106 --> 00:29:20,506
array.


863
00:29:21,636 --> 00:29:23,386
I looked over at Crusty, who had


864
00:29:23,386 --> 00:29:24,636
been quietly practicing the


865
00:29:24,676 --> 00:29:26,876
cha-cha-cha in the corner, but


866
00:29:26,876 --> 00:29:28,586
he didn't seem to think I was


867
00:29:29,736 --> 00:29:30,000
finished.


868
00:29:31,316 --> 00:29:32,996
"What does bring forward have to


869
00:29:32,996 --> 00:29:34,026
do with arrays?"


870
00:29:34,916 --> 00:29:37,196
he asked.


871
00:29:37,436 --> 00:29:38,976
"Well, nothing," I sighed and


872
00:29:38,976 --> 00:29:40,046
started thinking about how to


873
00:29:40,046 --> 00:29:41,206
remove this dependency.


874
00:29:42,656 --> 00:29:43,706
Let's see, there's a stable


875
00:29:43,706 --> 00:29:46,066
partition here, which requires


876
00:29:46,066 --> 00:29:47,636
mutable collection conformance.


877
00:29:48,186 --> 00:29:49,416
So, maybe I'll just move it to


878
00:29:49,416 --> 00:29:52,676
mutable collection.


879
00:29:53,006 --> 00:29:53,466
Hmm.


880
00:29:53,896 --> 00:29:56,076
I thought, clearly the index


881
00:29:56,116 --> 00:29:58,536
type doesn't match Int.


882
00:29:59,456 --> 00:29:59,746
Okay.


883
00:29:59,746 --> 00:30:00,826
So, there's a simple fix for


884
00:30:00,826 --> 00:30:01,000
this, right?


885
00:30:04,216 --> 00:30:04,936
Have you done this?


886
00:30:06,176 --> 00:30:08,106
Don't do this.


887
00:30:09,546 --> 00:30:11,326
It compiled, but Crusty had


888
00:30:11,326 --> 00:30:12,586
suddenly stopped dancing, and I


889
00:30:12,586 --> 00:30:15,156
knew something was wrong.


890
00:30:15,366 --> 00:30:16,166
"What?" I said.


891
00:30:16,966 --> 00:30:18,836
"Rookies always do that," said


892
00:30:18,836 --> 00:30:20,036
Crusty, shaking his head.


893
00:30:21,566 --> 00:30:23,216
"First, you got that comparison


894
00:30:23,216 --> 00:30:24,736
with 0, which is going to be


895
00:30:24,736 --> 00:30:26,056
wrong for array slice.


896
00:30:26,686 --> 00:30:29,456
So, did you know that array


897
00:30:29,456 --> 00:30:31,596
slices, their indices don't


898
00:30:31,596 --> 00:30:32,216
start at 0?


899
00:30:32,216 --> 00:30:35,696
The indices of all slices start


900
00:30:35,966 --> 00:30:37,506
with the corresponding index in


901
00:30:37,506 --> 00:30:38,786
the underlying collection that


902
00:30:38,786 --> 00:30:40,246
they were sliced from.


903
00:30:40,796 --> 00:30:42,976
That relationship is critical if


904
00:30:42,976 --> 00:30:44,126
you want to be able to compose


905
00:30:44,126 --> 00:30:46,466
generic algorithms using slices,


906
00:30:47,056 --> 00:30:47,946
so it's really important."


907
00:30:49,156 --> 00:30:51,946
Well, this problem, I knew to


908
00:30:51,946 --> 00:30:52,406
fix.


909
00:30:53,146 --> 00:30:54,126
Just compare it with start


910
00:30:54,126 --> 00:30:54,516
index.


911
00:30:55,766 --> 00:30:58,346
But the real problem is "What


912
00:30:58,346 --> 00:31:00,056
does bringForward have to do


913
00:31:00,056 --> 00:31:01,846
with having integer indices?"


914
00:31:01,846 --> 00:31:02,576
I interrupted.


915
00:31:03,416 --> 00:31:04,416
"Yeah, I know."


916
00:31:05,266 --> 00:31:07,466
"Well, I do have to get the


917
00:31:07,466 --> 00:31:10,156
index before i, which I can do


918
00:31:10,156 --> 00:31:10,876
with subtraction."


919
00:31:12,856 --> 00:31:14,976
Crusty just sighed and broke out


920
00:31:14,976 --> 00:31:15,906
the lozenges again.


921
00:31:17,466 --> 00:31:19,376
And then, he laid two fingers


922
00:31:19,376 --> 00:31:22,156
down on the desk and walked them


923
00:31:22,566 --> 00:31:24,966
across until his right hand was


924
00:31:25,136 --> 00:31:26,706
pointing at the first green


925
00:31:26,706 --> 00:31:27,276
lozenge.


926
00:31:27,806 --> 00:31:31,446
"Not a backwards step in the


927
00:31:31,446 --> 00:31:32,506
whole dance," he said.


928
00:31:33,406 --> 00:31:35,286
And I realized that Crusty had


929
00:31:35,286 --> 00:31:37,586
just shown me a new algorithm.


930
00:31:38,636 --> 00:31:39,546
Let's call that one


931
00:31:39,696 --> 00:31:40,986
indexBeforeFirst.


932
00:31:42,066 --> 00:31:43,776
"Now, the trick here is to keep


933
00:31:43,776 --> 00:31:46,086
your focus by assuming somebody


934
00:31:46,086 --> 00:31:46,976
already wrote it for you."


935
00:31:47,826 --> 00:31:49,116
And he proceeded to hack away


936
00:31:49,116 --> 00:31:50,336
all the code that we didn't


937
00:31:50,336 --> 00:31:53,906
need, like that and that.


938
00:31:56,616 --> 00:32:00,866
"Predecessor is the index before


939
00:32:00,866 --> 00:32:02,416
the first one where the


940
00:32:02,416 --> 00:32:04,286
predicate is satisfied.


941
00:32:05,346 --> 00:32:06,656
Now, just look how pretty that


942
00:32:06,656 --> 00:32:07,046
reads."


943
00:32:08,486 --> 00:32:10,946
Now, if you look at it, you can


944
00:32:10,946 --> 00:32:11,706
see that he's right.


945
00:32:13,116 --> 00:32:15,006
Taking away all the irrelevant


946
00:32:15,006 --> 00:32:17,436
detail about shapes, selections,


947
00:32:17,546 --> 00:32:20,066
arrays, and integers had left me


948
00:32:20,066 --> 00:32:22,006
with clearer code because it


949
00:32:22,006 --> 00:32:23,626
only traffics in the essentials


950
00:32:23,696 --> 00:32:24,356
of the problem.


951
00:32:24,926 --> 00:32:27,496
"I already showed you how


952
00:32:27,496 --> 00:32:28,956
indexBeforeFirst works.


953
00:32:29,266 --> 00:32:31,986
See if you could write it," he


954
00:32:31,986 --> 00:32:32,236
said.


955
00:32:32,706 --> 00:32:34,036
So, I think I was starting to


956
00:32:34,036 --> 00:32:36,016
catch on now because I got it


957
00:32:36,016 --> 00:32:37,036
right the first time.


958
00:32:37,666 --> 00:32:40,646
I told you, I'm a superfast


959
00:32:40,646 --> 00:32:40,996
typist.


960
00:32:41,466 --> 00:32:41,726
All right.


961
00:32:42,236 --> 00:32:45,436
So, return the first index whose


962
00:32:45,436 --> 00:32:48,536
successor matches the predicate.


963
00:32:49,206 --> 00:32:51,556
I was pretty excited about how


964
00:32:51,556 --> 00:32:52,396
well this was going.


965
00:32:53,436 --> 00:32:54,456
"All right, Crusty," I said,


966
00:32:54,766 --> 00:32:55,726
"let's do the next one."


967
00:32:57,516 --> 00:32:58,946
"Ain't you forgetting something,


968
00:32:58,946 --> 00:32:59,296
Bonkey?"


969
00:33:00,116 --> 00:33:00,586
he asked.


970
00:33:00,586 --> 00:33:02,306
I didn't know what he was


971
00:33:02,306 --> 00:33:02,906
talking about.


972
00:33:03,466 --> 00:33:05,276
The code was clean, and it


973
00:33:05,276 --> 00:33:05,666
worked.


974
00:33:07,016 --> 00:33:08,336
"Semantics, son.


975
00:33:09,046 --> 00:33:10,216
How am I supposed to use these


976
00:33:10,216 --> 00:33:11,416
from other code if I don't know


977
00:33:11,416 --> 00:33:12,156
what they mean?"


978
00:33:12,786 --> 00:33:17,156
And that's when I realized every


979
00:33:17,156 --> 00:33:18,926
time we'd use the new algorithm,


980
00:33:19,446 --> 00:33:20,326
we had leaned on his


981
00:33:20,326 --> 00:33:21,936
documentation to draw


982
00:33:21,936 --> 00:33:23,416
conclusions about the meaning


983
00:33:23,726 --> 00:33:25,296
and efficiency of our own code.


984
00:33:26,346 --> 00:33:27,846
And because most algorithms are


985
00:33:27,846 --> 00:33:29,456
built out of other algorithms,


986
00:33:29,896 --> 00:33:32,816
they lean on the same thing.


987
00:33:33,026 --> 00:33:34,826
Recently, I was interviewing a


988
00:33:34,826 --> 00:33:36,486
perspective intern and asked him


989
00:33:36,486 --> 00:33:38,236
about the role of documentation,


990
00:33:38,636 --> 00:33:40,226
and he began with a phrase I


991
00:33:40,226 --> 00:33:41,156
won't forget.


992
00:33:41,966 --> 00:33:43,306
"Oh, it's incredibly important,"


993
00:33:43,776 --> 00:33:44,206
he said.


994
00:33:45,646 --> 00:33:46,816
"We're building these towers of


995
00:33:46,816 --> 00:33:48,996
abstraction," and now I'm


996
00:33:48,996 --> 00:33:50,946
paraphrasing, "the reason we can


997
00:33:50,946 --> 00:33:52,286
build without constantly


998
00:33:52,286 --> 00:33:54,086
inspecting the layers below us


999
00:33:54,706 --> 00:33:56,036
is that the parts that we build


1000
00:33:56,036 --> 00:33:57,176
on are documented."


1001
00:33:57,666 --> 00:34:01,966
Now, as an app developer, you


1002
00:34:02,176 --> 00:34:03,746
are working at the very top of a


1003
00:34:03,746 --> 00:34:05,356
tower that stretches through


1004
00:34:05,356 --> 00:34:07,966
your system frameworks, DOS, and


1005
00:34:07,966 --> 00:34:09,556
into the hardware, which rests


1006
00:34:10,146 --> 00:34:11,216
on the laws of physics.


1007
00:34:12,815 --> 00:34:14,096
But as soon as you call one of


1008
00:34:14,096 --> 00:34:15,936
your own methods, it becomes


1009
00:34:15,936 --> 00:34:18,146
part of your foundation; so,


1010
00:34:18,146 --> 00:34:19,666
document your code.


1011
00:34:20,235 --> 00:34:21,565
The intern was hired, by the


1012
00:34:21,565 --> 00:34:23,946
way, and he's sitting right


1013
00:34:26,295 --> 00:34:26,406
there.


1014
00:34:26,616 --> 00:34:28,896
So, I took the hint and


1015
00:34:28,896 --> 00:34:29,936
documented Crusty's new


1016
00:34:29,936 --> 00:34:32,956
algorithm, which meant that we


1017
00:34:32,956 --> 00:34:33,716
could forget about the


1018
00:34:33,716 --> 00:34:36,956
implementation and just use it,


1019
00:34:37,206 --> 00:34:38,306
knowing that Quick Help had


1020
00:34:38,306 --> 00:34:39,416
everything that we needed.


1021
00:34:41,246 --> 00:34:42,856
Now, I also documented


1022
00:34:42,856 --> 00:34:43,496
bringForward.


1023
00:34:45,956 --> 00:34:46,565
Cool!


1024
00:34:48,136 --> 00:34:49,456
Now, because it seemed to be


1025
00:34:49,456 --> 00:34:51,626
solving all of my problems, at


1026
00:34:51,626 --> 00:34:53,496
this point, I was really curious


1027
00:34:53,496 --> 00:34:55,786
to see what was going on inside


1028
00:34:55,786 --> 00:34:56,596
stablePartition.


1029
00:34:57,806 --> 00:34:59,456
It turns out I was well rewarded


1030
00:34:59,526 --> 00:35:01,416
because it's a really beautiful


1031
00:35:01,416 --> 00:35:02,486
and instructive algorithm.


1032
00:35:03,766 --> 00:35:05,196
The public method gets the


1033
00:35:05,196 --> 00:35:06,846
collections count and passes it


1034
00:35:06,846 --> 00:35:10,506
on to this helper, which uses a


1035
00:35:10,506 --> 00:35:11,776
divide and conquer strategy.


1036
00:35:13,056 --> 00:35:15,136
So, first, it takes care of the


1037
00:35:15,136 --> 00:35:17,276
base cases when the count is


1038
00:35:17,276 --> 00:35:18,436
less than 2, we're done.


1039
00:35:18,966 --> 00:35:19,916
We just need to figure out


1040
00:35:20,396 --> 00:35:21,656
whether the partition point is


1041
00:35:21,656 --> 00:35:23,046
at the beginning or at the end


1042
00:35:23,046 --> 00:35:26,016
of the collection.


1043
00:35:26,116 --> 00:35:28,496
Next, we divide the collection


1044
00:35:28,546 --> 00:35:29,416
in two.


1045
00:35:31,136 --> 00:35:33,696
Now, at this point, you have to


1046
00:35:33,746 --> 00:35:35,136
temporarily take it on faith


1047
00:35:35,136 --> 00:35:37,146
that the algorithm works because


1048
00:35:37,146 --> 00:35:38,346
we're going to stable partition


1049
00:35:38,346 --> 00:35:41,056
the left half and the right


1050
00:35:41,056 --> 00:35:41,446
half.


1051
00:35:42,136 --> 00:35:46,766
Now, if you take a look at these


1052
00:35:46,766 --> 00:35:49,166
two ends, you can see that


1053
00:35:49,166 --> 00:35:50,746
everything is exactly in the


1054
00:35:50,746 --> 00:35:54,556
right place, but this center


1055
00:35:54,556 --> 00:35:56,516
section has two parts that need


1056
00:35:56,516 --> 00:35:57,316
to be exchanged.


1057
00:35:58,806 --> 00:36:01,016
Now, they won't always have the


1058
00:36:01,016 --> 00:36:03,126
same length as they do in this


1059
00:36:03,126 --> 00:36:06,716
example, and fortunately there's


1060
00:36:06,716 --> 00:36:07,986
an algorithm for that.


1061
00:36:08,906 --> 00:36:10,636
We call it rotate.


1062
00:36:11,176 --> 00:36:11,276
Okay.


1063
00:36:14,466 --> 00:36:16,496
I'm not going to go into rotate


1064
00:36:16,496 --> 00:36:18,226
here, but it's actually quite


1065
00:36:18,256 --> 00:36:19,156
beautiful, and if you're


1066
00:36:19,156 --> 00:36:20,686
interested, you can find its


1067
00:36:20,686 --> 00:36:22,446
implementation in the same file


1068
00:36:22,446 --> 00:36:23,436
as stable partitions.


1069
00:36:24,116 --> 00:36:24,216
Okay.


1070
00:36:25,596 --> 00:36:27,146
Back to shapes.


1071
00:36:28,186 --> 00:36:32,486
Now, this mess implemented the


1072
00:36:32,696 --> 00:36:34,706
dragging in the shapes list, and


1073
00:36:34,706 --> 00:36:36,626
it had always been one of my


1074
00:36:36,626 --> 00:36:38,706
most complicated and buggy


1075
00:36:38,706 --> 00:36:39,326
operations.


1076
00:36:40,336 --> 00:36:41,616
The strategy had been to


1077
00:36:41,616 --> 00:36:43,246
allocate the temporary buffer;


1078
00:36:44,536 --> 00:36:46,486
then, loop over the shapes


1079
00:36:47,076 --> 00:36:48,506
before the insertion point,


1080
00:36:48,736 --> 00:36:50,196
extracting the selected ones and


1081
00:36:50,196 --> 00:36:51,576
adjusting the insertion point,


1082
00:36:52,526 --> 00:36:54,086
and then separately loop over


1083
00:36:54,086 --> 00:36:55,896
the rest of the shapes without


1084
00:36:55,896 --> 00:36:57,236
adjusting the insertion point,


1085
00:36:57,236 --> 00:36:58,596
extracting the selected ones.


1086
00:36:59,126 --> 00:37:02,716
And then, finally, reinsert


1087
00:37:02,716 --> 00:37:02,916
them.


1088
00:37:06,536 --> 00:37:08,806
Honestly, I was a little scared


1089
00:37:08,806 --> 00:37:10,726
to touch the code because I


1090
00:37:10,726 --> 00:37:12,156
thought I finally had it right.


1091
00:37:12,156 --> 00:37:14,276
It had been almost a week since


1092
00:37:14,276 --> 00:37:15,536
the last time I discovered a new


1093
00:37:15,536 --> 00:37:16,056
bug.


1094
00:37:16,526 --> 00:37:21,026
But I had gotten pretty good at


1095
00:37:21,026 --> 00:37:22,726
this process now, so I tried


1096
00:37:23,286 --> 00:37:24,766
visualizing the operation


1097
00:37:24,766 --> 00:37:28,976
happening all at once.


1098
00:37:29,106 --> 00:37:31,116
Hey, that looks familiar.


1099
00:37:31,326 --> 00:37:34,856
Let's see it again.


1100
00:37:35,056 --> 00:37:35,486
Hmm.


1101
00:37:36,946 --> 00:37:39,826
Suppose we do this first, and


1102
00:37:39,826 --> 00:37:40,926
then take care of the parts


1103
00:37:40,926 --> 00:37:41,456
separately.


1104
00:37:43,456 --> 00:37:44,246
That's right.


1105
00:37:44,706 --> 00:37:45,946
This is just two stable


1106
00:37:45,946 --> 00:37:48,036
partitions with inverted


1107
00:37:48,696 --> 00:37:48,976
predicates.


1108
00:37:49,596 --> 00:37:51,316
So, the generic algorithm


1109
00:37:51,736 --> 00:37:52,846
collapsed down to this


1110
00:37:52,886 --> 00:37:56,716
two-liner, and here's what's


1111
00:37:56,716 --> 00:37:57,636
left in canvas.


1112
00:37:58,186 --> 00:38:01,126
Now, let's just see that next to


1113
00:38:01,126 --> 00:38:02,426
the old code.


1114
00:38:04,456 --> 00:38:07,886
That's not bad, but we got a


1115
00:38:07,886 --> 00:38:10,396
reusable efficient documented


1116
00:38:10,766 --> 00:38:12,346
general purpose algorithm out of


1117
00:38:12,346 --> 00:38:13,846
it, which is spectacular.


1118
00:38:14,446 --> 00:38:14,556
Okay.


1119
00:38:17,916 --> 00:38:21,846
So, this is a learned skill to


1120
00:38:21,846 --> 00:38:23,746
look past the details that are


1121
00:38:23,746 --> 00:38:25,086
specific to your application


1122
00:38:25,086 --> 00:38:27,056
domain, see what your code is


1123
00:38:27,056 --> 00:38:29,126
doing fundamentally, and capture


1124
00:38:29,126 --> 00:38:31,416
that in reusable generic code.


1125
00:38:32,276 --> 00:38:33,776
It takes practice.


1126
00:38:34,966 --> 00:38:35,636
So, why bother?


1127
00:38:36,536 --> 00:38:38,636
Well, the practical answer is


1128
00:38:38,636 --> 00:38:39,966
that because they're decoupled


1129
00:38:39,966 --> 00:38:41,896
from those irrelevant details,


1130
00:38:42,336 --> 00:38:44,126
generic algorithms are more


1131
00:38:44,126 --> 00:38:46,296
reusable, testable, and even


1132
00:38:46,296 --> 00:38:47,976
clearer than their non-generic


1133
00:38:47,976 --> 00:38:48,706
counterparts.


1134
00:38:49,676 --> 00:38:51,336
But I also think it's just


1135
00:38:51,586 --> 00:38:53,156
deeply rewarding for anyone that


1136
00:38:53,296 --> 00:38:54,446
really loves programming.


1137
00:38:55,646 --> 00:38:56,996
It's a search for truth and


1138
00:38:56,996 --> 00:38:59,406
beauty but not some abstract


1139
00:38:59,406 --> 00:39:01,266
untouchable truth because the


1140
00:39:01,266 --> 00:39:02,876
constraints of actual hardware


1141
00:39:02,876 --> 00:39:03,696
keep you honest.


1142
00:39:04,836 --> 00:39:06,066
As Crusty likes to say,


1143
00:39:07,026 --> 00:39:10,136
"Programming reveals the real."


1144
00:39:10,346 --> 00:39:12,296
So, treat your computation as a


1145
00:39:12,296 --> 00:39:14,576
first class citizen with all the


1146
00:39:14,576 --> 00:39:16,186
rights and obligations that you


1147
00:39:16,186 --> 00:39:18,416
take seriously for types and


1148
00:39:18,416 --> 00:39:19,856
application architecture.


1149
00:39:20,316 --> 00:39:22,566
Identify it, give it a name,


1150
00:39:22,846 --> 00:39:25,756
unit test it, and document its


1151
00:39:25,756 --> 00:39:27,006
semantics and performance.


1152
00:39:27,096 --> 00:39:30,556
Now, I want to close by putting


1153
00:39:30,556 --> 00:39:32,366
this advice you saw from Shawn


1154
00:39:32,366 --> 00:39:34,136
Perin in its full context.


1155
00:39:34,676 --> 00:39:37,466
"If you want to improve the code


1156
00:39:37,466 --> 00:39:39,146
quality in your organization,


1157
00:39:39,606 --> 00:39:41,586
replace all of your coding


1158
00:39:41,586 --> 00:39:44,506
standards with one goal, No Raw


1159
00:39:44,506 --> 00:39:44,976
Loops."


1160
00:39:46,386 --> 00:39:46,696
Thank you.


1161
00:39:47,516 --> 00:39:52,500
[ Applause ]

