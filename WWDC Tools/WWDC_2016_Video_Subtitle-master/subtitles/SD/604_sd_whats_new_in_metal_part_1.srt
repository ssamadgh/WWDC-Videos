1
00:00:06,516 --> 00:00:18,500
[ Music ]


2
00:00:24,626 --> 00:00:25,396
>> Morning, everyone.


3
00:00:26,696 --> 00:00:26,946
Thanks.


4
00:00:27,516 --> 00:00:30,126
[ Applause ]


5
00:00:30,626 --> 00:00:32,266
>> My name is Aaftab Munshi.


6
00:00:32,726 --> 00:00:34,966
And my colleagues and I
are really excited to share


7
00:00:34,966 --> 00:00:38,796
with you the new features in
Metal in macOS Sierra and iOS X.


8
00:00:39,276 --> 00:00:43,026
But let's begin by highlighting
the sessions we have


9
00:00:43,416 --> 00:00:45,236
on Metal this year at WWDC.


10
00:00:45,426 --> 00:00:48,256
So yesterday we had two
sessions that talked


11
00:00:48,256 --> 00:00:50,526
about adopting Metal
in your application.


12
00:00:51,086 --> 00:00:53,116
And today we have
three sessions.


13
00:00:53,356 --> 00:00:56,296
So this session and
the two sessions


14
00:00:56,346 --> 00:00:59,296
that cover the new features in
Metal, which is then followed


15
00:00:59,296 --> 00:01:01,076
by another session
where we'll talk


16
00:01:01,076 --> 00:01:03,136
about optimizing
your Metal shaders.


17
00:01:03,706 --> 00:01:04,736
All right.


18
00:01:04,736 --> 00:01:10,426
So let's look at the features
we're going to talk about.


19
00:01:10,546 --> 00:01:13,426
So in the second session the
features we will be talking


20
00:01:13,426 --> 00:01:16,916
about are function or shader
specialization and being able


21
00:01:16,916 --> 00:01:20,106
to write to resources such
as buffers and textures


22
00:01:20,436 --> 00:01:22,266
from your fragment
and vortex shader,


23
00:01:22,766 --> 00:01:26,106
wide color using wide color
displays in your application


24
00:01:26,106 --> 00:01:29,136
and texture assets, and some
new additions we've added


25
00:01:29,136 --> 00:01:32,656
to Metal performance shaders,
specifically using axillary


26
00:01:32,656 --> 00:01:34,656
and [inaudible] networks
on the GPU with Metal.


27
00:01:35,226 --> 00:01:39,366
In this session we're
going to talk about some


28
00:01:39,366 --> 00:01:41,686
of the improvements we
have added to Tools,


29
00:01:41,686 --> 00:01:43,326
which we think you guys
are going to really love.


30
00:01:43,956 --> 00:01:45,346
We've also made resource heaps


31
00:01:45,486 --> 00:01:47,786
and resource allocations
much faster


32
00:01:48,206 --> 00:01:49,256
and given you more control.


33
00:01:49,376 --> 00:01:51,016
So we'll talk about
that resource heaps


34
00:01:51,016 --> 00:01:52,146
and memoryless render targets.


35
00:01:52,636 --> 00:01:54,396
And I'm going to be
talking about tessellation.


36
00:01:54,766 --> 00:01:55,556
So let's begin.


37
00:01:56,256 --> 00:01:56,946
All right.


38
00:01:57,026 --> 00:02:01,376
So the first thing, let's spend
a little bit of time trying


39
00:02:01,376 --> 00:02:03,766
to understand why we
need tessellation.


40
00:02:04,256 --> 00:02:08,686
So we are seeing applications
such as games rendering more


41
00:02:08,686 --> 00:02:10,256
and more realistic
visual content.


42
00:02:10,606 --> 00:02:13,136
So what that means is in
order to render such content,


43
00:02:13,136 --> 00:02:15,266
we need to be able to
send detailed amount


44
00:02:15,266 --> 00:02:16,746
of geometry to the GPU.


45
00:02:16,836 --> 00:02:18,366
That's where we're going
to send this input.


46
00:02:19,076 --> 00:02:21,736
That means lots and lots
of triangles that have


47
00:02:21,736 --> 00:02:24,246
to be processed, which
means a large increase


48
00:02:24,246 --> 00:02:24,916
in memory bandwidth.


49
00:02:25,286 --> 00:02:26,776
It would be really nice


50
00:02:27,526 --> 00:02:31,076
if instead we could just
describe this geometry


51
00:02:31,076 --> 00:02:33,756
that we want to send to the GPU
as a lower resolution model,


52
00:02:34,006 --> 00:02:38,526
call it a core smash, and
then have the GPU generate the


53
00:02:38,526 --> 00:02:39,516
high-resolution model.


54
00:02:39,886 --> 00:02:42,756
So in fact, that's
what tessellation does.


55
00:02:43,486 --> 00:02:45,886
Tessellation is a technique
that you can use to amplify


56
00:02:45,886 --> 00:02:48,616
and refine the details
of your geometric object.


57
00:02:49,006 --> 00:02:51,416
We have two important
requirements we need to meet.


58
00:02:51,986 --> 00:02:55,276
The first is that the
high-resolution model,


59
00:02:55,276 --> 00:02:58,456
the triangles that are
generated do not get stored


60
00:02:58,456 --> 00:02:59,226
in graphics memory.


61
00:02:59,266 --> 00:03:00,976
We don't want to pay
that bandwidth cost.


62
00:03:01,066 --> 00:03:03,716
And the second is a
method that's used needs


63
00:03:03,716 --> 00:03:04,396
to be programmable.


64
00:03:04,666 --> 00:03:06,756
So let's look at an example.


65
00:03:06,756 --> 00:03:10,726
So here is a screenshot
from GFXBench 4.0,


66
00:03:10,926 --> 00:03:12,516
which is a benchmark
released by [inaudible].


67
00:03:12,516 --> 00:03:15,656
And one of the key features
it focuses on is tessellation.


68
00:03:15,836 --> 00:03:16,926
So here's a screenshot


69
00:03:16,926 --> 00:03:19,666
of the car that's being
rendered without tessellation.


70
00:03:19,786 --> 00:03:20,816
You can see those rims.


71
00:03:21,616 --> 00:03:22,396
They're very polygonal.


72
00:03:22,396 --> 00:03:23,856
You wouldn't drive a car
like that, would you?


73
00:03:24,946 --> 00:03:27,676
Even the body panels
have cracks in them.


74
00:03:28,076 --> 00:03:32,296
And the reason for that is this
is the actual geometry that's


75
00:03:32,296 --> 00:03:32,986
being sent.


76
00:03:32,986 --> 00:03:36,076
So you can see not a lot of
triangles, which is great --


77
00:03:36,076 --> 00:03:38,076
it's exactly what we want.


78
00:03:38,566 --> 00:03:41,356
What tessellation does is
takes that input geometry


79
00:03:41,356 --> 00:03:42,896
and produces something
like that.


80
00:03:44,336 --> 00:03:46,376
I think this is really cool.


81
00:03:46,706 --> 00:03:48,686
So if you look at
the wire frame,


82
00:03:49,016 --> 00:03:51,136
you can see the GPUs
actually generating,


83
00:03:51,136 --> 00:03:53,736
now we're rendering lots
and lots of triangles, okay?


84
00:03:53,736 --> 00:03:55,186
And that's the power
of tessellation.


85
00:03:55,866 --> 00:03:56,276
All right.


86
00:03:56,276 --> 00:03:58,976
So let's look at how
tessellation works in Metal.


87
00:03:59,846 --> 00:04:04,186
So just like we did
with Metal, you know,


88
00:04:04,186 --> 00:04:07,506
we wanted to take a clean
sheet approach, right?


89
00:04:07,506 --> 00:04:09,396
We wanted to design
something that was --


90
00:04:09,816 --> 00:04:11,716
even though there
are existing API's


91
00:04:11,886 --> 00:04:14,636
that do support tessellation
that you may be familiar with,


92
00:04:14,936 --> 00:04:17,926
we wanted something that
was really simple to graph,


93
00:04:18,046 --> 00:04:20,366
you know, easy to use,
and we did not want


94
00:04:20,366 --> 00:04:21,755
to leave any performance
on the table.


95
00:04:23,016 --> 00:04:25,676
And we think we have achieved
that, and I hope you agree


96
00:04:25,746 --> 00:04:26,816
after this presentation.


97
00:04:27,826 --> 00:04:31,736
So tessellation is available
in macOS Sierra and on iOS


98
00:04:32,086 --> 00:04:33,196
with the A9 processor.


99
00:04:33,296 --> 00:04:34,066
All right.


100
00:04:34,066 --> 00:04:37,396
So let's -- the things I'm
going to talk about is well,


101
00:04:37,596 --> 00:04:39,586
how does the Metal
graphics pipeline look


102
00:04:39,586 --> 00:04:40,956
like for tessellation?


103
00:04:41,556 --> 00:04:43,566
How do I render my
geometry with tessellation?


104
00:04:43,566 --> 00:04:45,816
And then how do I adopt
it in my application?


105
00:04:46,266 --> 00:04:46,866
So let's begin.


106
00:04:47,726 --> 00:04:51,796
So today when you send
primitives to the GPU


107
00:04:51,796 --> 00:04:55,696
with Metal, you're sending
triangles, lines, or points.


108
00:04:56,186 --> 00:04:59,016
With tessellation, you're
sending what we call a patch.


109
00:04:59,726 --> 00:05:02,916
And put simply, a patch is
just a parametric surface


110
00:05:03,376 --> 00:05:04,856
that is made up of
spline curves.


111
00:05:04,856 --> 00:05:05,576
What does that mean?


112
00:05:05,576 --> 00:05:06,416
You may have heard of things


113
00:05:06,416 --> 00:05:08,686
like Bezier patches
or B-spline patches.


114
00:05:09,166 --> 00:05:12,476
So you describe a patch by
a set of control-points.


115
00:05:12,476 --> 00:05:16,256
So in this figure you
see is a B-spline patch.


116
00:05:16,256 --> 00:05:19,666
So you have 16 control-points
or control vertices.


117
00:05:20,316 --> 00:05:25,096
And what tessellation does put
simply is allows you to control,


118
00:05:25,156 --> 00:05:28,676
okay, how many triangles do
I use to render this patch?


119
00:05:28,786 --> 00:05:30,056
So you may decide,
"You know what?


120
00:05:30,296 --> 00:05:31,676
I don't really want
a lot of triangles.


121
00:05:31,736 --> 00:05:33,186
I don't care how it looks."


122
00:05:33,186 --> 00:05:36,386
So you may decide just four
triangles is more than enough


123
00:05:36,386 --> 00:05:37,826
and you'll get a polygonal look.


124
00:05:38,456 --> 00:05:41,446
Or you decide, "Hey, I
really want this looking nice


125
00:05:41,446 --> 00:05:41,976
and smooth."


126
00:05:43,296 --> 00:05:44,466
That would take a
lot more triangles.


127
00:05:44,686 --> 00:05:46,266
But you have that control.


128
00:05:47,086 --> 00:05:48,726
So let's start.


129
00:05:48,936 --> 00:05:51,256
So the first stage in
the graphics pipeline


130
00:05:51,256 --> 00:05:53,146
when we're doing
tessellation is we call it a


131
00:05:53,146 --> 00:05:54,096
tessellation kernel.


132
00:05:54,666 --> 00:05:56,576
And what it does is
it takes the patch --


133
00:05:56,576 --> 00:05:59,016
we talked about the patch with
the control-points as input --


134
00:05:59,436 --> 00:06:02,816
and decides, okay, how much
do I need to subdivide this?


135
00:06:03,146 --> 00:06:05,866
How many triangles do I want
the GPU to generate, right?


136
00:06:06,256 --> 00:06:09,066
This information is
captured in what we call


137
00:06:09,066 --> 00:06:10,246
as tessellation factors.


138
00:06:10,396 --> 00:06:11,396
And I'll talk a little bit


139
00:06:11,396 --> 00:06:14,056
about what these factors
are a few slides later.


140
00:06:15,006 --> 00:06:18,346
And you can also generate
additional patch data


141
00:06:18,346 --> 00:06:20,196
if you need it in a later stage.


142
00:06:20,426 --> 00:06:22,256
The key thing this is
a programmable stage,


143
00:06:22,256 --> 00:06:24,676
that means you're writing code.


144
00:06:24,856 --> 00:06:27,376
So once you've written
[inaudible] tessellation


145
00:06:27,376 --> 00:06:30,276
factors, the next stage
is called the tessellator.


146
00:06:30,846 --> 00:06:32,336
So this is a fixed
function stage.


147
00:06:32,516 --> 00:06:33,556
So no code to write.


148
00:06:33,786 --> 00:06:37,266
But you do net knobs
to configure it, okay?


149
00:06:37,506 --> 00:06:39,296
So it takes those
tessellation factors


150
00:06:39,856 --> 00:06:42,046
and breaks the patch
up into triangles.


151
00:06:42,766 --> 00:06:45,126
And the key thing the
tessellator does here is


152
00:06:45,126 --> 00:06:46,576
that it does not store


153
00:06:46,936 --> 00:06:49,216
that triangle list it
generates in graphics memory.


154
00:06:49,996 --> 00:06:52,526
In addition to the triangle
list it has generated,


155
00:06:52,786 --> 00:06:56,146
for each vertex in the triangle
list it will generate what we


156
00:06:56,146 --> 00:06:58,936
call a parametric coordinate
-- the U and the V value.


157
00:06:59,296 --> 00:07:02,656
And it uses this along
with the control-points


158
00:07:03,026 --> 00:07:05,946
to compute the actual
position on the surface.


159
00:07:05,946 --> 00:07:07,156
Okay? All right.


160
00:07:07,156 --> 00:07:09,316
So the tessellator
generates triangles.


161
00:07:09,316 --> 00:07:13,666
Today in Metal when you
want to render primitives,


162
00:07:13,906 --> 00:07:15,806
you send triangles to the GPU.


163
00:07:16,246 --> 00:07:17,316
What is the first thing


164
00:07:17,316 --> 00:07:20,876
that happens is a vertex
shader is executed, right?


165
00:07:21,136 --> 00:07:23,196
Well, here the tessellator's
generating triangles.


166
00:07:23,196 --> 00:07:25,966
So if you think logically,


167
00:07:25,966 --> 00:07:29,316
the next stage would be a
vertex shader, and it is.


168
00:07:29,546 --> 00:07:32,446
We just call it the
post-tessellation vertex shader


169
00:07:32,446 --> 00:07:34,786
because it's operating
on the triangles


170
00:07:34,786 --> 00:07:36,426
that are generated
by the tessellator.


171
00:07:37,036 --> 00:07:40,876
And so it's going to execute for
the vertices of the triangles


172
00:07:41,126 --> 00:07:43,426
that the tessellator
generated and it's going


173
00:07:43,426 --> 00:07:45,846
to output transform positions.


174
00:07:46,026 --> 00:07:48,076
So if you're familiar
with DirectX,


175
00:07:48,206 --> 00:07:50,906
it's this shader plays
the same, similar role


176
00:07:50,906 --> 00:07:53,776
as the domain shader
does in DirectX.


177
00:07:55,046 --> 00:07:55,316
All right.


178
00:07:55,316 --> 00:07:57,536
And then the rest of the
pipeline remains the same.


179
00:07:57,536 --> 00:07:59,776
We have the rasterizer and
the fragment shader, right?


180
00:08:00,136 --> 00:08:03,736
So you may ask, "Well, so I need
to write this compute kernel


181
00:08:03,736 --> 00:08:05,296
to generate the tessellation
factors.


182
00:08:05,816 --> 00:08:08,016
Well, can I use the
vertex or fragment shader?"


183
00:08:08,536 --> 00:08:09,386
Of course you can.


184
00:08:09,926 --> 00:08:12,816
In fact, you don't even
need to write a shader


185
00:08:12,816 --> 00:08:15,456
to generate these factors;
you may have precomputed them


186
00:08:15,856 --> 00:08:17,666
and you can just load
them in a buffer and pass


187
00:08:17,696 --> 00:08:18,566
that to the tessellator.


188
00:08:18,566 --> 00:08:19,936
So you have a lot of control.


189
00:08:20,306 --> 00:08:25,016
But if you are generating these
factors in the GPU, we recommend


190
00:08:25,016 --> 00:08:26,076
that you use a compute kernel.


191
00:08:26,076 --> 00:08:27,116
Because guess what?


192
00:08:27,496 --> 00:08:30,686
That allows us to run
that kernel asynchronously


193
00:08:30,686 --> 00:08:31,606
with other draw commands.


194
00:08:32,426 --> 00:08:33,746
So netting you a performance win


195
00:08:33,946 --> 00:08:35,806
and I think you guys
will like that.


196
00:08:36,775 --> 00:08:38,506
Well, actually let's
take it a step further.


197
00:08:39,066 --> 00:08:40,756
You don't even need to run
this kernel every frame.


198
00:08:41,346 --> 00:08:42,106
Because guess what?


199
00:08:42,566 --> 00:08:44,576
If you have computed the
tessellation factors --


200
00:08:44,576 --> 00:08:46,726
let's say you decide,
"Hey, objects close


201
00:08:46,726 --> 00:08:49,186
to the camera get much
more tessellation,


202
00:08:49,546 --> 00:08:51,666
objects further away
not as much."


203
00:08:51,886 --> 00:08:53,806
So once I've computed
them, then depending


204
00:08:53,806 --> 00:08:56,676
on how the object is moving,
I can just apply a scale


205
00:08:57,116 --> 00:08:58,456
and the tessellator takes that.


206
00:08:58,456 --> 00:09:01,266
So really, the pipeline
is really, really simple.


207
00:09:01,266 --> 00:09:02,946
We have four stages.


208
00:09:03,406 --> 00:09:05,936
So let's compare it with
the graphics pipeline


209
00:09:05,936 --> 00:09:06,806
without tessellation.


210
00:09:08,096 --> 00:09:09,666
So without tessellation
we have three stages --


211
00:09:10,416 --> 00:09:12,536
we have vertex shade,
the rasterizer,


212
00:09:12,626 --> 00:09:13,456
and the fragment stage.


213
00:09:13,686 --> 00:09:16,466
With tessellation we added a
new stage, the tessellator.


214
00:09:16,466 --> 00:09:18,886
It's fixed function so you
don't have to write any shader.


215
00:09:19,466 --> 00:09:22,256
And the vertex shader became the
post-tessellation vertex shader.


216
00:09:23,396 --> 00:09:26,016
We think this is really
simple to understand.


217
00:09:26,156 --> 00:09:28,306
I hope you agree.


218
00:09:28,876 --> 00:09:29,556
All right.


219
00:09:29,556 --> 00:09:31,956
So how do I render my
geometry with tessellation?


220
00:09:32,746 --> 00:09:34,596
There are four things
I'm going to talk about.


221
00:09:35,166 --> 00:09:37,226
Okay. Let's look at
this post-tessellation


222
00:09:37,226 --> 00:09:39,986
or post-tess vertex shader;
how is this different


223
00:09:39,986 --> 00:09:41,186
from the regular vertex shader?


224
00:09:41,686 --> 00:09:43,386
How do I pass my patch inputs?


225
00:09:43,756 --> 00:09:46,306
And I told you that the
tessellator's configurable.


226
00:09:46,306 --> 00:09:48,046
So let's look at
how we configure it


227
00:09:48,046 --> 00:09:48,876
and then draw patches.


228
00:09:50,886 --> 00:09:53,166
So, well, meet the new shader,
same with the old shader.


229
00:09:53,406 --> 00:09:56,266
So in fact, you declare a
post-tessellation vertex shader


230
00:09:56,266 --> 00:09:57,356
with a vertex qualifier.


231
00:09:57,356 --> 00:10:01,536
But in addition to that, you
also specify this attribute


232
00:10:01,536 --> 00:10:03,286
which says, "Hey, it's
working on a patch."


233
00:10:03,536 --> 00:10:06,646
There are two kinds of patches
-- a quad and triangle patch.


234
00:10:06,726 --> 00:10:08,186
And you see the number
next to that?


235
00:10:08,186 --> 00:10:11,586
That number tells you how many
control-points this patch is


236
00:10:11,586 --> 00:10:12,056
working on.


237
00:10:13,006 --> 00:10:15,116
So if you had a regular
vertex shader,


238
00:10:15,146 --> 00:10:17,296
you would have passed
a vertex ideas input.


239
00:10:17,796 --> 00:10:19,836
Now you pass a patchID as input.


240
00:10:20,536 --> 00:10:22,936
Remember I told you the
tessellator generated a


241
00:10:22,936 --> 00:10:24,936
parametric UV coordinate?


242
00:10:25,006 --> 00:10:28,106
Well, that's what this
position in patch input is.


243
00:10:28,646 --> 00:10:31,266
And then if you had a
regular vertex shader,


244
00:10:31,266 --> 00:10:33,236
you would have passed
something as stage in,


245
00:10:33,506 --> 00:10:35,416
the patch input we
passed at the stage in.


246
00:10:36,016 --> 00:10:37,636
Everything else you
just bring computations


247
00:10:37,696 --> 00:10:40,936
and you're generating a
transformed vertex output.


248
00:10:40,936 --> 00:10:43,676
And that's actually going
to be exactly identical


249
00:10:43,676 --> 00:10:45,266
because the next stage with


250
00:10:45,266 --> 00:10:48,326
or without tessellation
is a rasterizer.


251
00:10:50,316 --> 00:10:50,636
All right.


252
00:10:50,636 --> 00:10:51,806
So let's look at patch inputs.


253
00:10:52,616 --> 00:10:55,056
So if you had a regular
vertex shader,


254
00:10:55,246 --> 00:10:57,176
you would have described
your vertex input


255
00:10:57,176 --> 00:10:59,326
as a struct, okay,
in your shader.


256
00:10:59,396 --> 00:11:03,026
And if you had decoupled the
date type, that means the layout


257
00:11:03,026 --> 00:11:05,246
and the buffers where the
vertex inputs are coming


258
00:11:05,246 --> 00:11:08,176
from do not match the
declaration in the shader,


259
00:11:08,176 --> 00:11:10,326
then you would have used
the MTLVertexDescriptor


260
00:11:10,326 --> 00:11:12,116
to describe the layout.


261
00:11:12,576 --> 00:11:14,946
Well, for patches
there are two inputs.


262
00:11:15,096 --> 00:11:17,336
One is the per-patch input.


263
00:11:17,746 --> 00:11:20,666
And remember, I told there are
one or more control-points?


264
00:11:21,096 --> 00:11:23,476
So we need to specify
those as inputs as well.


265
00:11:23,866 --> 00:11:27,466
But it looks identical
how you specify these.


266
00:11:27,716 --> 00:11:31,356
So you use a MTLVertexDescriptor
to specify the layout


267
00:11:31,356 --> 00:11:33,656
of the patch input
data in memory.


268
00:11:34,186 --> 00:11:37,246
And as I showed you the slide
before, we declared that input


269
00:11:37,246 --> 00:11:38,256
as a stage in as well.


270
00:11:38,776 --> 00:11:43,376
And you use the attribute index
to identify an element as input


271
00:11:43,376 --> 00:11:46,036
in the shader with the
corresponding declaration


272
00:11:46,376 --> 00:11:47,926
in your MTLVertexDescriptor.


273
00:11:49,136 --> 00:11:53,906
Since there can be more than one
control-point, we basically have


274
00:11:53,906 --> 00:11:55,686
to declare it using
a template type.


275
00:11:55,686 --> 00:11:57,546
And I'll talk about
that in the next slide.


276
00:11:57,546 --> 00:11:58,656
So let's look at an example.


277
00:11:58,656 --> 00:12:00,906
So here I have my
control-point data.


278
00:12:01,036 --> 00:12:02,096
It has two elements.


279
00:12:02,346 --> 00:12:04,086
So I'm using attributes
zero and one.


280
00:12:04,966 --> 00:12:07,846
And my per-patch data, which
is attributes two and three.


281
00:12:08,256 --> 00:12:09,926
So we combine these
two things together


282
00:12:09,926 --> 00:12:12,526
and this is my patch
input for every patch.


283
00:12:13,086 --> 00:12:16,386
So notice that control templated
type patch underscore control


284
00:12:16,386 --> 00:12:17,096
underscore point.


285
00:12:17,556 --> 00:12:20,316
So that's what tells the
Metal shading compiler "Hey,


286
00:12:20,316 --> 00:12:21,916
this is referring to
control-point input."


287
00:12:22,346 --> 00:12:25,286
Okay? And remember I told
you about this number 16


288
00:12:25,286 --> 00:12:26,436
or whatever the number is?


289
00:12:26,886 --> 00:12:29,286
That also tells the Metal
shading compiler how many


290
00:12:29,286 --> 00:12:30,326
control-points there are.


291
00:12:30,866 --> 00:12:34,626
So now we have all information
we need to get the patch input.


292
00:12:35,156 --> 00:12:36,846
And so we just pass
that as stage in.


293
00:12:37,776 --> 00:12:41,276
It's pretty simple, I think.


294
00:12:42,216 --> 00:12:42,516
All right.


295
00:12:43,526 --> 00:12:45,546
So okay, how do I
configure knobs?


296
00:12:45,716 --> 00:12:46,856
So there are properties


297
00:12:46,856 --> 00:12:49,026
in the
MTLRenderPipelineDescriptor you


298
00:12:49,026 --> 00:12:49,436
can set.


299
00:12:49,986 --> 00:12:54,476
A few examples are you can tell
the tessellator the method you


300
00:12:54,476 --> 00:12:56,566
want to use to generate
the triangles;


301
00:12:56,566 --> 00:12:57,886
it's called the partitioning
mode.


302
00:12:58,656 --> 00:13:01,696
You can also specify a
max tessellation level.


303
00:13:02,016 --> 00:13:04,926
And we think this is
really, really useful


304
00:13:04,926 --> 00:13:08,186
because it allows you to control
the maximum amount of geometry


305
00:13:08,526 --> 00:13:10,976
that the GPU will generate
for your tessellated objects.


306
00:13:11,696 --> 00:13:14,996
Remember, the tessellator
needs to read these factors.


307
00:13:15,256 --> 00:13:17,396
So you need to specify the
buffer of where they come from.


308
00:13:17,856 --> 00:13:21,016
So use the
setTessellationFactorBuffer API


309
00:13:21,646 --> 00:13:22,116
to do that.


310
00:13:22,336 --> 00:13:26,416
Now, these factors,
so they tell how much


311
00:13:26,456 --> 00:13:30,046
to subdivide the patches along
the edges and on the inside.


312
00:13:30,536 --> 00:13:32,206
So we have two kinds of patches.


313
00:13:32,206 --> 00:13:33,536
If it's a triangular patch,


314
00:13:33,666 --> 00:13:35,756
there are three edges
and one inside.


315
00:13:36,186 --> 00:13:39,616
If it's a quad, then you have
four edges and two insides.


316
00:13:39,616 --> 00:13:43,516
So you specify these as half
precision floating point values


317
00:13:43,846 --> 00:13:45,156
that you pass in.


318
00:13:47,466 --> 00:13:48,376
And then drawing.


319
00:13:48,776 --> 00:13:51,586
So today when you're
drawing primitives,


320
00:13:51,926 --> 00:13:53,866
you're sending triangles
to be rendered by the GPU,


321
00:13:54,216 --> 00:13:55,736
you're either going
to call drawPrimitives


322
00:13:56,056 --> 00:13:57,406
or drawIndexPrimitives.


323
00:13:57,986 --> 00:14:00,996
You the specify the start
vertex, number of vertices.


324
00:14:01,406 --> 00:14:03,776
And if your vertex
indexes are not continuous,


325
00:14:03,836 --> 00:14:05,236
you will pass an index buffer.


326
00:14:05,766 --> 00:14:08,006
Well, to draw patches,
you call drawPatches


327
00:14:08,766 --> 00:14:09,896
or drawIndexedPatches.


328
00:14:10,246 --> 00:14:13,216
You specify the start patch,
the number of patches.


329
00:14:13,216 --> 00:14:15,886
And if you're control-point
indexes are not continuous,


330
00:14:16,016 --> 00:14:17,336
you specify an index buffer.


331
00:14:17,596 --> 00:14:18,946
So it's just a one-to-one
mapping.


332
00:14:19,556 --> 00:14:22,716
And then there is the
DrawIndirect variants.


333
00:14:23,176 --> 00:14:25,576
And what these are is
that you do not specify


334
00:14:25,996 --> 00:14:28,076
where the start patch
and how many patches


335
00:14:28,306 --> 00:14:31,136
and other information when
you make the draw call,


336
00:14:31,306 --> 00:14:32,636
but instead you pass a buffer.


337
00:14:33,516 --> 00:14:35,896
And that gets filled out
with this information


338
00:14:35,896 --> 00:14:38,746
by a command that's running on
the GPU, just like you would do


339
00:14:38,746 --> 00:14:39,756
for drawPrimitives as well.


340
00:14:40,436 --> 00:14:43,336
So really, if you don't know
how to use drawPrimitives,


341
00:14:43,836 --> 00:14:46,846
then drawPatches just
works very similarly.


342
00:14:47,076 --> 00:14:49,216
Okay? So we think this
is really easy to use.


343
00:14:49,936 --> 00:14:50,676
All right?


344
00:14:51,616 --> 00:14:55,976
So hold on.


345
00:14:57,466 --> 00:15:00,386
So I've shown you what
Metal tessellation is


346
00:15:00,646 --> 00:15:02,446
and how to use it.


347
00:15:02,796 --> 00:15:05,366
As many of you may
be familiar with


348
00:15:05,366 --> 00:15:09,376
or already using tessellation in
your application using DirectX


349
00:15:09,846 --> 00:15:12,526
or OpenGL, you will notice
Metal tessellation's a


350
00:15:12,526 --> 00:15:13,106
little different.


351
00:15:13,596 --> 00:15:14,146
Don't worry.


352
00:15:14,516 --> 00:15:15,816
We've designed Metal
tessellation


353
00:15:15,966 --> 00:15:17,326
so it's incredibly
straightforward


354
00:15:17,326 --> 00:15:19,916
to move your existing
tessellation code to Metal.


355
00:15:20,296 --> 00:15:23,736
As an example, for the past
few weeks we've been working


356
00:15:23,736 --> 00:15:24,326
with Unity.


357
00:15:24,896 --> 00:15:28,026
And in an incredibly short
period of time they've been able


358
00:15:28,026 --> 00:15:30,666
to integrate Metal
Tessellation in the engine.


359
00:15:30,996 --> 00:15:34,836
And here's what they
have to say.


360
00:15:35,076 --> 00:15:38,916
So we're really excited that
support for Metal Tessellation,


361
00:15:39,226 --> 00:15:42,296
Metal Compute and the ability
to write native Metal shaders


362
00:15:42,296 --> 00:15:43,756
in Unity's coming
later this year.


363
00:15:44,066 --> 00:15:46,266
It's incredibly exciting.


364
00:15:46,596 --> 00:15:48,666
And we've also been
working with Epic


365
00:15:49,386 --> 00:15:52,546
to efficiently integrate Metal
Tessellation in Unreal Engine 4.


366
00:15:53,336 --> 00:15:56,546
And Epic is planning to
release their support


367
00:15:56,656 --> 00:15:58,836
in UE4 later this year, okay?


368
00:16:00,176 --> 00:16:04,226
So we have UE4, we have Unity
supporting Metal Tessellation.


369
00:16:04,716 --> 00:16:09,516
Well, let me show you
tessellation in action


370
00:16:09,916 --> 00:16:11,316
in these game engines


371
00:16:11,316 --> 00:16:15,106
by demonstrating two commonly
used rendering techniques called


372
00:16:15,106 --> 00:16:18,276
adaptive tessellation
and displacement mapping.


373
00:16:19,906 --> 00:16:21,226
All right.


374
00:16:25,056 --> 00:16:31,786
So here we have a
simple demo developed


375
00:16:31,786 --> 00:16:35,126
by a few Apple engineers
using Unreal Engine 4.


376
00:16:35,196 --> 00:16:37,466
So let's turn tessellation
off, which I have,


377
00:16:37,566 --> 00:16:38,776
and get wire frame mode.


378
00:16:39,276 --> 00:16:40,486
You can see there are not a lot


379
00:16:40,486 --> 00:16:42,506
of triangles being
sent to the GPU.


380
00:16:42,506 --> 00:16:43,446
This is great.


381
00:16:43,446 --> 00:16:44,546
This is exactly what we want.


382
00:16:44,546 --> 00:16:46,816
We want to keep the amount of
geometry we send to the GPU


383
00:16:46,816 --> 00:16:48,146
to be as little as possible.


384
00:16:48,596 --> 00:16:51,056
Let's turn tessellation
on and see what happens.


385
00:16:52,246 --> 00:16:55,356
You can see now the GPU is
generating a lot more triangles.


386
00:16:56,156 --> 00:16:59,066
And adaptive tessellation
is a technique that allows


387
00:16:59,066 --> 00:17:02,006
to control the geometric
detail where it matters.


388
00:17:02,226 --> 00:17:05,415
So in this example we've decided
that objects that are closer


389
00:17:05,415 --> 00:17:06,906
to the camera need more detail.


390
00:17:07,286 --> 00:17:09,185
So let's draw them with
a lot more triangles


391
00:17:09,185 --> 00:17:11,086
versus objects further
away do not.


392
00:17:11,415 --> 00:17:15,836
So the regions in blue represent
regions of lowest amount


393
00:17:15,836 --> 00:17:18,646
of tessellation, and the region
in red represents the regions


394
00:17:18,646 --> 00:17:19,876
with the highest
amount of tessellation.


395
00:17:19,876 --> 00:17:22,236
I can show you as I move
the slider to the right,


396
00:17:22,465 --> 00:17:24,425
I can use that to increase
my tessellation level


397
00:17:24,425 --> 00:17:27,266
and you can see objects
closer will become red.


398
00:17:27,715 --> 00:17:30,556
Okay? Well, let's turn
wire frame mode off.


399
00:17:31,416 --> 00:17:34,196
And if you run -- as we
go through this cave,


400
00:17:34,556 --> 00:17:36,506
you can see there's a
lot more detail, right?


401
00:17:36,506 --> 00:17:40,226
If I turn tessellation off, all
that detail is gone, it's lost.


402
00:17:41,106 --> 00:17:43,976
Turn tessellation on,
it looks really amazing.


403
00:17:44,356 --> 00:17:49,526
So this is an example of
how I can use tessellation


404
00:17:50,396 --> 00:17:53,826
to really create rich visual
scenes in my application.


405
00:17:54,346 --> 00:17:56,886
And I wanted to thank
the great folks at Epic


406
00:17:56,886 --> 00:17:57,846
for making this happen.


407
00:17:58,776 --> 00:18:09,646
So the next demo is displacement
mapping running on Unity.


408
00:18:10,156 --> 00:18:11,816
So here we have a
sphere being rendered.


409
00:18:12,436 --> 00:18:14,256
Well, let's look at how
many triangles we're using


410
00:18:14,256 --> 00:18:15,036
to render the sphere.


411
00:18:16,416 --> 00:18:17,506
Not a lot, right?


412
00:18:17,506 --> 00:18:19,366
There are about 3,000 triangles.


413
00:18:19,836 --> 00:18:22,346
And what displacement
mapping is, is a technique


414
00:18:22,346 --> 00:18:25,706
that allows you to
displace the geometry


415
00:18:26,056 --> 00:18:27,706
to create incredible detail.


416
00:18:28,216 --> 00:18:30,416
And it does that
by looking up --


417
00:18:30,736 --> 00:18:33,646
using a displacement
map, which is a texture.


418
00:18:33,646 --> 00:18:36,426
So you look up, you know, from
a texture, from this texture


419
00:18:36,426 --> 00:18:39,126
and then use that to
[inaudible] the vertex position.


420
00:18:39,526 --> 00:18:41,706
Or you may actually do this
procedurally if you wanted to.


421
00:18:42,306 --> 00:18:45,846
But displacement mapping
requires that, you know,


422
00:18:45,846 --> 00:18:48,166
you're drawing lots and
lots of really, really,


423
00:18:48,166 --> 00:18:49,496
really small triangles.


424
00:18:49,636 --> 00:18:50,466
Otherwise it doesn't work.


425
00:18:50,466 --> 00:18:52,106
It creates artifacts,
it just cracks.


426
00:18:52,606 --> 00:18:53,826
But that's fine, you know?


427
00:18:53,826 --> 00:18:54,706
We can use tessellation.


428
00:18:54,706 --> 00:18:55,516
That's what it's here for.


429
00:18:55,896 --> 00:18:58,426
Because we still want
to send 3,000 triangles,


430
00:18:58,426 --> 00:18:59,786
smaller triangles to the GPU


431
00:19:00,166 --> 00:19:01,526
and use tessellation
to generate that.


432
00:19:01,526 --> 00:19:02,776
So let's turn wire
frame mode off


433
00:19:03,206 --> 00:19:04,936
and let's turn displacement
mapping on.


434
00:19:06,286 --> 00:19:09,516
As you can see now incredible
detail on the sphere, right?


435
00:19:09,516 --> 00:19:11,036
If I turn wire frame mode on,


436
00:19:11,566 --> 00:19:14,386
you can see we're generating
a lot more triangles


437
00:19:14,516 --> 00:19:15,816
and they are really,
really small.


438
00:19:16,416 --> 00:19:18,706
In fact, let's actually
animate the displacement map


439
00:19:18,706 --> 00:19:20,576
so you can see the
shapes changing


440
00:19:20,856 --> 00:19:24,946
and let's zoom in to see detail.


441
00:19:25,156 --> 00:19:26,776
You can see self-shadowing
happening.


442
00:19:27,896 --> 00:19:30,646
And the reason self-shadowing
is happening here is


443
00:19:30,696 --> 00:19:33,206
because we're actually
changing the geometry,


444
00:19:33,616 --> 00:19:36,116
unlike a technique many
of you may be familiar


445
00:19:36,116 --> 00:19:37,026
with called bump mapping


446
00:19:37,326 --> 00:19:39,206
which just creates an
illusion of realism.


447
00:19:39,466 --> 00:19:41,526
So this is another
technique which you can use


448
00:19:41,806 --> 00:19:44,526
with tessellation to
create incredible detail


449
00:19:44,526 --> 00:19:46,256
in your application
that you're rendering.


450
00:19:46,716 --> 00:19:50,306
And hey, thank you to
Unity for this demo.


451
00:19:51,516 --> 00:19:57,786
[ Applause ]


452
00:19:58,286 --> 00:19:58,566
All right.


453
00:19:58,566 --> 00:19:58,876
So


454
00:20:05,306 --> 00:20:07,556
Metal Tessellation
can also be used


455
00:20:07,556 --> 00:20:09,846
to accelerate digital
content creation tools.


456
00:20:10,426 --> 00:20:14,586
As an example OpenSubdiv is an
open source library released


457
00:20:14,586 --> 00:20:15,016
by Pixar.


458
00:20:15,766 --> 00:20:17,856
And it implements
high-performance


459
00:20:17,856 --> 00:20:18,866
subdivision surfaces.


460
00:20:19,206 --> 00:20:21,196
Actually, it has been
integrated into a number


461
00:20:21,196 --> 00:20:23,726
of third-party digital
content creation tools,


462
00:20:24,066 --> 00:20:25,686
such as Maya from Autodesk.


463
00:20:26,716 --> 00:20:28,736
And OpenSubdiv uses tessellation


464
00:20:28,936 --> 00:20:30,656
to render these subdivision
surfaces.


465
00:20:31,316 --> 00:20:34,976
Well, we -- Apple -- have
added Metal Tessellation


466
00:20:34,976 --> 00:20:35,976
into OpenSubdiv.


467
00:20:35,976 --> 00:20:38,726
And I'm really excited to
announce here that we plan


468
00:20:38,726 --> 00:20:39,686
to release these changes


469
00:20:39,716 --> 00:20:42,746
to the OpenSubdiv open source
project later this summer.


470
00:20:42,746 --> 00:20:45,126
Okay. I mean, here's
what Pixar has to say.


471
00:20:46,576 --> 00:20:48,156
As you can see, Pixar's
really excited


472
00:20:48,156 --> 00:20:49,956
to see a native Metal
implementation


473
00:20:50,366 --> 00:20:55,976
of OpenSubdiv in iOS and macOS.


474
00:20:56,046 --> 00:20:56,246
All right.


475
00:20:56,246 --> 00:20:58,766
So now you may be asking,
"Well, what about me?


476
00:20:59,176 --> 00:21:02,346
How do I move my existing
tessellation code to Metal?"


477
00:21:02,346 --> 00:21:03,816
Well, let me show you how.


478
00:21:04,546 --> 00:21:06,216
So we'll take DirectX
an as example here,


479
00:21:06,216 --> 00:21:07,796
but the same rules
apply to OpenGL.


480
00:21:07,796 --> 00:21:11,516
So here is what the DirectX
graphics pipeline looks


481
00:21:11,516 --> 00:21:12,416
like with tessellation.


482
00:21:12,906 --> 00:21:15,516
We have three new stages --
two of them are programmable.


483
00:21:15,516 --> 00:21:17,066
They're called the hull
and the domain shader.


484
00:21:17,526 --> 00:21:19,026
And then we have this
tessellator in the middle.


485
00:21:19,136 --> 00:21:20,016
Right? So, well, okay.


486
00:21:20,056 --> 00:21:20,966
How do I move this to Metal?


487
00:21:21,396 --> 00:21:23,136
Notice where the
domain shader sits.


488
00:21:23,136 --> 00:21:24,426
It sits right after
the tessellator.


489
00:21:24,426 --> 00:21:27,396
Does it remind you of any
other shader I showed you


490
00:21:27,396 --> 00:21:28,186
in the Metal pipeline?


491
00:21:28,906 --> 00:21:30,016
Yeah, I think so.


492
00:21:30,016 --> 00:21:31,876
Yeah, post-tessellation
vertex shader.


493
00:21:31,876 --> 00:21:32,686
Because guess what?


494
00:21:33,006 --> 00:21:33,786
The domain shader


495
00:21:34,126 --> 00:21:37,206
with tessellation really
becomes the new vertex shader.


496
00:21:37,836 --> 00:21:41,236
And just like you can
very easily move your HLSL


497
00:21:41,416 --> 00:21:44,096
or GLSL vertex functions
to Metal,


498
00:21:44,566 --> 00:21:47,076
you can move these domain
shaders pretty easily


499
00:21:47,346 --> 00:21:49,516
to the post-tessellation
vertex shader.


500
00:21:49,936 --> 00:21:52,396
The tessellator is exactly
the same, no changes.


501
00:21:52,966 --> 00:21:55,306
So really, we have this
guy, these two shaders,


502
00:21:55,716 --> 00:21:56,816
the vertex and hull shader.


503
00:21:57,026 --> 00:21:58,606
And we got to make
them into a kernel.


504
00:21:58,746 --> 00:22:02,056
Okay. Let's look at
how we can do that.


505
00:22:02,206 --> 00:22:06,726
So let's look at some --
since we have a vertex shader,


506
00:22:07,376 --> 00:22:10,566
that means there's probably
a vertex descriptor described


507
00:22:10,946 --> 00:22:12,616
at runtime by the application.


508
00:22:13,366 --> 00:22:16,426
And that means -- because
the data's probably going


509
00:22:16,426 --> 00:22:17,046
to be decoupled.


510
00:22:17,046 --> 00:22:19,416
So that means I need
to declare stage in.


511
00:22:19,606 --> 00:22:22,186
But I don't do stage
in in a kernel.


512
00:22:22,386 --> 00:22:24,146
Right? Well, now you can.


513
00:22:24,426 --> 00:22:25,516
We've added support for it.


514
00:22:25,926 --> 00:22:28,506
So just like in a vertex
shader you use stage


515
00:22:28,506 --> 00:22:31,946
in to say this is my vertex
input, you can use stage


516
00:22:31,946 --> 00:22:34,496
in to say this my
per thread input.


517
00:22:34,896 --> 00:22:37,986
And you can specify
the actual data layout


518
00:22:38,536 --> 00:22:40,926
in a MTLStage
inputOutputDescriptor.


519
00:22:41,136 --> 00:22:42,416
It behaves identically.


520
00:22:42,416 --> 00:22:44,956
It's very similar to
a MTLVertexDescriptor.


521
00:22:45,166 --> 00:22:49,036
Some of the things you
specify are a little different


522
00:22:49,036 --> 00:22:54,106
because this is for
compute, not for vertex.


523
00:22:56,206 --> 00:23:00,106
And then two things to observe.


524
00:23:00,276 --> 00:23:02,546
With tessellation
DirectX or OpenGL,


525
00:23:02,956 --> 00:23:06,296
the vertex shader executes on
the control-point of a patch.


526
00:23:06,836 --> 00:23:09,996
And the hull shader has
these two functions.


527
00:23:10,386 --> 00:23:13,056
One that executes on a
control-point and one


528
00:23:13,056 --> 00:23:14,146
that executes on a patch.


529
00:23:14,656 --> 00:23:17,226
The per-patch hull function is
what actually generates your


530
00:23:17,226 --> 00:23:18,186
tessellation factors.


531
00:23:18,696 --> 00:23:19,016
All right.


532
00:23:19,436 --> 00:23:20,796
So the best thing to do?


533
00:23:20,796 --> 00:23:23,186
Translate all these three
functions to Metal functions.


534
00:23:23,606 --> 00:23:24,946
And then we'll write
a Metal kernel


535
00:23:24,946 --> 00:23:26,476
that will call these functions.


536
00:23:26,736 --> 00:23:28,366
But don't worry, we're not
going to make function calls.


537
00:23:28,846 --> 00:23:30,376
The Metal compiler
will in-line these.


538
00:23:30,576 --> 00:23:34,136
Okay? So let's look
at how this works.


539
00:23:34,136 --> 00:23:36,106
So each thread basically
is going


540
00:23:36,106 --> 00:23:39,166
to call the control-point
function for the vertex


541
00:23:39,166 --> 00:23:40,466
and for the hull, right?


542
00:23:40,466 --> 00:23:42,526
So let's say there
were 16 control-points.


543
00:23:42,926 --> 00:23:44,896
So the first thread
calls the vertex


544
00:23:45,066 --> 00:23:46,346
and control-point hull function,


545
00:23:46,866 --> 00:23:49,736
second thread does the
same thing, and so on.


546
00:23:49,736 --> 00:23:52,856
Right? And any intermittent data
that they produce that they want


547
00:23:52,856 --> 00:23:55,206
to share, they'll put that
in thread group memory,


548
00:23:55,206 --> 00:23:57,756
which is this local memory


549
00:23:57,756 --> 00:24:00,376
which is high-performance,
very low-latency.


550
00:24:00,376 --> 00:24:01,856
So we're not going
after graphics memory.


551
00:24:02,306 --> 00:24:04,946
And then if there were
16 control-points,


552
00:24:04,946 --> 00:24:07,316
there will be 16 threads
operating on these.


553
00:24:07,836 --> 00:24:11,126
Only one of them need to execute
the per-patch hull function.


554
00:24:11,126 --> 00:24:13,046
That means you typically
have a barrier,


555
00:24:13,416 --> 00:24:14,396
and then you will execute --


556
00:24:14,396 --> 00:24:16,846
only one of the thread will
execute the hull functions.


557
00:24:16,846 --> 00:24:18,466
You have a conditional
check saying, "Hey,


558
00:24:18,466 --> 00:24:21,776
is my thread in thread
group ID0?


559
00:24:21,776 --> 00:24:22,706
Then call this thing."


560
00:24:22,916 --> 00:24:24,116
And this is the function


561
00:24:24,116 --> 00:24:27,656
that will output the
tessellation factors


562
00:24:27,856 --> 00:24:28,636
to graphics memory.


563
00:24:29,156 --> 00:24:31,266
If you had any additional
patch data you wanted


564
00:24:31,266 --> 00:24:32,716
to output, you could do so.


565
00:24:32,716 --> 00:24:35,196
And if you really, really,
really, really wanted


566
00:24:35,196 --> 00:24:38,376
to output the control-point
data, you can do so.


567
00:24:38,376 --> 00:24:41,626
But we find in most case the
control-point data is just


568
00:24:41,676 --> 00:24:42,306
passed through.


569
00:24:42,306 --> 00:24:45,036
It's the nature of
the graphics pipeline,


570
00:24:45,036 --> 00:24:47,006
and these are the existing API's


571
00:24:47,346 --> 00:24:48,966
which requires you
to pass them through.


572
00:24:49,116 --> 00:24:51,366
But you're just passing them
through; don't write it out.


573
00:24:51,476 --> 00:24:53,516
You already have them
in your buffer, okay?


574
00:24:54,486 --> 00:24:55,346
All right.


575
00:24:55,346 --> 00:24:56,096
Let me close.


576
00:24:56,386 --> 00:24:58,576
So I hope I have shown you


577
00:24:58,916 --> 00:25:03,616
that Metal Tessellation
is simple and easy to use.


578
00:25:03,796 --> 00:25:06,696
We designed it from the
ground up for performance.


579
00:25:07,646 --> 00:25:09,046
I've shown you how easy it is


580
00:25:09,156 --> 00:25:12,356
to adapt your existing
tessellation code to Metal.


581
00:25:13,356 --> 00:25:15,056
It's available on iOS and macOS.


582
00:25:15,276 --> 00:25:17,986
So now it's your turn.


583
00:25:18,446 --> 00:25:20,316
Show us, you know,
use tessellation


584
00:25:20,316 --> 00:25:22,716
and create some amazing visuals


585
00:25:22,716 --> 00:25:24,716
that you can render
in the application.


586
00:25:25,956 --> 00:25:27,456
So I want to thank
you for your time.


587
00:25:27,456 --> 00:25:29,946
I'm going to call my colleague,
James, and he's going to talk


588
00:25:29,946 --> 00:25:32,606
to you about resource heaps
and memoryless render targets.


589
00:25:32,606 --> 00:25:32,996
Thank you.


590
00:25:34,516 --> 00:25:40,596
[ Applause ]


591
00:25:41,096 --> 00:25:41,386
>> All right.


592
00:25:41,386 --> 00:25:41,996
Thank you, Aaftab.


593
00:25:42,826 --> 00:25:45,866
For the next part of
this session I'm excited


594
00:25:45,866 --> 00:25:49,926
to introduce two new Metal
features available in iOS


595
00:25:49,926 --> 00:25:53,016
and tvOS - resource heaps and
memoryless render targets.


596
00:25:54,196 --> 00:25:56,196
These features enable
you to take control


597
00:25:56,196 --> 00:25:58,926
of your resource
management for greater CPU


598
00:25:58,926 --> 00:25:59,946
and memory efficiency.


599
00:26:00,876 --> 00:26:02,496
I'll introduce resource
heaps first,


600
00:26:02,716 --> 00:26:04,336
followed by memoryless
render targets.


601
00:26:06,246 --> 00:26:09,146
So resource heaps are a
new lower overhead resource


602
00:26:09,146 --> 00:26:10,436
management option in Metal.


603
00:26:10,436 --> 00:26:13,406
Now, you can already create
buffers and textures in Metal,


604
00:26:13,856 --> 00:26:15,216
so why do we need another way?


605
00:26:16,076 --> 00:26:18,516
Well, creating resources
through the existing Metal API


606
00:26:18,626 --> 00:26:21,126
with a device is
easy and convenient


607
00:26:21,516 --> 00:26:23,586
and many developers
appreciate the simplicity.


608
00:26:24,346 --> 00:26:25,966
On the other hand, as many


609
00:26:25,966 --> 00:26:28,336
of your Metal apps
render increasingly rich


610
00:26:28,366 --> 00:26:31,646
and complex scenes, you
asked for finer control


611
00:26:31,646 --> 00:26:34,726
over your Metal resources
to unlock greater CPU


612
00:26:34,726 --> 00:26:35,646
and memory efficiency.


613
00:26:36,426 --> 00:26:39,396
That's why we are
introducing resource heaps.


614
00:26:39,576 --> 00:26:43,246
Resource heaps enable fast
resource creation and binding


615
00:26:43,556 --> 00:26:45,036
through resource sub-allocation.


616
00:26:45,866 --> 00:26:49,236
The flexibility of resource
heaps saves you memory


617
00:26:49,286 --> 00:26:52,116
by allowing multiple
resources to alias in memory.


618
00:26:52,986 --> 00:26:55,656
And finally, the
efficiency and flexibility


619
00:26:55,656 --> 00:26:59,026
of resource heaps is made
possible by you taking control


620
00:26:59,026 --> 00:27:00,926
over tracking resource
dependencies


621
00:27:01,266 --> 00:27:02,966
with explicit command
synchronization.


622
00:27:03,946 --> 00:27:06,386
Now, let's dive into each one
of these features starting


623
00:27:06,386 --> 00:27:07,906
with resource sub-allocation.


624
00:27:09,276 --> 00:27:11,506
Before talking about the
details of sub-allocation,


625
00:27:11,816 --> 00:27:15,556
let's first discuss why
device-based resource creation


626
00:27:15,556 --> 00:27:16,226
is expensive.


627
00:27:17,416 --> 00:27:18,876
Creating an individual resource


628
00:27:19,076 --> 00:27:21,186
with a Metal device
involves multiple steps:


629
00:27:21,856 --> 00:27:24,776
Allocating the memory; preparing
the memory for the GPU;


630
00:27:25,476 --> 00:27:28,136
clearing the memory for
security; and then, finally,


631
00:27:28,196 --> 00:27:29,886
creating the Metal object.


632
00:27:30,616 --> 00:27:33,036
Each one of these steps
takes time and a majority


633
00:27:33,036 --> 00:27:34,886
of the time is spent
in memory operations.


634
00:27:35,696 --> 00:27:38,686
But there are situations when
you need to create resources


635
00:27:38,916 --> 00:27:40,376
on your performance-critical
path


636
00:27:40,686 --> 00:27:42,266
without introducing
performance hitches.


637
00:27:43,366 --> 00:27:44,736
Texture streaming is one example


638
00:27:45,396 --> 00:27:48,316
or perhaps you have an image
processing app that needs


639
00:27:48,316 --> 00:27:49,116
to generate a number


640
00:27:49,116 --> 00:27:50,956
of temporary textures
to execute a filter.


641
00:27:51,536 --> 00:27:55,086
The cost of binding resources


642
00:27:55,276 --> 00:27:57,946
to command encoders can also
become a performance issue.


643
00:27:58,836 --> 00:28:01,616
Metal must track each
unique resource bound


644
00:28:01,616 --> 00:28:03,416
to a command encoder
to make sure


645
00:28:03,416 --> 00:28:05,066
that the GPU can
access the memory.


646
00:28:05,736 --> 00:28:08,316
And for complex scenes, this
cost can add up as well.


647
00:28:10,066 --> 00:28:12,226
Resource sub-allocation
addresses both


648
00:28:12,226 --> 00:28:13,396
of these performance issues.


649
00:28:14,236 --> 00:28:17,146
Remember that the expensive
part of resource creation is


650
00:28:17,146 --> 00:28:18,246
in the memory operations.


651
00:28:19,046 --> 00:28:21,626
With resource heaps you can
perform the memory operations


652
00:28:21,626 --> 00:28:23,736
ahead of time outside
of your game loop.


653
00:28:24,976 --> 00:28:27,656
Resource heaps address the
binding cost by allowing you


654
00:28:27,656 --> 00:28:31,096
to sub-allocate many logical
resources from a single heap.


655
00:28:32,056 --> 00:28:34,436
By sub-allocating multiple
resources from one heap,


656
00:28:34,756 --> 00:28:37,256
Metal tracks one memory
allocation instead


657
00:28:37,256 --> 00:28:38,816
of one per individual resource.


658
00:28:39,566 --> 00:28:41,696
This significantly reduces
your driver overhead.


659
00:28:43,486 --> 00:28:44,946
Now, let's compare
resource creation


660
00:28:44,946 --> 00:28:47,426
between the Metal device and
the new Metal resource heap.


661
00:28:48,146 --> 00:28:51,786
When you create a resource with
a device, Metal will allocate


662
00:28:51,786 --> 00:28:52,986
and prepare a block of memory


663
00:28:53,466 --> 00:28:54,716
and then create the
Metal object.


664
00:28:55,406 --> 00:28:57,506
So for four resources,
Metal will allocate


665
00:28:57,506 --> 00:28:59,016
or prepare four blocks
of memory.


666
00:28:59,826 --> 00:29:01,996
Now, compare that
to the MTLHeap.


667
00:29:02,456 --> 00:29:04,206
When you use a MTLHeap
for resource creation,


668
00:29:04,206 --> 00:29:06,486
you first create the heap
object ahead of time.


669
00:29:07,276 --> 00:29:09,726
Memory will allocate and
prepare a block of memory


670
00:29:09,796 --> 00:29:10,836
of the requested size.


671
00:29:11,466 --> 00:29:13,816
And if you do this ahead of time
outside of your render loop,


672
00:29:14,376 --> 00:29:16,666
the expensive part of
resource creation is complete.


673
00:29:18,166 --> 00:29:20,356
Now, to create four
resources out of the MTLHeap,


674
00:29:20,986 --> 00:29:23,706
Metal only needs to reserve
a piece of the heap's memory


675
00:29:23,926 --> 00:29:25,186
and create the resource
metadata.


676
00:29:25,586 --> 00:29:26,606
This is much faster.


677
00:29:27,496 --> 00:29:28,626
Now let's see what
happens when we want


678
00:29:28,626 --> 00:29:29,906
to release some resources.


679
00:29:30,956 --> 00:29:33,136
When a device-based
resource is released,


680
00:29:33,456 --> 00:29:34,796
the Metal object is destroyed,


681
00:29:35,306 --> 00:29:38,466
but the device will also free
the memory resource allocation.


682
00:29:39,236 --> 00:29:41,186
On the other hand, when
releasing a heap resource,


683
00:29:41,416 --> 00:29:43,006
only the object is destroyed.


684
00:29:43,586 --> 00:29:45,156
The memory is still
owned by the heap.


685
00:29:45,856 --> 00:29:47,066
So creating a new resource


686
00:29:47,066 --> 00:29:50,136
on the device will incur another
expensive memory allocation,


687
00:29:50,596 --> 00:29:54,006
whereas the heap can quickly
reassign the free memory


688
00:29:54,216 --> 00:29:55,166
to another resource.


689
00:29:56,766 --> 00:29:58,066
Let me show you how easy it is


690
00:29:58,096 --> 00:30:00,726
to sub-allocate Metal
resources with Swift.


691
00:30:01,256 --> 00:30:04,096
So like many Metal objects,


692
00:30:04,256 --> 00:30:07,866
the Metal resource heap has a
corresponding descriptor object.


693
00:30:08,406 --> 00:30:11,176
So let's create a heap
descriptor and set the size


694
00:30:11,406 --> 00:30:14,376
to the amount of
memory to back the heap.


695
00:30:14,896 --> 00:30:16,756
With the heap descriptor
we can ask the device


696
00:30:16,916 --> 00:30:18,256
to create us a heap object.


697
00:30:18,726 --> 00:30:20,906
Remember, this is the slower
operation, so do this ahead


698
00:30:20,906 --> 00:30:22,996
of time, like when
your app starts


699
00:30:23,056 --> 00:30:24,576
or at content loading time.


700
00:30:26,136 --> 00:30:27,386
With the constructed heap,


701
00:30:27,736 --> 00:30:29,426
we can call its resource
creation methods,


702
00:30:29,586 --> 00:30:32,076
which should look very
familiar since the name


703
00:30:32,076 --> 00:30:38,006
and arguments are the same
as the device equivalents.


704
00:30:39,496 --> 00:30:41,526
So before moving on
to the next topic I'd


705
00:30:41,526 --> 00:30:42,876
like to share some
best practices


706
00:30:42,876 --> 00:30:44,776
for using resource heaps
for sub-allocation.


707
00:30:45,466 --> 00:30:48,276
Now, the most important tip
is to use resource heaps


708
00:30:48,516 --> 00:30:51,176
to create resources on your
performance-critical path.


709
00:30:51,696 --> 00:30:54,496
Creating resources using
the device is not designed


710
00:30:54,496 --> 00:30:58,426
for your game loop;
resource heaps are.


711
00:30:59,076 --> 00:31:03,146
Allocating resources of varying
sizes can lead to fragmentation


712
00:31:03,146 --> 00:31:03,966
of a heap's memory


713
00:31:04,256 --> 00:31:06,346
if the resources have
varying lifetimes.


714
00:31:07,226 --> 00:31:10,326
So use multiple heaps and
bucket resources by size


715
00:31:10,526 --> 00:31:12,026
to limit the effects
of fragmentation.


716
00:31:12,516 --> 00:31:15,306
Now, you may also
be wondering how


717
00:31:15,306 --> 00:31:17,006
to choose an appropriate
heap size.


718
00:31:17,716 --> 00:31:20,456
Well, Metal provides two new
methods on the Metal device


719
00:31:20,816 --> 00:31:24,066
to query the size and alignment
of a texture and buffer.


720
00:31:25,076 --> 00:31:27,256
Use these queries to help
you calculate the heap size


721
00:31:27,256 --> 00:31:27,726
that you need.


722
00:31:29,406 --> 00:31:30,816
Okay. Let's move on
to the next feature


723
00:31:30,816 --> 00:31:32,866
of resource heaps --
Resource aliasing.


724
00:31:34,256 --> 00:31:36,956
Resource aliasing allows
multiple dynamic resources


725
00:31:37,226 --> 00:31:38,616
to occupy the same memory,


726
00:31:38,906 --> 00:31:41,246
therefore reducing the
total memory footprint


727
00:31:41,426 --> 00:31:42,296
of the resources.


728
00:31:42,956 --> 00:31:46,666
Dynamic resources have contents
that are regenerated each frame


729
00:31:46,666 --> 00:31:51,116
and include things like your
shadow maps, your G buffer data,


730
00:31:51,116 --> 00:31:53,586
or temporary textures
used in post-processing.


731
00:31:55,246 --> 00:31:58,096
Here we have a heap containing
two nonaliasing resources.


732
00:31:58,656 --> 00:32:00,656
Compare that to this heap
containing the same two


733
00:32:00,656 --> 00:32:02,526
resources but now
they are aliasing.


734
00:32:02,796 --> 00:32:04,026
Now, you can obviously see


735
00:32:04,026 --> 00:32:07,206
that the aliasing resources can
fit inside a much smaller heap.


736
00:32:10,066 --> 00:32:13,566
Let's apply resource
aliasing to this game frame.


737
00:32:14,376 --> 00:32:16,626
The shadow map passes render
a set of shadow maps --


738
00:32:17,036 --> 00:32:18,436
one for each light in the scene.


739
00:32:19,426 --> 00:32:21,316
So here in our heap we have
a number of shadow maps.


740
00:32:21,976 --> 00:32:26,556
And in the main pass during
fragment processing the shaders


741
00:32:26,556 --> 00:32:28,416
will sample the shadow
maps to determine


742
00:32:28,416 --> 00:32:29,946
if each object is in shadow.


743
00:32:29,946 --> 00:32:34,016
Now, after the main
pass ends, the contents


744
00:32:34,016 --> 00:32:35,856
for the shadow maps are
completely consumed.


745
00:32:35,896 --> 00:32:38,306
They will be regenerated
in the next frame.


746
00:32:38,966 --> 00:32:42,736
So after the main pass ends, we
execute a post-processing chain


747
00:32:42,796 --> 00:32:45,476
that can consist of a number
of off-screen render passes,


748
00:32:45,866 --> 00:32:48,486
each executing a specific
filter like a blur or bloom.


749
00:32:49,556 --> 00:32:52,286
These filters will store
their contents into textures


750
00:32:52,286 --> 00:32:54,966
to pass filter results to
the next stages the chain.


751
00:32:55,686 --> 00:32:58,766
Now, the key takeaway
here is that the contents


752
00:32:58,766 --> 00:33:00,936
for the shadow maps and the
post-processing textures are


753
00:33:00,936 --> 00:33:02,326
never used at the same time.


754
00:33:03,146 --> 00:33:06,846
So why not share the memory?


755
00:33:07,176 --> 00:33:10,136
So let me show you how to create
these aliasing resource sets


756
00:33:10,136 --> 00:33:10,586
with Swift.


757
00:33:11,296 --> 00:33:12,906
Now, the first section
should look familiar.


758
00:33:13,366 --> 00:33:15,026
First we ask the device
to create us a heap


759
00:33:15,916 --> 00:33:18,126
and we create our
three shadow maps.


760
00:33:18,786 --> 00:33:21,586
Okay. Now we see a new
method, makeAliasable.


761
00:33:22,546 --> 00:33:23,876
By calling makeAliasable


762
00:33:23,876 --> 00:33:26,476
on a heap resource you are
telling the heap to consider


763
00:33:26,476 --> 00:33:28,056
that resource's memory
to be free.


764
00:33:29,366 --> 00:33:33,126
The shadow maps are still
active, but their memory is free


765
00:33:33,126 --> 00:33:35,546
to be reassigned by the
heap to new resources.


766
00:33:35,806 --> 00:33:38,796
So now when we create the
post-processing textures


767
00:33:38,796 --> 00:33:41,916
on the same heap, they
can occupy the same memory


768
00:33:41,916 --> 00:33:43,426
as the shadow maps.


769
00:33:44,616 --> 00:33:47,856
So now let's talk about
some best practices


770
00:33:47,926 --> 00:33:48,896
for resource aliasing.


771
00:33:49,526 --> 00:33:52,226
To maximize memory reuse


772
00:33:52,226 --> 00:33:56,756
for dynamic resources call
resource creation methods


773
00:33:56,826 --> 00:33:59,796
in the same sequence that their
resources are used in a frame.


774
00:34:00,646 --> 00:34:02,956
That will allow you to
call makeAliasable --


775
00:34:03,616 --> 00:34:06,606
that will allow you to
interleave makeAliasable calls


776
00:34:07,026 --> 00:34:11,976
when the resource contents
have been consumed.


777
00:34:12,045 --> 00:34:13,096
And you want to keep dynamic


778
00:34:13,226 --> 00:34:15,005
and static resources
in separate heaps.


779
00:34:15,886 --> 00:34:18,966
Static resources are generally
not aliasable and can end


780
00:34:18,966 --> 00:34:21,766
up preventing dynamic
resources from aliasing


781
00:34:21,766 --> 00:34:22,716
with each other due


782
00:34:22,716 --> 00:34:24,156
to fragmentation of
the heap's memory.


783
00:34:25,926 --> 00:34:28,815
Next I'm going to talk about how
to synchronize command access


784
00:34:28,876 --> 00:34:32,496
to your heap resources.


785
00:34:33,045 --> 00:34:35,746
So, so far we have discussed
fast resource creation


786
00:34:35,815 --> 00:34:38,346
with sub-allocation and
efficient memory usage


787
00:34:38,346 --> 00:34:39,446
with resource aliasing.


788
00:34:40,025 --> 00:34:42,426
But remember that resource
heaps are fast and flexible


789
00:34:42,616 --> 00:34:44,406
because you control
the synchronization


790
00:34:44,406 --> 00:34:45,326
of heap resources.


791
00:34:45,916 --> 00:34:47,396
This is something
you do not have to do


792
00:34:47,396 --> 00:34:48,525
with device resources.


793
00:34:49,716 --> 00:34:52,356
But unlike device
resources, Metal won't know


794
00:34:52,356 --> 00:34:54,946
when a command modifies the
contents of a heap resource


795
00:34:55,456 --> 00:34:59,096
like when a render pass stores
new contents to a texture.


796
00:35:00,346 --> 00:35:02,646
Metal also doesn't know when
you're changing interpretation


797
00:35:02,646 --> 00:35:05,576
of the heap's memory from
one aliasing set to another.


798
00:35:06,116 --> 00:35:08,866
But for correctness,
Metal needs know


799
00:35:08,866 --> 00:35:10,776
when a command is
updating a heap resource


800
00:35:11,076 --> 00:35:14,016
so that other commands can
safely read the results.


801
00:35:15,076 --> 00:35:16,296
This is especially important


802
00:35:16,296 --> 00:35:19,066
because the GPU can execute
multiple commands in parallel.


803
00:35:19,736 --> 00:35:22,656
So to synchronize
access to heap resources,


804
00:35:22,886 --> 00:35:25,786
your application will
create and manage GPU fences


805
00:35:26,466 --> 00:35:29,256
to communicate resource
dependencies across commands.


806
00:35:30,276 --> 00:35:32,086
Let's take a closer look
at how GPU fences work.


807
00:35:33,416 --> 00:35:35,516
So a GPU fence is the timestamp.


808
00:35:35,976 --> 00:35:39,496
It is a reference point in
the GPUs execution timeline.


809
00:35:40,026 --> 00:35:42,316
Now, you can encode
two actions with fences


810
00:35:42,366 --> 00:35:43,386
to synchronize commands.


811
00:35:43,876 --> 00:35:47,406
A command can update a fence
to move the timestamp forward


812
00:35:47,466 --> 00:35:48,466
when the command is finished.


813
00:35:49,156 --> 00:35:51,916
And a command can wait
on a fence to wait


814
00:35:51,916 --> 00:35:54,476
until the GPU has reached
the most recent fence update


815
00:35:54,476 --> 00:35:55,316
before executing.


816
00:35:56,676 --> 00:35:58,836
Okay. Let's bring back
the previous game frame


817
00:35:58,996 --> 00:36:00,616
and I will show you
how to use fences


818
00:36:00,726 --> 00:36:03,596
to synchronize command access
to the aliasing heap resources.


819
00:36:05,206 --> 00:36:08,776
So here again is the example
frame, a three-part frame,


820
00:36:08,866 --> 00:36:10,676
but now we have five
boxes because two


821
00:36:10,676 --> 00:36:13,556
of the render stages, render
passes are split in the vertex


822
00:36:13,636 --> 00:36:15,476
and fragment processing steps.


823
00:36:16,096 --> 00:36:18,296
So we have a shadow
pass, a main pass,


824
00:36:18,296 --> 00:36:20,106
and finally a post-processing
pass


825
00:36:20,536 --> 00:36:21,866
that we will execute
with compute.


826
00:36:23,656 --> 00:36:25,806
So Metal commands are submitted


827
00:36:25,806 --> 00:36:27,916
in serial order to
the command queue.


828
00:36:28,556 --> 00:36:29,586
So maybe it's not quite clear


829
00:36:29,586 --> 00:36:32,116
yet why we need any
synchronization across commands.


830
00:36:33,046 --> 00:36:35,546
But GPUs are very parallel
machines and can operate


831
00:36:35,546 --> 00:36:37,006
on multiple commands
in parallel.


832
00:36:38,296 --> 00:36:41,956
GPUs in our iOS and tvOS
products can execute vertex,


833
00:36:42,266 --> 00:36:45,436
fragment, and compute
commands all in parallel


834
00:36:45,496 --> 00:36:47,846
to maximize GPU utilization.


835
00:36:48,456 --> 00:36:49,936
The GPU can even be working


836
00:36:49,936 --> 00:36:52,486
on multiple frames
at the same time.


837
00:36:53,316 --> 00:36:53,696
All right.


838
00:36:53,696 --> 00:36:55,136
So maybe now you spot a problem.


839
00:36:55,136 --> 00:36:57,936
Look at these two commands
that are highlighted.


840
00:36:58,586 --> 00:37:00,246
They are both updating
the aliasing


841
00:37:00,286 --> 00:37:01,986
and heap resources
at the same time.


842
00:37:02,766 --> 00:37:04,896
We have to use a
fence to fix this.


843
00:37:05,866 --> 00:37:07,466
So first let's bring in a fence.


844
00:37:08,876 --> 00:37:11,686
The post-process command
will update the fence


845
00:37:13,006 --> 00:37:16,336
so that the shadow commands
fragment processing stage can


846
00:37:16,336 --> 00:37:17,246
wait on the fence.


847
00:37:18,616 --> 00:37:21,456
Right? So now the two
commands don't execute


848
00:37:21,456 --> 00:37:22,426
at the same time anymore.


849
00:37:22,426 --> 00:37:25,886
So I'm going to show you how
to encode this fence update


850
00:37:25,886 --> 00:37:28,696
and fence wait with Swift.


851
00:37:29,456 --> 00:37:31,666
First, we create a
fence with a device.


852
00:37:32,416 --> 00:37:34,226
This is a new method
-- no arguments.


853
00:37:35,036 --> 00:37:37,776
Next, let's encode the
post-processing compute encoder


854
00:37:37,906 --> 00:37:39,066
at the end of the first frame.


855
00:37:39,776 --> 00:37:43,416
We first create a
computeCommandEncoder


856
00:37:43,656 --> 00:37:44,726
and encode the dispatches.


857
00:37:45,216 --> 00:37:51,156
But before we end the encoder,
we first update the fence


858
00:37:51,286 --> 00:37:53,146
so that subsequent
commands can wait


859
00:37:53,146 --> 00:37:55,896
until this command has
finished executing.


860
00:37:56,186 --> 00:38:01,326
So in the next frame we would
encode the shadow rendering.


861
00:38:01,706 --> 00:38:03,336
So we create a
renderCommandEncoder


862
00:38:03,966 --> 00:38:06,476
in commandBufB, which
represents the command buffer


863
00:38:06,476 --> 00:38:07,576
for the next frame.


864
00:38:08,146 --> 00:38:12,156
But before drawing the scene,
we first encode a fence wait


865
00:38:13,226 --> 00:38:15,136
to wait until the
post-processing is completed


866
00:38:15,336 --> 00:38:15,996
on the GPU.


867
00:38:16,286 --> 00:38:18,266
Now, notice this time
there are two arguments.


868
00:38:18,706 --> 00:38:21,046
There's a second argument
called beforeStages.


869
00:38:22,496 --> 00:38:25,236
Render commands execute in two
stages -- vertex and fragment.


870
00:38:25,606 --> 00:38:29,346
So Metal allows you to specify
the particular stage that needs


871
00:38:29,346 --> 00:38:30,306
to wait for the fence.


872
00:38:31,056 --> 00:38:33,056
In our example only the
fragment stage needs


873
00:38:33,106 --> 00:38:37,936
to access the heap resources, so
we specify the fragment stage.


874
00:38:38,416 --> 00:38:40,736
Finally, we can render
our shadow maps safely


875
00:38:41,086 --> 00:38:43,536
because we know that this
command will only execute


876
00:38:43,536 --> 00:38:46,146
after the previous frame's
post-processing is complete.


877
00:38:46,756 --> 00:38:50,056
Okay. Let me talk about
some best practices


878
00:38:50,056 --> 00:38:51,156
for command synchronization.


879
00:38:51,966 --> 00:38:55,336
So you know that if you use
heaps, you have to use fences


880
00:38:55,336 --> 00:38:56,696
to synchronize command access.


881
00:38:57,196 --> 00:38:58,526
But you are given this control


882
00:38:58,526 --> 00:39:00,356
because you know you
have more knowledge


883
00:39:00,356 --> 00:39:02,366
about how your resources
are used


884
00:39:02,846 --> 00:39:05,936
and your application will
be more CPU-efficient


885
00:39:06,246 --> 00:39:08,196
than if Metal were to
track all of this for you.


886
00:39:09,106 --> 00:39:11,926
For example, textures
that are initialized once


887
00:39:11,926 --> 00:39:14,566
and never modified don't
even need to be tracked.


888
00:39:15,916 --> 00:39:17,136
And as another example,


889
00:39:17,376 --> 00:39:19,896
resources that are used
together can be tracked together


890
00:39:19,896 --> 00:39:21,606
with a single fence.


891
00:39:23,476 --> 00:39:26,976
So let me summarize the main
ideas of resource heaps.


892
00:39:28,326 --> 00:39:31,126
Create resources faster
with suballocation.


893
00:39:32,296 --> 00:39:34,226
Use your memory budget
more efficiently


894
00:39:34,666 --> 00:39:35,716
with resource aliasing.


895
00:39:36,866 --> 00:39:40,156
And synchronize your
heap updates


896
00:39:40,256 --> 00:39:43,066
across GPU commands
with GPU fences.


897
00:39:45,956 --> 00:39:49,786
Okay. Now I'd like to introduce
another new feature available


898
00:39:49,986 --> 00:39:52,766
in iOS and tvOS:
Memoryless render targets.


899
00:39:53,626 --> 00:39:54,956
Now, this sounds
a little magical,


900
00:39:55,366 --> 00:39:58,146
but I will show you how almost
every Metal app can use this


901
00:39:58,146 --> 00:40:00,536
feature to save a
significant amount of memory


902
00:40:00,976 --> 00:40:03,266
with a single line of code.


903
00:40:03,976 --> 00:40:07,106
So memoryless render
targets are simply textures


904
00:40:07,106 --> 00:40:10,136
that do not allocate any system
memory for the texture contents.


905
00:40:11,016 --> 00:40:14,676
Without any memory backing
the texture contents,


906
00:40:14,956 --> 00:40:16,776
what remains is the
texture's metadata,


907
00:40:17,086 --> 00:40:19,796
such as the texture's dimensions
and internal texture format.


908
00:40:20,506 --> 00:40:22,746
Now obviously this is
a huge memory savings,


909
00:40:23,356 --> 00:40:25,356
but when can you use a
memoryless render target?


910
00:40:26,506 --> 00:40:29,566
You can use them for render pass
attachments that are not stored.


911
00:40:30,566 --> 00:40:34,596
Most Metal apps will have
some attachments associated


912
00:40:34,596 --> 00:40:38,606
with a store action of don't
care or multisample resolve.


913
00:40:38,746 --> 00:40:41,296
And the textures used for those
render pass attachments can


914
00:40:41,296 --> 00:40:42,026
be memoryless.


915
00:40:42,726 --> 00:40:46,236
To make a memoryless
render target,


916
00:40:46,556 --> 00:40:48,976
you can simply create the
texture as you normally would


917
00:40:49,306 --> 00:40:50,836
with an additional
storage mode flag --


918
00:40:51,486 --> 00:40:53,226
MTLStorageModeMemoryless.


919
00:40:53,646 --> 00:40:54,756
That's it.


920
00:40:55,286 --> 00:40:57,776
This feature is supported
only on iOS and tvOS


921
00:40:57,776 --> 00:40:59,326
because it relies


922
00:40:59,326 --> 00:41:01,366
on the tile-based
rendering architecture


923
00:41:01,646 --> 00:41:03,616
of A7 and later GPUs.


924
00:41:04,596 --> 00:41:05,886
Let me show you how
this feature works.


925
00:41:06,846 --> 00:41:09,786
Here on your right we have
two render pass attachment --


926
00:41:10,136 --> 00:41:11,876
a color attachment and
a depth attachment.


927
00:41:12,326 --> 00:41:15,886
Now, A7 and later GPUs
execute render passes one tile


928
00:41:15,886 --> 00:41:20,436
at a time, taking advantage
of a fast GPU tile storage


929
00:41:20,696 --> 00:41:22,076
at the heart of the GPU.


930
00:41:22,806 --> 00:41:25,836
The GPU tile storage contains
tile-sized representations


931
00:41:25,836 --> 00:41:28,206
of your depth, stencil,
and color attachments.


932
00:41:28,946 --> 00:41:31,246
And this tile storage
is completely separate


933
00:41:31,566 --> 00:41:33,246
from the texture backing
and system memory.


934
00:41:33,906 --> 00:41:37,466
Now, in Metal your load and
store actions control how


935
00:41:37,466 --> 00:41:40,136
to initialize the GPU
tile storage and whether


936
00:41:40,136 --> 00:41:43,326
to copy the results from
the GPU tile storage back


937
00:41:43,326 --> 00:41:44,076
to system memory.


938
00:41:44,906 --> 00:41:48,376
If an attachment is not loaded
from memory and it is not stored


939
00:41:48,376 --> 00:41:50,496
to memory, you can
make the texture


940
00:41:50,496 --> 00:41:51,836
for that attachment memoryless


941
00:41:52,186 --> 00:41:54,516
to eliminate the
memory allocation.


942
00:41:55,866 --> 00:41:57,966
Next, I'll describe some
very common scenarios


943
00:41:57,996 --> 00:42:00,446
where you can apply this
feature to your app.


944
00:42:01,996 --> 00:42:04,526
Depth attachments
are frequently used


945
00:42:04,646 --> 00:42:06,956
to enable depth testing
in 3-D scenes.


946
00:42:07,966 --> 00:42:11,016
But the A7 and later GPUs
perform depth testing completely


947
00:42:11,016 --> 00:42:13,286
in GPU tile storage
one tile at a time.


948
00:42:13,906 --> 00:42:16,356
Depth testing does not
need to use system memory.


949
00:42:17,246 --> 00:42:19,826
So if you don't store the depth
texture for use in later passes,


950
00:42:20,586 --> 00:42:22,586
make the texture memoryless
and save the memory.


951
00:42:23,106 --> 00:42:25,686
Let me show you another
opportunity.


952
00:42:27,226 --> 00:42:29,546
When executing multisample
rendering, again,


953
00:42:29,546 --> 00:42:31,676
the A7 and later GPUs
perform all the rendering


954
00:42:31,676 --> 00:42:32,686
in GPU tile storage.


955
00:42:32,726 --> 00:42:35,906
The MSAA color attachment
texture is only used


956
00:42:35,906 --> 00:42:38,386
if you choose to store the
sample data for a later use.


957
00:42:39,646 --> 00:42:43,476
But most apps will choose the
multisample resolve store action


958
00:42:43,836 --> 00:42:45,986
which results directly
from the GPU tile storage


959
00:42:46,296 --> 00:42:47,946
to the resolve color
attachment texture.


960
00:42:49,256 --> 00:42:51,666
So in that case make the
multisample color attachment


961
00:42:51,666 --> 00:42:54,636
texture memoryless and this
is a massive memory savings.


962
00:42:55,966 --> 00:42:57,206
As you can see, the savings


963
00:42:57,206 --> 00:42:59,176
for adopting this
feature are substantial.


964
00:42:59,176 --> 00:43:02,396
By making a 1080p depth
texture memoryless,


965
00:43:02,856 --> 00:43:04,596
your app will save
almost 8 megabytes.


966
00:43:05,666 --> 00:43:07,206
If you are rendering to
the native resolution


967
00:43:07,206 --> 00:43:09,296
of a 12.9-inch iPad Pro,


968
00:43:09,596 --> 00:43:11,896
the savings for the depth
buffer is over 20 megabytes.


969
00:43:12,706 --> 00:43:15,516
And the savings for making a
four times multisample render


970
00:43:15,516 --> 00:43:18,476
target memoryless are even
larger, four times larger.


971
00:43:19,876 --> 00:43:23,436
So use memoryless render
targets to make the most


972
00:43:23,436 --> 00:43:25,846
of your application's
memory budget.


973
00:43:26,396 --> 00:43:29,216
Use the savings to lower the
memory footprint of your game.


974
00:43:29,576 --> 00:43:32,646
Or better yet, use the
savings to add more beautiful


975
00:43:32,646 --> 00:43:34,326
and unique content to your game.


976
00:43:36,446 --> 00:43:38,976
Okay. I'd like to invite
Jose up to tell you all


977
00:43:38,976 --> 00:43:40,806
about the improvements
to the Metal Tools.


978
00:43:41,516 --> 00:43:46,966
[ Applause ]


979
00:43:47,466 --> 00:43:47,946
>> Thank you, James.


980
00:43:48,666 --> 00:43:50,116
So outside the great additions


981
00:43:50,116 --> 00:43:52,396
to the Metal API we did
some great improvements


982
00:43:52,396 --> 00:43:56,256
to Metal Developer Tools
I want to show you.


983
00:43:56,546 --> 00:43:59,296
First we'll talk about
what's in Metal System Trace.


984
00:43:59,846 --> 00:44:02,096
Than we'll introduce a new
feature called GPU Override.


985
00:44:03,146 --> 00:44:05,766
And we have some very
exciting new features coming


986
00:44:05,766 --> 00:44:10,586
to GPU Frame Debugger.


987
00:44:12,006 --> 00:44:13,156
So what is Metal System Trace?


988
00:44:14,316 --> 00:44:18,016
In the [inaudible] Metal session
we presented this graph showing


989
00:44:18,016 --> 00:44:21,966
you Metal working on
power in CPU and GPU.


990
00:44:22,126 --> 00:44:24,236
Metal System Trace is
a set of instruments


991
00:44:24,236 --> 00:44:25,926
for visualizing just that,


992
00:44:26,746 --> 00:44:28,176
helping you understand
the timeline


993
00:44:28,176 --> 00:44:29,576
of your Metal applications


994
00:44:29,876 --> 00:44:33,096
through the whole graphic
pipeline, from the CPU


995
00:44:33,806 --> 00:44:38,746
to the GPU, and then
on to the display.


996
00:44:38,886 --> 00:44:41,836
Last year at WWDC we
introduced Metal System Trace


997
00:44:41,836 --> 00:44:42,876
for iOS platform.


998
00:44:43,446 --> 00:44:46,176
I highly recommend checking
out last year's presentation


999
00:44:46,356 --> 00:44:49,566
for a great overview
of Metal System Trace.


1000
00:44:49,756 --> 00:44:52,176
Later in the fall we
added support for tvOS.


1001
00:44:53,236 --> 00:44:55,806
And today we're happy to
announce Metal System Trace


1002
00:44:55,806 --> 00:44:59,266
for macOS to help you squeeze
out the last bit of performance


1003
00:44:59,816 --> 00:45:00,836
on all Metal platforms.


1004
00:45:01,516 --> 00:45:05,756
[ Applause ]


1005
00:45:06,256 --> 00:45:08,696
>> We improved Metal System
Trace across the board,


1006
00:45:08,786 --> 00:45:12,226
extending the events
that we report.


1007
00:45:12,226 --> 00:45:12,956
[Inaudible] events,


1008
00:45:13,376 --> 00:45:16,236
we visualized expensive resource
operations to just picking data


1009
00:45:16,236 --> 00:45:18,146
from system memory
to video memory.


1010
00:45:20,106 --> 00:45:23,986
Like in this case where we
can see painting in macOS,


1011
00:45:24,456 --> 00:45:26,106
which is causing a
delay in GPU execution.


1012
00:45:29,336 --> 00:45:32,736
Metal System Trace also
displays debug groups,


1013
00:45:32,906 --> 00:45:33,966
which make it easier for you


1014
00:45:33,966 --> 00:45:38,736
to understand command encoded
relations in your trace.


1015
00:45:38,916 --> 00:45:42,586
On macOS we support tracing
multiple GPUs at the same time,


1016
00:45:42,946 --> 00:45:44,806
which is unbelievable
for those use cases


1017
00:45:44,806 --> 00:45:47,926
where you're distributing
work across different GPUs.


1018
00:45:49,016 --> 00:45:51,946
And on iOS we now
display scalar workloads


1019
00:45:52,236 --> 00:45:54,786
so that you can diagnose when
you're introducing latency


1020
00:45:55,286 --> 00:46:00,966
by rotating or scaling
your views.


1021
00:46:01,156 --> 00:46:02,786
You can now use a wider range


1022
00:46:02,786 --> 00:46:04,876
of instruments alongside
Metal System Trace


1023
00:46:05,656 --> 00:46:09,636
such as Time Profiler,
File Activity,


1024
00:46:10,896 --> 00:46:13,356
Allocations, and many more.


1025
00:46:13,686 --> 00:46:15,506
Even different views
such as CPU data,


1026
00:46:15,826 --> 00:46:18,136
which will show you
CPU core time slices.


1027
00:46:19,766 --> 00:46:23,406
These will help you to correlate
Metal events into context,


1028
00:46:23,606 --> 00:46:24,856
deepening the understanding


1029
00:46:25,276 --> 00:46:27,566
of how the system is
running your application


1030
00:46:28,166 --> 00:46:29,776
and allowing you
to diagnose things


1031
00:46:29,776 --> 00:46:35,786
such as GPU starvation
caused by CPU stall due


1032
00:46:35,786 --> 00:46:37,346
to a [inaudible] operation.


1033
00:46:40,576 --> 00:46:43,196
Metal System Trace
captures a wealth of data.


1034
00:46:43,586 --> 00:46:45,996
So we made it easier for you
to interpret and navigate.


1035
00:46:47,506 --> 00:46:50,086
With the new workload
highlighting, you can focus


1036
00:46:50,086 --> 00:46:52,336
on any command encoder
or command buffer


1037
00:46:53,246 --> 00:46:54,286
as it works through
the pipeline.


1038
00:46:54,396 --> 00:46:56,906
And with with support
for keyboard navigation,


1039
00:46:56,906 --> 00:46:59,056
you can quickly move your
selection through your trace.


1040
00:47:01,456 --> 00:47:04,246
Finally, I want to introduce
Performance Observation.


1041
00:47:05,026 --> 00:47:07,886
And what Performance
Observation does is present you


1042
00:47:07,886 --> 00:47:10,896
with a comprehensive list of
the potential issues we found


1043
00:47:10,896 --> 00:47:12,266
in your trace from analyzing it.


1044
00:47:13,996 --> 00:47:16,336
From display surface
taking too long


1045
00:47:17,666 --> 00:47:20,146
to unexpected shader
compilations,


1046
00:47:21,316 --> 00:47:26,066
or high GPU execution times,
Performance Observations finds


1047
00:47:26,066 --> 00:47:27,596
for you the events which
you are looking for,


1048
00:47:28,356 --> 00:47:29,856
which you can navigate
straight to them


1049
00:47:29,856 --> 00:47:31,436
from the Performance
Observation list.


1050
00:47:32,706 --> 00:47:34,006
All these new additions
will allow you


1051
00:47:34,006 --> 00:47:36,216
to tune your Metal
applications to run as smoothly


1052
00:47:36,216 --> 00:47:37,126
as you want them to be.


1053
00:47:38,426 --> 00:47:39,526
And now for a demonstration


1054
00:47:39,526 --> 00:47:41,346
of our awesome GPU
debugging improvements,


1055
00:47:41,736 --> 00:47:43,166
let me hand over to
my colleague, Alp.


1056
00:47:44,516 --> 00:47:49,500
[ Applause ]


1057
00:47:57,046 --> 00:47:57,596
>> Thanks, Jose.


1058
00:47:58,856 --> 00:48:01,246
I have a number of great
features to show you today.


1059
00:48:01,416 --> 00:48:02,596
So let's dive right in.


1060
00:48:02,676 --> 00:48:05,506
I have my app running here,


1061
00:48:05,896 --> 00:48:09,586
cruising over beautiful terrain
tessellated to finest details.


1062
00:48:10,746 --> 00:48:13,136
Wouldn't it be great to see
this terrain in wire frame


1063
00:48:13,136 --> 00:48:14,936
to see triangles individually?


1064
00:48:15,656 --> 00:48:19,286
The good news is our newest
feature, GPU Overrides,


1065
00:48:19,676 --> 00:48:22,516
gives you ability to modify
your Metal rendering right


1066
00:48:22,516 --> 00:48:24,756
from the debug bar while
your app is running.


1067
00:48:26,096 --> 00:48:28,606
We have a number of different
overrides you can mix and match,


1068
00:48:28,906 --> 00:48:29,896
including wire frame mode.


1069
00:48:31,566 --> 00:48:32,606
Let's switch to wire frame mode


1070
00:48:32,606 --> 00:48:35,506
to see how tessellated
the terrain is.


1071
00:48:36,966 --> 00:48:40,146
Visualizing each
triangle you might want


1072
00:48:40,216 --> 00:48:42,046
to tune your tessellation
to fine the balance


1073
00:48:42,046 --> 00:48:45,006
between performance
and visual quality.


1074
00:48:45,326 --> 00:48:47,006
Normally you'd have to go back


1075
00:48:47,006 --> 00:48:49,776
and change your code,
recompile, and run.


1076
00:48:49,856 --> 00:48:52,456
But with GPU Overrides,
you can experiment


1077
00:48:52,456 --> 00:48:56,936
with your tessellation scaling
right from the Overrides menu.


1078
00:48:57,136 --> 00:48:59,276
Let's set scaling to 25%.


1079
00:49:02,306 --> 00:49:05,226
Now we have far less
triangles but lost some


1080
00:49:05,226 --> 00:49:06,386
of the interesting details.


1081
00:49:07,706 --> 00:49:11,066
Let's try 75%.


1082
00:49:11,776 --> 00:49:12,586
I think this looks better.


1083
00:49:12,586 --> 00:49:16,926
Let's see it without
the wire frame.


1084
00:49:16,926 --> 00:49:18,006
Okay. I like this one.


1085
00:49:18,596 --> 00:49:21,056
Now, we have less triangles
than what we started with


1086
00:49:21,526 --> 00:49:23,256
but still have all
the nice details.


1087
00:49:23,256 --> 00:49:25,006
And with the performance gains,


1088
00:49:25,366 --> 00:49:27,246
I can add more cool
effects to my scene.


1089
00:49:28,776 --> 00:49:32,296
So as seen here, GPU Overrides
is a great tool to help


1090
00:49:32,296 --> 00:49:34,666
with initial diagnosis
for some of the visual


1091
00:49:34,906 --> 00:49:38,276
and performance problems
in your scene.


1092
00:49:38,496 --> 00:49:42,926
Next, let's capture the frame
to show you some of the features


1093
00:49:43,016 --> 00:49:45,506
that will greatly improve
your debugging workflow.


1094
00:49:47,776 --> 00:49:50,466
The frame capture is
done and I am looking


1095
00:49:50,466 --> 00:49:54,566
for the terrain resources to
see how we are [inaudible].


1096
00:49:57,456 --> 00:50:00,536
Let's switch to all GPU
objects in Resource Center


1097
00:50:00,936 --> 00:50:03,376
where you can see all
your textures and buffers.


1098
00:50:05,976 --> 00:50:07,986
So we have all of
resources here.


1099
00:50:08,526 --> 00:50:10,346
And going over everything
one by one


1100
00:50:10,766 --> 00:50:14,016
to find terrain resources
could take some time.


1101
00:50:14,676 --> 00:50:16,946
This is where the new
filter bar comes to help.


1102
00:50:18,036 --> 00:50:21,496
You can filter by any properties
you see here, such as label,


1103
00:50:21,976 --> 00:50:23,866
type, size, or details.


1104
00:50:25,256 --> 00:50:27,446
Since I labeled all
my resources,


1105
00:50:27,596 --> 00:50:29,116
I'll just filter by terrain.


1106
00:50:29,166 --> 00:50:32,696
And right here I have
all the resources used


1107
00:50:32,696 --> 00:50:35,456
for rendering the terrain.


1108
00:50:35,636 --> 00:50:38,336
Now that I found the terrain
patches buffer, what I would


1109
00:50:38,396 --> 00:50:41,176
like to do is to see where
I'm actually using it.


1110
00:50:42,506 --> 00:50:47,156
With a simple drag and drop I
can filter function navigator


1111
00:50:47,156 --> 00:50:49,516
to show me all the
calls that's made


1112
00:50:49,516 --> 00:50:51,496
to terrain patches
buffer just like that.


1113
00:50:52,636 --> 00:50:56,406
In this case, I see where it
is calculated using compute


1114
00:50:56,896 --> 00:51:01,556
and where it says [inaudible]
while rendering the terrain.


1115
00:51:01,736 --> 00:51:03,166
This filter is really powerful.


1116
00:51:03,166 --> 00:51:06,186
I can also use any
other properties


1117
00:51:06,186 --> 00:51:08,226
of the bound resources
to filter draw calls.


1118
00:51:09,146 --> 00:51:11,886
For example, if you
filter by SRGB,


1119
00:51:12,776 --> 00:51:16,436
you'll see all the draw calls
that are using a texture


1120
00:51:16,476 --> 00:51:18,326
with SRGB pixel format.


1121
00:51:19,666 --> 00:51:21,846
This is a natural
way of navigating


1122
00:51:21,846 --> 00:51:22,926
around your frame quickly.


1123
00:51:24,836 --> 00:51:28,536
Next, let's move
to bound GP objects


1124
00:51:28,536 --> 00:51:31,916
to see how we are using these
resources to render the terrain.


1125
00:51:32,536 --> 00:51:36,986
In bound mode your
resources are grouped


1126
00:51:36,986 --> 00:51:39,176
under different sections
based on the stage


1127
00:51:39,176 --> 00:51:40,636
of the Metal pipeline
they are used


1128
00:51:40,636 --> 00:51:44,256
in so you know exactly
where to look.


1129
00:51:44,486 --> 00:51:45,776
Looking at the vertex stage,


1130
00:51:46,236 --> 00:51:49,476
terrain patches is a buffer
bound to multiple binding points


1131
00:51:49,646 --> 00:51:50,686
with different offsets.


1132
00:51:52,036 --> 00:51:58,026
Let's use our only buffer
[inaudible] to inspect the data.


1133
00:51:58,026 --> 00:52:00,046
All the vertex data
has stayed nicely


1134
00:52:00,096 --> 00:52:02,796
with the layout except
[inaudible] Metal function


1135
00:52:02,796 --> 00:52:03,456
with patches.


1136
00:52:04,036 --> 00:52:06,496
So this is using the
exact same struct


1137
00:52:06,496 --> 00:52:07,716
as your post-vertex function.


1138
00:52:08,256 --> 00:52:11,186
And we have a color data here.


1139
00:52:11,956 --> 00:52:15,576
It recognizes the word color
and visualizes the real color


1140
00:52:15,576 --> 00:52:19,576
of the value right in there.


1141
00:52:19,696 --> 00:52:22,146
Since this is a large buffer
that contains different types


1142
00:52:22,146 --> 00:52:24,886
of data, I have added
some debug markers


1143
00:52:25,016 --> 00:52:28,616
with the new [inaudible] API,
which makes it extra easy


1144
00:52:28,616 --> 00:52:29,926
to find what you
are looking for.


1145
00:52:32,496 --> 00:52:35,356
With the layout menu,
you can jump straight


1146
00:52:35,356 --> 00:52:43,136
to any other available layout
you would like to inspect.


1147
00:52:43,316 --> 00:52:45,056
Looking at individual
buffers is great.


1148
00:52:45,926 --> 00:52:48,916
What is even better is the
new input attribute view


1149
00:52:49,526 --> 00:52:51,936
which lets you see
all your vertex data


1150
00:52:52,006 --> 00:52:53,756
as your vertex shader sees it.


1151
00:52:56,036 --> 00:52:59,046
Input attributes collects all
the data from your instances,


1152
00:52:59,496 --> 00:53:02,556
tessellation factor buffers,
and your stage in data,


1153
00:53:02,556 --> 00:53:10,276
then provides you a single view
to look at all of it together.


1154
00:53:10,276 --> 00:53:13,946
In this case we are rendering
instances with multiple patches


1155
00:53:14,436 --> 00:53:18,766
and I can see what data belongs
to which patch of an instance.


1156
00:53:19,316 --> 00:53:22,746
So that was a quick look at some


1157
00:53:22,746 --> 00:53:24,716
of our newest GPU Frame
Debugger features.


1158
00:53:25,246 --> 00:53:31,556
Let's switch back to
slides and wrap up.


1159
00:53:32,516 --> 00:53:37,336
[ Applause ]


1160
00:53:37,836 --> 00:53:39,156
So you've just seen some


1161
00:53:39,156 --> 00:53:41,086
of our newest GPU Frame
Debugger features.


1162
00:53:41,756 --> 00:53:43,316
I would like to tell
you about two more.


1163
00:53:44,026 --> 00:53:49,746
With the new Extended Validation
mode the GPU Frame Debugger can


1164
00:53:49,746 --> 00:53:52,596
perform even deeper
analysis of your application,


1165
00:53:53,386 --> 00:53:56,676
providing recommendations
[inaudible] the optimal texture


1166
00:53:56,676 --> 00:53:59,646
usage or storage mode
for your resources.


1167
00:54:01,356 --> 00:54:07,116
You can enable this mode from
the Xcode scheme editors.


1168
00:54:07,626 --> 00:54:08,486
And the new support


1169
00:54:08,486 --> 00:54:11,886
for stand-alone Metal Library
Projects lets you create Metal


1170
00:54:11,886 --> 00:54:14,256
libraries to be shared
in multiple apps


1171
00:54:14,806 --> 00:54:18,096
or include multiple of
them in a single app just


1172
00:54:18,096 --> 00:54:19,806
like any other framework
or library.


1173
00:54:22,536 --> 00:54:24,456
So we talked about features


1174
00:54:24,456 --> 00:54:26,416
that will greatly improve
your tool's experience.


1175
00:54:26,956 --> 00:54:30,326
Now let's summarize what we have
seen so far in this session.


1176
00:54:32,636 --> 00:54:36,136
We have seen the great additions
to Metal API with tessellation,


1177
00:54:36,916 --> 00:54:39,726
resource heaps and
memoryless render targets,


1178
00:54:40,216 --> 00:54:43,296
then we showed you improved
tools, Metal System Trace


1179
00:54:43,296 --> 00:54:44,236
and GPU Frame Debugger.


1180
00:54:45,606 --> 00:54:47,836
Be sure to stick around
for part two this afternoon


1181
00:54:47,896 --> 00:54:51,046
where I will talk about
function specialization


1182
00:54:51,196 --> 00:54:54,426
and function resource
read-writes, wide color


1183
00:54:54,676 --> 00:54:57,356
and texture assets,
and additions


1184
00:54:57,356 --> 00:54:58,816
to Metal performance shaders.


1185
00:55:00,636 --> 00:55:02,546
For more information
about this session,


1186
00:55:02,726 --> 00:55:04,336
please check the link online.


1187
00:55:04,676 --> 00:55:06,816
You can catch the
video and get links


1188
00:55:06,816 --> 00:55:11,376
to documentation
and sample code.


1189
00:55:11,866 --> 00:55:15,596
We had great sessions yesterday,
which are available online.


1190
00:55:15,886 --> 00:55:18,976
And this afternoon we have
What's New in Metal, Part2,


1191
00:55:18,976 --> 00:55:22,066
then Advanced Metal Shader
Optimization in this room.


1192
00:55:23,276 --> 00:55:25,306
Thanks for coming,
and have a great WWDC.


1193
00:55:26,516 --> 00:55:29,500
[ Applause ]

