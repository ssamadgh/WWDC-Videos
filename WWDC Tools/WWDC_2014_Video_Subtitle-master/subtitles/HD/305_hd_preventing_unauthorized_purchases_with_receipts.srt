1
00:00:00,506 --> 00:00:11,686
[ Silence ]


2
00:00:12,186 --> 00:00:14,796
>> Hi. My name is James Wilson
and I'm an engineering manager.


3
00:00:14,796 --> 00:00:18,636
And one of the things that my
team works is on the frameworks


4
00:00:18,636 --> 00:00:21,936
that power the App Store
and the iBookstore in OS X,


5
00:00:21,936 --> 00:00:24,826
which in course - of course
includes the unified receipt


6
00:00:24,826 --> 00:00:26,446
format that we introduced
last year.


7
00:00:27,726 --> 00:00:30,296
So in this session, "Preventing
Unauthorized Purchases


8
00:00:30,296 --> 00:00:33,016
with Receipts", what we're
specifically going to talk


9
00:00:33,016 --> 00:00:37,896
about is a way in which you can
use this concept of a receipt


10
00:00:38,176 --> 00:00:40,386
to protect your revenue
and enforce protection


11
00:00:40,386 --> 00:00:42,856
of your business model
directly into your app,


12
00:00:43,206 --> 00:00:46,476
as well as into your servers
that are issuing content based


13
00:00:46,476 --> 00:00:48,136
on an in-app purchase
having been made.


14
00:00:50,396 --> 00:00:51,796
Ultimately, we use receipts


15
00:00:51,796 --> 00:00:54,226
to know exactly what the
customer has paid for.


16
00:00:54,406 --> 00:00:58,946
And you can do this both within
your app, so you can build logic


17
00:00:58,946 --> 00:01:01,706
into your app binary itself
that verifies the receipt,


18
00:01:02,176 --> 00:01:03,486
knows that it came from Apple


19
00:01:03,486 --> 00:01:05,576
and knows exactly what
the user has paid for,


20
00:01:06,156 --> 00:01:09,286
as well as you can engineer
logic into your servers to do


21
00:01:09,286 --> 00:01:13,036
that same verification to make
sure a real monetary transaction


22
00:01:13,036 --> 00:01:15,206
has occurred with the
App Store to make sure


23
00:01:15,206 --> 00:01:16,556
that you're going
to be paid for it.


24
00:01:18,126 --> 00:01:20,016
All this comes down
to one simple thing,


25
00:01:20,376 --> 00:01:21,886
protecting your revenue.


26
00:01:23,876 --> 00:01:27,456
Now, the receipt is a lot like
the physical proof of purchase,


27
00:01:27,516 --> 00:01:30,076
docket or receipt that you get
when you're shopping in a store.


28
00:01:30,706 --> 00:01:31,996
It's the same sort of concept.


29
00:01:32,946 --> 00:01:35,046
It's a trusted record of the app


30
00:01:35,046 --> 00:01:36,966
and in-app purchases
that have been made.


31
00:01:37,846 --> 00:01:39,766
And just like that physical
receipt that you get


32
00:01:39,766 --> 00:01:41,946
when you're shopping in
a store, it's the way


33
00:01:41,946 --> 00:01:45,286
that you can build security
into your app to make sure


34
00:01:45,286 --> 00:01:48,146
that you are going to be paid
for those features and content


35
00:01:48,146 --> 00:01:50,256
that you're unlocking and
providing to your users.


36
00:01:51,056 --> 00:01:53,936
You know, just like a department
store can look at your receipt


37
00:01:53,936 --> 00:01:56,106
and know exactly what you
paid for before you walk


38
00:01:56,106 --> 00:01:59,376
out with goods, you can do the
exact same thing in your app,


39
00:01:59,376 --> 00:02:00,996
and that's what we're going
to show you in this session.


40
00:02:02,066 --> 00:02:05,546
The receipt itself is stored
on the device and there's APIs


41
00:02:05,546 --> 00:02:06,936
that you can use to access it.


42
00:02:07,636 --> 00:02:09,636
And the receipt is
issued by the App Store.


43
00:02:09,636 --> 00:02:12,696
We issue a receipt every time
a transaction takes place.


44
00:02:13,716 --> 00:02:15,916
So when an app is
purchased and installed,


45
00:02:16,276 --> 00:02:17,226
there's a receipt in there.


46
00:02:18,036 --> 00:02:20,946
When an in-app purchase
occurs, a receipt is issued


47
00:02:21,216 --> 00:02:23,466
and it's available to you
to verify that purchase.


48
00:02:23,906 --> 00:02:27,406
Likewise, when previous
transactions are restored,


49
00:02:27,786 --> 00:02:29,656
another receipt is
issued that will allow you


50
00:02:29,656 --> 00:02:32,496
to verify the authenticity
of those purchases.


51
00:02:33,596 --> 00:02:36,576
And we achieve that by having
the receipts signed in a way


52
00:02:36,576 --> 00:02:39,096
that is verifiable by
you at the code level.


53
00:02:39,696 --> 00:02:42,376
So once you get this receipt,
you can confirm it really came


54
00:02:42,376 --> 00:02:44,666
from Apple and hasn't
been tampered with at all.


55
00:02:44,666 --> 00:02:48,726
But most importantly, the
receipt file is unique


56
00:02:48,806 --> 00:02:51,376
to your app on a single device.


57
00:02:52,336 --> 00:02:54,646
It makes sure that when
you verify that receipt,


58
00:02:54,646 --> 00:02:57,576
you can be absolutely certain
that this purchase happened


59
00:02:57,576 --> 00:03:01,926
for your app, from this user,
on this single device alone.


60
00:03:02,336 --> 00:03:06,596
Now, when we're working
with receipts, as you'll see


61
00:03:06,596 --> 00:03:09,176
in this session, it's
a lot like a recipe.


62
00:03:10,286 --> 00:03:13,936
There's a recipe that Apple
gives you, but there are things


63
00:03:13,936 --> 00:03:16,146
that you are going to need to
bring to the table as well.


64
00:03:16,666 --> 00:03:18,886
There's decisions that you
will need to make along the way


65
00:03:19,276 --> 00:03:22,756
to make sure that your receipt
implementation, your ability


66
00:03:22,756 --> 00:03:26,586
to protect your revenue in your
app, suits your unique needs.


67
00:03:27,836 --> 00:03:30,296
There's a lot of flexibility
built into this system.


68
00:03:31,596 --> 00:03:33,556
Now, in particular,
what Apple provides you


69
00:03:33,556 --> 00:03:36,016
with is the receipt
format specification,


70
00:03:36,356 --> 00:03:39,296
and we've built this receipt
on a bunch of open standards.


71
00:03:39,606 --> 00:03:42,156
There's nothing proprietary
about these receipts


72
00:03:42,646 --> 00:03:43,896
and the great thing
about that is,


73
00:03:43,936 --> 00:03:45,916
because they're all open
standards that are very,


74
00:03:45,916 --> 00:03:48,966
very widely used in many
places, you have lots


75
00:03:48,966 --> 00:03:51,846
of options available for you
for how to work with receipts.


76
00:03:52,206 --> 00:03:55,786
We give you the receipt itself
and there's APIs to find


77
00:03:55,786 --> 00:03:56,946
where the receipt is located.


78
00:03:57,956 --> 00:03:59,656
And we're giving you
instructions on how


79
00:03:59,656 --> 00:04:01,526
to do on-device receipt
validation,


80
00:04:01,526 --> 00:04:03,316
and that'll be the main
focus of this session.


81
00:04:04,036 --> 00:04:07,786
And we also provide an online
service that allows your servers


82
00:04:07,976 --> 00:04:09,886
to verify the authenticity
of a receipt.


83
00:04:10,836 --> 00:04:14,976
But what you, as the developer,
need to choose, is the level


84
00:04:14,976 --> 00:04:17,516
of security that's
appropriate for your product.


85
00:04:18,755 --> 00:04:20,276
And likewise, that
will translate


86
00:04:20,276 --> 00:04:22,856
into determining the
level of complexity


87
00:04:23,156 --> 00:04:25,466
in your implementation
that suits your needs.


88
00:04:28,036 --> 00:04:30,296
There's three key decisions that
you're going to need to make,


89
00:04:30,586 --> 00:04:32,746
and we'll call these out as
we go through this session


90
00:04:32,746 --> 00:04:33,526
to help you with that.


91
00:04:34,146 --> 00:04:35,616
The first decision
you're going to need


92
00:04:35,616 --> 00:04:38,746
to make is how will you verify
the signature in the receipt?


93
00:04:39,186 --> 00:04:43,116
What will you use to determine
that the receipt definitely came


94
00:04:43,116 --> 00:04:44,836
from Apple and hasn't
been tampered


95
00:04:44,876 --> 00:04:45,936
with since we minted it?


96
00:04:47,226 --> 00:04:51,196
Second is how will you verify
that the receipt is intended


97
00:04:51,196 --> 00:04:52,926
for your app on this device?


98
00:04:54,076 --> 00:04:57,916
And lastly, you will need to
decide how you wish to interpret


99
00:04:57,916 --> 00:04:59,576
that purchase data
that's contained


100
00:04:59,576 --> 00:05:00,966
within the receipt itself


101
00:05:01,016 --> 00:05:03,226
so you know exactly
what the user paid for.


102
00:05:06,036 --> 00:05:09,216
When you're making these
decisions, the primary thing


103
00:05:09,216 --> 00:05:12,916
that factors into this is
the value of your products


104
00:05:13,556 --> 00:05:15,946
and therefore how much
importance you place


105
00:05:16,466 --> 00:05:18,106
on protecting that revenue.


106
00:05:19,196 --> 00:05:20,256
Here's one way to look at it.


107
00:05:21,106 --> 00:05:23,246
If you are a very
high value product,


108
00:05:23,996 --> 00:05:26,906
you're typically selling perhaps
an in-app purchase that's


109
00:05:26,906 --> 00:05:30,156
designed to be a one-off
purchase, large value,


110
00:05:30,546 --> 00:05:33,996
and that one single in-app
purchase is the primary revenue


111
00:05:33,996 --> 00:05:36,656
stream for your app
and the primary enabler


112
00:05:36,656 --> 00:05:39,576
for all the features and content
that you're selling to the user.


113
00:05:40,796 --> 00:05:43,296
Now, in that sense, you're a lot
like a high-end jewelry store.


114
00:05:44,196 --> 00:05:46,176
And when you think about
your shopping experience


115
00:05:46,176 --> 00:05:47,796
in a jewelry store, you notice


116
00:05:47,796 --> 00:05:52,046
that they implement very complex
levels of security to make sure


117
00:05:52,046 --> 00:05:54,636
that not one single pearl
can walk out that door


118
00:05:55,026 --> 00:05:56,376
without having been paid for.


119
00:05:57,816 --> 00:05:59,336
You know, when you go
to a jewelry store,


120
00:05:59,336 --> 00:06:01,816
you see jewelry hidden
behind glass cases.


121
00:06:02,366 --> 00:06:04,556
You see security staff
positioned at the door.


122
00:06:04,996 --> 00:06:06,906
You might see security
wandering through,


123
00:06:06,906 --> 00:06:08,536
making sure that
everything's okay.


124
00:06:09,236 --> 00:06:11,186
There might be metal
detectors, you know,


125
00:06:11,186 --> 00:06:12,856
proof of purchase
checking, et cetera.


126
00:06:13,176 --> 00:06:16,466
It's a very high level of
security and quite complex.


127
00:06:17,096 --> 00:06:19,796
But the reason they
go to these lengths is


128
00:06:19,796 --> 00:06:21,816
because their business
model is centered


129
00:06:21,816 --> 00:06:25,776
around that one-off large
purchase that you're not going


130
00:06:25,776 --> 00:06:27,006
to make very frequently.


131
00:06:27,526 --> 00:06:30,836
But at the complete other end


132
00:06:30,836 --> 00:06:33,866
of the spectrum is
lower value product


133
00:06:34,566 --> 00:06:37,926
and these are typically the
lower value in-app purchases,


134
00:06:38,006 --> 00:06:41,716
dollar, $2, maybe up to $5,
and they're typically things


135
00:06:41,716 --> 00:06:45,356
that are consumables and your
business model probably relies


136
00:06:45,356 --> 00:06:47,316
on customers coming
back again and again


137
00:06:47,576 --> 00:06:50,586
to enjoy the same product,
buying more currency,


138
00:06:50,906 --> 00:06:52,436
buying more gas for their car,


139
00:06:52,436 --> 00:06:54,556
more blocks so they can
build amazing things.


140
00:06:55,676 --> 00:06:59,636
In this sense, you're a lot
more like a grocery store.


141
00:07:00,566 --> 00:07:02,986
Think about your shopping
experience in a grocery store.


142
00:07:03,336 --> 00:07:06,256
The grocery store wants you
to feel incredibly comfortable


143
00:07:06,256 --> 00:07:09,446
and happy shopping there so that
you'll come back again and again


144
00:07:09,446 --> 00:07:11,776
and again and keep
spending with them.


145
00:07:12,926 --> 00:07:15,386
Grocery stores are filled
with hundreds and hundreds


146
00:07:15,386 --> 00:07:17,386
of products that are
probably selling for $1


147
00:07:17,386 --> 00:07:18,616
or $2 and not much more.


148
00:07:19,596 --> 00:07:22,056
They rely on the same sort of
business model that you would


149
00:07:22,056 --> 00:07:24,316
if you were selling those
low-value consumables.


150
00:07:24,856 --> 00:07:27,016
They want you to have a
great shopping experience


151
00:07:27,396 --> 00:07:28,846
to feel comfortable and welcome


152
00:07:29,136 --> 00:07:31,216
and to enjoy it every
single time.


153
00:07:31,656 --> 00:07:33,366
And they're not going to
care too much if a couple


154
00:07:33,366 --> 00:07:35,676
of grapes walk out of the
store without being paid for,


155
00:07:36,046 --> 00:07:37,726
unless you keep coming
back again and again


156
00:07:37,726 --> 00:07:38,536
and stealing the grapes.


157
00:07:38,536 --> 00:07:42,886
So let's take a look
at how we work


158
00:07:42,886 --> 00:07:44,156
with receipts in the workflow.


159
00:07:45,486 --> 00:07:49,596
Starting off with the basics,
the receipt itself is stored


160
00:07:49,596 --> 00:07:51,946
in the App Bundle or in
your Sandbox container,


161
00:07:52,406 --> 00:07:55,806
and there's an API and NS bundle
that gets you the URL to locate


162
00:07:55,806 --> 00:07:56,826
where that receipt is.


163
00:07:57,786 --> 00:07:59,546
It's a single flat file.


164
00:07:59,916 --> 00:08:01,556
So it's really easy
to work with.


165
00:08:01,986 --> 00:08:03,166
It's not too complicated.


166
00:08:04,056 --> 00:08:07,186
Contained within that single
flat file is purchased data


167
00:08:07,186 --> 00:08:08,656
about the app purchase itself,


168
00:08:08,656 --> 00:08:10,726
as well as in-app purchases
that have been made.


169
00:08:11,636 --> 00:08:13,996
And there's also a
signature that allows us


170
00:08:14,306 --> 00:08:15,546
to check the authenticity.


171
00:08:15,546 --> 00:08:18,326
You see, we take that
purchase information,


172
00:08:18,726 --> 00:08:20,996
what you're particularly
interested in as a developer,


173
00:08:21,436 --> 00:08:25,096
and wrap it around certificates
and signatures that make sure


174
00:08:25,096 --> 00:08:27,766
that when we write that purchase
information into the receipt,


175
00:08:28,406 --> 00:08:31,906
we sign it and add a signature
that means you can verify


176
00:08:32,015 --> 00:08:35,285
that it's exactly as we intended
when we minted the receipt


177
00:08:35,426 --> 00:08:38,496
and no one's tried to fake
it by adding in any products,


178
00:08:38,765 --> 00:08:40,796
changing purchase
information, et cetera.


179
00:08:41,376 --> 00:08:44,826
And we built this
on open standards.


180
00:08:45,306 --> 00:08:49,376
In particular, the signing that
we use to wrap that payload


181
00:08:49,376 --> 00:08:52,356
of data in a signature so it
can't be tampered with is known


182
00:08:52,356 --> 00:08:55,266
as a PKCS#7 Cryptographic
Container.


183
00:08:55,936 --> 00:08:57,376
Don't let the acronyms
fool you here.


184
00:08:57,696 --> 00:08:59,606
There's a lot of
information available online


185
00:08:59,606 --> 00:09:02,276
and these are very widely
used in many, many places.


186
00:09:03,876 --> 00:09:06,116
The data itself in that payload,


187
00:09:06,246 --> 00:09:08,996
the purchase information,
we encode that.


188
00:09:09,196 --> 00:09:10,966
That is, we structure
it at the byte level,


189
00:09:11,426 --> 00:09:13,426
using a standard called ASN.1.


190
00:09:14,086 --> 00:09:16,886
Now, you would be
amazed at the huge number


191
00:09:16,976 --> 00:09:18,996
of places that ASN.1 is used.


192
00:09:19,476 --> 00:09:21,676
It's a standard that has
been around for a very,


193
00:09:21,676 --> 00:09:24,006
very long time, which is great


194
00:09:24,036 --> 00:09:25,866
because when you combine
the fact that both


195
00:09:25,866 --> 00:09:28,936
of these are very widely used,
it means that you're going


196
00:09:28,936 --> 00:09:31,126
to find that you're not
the first person to try


197
00:09:31,126 --> 00:09:32,526
and implement support for this.


198
00:09:33,376 --> 00:09:35,486
In fact, as we progress
through this session,


199
00:09:36,126 --> 00:09:38,446
you'll see that all those
decisions you need to make,


200
00:09:38,736 --> 00:09:40,176
they generally span this gamut.


201
00:09:40,626 --> 00:09:43,276
From at one end of the extreme,


202
00:09:43,276 --> 00:09:45,016
there will be off
the shelf offerings


203
00:09:45,016 --> 00:09:47,166
that you can simply pick up
and run with straight away.


204
00:09:48,286 --> 00:09:50,406
In the middle ground, there's
probably a lot of sample code


205
00:09:50,406 --> 00:09:53,676
out there that you can find
and maybe copy and adjust it


206
00:09:53,676 --> 00:09:54,906
to suit your needs somewhat.


207
00:09:54,906 --> 00:09:58,006
But then, because these
are open standards


208
00:09:58,496 --> 00:10:00,636
and the specifications
are freely available,


209
00:10:00,636 --> 00:10:03,306
you're completely empowered to
write your own implementation


210
00:10:03,636 --> 00:10:05,286
if that was important to you.


211
00:10:06,126 --> 00:10:08,166
That is, if you want
complete control


212
00:10:09,076 --> 00:10:13,856
over how you protect your
revenue, you can do that.


213
00:10:14,306 --> 00:10:15,326
So some of the options.


214
00:10:17,206 --> 00:10:19,626
OpenSSL, which I'm sure
everyone has heard of,


215
00:10:19,786 --> 00:10:21,896
is a cryptographic library


216
00:10:22,036 --> 00:10:24,276
that serves many
functions beyond just HTTPS


217
00:10:24,276 --> 00:10:26,936
and secure sockets that
it's more widely known for.


218
00:10:27,636 --> 00:10:31,256
OpenSSL includes support for not
only doing the PKCS#7 signature


219
00:10:31,256 --> 00:10:34,106
verification, but also
for reading ASN.1.


220
00:10:34,186 --> 00:10:36,666
So it's kind of a one-stop
shop if you wanted a library


221
00:10:36,666 --> 00:10:38,196
that was available that
could do this for you.


222
00:10:39,266 --> 00:10:41,306
There's also some other command
line tools that can help you


223
00:10:41,306 --> 00:10:42,746
out with this, and I'm
sure there is a lot


224
00:10:42,746 --> 00:10:43,856
of other offerings out there.


225
00:10:44,706 --> 00:10:46,326
But you can still
create your own


226
00:10:46,526 --> 00:10:48,286
if that's what you want to do.


227
00:10:49,126 --> 00:10:51,146
So what I'm going to take you


228
00:10:51,146 --> 00:10:53,886
through in this session
is a three-step process


229
00:10:53,886 --> 00:10:56,476
that you can use to
verify these receipts.


230
00:10:56,996 --> 00:10:59,806
The first thing we have
to do is make sure we know


231
00:10:59,806 --> 00:11:03,296
that the receipt is
authentic and trusted.


232
00:11:04,106 --> 00:11:06,956
That is, it came from Apple
and no one's tampered with it.


233
00:11:08,026 --> 00:11:10,756
Once we know we have a receipt
that is authentic and trusted,


234
00:11:11,616 --> 00:11:14,506
we can move on to confirming
that the receipt was


235
00:11:14,506 --> 00:11:17,756
in fact intended for
our app on this device.


236
00:11:18,826 --> 00:11:20,716
Because just as it's
important to make sure


237
00:11:20,716 --> 00:11:22,606
that no one's tampered with
the receipt, we also want


238
00:11:22,606 --> 00:11:24,976
to make sure no one's just
copied it from another device.


239
00:11:27,396 --> 00:11:30,456
Now, once we have a receipt
that we know we trust and it's


240
00:11:30,456 --> 00:11:33,196
for our app on this single
device, we can go ahead


241
00:11:33,196 --> 00:11:35,106
and start interpreting
that purchase data


242
00:11:35,316 --> 00:11:37,286
to know exactly what
the user has paid for.


243
00:11:38,056 --> 00:11:40,366
I'm going to start
this off with a demo.


244
00:11:41,446 --> 00:11:46,036
I have here a very simple
project that's just going


245
00:11:46,036 --> 00:11:48,616
to get us started in terms of
getting a receipt to work with.


246
00:11:49,346 --> 00:11:51,356
I mean, all of this is great,
but if you haven't been able


247
00:11:51,356 --> 00:11:54,216
to get a receipt to actually
start verifying the signature


248
00:11:54,216 --> 00:11:55,976
with, this process
can be difficult.


249
00:11:55,976 --> 00:11:57,536
So let's see how we
go about doing that.


250
00:11:58,066 --> 00:11:58,946
Really simple app.


251
00:11:59,496 --> 00:12:00,956
Application did finish launching


252
00:12:01,126 --> 00:12:04,156
and the first thing I do
is I call this NSBundle API


253
00:12:04,746 --> 00:12:06,666
to get the URL to the
App Store receipt.


254
00:12:07,586 --> 00:12:10,486
I'm simply going to use
NSFileManager here to determine


255
00:12:10,486 --> 00:12:11,836
if the file exists or not.


256
00:12:11,996 --> 00:12:13,696
That is, do we have a
receipt to work with?


257
00:12:14,746 --> 00:12:17,306
If we do, I've set myself up a
method that can go ahead and do


258
00:12:17,306 --> 00:12:18,456
that validation for me.


259
00:12:19,116 --> 00:12:24,786
But if not, if I don't have a
receipt, what I do is, on OS X,


260
00:12:24,786 --> 00:12:27,956
I exit my app with this
special exit code of 173.


261
00:12:28,876 --> 00:12:30,806
That tells the OS
and the App Store


262
00:12:30,806 --> 00:12:32,966
that you believe your
receipt is bad or missing


263
00:12:32,966 --> 00:12:35,536
and it lets the App Store go
and get a receipt for you.


264
00:12:36,586 --> 00:12:38,816
So this is all in
the documentation


265
00:12:38,816 --> 00:12:40,506
and it seems pretty
straightforward at this point.


266
00:12:41,126 --> 00:12:42,346
So I'm going to clean
this project


267
00:12:42,346 --> 00:12:43,576
to make sure we have no receipt.


268
00:12:43,576 --> 00:12:44,926
I'm going to build it.


269
00:12:45,006 --> 00:12:46,816
I'm going to run it.


270
00:12:47,556 --> 00:12:49,606
Now, notice I've got two
breakpoints set up here.


271
00:12:49,606 --> 00:12:52,656
The first is I wanted to check
that I got my App Store receipt.


272
00:12:52,656 --> 00:12:55,896
And if we see down here in the
debug console, I definitely did.


273
00:12:57,296 --> 00:13:00,406
And I'm going to ask FileManager
if that receipt exists.


274
00:13:01,076 --> 00:13:01,746
It says no.


275
00:13:01,746 --> 00:13:04,486
Of course, because I'm running
from Xcode and I have not


276
00:13:04,486 --> 00:13:05,586
yet put my app on the store.


277
00:13:05,586 --> 00:13:06,996
So of course we don't
have a receipt.


278
00:13:07,296 --> 00:13:09,826
But we want one so we can
start testing out validation.


279
00:13:10,696 --> 00:13:13,136
So the documentation
says to exit(173).


280
00:13:13,386 --> 00:13:17,036
Let's do that.


281
00:13:17,196 --> 00:13:18,136
And nothing happens.


282
00:13:19,226 --> 00:13:20,956
This is the first point
the developers kind


283
00:13:20,956 --> 00:13:21,696
of get stuck with.


284
00:13:22,226 --> 00:13:24,816
They get started with receipt
validation, put their code


285
00:13:24,816 --> 00:13:27,656
in place, run it in Xcode, and
go why doesn't this do anything?


286
00:13:27,886 --> 00:13:32,226
The reason for that is when you
run your app in Xcode like that


287
00:13:32,226 --> 00:13:36,786
and it hits that exit(173) code,
only Xcode sees that exit code.


288
00:13:37,296 --> 00:13:39,036
So the OS and the App
Store is not aware


289
00:13:39,036 --> 00:13:40,196
that you're actually
running your app


290
00:13:40,196 --> 00:13:41,326
and wanting to get a receipt.


291
00:13:41,796 --> 00:13:43,246
So here's a trick
to help you do that.


292
00:13:43,976 --> 00:13:46,216
This time when I run the app
and I hit the same breakpoint,


293
00:13:46,696 --> 00:13:49,946
I'm going to go down here
to the Dock, control+click


294
00:13:49,946 --> 00:13:54,536
on the app icon down here, and
I use options, show in Finder.


295
00:13:55,726 --> 00:13:58,566
That brings up Finder to
my debug-built version


296
00:13:58,566 --> 00:13:59,676
of the app that we're running.


297
00:14:00,276 --> 00:14:02,956
Because remember, I want this
to exit with that special code


298
00:14:02,956 --> 00:14:04,716
and for the App Store
to see that exit code


299
00:14:04,916 --> 00:14:06,276
so it gets me a new receipt.


300
00:14:06,766 --> 00:14:07,866
So watch what I do here.


301
00:14:07,866 --> 00:14:10,456
I go back to Xcode and I stop
that instance of the app.


302
00:14:11,706 --> 00:14:15,006
Back to Finder and now I
run the app from Finder.


303
00:14:15,006 --> 00:14:15,846
And look what happened.


304
00:14:16,166 --> 00:14:19,726
We did the same logic, receipt
wasn't there, and we exited 173.


305
00:14:20,106 --> 00:14:23,206
Now, the App Store has seen
that and is prompting me to sign


306
00:14:23,206 --> 00:14:25,976
in so that we can go and get a
receipt to start working with.


307
00:14:26,616 --> 00:14:29,156
And because my app was signed
with my development certificate,


308
00:14:29,316 --> 00:14:32,166
I'm connected to the App Store's
test environment using my


309
00:14:32,166 --> 00:14:35,456
iTunes-connected test accounts
to get a test receipt for us


310
00:14:35,456 --> 00:14:36,356
to start working with.


311
00:14:36,956 --> 00:14:38,926
So I sign in, we
get our receipt,


312
00:14:39,226 --> 00:14:41,326
and my really simple app
has finished launching


313
00:14:41,326 --> 00:14:41,906
with the receipt.


314
00:14:43,156 --> 00:14:45,686
Now, just to double check,
if I go back here into Xcode,


315
00:14:46,566 --> 00:14:48,026
we go to our URL to the receipt,


316
00:14:48,506 --> 00:14:50,976
and this time we have the
receipt and we're ready


317
00:14:50,976 --> 00:14:53,046
to start working with the
validation of that receipt.


318
00:14:54,626 --> 00:14:58,686
Now, if you are working with
iOS receipts, one other tip


319
00:14:58,716 --> 00:14:59,996
that you might find handy is


320
00:14:59,996 --> 00:15:01,476
if you're having
trouble getting a receipt


321
00:15:01,476 --> 00:15:04,236
in the test environment,
make an in-app purchase.


322
00:15:04,606 --> 00:15:05,926
When you make an
in-app purchase,


323
00:15:05,926 --> 00:15:07,566
you will get a new
receipt and you can use


324
00:15:07,566 --> 00:15:11,076
that to test your
validation code.


325
00:15:12,746 --> 00:15:13,936
So let's go to first step,


326
00:15:14,036 --> 00:15:15,836
verifying the signature
in that receipt.


327
00:15:15,836 --> 00:15:17,796
So we know that this
receipt is authentic,


328
00:15:17,996 --> 00:15:19,496
untrusted and unaltered.


329
00:15:21,596 --> 00:15:26,176
So this verification
of the signature,


330
00:15:26,176 --> 00:15:27,896
make sure the receipt
hasn't been altered


331
00:15:27,896 --> 00:15:30,096
since it left Apple, because
we don't want anyone tampering


332
00:15:30,096 --> 00:15:32,226
with it, and that
it came from Apple


333
00:15:32,466 --> 00:15:34,436
so that no one else can
just mint their own receipts


334
00:15:34,436 --> 00:15:37,196
that look otherwise valid,
but are in fact frauds.


335
00:15:38,786 --> 00:15:41,476
This is where the PKCS#7
cryptographic container


336
00:15:41,476 --> 00:15:42,026
comes in.


337
00:15:42,096 --> 00:15:45,856
It's how we wrap that protected
body of purchase information


338
00:15:46,186 --> 00:15:47,886
around those signatures
and certificates


339
00:15:48,106 --> 00:15:49,706
so that we can confirm
authenticity.


340
00:15:50,846 --> 00:15:52,316
Now, your options
available for you


341
00:15:52,316 --> 00:15:54,016
for doing this authenticity
check,


342
00:15:54,696 --> 00:15:57,096
we mentioned before there's -
OpenSSL can do this for you,


343
00:15:57,096 --> 00:15:59,036
there's no doubt many
other frameworks out there


344
00:15:59,036 --> 00:16:00,056
that can do this for you.


345
00:16:00,056 --> 00:16:03,456
But of course, you can roll
your own if you choose.


346
00:16:03,936 --> 00:16:07,246
To get you started, though,
the first thing we need


347
00:16:07,246 --> 00:16:08,526
to do is find that receipt.


348
00:16:08,806 --> 00:16:11,526
We call [NSBundle
mainBundle] appStoreReceiptURL.


349
00:16:11,826 --> 00:16:13,556
That gives a URL to the receipt.


350
00:16:14,716 --> 00:16:18,046
Once we've got that URL, we
need to get it read into memory


351
00:16:18,046 --> 00:16:20,096
so we can start working on
it, and that's as simple


352
00:16:20,096 --> 00:16:23,406
as using something like [NSData
alloc] initWithContentsOfURL.


353
00:16:23,406 --> 00:16:28,066
I'm going to walk you through
here an OpenSSL example of how


354
00:16:28,066 --> 00:16:29,516
to do this signature
verification.


355
00:16:29,896 --> 00:16:32,236
This is straight out of our
documentation we have online.


356
00:16:33,016 --> 00:16:35,936
But one thing to note is, this
example makes two assumptions.


357
00:16:36,536 --> 00:16:39,456
We assume that you've already
read the receipt into memory


358
00:16:39,456 --> 00:16:41,776
and have stored it in this
variable called b-receipt;


359
00:16:42,906 --> 00:16:46,216
And we also assume that you've
got a copy of Apple's root CA,


360
00:16:46,216 --> 00:16:48,726
our Route Certificate Authority,
which you can find online,


361
00:16:49,326 --> 00:16:51,266
and you have that in your
App Bundle and you've read it


362
00:16:51,266 --> 00:16:54,246
into memory and stored it in
this variable called -x509;.


363
00:16:54,776 --> 00:16:57,836
Why 509? Because
x509 is the standard


364
00:16:57,836 --> 00:16:59,836
by which that CA is encoded.


365
00:17:00,906 --> 00:17:02,966
So once we've got those
two key ingredients,


366
00:17:03,676 --> 00:17:07,636
the first thing we want to do
is convert that blob of binary


367
00:17:07,636 --> 00:17:09,175
that represents the
receipt in memory


368
00:17:09,596 --> 00:17:12,175
into a useful data structure
that we can start working with.


369
00:17:12,665 --> 00:17:14,685
And we do that by
calling the really simply


370
00:17:14,685 --> 00:17:18,486
and aptly named d2i-PKCS7-bio.


371
00:17:20,415 --> 00:17:21,685
Don't let these names fool you.


372
00:17:22,266 --> 00:17:24,806
What you'll see here is despite
the fact that these were named


373
00:17:24,846 --> 00:17:28,165
by someone very arcane,
these are simple concepts.


374
00:17:28,566 --> 00:17:30,836
We're reading a file into
memory, we're setting it


375
00:17:30,836 --> 00:17:33,616
up in a structure so we can work
with it, and we're checking -


376
00:17:33,726 --> 00:17:36,346
we're calling some functions
on it and checking the result.


377
00:17:36,766 --> 00:17:37,816
Anyone can do that.


378
00:17:38,936 --> 00:17:40,386
So once we've got
our data structure,


379
00:17:41,006 --> 00:17:42,316
we've got our receipt
in one hand.


380
00:17:42,596 --> 00:17:45,726
But the other thing we
need is our certificate


381
00:17:45,806 --> 00:17:48,216
that we expect this
receipt to match up against.


382
00:17:48,826 --> 00:17:50,476
Right? We want to
compare these two things.


383
00:17:50,476 --> 00:17:52,996
We have a receipt, but we
want to make sure that it came


384
00:17:52,996 --> 00:17:55,266
from Apple and hasn't been
altered since Apple created it.


385
00:17:55,746 --> 00:17:58,396
So we set up this
certificate store and we add


386
00:17:58,396 --> 00:18:00,166
into that store Apple's Root CA.


387
00:18:00,746 --> 00:18:03,096
Because if the certificate
- if the signature


388
00:18:03,096 --> 00:18:05,356
in the receipt is
valid, it has to appear


389
00:18:05,356 --> 00:18:08,256
that it's come from
Apple's Root CA.


390
00:18:08,636 --> 00:18:10,106
Now, we get into
the meat of this.


391
00:18:10,636 --> 00:18:13,886
We call the much better
named PKCS7-verify function,


392
00:18:14,396 --> 00:18:17,486
pass into it our receipt
and our certificate store,


393
00:18:17,486 --> 00:18:19,486
and we just check the result.


394
00:18:20,946 --> 00:18:22,426
If the result is equal to one,


395
00:18:22,806 --> 00:18:24,756
that means our receipt
signature is valid.


396
00:18:25,126 --> 00:18:28,536
It came from Apple, is
trusted, hasn't be altered


397
00:18:28,536 --> 00:18:30,076
since Apple minted the receipt.


398
00:18:31,026 --> 00:18:33,236
Now, you also get another bonus
from calling this function


399
00:18:33,236 --> 00:18:37,946
and that is that it will return
back to you the actual payload


400
00:18:37,946 --> 00:18:39,126
of the receipt itself.


401
00:18:39,276 --> 00:18:41,106
So that body of purchase
information


402
00:18:41,106 --> 00:18:43,516
that you can start inspecting
to know what the user paid for.


403
00:18:43,896 --> 00:18:45,566
And you get that
back in this example


404
00:18:45,566 --> 00:18:47,246
in the b-receiptPayload
variable.


405
00:18:49,136 --> 00:18:51,926
So I have another project
here that builds upon


406
00:18:51,926 --> 00:18:53,696
that simple example
that we saw before.


407
00:18:54,766 --> 00:18:59,516
You see here that I have my
same did finish launching method


408
00:18:59,516 --> 00:19:00,516
where I check the receipt.


409
00:19:01,086 --> 00:19:03,006
We know we've got a
receipt from the last demo.


410
00:19:03,176 --> 00:19:06,106
And so, I've fleshed out my
validate receipt URL method


411
00:19:06,766 --> 00:19:08,456
with these exact same calls


412
00:19:09,096 --> 00:19:11,246
that we just saw in
that slide before.


413
00:19:11,246 --> 00:19:13,176
So I'm going to build this.


414
00:19:15,256 --> 00:19:19,666
Huh, 12 warnings, 12 errors.


415
00:19:20,706 --> 00:19:21,826
Not a great start.


416
00:19:22,286 --> 00:19:23,446
Again, this is another point


417
00:19:23,446 --> 00:19:25,196
that the developers can
find really frustrating


418
00:19:25,196 --> 00:19:26,046
with this process.


419
00:19:26,916 --> 00:19:29,406
When you take this example code
and try and use it, you're going


420
00:19:29,406 --> 00:19:30,796
to run into a few roadblocks.


421
00:19:30,906 --> 00:19:32,446
But we can get through this.


422
00:19:33,576 --> 00:19:37,626
The first thing is, the reason
you're getting all these


423
00:19:37,896 --> 00:19:39,856
compiler warnings
here, telling you


424
00:19:39,856 --> 00:19:41,446
that all these methods
were deprecated,


425
00:19:41,966 --> 00:19:43,586
is because, in fact, they are.


426
00:19:43,956 --> 00:19:45,456
Why am I up here on
stage telling you


427
00:19:45,456 --> 00:19:46,706
to use deprecated methods?


428
00:19:47,746 --> 00:19:53,686
We deprecated these in OS X 10.7
because we want developers that,


429
00:19:53,686 --> 00:19:55,436
especially if you're
concerned about, you know,


430
00:19:55,436 --> 00:19:58,606
strong cryptography and security
like this, we want developers


431
00:19:58,606 --> 00:20:01,716
to create and roll their
own build of OpenSSL


432
00:20:01,716 --> 00:20:04,036
as a static library
and integrate


433
00:20:04,036 --> 00:20:08,266
that OpenSSL build straight
into your application's binary.


434
00:20:10,046 --> 00:20:10,576
Think of it this way.


435
00:20:11,306 --> 00:20:14,176
When you build your app and
link against things like UIKit


436
00:20:14,176 --> 00:20:17,536
and AppKit, that's an
external dependency.


437
00:20:18,436 --> 00:20:21,096
Your app can run on one machine,
on one version of the OS,


438
00:20:21,096 --> 00:20:23,386
and run just fine on
another version of the OS,


439
00:20:23,386 --> 00:20:25,836
even though AppKit and UIKit
might be very different.


440
00:20:26,286 --> 00:20:28,476
They're external dependencies
that can be swapped out from


441
00:20:28,476 --> 00:20:30,646
under you and, as long
as those APIs match


442
00:20:30,646 --> 00:20:33,076
up to what your app is
expecting, it'll run.


443
00:20:33,796 --> 00:20:38,936
But imagine how easy it would
be for someone who wanted to try


444
00:20:38,936 --> 00:20:42,736
and attack your app, to try
and rip you off, to simply swap


445
00:20:42,736 --> 00:20:46,956
out an external dependency,
like OpenSSL, for a version


446
00:20:46,956 --> 00:20:48,866
of OpenSSL that they
brought themselves


447
00:20:48,866 --> 00:20:49,846
that simply said, "Yeah.


448
00:20:49,846 --> 00:20:50,596
Everything's fine.


449
00:20:51,286 --> 00:20:52,126
This receipt's valid.


450
00:20:53,056 --> 00:20:53,966
Trust me."


451
00:20:54,096 --> 00:20:56,626
You see? When you use
that external dependency


452
00:20:56,626 --> 00:20:59,176
for strong cryptography and
privacy sort of stuff like this,


453
00:20:59,706 --> 00:21:02,296
you can run into problems where
you create a big attack vector


454
00:21:02,296 --> 00:21:04,186
that makes it really
easy for someone


455
00:21:04,186 --> 00:21:06,356
to circumvent the logic
you're putting in your app


456
00:21:06,356 --> 00:21:08,976
to protect your revenue and
enforce your business model.


457
00:21:10,326 --> 00:21:12,996
So what we need to do here
is build our own OpenSSL.


458
00:21:13,286 --> 00:21:16,166
Now, that's not as nearly
as scary as it sounds


459
00:21:16,166 --> 00:21:17,996
and I've got some tips
for you in the next slide.


460
00:21:19,026 --> 00:21:21,986
In fact, I've already built my
own OpenSSL and I have it here


461
00:21:22,566 --> 00:21:25,946
on the desktop in a
folder called OpenSSL.


462
00:21:26,196 --> 00:21:28,936
Now, when you build OpenSSL,
it produces two things for you,


463
00:21:29,836 --> 00:21:32,226
a folder called "include",
full of the header files


464
00:21:32,226 --> 00:21:34,716
for what we want to work
with, and also a "lib" folder


465
00:21:34,716 --> 00:21:37,586
that contains that .a static
library that we've built.


466
00:21:38,596 --> 00:21:41,146
Now, using this is
actually pretty simple.


467
00:21:41,456 --> 00:21:44,066
I like to keep my projects
pretty clean, so I'm going


468
00:21:44,066 --> 00:21:50,096
to go ahead and create myself
a group here called OpenSSL,


469
00:21:51,056 --> 00:21:51,656
if I can spell.


470
00:21:53,446 --> 00:21:54,056
There we go.


471
00:21:54,266 --> 00:21:57,286
And all I have to do is simply
drag and drop this built product


472
00:21:57,286 --> 00:21:59,446
from OpenSSL straight
into my project,


473
00:21:59,446 --> 00:22:01,366
header files and
static libraries.


474
00:22:01,976 --> 00:22:04,556
Make sure you click
this "Copy items


475
00:22:04,556 --> 00:22:06,516
into destination group folder".


476
00:22:06,886 --> 00:22:08,666
That makes sure that
we copy those headers


477
00:22:08,746 --> 00:22:10,876
and the static library
you've built directly


478
00:22:10,926 --> 00:22:12,326
into your project itself.


479
00:22:12,326 --> 00:22:14,226
Otherwise, you'll have a
dangling external dependency


480
00:22:14,226 --> 00:22:14,986
that might go away.


481
00:22:16,456 --> 00:22:17,016
So finish.


482
00:22:17,676 --> 00:22:20,256
I add in my freshly built
OpenSSL to my product.


483
00:22:20,626 --> 00:22:24,016
Cool. Build it.


484
00:22:24,276 --> 00:22:27,696
Build succeeds, but I still
have 11 compiler warnings and,


485
00:22:27,696 --> 00:22:28,816
if you're like me,
you care a lot


486
00:22:28,816 --> 00:22:30,756
about your project
building with zero warnings.


487
00:22:31,396 --> 00:22:33,506
So why are we still getting
these deprecated warnings?


488
00:22:33,506 --> 00:22:38,156
Because Xcode is trying to
build against the SDK that ships


489
00:22:38,156 --> 00:22:40,536
with the OS that has
that deprecated OpenSSL.


490
00:22:41,456 --> 00:22:43,996
The way we get around that
is we have to tell Xcode


491
00:22:44,456 --> 00:22:47,446
that for this app that we're
building, we actually want Xcode


492
00:22:47,446 --> 00:22:50,926
to use our OpenSSL that we
just added to the project.


493
00:22:51,786 --> 00:22:53,966
So I went to my project
settings here.


494
00:22:54,326 --> 00:22:57,436
I have clicked on this
target and I'm going


495
00:22:57,436 --> 00:22:58,486
to go to Build Settings.


496
00:22:58,886 --> 00:23:01,366
And as an option, you'll find an
item called Header Search Paths.


497
00:23:01,366 --> 00:23:04,806
I'm going to double-click
on that and I need


498
00:23:04,806 --> 00:23:07,746
to tell Xcode here where
to find those OpenSSL files


499
00:23:07,746 --> 00:23:08,406
that we just added.


500
00:23:09,106 --> 00:23:12,226
An easy trick for doing
that is, pop this open here


501
00:23:12,226 --> 00:23:14,596
on the side panel, find
one of the headers,


502
00:23:15,266 --> 00:23:19,026
open up this side inspector, and
there you'll see the full path


503
00:23:19,596 --> 00:23:22,306
to where that header file
is located in the project.


504
00:23:22,986 --> 00:23:27,276
Now, notice in this case, I've
got it within my project folder


505
00:23:27,426 --> 00:23:30,656
and it's in a folder hierarchy
called Include/include.


506
00:23:31,136 --> 00:23:34,846
Okay. So we just need to tell
Xcode to go and allow files


507
00:23:34,846 --> 00:23:37,066
to be imported from that
location for headers.


508
00:23:38,046 --> 00:23:40,856
So I double click here
and rather than having


509
00:23:40,856 --> 00:23:43,596
to enter the full directory
path, I can use a shortcut


510
00:23:43,596 --> 00:23:46,796
of saying it's in
SourceRoot/Include/include,


511
00:23:47,056 --> 00:23:49,536
because that's where we
saw the file just before.


512
00:23:50,516 --> 00:23:52,816
I add that in, put it to
the top, because I want


513
00:23:52,816 --> 00:23:54,686
that before anything
else in the system.


514
00:23:54,906 --> 00:23:57,876
I want to make sure we look
at my OpenSSL files first.


515
00:23:59,036 --> 00:24:03,046
Done. We see that was updated
there and close this file


516
00:24:03,046 --> 00:24:05,226
and go back to our AppDelegate,
where we had all these warnings.


517
00:24:06,856 --> 00:24:11,076
Done. All those compiler
warnings went away.


518
00:24:11,796 --> 00:24:14,566
Because now, we're building
our project against our OpenSSL


519
00:24:14,566 --> 00:24:18,436
that we built, that we know the
integrity of, that we're going


520
00:24:18,436 --> 00:24:21,566
to ship built into our app
binary to protect our revenue


521
00:24:21,566 --> 00:24:22,596
and check our receipts.


522
00:24:24,056 --> 00:24:25,576
So let's run this
and see how it goes.


523
00:24:26,796 --> 00:24:29,266
So we've already got a
receipt from the earlier demo


524
00:24:29,266 --> 00:24:32,326
that we did and now we can
enter our validateReceiptAtURL


525
00:24:32,436 --> 00:24:32,976
method here.


526
00:24:34,156 --> 00:24:36,486
These are the same calls we
saw just on the slide before.


527
00:24:36,486 --> 00:24:37,736
I load the receipt into memory.


528
00:24:37,796 --> 00:24:39,176
I load the Root CA
in the memory.


529
00:24:40,126 --> 00:24:43,976
d2i-PKCS7-bio to load
that ball of receipt


530
00:24:43,976 --> 00:24:46,326
into a usable data
structure called P7.


531
00:24:46,986 --> 00:24:50,376
Create my certificate store and
now I'm ready to do the magic.


532
00:24:51,006 --> 00:24:52,836
Does this receipt
stack up against


533
00:24:52,836 --> 00:24:54,016
that Root CA Certificate?


534
00:24:54,556 --> 00:24:58,606
I step over that and
if I look down here


535
00:24:58,606 --> 00:25:00,066
in the console, sure enough.


536
00:25:00,566 --> 00:25:01,456
Result is 1.


537
00:25:02,486 --> 00:25:04,206
That means we can now
move forward knowing


538
00:25:04,206 --> 00:25:06,736
that we have a real,
valid and trusted receipt


539
00:25:06,876 --> 00:25:09,486
that we can start getting
purchase information out of.


540
00:25:09,606 --> 00:25:12,546
And well, before we do that, we
need to confirm that it's for -


541
00:25:12,546 --> 00:25:14,156
intended for our
app on this device.


542
00:25:15,566 --> 00:25:17,396
But now, we're over the
hurdle of not only working


543
00:25:17,396 --> 00:25:19,356
with the receipt that we got
from the test environment,


544
00:25:19,656 --> 00:25:22,436
but we now got OpenSSL
integrated into our project


545
00:25:22,926 --> 00:25:25,766
to be ready to be built
for both iOS and OS X.


546
00:25:26,346 --> 00:25:28,896
Although I'm demoing
everything here using OS X,


547
00:25:29,876 --> 00:25:32,796
everything I cover here applies
to iOS, just as it does on OS X,


548
00:25:32,796 --> 00:25:34,666
and if there's any
platform differences,


549
00:25:34,696 --> 00:25:35,686
I'll call them out for you.


550
00:25:36,746 --> 00:25:39,236
A couple of tips on
building OpenSSL for you.


551
00:25:39,456 --> 00:25:42,716
First is, you need to build
it as a static library,


552
00:25:43,386 --> 00:25:45,756
not a dylib, not a
framework, not something


553
00:25:45,756 --> 00:25:47,936
that can be external
to your binary.


554
00:25:48,426 --> 00:25:50,726
You need it to be a
static library so that


555
00:25:50,726 --> 00:25:54,086
when you build your app and
link it, it takes that .a


556
00:25:54,086 --> 00:25:56,886
and puts it right
into your app's binary


557
00:25:56,966 --> 00:25:58,716
so no one else can
swap it out from you.


558
00:25:58,716 --> 00:26:01,696
Now, if you're building
for multiple architectures,


559
00:26:01,696 --> 00:26:04,086
which you almost certainly will
be if you're building for iOS,


560
00:26:04,086 --> 00:26:05,636
for all the different
arm architectures,


561
00:26:06,616 --> 00:26:08,576
then what you need to do
is build a separate .a,


562
00:26:08,576 --> 00:26:11,936
a separate static library,
for each architecture you want


563
00:26:11,936 --> 00:26:15,056
to support, be it
arm, armv7, arm64,


564
00:26:15,056 --> 00:26:16,876
whatever you might
need to build for.


565
00:26:17,076 --> 00:26:21,086
Or for x86-64 in OS X.


566
00:26:21,376 --> 00:26:24,426
Now, when you create those
individual .a static libraries


567
00:26:24,426 --> 00:26:27,656
for each of those architectures,
you use the lipo command tool


568
00:26:28,156 --> 00:26:30,826
to take all of those little
.a architecture slices


569
00:26:30,826 --> 00:26:32,866
and combine them
into one fat binary


570
00:26:32,866 --> 00:26:36,956
that is one single .a static
library that combines all


571
00:26:36,956 --> 00:26:38,266
of our slices for all


572
00:26:38,266 --> 00:26:39,906
of our architectures
we want to support.


573
00:26:40,946 --> 00:26:42,926
And then, you can just drag
that straight into your project,


574
00:26:42,926 --> 00:26:44,046
like we did just before.


575
00:26:44,966 --> 00:26:46,296
Now, when you build OpenSSL,


576
00:26:46,876 --> 00:26:48,686
the first thing you do
is use a configure script


577
00:26:48,686 --> 00:26:51,676
to configure OpenSSL for the
platforms you're building on.


578
00:26:52,226 --> 00:26:53,786
Here's two tips that
you'll find handy.


579
00:26:54,216 --> 00:26:57,056
If you're building for
OS X 64-bit, configure it


580
00:26:57,056 --> 00:27:01,506
with the darwin64-x86-64-cc
host type.


581
00:27:01,646 --> 00:27:04,376
If you see documentation
trying to tell you to use some


582
00:27:04,376 --> 00:27:05,786
of the BASD generic types,


583
00:27:06,176 --> 00:27:07,456
you're going to run
into trouble.


584
00:27:07,996 --> 00:27:09,086
So this is much easier


585
00:27:09,086 --> 00:27:12,536
and it ensures a proper
build of OpenSSL on x86-64.


586
00:27:12,536 --> 00:27:16,006
But if you're using - if
you're building for iOS,


587
00:27:16,666 --> 00:27:18,986
try using the iPhone
OS cross host type


588
00:27:18,986 --> 00:27:19,856
in the configure script


589
00:27:19,856 --> 00:27:21,646
to configure it for
iOS accordingly.


590
00:27:22,176 --> 00:27:25,426
But you will definitely not
be the first person ever


591
00:27:25,426 --> 00:27:28,836
that has tried to build
OpenSSL for either OS X or iOS.


592
00:27:29,286 --> 00:27:32,026
We deprecated OpenSSL
a while back in OS X


593
00:27:32,026 --> 00:27:35,976
and we never shipped an OpenSSL
in iOS that developers can use.


594
00:27:36,256 --> 00:27:37,786
So lots of folks have
been through this


595
00:27:37,786 --> 00:27:38,966
for lots of different reasons.


596
00:27:39,256 --> 00:27:41,336
There's lots of examples
available to you online.


597
00:27:44,956 --> 00:27:46,756
Two notes about doing
the verification.


598
00:27:46,806 --> 00:27:49,636
No matter how you do the
verification, be it OpenSSL,


599
00:27:49,636 --> 00:27:51,106
roll your own, or
another offering,


600
00:27:51,966 --> 00:27:54,896
do check the expiry
date on the certificate.


601
00:27:56,086 --> 00:27:59,576
When you're contacting a web
server via HTTPS, it's important


602
00:28:00,116 --> 00:28:03,616
that you verify the expiry
date of the signature.


603
00:28:04,236 --> 00:28:06,056
You don't want to be
talking to a web server


604
00:28:06,056 --> 00:28:08,786
out there using a secured
transport with a certificate


605
00:28:08,786 --> 00:28:09,906
that has since expired.


606
00:28:10,956 --> 00:28:13,046
But the reverse is
true here for receipts.


607
00:28:13,306 --> 00:28:16,036
Keep in mind the fact that we
mint this receipt at a point


608
00:28:16,036 --> 00:28:19,626
in time and that comes with your
app when someone downloads it


609
00:28:19,626 --> 00:28:20,816
or makes an in-app purchase.


610
00:28:21,576 --> 00:28:22,756
Now, at that point in time,


611
00:28:22,756 --> 00:28:24,626
there will be certificates
included in that receipt


612
00:28:24,946 --> 00:28:25,926
that have an expiry date.


613
00:28:27,586 --> 00:28:30,776
If that - if someone buys
your app today and then a year


614
00:28:30,776 --> 00:28:33,416
down the track, that certificate
expires within the receipt,


615
00:28:33,806 --> 00:28:35,746
that does not make
the receipt invalid.


616
00:28:36,916 --> 00:28:39,296
The receipt is just as
valid as it was the day


617
00:28:39,296 --> 00:28:40,106
that you purchased it.


618
00:28:40,886 --> 00:28:44,446
And it would be a terrible
experience for that user if all


619
00:28:44,446 --> 00:28:46,716
of a sudden your app
stopped working only


620
00:28:46,716 --> 00:28:49,316
because the receipt has
a certificate in there


621
00:28:49,316 --> 00:28:50,366
that has since expired.


622
00:28:51,596 --> 00:28:54,306
But what you do absolutely
want to make sure you do


623
00:28:54,306 --> 00:28:57,526
when you do your receipt
validation is evaluate the trust


624
00:28:57,526 --> 00:29:00,186
of the certificates
right up to the Root CA.


625
00:29:00,186 --> 00:29:02,876
You see, the certificates
exist in a chain.


626
00:29:04,086 --> 00:29:05,796
But at the head of the
chain, at the root,


627
00:29:05,946 --> 00:29:08,296
has to be Apple's Root
Certificate Authority.


628
00:29:08,746 --> 00:29:11,236
That's the only way you can be
absolutely certain that it came


629
00:29:11,236 --> 00:29:15,016
from us and not from someone
else trying to pose as Apple.


630
00:29:15,016 --> 00:29:19,416
I want to take a
quick word, though,


631
00:29:19,416 --> 00:29:21,266
about examples and sample code.


632
00:29:21,886 --> 00:29:23,546
I've mentioned a lot
throughout this session


633
00:29:23,546 --> 00:29:26,536
that there are a lot
of samples out there.


634
00:29:26,536 --> 00:29:29,326
There's examples I'm sure,
there's off the shelf offerings


635
00:29:29,326 --> 00:29:31,046
that you could literally
download and put straight


636
00:29:31,046 --> 00:29:32,576
in your project that
would do this for you.


637
00:29:32,786 --> 00:29:36,156
But that convenience
comes at a price.


638
00:29:37,316 --> 00:29:40,436
You have to keep in mind
that reusing code brings


639
00:29:40,436 --> 00:29:41,996
with it bugs and
vulnerabilities.


640
00:29:42,336 --> 00:29:44,156
No matter how good
the developer is,


641
00:29:45,236 --> 00:29:47,376
no matter how well you
use the sample code,


642
00:29:47,376 --> 00:29:51,976
no matter how much you might
have paid for it, any code comes


643
00:29:51,976 --> 00:29:53,976
with bugs and possible
vulnerabilities.


644
00:29:54,506 --> 00:29:58,576
And the more people that
use the exact same way


645
00:29:58,576 --> 00:30:01,756
of doing receipt validation,
the more there is the chance


646
00:30:01,756 --> 00:30:04,966
of one exploit affecting
many, many apps.


647
00:30:06,026 --> 00:30:08,266
You know back in that
jewelry example imagine


648
00:30:08,266 --> 00:30:11,636
if every jewelry shop around
the world used the same lock


649
00:30:11,636 --> 00:30:14,596
on their cabinets, and
then one day someone finds


650
00:30:14,596 --> 00:30:16,306
out a really easy way
to open that lock.


651
00:30:16,916 --> 00:30:20,166
Not going to be good for anyone
owning a jewelry store, right?


652
00:30:21,116 --> 00:30:22,306
Same sort of principle here.


653
00:30:23,456 --> 00:30:25,516
Although this can seem
so convenient to just go


654
00:30:25,516 --> 00:30:27,226
and grab something off
GitHub or somewhere else,


655
00:30:27,226 --> 00:30:28,566
and drop it into your
project, and, "Hey,


656
00:30:28,566 --> 00:30:30,436
I've got receipt validation
and protected revenue."


657
00:30:31,126 --> 00:30:33,926
You need to understand the
risks of what you're bringing


658
00:30:33,926 --> 00:30:37,326
in because that's your revenue
stream at the end of the day,


659
00:30:37,706 --> 00:30:39,376
not the third-party
that wrote that code,


660
00:30:39,486 --> 00:30:42,206
not the nice individual
that put up some sample code


661
00:30:42,206 --> 00:30:43,226
to help you get this done.


662
00:30:43,486 --> 00:30:44,356
It's not their revenue.


663
00:30:44,356 --> 00:30:45,316
It's your revenue.


664
00:30:46,826 --> 00:30:49,196
So make sure you make decisions
that suit your product.


665
00:30:50,366 --> 00:30:52,626
Maybe you're okay with those
sorts of vulnerabilities,


666
00:30:52,626 --> 00:30:53,946
and bugs, and the possibility


667
00:30:53,946 --> 00:30:55,666
of a single exploit
affecting your app.


668
00:30:55,956 --> 00:30:58,156
Maybe that suits the
business model and level


669
00:30:58,156 --> 00:30:59,146
of protection you want.


670
00:30:59,896 --> 00:31:03,946
But either way, know the risks
and own those risks yourself.


671
00:31:05,256 --> 00:31:08,696
All right, so we've got a
receipt that we know is trusted


672
00:31:08,696 --> 00:31:10,196
and verified, and
it came from Apple.


673
00:31:10,986 --> 00:31:12,956
Now we need to make
sure that it is intended


674
00:31:12,956 --> 00:31:15,186
for your app on this
device only.


675
00:31:15,986 --> 00:31:20,256
To do that, we need to look
at the receipt payload itself.


676
00:31:20,556 --> 00:31:22,616
Now this is a very
high-level look


677
00:31:22,616 --> 00:31:24,116
at how a receipt is structured.


678
00:31:24,496 --> 00:31:26,726
It's structured as a
series of attributes.


679
00:31:27,306 --> 00:31:28,996
You could think of these
attributes as a cross


680
00:31:28,996 --> 00:31:31,056
between an NSArray
and an NSDictionary.


681
00:31:32,166 --> 00:31:35,026
They're like an NSDictionary
because they have things


682
00:31:35,026 --> 00:31:36,436
like a type and a value,


683
00:31:36,436 --> 00:31:38,756
a lot like a dictionary
has a key and an object.


684
00:31:38,986 --> 00:31:41,926
But they're like an Array
because there is a sequence


685
00:31:41,926 --> 00:31:43,766
of these throughout the receipt


686
00:31:43,766 --> 00:31:45,916
that you can loop
over to interpret.


687
00:31:46,936 --> 00:31:49,886
They also have a version on
each of these attributes,


688
00:31:50,226 --> 00:31:51,996
but that's not too
important to us right now.


689
00:31:51,996 --> 00:31:55,716
The key thing we need to know
is inside that body of data


690
00:31:55,716 --> 00:31:58,156
in the receipt is a
series of attributes.


691
00:31:58,226 --> 00:32:00,596
Each attribute has a type
that tells us what it is,


692
00:32:00,596 --> 00:32:03,796
what it means, and then
a value that corresponds


693
00:32:03,796 --> 00:32:05,586
to what this attribute
is telling us.


694
00:32:06,046 --> 00:32:10,256
So the first thing we
need to do is check


695
00:32:10,256 --> 00:32:12,946
if this receipt was actually
intended for our app.


696
00:32:13,066 --> 00:32:15,316
In those attributes
there'll be one called Type 2


697
00:32:15,506 --> 00:32:16,746
and one called Type 3.


698
00:32:17,196 --> 00:32:18,926
All the attributes
are named by a number.


699
00:32:19,566 --> 00:32:21,646
So attribute Type
2 in the receipt,


700
00:32:21,756 --> 00:32:23,286
if you read that
attribute's value,


701
00:32:23,286 --> 00:32:24,696
it will be the Bundle Identifier


702
00:32:24,696 --> 00:32:26,186
that this receipt
was intended for.


703
00:32:26,766 --> 00:32:28,566
And then Type 3 is
the Bundle Version


704
00:32:28,566 --> 00:32:30,056
that this receipt
was intended for.


705
00:32:31,046 --> 00:32:33,006
So you can check the
bundle identifier,


706
00:32:33,006 --> 00:32:34,316
make sure it's for your app.


707
00:32:34,726 --> 00:32:35,906
You can check the bundle version


708
00:32:35,906 --> 00:32:37,786
if you want an even
higher level of security.


709
00:32:37,786 --> 00:32:39,676
Perhaps you want to
make absolutely certain


710
00:32:39,676 --> 00:32:42,286
that someone's not using a
receipt from an older version


711
00:32:42,286 --> 00:32:44,756
of your app that perhaps
doesn't have the same features


712
00:32:44,756 --> 00:32:45,306
and content.


713
00:32:45,846 --> 00:32:49,836
The one thing to note
is use hardcoded values


714
00:32:49,836 --> 00:32:50,696
for the comparison.


715
00:32:51,256 --> 00:32:54,616
Why? Because if you
simply grab the values


716
00:32:54,616 --> 00:32:57,816
out of your Info.plist and
compare them against the values


717
00:32:57,816 --> 00:33:00,476
in the receipt it's all
too easy for someone to go


718
00:33:00,476 --> 00:33:02,756
and edit your Info.plist
and make it look exactly


719
00:33:02,756 --> 00:33:04,676
like the receipt that they're
trying to fake you with.


720
00:33:05,526 --> 00:33:08,966
So hardcode those values into
your app that you're expecting,


721
00:33:09,316 --> 00:33:11,416
that way they're part of
the code signed at binary,


722
00:33:11,946 --> 00:33:13,406
much harder to try
and circumvent.


723
00:33:13,916 --> 00:33:16,976
Now that was a very
high-level look


724
00:33:17,596 --> 00:33:19,316
at how this receipt
data is structured


725
00:33:19,316 --> 00:33:20,366
in terms of attributes.


726
00:33:20,456 --> 00:33:22,126
But as I said before,
this is encoded,


727
00:33:22,446 --> 00:33:26,456
as in the bytes are arranged,
using a standard called ASN.1.


728
00:33:27,796 --> 00:33:31,096
There's two other attributes
along with Type 2 and Type 3.


729
00:33:31,846 --> 00:33:34,536
So we use Type 2 and Type 3 to
confirm that this receipt was


730
00:33:34,536 --> 00:33:37,596
for our app, but now
we need to confirm


731
00:33:37,596 --> 00:33:39,926
that it was actually
intended for this device only


732
00:33:40,176 --> 00:33:42,706
because we don't want someone
to simply be able to copy a -


733
00:33:42,706 --> 00:33:44,346
a receipt around
to their friends


734
00:33:44,716 --> 00:33:47,546
so that they can use the
app without paying for it.


735
00:33:47,546 --> 00:33:50,676
So included in the receipt
is an attribute called Type 4


736
00:33:50,676 --> 00:33:52,866
which is an opaque value,
just a blob of bytes,


737
00:33:53,576 --> 00:33:56,066
and Type 5 which
is a SHA-1 hash.


738
00:33:56,186 --> 00:33:58,916
Now if you're not familiar
with hashing, hashing is a way


739
00:33:58,916 --> 00:34:02,546
to take a large bit of data
and boil it down to a unique,


740
00:34:02,726 --> 00:34:05,416
smaller data that will
be absolutely unique


741
00:34:05,416 --> 00:34:08,016
to that larger data set that
was the input to the hash.


742
00:34:10,085 --> 00:34:14,606
So this Type 5 attribute is
a SHA-1 hash of 3 key values.


743
00:34:15,366 --> 00:34:19,606
It's a Bundle ID, plus a unique
device identifier like the GUI


744
00:34:19,606 --> 00:34:23,536
on OS X or the device
for vendor on iOS,


745
00:34:24,295 --> 00:34:26,065
and also this Opaque Value.


746
00:34:26,956 --> 00:34:29,795
How does this work to actually
confirm that it's intended


747
00:34:29,795 --> 00:34:32,286
for your device,
for a single device?


748
00:34:33,726 --> 00:34:36,835
You see, the App Store
knows these three key pieces


749
00:34:36,835 --> 00:34:39,186
of information at the time
that purchase is made.


750
00:34:39,786 --> 00:34:41,556
When someone taps the
buy button on your app


751
00:34:41,556 --> 00:34:43,056
or on an in-app purchase
and completes


752
00:34:43,056 --> 00:34:45,775
that transaction the app
store knows three key things.


753
00:34:46,186 --> 00:34:48,806
One, we know the Bundle ID of
the app making the purchase.


754
00:34:49,496 --> 00:34:52,476
Two, we know the device
identifier from that device


755
00:34:52,476 --> 00:34:54,815
because it's sent to the store
when that transaction is made.


756
00:34:55,525 --> 00:34:59,176
And three, on server side
we create this opaque value,


757
00:34:59,176 --> 00:35:01,756
this bit of random entropy that
we inject into this process


758
00:35:02,076 --> 00:35:03,186
to make it harder to attack.


759
00:35:03,926 --> 00:35:06,536
So the App Store knows these
three key things at the time


760
00:35:06,536 --> 00:35:08,666
of purchase, creates
the SHA-1 hash,


761
00:35:09,166 --> 00:35:10,496
bakes it into the receipt along


762
00:35:10,496 --> 00:35:12,116
with that opaque
value that we used.


763
00:35:12,546 --> 00:35:16,206
But the great thing is that your
app can know these same three


764
00:35:16,206 --> 00:35:18,776
values at the time of
doing receipt validation.


765
00:35:20,076 --> 00:35:21,986
So because you know
these three values,


766
00:35:22,316 --> 00:35:24,726
and you can string them together
in that long concatenation


767
00:35:24,726 --> 00:35:26,096
of bytes and create the hash,


768
00:35:26,826 --> 00:35:28,946
and the App Store knew
these three key values


769
00:35:28,946 --> 00:35:31,016
and created the same hash
and put it in the receipt,


770
00:35:31,076 --> 00:35:35,346
if the hash you calculate
exactly matches the hash


771
00:35:35,346 --> 00:35:36,696
that the App Store
created and put


772
00:35:36,696 --> 00:35:38,656
in the receipt then
you're certain


773
00:35:38,976 --> 00:35:40,326
that this receipt was intended


774
00:35:40,326 --> 00:35:42,086
for your app on this
device only.


775
00:35:42,846 --> 00:35:45,476
It's completely unique
to this device.


776
00:35:48,086 --> 00:35:52,906
Now about ASN.1,
these high-level -


777
00:35:52,906 --> 00:35:54,486
this high-level look
at the attributes


778
00:35:55,256 --> 00:35:57,536
that explains how we structured
them, and how you work


779
00:35:57,536 --> 00:35:59,406
with the different attributes,
and how we store them


780
00:35:59,406 --> 00:36:01,556
as an array of attributes
with a type and a value.


781
00:36:01,556 --> 00:36:04,076
But how are they encoded
at the actual byte level?


782
00:36:04,076 --> 00:36:05,456
How do you work with
this in code?


783
00:36:06,396 --> 00:36:09,076
The way you do that is
by harnessing ASN.1.


784
00:36:09,076 --> 00:36:13,496
ASN.1 is this way in which we
can use a textual definition


785
00:36:13,496 --> 00:36:14,666
that you see here onscreen


786
00:36:15,116 --> 00:36:18,556
to describe how the bytes
are arranged in the receipt.


787
00:36:19,756 --> 00:36:21,836
We provide you with
this ASN.1 definition


788
00:36:21,836 --> 00:36:24,366
of how we've structured the
receipt, and what you're seeing


789
00:36:24,366 --> 00:36:27,806
up onscreen is that you have
a receipt module defined,


790
00:36:28,446 --> 00:36:30,256
and in that receipt
there is a payload,


791
00:36:30,826 --> 00:36:33,536
and that payload is a set
of receipt attributes.


792
00:36:34,376 --> 00:36:36,726
And the receipt attribute
will be part of a sequence,


793
00:36:37,026 --> 00:36:39,896
and it contains a type,
which relates to that type


794
00:36:39,896 --> 00:36:42,816
that we just saw before,
as well as a value


795
00:36:42,816 --> 00:36:44,896
that is an octet string
or a bunch of bytes.


796
00:36:45,516 --> 00:36:47,856
And that refers to things
like that Opaque Value


797
00:36:47,856 --> 00:36:52,216
in the SHA-1 hash that
we looked at just before.


798
00:36:52,216 --> 00:36:57,676
Working with ASN.1, the trick
is you need to find a way to go


799
00:36:57,676 --> 00:37:00,026
from that textual
definition that's based


800
00:37:00,026 --> 00:37:03,336
on the open standard of OpenSSL
to actually being able to read,


801
00:37:03,336 --> 00:37:06,056
and write, and work
with it in a code level.


802
00:37:06,056 --> 00:37:08,656
So there's a few options
for you because, of course,


803
00:37:08,656 --> 00:37:10,126
this is very widely used.


804
00:37:11,476 --> 00:37:12,946
One option is, again, OpenSSL.


805
00:37:13,036 --> 00:37:17,016
Just as it did the PKCS7
verification it can read ASN.1


806
00:37:17,016 --> 00:37:17,636
just fine.


807
00:37:18,886 --> 00:37:20,686
You can create your own
parser if you wanted to,


808
00:37:20,686 --> 00:37:22,376
to again have full
control over this.


809
00:37:23,676 --> 00:37:25,276
Let's look at an
OpenSSL example.


810
00:37:26,066 --> 00:37:29,646
When we did the first of
verifying the recipe we got back


811
00:37:29,646 --> 00:37:31,036
that P7 data structure.


812
00:37:31,036 --> 00:37:31,806
Remember that?


813
00:37:32,766 --> 00:37:35,376
Now we can use that same data
structure to actually get


814
00:37:35,376 --> 00:37:38,306
that payload of receipt data
that's encoded in ASN.1.


815
00:37:38,746 --> 00:37:41,066
It's buried in there in
the P7 data structure


816
00:37:41,066 --> 00:37:41,906
that we see there.


817
00:37:42,556 --> 00:37:44,576
Once we've got that we can
call this function called


818
00:37:44,576 --> 00:37:48,356
ASN1-get-object to start
pulling those objects out of


819
00:37:48,356 --> 00:37:50,126
that ASN.1-encoded byte stream.


820
00:37:51,026 --> 00:37:52,656
The objects are things
like there'll be an object


821
00:37:52,656 --> 00:37:53,816
for the top-level receipt.


822
00:37:54,836 --> 00:37:57,616
There'll be an object in
there for the Payload.


823
00:37:58,066 --> 00:38:00,456
There'll be an object in there
for the ReceiptAttribute,


824
00:38:00,456 --> 00:38:02,106
and then subjects
under there for each


825
00:38:02,106 --> 00:38:03,506
of the type, value, and version.


826
00:38:03,506 --> 00:38:06,176
You see, it's arranged
very hierarchically,


827
00:38:06,816 --> 00:38:09,276
and that follows the same
structure that we just saw


828
00:38:09,276 --> 00:38:11,196
in this ASN.1 textual
definition.


829
00:38:12,766 --> 00:38:16,626
Now this is not perfectly coded,
but it gives you an example


830
00:38:16,626 --> 00:38:20,076
of how in which you would
work with ASN.1 in OpenSSL


831
00:38:20,076 --> 00:38:21,666
if that's how you
choose to do this.


832
00:38:22,896 --> 00:38:26,526
You'd set up a while loop
to essentially move a -


833
00:38:26,526 --> 00:38:29,686
move a pointer throughout
that stream of bytes


834
00:38:29,686 --> 00:38:30,806
that represents the receipt.


835
00:38:31,316 --> 00:38:32,406
We want to basically walk


836
00:38:32,406 --> 00:38:34,096
through the receipt
ad read it as we go.


837
00:38:35,136 --> 00:38:37,966
So we set up the while loop and
start calling ASN1-get-object


838
00:38:38,226 --> 00:38:41,486
to pull those attributes and
values out of the receipt.


839
00:38:42,046 --> 00:38:44,256
So I make one call to get
my attribute, for example.


840
00:38:45,026 --> 00:38:47,766
Another call to get the
type, and notice I'm moving


841
00:38:47,766 --> 00:38:50,886
that pointer value around
like a finger following words


842
00:38:50,886 --> 00:38:51,286
in a book.


843
00:38:51,926 --> 00:38:55,176
And I'm calling ASN1-get-object
to read each of those words out


844
00:38:55,176 --> 00:38:56,316
and so I can use them.


845
00:38:56,976 --> 00:39:00,276
After a few more calls to
ASN1-get-object I'm ready


846
00:39:00,276 --> 00:39:02,126
to switch on that attribute type


847
00:39:02,126 --> 00:39:03,516
so I can see what
I'm looking for.


848
00:39:04,386 --> 00:39:06,006
In this case, just
for a simple example,


849
00:39:06,006 --> 00:39:08,936
I'm looking for Attribute Type
2, which we know is a BundleID.


850
00:39:08,936 --> 00:39:12,956
And then I can start processing
that by calling ASN1-get-object


851
00:39:13,296 --> 00:39:15,196
to actually read the
string value and compare it


852
00:39:15,196 --> 00:39:16,526
against my hardcoded BundleID.


853
00:39:16,526 --> 00:39:20,686
But of course I want to show you
that this is a real world thing


854
00:39:20,686 --> 00:39:22,416
that anyone can do,
so here's my demo.


855
00:39:23,096 --> 00:39:25,306
Now same as before, I've
got a third project here


856
00:39:25,306 --> 00:39:27,866
that builds upon the same two
samples that we've seen so far.


857
00:39:29,336 --> 00:39:32,486
You see here we have
the old familiar loading


858
00:39:32,486 --> 00:39:34,106
up of the receipt,
certificate store,


859
00:39:34,106 --> 00:39:36,026
and then calling PKCS7-verify.


860
00:39:36,526 --> 00:39:38,166
But now when we get
our result of one,


861
00:39:38,166 --> 00:39:40,366
and we know this thing
is valid and unaltered,


862
00:39:41,056 --> 00:39:43,256
and we want to start reading
the purchase information out,


863
00:39:43,646 --> 00:39:46,286
I'm going to go ahead and
start using OpenSSL to do that,


864
00:39:46,286 --> 00:39:49,046
to actually read the information
about what someone purchased.


865
00:39:50,576 --> 00:39:54,366
So just like we saw before I
find the actual octet string,


866
00:39:54,366 --> 00:39:56,376
that stream of bytes that
represents the receipt,


867
00:39:56,966 --> 00:39:58,656
buried within my
P7 data structure.


868
00:39:59,246 --> 00:40:01,866
I start calling this
ASN1-get-object method


869
00:40:01,866 --> 00:40:03,876
to start reading those
bits of information out of


870
00:40:03,876 --> 00:40:04,936
that byte stream one at a time.


871
00:40:06,696 --> 00:40:09,366
When I start doing that in my
while loop to walk over each


872
00:40:09,366 --> 00:40:11,936
of those bytes you see
that I set up that pointer,


873
00:40:11,936 --> 00:40:15,716
and each time I call
ASN1-get-object here I advance


874
00:40:15,716 --> 00:40:16,936
that pointer along, just


875
00:40:16,936 --> 00:40:18,466
like the finger following
the words in a book.


876
00:40:19,456 --> 00:40:21,696
So I make a few calls to
ASN1-get-object because I want


877
00:40:21,696 --> 00:40:24,046
to get things like the attribute
type, attribute version,


878
00:40:24,046 --> 00:40:25,666
and then the actual
object itself.


879
00:40:26,176 --> 00:40:29,276
Set up my switch statement, and
I've got a case 2 here looking


880
00:40:29,276 --> 00:40:32,706
for BundleID, and a final call
here looking for ASN1-get-object


881
00:40:33,096 --> 00:40:34,706
that allows me to
form the string


882
00:40:34,706 --> 00:40:35,886
which will be a bundle ID.


883
00:40:36,686 --> 00:40:37,746
Let's run it and see it work.


884
00:40:40,416 --> 00:40:44,386
Notice by the fact that I had
done the OpenSSL integration


885
00:40:44,386 --> 00:40:46,446
before in this project
I don't have to mess


886
00:40:46,446 --> 00:40:47,216
around with that again.


887
00:40:47,216 --> 00:40:49,496
This project is already set
up just like we had before.


888
00:40:51,936 --> 00:40:53,506
So I've got a receipt, great.


889
00:40:53,506 --> 00:40:55,066
We move into our
validateReceipt.


890
00:40:55,926 --> 00:40:59,776
We've gone and called
the PKCS7-verify here


891
00:40:59,776 --> 00:41:01,036
to make sure the
receipt is trusted


892
00:41:01,036 --> 00:41:02,446
and unaltered, and it is.


893
00:41:02,976 --> 00:41:04,126
Now we can start reading it.


894
00:41:04,666 --> 00:41:05,946
So I've got the byte stream.


895
00:41:06,636 --> 00:41:09,626
I start calling ASN1-get-object
to read that receipt in.


896
00:41:10,006 --> 00:41:12,946
Then I set up my while loop to
iterate over each of that series


897
00:41:12,946 --> 00:41:14,146
of attributes in the receipt.


898
00:41:15,426 --> 00:41:18,166
And as we see as we sail
down this first attempt


899
00:41:18,166 --> 00:41:22,426
at getting an object out of
the receipt, we get all the way


900
00:41:22,426 --> 00:41:25,646
down to our Switch
statement, and if we pull


901
00:41:25,646 --> 00:41:28,276
up the debug console
here you'll see, in fact,


902
00:41:28,276 --> 00:41:31,556
what it found first
is Attribute Type 4.


903
00:41:32,486 --> 00:41:34,536
So as you iterate
over this while loop,


904
00:41:34,536 --> 00:41:37,226
it's essentially finding each
of those attributes that we saw


905
00:41:37,226 --> 00:41:39,746
in the receipt, and you set
up the Switch statement here


906
00:41:39,826 --> 00:41:41,156
to work with them accordingly.


907
00:41:42,566 --> 00:41:46,236
So in fact, if we let this
run we would see a bunch


908
00:41:46,236 --> 00:41:49,906
of breakpoints hit here in our
Switch statement, switching


909
00:41:49,906 --> 00:41:52,426
and - as we looped over
each of those attributes,


910
00:41:52,426 --> 00:41:54,246
we can see this time
we've got Type 4.


911
00:41:54,556 --> 00:41:56,416
Advance it again and
we get different values


912
00:41:56,416 --> 00:41:57,356
as we go forward.


913
00:41:58,486 --> 00:42:00,566
And we can begin working
with those to pull out things


914
00:42:00,566 --> 00:42:03,486
like the bundle ID to
confirm that, the hash value,


915
00:42:03,486 --> 00:42:05,266
perform that hash to confirm


916
00:42:05,266 --> 00:42:09,996
that it is intended
for this device.


917
00:42:10,456 --> 00:42:12,236
All right, we're nearly there.


918
00:42:12,236 --> 00:42:13,796
We have a receipt that
we know is trusted.


919
00:42:14,526 --> 00:42:16,536
We've confirmed it's for
our app on this device.


920
00:42:16,956 --> 00:42:19,976
Now we can get down to the
money end of this and find


921
00:42:19,976 --> 00:42:22,886
out what the user has in
fact paid for so we know what


922
00:42:22,886 --> 00:42:24,916
to unlock, and we know what
content to provide them.


923
00:42:25,906 --> 00:42:29,346
Now along with those
Attributes Type 2, 3, 4,


924
00:42:29,346 --> 00:42:32,286
and 5 that we just looked
at, you will also see one


925
00:42:32,286 --> 00:42:34,446
or more attributes of Type 17.


926
00:42:34,966 --> 00:42:37,896
Type 17 is a record of an in-app
purchase having been made,


927
00:42:38,286 --> 00:42:40,946
and this is how you verify that
that in-app purchase was real


928
00:42:40,946 --> 00:42:42,706
and authentic and
is going to result


929
00:42:42,706 --> 00:42:44,046
in money making its way to you.


930
00:42:45,716 --> 00:42:47,926
The value of the
Type 17 attribute is


931
00:42:47,926 --> 00:42:51,456
in fact a nested set
of attributes itself.


932
00:42:51,966 --> 00:42:54,866
So you find the Type 17
attribute, get the value,


933
00:42:55,206 --> 00:42:57,996
and that value is going to
be a nested set of attributes


934
00:42:57,996 --> 00:43:00,506
that tell you the
quantity, product identifier,


935
00:43:00,506 --> 00:43:02,736
and the transaction
identifier and purchase date


936
00:43:02,916 --> 00:43:04,786
for an in-app purchase
that has been made.


937
00:43:05,316 --> 00:43:08,406
And again, we give you the
ASN.1 representation of that


938
00:43:08,406 --> 00:43:09,676
so you know how it's structured.


939
00:43:12,206 --> 00:43:14,726
Now if you have a paid app in
the Store and have been wanting


940
00:43:14,726 --> 00:43:17,606
to make the transition to making
a freemium app, that is free


941
00:43:17,606 --> 00:43:20,816
with in-app purchases,
one thing you don't want


942
00:43:20,816 --> 00:43:22,156
to do is leave those loyal,


943
00:43:22,156 --> 00:43:23,826
paying customers
out in the cold.


944
00:43:24,356 --> 00:43:26,366
If they've already paid the
full price for your app,


945
00:43:26,656 --> 00:43:29,236
they shouldn't have to go and do
a bunch of in-app purchases just


946
00:43:29,236 --> 00:43:30,696
to get back what
they've already paid for.


947
00:43:31,246 --> 00:43:32,386
So here's a trick you can do.


948
00:43:32,906 --> 00:43:36,236
Included in the receipt now is
this Type 19 attribute called


949
00:43:36,236 --> 00:43:37,776
Original Application Version.


950
00:43:38,556 --> 00:43:40,086
That is the application version


951
00:43:40,556 --> 00:43:42,546
that the user originally
purchased.


952
00:43:43,066 --> 00:43:46,376
So if two years ago I purchased
this app the receipt will always


953
00:43:46,376 --> 00:43:49,746
reflect the version that was
in the store at the time I made


954
00:43:49,746 --> 00:43:51,216
that purchase all
those years ago.


955
00:43:52,366 --> 00:43:55,466
And that's your way of knowing
whether to treat the app


956
00:43:55,466 --> 00:43:58,576
as a paid version and give them
what they've paid for or to know


957
00:43:58,576 --> 00:44:00,566
that they purchased the app
when you were a freemium app


958
00:44:01,276 --> 00:44:02,816
to not unlock features
and content


959
00:44:02,816 --> 00:44:04,756
until you see those in-app
purchases being made.


960
00:44:05,976 --> 00:44:08,916
Now in terms of in-app
purchases, different types


961
00:44:08,916 --> 00:44:11,196
of content have different
lifecycles in terms


962
00:44:11,196 --> 00:44:13,026
of what is seen in the receipt.


963
00:44:14,026 --> 00:44:16,306
If you are dealing
with consumable


964
00:44:16,306 --> 00:44:21,506
and non-renewing subscriptions,
so things like gas in a race car


965
00:44:21,506 --> 00:44:26,576
in a racing game, coins, blocks,
currency, non-consumable -


966
00:44:26,576 --> 00:44:29,056
sorry, consumables are
things that you buy,


967
00:44:29,606 --> 00:44:31,766
use on a single device,
and they get used up.


968
00:44:32,906 --> 00:44:35,176
Those sorts of items,
because they are that purchase


969
00:44:35,176 --> 00:44:37,136
that you can make again
and again and are intended


970
00:44:37,136 --> 00:44:41,716
to be used on a single
device, they only appear once


971
00:44:41,716 --> 00:44:44,726
in the receipt, and only in
the receipt that's issued


972
00:44:44,726 --> 00:44:45,916
at the time of purchase.


973
00:44:46,846 --> 00:44:49,576
So when that purchase is made -
if you have 500 gallons of gas


974
00:44:49,576 --> 00:44:52,796
in the racecar - you need
to interpret the receipt


975
00:44:52,796 --> 00:44:54,266
at that point in
time and validate it,


976
00:44:54,446 --> 00:44:55,956
and then stash that state .


977
00:44:56,456 --> 00:44:58,486
That is, up the gas
tank by 500 gallons


978
00:44:58,486 --> 00:44:59,346
or whatever it might be -


979
00:44:59,836 --> 00:45:02,406
you need to stash
that state yourself.


980
00:45:02,896 --> 00:45:04,786
That transaction
will not be present


981
00:45:04,786 --> 00:45:07,686
in any subsequent receipts that
we issue, nor will it be present


982
00:45:07,686 --> 00:45:10,236
if you perform the
restoreCompletedTransactions.


983
00:45:10,576 --> 00:45:11,976
They're a one-shot deal.


984
00:45:12,476 --> 00:45:15,856
When the transaction is done
you inspect the receipt,


985
00:45:16,016 --> 00:45:17,506
stash that state yourself.


986
00:45:17,786 --> 00:45:20,686
Now the total opposite
to that is non-consumable


987
00:45:20,686 --> 00:45:22,246
and auto-renewable
subscriptions.


988
00:45:22,836 --> 00:45:24,896
If you're selling
non-consumables,


989
00:45:24,896 --> 00:45:27,656
like levels in a game, for
example, those are things


990
00:45:27,656 --> 00:45:30,936
that a user buys once, and they
would rightly expect to be able


991
00:45:30,936 --> 00:45:33,136
to use that game level
on other devices.


992
00:45:33,506 --> 00:45:36,826
If I go and buy a new phone and
re-download your app I expect


993
00:45:36,826 --> 00:45:39,206
to get back all the lower levels
that I've already paid for.


994
00:45:40,336 --> 00:45:41,866
So because these non-consumables


995
00:45:41,866 --> 00:45:44,626
and auto-renewable subscriptions
have that sense of permanency


996
00:45:44,626 --> 00:45:47,036
about them, they are
always in the receipt.


997
00:45:48,016 --> 00:45:49,836
And you can use the
StoreKit APIs


998
00:45:49,836 --> 00:45:51,456
to restore completed
transactions,


999
00:45:51,756 --> 00:45:54,586
which is how the user gets back
all those things they've bought


1000
00:45:54,586 --> 00:45:57,136
from you before in
terms of non-consumable


1001
00:45:57,496 --> 00:46:00,156
and auto-renewable subscriptions
that are still valid.


1002
00:46:00,156 --> 00:46:05,816
What we've talked about so far
is all about the happy path


1003
00:46:05,816 --> 00:46:07,806
of a receipt being
valid and true.


1004
00:46:08,676 --> 00:46:10,456
What if receipts are invalid?


1005
00:46:10,786 --> 00:46:13,056
What if when you validate
this it's either missing


1006
00:46:13,286 --> 00:46:14,676
or something appears
wrong with it?


1007
00:46:16,236 --> 00:46:20,016
The fact is, that doesn't mean
something bad has happened.


1008
00:46:20,616 --> 00:46:23,306
That does not necessarily
mean someone is trying


1009
00:46:23,306 --> 00:46:24,986
to rip you off.


1010
00:46:25,256 --> 00:46:27,266
There are many real
world scenarios


1011
00:46:27,676 --> 00:46:29,276
that your app will
definitely run


1012
00:46:29,276 --> 00:46:34,246
into where a receipt is missing
or invalid through no fault


1013
00:46:34,246 --> 00:46:37,056
of the user, not because
anyone's trying to rip you off.


1014
00:46:38,046 --> 00:46:39,726
But if you see this
happen, what you need


1015
00:46:39,726 --> 00:46:41,246
to do is refresh the receipt.


1016
00:46:42,176 --> 00:46:44,476
On iOS, if the receipt
doesn't exist or appears


1017
00:46:44,476 --> 00:46:46,656
to be invalid you'd
refresh it using StoreKit.


1018
00:46:47,356 --> 00:46:49,886
StoreKit has the
SKReceiptRefresh operation


1019
00:46:50,756 --> 00:46:52,586
which allows you
to - you can alloc


1020
00:46:52,586 --> 00:46:55,136
and init this
SKReceiptRefreshRequest object,


1021
00:46:55,846 --> 00:46:57,446
set a delegate so
you get the callbacks


1022
00:46:57,446 --> 00:46:59,836
when the refresh is done,
and then start the refresh.


1023
00:47:01,276 --> 00:47:03,856
When that request completes you
should get back a new receipt


1024
00:47:03,856 --> 00:47:05,576
that you can then re-verify.


1025
00:47:06,186 --> 00:47:08,456
But note that, getting
a new receipt,


1026
00:47:08,866 --> 00:47:10,086
we have to talk to
the App Store.


1027
00:47:10,836 --> 00:47:12,936
So of course a network
connection will be required


1028
00:47:13,026 --> 00:47:14,566
which your user may
not always have.


1029
00:47:15,836 --> 00:47:18,756
Store sign-in will be required
so that we can go and verify


1030
00:47:18,756 --> 00:47:20,256
that this person really is them


1031
00:47:20,256 --> 00:47:22,526
and check their purchase history
before we issue the receipt.


1032
00:47:23,936 --> 00:47:27,146
But what you need to do is avoid
continuous loops of refresh,


1033
00:47:27,146 --> 00:47:28,806
validate, refresh
validate, refresh,


1034
00:47:28,806 --> 00:47:31,526
validate because each time
you do that, the user's going


1035
00:47:31,526 --> 00:47:33,666
to get stuck in this horrible
loop of prompt for off.


1036
00:47:33,666 --> 00:47:34,646
"Yes, I signed in."


1037
00:47:35,436 --> 00:47:36,296
Still bad.


1038
00:47:36,486 --> 00:47:37,626
"Oh, sign in again."


1039
00:47:37,856 --> 00:47:40,046
And all this network traffic
goes back and forward.


1040
00:47:40,466 --> 00:47:43,766
So what you should do is, on
launch, validate the receipt.


1041
00:47:44,336 --> 00:47:46,886
If it's missing or invalid
you can refresh it once.


1042
00:47:47,306 --> 00:47:49,526
If it's still missing
and invalid that's it.


1043
00:47:50,636 --> 00:47:51,886
Don't call refresh again.


1044
00:47:53,246 --> 00:47:55,456
But OS X is of course
a little different.


1045
00:47:55,456 --> 00:47:59,606
As we saw before, if the receipt
is invalid or missing you exit


1046
00:47:59,606 --> 00:48:02,346
with code 173 to tell
the OS and the App Store


1047
00:48:02,346 --> 00:48:03,666
that you need to
get a new receipt.


1048
00:48:05,546 --> 00:48:08,536
The OS sees that exit
code, tells the App Store,


1049
00:48:08,536 --> 00:48:11,026
and the App Store will go and
get a new receipt for you.


1050
00:48:11,026 --> 00:48:14,776
But just like on iOS, it will
require a network connection


1051
00:48:15,826 --> 00:48:17,416
and store sign-in
will be requested.


1052
00:48:18,236 --> 00:48:20,066
So this is definitely
not something you want


1053
00:48:20,066 --> 00:48:21,536
to do automatically on launch.


1054
00:48:22,576 --> 00:48:27,116
Now when you - do you receive
validation, and it appears


1055
00:48:27,116 --> 00:48:31,246
to be invalid or missing, and
you request a new receipt even


1056
00:48:31,246 --> 00:48:34,406
if then you still don't have
a receipt or it still appears


1057
00:48:34,406 --> 00:48:38,806
to be invalid, what you do
next is entirely up to you.


1058
00:48:40,796 --> 00:48:43,376
Invalid or missing
receipts will happen.


1059
00:48:44,046 --> 00:48:46,706
Everyone's app will see a
condition where this happens,


1060
00:48:46,706 --> 00:48:48,176
and it could be entirely
legitimate.


1061
00:48:48,526 --> 00:48:49,356
Here's an example.


1062
00:48:49,846 --> 00:48:53,086
If I sync an app from
iTunes to my iOS device,


1063
00:48:53,766 --> 00:48:56,446
it lands on the iOS
device with no receipt.


1064
00:48:56,946 --> 00:49:00,496
Because it wasn't purchased
directly from the App Store,


1065
00:49:00,496 --> 00:49:02,776
the App store doesn't have
that unique device identifier.


1066
00:49:02,776 --> 00:49:04,126
We can't issue a receipt.


1067
00:49:04,796 --> 00:49:06,566
So it lands on the
device with no receipt,


1068
00:49:06,846 --> 00:49:09,046
and when your app launches
it'll find no receipt and need


1069
00:49:09,046 --> 00:49:10,996
to refresh it if you want
to validate the receipt.


1070
00:49:12,296 --> 00:49:15,336
So it's a real world scenario
that will happen, but you need


1071
00:49:15,336 --> 00:49:17,166
to configure the - you
need to consider the case


1072
00:49:17,166 --> 00:49:19,596
that that refresh of the
receipt may not be possible.


1073
00:49:19,656 --> 00:49:22,846
All right, what if I got
my wonderful app from the -


1074
00:49:22,966 --> 00:49:26,046
from the iTunes Store or the App
Store, and I'm really excited


1075
00:49:26,046 --> 00:49:28,036
about using it on the plane
flight I'm about to get on.


1076
00:49:28,586 --> 00:49:31,986
I plug my iOS device in,
sync the app across, unplug,


1077
00:49:32,406 --> 00:49:34,976
jump on the plane, no Wi-Fi.


1078
00:49:36,026 --> 00:49:37,816
"Ah, I can't get a receipt."


1079
00:49:38,486 --> 00:49:42,606
It's up to you now to decide
how you want to handle that.


1080
00:49:42,606 --> 00:49:46,786
Okay, you should ideally
match the user experience


1081
00:49:46,786 --> 00:49:47,976
to the value of your app.


1082
00:49:47,976 --> 00:49:50,876
And this comes back to the
concepts we were talking before.


1083
00:49:50,876 --> 00:49:54,086
I mean, you can allow full
access to the app's content


1084
00:49:54,086 --> 00:49:56,936
and features even if the
receipt's invalid if you choose.


1085
00:49:57,676 --> 00:49:59,986
You could maybe have a - you
could maybe have a grace period


1086
00:50:00,146 --> 00:50:01,776
where you will allow
some use of the app.


1087
00:50:02,436 --> 00:50:04,726
You could limit access to
certain areas of the app;


1088
00:50:04,726 --> 00:50:06,116
perhaps there's one
area of the app


1089
00:50:06,606 --> 00:50:09,066
that is particularly valuable
that you wouldn't want


1090
00:50:09,066 --> 00:50:11,396
to let them access even if
they can't get a receipt.


1091
00:50:12,726 --> 00:50:14,656
Or you could block
functionality entirely.


1092
00:50:15,216 --> 00:50:16,386
You could have the
app do nothing


1093
00:50:16,386 --> 00:50:17,826
until a valid receipt is seen.


1094
00:50:18,836 --> 00:50:21,386
On OS X only, you could in
fact force that app to quit


1095
00:50:21,386 --> 00:50:24,276
if you wanted to, but that
concept does not exist on iOS.


1096
00:50:24,426 --> 00:50:26,126
On iOS, the app is
always running,


1097
00:50:26,566 --> 00:50:28,246
so it's up to you to
decide what to do.


1098
00:50:28,246 --> 00:50:32,196
But again, think about
which business model you are


1099
00:50:32,196 --> 00:50:32,796
more like.


1100
00:50:32,956 --> 00:50:35,356
Are you like the grocery store
that wants a comfortable,


1101
00:50:35,596 --> 00:50:39,126
really happy buying experience
and usage experience every time,


1102
00:50:39,586 --> 00:50:40,776
and maybe you don't care if one


1103
00:50:40,776 --> 00:50:42,306
or two bananas goes
out the door?


1104
00:50:42,616 --> 00:50:44,816
Maybe you don't care too
much if a receipt's invalid


1105
00:50:44,816 --> 00:50:47,226
for a little bit of time.


1106
00:50:47,436 --> 00:50:50,386
Or maybe you are more like
that high-end jewelry store,


1107
00:50:50,616 --> 00:50:53,776
and maybe it's totally not
okay for your app to be used


1108
00:50:53,776 --> 00:50:55,636
in any way unless
there's a valid receipt.


1109
00:50:56,056 --> 00:50:58,936
It's up to you, but you should
really think about the value


1110
00:50:58,936 --> 00:51:02,036
of your product and how you
want the user's experience to be


1111
00:51:02,266 --> 00:51:03,426
if they don't have a receipt.


1112
00:51:04,026 --> 00:51:06,946
Now everything we've talked
about so far is about validating


1113
00:51:06,946 --> 00:51:09,146
that receipt on a device,
but you can also do


1114
00:51:09,146 --> 00:51:11,106
that same process
on your servers.


1115
00:51:11,306 --> 00:51:13,616
If you have servers
issuing content based


1116
00:51:13,616 --> 00:51:16,266
on an in-app purchase being
made here's what you can do.


1117
00:51:16,966 --> 00:51:18,236
When you request that content,


1118
00:51:18,846 --> 00:51:20,516
send the receipt
up to your server.


1119
00:51:20,846 --> 00:51:23,286
Your server can talk to
Apple's validation servers,


1120
00:51:23,656 --> 00:51:25,696
and we will return
back a block of JSON


1121
00:51:26,376 --> 00:51:29,476
that will tell you whether
or not the receipt is valid,


1122
00:51:29,476 --> 00:51:31,656
and it will also include
the purchase information.


1123
00:51:32,246 --> 00:51:34,326
Your server can interpret
the purchase information


1124
00:51:34,326 --> 00:51:37,776
and decide only to hand
back that content based


1125
00:51:37,776 --> 00:51:40,476
on that real monetary
transaction having taken place.


1126
00:51:40,846 --> 00:51:43,166
It's a great way to secure
and lock down the access


1127
00:51:43,166 --> 00:51:45,146
to that content that
you're hosting online.


1128
00:51:45,146 --> 00:51:47,116
Now for this server -


1129
00:51:47,116 --> 00:51:50,686
server-to-server validation it's
only designed for your servers


1130
00:51:50,686 --> 00:51:53,116
to validate the receipt
before they issue content.


1131
00:51:53,746 --> 00:51:56,996
And it's your app that needs to
send the receipt to your server.


1132
00:51:57,546 --> 00:51:58,376
You need to secure


1133
00:51:58,376 --> 00:51:59,986
that end-to-end communication
channel,


1134
00:52:00,376 --> 00:52:03,166
and then only your
server sends the receipt


1135
00:52:03,296 --> 00:52:04,796
to Apple's validation server.


1136
00:52:05,636 --> 00:52:09,856
Never, never, never ever
send the receipt directly


1137
00:52:09,856 --> 00:52:12,736
from your app on a device
to the validation servers.


1138
00:52:13,386 --> 00:52:15,206
Way too easy for someone
to sit in the middle


1139
00:52:15,206 --> 00:52:16,446
and return a false positive,


1140
00:52:16,816 --> 00:52:19,186
and you'll also be exposing
your shared secret for using


1141
00:52:19,186 --> 00:52:20,396
that validation service.


1142
00:52:21,256 --> 00:52:23,506
But the good thing is, the
response you get back is


1143
00:52:23,506 --> 00:52:24,886
in JSON, which is
really easy to pass


1144
00:52:24,886 --> 00:52:28,426
for virtually any server
platform out there.


1145
00:52:29,476 --> 00:52:31,846
Now what you absolutely
have to make sure you do


1146
00:52:31,916 --> 00:52:33,706
if you're implementing
receipt validation is,


1147
00:52:33,706 --> 00:52:34,576
test it thoroughly.


1148
00:52:35,066 --> 00:52:37,826
A bug in this area of code
could be disastrous for you


1149
00:52:38,596 --> 00:52:40,416
because it could lock
someone out of the features


1150
00:52:40,416 --> 00:52:42,106
and content they
really have paid for,


1151
00:52:42,356 --> 00:52:43,916
and I guarantee you
that's a one-way trip


1152
00:52:43,916 --> 00:52:44,986
to one-star reviews.


1153
00:52:46,146 --> 00:52:47,226
So test really thoroughly.


1154
00:52:47,226 --> 00:52:49,036
How does your app behave
when there's no receipt?


1155
00:52:49,336 --> 00:52:51,486
How does it behave when the
receipt looks to be invalid?


1156
00:52:51,756 --> 00:52:54,396
How does it behave when the
app - when the receipt appears


1157
00:52:54,396 --> 00:52:55,796
to be valid after refresh?


1158
00:52:56,176 --> 00:52:58,516
What if the refresh failed
and it's still invalid?


1159
00:52:58,516 --> 00:52:59,606
How does your app behave?


1160
00:53:00,086 --> 00:53:02,166
And if you're selling your
app using the Volume Purchase


1161
00:53:02,166 --> 00:53:03,846
Program for business
and education,


1162
00:53:04,306 --> 00:53:06,496
be aware of the extra fields
that are in the receipt


1163
00:53:06,816 --> 00:53:08,896
to tell you whether your
app has been allocated


1164
00:53:08,896 --> 00:53:10,586
to a user or revoked.


1165
00:53:11,006 --> 00:53:15,076
But the really important message
that I want to make sure gets


1166
00:53:15,076 --> 00:53:17,866
through is that these
are not edge cases.


1167
00:53:18,366 --> 00:53:20,266
Your app will launch
without a receipt.


1168
00:53:20,366 --> 00:53:22,476
Your app will launch with a
receipt that looks invalid.


1169
00:53:22,476 --> 00:53:24,256
You know that example
before I gave you


1170
00:53:24,256 --> 00:53:26,186
of an iOS app being
synced from iTunes?


1171
00:53:26,706 --> 00:53:30,306
When you buy a new Mac and you
move your apps from your old Mac


1172
00:53:30,306 --> 00:53:32,246
to your new Mac, guess what?


1173
00:53:32,246 --> 00:53:34,376
The receipt moves from the
old Mac to the new Mac.


1174
00:53:34,876 --> 00:53:37,516
So when your app launches
it's going to see a receipt


1175
00:53:37,516 --> 00:53:39,496
that was not intended
for the new Mac.


1176
00:53:40,026 --> 00:53:41,776
So these are real
things that happen.


1177
00:53:41,776 --> 00:53:44,466
They're definitely
not edge cases at all.


1178
00:53:45,396 --> 00:53:47,616
Now testing this on iOS,


1179
00:53:47,616 --> 00:53:49,766
you need to use the App
Store's test environment.


1180
00:53:50,156 --> 00:53:51,906
To do that, you run
the app in Xcode,


1181
00:53:52,056 --> 00:53:53,896
perform an in-app purchase
to get the receipt,


1182
00:53:54,126 --> 00:53:56,486
but you must have
your app signed


1183
00:53:56,486 --> 00:53:57,886
with a development certificate.


1184
00:53:59,766 --> 00:54:01,756
OS X? Similar but different.


1185
00:54:01,896 --> 00:54:05,026
Build it in Xcode, run the
app from Finder, remember.


1186
00:54:05,026 --> 00:54:07,946
So Finder in the OS, and the
App Store sees that exit code,


1187
00:54:07,946 --> 00:54:09,376
and we know you need
to get a receipt.


1188
00:54:11,296 --> 00:54:14,426
When you exit with that
receipt you must make sure -


1189
00:54:14,426 --> 00:54:16,556
exit with that code,
sorry, you must make sure


1190
00:54:16,556 --> 00:54:19,716
that your app is signed with
its development certificate.


1191
00:54:22,236 --> 00:54:25,026
Now in case you missed the
very, very deliberate repetition


1192
00:54:25,026 --> 00:54:29,556
in those last two slides,
your app must be signed


1193
00:54:29,706 --> 00:54:30,876
with your development
certificate.


1194
00:54:30,876 --> 00:54:34,086
Why? Well, because
the first thing we do


1195
00:54:34,086 --> 00:54:35,986
at the App Store Layer
when your app says, "Hey,


1196
00:54:35,986 --> 00:54:36,946
I want a new receipt," or, "Hey,


1197
00:54:36,946 --> 00:54:38,126
I want to make an
in-app purchase,"


1198
00:54:38,426 --> 00:54:40,066
is we inspect your
code signature.


1199
00:54:40,736 --> 00:54:42,316
If the app appears to be signed


1200
00:54:42,316 --> 00:54:43,956
with your development
certificate we know you're a


1201
00:54:43,956 --> 00:54:46,646
developer testing your app
so we route those requests


1202
00:54:46,646 --> 00:54:49,596
to the test environment so that
you can make in-app purchases,


1203
00:54:49,636 --> 00:54:50,946
test your receipt validation


1204
00:54:50,946 --> 00:54:52,736
without actually
buying something.


1205
00:54:53,786 --> 00:54:55,076
But if we see the app is signed


1206
00:54:55,076 --> 00:54:56,786
with a production App
Store certificate,


1207
00:54:57,106 --> 00:54:59,316
we know this is an app that's
been purchased; it's out there


1208
00:54:59,316 --> 00:55:01,256
in the wheel - real
world, so therefore,


1209
00:55:01,256 --> 00:55:03,536
we route those requests
to the production store


1210
00:55:03,866 --> 00:55:06,336
so that you get paid for the
transactions the customer


1211
00:55:06,336 --> 00:55:06,836
is making.


1212
00:55:09,486 --> 00:55:11,926
Lastly, a quick word on
the app submission process,


1213
00:55:12,366 --> 00:55:14,436
especially as how it
pertains to receipts.


1214
00:55:14,926 --> 00:55:18,816
When you're developing your app,
Development-signed of course,


1215
00:55:19,026 --> 00:55:21,076
and you're working with the
App Store's test environment


1216
00:55:21,076 --> 00:55:23,266
to test your in-app purchase
and receipt validation,


1217
00:55:23,686 --> 00:55:26,426
the receipts you get back are
test environment receipts.


1218
00:55:27,206 --> 00:55:29,546
Now because your app may not
already be on the Store yet,


1219
00:55:29,546 --> 00:55:31,566
and you're using the test
environment there'll be some


1220
00:55:31,566 --> 00:55:33,126
difference in the
fields that are present.


1221
00:55:34,656 --> 00:55:36,636
When your app is on
sale in the App Store


1222
00:55:36,636 --> 00:55:40,226
and it's Production-signed you
will see production receipts


1223
00:55:40,346 --> 00:55:43,216
that have some more fields in
them because your app is real


1224
00:55:43,216 --> 00:55:44,406
and live on the Store.


1225
00:55:45,596 --> 00:55:48,386
But App Review is different.


1226
00:55:49,336 --> 00:55:54,266
App Review uses test receipts
using a Production-signed app.


1227
00:55:54,936 --> 00:55:58,016
That's not something you can
do, only App Review can do.


1228
00:55:58,196 --> 00:56:01,646
But what you need to
be aware of is that,


1229
00:56:01,646 --> 00:56:04,566
when you're testing your app,
if you try to get too clever


1230
00:56:04,566 --> 00:56:06,536
and think, "Oh, I've
found a way to determine


1231
00:56:06,536 --> 00:56:09,206
that these receipts are from the
test environment, and I never,


1232
00:56:09,206 --> 00:56:10,956
ever, ever, ever want
someone out there


1233
00:56:10,956 --> 00:56:13,586
to be getting a receipt using my
app from the test environment,"


1234
00:56:14,206 --> 00:56:15,706
if you try and implement code


1235
00:56:15,706 --> 00:56:18,156
that rejects a test
environment receipt


1236
00:56:18,156 --> 00:56:21,226
because you're
Production-signed, guess what?


1237
00:56:21,686 --> 00:56:23,056
App Review can't
review your app.


1238
00:56:24,196 --> 00:56:26,236
We won't be able to use
your in-app purchases,


1239
00:56:27,506 --> 00:56:29,326
and therefore, it'll
get rejected.


1240
00:56:29,896 --> 00:56:33,756
So just be aware that you will
have your live Production-signed


1241
00:56:33,756 --> 00:56:35,086
version of the app
that you submitted.


1242
00:56:35,396 --> 00:56:38,136
It will see test receipts
during App Review.


1243
00:56:38,686 --> 00:56:43,306
So if you'd like more
information you can contact


1244
00:56:43,306 --> 00:56:44,256
our Evangelists.


1245
00:56:44,696 --> 00:56:46,236
There's also documentation
online


1246
00:56:46,236 --> 00:56:48,236
with the Receipt
Validation Programming Guide.


1247
00:56:48,636 --> 00:56:50,336
And of course there's the
Apple Developer Forums,


1248
00:56:50,336 --> 00:56:52,736
which are a great place to
discuss this and ask for help.


1249
00:56:53,916 --> 00:56:56,496
Some related sessions: on
Wednesday I gave a session


1250
00:56:56,496 --> 00:56:58,376
about optimizing your
in-app purchases.


1251
00:56:58,516 --> 00:57:00,296
That was around creating
a trouble-free


1252
00:57:00,296 --> 00:57:03,296
and smooth in-app purchase
experience every single time.


1253
00:57:04,586 --> 00:57:06,956
And my colleague Rachel gave
an excellent session earlier


1254
00:57:06,956 --> 00:57:09,256
that morning that was
about how to design


1255
00:57:09,256 --> 00:57:10,966
for a great in-app
purchase experience.


1256
00:57:11,456 --> 00:57:12,876
It's great to protect
your revenue,


1257
00:57:13,226 --> 00:57:15,326
even better to have a
trouble-free in-app experience


1258
00:57:15,406 --> 00:57:17,476
every time, but you've
got to also create


1259
00:57:17,476 --> 00:57:19,296
that irresistible
sales experience.


1260
00:57:19,556 --> 00:57:21,036
So do go and check
out these sessions.


1261
00:57:21,036 --> 00:57:21,666
They were really good.


1262
00:57:22,736 --> 00:57:23,376
Thanks very much.


1263
00:57:24,508 --> 00:57:26,508
[ Applause ]

