1
00:00:23,046 --> 00:00:24,456
>> KATE STONE: Good
afternoon and welcome


2
00:00:24,456 --> 00:00:26,016
to What's New In LLDB.


3
00:00:26,326 --> 00:00:27,086
My name is Kate.


4
00:00:28,516 --> 00:00:33,566
[ Applause ]


5
00:00:34,066 --> 00:00:36,106
>> KATE STONE: And I manage
the runtime analysis tools


6
00:00:36,106 --> 00:00:37,756
in Xcode, including LLDB.


7
00:00:37,926 --> 00:00:40,246
I will be getting us started
here but I'll be bringing up two


8
00:00:40,246 --> 00:00:42,386
of my engineers,
Sean and Enrico,


9
00:00:42,386 --> 00:00:44,616
to dive into the details
in just a little bit.


10
00:00:45,346 --> 00:00:47,806
But to get us started, I would
like to talk a little bit


11
00:00:47,886 --> 00:00:49,936
about the year's highlights,
some of the changes,


12
00:00:49,936 --> 00:00:53,346
big and small, since the
last time we were at WWDC.


13
00:00:54,356 --> 00:00:58,426
Most notably we shipped
our first Swift debugger.


14
00:00:58,936 --> 00:01:01,446
It is a step forward, obviously,
in being able to write


15
00:01:01,596 --> 00:01:04,156
and develop the Swift code that
you have come to know and love.


16
00:01:05,676 --> 00:01:07,926
But more importantly it
wasn't our last step.


17
00:01:08,316 --> 00:01:10,156
We continued to improve
that debugger


18
00:01:10,156 --> 00:01:12,556
and we hope your continued
feedback will help us make it


19
00:01:12,556 --> 00:01:13,466
even better still.


20
00:01:13,626 --> 00:01:16,626
At the same time we
shipped the Swift REPL;


21
00:01:17,156 --> 00:01:17,966
it's a little bit different


22
00:01:17,966 --> 00:01:21,266
than your standard request
response REPL environment,


23
00:01:21,556 --> 00:01:24,496
in that it is really
LLDB in disguise.


24
00:01:25,226 --> 00:01:28,856
The REPL is not just a way that
you can ask questions in Swift.


25
00:01:28,856 --> 00:01:31,376
It is a way that you can
debug those questions,


26
00:01:31,376 --> 00:01:33,106
you can actually set
breakpoints in the REPL


27
00:01:33,336 --> 00:01:34,396
and do everything you'd expect


28
00:01:34,476 --> 00:01:37,276
from a debugging environment
because it is LLDB.


29
00:01:37,276 --> 00:01:39,186
If you haven't dug
deep into that,


30
00:01:39,346 --> 00:01:41,916
I'd recommend you take a look at
the blog posts on the subject.


31
00:01:42,876 --> 00:01:44,606
But, of course, that's
not the end.


32
00:01:44,606 --> 00:01:47,176
There are numerous improvements
that we have made since then.


33
00:01:47,176 --> 00:01:50,286
Since we first shipped, we've
made over 100 improvements


34
00:01:50,286 --> 00:01:52,576
in the Swift debugging
experience, and we continue


35
00:01:52,576 --> 00:01:54,226
to enhance the debugging
experience


36
00:01:54,226 --> 00:01:55,706
for Objective-C as well.


37
00:01:56,106 --> 00:01:57,396
We're going to cover
some of them here,


38
00:01:57,826 --> 00:01:59,976
but just to recap some of the
changes that have been made


39
00:01:59,976 --> 00:02:04,766
since last year, Swift types
initially did not show inherited


40
00:02:04,766 --> 00:02:05,876
Objective-C fields.


41
00:02:06,146 --> 00:02:07,096
We've since corrected that.


42
00:02:07,986 --> 00:02:10,416
Help now includes
command aliases.


43
00:02:10,416 --> 00:02:12,386
And it is important
to understand these,


44
00:02:12,386 --> 00:02:15,706
because while LLDB has what
may look like a wordy syntax,


45
00:02:16,576 --> 00:02:17,956
we might ask you to type 'help,


46
00:02:18,416 --> 00:02:20,246
in practice there are
a number of short cuts.


47
00:02:20,246 --> 00:02:22,866
And throughout this presentation
we'll use the following notation


48
00:02:22,866 --> 00:02:23,616
to describe them.


49
00:02:24,296 --> 00:02:28,366
Help can actually be abbreviated
to the first unique sequence.


50
00:02:28,716 --> 00:02:31,076
So in this case H is
enough to bring up help.


51
00:02:31,846 --> 00:02:34,536
More importantly, for
more elaborate examples


52
00:02:34,536 --> 00:02:39,136
like expression-O-- , which
means 'evaluate an expression,


53
00:02:39,706 --> 00:02:41,946
tell me the results as
if it were an object


54
00:02:42,046 --> 00:02:44,216
by sending it a method
to describe itself,


55
00:02:44,736 --> 00:02:48,086
and then no more options
followed by the expression,


56
00:02:48,546 --> 00:02:49,826
but you can just type PO.


57
00:02:49,926 --> 00:02:52,746
PO is a handy alias
that is shorthand


58
00:02:52,806 --> 00:02:53,946
for everything to the left.


59
00:02:54,776 --> 00:02:57,226
So, as you get used to
the help, you should learn


60
00:02:57,226 --> 00:02:59,966
to use the aliases, because they
are going to be your fastest way


61
00:03:00,076 --> 00:03:04,036
to get to some of the
powerful functionality in LLDB.


62
00:03:04,196 --> 00:03:06,726
We've also improved data
formatting, because telling you


63
00:03:06,726 --> 00:03:08,486
about your data is
absolutely critical


64
00:03:08,626 --> 00:03:10,236
to your debugging experience.


65
00:03:10,716 --> 00:03:15,696
So types like set and NS Index
Path now have default formatting


66
00:03:15,696 --> 00:03:17,726
to help you understand
your data instead


67
00:03:17,726 --> 00:03:19,146
of just showing you the raw dump


68
00:03:19,196 --> 00:03:20,726
of the underlying
representation.


69
00:03:21,586 --> 00:03:23,546
Printf prototype
for expressions,


70
00:03:24,176 --> 00:03:27,216
if you've ever tried to evaluate
an expression involving printf,


71
00:03:27,216 --> 00:03:30,046
you may have seen some
slightly suspect results.


72
00:03:30,546 --> 00:03:32,416
That's because the
debugger tries to make a lot


73
00:03:32,416 --> 00:03:35,586
of assumptions about your
expression for any declaration


74
00:03:35,586 --> 00:03:36,446
that it doesn't know,


75
00:03:36,516 --> 00:03:39,176
and it didn't know
printf, in most cases.


76
00:03:39,786 --> 00:03:42,476
So it didn't know that it was
a variatic function, that is,


77
00:03:42,476 --> 00:03:44,426
one that can take a
variable number of arguments,


78
00:03:44,836 --> 00:03:47,876
and didn't know especially
on 64-bit devices how


79
00:03:47,876 --> 00:03:49,416
to pass those arguments
correctly.


80
00:03:49,886 --> 00:03:51,476
That has been corrected
so that all


81
00:03:51,476 --> 00:03:54,086
of your expressions
involving printf for C


82
00:03:54,086 --> 00:03:56,886
and Objective-C should just
work right out of the box.


83
00:03:57,536 --> 00:03:59,586
And then lastly, and
truly lastly, this time,


84
00:03:59,876 --> 00:04:01,506
we have improved the
disassembly format


85
00:04:01,506 --> 00:04:05,066
to make it easier
than ever to read.


86
00:04:05,426 --> 00:04:07,846
Digging into some of the more
interesting enhancements,


87
00:04:08,716 --> 00:04:10,926
breakpoint enhancements
were made this spring


88
00:04:10,926 --> 00:04:12,466
that you may not be aware of.


89
00:04:12,826 --> 00:04:15,076
Specifically you can
now name breakpoints.


90
00:04:15,076 --> 00:04:18,505
And it may not seem obvious
why a named breakpoint would be


91
00:04:18,505 --> 00:04:21,236
easier to use than any other
breakpoint, until you realize


92
00:04:21,286 --> 00:04:23,156
that those names don't
have to be unique


93
00:04:23,156 --> 00:04:25,736
and that you can apply multiple
names to a single breakpoint.


94
00:04:26,006 --> 00:04:29,396
You can think of
them a lot like tags.


95
00:04:29,566 --> 00:04:32,426
And all breakpoint
commands take those names.


96
00:04:32,586 --> 00:04:35,786
So I can set a breakpoint
by providing breakpoint set


97
00:04:35,936 --> 00:04:40,526
and dash N, capital N followed
by a name, optionally followed


98
00:04:40,526 --> 00:04:43,286
by another dash capital N and
additional name, and so forth.


99
00:04:44,156 --> 00:04:46,616
But more importantly, once
I've given a breakpoint


100
00:04:46,796 --> 00:04:50,216
or multiple breakpoints a name,
I can then operate on them


101
00:04:50,466 --> 00:04:51,606
with all the other commands.


102
00:04:51,606 --> 00:04:54,966
Breakpoint enable name
will enable all breakpoints


103
00:04:55,266 --> 00:04:59,846
that share that name or,
again, think of it as that tag.


104
00:05:00,046 --> 00:05:02,466
That is made even more
interesting by the fact


105
00:05:02,466 --> 00:05:05,496
that we now allow you to
set breakpoints in LLDBinit.


106
00:05:06,276 --> 00:05:07,996
If you're not familiar
with LLDBinit,


107
00:05:08,206 --> 00:05:12,416
this is a filename starting with
a prefix with a period that goes


108
00:05:12,416 --> 00:05:15,666
in your home directory that
tells LLDB, here are a bunch


109
00:05:15,666 --> 00:05:19,366
of commands to execute every
time I start an LLDB session.


110
00:05:20,256 --> 00:05:22,156
So if you use these,
you can create a set


111
00:05:22,156 --> 00:05:24,846
of default breakpoints
when LLDB starts,


112
00:05:25,166 --> 00:05:28,226
and all breakpoints you set
before you actually create a


113
00:05:28,226 --> 00:05:31,536
target are inherited by
every target you create.


114
00:05:32,646 --> 00:05:36,256
So combine these two, and I
can write an LLDBinit along


115
00:05:36,256 --> 00:05:36,846
these lines.


116
00:05:37,236 --> 00:05:39,306
A set of breakpoints, -n
everything named malloc,


117
00:05:39,696 --> 00:05:41,426
a breakpoint -n everything
named free,


118
00:05:41,656 --> 00:05:45,176
name all of those breakpoints
memory, and then disable them.


119
00:05:45,366 --> 00:05:47,966
And what this gives me
is a handy way to get all


120
00:05:47,966 --> 00:05:49,966
of my memory handling
breakpoints just


121
00:05:49,966 --> 00:05:53,876
by typing 'breakpoint enable
memory' in any session


122
00:05:53,876 --> 00:05:54,896
that I use thereafter.


123
00:05:55,406 --> 00:05:58,236
So, you'll have your own set,
I'm sure, of handy breakpoints


124
00:05:58,276 --> 00:05:59,706
that you always want
to have access to


125
00:05:59,896 --> 00:06:02,126
and now you can give them
easy to remember names.


126
00:06:02,746 --> 00:06:07,586
But, of course, you are here
not just to learn about things


127
00:06:07,586 --> 00:06:09,086
that we have done
and already shipped,


128
00:06:09,356 --> 00:06:11,706
but the things we are
just starting to preview.


129
00:06:11,786 --> 00:06:14,636
Xcode 7, really important
release,


130
00:06:14,986 --> 00:06:16,406
a lot of improvements here.


131
00:06:16,636 --> 00:06:18,376
An expression evaluation,
notably.


132
00:06:18,606 --> 00:06:21,066
And Sean is going to talk to you
a lot more in depth about this.


133
00:06:21,696 --> 00:06:24,406
Swift 2 support, because, of
course, the language continues


134
00:06:24,406 --> 00:06:27,546
to evolve, as well as
Objective-C support in terms


135
00:06:27,546 --> 00:06:29,376
of advanced handling
for modules.


136
00:06:30,646 --> 00:06:32,146
Some of this we'll
cover in depth,


137
00:06:32,546 --> 00:06:34,806
but some of it is really
just behind the scenes.


138
00:06:34,806 --> 00:06:36,796
If you go digging, you
may notice, for example,


139
00:06:36,796 --> 00:06:39,976
that in Xcode 7, because
we know about modules,


140
00:06:40,736 --> 00:06:44,086
we can actually build debug
information for the module once


141
00:06:44,366 --> 00:06:46,516
and then not replicate
it everywhere else.


142
00:06:46,856 --> 00:06:50,176
This allows us to
drastically decrease the size


143
00:06:50,746 --> 00:06:54,096
of debug information and improve
the performance of compilation.


144
00:06:54,666 --> 00:06:56,656
Once you get into
actual .dSYM file,


145
00:06:56,656 --> 00:06:59,596
that .dSYM file will then
contain absolutely everything


146
00:06:59,596 --> 00:07:00,056
you need.


147
00:07:00,536 --> 00:07:03,026
But it also contains some
handy other optimizations,


148
00:07:03,026 --> 00:07:06,006
like not duplicating
information for C++ types,


149
00:07:06,376 --> 00:07:07,886
thanks to the one
definition rule,


150
00:07:08,126 --> 00:07:10,266
whereas before we may
have had multiple copies.


151
00:07:10,786 --> 00:07:13,576
In fact, we have seen
debug information winding


152
00:07:13,576 --> 00:07:18,076
up a sixth the size
that it was in Xcode 6,


153
00:07:18,236 --> 00:07:19,906
especially for C++ projects.


154
00:07:20,466 --> 00:07:23,456
We have also improved the data
formatting in a variety of ways.


155
00:07:23,706 --> 00:07:26,996
Vector types now get unique
automatic data formatting both


156
00:07:26,996 --> 00:07:28,476
for Objective-C and Swift.


157
00:07:29,036 --> 00:07:31,946
And, perhaps most importantly,
if you have custom types


158
00:07:32,086 --> 00:07:35,396
in Swift, you can now customize
the way they are presented just


159
00:07:35,506 --> 00:07:36,576
by writing Swift code.


160
00:07:36,576 --> 00:07:39,936
And Enrico will talk
about this in depth.


161
00:07:40,276 --> 00:07:42,796
We have integrated support for
address sanitizer into LLDB.


162
00:07:42,796 --> 00:07:45,986
So not only will address
sanitizer tell you


163
00:07:45,986 --> 00:07:47,506
when you reference
memory that is invalid,


164
00:07:47,796 --> 00:07:49,466
but you can ask questions
about memory.


165
00:07:49,846 --> 00:07:52,906
You can ask, for example, for
the history of memory to see


166
00:07:52,906 --> 00:07:55,556
where it was allocated or
when it was deallocated,


167
00:07:55,756 --> 00:07:59,006
right from the LLDB
console, so the memory family


168
00:07:59,006 --> 00:08:01,286
of commands are ones you
might want to dig into


169
00:08:01,346 --> 00:08:03,706
and look at the help for.


170
00:08:03,916 --> 00:08:06,606
We've also added
type lookup commands.


171
00:08:06,886 --> 00:08:09,496
The type lookup command will
allow you to get information


172
00:08:09,496 --> 00:08:10,906
about any type in the system.


173
00:08:11,436 --> 00:08:13,786
Basically it's a
header-like representation


174
00:08:13,786 --> 00:08:16,296
that you can get right there
in the debugger to remind you


175
00:08:16,376 --> 00:08:17,746
about the contents of the type.


176
00:08:19,146 --> 00:08:20,606
So, from the LLDB prompt,


177
00:08:21,116 --> 00:08:24,596
all I need to do is type 'type
lookup' followed by a type name


178
00:08:24,836 --> 00:08:26,806
and I'll get a quick
description of that type.


179
00:08:26,966 --> 00:08:28,866
In this case the new
error type that's used


180
00:08:28,866 --> 00:08:31,026
by Swift's error
handling mechanism.


181
00:08:31,346 --> 00:08:33,586
I see that behind the
scenes we have a pair


182
00:08:33,586 --> 00:08:36,606
of properties normally
implemented for you so long


183
00:08:36,606 --> 00:08:37,785
as you're using a EDAM type,


184
00:08:38,216 --> 00:08:40,726
but nonetheless you can see the
details right from the console.


185
00:08:41,206 --> 00:08:43,145
Similarly if I'm
interested in a type


186
00:08:43,145 --> 00:08:44,876
like 'Comparable,' a protocol.


187
00:08:45,216 --> 00:08:47,136
It will tell me that this
protocol actually derives


188
00:08:47,136 --> 00:08:49,936
from two others, so that you
will see that Equatable is


189
00:08:49,936 --> 00:08:51,626
where we get the
equality operator.


190
00:08:52,066 --> 00:08:54,806
The underscore Comparable is
where we get the basic less-than


191
00:08:55,116 --> 00:08:57,246
and then the derived
operators are part


192
00:08:57,246 --> 00:08:58,316
of the Comparable protocol.


193
00:08:58,776 --> 00:09:01,206
So there's a lot of convenient
information you can get here.


194
00:09:01,496 --> 00:09:04,516
And like everything else,
remind you that you don't have


195
00:09:04,566 --> 00:09:06,576
to type the full
command 'type lookup.'


196
00:09:06,836 --> 00:09:10,266
TY space L is sufficient
to use this command.


197
00:09:10,846 --> 00:09:13,986
But to dive into more depth,
especially to talk to us


198
00:09:13,986 --> 00:09:15,696
about how we evaluate
expressions,


199
00:09:15,996 --> 00:09:17,956
I would like to invite up
Sean Callanan [applause].


200
00:09:19,456 --> 00:09:19,876
>> SEAN CALLANAN: Hello.


201
00:09:21,606 --> 00:09:24,276
I want to tell you
about compilers in LLDB.


202
00:09:24,276 --> 00:09:26,346
Now you may be saying


203
00:09:26,346 --> 00:09:28,916
to yourself there are
lots of compiler sessions.


204
00:09:29,296 --> 00:09:30,456
Why do I care about compilers?


205
00:09:31,566 --> 00:09:34,486
Compilers are a critical
part of LLDB.


206
00:09:35,276 --> 00:09:37,646
They are what makes
LLDB powerful,


207
00:09:37,646 --> 00:09:40,646
and they are what
makes LLDB easy to use.


208
00:09:41,196 --> 00:09:44,866
It is really powerful because
compilers have a unique


209
00:09:44,866 --> 00:09:49,076
understanding of the way your
program works, the way it lays


210
00:09:49,076 --> 00:09:53,976
out its data, and what you mean
when you say I want to look


211
00:09:53,976 --> 00:09:56,876
at this variable or
call this function.


212
00:09:56,956 --> 00:10:00,246
Another reason the
compilers are so important is


213
00:10:00,246 --> 00:10:02,946
because they make it easy
to work with the debugger.


214
00:10:03,896 --> 00:10:08,156
If you want to print something
you just use the code you are


215
00:10:08,156 --> 00:10:11,476
used to typing, pass it
to the expression command,


216
00:10:11,476 --> 00:10:14,916
and the compiler
takes over from there.


217
00:10:16,176 --> 00:10:19,436
So today I want to tell you


218
00:10:19,436 --> 00:10:21,326
about the improvements
we've made


219
00:10:21,816 --> 00:10:25,206
in two important areas related
to our compiler integration.


220
00:10:26,776 --> 00:10:29,296
First of all, I've
got some great news


221
00:10:29,296 --> 00:10:31,276
for you long-time
Objective-C developers.


222
00:10:32,486 --> 00:10:35,996
And then I'm going to tell
all you Swift developers,


223
00:10:35,996 --> 00:10:38,206
whom I hope is all
of you at this point,


224
00:10:39,446 --> 00:10:41,946
about the improvements
we've made there, too.


225
00:10:42,516 --> 00:10:47,246
Let's get started
on Objective-C.


226
00:10:47,506 --> 00:10:52,376
Now, LLDB contains two
separate compilers.


227
00:10:53,916 --> 00:10:58,646
Clang, a powerful Objective-C
compiler and, of course,


228
00:10:58,796 --> 00:11:02,606
since last year,
the Swift compiler.


229
00:11:02,606 --> 00:11:06,196
Our Objective-C compiler
support has been improving


230
00:11:06,196 --> 00:11:09,446
over the years and we have
been adding great new features.


231
00:11:10,686 --> 00:11:13,996
For example, the Objective-C
runtime integration.


232
00:11:14,826 --> 00:11:18,006
So if there's some information
in the Objective-C runtime


233
00:11:18,296 --> 00:11:21,946
that isn't present in your debug
information, we know to feed


234
00:11:21,946 --> 00:11:25,166
that to the compiler so that
you can use lots of classes


235
00:11:25,606 --> 00:11:27,136
without having to
do anything special.


236
00:11:27,656 --> 00:11:29,596
Last year, of course,


237
00:11:29,936 --> 00:11:32,966
we introduced the Swift
compiler into LLDB.


238
00:11:32,966 --> 00:11:39,026
And the Swift compiler already
is a very powerful tool.


239
00:11:39,496 --> 00:11:41,996
And we've used a lot of
lessons that we learned


240
00:11:41,996 --> 00:11:43,546
from integrating
the Swift compiler,


241
00:11:43,546 --> 00:11:46,106
and we are improving
them both together.


242
00:11:47,636 --> 00:11:50,576
Let's talk about how the
expression parser works


243
00:11:51,596 --> 00:11:54,696
with Swift, with a
view of Objective-C.


244
00:11:54,696 --> 00:11:59,966
Let's look at a simple
print command.


245
00:12:00,686 --> 00:12:03,556
Now I say print here because
I'm using the p shortcut.


246
00:12:04,476 --> 00:12:07,116
What that actually
means is expression.


247
00:12:08,186 --> 00:12:09,466
Notice the dash dash.


248
00:12:10,336 --> 00:12:14,156
That means everything after
the p command has to be code.


249
00:12:14,476 --> 00:12:17,746
You can't pass extra options
to the command this way.


250
00:12:18,356 --> 00:12:20,186
There are other ways,
as Enrico will tell you,


251
00:12:20,296 --> 00:12:21,496
and as Kate showed you before.


252
00:12:22,686 --> 00:12:25,866
Now here is some simple code
that runs through a loop


253
00:12:25,866 --> 00:12:27,366
and prints the loop
counter each time.


254
00:12:28,046 --> 00:12:30,876
And, indeed, if you run
it you get the numbers


255
00:12:30,876 --> 00:12:31,796
out that you would expect.


256
00:12:33,296 --> 00:12:34,066
Why is this cool?


257
00:12:35,006 --> 00:12:39,736
Well, LLDB and your program
are separate processes.


258
00:12:40,766 --> 00:12:43,116
LLDB has a swift
compiler inside it.


259
00:12:44,316 --> 00:12:48,276
Your program is already
running, but with LLDB's help,


260
00:12:48,866 --> 00:12:52,356
the Swift compiler can inject
the code that you just typed


261
00:12:52,596 --> 00:12:53,906
into your program to run.


262
00:12:54,506 --> 00:12:58,726
That's kind of cool if you
like printing loop counters.


263
00:12:59,436 --> 00:13:03,426
But there's a little
bit more to debugging.


264
00:13:03,516 --> 00:13:05,886
Swift also works
with your variables.


265
00:13:06,536 --> 00:13:08,836
You type in some code.


266
00:13:09,486 --> 00:13:13,176
And the contents of
an array are printed.


267
00:13:14,626 --> 00:13:17,526
Now, this array here
is just a piece of data


268
00:13:17,526 --> 00:13:18,426
that is in your program.


269
00:13:19,436 --> 00:13:23,236
And LLDB arranges to show
that data to the compiler


270
00:13:23,626 --> 00:13:26,426
so that it can generate
the code that you expect.


271
00:13:27,176 --> 00:13:31,306
There is another thing I want
to talk about really quickly.


272
00:13:31,746 --> 00:13:33,836
And that is how Swift
works with the SDK.


273
00:13:35,426 --> 00:13:39,286
When you type an expression like
NSApplication.sharedApplication,


274
00:13:40,606 --> 00:13:42,796
what happens is, first


275
00:13:42,796 --> 00:13:46,166
of all you see the
NSApplication.sharedApplication,


276
00:13:46,166 --> 00:13:46,926
the way you would expect.


277
00:13:48,396 --> 00:13:53,146
But what LLDB is doing is going
out and finding the SDK module


278
00:13:53,146 --> 00:13:56,916
that contains that, giving
the compiler access to it,


279
00:13:57,566 --> 00:14:00,646
then the compiler finds
NSApplication and figures


280
00:14:00,646 --> 00:14:02,556
out how to use
sharedApplication.


281
00:14:03,896 --> 00:14:07,516
That's all great and it
is automatic in Swift.


282
00:14:08,686 --> 00:14:12,306
In Objective-C it
doesn't always work.


283
00:14:13,516 --> 00:14:18,086
So let's try all these things
in Objective-C and some


284
00:14:18,086 --> 00:14:20,926
of you may be getting a little
bit apprehensive at this moment,


285
00:14:21,596 --> 00:14:25,476
because you know that trying to
NSLog something isn't as easy


286
00:14:25,476 --> 00:14:26,916
as it sounds in the debugger.


287
00:14:26,916 --> 00:14:32,356
Well, in the past when
you've typed in NSLog,


288
00:14:32,766 --> 00:14:36,826
you've seen errors like this:
NS log has unknown return type.


289
00:14:37,716 --> 00:14:40,006
That's because in
the SDK, sure enough,


290
00:14:40,006 --> 00:14:41,706
there's a definition of NSLog.


291
00:14:42,116 --> 00:14:44,296
But what LLDB sees
is only what's


292
00:14:44,296 --> 00:14:46,016
in the debug information
in the symbols.


293
00:14:46,426 --> 00:14:48,056
In this case, all
it sees is a symbol.


294
00:14:48,836 --> 00:14:51,236
That symbol, we don't know
what its return type is


295
00:14:51,376 --> 00:14:53,616
and we don't even know that
it takes a format string.


296
00:14:54,536 --> 00:14:57,006
Well, the good news is,
we fixed that [applause].


297
00:14:58,126 --> 00:14:59,686
>> SEAN CALLANAN: NSLog works
the way you would expect.


298
00:15:05,846 --> 00:15:09,766
Now, let's try something a
little bit more underhanded.


299
00:15:11,316 --> 00:15:12,836
Print NSMakeRect.


300
00:15:13,566 --> 00:15:14,206
Wait a second!


301
00:15:14,276 --> 00:15:15,516
Why is this underhanded?


302
00:15:15,716 --> 00:15:19,476
It's right there
in the frameworks.


303
00:15:19,476 --> 00:15:22,856
Unfortunately it looks like this
identifier doesn't even exist.


304
00:15:23,766 --> 00:15:26,706
Now, you may know
that if you use NSLog


305
00:15:26,706 --> 00:15:29,166
and you cast the result,
yeah, you can use that.


306
00:15:30,096 --> 00:15:32,086
But with NSMakeRect
you can't even do that.


307
00:15:33,546 --> 00:15:37,336
That's because NSMakeRect
is defined NS-Inline.


308
00:15:37,896 --> 00:15:39,236
There is no symbol for it.


309
00:15:39,796 --> 00:15:42,166
What LLDB sees is nothing.


310
00:15:44,106 --> 00:15:44,566
Good news.


311
00:15:45,346 --> 00:15:47,816
No problem anymore.


312
00:15:48,516 --> 00:15:53,566
[ Applause ]


313
00:15:54,066 --> 00:15:55,566
>> SEAN CALLANAN: Just
one more pain point left.


314
00:15:56,796 --> 00:16:00,266
Now let's look at
the old NSApplication


315
00:16:00,266 --> 00:16:01,526
sharedApplication case.


316
00:16:01,846 --> 00:16:04,486
Sure, if you ran that
expression by yourself, yes,


317
00:16:04,486 --> 00:16:05,656
it would work in Objective-C.


318
00:16:05,656 --> 00:16:06,826
I mean, we have been working


319
00:16:06,826 --> 00:16:08,536
on the Objective-C
runtime integration.


320
00:16:09,446 --> 00:16:12,216
But if you try to get out the
undo.Manager you quickly see


321
00:16:12,446 --> 00:16:14,496
that the runtime doesn't
tell you everything.


322
00:16:15,226 --> 00:16:17,316
In particular you
get this weird error


323
00:16:17,576 --> 00:16:21,546
about undo.Manager not being
found on an object of type id.


324
00:16:22,536 --> 00:16:23,686
What is going on there?


325
00:16:24,146 --> 00:16:25,636
In the SDK, sure enough,


326
00:16:25,636 --> 00:16:28,316
sharedApplication returns
an NSApplication star.


327
00:16:28,786 --> 00:16:32,836
But if you look at the
runtime, what it returns is id,


328
00:16:33,076 --> 00:16:36,426
a generic Objective-C object.


329
00:16:36,956 --> 00:16:39,906
Great news.


330
00:16:40,186 --> 00:16:41,426
That is no longer a problem.


331
00:16:41,926 --> 00:16:45,086
In fact we see information
that we can only find


332
00:16:45,086 --> 00:16:48,956
out from the SDK such as that
that pointer is nullable.


333
00:16:49,076 --> 00:16:51,716
This is some of the great
new SDK support for Swift


334
00:16:52,066 --> 00:16:54,266
that just bubbles down
into Objective-C as well.


335
00:16:55,066 --> 00:17:00,076
But the information
is right there.


336
00:17:00,466 --> 00:17:02,676
And that's the philosophy
that we've applied here.


337
00:17:03,526 --> 00:17:05,415
Read straight from the SDK.


338
00:17:06,205 --> 00:17:08,406
Your code has always
worked in LLDB.


339
00:17:08,705 --> 00:17:13,215
We knew about local variables,
functions, your own classes.


340
00:17:14,986 --> 00:17:16,886
SDK functions, on
the other hand,


341
00:17:17,656 --> 00:17:20,106
we had a little bit more
issues with, as you see.


342
00:17:20,915 --> 00:17:24,256
SDK classes like NSView
and NSApplication, yeah,


343
00:17:24,256 --> 00:17:25,695
we saw them but, as you see,


344
00:17:25,695 --> 00:17:27,266
because of the runtime
integration,


345
00:17:28,006 --> 00:17:29,626
there was a little bit
of an asterisk there.


346
00:17:31,116 --> 00:17:33,966
Now, SDK constants, if
you ever tried using


347
00:17:34,136 --> 00:17:36,566
NSASCIIStringEncoding
in an expression,


348
00:17:36,566 --> 00:17:37,866
you know that never flew.


349
00:17:39,136 --> 00:17:43,256
And if you tried using macros
like int-max, and, you know,


350
00:17:43,456 --> 00:17:46,006
max, to take the
largest of two numbers,


351
00:17:46,616 --> 00:17:48,106
that wasn't going
anywhere either.


352
00:17:49,226 --> 00:17:52,816
Well, all of that is
fixed in the latest LLDB.


353
00:17:53,516 --> 00:17:59,776
[ Applause ]


354
00:18:00,276 --> 00:18:00,866
>> SEAN CALLANAN: And we got rid


355
00:18:00,866 --> 00:18:04,776
of the annoying asterisk,
too [laughter].


356
00:18:05,046 --> 00:18:06,316
>> SEAN CALLANAN:
Now, you may say,


357
00:18:06,316 --> 00:18:09,936
how many easy monthly payments
of 39.95 do I need to make


358
00:18:10,196 --> 00:18:11,406
to get this functionality?


359
00:18:11,406 --> 00:18:13,116
Well, good news, it is all free


360
00:18:13,116 --> 00:18:15,766
and the way you do
it is @import AppKit.


361
00:18:17,116 --> 00:18:18,886
You just run an expression


362
00:18:19,026 --> 00:18:21,656
that says import the
frameworks I care about,


363
00:18:22,526 --> 00:18:24,736
if you pull in AppKit,
or for the two


364
00:18:24,736 --> 00:18:31,966
or three iOS programmers among
you, import UIKit, this works.


365
00:18:32,566 --> 00:18:39,726
Now, we haven't been standing
still with Swift either.


366
00:18:40,156 --> 00:18:44,476
Swift 2.0 has great
error handling support


367
00:18:44,656 --> 00:18:47,956
and LLDB is right off
at the bat supporting


368
00:18:47,956 --> 00:18:52,856
that just the way
you would expect.


369
00:18:52,986 --> 00:18:58,596
We can handle Swift errors and
you don't need to call 'try'


370
00:18:58,596 --> 00:19:00,016
when you are calling functions


371
00:19:00,046 --> 00:19:02,416
that could throw
errors in expressions.


372
00:19:03,396 --> 00:19:07,576
The reason is because
we catch stuff for you.


373
00:19:08,176 --> 00:19:12,456
If you type this
function 'throws' and pass


374
00:19:12,506 --> 00:19:13,496
that to an expression,


375
00:19:13,496 --> 00:19:15,366
notice this is the
same as the p command.


376
00:19:16,646 --> 00:19:20,996
You will get an error
variable created for you


377
00:19:21,256 --> 00:19:23,646
that contains the error
that that function threw.


378
00:19:24,236 --> 00:19:28,576
You can also do this
in the REPL.


379
00:19:29,276 --> 00:19:34,356
If from the REPL prompt,
you do the same thing,


380
00:19:34,566 --> 00:19:36,476
you get an error variable.


381
00:19:38,516 --> 00:19:44,226
Now, let's look at a little bit
more detail of LLDB support.


382
00:19:44,466 --> 00:19:47,126
And that is, you
don't always want


383
00:19:47,246 --> 00:19:49,236
to see what the resulting
error was.


384
00:19:49,926 --> 00:19:52,916
You want to know what was the
code that threw that error.


385
00:19:54,546 --> 00:19:55,486
Well, the way you've done this


386
00:19:55,486 --> 00:19:57,476
in Objective-C is
you used breakpoints.


387
00:19:58,706 --> 00:20:01,976
Specifically you set breakpoints
on Objective-C exceptions.


388
00:20:03,166 --> 00:20:06,706
The way you did this was you
used the breakpoint set command.


389
00:20:07,276 --> 00:20:12,676
You specify that you want
to set the breakpoint


390
00:20:13,016 --> 00:20:15,776
for the Objective-C exception,


391
00:20:16,656 --> 00:20:18,676
and we set that breakpoint
for you.


392
00:20:19,106 --> 00:20:21,886
Now whenever your
Objective-C code tries


393
00:20:21,956 --> 00:20:23,806
to throw an exception,
we'll stop.


394
00:20:25,196 --> 00:20:27,376
You can do the same
thing with Swift errors.


395
00:20:28,196 --> 00:20:30,536
Just replace the
Objective-C with Swift


396
00:20:30,536 --> 00:20:34,276
and we'll stop whenever
your program wants


397
00:20:34,316 --> 00:20:36,056
to throw a Swift error.


398
00:20:37,476 --> 00:20:40,806
But there's another cool
thing that you can do.


399
00:20:40,806 --> 00:20:45,516
And that is you can stop on
specific types of errors.


400
00:20:46,646 --> 00:20:48,456
This is something
we support in Swift.


401
00:20:49,146 --> 00:20:52,026
And the way you do it is very
simple, it's very similar


402
00:20:52,026 --> 00:20:54,826
to the way you would set an
expression breakpoint anyway.


403
00:20:56,136 --> 00:21:01,596
You use the dash O parameter,
which specifies the type name


404
00:21:01,876 --> 00:21:04,606
of the error you want to catch.


405
00:21:04,816 --> 00:21:10,886
Now if you do that, you
will stop only when the type


406
00:21:10,886 --> 00:21:15,276
of error you're interested
in would be thrown.


407
00:21:15,876 --> 00:21:23,616
Now, finally, of course you can
still catch errors the way you


408
00:21:23,616 --> 00:21:24,776
would in normal code.


409
00:21:24,776 --> 00:21:28,646
After all, the REPL is meant
partially as a way to learn


410
00:21:28,706 --> 00:21:30,646
and explore the way
the language works.


411
00:21:32,016 --> 00:21:35,076
If you import Foundation
to get an NSError


412
00:21:36,236 --> 00:21:39,436
and then you write some
code that throws an NSError,


413
00:21:40,336 --> 00:21:44,306
you can catch that
NSError and print it.


414
00:21:45,096 --> 00:21:48,616
If you do that, the output
will be exactly the same


415
00:21:48,746 --> 00:21:50,566
as if you had caught
it in your own program.


416
00:21:50,596 --> 00:21:55,666
So I hope you go out of
this remembering two things.


417
00:21:56,126 --> 00:22:01,606
First of all, add import your
modules, and second of all,


418
00:22:02,416 --> 00:22:04,916
try playing around with
error handing in LLDB.


419
00:22:04,916 --> 00:22:07,436
It's a great place to do it.


420
00:22:07,696 --> 00:22:10,226
Now, for much more
detail, not about how


421
00:22:10,226 --> 00:22:12,256
to tell your program what to do,


422
00:22:12,696 --> 00:22:16,006
but how to print the information
your program produces


423
00:22:16,006 --> 00:22:18,766
after it's done it,
I would like to call


424
00:22:18,766 --> 00:22:19,686
up Enrico Granata [applause].


425
00:22:23,046 --> 00:22:23,176
>> ENRICO GRANATA: Hi!


426
00:22:23,846 --> 00:22:26,036
I was in the Labs this morning.


427
00:22:26,316 --> 00:22:30,266
And we were trying to look
through a problem and one thing


428
00:22:30,266 --> 00:22:33,366
that came up is, why can
I not see this variable?


429
00:22:33,796 --> 00:22:35,566
What's up with that?


430
00:22:35,566 --> 00:22:37,956
And in order to help
us figure that out,


431
00:22:38,516 --> 00:22:39,856
we tried several commands.


432
00:22:39,856 --> 00:22:42,886
We tried expression, we tried
PO, we tried frame variable.


433
00:22:43,376 --> 00:22:47,086
And people usually at this
point ask, why do you have


434
00:22:47,086 --> 00:22:49,576
so many commands to do
pretty much the same thing?


435
00:22:49,616 --> 00:22:51,916
Look at my data, see what
is happening in my program.


436
00:22:52,536 --> 00:22:56,266
Well, all of you here get
the insider scoop now.


437
00:22:56,716 --> 00:22:58,596
Let's look at the
commands that LLDB has


438
00:22:58,716 --> 00:22:59,676
to let you look at data.


439
00:23:00,326 --> 00:23:01,526
There's three of them.


440
00:23:01,526 --> 00:23:07,046
Frame variable, the expression
command, which is the p command,


441
00:23:07,686 --> 00:23:09,686
the expression dash uppercase O,


442
00:23:09,876 --> 00:23:11,716
which as you've been
told before,


443
00:23:12,296 --> 00:23:14,856
you know as the po command.


444
00:23:15,976 --> 00:23:17,976
First one, frame
variable command.


445
00:23:18,696 --> 00:23:21,666
The frame variable command
which you can shorten as frv


446
00:23:21,666 --> 00:23:26,036
when you type it, is pretty
much the Xcode variables view.


447
00:23:26,606 --> 00:23:29,346
It lets you look at all
your local variables.


448
00:23:30,356 --> 00:23:33,656
It lets you look at only a
few of your local variables,


449
00:23:34,596 --> 00:23:37,806
and optionally you can
also apply formatting


450
00:23:38,116 --> 00:23:40,166
with the dash dash format flag.


451
00:23:40,636 --> 00:23:45,086
One thing I want to highlight,
because I will get back to it,


452
00:23:45,086 --> 00:23:48,616
is when you see that
Tuple in the first output,


453
00:23:49,056 --> 00:23:51,926
that is an aggregate,
that is an object


454
00:23:51,966 --> 00:23:53,706
that contains other objects.


455
00:23:54,146 --> 00:23:56,446
The things that are
within that aggregate,


456
00:23:56,976 --> 00:23:59,206
we call them children.


457
00:23:59,866 --> 00:24:04,596
The expression command is
the command you've seen a lot


458
00:24:04,596 --> 00:24:05,226
in this session.


459
00:24:05,486 --> 00:24:06,446
I'll be really brief.


460
00:24:06,986 --> 00:24:09,206
Of course, with the
expression command,


461
00:24:09,206 --> 00:24:11,426
you can do simple
arithmetic, as you'd guess.


462
00:24:12,526 --> 00:24:16,056
It is totally possible
to use previous results


463
00:24:16,666 --> 00:24:19,926
and actually do more
stuff with them.


464
00:24:20,166 --> 00:24:22,416
And of course, the expression
command also knows how


465
00:24:22,416 --> 00:24:24,576
to do custom formatting
of your results.


466
00:24:25,716 --> 00:24:29,356
One thing I want to point
out, once again, children.


467
00:24:30,786 --> 00:24:33,226
Third command, the po command.


468
00:24:34,146 --> 00:24:36,626
This is probably the
command that all of you


469
00:24:36,626 --> 00:24:39,896
who are Objective-C developers,
I'm guessing quite a few prior


470
00:24:39,896 --> 00:24:43,216
to Objective-C code, and
you know the po command.


471
00:24:43,796 --> 00:24:46,886
You can create objects and get
their description printed out.


472
00:24:47,786 --> 00:24:51,006
You can just create an NSArray
or print the existing NSArray


473
00:24:51,006 --> 00:24:52,246
and you'll see the
contents of it.


474
00:24:53,046 --> 00:24:56,336
Or, guess what, it
simply works for a string.


475
00:24:57,756 --> 00:24:59,266
So, three commands.


476
00:24:59,906 --> 00:25:02,076
They don't all do
exactly the same thing,


477
00:25:02,206 --> 00:25:03,766
as you probably guessed by now.


478
00:25:04,706 --> 00:25:07,996
Actually, they are
somewhat similar


479
00:25:07,996 --> 00:25:09,036
and not at all identical.


480
00:25:09,416 --> 00:25:11,846
For instance, the
expression command


481
00:25:11,846 --> 00:25:15,586
and the po command are
'run my code' commands.


482
00:25:16,086 --> 00:25:19,826
Whatever code you type,
these commands will run it.


483
00:25:20,556 --> 00:25:22,386
But then the frame
variable command


484
00:25:22,386 --> 00:25:25,236
and expression command
do step 2 differently.


485
00:25:25,716 --> 00:25:27,486
When they have to
show you your result,


486
00:25:27,856 --> 00:25:30,136
they use the LLDB
formatter system.


487
00:25:31,346 --> 00:25:34,216
We talked quite a bit about
the LLDB formatter system


488
00:25:34,346 --> 00:25:36,476
in past WWDC sessions.


489
00:25:36,856 --> 00:25:38,546
And you should totally
go check them out.


490
00:25:39,086 --> 00:25:41,896
But really briefly,
LLDB has knowledge


491
00:25:41,896 --> 00:25:45,446
of some built-in system types
and automatically formats them.


492
00:25:45,776 --> 00:25:48,456
NSArray, NSDictionaries
with strings.


493
00:25:48,936 --> 00:25:50,966
And it is possible for you


494
00:25:50,966 --> 00:25:53,496
to provide your own format
as written in Python.


495
00:25:54,696 --> 00:25:55,576
On the other hand,


496
00:25:55,986 --> 00:25:58,216
the po command will not
use LLDB formatters.


497
00:25:58,646 --> 00:26:02,766
The po command runs some more
extra code behind the covers,


498
00:26:03,136 --> 00:26:06,276
behind the scenes, to actually
produce the result it has


499
00:26:06,316 --> 00:26:06,766
to show you.


500
00:26:06,806 --> 00:26:10,576
You probably have written at
least one description method


501
00:26:10,576 --> 00:26:13,376
in one of your Objective-C
classes and then you realized,


502
00:26:13,506 --> 00:26:15,196
oh, that's what po prints.


503
00:26:16,266 --> 00:26:20,016
Now I want you to think for a
second about these two models


504
00:26:20,016 --> 00:26:23,756
of actually taking your object
and producing data for it.


505
00:26:24,136 --> 00:26:28,346
The LLDB formatter's model
is what we call the 'out


506
00:26:28,346 --> 00:26:29,576
of process' formatting model.


507
00:26:29,996 --> 00:26:33,636
Why? Because the formatter
sits outside of your process.


508
00:26:33,946 --> 00:26:36,376
It is either built
knowledge into the debugger


509
00:26:36,846 --> 00:26:39,596
or you brought some Python
script to represent your object.


510
00:26:39,596 --> 00:26:41,976
It's different languages,
different files


511
00:26:42,066 --> 00:26:43,756
that live in different scopes.


512
00:26:44,636 --> 00:26:48,706
On the other hand, that external
formatter lives in the dugger.


513
00:26:48,906 --> 00:26:51,936
It is really easy for
that guy to get access


514
00:26:51,936 --> 00:26:54,436
to all the knowledge about your
program that the debugger has.


515
00:26:54,736 --> 00:26:57,276
It's kind of like a bird's
eye view of your process.


516
00:26:57,526 --> 00:27:01,506
Because of that, it's also
really easy for this kind


517
00:27:01,506 --> 00:27:03,076
of formatter to make sure


518
00:27:03,076 --> 00:27:05,146
that your program
state is not changed.


519
00:27:05,666 --> 00:27:07,986
You don't want to change
the state of your program


520
00:27:07,986 --> 00:27:10,326
as a result of looking
at data in the debugger.


521
00:27:10,756 --> 00:27:13,786
The debugger is kind of
like the stage inspector.


522
00:27:13,786 --> 00:27:16,406
It looks at things and
tries not to change them.


523
00:27:17,616 --> 00:27:20,046
The other model, the po model,


524
00:27:20,416 --> 00:27:24,286
the 'write a description
method' model is an in-process


525
00:27:24,286 --> 00:27:25,126
formatting model.


526
00:27:25,616 --> 00:27:28,356
You write your data and
your formatter together,


527
00:27:28,666 --> 00:27:30,566
you write them in
the same language.


528
00:27:31,116 --> 00:27:33,656
You probably even write
them in the same file.


529
00:27:34,606 --> 00:27:37,056
And because your formatter
is just code that runs


530
00:27:37,056 --> 00:27:40,496
in your application, it
gets easy and full access


531
00:27:40,496 --> 00:27:42,746
to the object model
of your application.


532
00:27:44,046 --> 00:27:47,846
But with great power,
comes great responsibility.


533
00:27:48,526 --> 00:27:52,116
You want to make sure that your
formatter does not change the


534
00:27:52,116 --> 00:27:52,976
state of your program.


535
00:27:53,526 --> 00:27:56,486
You want to make sure you don't
do anything in your formatter


536
00:27:56,896 --> 00:27:59,176
that will alter the object
you're trying to represent.


537
00:28:00,976 --> 00:28:04,396
Well, you say, okay,
Objective-C has an in-process


538
00:28:04,396 --> 00:28:05,136
formatting model.


539
00:28:05,456 --> 00:28:06,856
I can write a description
method,


540
00:28:06,856 --> 00:28:08,036
the debugger will pick it up.


541
00:28:08,786 --> 00:28:10,556
What about Swift?


542
00:28:11,346 --> 00:28:13,566
Turns out, and once again,
those of you that are


543
00:28:13,566 --> 00:28:15,006
in this room get
the insider scoop,


544
00:28:15,446 --> 00:28:18,256
that Swift has had an
in-process formatting model


545
00:28:18,646 --> 00:28:19,746
since the very beginning.


546
00:28:20,696 --> 00:28:21,396
But, where is it?


547
00:28:21,616 --> 00:28:22,676
How do I use it?


548
00:28:23,126 --> 00:28:26,496
I hope all of you have
used the Swift playground.


549
00:28:27,116 --> 00:28:28,986
If you have used the
Swift playground,


550
00:28:29,496 --> 00:28:32,126
you have used the Swift
in-process formatting model.


551
00:28:32,356 --> 00:28:35,836
It has been there
since the beginning.


552
00:28:35,836 --> 00:28:36,526
So what is new?


553
00:28:37,436 --> 00:28:41,236
Now in Xcode 7, we take
that very same model,


554
00:28:41,796 --> 00:28:43,486
we make it public API.


555
00:28:44,416 --> 00:28:46,986
It is available for you to use.


556
00:28:46,986 --> 00:28:50,066
And it still powers
the playgrounds,


557
00:28:50,656 --> 00:28:53,806
but now it also powers
the LLDB po command.


558
00:28:54,436 --> 00:28:56,606
Now you've got the
right Swift formatters


559
00:28:56,656 --> 00:28:58,006
for your Swift objects.


560
00:28:58,696 --> 00:29:01,406
How? Let's look a little
bit under the cover.


561
00:29:01,916 --> 00:29:05,306
The model is based
upon four protocols.


562
00:29:05,886 --> 00:29:07,836
These are their names.


563
00:29:09,286 --> 00:29:11,426
Yes, I said four protocols.


564
00:29:12,086 --> 00:29:13,856
And their names are
also quite lengthy.


565
00:29:14,616 --> 00:29:16,666
But I wouldn't worry
too much about that.


566
00:29:16,946 --> 00:29:20,126
It's possible to only opt-in
partially to this model.


567
00:29:20,376 --> 00:29:22,306
The four protocols
doesn't mean you have


568
00:29:22,306 --> 00:29:23,956
to conform to all of them.


569
00:29:23,956 --> 00:29:26,576
You can choose a subset to
get the result you want done.


570
00:29:27,156 --> 00:29:30,256
>> ENRICO: Conform to those,
do that work, and profit.


571
00:29:31,486 --> 00:29:32,406
Let's look at the protocols.


572
00:29:33,836 --> 00:29:37,336
CustomStringConvertible is
the protocol that tells,


573
00:29:37,926 --> 00:29:42,286
that tells us, how would I
print my object as a string?


574
00:29:42,816 --> 00:29:45,426
It doesn't only tell LLDB.


575
00:29:45,716 --> 00:29:47,166
It also tells Swift.


576
00:29:47,856 --> 00:29:50,266
How? The Swift print function,


577
00:29:50,816 --> 00:29:53,466
as well as the Swift string
interpolation feature,


578
00:29:53,776 --> 00:29:55,656
both use the
CustomStringConvertible


579
00:29:55,656 --> 00:29:56,206
protocol.


580
00:29:57,276 --> 00:29:58,416
That's a lot of benefit.


581
00:29:58,586 --> 00:30:00,596
How hard can it be to get it?


582
00:30:01,346 --> 00:30:02,676
It's pretty easy.


583
00:30:02,846 --> 00:30:05,026
I have a data structure
that represents the bottles


584
00:30:05,026 --> 00:30:07,946
of beer song, because I'm
preparing myself for the bash.


585
00:30:08,376 --> 00:30:10,186
And I want to print the lyrics.


586
00:30:10,886 --> 00:30:13,316
I create an instance of that,
and I say, how many bottles


587
00:30:13,316 --> 00:30:14,396
of beer are on the wall.


588
00:30:14,396 --> 00:30:18,366
But that's for when
everything in my app works fine.


589
00:30:18,366 --> 00:30:20,286
If I'm debugging it,
maybe I need a little bit


590
00:30:20,286 --> 00:30:21,176
more information.


591
00:30:21,666 --> 00:30:24,546
That's where Custom Debug
String Convertible kicks in.


592
00:30:25,376 --> 00:30:28,536
It's a debugger specific
representation of the object.


593
00:30:29,536 --> 00:30:33,786
What debugger-specific means
is really up to your app.


594
00:30:33,786 --> 00:30:35,756
It's really up to the
semantics of your object model.


595
00:30:36,506 --> 00:30:40,166
But, as a hint, the
debugPrint function will default


596
00:30:40,166 --> 00:30:41,626
to choosing this protocol.


597
00:30:42,326 --> 00:30:46,266
Of course, both print and
debugPrint will fall back


598
00:30:46,316 --> 00:30:49,496
to the other conformance if
their favorite one isn't there.


599
00:30:50,476 --> 00:30:52,266
How to get this to work?


600
00:30:52,266 --> 00:30:52,986
Pretty simple.


601
00:30:53,966 --> 00:30:55,276
Let's extend our
bottles of beer.


602
00:30:55,386 --> 00:30:58,626
Because we are debugging, we
want to know a little bit more


603
00:30:58,626 --> 00:31:01,436
about the bottles of beer on
the wall, so we can just check


604
00:31:01,496 --> 00:31:03,916
that they are all correctly
stout, and it is going


605
00:31:03,916 --> 00:31:05,466
to be a great bash
because they all are.


606
00:31:06,316 --> 00:31:10,656
Third protocol is Custom
Playground Quick Lookable.


607
00:31:11,776 --> 00:31:12,876
As the name implies,


608
00:31:13,366 --> 00:31:16,196
this protocol is
specifically for playgrounds.


609
00:31:16,476 --> 00:31:20,726
It is meant to provide rich
graphical representations


610
00:31:20,726 --> 00:31:22,596
of your object in a playground.


611
00:31:23,706 --> 00:31:24,466
You want an example?


612
00:31:24,726 --> 00:31:25,716
Sure thing.


613
00:31:26,626 --> 00:31:29,636
I can write a data structure
that represents a person,


614
00:31:29,636 --> 00:31:32,726
and then I can get a
depiction of a person to show


615
00:31:32,726 --> 00:31:35,306
up in my playground
sidebar as a result


616
00:31:35,306 --> 00:31:37,526
of creating an object
of that type.


617
00:31:38,556 --> 00:31:41,846
I'm quite sorry to disappoint
you guys, I really wanted


618
00:31:41,846 --> 00:31:42,826
to get this to happen.


619
00:31:43,146 --> 00:31:44,716
But, unfortunately the t-shirts


620
00:31:44,716 --> 00:31:47,806
with my person will not
be sold at the conference.


621
00:31:48,356 --> 00:31:52,176
Sorry. But I have something
to make up for that.


622
00:31:52,696 --> 00:31:56,126
The last protocol in the lot,
the Custom Reflectable protocol.


623
00:31:56,426 --> 00:31:58,466
It allows us to invent
a entirely custom


624
00:31:58,686 --> 00:31:59,666
children hierarchy.


625
00:32:00,076 --> 00:32:02,916
Yes, I said I would get back to
the word 'children' and I did.


626
00:32:04,036 --> 00:32:07,136
When I say an entirely
custom children hierarchy,


627
00:32:08,276 --> 00:32:11,926
what I mean is that
I can make a new --


628
00:32:11,926 --> 00:32:14,786
I can make a new
structure for my object.


629
00:32:15,016 --> 00:32:17,196
I can tell the language,
I can tell the debugger,


630
00:32:17,196 --> 00:32:18,206
I can tell the playgrounds,


631
00:32:18,636 --> 00:32:20,786
this is what my object
is actually made of.


632
00:32:20,876 --> 00:32:22,006
This is how you should see it.


633
00:32:22,566 --> 00:32:26,416
And the way you do this, the
currency that you transact in,


634
00:32:26,866 --> 00:32:29,106
when you're trying to describe
the structure of objects


635
00:32:29,156 --> 00:32:33,426
to Swift, is called a
Mirror, reflectable mirror.


636
00:32:35,226 --> 00:32:37,766
Let's see an example,
without further ado.


637
00:32:38,056 --> 00:32:40,596
I have an application
whose job it is


638
00:32:40,816 --> 00:32:42,726
to collect temperature samples.


639
00:32:43,046 --> 00:32:45,116
It has got a couple
data structures.


640
00:32:45,706 --> 00:32:49,556
One that describes a moment
in time, and one says,


641
00:32:49,746 --> 00:32:51,126
for a given moment in time,


642
00:32:51,536 --> 00:32:53,516
this was the temperature
information I got.


643
00:32:54,236 --> 00:32:56,206
And then we have got
temperature samples, of course.


644
00:32:57,256 --> 00:32:58,356
Now I'm debugging this app.


645
00:32:58,356 --> 00:33:00,796
I'm trying to see
what is going on,


646
00:33:00,796 --> 00:33:02,146
how it's processing the samples.


647
00:33:02,686 --> 00:33:05,156
So I say po temperatures.


648
00:33:05,626 --> 00:33:07,246
And that's what I got.


649
00:33:08,716 --> 00:33:11,426
Honestly, you know, I
look at it and I say,


650
00:33:11,426 --> 00:33:13,676
it is not bad for a default.


651
00:33:14,406 --> 00:33:16,216
But I immediately see
a couple things I want


652
00:33:16,216 --> 00:33:17,146
to change about this.


653
00:33:17,936 --> 00:33:20,136
Why stack time on two lines?


654
00:33:20,136 --> 00:33:22,456
I really wish it
was all in one line.


655
00:33:22,826 --> 00:33:24,906
And it would be great
if it was in a.m.


656
00:33:24,906 --> 00:33:26,756
/p.m. format, too.


657
00:33:26,916 --> 00:33:29,816
And that temperature, I
look at it and I'm like,


658
00:33:30,046 --> 00:33:31,636
what scale is that in?


659
00:33:31,706 --> 00:33:32,436
I don't even know.


660
00:33:32,676 --> 00:33:35,696
Is it Kelvin, is it
Reaumur, is it Rankine?


661
00:33:36,006 --> 00:33:39,116
We are in America and
we want our Fahrenheit


662
00:33:40,766 --> 00:33:40,966
degrees [laughter].


663
00:33:41,056 --> 00:33:44,296
>> ENRICO GRANATA: Well, the
good news is that we can fix all


664
00:33:44,296 --> 00:33:46,856
of these things, in two steps.


665
00:33:48,306 --> 00:33:52,356
Let's go. Step one, let's get
the time printed on one line.


666
00:33:53,156 --> 00:33:56,776
Here is what I did to get
that to happen for me.


667
00:33:57,186 --> 00:33:59,076
I used an NSDate formatter.


668
00:34:00,726 --> 00:34:03,806
Because I got to run
within my application,


669
00:34:04,186 --> 00:34:05,696
because the code I'm running


670
00:34:05,696 --> 00:34:09,686
to format this object is
actually just normal Swift code,


671
00:34:09,976 --> 00:34:12,766
it is just code I would normally
write as part of my app,


672
00:34:12,846 --> 00:34:15,056
whatever framework,
whatever library,


673
00:34:15,386 --> 00:34:17,696
whatever technology my
app would normally use


674
00:34:17,696 --> 00:34:21,016
to get this job done, I can
just use it in my formatters.


675
00:34:21,496 --> 00:34:23,606
In this case NSDate formatter.


676
00:34:24,926 --> 00:34:28,295
Step two, let's get those
Fahrenheit degrees going.


677
00:34:29,456 --> 00:34:30,886
How do we do it?


678
00:34:31,696 --> 00:34:32,946
We create a mirror.


679
00:34:33,576 --> 00:34:34,176
Here we are.


680
00:34:34,876 --> 00:34:38,266
Now we are saying that our
temperature data object is


681
00:34:38,266 --> 00:34:41,626
structured as a container
of three things.


682
00:34:42,246 --> 00:34:44,286
A time, a temperature
in Centigrade,


683
00:34:44,286 --> 00:34:45,596
and a temperature in Fahrenheit.


684
00:34:46,235 --> 00:34:48,626
The time is the string
interpolation


685
00:34:48,916 --> 00:34:51,755
of the actual time data
stored inside the object.


686
00:34:52,496 --> 00:34:54,896
And because it is
string interpolated


687
00:34:54,896 --> 00:34:57,766
and because we provided a custom
string convertible conformance,


688
00:34:58,386 --> 00:35:00,266
that will be automatically
picked up.


689
00:35:01,216 --> 00:35:04,496
One more thing worth
noticing here is


690
00:35:04,576 --> 00:35:08,246
that when I get both scales,
when I get both Centigrade


691
00:35:08,246 --> 00:35:10,596
and Fahrenheit for
my result printing,


692
00:35:11,106 --> 00:35:13,916
I don't change the value
stored inside the object.


693
00:35:13,976 --> 00:35:15,866
Of course, you say, you don't.


694
00:35:16,346 --> 00:35:20,036
Well, it is actually quite a
bit important to remember not


695
00:35:20,036 --> 00:35:21,416
to change the state
of your program


696
00:35:21,596 --> 00:35:23,296
by writing in-process
formatters.


697
00:35:24,066 --> 00:35:27,476
And now that we've done all this
work, now we've got all this,


698
00:35:28,666 --> 00:35:30,376
now how do we benefit?


699
00:35:31,726 --> 00:35:35,496
Well, we could try
po-ing that again.


700
00:35:35,686 --> 00:35:36,986
And here we go.


701
00:35:37,196 --> 00:35:38,526
And now I look at it again.


702
00:35:38,666 --> 00:35:39,586
I see my object.


703
00:35:39,636 --> 00:35:42,256
And I can look and I see now


704
00:35:42,256 --> 00:35:46,806
that at 6:30 p.m.
it was 93.2 degrees.


705
00:35:49,056 --> 00:35:51,396
Yup, in case you are
wondering, it was really hot


706
00:35:51,396 --> 00:35:52,456
in Cupertino yesterday.


707
00:35:53,746 --> 00:35:58,116
And now we did this work but
we did it because we were smart


708
00:35:58,186 --> 00:35:59,836
and we did the work
ahead of time.


709
00:36:00,516 --> 00:36:03,346
Sometimes I'm trying
to debug something


710
00:36:03,796 --> 00:36:07,076
and I got my program
just where I want it.


711
00:36:07,286 --> 00:36:09,806
I have got this one
hard-to-reproduce bug


712
00:36:10,006 --> 00:36:12,066
to finally happen.


713
00:36:12,326 --> 00:36:14,816
But now it is really
hard to look at the data.


714
00:36:15,316 --> 00:36:17,126
The data is confusing,
it's complicated.


715
00:36:17,286 --> 00:36:20,136
And I wish I had done
this work before,


716
00:36:20,436 --> 00:36:21,746
so that now I could
actually look


717
00:36:21,746 --> 00:36:23,146
at my data in much simpler ways.


718
00:36:24,066 --> 00:36:26,186
But alas I haven't.


719
00:36:26,186 --> 00:36:27,156
All hope is lost.


720
00:36:28,606 --> 00:36:30,266
Nope! No, it isn't!


721
00:36:30,706 --> 00:36:33,246
You can add conformances
and runtime, too.


722
00:36:33,246 --> 00:36:36,656
Through the expression parser
you can add these conformances


723
00:36:36,826 --> 00:36:39,126
and run while debugging
your app.


724
00:36:39,806 --> 00:36:43,156
On the other hand, you
cannot change them.


725
00:36:43,236 --> 00:36:45,186
Existing conformances stay.


726
00:36:45,186 --> 00:36:49,246
You are in the REPL,
you're experimenting.


727
00:36:50,016 --> 00:36:51,706
You really wish you
could po something.


728
00:36:52,166 --> 00:36:54,136
Oh, how I wish I could
add a conformance.


729
00:36:55,326 --> 00:36:56,786
You can do that in
the REPL as well.


730
00:36:57,166 --> 00:37:02,926
And, of course, but I'm sure
you all expect that, guess what?


731
00:37:04,086 --> 00:37:06,346
In playgrounds, too.


732
00:37:07,176 --> 00:37:11,106
Look at that!


733
00:37:11,306 --> 00:37:15,876
It seems to me that a lot
of this work that we've done


734
00:37:15,876 --> 00:37:18,086
over the last year in
debugger land that you've heard


735
00:37:18,086 --> 00:37:22,896
from Kate, from Sean, and from
me, has to do with making sure


736
00:37:22,896 --> 00:37:26,826
that it is really easy to access
as much of your information


737
00:37:26,826 --> 00:37:28,556
as possible while
you are debugging.


738
00:37:29,606 --> 00:37:33,596
Access to the Objective-C
runtime gives you more insight


739
00:37:33,666 --> 00:37:36,146
into fields that before
were unavailable to you.


740
00:37:36,426 --> 00:37:41,556
The SDK modules offer an
unprecedented level of access


741
00:37:41,606 --> 00:37:43,056
to the operating environment


742
00:37:43,056 --> 00:37:45,986
that your application is
running in, more types,


743
00:37:45,986 --> 00:37:48,086
more functions, even macros.


744
00:37:49,186 --> 00:37:51,156
And in-process formatting,


745
00:37:52,726 --> 00:37:55,016
in-process formatting
is a great way for you


746
00:37:55,016 --> 00:37:58,666
to create compelling
representations of your types,


747
00:37:59,126 --> 00:38:00,846
that apply across the board.


748
00:38:01,176 --> 00:38:03,696
They apply in the playgrounds,
they apply in the REPL,


749
00:38:03,816 --> 00:38:05,216
they apply in the debugger.


750
00:38:06,626 --> 00:38:09,656
For more information, of
course, do not hesitate


751
00:38:09,656 --> 00:38:12,216
to visit our website,
Swift language docs,


752
00:38:12,486 --> 00:38:15,776
or Developer Forums, of
course, the Labs, and Stefan,


753
00:38:15,776 --> 00:38:17,776
our Evangelist, is
but an email away.


754
00:38:19,376 --> 00:38:22,326
Thank you very much,
and have a great WWDC!


755
00:38:24,516 --> 00:38:36,190
[ Applause ]

