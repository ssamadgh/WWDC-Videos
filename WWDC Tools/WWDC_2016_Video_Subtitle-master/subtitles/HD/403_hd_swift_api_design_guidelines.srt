1
00:00:07,516 --> 00:00:19,500
[ Music ]


2
00:00:26,516 --> 00:00:29,966
[ Applause ]


3
00:00:30,466 --> 00:00:30,906
>> Thank you.


4
00:00:33,066 --> 00:00:35,016
Welcome. So, I'm Doug Gregor.


5
00:00:35,086 --> 00:00:37,316
I'm here with my
colleague Michael Ilseman


6
00:00:37,646 --> 00:00:38,686
to talk about design.


7
00:00:39,476 --> 00:00:42,386
Because good design
makes us more productive.


8
00:00:42,946 --> 00:00:46,806
And good API design helps
us write code that is clear,


9
00:00:47,056 --> 00:00:49,026
concise and beautiful in Swift.


10
00:00:49,106 --> 00:00:52,596
And that's every bit as true
whether you're writing your API


11
00:00:52,596 --> 00:00:55,016
for a million other
developers or just


12
00:00:55,016 --> 00:00:56,696
for yourself inside
your own app.


13
00:00:57,556 --> 00:00:59,106
Because good design
really does matter.


14
00:01:00,616 --> 00:01:03,236
So, we're going to be talking


15
00:01:03,236 --> 00:01:05,355
about the Swift API
Design Guidelines today.


16
00:01:05,726 --> 00:01:08,506
These are new guidelines we're
introducing with Swift 3.


17
00:01:09,296 --> 00:01:10,956
We're going to talk about
the philosophy behind


18
00:01:10,956 --> 00:01:11,776
these guidelines.


19
00:01:12,006 --> 00:01:14,356
Talk through some of them
to try to get a sense of how


20
00:01:14,356 --> 00:01:16,746
to build great Swift APIs.


21
00:01:18,376 --> 00:01:22,646
Now, then we're going to talk
about the Grand Renaming.


22
00:01:23,226 --> 00:01:25,216
Which is what we like
to call the application


23
00:01:25,216 --> 00:01:28,916
of these guidelines to all of
the APIs you use day to day.


24
00:01:29,316 --> 00:01:30,416
Swift Standard Library.


25
00:01:30,696 --> 00:01:32,966
Cocoa and Cocoa Touch APIs.


26
00:01:32,966 --> 00:01:34,146
Now, this Grand Renaming
is going


27
00:01:34,146 --> 00:01:36,216
to affect a lot of your code.


28
00:01:37,866 --> 00:01:39,066
Pretty much all the
code that you've written


29
00:01:39,066 --> 00:01:41,836
in Swift 2 is going to change
in some sense in Swift 3.


30
00:01:42,556 --> 00:01:42,966
>> Whooh!


31
00:01:43,366 --> 00:01:43,816
>> Yes!


32
00:01:44,516 --> 00:01:46,546
[ Applause ]


33
00:01:47,046 --> 00:01:48,796
So, we're going to talk through
what that means for your code.


34
00:01:49,816 --> 00:01:50,906
And how to deal with it.


35
00:01:50,906 --> 00:01:53,156
And starting thinking
in Swift 3.


36
00:01:54,186 --> 00:01:57,306
Finally, we're going to talk
about some new tools and tricks


37
00:01:57,306 --> 00:02:01,036
that we have for mapping
C and Objective-C APIs


38
00:02:01,246 --> 00:02:03,416
into beautiful Swift APIs.


39
00:02:03,416 --> 00:02:07,726
That's a whole lot
of what and how.


40
00:02:08,196 --> 00:02:10,265
The biggest question
you probably have


41
00:02:10,265 --> 00:02:12,836
about the guidelines is why?


42
00:02:14,686 --> 00:02:16,256
Why, after two years of working


43
00:02:16,256 --> 00:02:18,586
with Swift are we changing
all the APIs that you work


44
00:02:18,586 --> 00:02:19,856
with on a daily basis?


45
00:02:21,096 --> 00:02:24,116
And the answer comes down to
the character of the language.


46
00:02:24,176 --> 00:02:26,386
Because every programing
language has its own


47
00:02:26,386 --> 00:02:27,846
distinctive character.


48
00:02:28,186 --> 00:02:30,116
It has its own syntactic feel.


49
00:02:31,366 --> 00:02:33,386
But it's more than the syntax.


50
00:02:33,486 --> 00:02:35,416
It's also the kinds of tradeoffs


51
00:02:35,416 --> 00:02:37,206
that that language
decides to make.


52
00:02:37,366 --> 00:02:40,316
Does it skew toward
safety, performance?


53
00:02:40,316 --> 00:02:43,666
Do you care about some
mathematical terseness


54
00:02:43,716 --> 00:02:46,426
or something that is
clear and easy to read?


55
00:02:46,426 --> 00:02:51,596
You take a look at Swift code,
and it's instantly recognizable.


56
00:02:51,876 --> 00:02:55,806
And you can see Swift
rendering an opinion


57
00:02:55,806 --> 00:02:56,976
about certain things here.


58
00:02:56,976 --> 00:02:58,736
It uses trailing closures.


59
00:02:59,016 --> 00:03:00,306
So the control flow works


60
00:03:00,306 --> 00:03:02,696
with your libraries
and your APIs nicely.


61
00:03:03,276 --> 00:03:04,816
It has optionals, so you have


62
00:03:04,876 --> 00:03:07,166
to consider the possibility
of nil everywhere.


63
00:03:07,166 --> 00:03:10,986
You can't just ignore that
this possibility exists.


64
00:03:11,356 --> 00:03:15,106
And so, when you're working
with Swift it feels like Swift.


65
00:03:15,776 --> 00:03:18,266
But it's not just the
language contributing to it.


66
00:03:18,266 --> 00:03:21,316
It's really the APIs you
use day in and day out.


67
00:03:21,676 --> 00:03:25,246
And these APIs have to meld with
the character of the language.


68
00:03:25,556 --> 00:03:28,046
So you get a consistent,
whole experience of working


69
00:03:28,046 --> 00:03:29,426
with beautiful Swift code.


70
00:03:31,276 --> 00:03:34,776
Now, these are some Cocoa
and Cocoa Touch APIs.


71
00:03:35,706 --> 00:03:38,596
And these APIs were
designed based


72
00:03:38,596 --> 00:03:40,216
on the coding guidelines
for Cocoa.


73
00:03:41,336 --> 00:03:42,356
You may have read these before.


74
00:03:42,356 --> 00:03:43,146
I hope you have.


75
00:03:43,666 --> 00:03:46,896
They espouse clarity
and consistency


76
00:03:47,436 --> 00:03:48,536
in the design of APIs.


77
00:03:48,536 --> 00:03:53,326
And we've been applying these to
thousands upon thousands of APIs


78
00:03:53,326 --> 00:03:56,476
over more than a decade, all
right, to produce the Cocoa


79
00:03:56,476 --> 00:03:57,776
and Cocoa Touch platforms.


80
00:03:57,776 --> 00:03:59,246
And these wonderful APIs we use.


81
00:03:59,876 --> 00:04:02,096
Now, these guidelines
were designed


82
00:04:02,706 --> 00:04:07,076
for a different language
with a different character.


83
00:04:08,356 --> 00:04:12,026
And so, when you bring all of
these APIs that were written


84
00:04:12,026 --> 00:04:15,426
for Objective-C into
Swift unmodified,


85
00:04:16,375 --> 00:04:18,796
they seemed a little
bit out of character.


86
00:04:18,796 --> 00:04:20,995
They feel a bit not-Swifty.


87
00:04:22,506 --> 00:04:23,496
What's that even mean?


88
00:04:24,236 --> 00:04:25,216
Not Swifty?


89
00:04:26,206 --> 00:04:26,856
You hear it a lot.


90
00:04:27,886 --> 00:04:32,386
But in essence, this is why
two years in to having Swift


91
00:04:32,386 --> 00:04:35,076
as a platform that
many thousands


92
00:04:35,076 --> 00:04:38,246
of developers are using, is
the right time to reevaluate.


93
00:04:38,846 --> 00:04:41,646
Because we have experience
from a much larger community


94
00:04:41,646 --> 00:04:44,506
to understand what works
well in Swift code.


95
00:04:45,456 --> 00:04:50,916
And so we set off to design the
API Design Guidelines to try


96
00:04:50,916 --> 00:04:53,386
to codify what it is
to build a Swifty API


97
00:04:53,386 --> 00:04:57,186
and help everyone build more
consistent, more clear APIs


98
00:04:57,186 --> 00:04:58,526
within this language
that we love.


99
00:05:00,476 --> 00:05:03,826
Now, in the lower
left you see SE-0023.


100
00:05:04,136 --> 00:05:06,146
That's the Swift
evolution proposal number


101
00:05:06,146 --> 00:05:09,426
that contains all of the
API Design Guidelines.


102
00:05:09,706 --> 00:05:11,716
You'll see these proposal
numbers throughout the talk.


103
00:05:12,336 --> 00:05:14,006
Again, you can go
look at Swift.org,


104
00:05:14,136 --> 00:05:16,456
look up this proposal number
to see more information


105
00:05:16,496 --> 00:05:20,066
about that particular change
to the Swift language.


106
00:05:20,676 --> 00:05:23,196
But for now, let's talk about
the guidelines themselves.


107
00:05:24,576 --> 00:05:28,376
The main principles of the
Swift API design guidelines are


108
00:05:28,376 --> 00:05:31,026
clarity at the point of use.


109
00:05:31,096 --> 00:05:34,146
Where your API shows up
in someone else's code.


110
00:05:36,306 --> 00:05:38,156
And we love concise code.


111
00:05:38,236 --> 00:05:41,026
But the clarity is the
most important aspect.


112
00:05:41,026 --> 00:05:43,326
It's more important
than having brief code.


113
00:05:44,486 --> 00:05:47,086
That said, concise code
does happen in Swift.


114
00:05:47,366 --> 00:05:49,426
Swift code does tend
to be more concise.


115
00:05:49,476 --> 00:05:50,896
We can feel it when we
look at the language.


116
00:05:50,896 --> 00:05:53,486
And we see it in actual
metrics when we talk about apps


117
00:05:53,486 --> 00:05:56,876
that have been ported into
Swift and written in Swift.


118
00:05:56,876 --> 00:06:00,486
But that comes from using
the right contextual cues.


119
00:06:01,046 --> 00:06:03,046
Let's dive into these
principles a little bit more


120
00:06:03,046 --> 00:06:04,286
and look at some APIs.


121
00:06:05,216 --> 00:06:07,656
So, we're going to
talk about usage first.


122
00:06:09,366 --> 00:06:10,966
So why focus on the use sites?


123
00:06:11,236 --> 00:06:13,236
Well, for one, it's just
a simple numbers game.


124
00:06:13,236 --> 00:06:15,046
You're going to write
your API once.


125
00:06:15,636 --> 00:06:18,506
People will look at that
API in code, or maybe look


126
00:06:18,506 --> 00:06:21,036
at the documentation for
it a couple of times.


127
00:06:21,556 --> 00:06:25,096
But the vast majority of
times that your API matters,


128
00:06:25,096 --> 00:06:28,646
the number of times it's seen,
it's going to be in the context


129
00:06:28,956 --> 00:06:30,336
of a whole lot of other code.


130
00:06:30,836 --> 00:06:33,716
And when you're in that
context, you have all


131
00:06:33,716 --> 00:06:35,866
of this extra rich
contextual information.


132
00:06:36,496 --> 00:06:40,606
You have the local variables,
their names, their types.


133
00:06:41,316 --> 00:06:43,416
You have uses of related APIs.


134
00:06:43,466 --> 00:06:45,266
And so the goal of
your API isn't


135
00:06:45,266 --> 00:06:46,906
to stand up and say, "Hello!


136
00:06:46,906 --> 00:06:48,786
I'm here and I have
a nice big name."


137
00:06:49,586 --> 00:06:52,876
The goal of your API is to fit
in with the rest of the code


138
00:06:53,186 --> 00:06:54,896
so that the end result
is beautiful.


139
00:06:55,506 --> 00:06:59,696
Now, when you're focusing on
use cases, resist the temptation


140
00:07:00,456 --> 00:07:02,136
to optimize for bad code.


141
00:07:03,346 --> 00:07:05,906
It is absolutely true that
someone can go and use names


142
00:07:05,906 --> 00:07:08,476
like A and B and C
for all the variables.


143
00:07:08,766 --> 00:07:10,816
And this code is
not clear anymore.


144
00:07:11,416 --> 00:07:16,666
You can't fix this bad
code with your API alone.


145
00:07:18,086 --> 00:07:21,756
All you can do is make other
code more verbose or less clear.


146
00:07:22,986 --> 00:07:25,416
So focus on proper use cases.


147
00:07:25,416 --> 00:07:28,666
Focus on the beautiful code
and tune your API for that.


148
00:07:29,876 --> 00:07:32,296
Let's actually look at
a specific example here.


149
00:07:32,576 --> 00:07:34,236
And so we're going
to start with an API


150
00:07:34,436 --> 00:07:37,236
that is removing an
item from a collection.


151
00:07:37,706 --> 00:07:40,196
We're going to start by
calling it removeItem.


152
00:07:40,976 --> 00:07:41,836
Sounds good.


153
00:07:41,836 --> 00:07:43,706
But I've made my first mistake.


154
00:07:43,856 --> 00:07:45,546
This is not a use case.


155
00:07:45,616 --> 00:07:47,456
This is just a name
in the abstract.


156
00:07:48,006 --> 00:07:51,006
So, let's bring up a use case
that I have in mind today.


157
00:07:51,746 --> 00:07:52,416
Don't ask why.


158
00:07:52,706 --> 00:07:56,946
He knows. So, remove item
ted from the list of friends.


159
00:07:57,906 --> 00:08:00,596
Now, you'll notice that
there's actually two things


160
00:08:00,596 --> 00:08:02,216
in this use case
that are referring


161
00:08:02,216 --> 00:08:03,676
to what the argument is.


162
00:08:03,676 --> 00:08:05,146
They're trying to
describe the argument.


163
00:08:05,636 --> 00:08:07,786
There's the word item
that's part of our name.


164
00:08:07,786 --> 00:08:10,326
And then there's
the argument ted


165
00:08:10,416 --> 00:08:12,096
which is some local
variable with a type.


166
00:08:12,976 --> 00:08:18,586
Of these two, the variable ted
is the actual better descriptor


167
00:08:18,586 --> 00:08:19,546
of what the argument is.


168
00:08:19,976 --> 00:08:21,086
It's in context.


169
00:08:21,206 --> 00:08:23,516
As you're reading this call
in context, you know what


170
00:08:23,516 --> 00:08:24,556
that local variable is.


171
00:08:24,556 --> 00:08:25,456
It means something.


172
00:08:25,456 --> 00:08:27,826
It has a strong type.


173
00:08:28,016 --> 00:08:29,806
So maybe the problem
here is really


174
00:08:30,246 --> 00:08:33,285
that the word item isn't
sufficiently descriptive.


175
00:08:33,785 --> 00:08:35,366
Maybe we'd feel a little
bit more comfortable


176
00:08:35,366 --> 00:08:36,626
if it were called removeObject.


177
00:08:38,126 --> 00:08:39,635
Well, that's probably not right,


178
00:08:39,635 --> 00:08:41,876
because we're probably using
value types here anyway.


179
00:08:41,876 --> 00:08:43,655
So it's just actively wrong.


180
00:08:44,066 --> 00:08:46,016
We could say, hmm,
removeElement.


181
00:08:46,906 --> 00:08:49,686
Okay. Collections in Swift
use the term element.


182
00:08:50,686 --> 00:08:52,886
But, it's not helping us any.


183
00:08:53,716 --> 00:08:55,226
And moreover, if we
were to start writing


184
00:08:55,226 --> 00:08:56,656
down different use cases,


185
00:08:56,906 --> 00:08:59,326
it might actually
become less clear.


186
00:09:00,426 --> 00:09:02,066
Here I want to remove
element caffeine


187
00:09:02,066 --> 00:09:03,666
from a list of organic
compounds.


188
00:09:04,486 --> 00:09:05,186
That's misleading.


189
00:09:05,186 --> 00:09:05,836
It's wrong.


190
00:09:05,836 --> 00:09:07,006
Caffeine is not an element.


191
00:09:07,006 --> 00:09:09,086
It's a compound made
up of elements.


192
00:09:09,626 --> 00:09:12,166
So, our attempt at using
some innocuous word here


193
00:09:12,166 --> 00:09:14,626
to describe the argument
has actually led us


194
00:09:14,626 --> 00:09:16,606
to less clear use cases.


195
00:09:17,966 --> 00:09:22,406
Okay. So maybe the problem
is that we should stop trying


196
00:09:22,406 --> 00:09:24,726
to get these innocuous sort
of general words in there


197
00:09:24,726 --> 00:09:25,926
and we should be
really specific.


198
00:09:26,506 --> 00:09:28,836
Remove person ted from
the list of friends.


199
00:09:29,416 --> 00:09:31,866
It's a little awkward
in English.


200
00:09:32,616 --> 00:09:33,276
I wouldn't say that.


201
00:09:33,276 --> 00:09:34,206
I would just say, remove(ted).


202
00:09:35,056 --> 00:09:40,006
But moreover, if I do this, if
I try to get really specific


203
00:09:40,616 --> 00:09:43,716
for this generic API,
well now I expect


204
00:09:43,716 --> 00:09:44,976
to be specific everywhere.


205
00:09:45,076 --> 00:09:49,016
And now there's one conceptual
API of just removing an item


206
00:09:49,016 --> 00:09:51,616
from a collection has
different names throughout the


207
00:09:51,616 --> 00:09:52,476
source base.


208
00:09:53,766 --> 00:09:55,366
That makes it harder
to understand.


209
00:09:55,366 --> 00:09:57,076
It's harder to recognize
that actually we're talking


210
00:09:57,076 --> 00:09:59,296
about the same thing
in different contexts.


211
00:09:59,756 --> 00:10:04,976
So, the Swift API Design
Guidelines go a different route.


212
00:10:05,246 --> 00:10:07,336
Omit needless words.


213
00:10:09,036 --> 00:10:12,396
If a word is not
contributing to the clarity


214
00:10:12,396 --> 00:10:14,326
of the use site,
don't put it in.


215
00:10:15,116 --> 00:10:17,096
So we can just say, remove(ted)
from the list of friends.


216
00:10:17,096 --> 00:10:18,116
It reads really nicely.


217
00:10:18,936 --> 00:10:22,926
Now, one of the reasons this
works so beautifully in Swift is


218
00:10:22,926 --> 00:10:28,186
that it has a strong static
type system to make sure


219
00:10:28,276 --> 00:10:30,936
that you don't write
nonsensical code and again,


220
00:10:30,936 --> 00:10:32,086
interpret it in the wrong way.


221
00:10:32,416 --> 00:10:35,216
And so the strong static
type system is making sure


222
00:10:35,406 --> 00:10:38,466
that the argument you passed
to remove is an element


223
00:10:38,466 --> 00:10:40,086
of the corresponding collection.


224
00:10:41,396 --> 00:10:43,906
If you were to do
something truly inadvisable,


225
00:10:44,036 --> 00:10:47,166
like for example, try to
remove caffeine from your list


226
00:10:47,166 --> 00:10:49,746
of friends, you're going
to get an error message


227
00:10:49,746 --> 00:10:54,016
from the compiler telling you
that that doesn't make sense.


228
00:10:54,676 --> 00:10:58,256
So, we've talked about
readability of the use sites.


229
00:10:59,436 --> 00:11:03,136
And we've eliminated a bunch
of words, which might put you


230
00:11:03,136 --> 00:11:05,096
in the mind that what we're
looking for is terse code.


231
00:11:06,136 --> 00:11:06,756
That's not true.


232
00:11:06,756 --> 00:11:07,846
We want clear code.


233
00:11:08,816 --> 00:11:13,816
But, clear code has to hit
the correct point in this sort


234
00:11:13,816 --> 00:11:16,086
of spectrum of terseness
to verbosity.


235
00:11:16,506 --> 00:11:20,426
And if you think about what is
verbose code, verbose code is


236
00:11:20,426 --> 00:11:23,586
when you have extra information
in there that you don't need.


237
00:11:25,146 --> 00:11:27,656
And verbose code
actually hurts clarity.


238
00:11:27,926 --> 00:11:30,146
Because what is your mind
doing as you're reading


239
00:11:30,146 --> 00:11:31,496
through this verbose code?


240
00:11:32,246 --> 00:11:35,476
It's trying to filter out
all of this extra noise,


241
00:11:35,656 --> 00:11:37,676
all the things you don't need
because they're redundant,


242
00:11:37,906 --> 00:11:39,526
to find the actual
signal in there.


243
00:11:40,996 --> 00:11:43,196
Now, the other end of the
spectrum is also not good.


244
00:11:43,196 --> 00:11:44,846
If you have code
that is too terse,


245
00:11:45,206 --> 00:11:48,346
then you're missing critical
information that you need


246
00:11:48,346 --> 00:11:50,106
to understand that code.


247
00:11:51,416 --> 00:11:53,056
A sign that this is happening,


248
00:11:53,056 --> 00:11:54,676
that you've made
things too terse,


249
00:11:54,776 --> 00:11:57,426
is when you're reading code
and you find yourself jumping


250
00:11:57,426 --> 00:11:59,516
to the API documentation
all the time


251
00:11:59,766 --> 00:12:02,656
because the APIs themselves
are insufficiently descriptive.


252
00:12:03,246 --> 00:12:06,156
So we're looking for this
sort sweet spot in the middle


253
00:12:06,516 --> 00:12:11,076
where you get clear
code that is concise.


254
00:12:11,366 --> 00:12:14,066
So all of the information you
need to understand those APIs


255
00:12:14,066 --> 00:12:17,656
and how they work is there in
the contextual information.


256
00:12:18,556 --> 00:12:21,196
This is actually a principle
of the Swift language itself.


257
00:12:21,196 --> 00:12:23,126
So I'm going to put up
a bunch of code here.


258
00:12:24,606 --> 00:12:29,306
And in this bunch of code we
actually have verbosity that's


259
00:12:29,306 --> 00:12:30,516
not needed in Swift.


260
00:12:30,876 --> 00:12:34,156
That verbosity is all of these
explicit type annotations.


261
00:12:34,926 --> 00:12:36,956
These aren't adding
to readability.


262
00:12:38,016 --> 00:12:39,676
You can get a sense of
what the types are just


263
00:12:39,676 --> 00:12:41,096
by reading the APIs.


264
00:12:41,146 --> 00:12:43,726
And indeed, in Swift you
probably wouldn't write the code


265
00:12:43,726 --> 00:12:44,236
this way.


266
00:12:44,436 --> 00:12:46,956
You would probably align
that type information


267
00:12:46,956 --> 00:12:48,926
and let the static type
trebicore [phonetic] do it


268
00:12:49,026 --> 00:12:51,236
for you leading to
more concise code


269
00:12:51,406 --> 00:12:53,276
that you can still read
through just as well.


270
00:12:53,406 --> 00:12:56,316
Now of course, types
are important.


271
00:12:56,316 --> 00:12:57,396
And the types are there.


272
00:12:57,786 --> 00:13:00,356
And if you need reassurance
about what a particular type is,


273
00:13:00,356 --> 00:13:02,116
if it'd help your
understanding, of course,


274
00:13:02,116 --> 00:13:05,166
the answer is just an option
click away inside Xcode.


275
00:13:06,816 --> 00:13:10,306
So let's look at another
API and try to talk


276
00:13:10,306 --> 00:13:13,666
about when a word
actually is needed


277
00:13:13,926 --> 00:13:15,816
to help describe an argument.


278
00:13:16,866 --> 00:13:19,726
We'll take this little API
here that adds a child view


279
00:13:20,326 --> 00:13:23,536
at some particular point
within some main view.


280
00:13:24,156 --> 00:13:25,446
And so we write out a use case.


281
00:13:25,616 --> 00:13:26,786
Always start with the use case.


282
00:13:27,116 --> 00:13:29,286
And think about the words
that apply to the arguments.


283
00:13:29,626 --> 00:13:32,796
So in the first case we have
the word child is applying


284
00:13:32,796 --> 00:13:35,326
to this view argument that
is our first argument.


285
00:13:36,126 --> 00:13:37,576
Is child adding something?


286
00:13:38,116 --> 00:13:39,646
Well, we know from
the static type system


287
00:13:39,646 --> 00:13:42,426
that sidebar is going to
be a view of some sort.


288
00:13:42,906 --> 00:13:47,556
But this word child
is clarifying the role


289
00:13:47,556 --> 00:13:49,466
of this parameter
in the operation.


290
00:13:49,516 --> 00:13:53,276
It's stating that this argument
here will become a child.


291
00:13:53,276 --> 00:13:54,826
It's establishing hierarchy.


292
00:13:55,296 --> 00:13:56,756
That's really important
information


293
00:13:56,756 --> 00:14:02,146
for understanding
what this API does.


294
00:14:02,636 --> 00:14:07,426
Now, in the second argument, we
have atPoint and then origin.


295
00:14:07,746 --> 00:14:08,946
What's origin going to be?


296
00:14:08,946 --> 00:14:10,546
Well, it's going
to be a CGPoint.


297
00:14:10,836 --> 00:14:12,526
This API is going
to take CGPoints.


298
00:14:12,526 --> 00:14:14,966
And you can't provide anything
other than a CGPoint here.


299
00:14:16,946 --> 00:14:19,046
So this word, it's
not adding anything.


300
00:14:19,046 --> 00:14:21,416
It's just restating
information that's already


301
00:14:21,446 --> 00:14:24,476
in the strong static type
system that will be enforced


302
00:14:24,586 --> 00:14:26,246
by the Swift language.


303
00:14:26,836 --> 00:14:27,516
So take it away.


304
00:14:27,586 --> 00:14:28,356
You don't need it.


305
00:14:29,016 --> 00:14:30,826
And now notice what the
call site looks like here.


306
00:14:30,826 --> 00:14:35,046
If we read it out, you add the
child sidebar at the origin.


307
00:14:36,456 --> 00:14:37,456
It reads grammatically.


308
00:14:38,156 --> 00:14:38,396
All right?


309
00:14:38,856 --> 00:14:39,926
This is one of the principles


310
00:14:39,926 --> 00:14:43,826
of this particular API
Design Guidelines is


311
00:14:43,826 --> 00:14:47,026
that we really want the use
sites to read grammatically.


312
00:14:47,686 --> 00:14:49,856
And we had this for our
example here of remove(ted)


313
00:14:50,736 --> 00:14:51,736
from our list of friends.


314
00:14:52,576 --> 00:14:54,486
Now, let's look at
a very related API.


315
00:14:54,486 --> 00:14:57,726
So this is removing
specifically some element.


316
00:14:58,186 --> 00:15:00,966
If we look at, say, the
API that removed something


317
00:15:00,966 --> 00:15:01,886
in a particular position.


318
00:15:02,146 --> 00:15:02,666
Read it out.


319
00:15:03,196 --> 00:15:06,806
Remove position of former
friend from the collection.


320
00:15:07,226 --> 00:15:07,836
It's not right.


321
00:15:08,276 --> 00:15:10,496
This isn't the collection
of positions.


322
00:15:10,846 --> 00:15:12,176
This is a collection of people.


323
00:15:13,576 --> 00:15:18,926
To actually make this read
well we want to say, remove at.


324
00:15:19,476 --> 00:15:23,456
Let's read this out remove at
the position of former friend.


325
00:15:23,996 --> 00:15:29,436
Notice how we've clarified the
behavior of the API by putting


326
00:15:29,436 --> 00:15:32,076
in this first argument label
to describe the relationship


327
00:15:32,076 --> 00:15:34,796
of the argument to the method.


328
00:15:36,796 --> 00:15:39,416
This brings us to naming
and the idea of naming.


329
00:15:39,656 --> 00:15:43,266
So, in Swift, a function
name is comprised


330
00:15:43,266 --> 00:15:46,226
of so-called base name,
which here is remove in both


331
00:15:46,226 --> 00:15:48,586
of these APIs, as well as all


332
00:15:48,586 --> 00:15:51,496
of the argument labels
for the arguments.


333
00:15:51,546 --> 00:15:55,116
And so these two related APIs,
they share the same base name


334
00:15:55,116 --> 00:15:57,776
of remove because they're in
this method family of operations


335
00:15:57,776 --> 00:15:59,366
that remove something
from a collection.


336
00:15:59,846 --> 00:16:01,556
But their argument
labels are different


337
00:16:02,316 --> 00:16:04,366
because they do different
things.


338
00:16:04,436 --> 00:16:07,356
One removes an element
by its identity.


339
00:16:07,686 --> 00:16:10,016
The other one removes
its element based


340
00:16:10,016 --> 00:16:11,796
on its position in the sequence.


341
00:16:12,656 --> 00:16:15,076
So slightly different
APIs have different names.


342
00:16:15,486 --> 00:16:19,426
Now, you can overload
based on type information.


343
00:16:19,636 --> 00:16:22,686
And if two APIs that share
the same compound name.


344
00:16:23,216 --> 00:16:24,856
But you should only do this


345
00:16:25,336 --> 00:16:28,206
when the APIs have
the same semantics.


346
00:16:28,586 --> 00:16:30,616
So it's fine to overload
the append name


347
00:16:30,616 --> 00:16:33,056
with no argument label
here to append a character


348
00:16:33,056 --> 00:16:34,296
or a string to some text.


349
00:16:34,596 --> 00:16:36,726
Because fundamentally these
are the same operation.


350
00:16:37,026 --> 00:16:40,876
They're just overloaded on
different types for convenience.


351
00:16:41,276 --> 00:16:43,696
Now, when you're coming up with
first argument labels, again,


352
00:16:43,806 --> 00:16:47,666
you want that use case
to read grammatically.


353
00:16:47,716 --> 00:16:50,586
And that includes the base
name of the method as well


354
00:16:50,586 --> 00:16:51,676
as the argument label.


355
00:16:52,216 --> 00:16:55,956
So my first API here
removeBoxes (withLabel:WWDC).


356
00:16:57,206 --> 00:16:58,306
Notice how that reads well.


357
00:16:58,676 --> 00:17:02,676
Now, inside that API we
have a prepositional phrase.


358
00:17:02,676 --> 00:17:04,626
So it's a little bit of
English grammar here.


359
00:17:04,626 --> 00:17:06,226
But essentially it's withLabel.


360
00:17:06,455 --> 00:17:09,596
And it describes the
relationship of the argument


361
00:17:10,156 --> 00:17:12,705
to the actual operation
of removing boxes.


362
00:17:12,766 --> 00:17:14,636
And so when you have one of
these prepositional phrases,


363
00:17:14,886 --> 00:17:16,106
put it on the first
argument label


364
00:17:16,106 --> 00:17:17,586
to describe the first argument.


365
00:17:19,616 --> 00:17:21,336
You also use first
argument labels


366
00:17:21,406 --> 00:17:23,766
if you essentially can't
form a grammatical phrase


367
00:17:23,955 --> 00:17:25,215
because it would be misleading


368
00:17:25,336 --> 00:17:26,675
to have the first
argument in there.


369
00:17:27,056 --> 00:17:28,486
And so here we have
a viewController.


370
00:17:28,486 --> 00:17:29,716
And we say dismiss(true).


371
00:17:29,716 --> 00:17:32,186
What is that?


372
00:17:32,186 --> 00:17:34,536
I can't banish a Boolean
constant to anywhere.


373
00:17:35,956 --> 00:17:38,166
And so to make this
read grammatically,


374
00:17:38,406 --> 00:17:39,886
I need to put an
argument label in there.


375
00:17:40,656 --> 00:17:41,756
Dismiss the viewController.


376
00:17:42,346 --> 00:17:43,186
And it's animated.


377
00:17:43,186 --> 00:17:44,076
Animated is true.


378
00:17:44,266 --> 00:17:46,276
And so this is extra
information that's coming along.


379
00:17:46,546 --> 00:17:50,376
The first argument label breaks
it up so that it reads well


380
00:17:50,686 --> 00:17:53,806
and it's clear that what
we're dismissing is the actual


381
00:17:53,806 --> 00:17:54,516
view controller.


382
00:17:55,446 --> 00:17:56,876
There are a couple of
other rules you can read


383
00:17:56,876 --> 00:17:57,906
about on Swift.org.


384
00:17:58,286 --> 00:18:01,646
But essentially you still will
omit first argument labels


385
00:18:01,646 --> 00:18:02,516
in some cases.


386
00:18:02,756 --> 00:18:06,056
And these are cases where
in the API it reads well


387
00:18:06,056 --> 00:18:08,546
to just have the argument
there, insert michael


388
00:18:08,866 --> 00:18:10,496
at the start index of friends.


389
00:18:11,656 --> 00:18:12,266
That reads well.


390
00:18:12,266 --> 00:18:14,846
We don't need a first argument
label to make it read well,


391
00:18:14,846 --> 00:18:16,326
and so we leave it out.


392
00:18:17,346 --> 00:18:21,406
Okay. Let's talk
a little bit more


393
00:18:21,406 --> 00:18:22,746
about naming before we move on.


394
00:18:23,506 --> 00:18:27,746
So, when you name a method, name
it based on its side effects.


395
00:18:28,016 --> 00:18:31,086
So, use English verbs, commands,


396
00:18:31,086 --> 00:18:33,876
to tell the receiver
do something.


397
00:18:34,866 --> 00:18:37,236
So here we might say, okay, we
have the friends collection.


398
00:18:37,456 --> 00:18:37,976
Reverse it.


399
00:18:38,246 --> 00:18:39,806
A viewController, present it.


400
00:18:40,146 --> 00:18:41,906
Organic compounds, append to it.


401
00:18:42,646 --> 00:18:44,256
Right? These are actions taken.


402
00:18:44,526 --> 00:18:46,136
We name based on
the actions taken.


403
00:18:46,856 --> 00:18:50,546
Now, when we have methods whose
primary responsibility is just


404
00:18:50,676 --> 00:18:55,916
to return some value
we use a noun.


405
00:18:56,036 --> 00:18:58,896
Describe the thing
that is being returned.


406
00:18:59,446 --> 00:19:02,156
And so here we can ask for the
background title of a button


407
00:19:02,246 --> 00:19:06,046
or the suffix of
this friends array.


408
00:19:07,226 --> 00:19:09,266
Now, when you're
dealing with value types,


409
00:19:10,636 --> 00:19:12,876
it's sometimes the case that
you have both a mutating


410
00:19:12,876 --> 00:19:16,116
and a non-mutating form of
essentially the same operation.


411
00:19:16,456 --> 00:19:17,746
And here what we like to call --


412
00:19:17,746 --> 00:19:20,206
we apply what we like
to call the ed/ing rule.


413
00:19:21,356 --> 00:19:24,646
And so this follows
from English grammar.


414
00:19:24,646 --> 00:19:27,286
And essentially you
start with the verb form.


415
00:19:27,466 --> 00:19:29,686
And so here we have
reverse a collection.


416
00:19:29,686 --> 00:19:31,916
You're commanding X
to reverse itself.


417
00:19:33,566 --> 00:19:36,276
Now, for the more
noun-like other form,


418
00:19:36,466 --> 00:19:37,516
we use the "ed" rule.


419
00:19:37,666 --> 00:19:39,996
So we ask for X reversed.


420
00:19:39,996 --> 00:19:40,616
All right?


421
00:19:40,616 --> 00:19:43,296
Where we're describing what the
result is that we want to get.


422
00:19:43,296 --> 00:19:45,436
And that corresponds
to the mutating form.


423
00:19:46,296 --> 00:19:47,786
Now, when the "ed"
rule doesn't apply,


424
00:19:47,786 --> 00:19:49,606
the "ing" rule generally does.


425
00:19:50,366 --> 00:19:52,266
This is usually when we
have an argument here.


426
00:19:52,566 --> 00:19:53,826
So we have a document directory.


427
00:19:53,906 --> 00:19:55,496
We can append a path
component to it.


428
00:19:55,956 --> 00:19:56,726
That's mutating.


429
00:19:56,726 --> 00:19:58,296
We told it to append this.


430
00:19:59,356 --> 00:20:00,726
Now we have the non-mutating
form.


431
00:20:00,796 --> 00:20:03,616
Give me the document directory
appending this particular


432
00:20:03,616 --> 00:20:04,216
path component.


433
00:20:05,756 --> 00:20:10,886
So these rules, and many, many
more, are described on Swift.org


434
00:20:10,886 --> 00:20:12,896
as part of the API Design
Guidelines document.


435
00:20:13,386 --> 00:20:15,896
Highly recommend that
you read them and try


436
00:20:15,896 --> 00:20:17,566
to apply them to your own APIs.


437
00:20:18,406 --> 00:20:20,966
But of course, these guidelines,


438
00:20:21,386 --> 00:20:23,466
they're not interesting
unless they actually are


439
00:20:23,466 --> 00:20:24,406
widely applied.


440
00:20:25,106 --> 00:20:28,156
And this is why we set
off on the Grand Renaming.


441
00:20:28,796 --> 00:20:31,786
Which is the application
of these guidelines


442
00:20:32,246 --> 00:20:35,246
to the Swift Standard
Library, to the Cocoa


443
00:20:35,246 --> 00:20:39,986
and Cocoa Touch APIs as well as
targeted improvements to APIs


444
00:20:39,986 --> 00:20:41,976
like Core Graphics,
Grand Central Dispatch.


445
00:20:41,976 --> 00:20:45,766
They're used all the time to
give them these Swifty makeovers


446
00:20:45,766 --> 00:20:46,876
to be beautiful in Swift.


447
00:20:48,566 --> 00:20:50,866
I talked a little bit about the
scale of the Grand Renaming.


448
00:20:51,006 --> 00:20:53,206
So, this is a little screen shot


449
00:20:53,786 --> 00:20:56,536
of a small Swift app called
Lister we've been shipping


450
00:20:56,536 --> 00:20:57,406
for a couple years.


451
00:20:57,466 --> 00:20:58,816
It's one of the sample
applications


452
00:20:59,646 --> 00:21:02,196
when it's being migrated
from Swift 2 to Swift 3.


453
00:21:03,066 --> 00:21:05,496
You can notice there's a whole
lot of .swift files on the left.


454
00:21:06,546 --> 00:21:09,846
Basically every Swift file in
the entire project is changed


455
00:21:09,846 --> 00:21:12,016
by the transition from
Swift 2 to Swift 3.


456
00:21:13,056 --> 00:21:15,416
And if you're looking at some
of the details in the middle


457
00:21:15,416 --> 00:21:18,546
and the right panes here,
you probably noticed that all


458
00:21:18,546 --> 00:21:21,066
of these Cocoa API
names have changed.


459
00:21:22,246 --> 00:21:25,146
Okay? So, there's a
lot of change here.


460
00:21:25,146 --> 00:21:26,016
We'll talk about that.


461
00:21:26,436 --> 00:21:28,336
But really what's interesting is


462
00:21:28,336 --> 00:21:30,516
that these Cocoa APIs
you may have been using


463
00:21:30,516 --> 00:21:33,556
for a very long time,
the APIs are the same,


464
00:21:33,556 --> 00:21:36,856
but now a given API has
two different names.


465
00:21:37,716 --> 00:21:40,006
Has one name that's
appropriate for Objective-C


466
00:21:40,776 --> 00:21:42,976
and one name that's
appropriate for Swift.


467
00:21:43,116 --> 00:21:48,746
As a Swift programmer, most of
the time you don't need to care.


468
00:21:49,316 --> 00:21:52,146
You can entirely work
within the Swift names.


469
00:21:52,486 --> 00:21:54,566
Use your generated
interfaces, the documentation,


470
00:21:54,566 --> 00:21:55,776
everything will show
you the Swift names.


471
00:21:55,776 --> 00:21:56,716
And that's all you'll deal with.


472
00:21:57,376 --> 00:21:59,096
However, there are times
when you're interacting


473
00:21:59,096 --> 00:22:01,396
with the system where
you actually do need the


474
00:22:01,396 --> 00:22:02,246
Objective-C name.


475
00:22:02,246 --> 00:22:04,276
For example, if you're
wiring up target action.


476
00:22:04,886 --> 00:22:06,606
And so, here we actually need


477
00:22:06,606 --> 00:22:08,866
to provide a selector
to target action.


478
00:22:09,106 --> 00:22:10,446
And we have this string literal.


479
00:22:11,426 --> 00:22:12,246
What do we write here?


480
00:22:12,856 --> 00:22:14,236
I don't know.


481
00:22:14,426 --> 00:22:15,836
You can look at the
generated interface.


482
00:22:16,376 --> 00:22:19,116
Maybe ask your Swift compiler
friends on Twitter or something.


483
00:22:19,586 --> 00:22:20,586
You can come up with the answer.


484
00:22:20,716 --> 00:22:21,126
That's fine.


485
00:22:21,746 --> 00:22:23,466
But, please don't do this.


486
00:22:24,346 --> 00:22:26,636
Because this is a
really, really weak link


487
00:22:27,216 --> 00:22:29,886
between this string literal,
which is super easy to mistype,


488
00:22:30,296 --> 00:22:32,706
and the method above that
you actually meant to call.


489
00:22:33,366 --> 00:22:37,126
This is why in Swift 2.2
we introduced #selector.


490
00:22:38,306 --> 00:22:39,686
#selector is a very
simple thing.


491
00:22:39,686 --> 00:22:40,806
It's an expression.


492
00:22:41,216 --> 00:22:44,006
It takes in the name
of a Swift method


493
00:22:44,776 --> 00:22:47,116
and produces the Objective-C
name for that method.


494
00:22:47,316 --> 00:22:49,486
You don't have to care what
that Objective-C name is.


495
00:22:49,486 --> 00:22:50,616
The compiler will get it right.


496
00:22:50,616 --> 00:22:52,926
And the great thing
about this, of course,


497
00:22:52,996 --> 00:22:55,136
is that Swift makes sure
that that method exists.


498
00:22:55,626 --> 00:22:57,736
Makes sure it's exposed
to Objective-C,


499
00:22:58,226 --> 00:22:59,496
and computes the correct name.


500
00:22:59,596 --> 00:23:01,636
And of course, this is
safe against refactoring.


501
00:23:01,976 --> 00:23:03,266
Works with code completion.


502
00:23:03,406 --> 00:23:05,376
So it's a much nicer
development experience.


503
00:23:05,376 --> 00:23:06,446
That means you don't
have to worry


504
00:23:06,446 --> 00:23:07,596
about the Objective-C names.


505
00:23:08,916 --> 00:23:12,026
In Swift 3 we've extended this
so you can also refer to getters


506
00:23:12,026 --> 00:23:13,316
and setters of properties.


507
00:23:13,606 --> 00:23:14,666
So we round out the set


508
00:23:14,666 --> 00:23:16,776
of Objective-C method names
you can actually compute.


509
00:23:16,876 --> 00:23:18,526
So this is very easy to use.


510
00:23:18,636 --> 00:23:21,206
You just pass in the argument
label setter or getter


511
00:23:21,206 --> 00:23:23,106
to get the setter or
the getter respectively.


512
00:23:23,536 --> 00:23:25,306
And then refer to an
Objective-C property.


513
00:23:26,226 --> 00:23:28,186
And of course, the
compiler will validate


514
00:23:28,186 --> 00:23:30,786
that that property exists, that
it's exposed to Objective-C


515
00:23:31,086 --> 00:23:34,226
and get the right
Objective-C name for it.


516
00:23:35,046 --> 00:23:36,236
Now, selectors aren't
the only sort


517
00:23:36,236 --> 00:23:38,496
of stringly type thing
we have when talking


518
00:23:38,496 --> 00:23:39,876
about Objective-C method names.


519
00:23:40,386 --> 00:23:43,236
We also have Key Paths,
which are notoriously hard


520
00:23:43,236 --> 00:23:45,876
to get right when
writing these things


521
00:23:45,876 --> 00:23:47,676
as string literals
with no validation.


522
00:23:48,616 --> 00:23:53,236
And so, in Swift 3 we're
also introducing #keyPath.


523
00:23:54,516 --> 00:24:00,876
[ Applause ]


524
00:24:01,376 --> 00:24:03,786
#keyPath does exactly
what you'd expect.


525
00:24:03,906 --> 00:24:07,376
You get to refer to a dotted
sequence of property accesses.


526
00:24:07,686 --> 00:24:10,186
Compiler validates that these
are actually Objective-C


527
00:24:10,186 --> 00:24:12,416
properties, gets
the right names.


528
00:24:12,856 --> 00:24:15,206
And then produces the
string that we pass


529
00:24:15,206 --> 00:24:16,986
down into the frameworks.


530
00:24:17,066 --> 00:24:19,336
And so between #selector
and #keyPath,


531
00:24:19,946 --> 00:24:23,276
you can essentially not worry
about the Objective-C names.


532
00:24:24,066 --> 00:24:26,316
You just write everything
in terms of the Swift names


533
00:24:26,666 --> 00:24:28,606
and you stay in that
set of names.


534
00:24:28,606 --> 00:24:30,126
You don't have to
straddle the boundary.


535
00:24:31,466 --> 00:24:33,576
Now, there are cases
where you do need to think


536
00:24:33,576 --> 00:24:35,306
about what the Objective-C
names are.


537
00:24:35,506 --> 00:24:37,766
You may have a mixed project
with Objective-C code in it


538
00:24:37,806 --> 00:24:39,746
that needs to refer to the
names in your Swift code.


539
00:24:40,376 --> 00:24:42,486
And names like this
handleDragWithSender


540
00:24:42,486 --> 00:24:45,946
for just don't feel right
when they're in Objective-C.


541
00:24:46,456 --> 00:24:51,016
So for these cases, you can
use the @objc attribute.


542
00:24:51,456 --> 00:24:54,706
And in parentheses put the exact
Objective-C name that you want.


543
00:24:55,316 --> 00:24:58,006
And that will be reflected in
your generated headers and all


544
00:24:58,006 --> 00:25:01,136
of the metadata and everything
else so you get specific control


545
00:25:01,136 --> 00:25:04,236
over the Objective-C
names, but no other part


546
00:25:04,236 --> 00:25:06,106
of your Swift code actually
has to care about this.


547
00:25:06,396 --> 00:25:11,926
And of course, this @objc with
a name works for properties,


548
00:25:11,926 --> 00:25:14,226
it works for methods,
classes, protocols.


549
00:25:14,226 --> 00:25:17,426
Anything that can be exposed
to Objective-C from Swift,


550
00:25:17,926 --> 00:25:19,366
you can control the name here.


551
00:25:19,966 --> 00:25:24,046
So you get nice Objective-C
APIs for your Swift code.


552
00:25:25,076 --> 00:25:28,396
Okay. There's a lot of
change coming with Swift 3.


553
00:25:29,936 --> 00:25:33,276
The Swift language itself
abstracts away the need to worry


554
00:25:33,276 --> 00:25:34,536
about the Objective-C names,


555
00:25:34,536 --> 00:25:37,226
and yet it gives you the
control you need for those times


556
00:25:37,226 --> 00:25:39,356
when you do care about
the Objective-C names.


557
00:25:40,986 --> 00:25:42,746
The tools are here to help you.


558
00:25:44,016 --> 00:25:47,686
So the Swift 3 migrator is going
to Swift 2 code and migrate it


559
00:25:47,686 --> 00:25:49,906
to the Swift 3 names
and the Swift 3 syntax.


560
00:25:50,226 --> 00:25:51,406
It's a lot of change.


561
00:25:52,366 --> 00:25:54,376
But these tools will help
you get over the hump


562
00:25:54,376 --> 00:25:55,786
and get working with Swift 3.


563
00:25:57,226 --> 00:25:59,246
Now, the Swift 3
migrator is a great tool.


564
00:25:59,836 --> 00:26:01,976
But it can't migrate
your muscle memory.


565
00:26:02,916 --> 00:26:04,676
Certainly can't migrate
all that code you copy


566
00:26:04,676 --> 00:26:06,086
and paste from stack overflow.


567
00:26:09,236 --> 00:26:11,646
So, the Swift compiler's
also here to help you.


568
00:26:12,196 --> 00:26:14,816
The Swift compiler, it knows
the Swift 2 names of all


569
00:26:14,816 --> 00:26:17,126
of these APIs as well
as the Swift 3 names.


570
00:26:17,436 --> 00:26:20,636
So if you write or paste
in some code from Swift 2,


571
00:26:20,876 --> 00:26:24,586
it'll recognize the old API
names and give you diagnostics


572
00:26:24,646 --> 00:26:27,656
with Fix-its to update your code
so you can get moving faster.


573
00:26:29,066 --> 00:26:31,496
Additionally, we've put
in near miss detection


574
00:26:31,636 --> 00:26:33,736
when you're implementing
optional protocol methods.


575
00:26:34,076 --> 00:26:36,996
And so this is great when
you're implementing a delegate.


576
00:26:37,316 --> 00:26:39,676
You make some minor
mistake in the name


577
00:26:39,676 --> 00:26:41,326
of that delegate method
you want to implement.


578
00:26:41,756 --> 00:26:44,406
Now you'll get a warning with
a Fix-it to fix up the names


579
00:26:44,796 --> 00:26:46,876
so you can be sure that your
method will be called properly.


580
00:26:46,966 --> 00:26:47,526
All right.


581
00:26:48,356 --> 00:26:52,966
Now I'd like to turn things
over to my colleague Michael,


582
00:26:53,376 --> 00:26:55,006
who's going to talk
about the mapping of C


583
00:26:55,006 --> 00:26:56,966
and Objective-C APIs into Swift.


584
00:26:58,516 --> 00:27:07,546
[ Applause ]


585
00:27:08,046 --> 00:27:09,046
>> So that's a lot about Swift.


586
00:27:09,206 --> 00:27:12,496
But what if you're an
Objective-C developer


587
00:27:12,756 --> 00:27:14,316
or are working with
a mixed project?


588
00:27:14,966 --> 00:27:17,666
All of your Objective-C
APIs are available in Swift.


589
00:27:17,856 --> 00:27:18,836
They always have been.


590
00:27:19,266 --> 00:27:21,156
But as Doug explained,
they were designed


591
00:27:21,156 --> 00:27:22,636
for a different language.


592
00:27:23,016 --> 00:27:24,916
They are increasingly starting


593
00:27:24,916 --> 00:27:27,356
to feel a little bit
foreign in Swift.


594
00:27:27,916 --> 00:27:30,676
So today I'm going to show
you how you can take control


595
00:27:30,676 --> 00:27:33,826
of the situation and give
your Swift users the APIs


596
00:27:33,946 --> 00:27:34,506
they deserve.


597
00:27:36,196 --> 00:27:38,996
I'm going to start with
a couple Objective-C APIs


598
00:27:38,996 --> 00:27:40,666
as they were imported
into Swift 2.


599
00:27:41,166 --> 00:27:44,926
Here we have two methods;
saveToURL, forSaveOperation


600
00:27:44,926 --> 00:27:46,756
and revertToContentsOfURL.


601
00:27:47,426 --> 00:27:51,606
But these don't really express
the API Design Guidelines


602
00:27:51,606 --> 00:27:52,456
that Doug outlined.


603
00:27:52,456 --> 00:27:55,186
There's a lot of
redundant type information.


604
00:27:55,806 --> 00:27:58,986
We're not making effective use
of the first parameter labels,


605
00:27:59,056 --> 00:27:59,926
first argument labels.


606
00:27:59,926 --> 00:28:04,456
So I'm going to start with what
you get for free automatically


607
00:28:04,456 --> 00:28:05,656
in the Swift 3 compiler.


608
00:28:05,976 --> 00:28:09,496
Swift 3 has improvements to how
Objective-C APIs are imported.


609
00:28:10,926 --> 00:28:13,596
The Swift compiler will
inspect method names


610
00:28:13,626 --> 00:28:15,386
and use grammatical
cues in order


611
00:28:15,386 --> 00:28:19,000
to infer first parameter labels.


612
00:28:23,176 --> 00:28:25,256
The Swift compiler will
inspect names in order


613
00:28:25,256 --> 00:28:27,506
to eliminate redundant
type information.


614
00:28:28,096 --> 00:28:33,476
The compiler can even
infer default arguments


615
00:28:33,556 --> 00:28:36,886
for common Objective-C idioms
such as completion handlers.


616
00:28:38,156 --> 00:28:40,116
Or option sets.


617
00:28:40,726 --> 00:28:44,556
And also, there are
new value types


618
00:28:44,556 --> 00:28:47,096
such as URL that
bridge to NSURL.


619
00:28:47,446 --> 00:28:50,086
So when we import, we
just import it directly.


620
00:28:52,376 --> 00:28:55,416
To find out more about
these value types, visit,


621
00:28:55,416 --> 00:28:59,376
What's New in Foundation
for Swift later today.


622
00:28:59,926 --> 00:29:02,286
So, automatic inference
is great and all,


623
00:29:02,346 --> 00:29:05,616
but fundamentally it's
driven by heuristics.


624
00:29:05,616 --> 00:29:07,546
The compiler, it
can't read your mind.


625
00:29:07,546 --> 00:29:08,956
It doesn't know your intent.


626
00:29:09,566 --> 00:29:12,816
And every now and then you
want to specify your own name.


627
00:29:13,266 --> 00:29:15,296
So we've extended NS Swift Name.


628
00:29:15,366 --> 00:29:17,446
Now, NS Swift Name has
been around since Swift 2.


629
00:29:17,446 --> 00:29:20,646
But in Swift 3 we support
full compound naming.


630
00:29:21,246 --> 00:29:23,906
A compound name is a base
name plus the argument labels.


631
00:29:24,006 --> 00:29:25,516
So in this case, we
have two methods.


632
00:29:26,316 --> 00:29:29,276
They're performing semantically
very similar operations.


633
00:29:29,486 --> 00:29:32,116
But they differ basically in
how they treat their argument.


634
00:29:32,116 --> 00:29:34,536
And so we import them with the
same base name constraints,


635
00:29:35,186 --> 00:29:38,766
but we say we want it equal
to this anchor or greater than


636
00:29:38,766 --> 00:29:41,616
or equal to this anchor.


637
00:29:42,756 --> 00:29:45,496
Now, method names will get you
a long way towards a Swifty API,


638
00:29:45,496 --> 00:29:47,616
but this doesn't
quite go far enough.


639
00:29:48,266 --> 00:29:50,806
Here I have some simple code
that's creating a standard


640
00:29:50,976 --> 00:29:51,956
Gregorian calendar.


641
00:29:52,876 --> 00:29:56,146
But if you look at this, this
doesn't really feel very Swifty,


642
00:29:56,876 --> 00:29:59,436
especially
NSCalendarIdentifierGregorian,


643
00:30:00,046 --> 00:30:02,486
which is a plain
string global variable.


644
00:30:02,966 --> 00:30:04,476
Plain string global variables,


645
00:30:04,476 --> 00:30:06,306
that's not really
how we do Swift.


646
00:30:06,796 --> 00:30:10,396
This is what we jokingly refer
to as stringly-typed API.


647
00:30:11,676 --> 00:30:13,866
And the fact that this
API takes a string,


648
00:30:14,566 --> 00:30:16,366
that kind of allows
simple errors.


649
00:30:16,366 --> 00:30:18,356
And yes, I know this
bug is shallow


650
00:30:18,356 --> 00:30:20,186
and a developer would
catch it right away.


651
00:30:20,686 --> 00:30:25,206
But the fact that a user of this
API has to remember what it is


652
00:30:25,206 --> 00:30:27,326
and it's not a valid
string to use here,


653
00:30:27,696 --> 00:30:29,996
that's an unnecessary
cognitive burden.


654
00:30:31,736 --> 00:30:34,136
So, why is this API like this?


655
00:30:34,666 --> 00:30:36,536
Well, we all know why
this API is like this.


656
00:30:36,536 --> 00:30:38,006
It came from Objective-C.


657
00:30:38,536 --> 00:30:41,426
But the fact that this
API came from Objective-C,


658
00:30:41,686 --> 00:30:43,206
that's an implementation detail.


659
00:30:43,386 --> 00:30:45,756
And that implementation
detail is leaking out.


660
00:30:46,336 --> 00:30:51,976
And at Apple, we're
not big fans of leaks.


661
00:30:52,046 --> 00:30:52,936
To figure out what's
going wrong,


662
00:30:52,936 --> 00:30:55,116
let's see how this Objective-C
API is mapping into Swift.


663
00:30:55,386 --> 00:30:58,956
Our global variable comes in as
a global variable, of course.


664
00:30:59,496 --> 00:31:01,546
But other than the name
of this global variable,


665
00:31:01,826 --> 00:31:02,876
nothing really tells you


666
00:31:02,876 --> 00:31:07,426
that this a very specific string
meant for a very specific API.


667
00:31:08,816 --> 00:31:11,176
Now, we could try
adding a typedef to try


668
00:31:11,176 --> 00:31:12,426
and hint at our intent.


669
00:31:12,856 --> 00:31:14,796
But a typedef, it's
just a type alias.


670
00:31:14,796 --> 00:31:16,876
It's a new name for an old type.


671
00:31:17,446 --> 00:31:19,796
And so that doesn't really
fix the problem here.


672
00:31:21,356 --> 00:31:23,646
So, how will this API
look if we were going


673
00:31:23,646 --> 00:31:25,896
to design this fresh in Swift 3?


674
00:31:26,666 --> 00:31:30,786
Well, we'd probably make a
new wrapper type around string


675
00:31:30,786 --> 00:31:32,436
to get some strong typing.


676
00:31:32,646 --> 00:31:33,836
And these global
variables, well,


677
00:31:33,916 --> 00:31:35,686
those would instead
be static properties.


678
00:31:36,346 --> 00:31:38,626
So in Swift 3 we introduced
a new attribute just


679
00:31:38,626 --> 00:31:39,446
for this use case.


680
00:31:39,796 --> 00:31:41,056
You can access this attribute


681
00:31:41,306 --> 00:31:44,036
through NS Extensible
String Enum when you wish


682
00:31:44,036 --> 00:31:45,146
to tell the Swift compiler


683
00:31:45,356 --> 00:31:48,176
to make a new wrapper
type around your string.


684
00:31:48,756 --> 00:31:52,306
You can just add
this to your typedef.


685
00:31:53,086 --> 00:31:57,286
And the importer will create
you the new type around this.


686
00:31:57,436 --> 00:32:00,426
And any global variables of
this type will get imported


687
00:32:00,426 --> 00:32:03,096
automatically as static
properties of this type.


688
00:32:04,926 --> 00:32:07,366
Now, we chose a struct here
because this is extensible.


689
00:32:07,366 --> 00:32:10,286
That is, other modules may
want to define their own.


690
00:32:10,646 --> 00:32:13,576
And if they do, they will also
be imported as static properties


691
00:32:13,576 --> 00:32:15,226
on an extension of this struct.


692
00:32:15,856 --> 00:32:22,906
Now, behind the scenes the Swift
compiler will map this directly


693
00:32:22,906 --> 00:32:24,466
to the underlying stored value,


694
00:32:24,466 --> 00:32:27,296
meaning that there's no
extra overhead or boxing


695
00:32:27,396 --> 00:32:32,756
or intermediaries involved.


696
00:32:33,736 --> 00:32:35,446
So, let's focus on the use site.


697
00:32:35,446 --> 00:32:38,806
Because good API design is
always focused on the use site.


698
00:32:39,456 --> 00:32:41,676
Before and after.


699
00:32:41,916 --> 00:32:44,856
And because the type
context is clearer,


700
00:32:45,036 --> 00:32:47,486
we can even just say .gregorian.


701
00:32:48,516 --> 00:32:57,146
[ Applause ]


702
00:32:57,646 --> 00:33:03,546
I'll kick it off by
starting myself next time.


703
00:33:03,906 --> 00:33:07,936
Also, in Swift 3 NSCalendar,
it's now just known as Calendar.


704
00:33:07,996 --> 00:33:10,666
This is a little fix up.


705
00:33:10,886 --> 00:33:16,236
So, we have method
names and we have types.


706
00:33:16,556 --> 00:33:17,316
What else do we have?


707
00:33:18,156 --> 00:33:21,046
Well, we have an elephant.


708
00:33:22,626 --> 00:33:25,316
That is, we have an
elephant in the room.


709
00:33:26,556 --> 00:33:28,886
And we've been pretending
not to notice it.


710
00:33:28,966 --> 00:33:30,706
But it's always been there.


711
00:33:32,396 --> 00:33:33,086
And it's C.


712
00:33:35,376 --> 00:33:39,436
Now, with Objective-C, the APIs
were already object-oriented,


713
00:33:39,436 --> 00:33:42,226
so when we import them we
just change a few strings,


714
00:33:42,226 --> 00:33:43,226
add a few types.


715
00:33:43,446 --> 00:33:44,436
It's relatively straightforward.


716
00:33:44,796 --> 00:33:45,976
But what about C?


717
00:33:46,756 --> 00:33:49,616
I'm going to focus
on Core Graphics.


718
00:33:50,076 --> 00:33:53,056
Now, Core Graphics is a
very popular API that's used


719
00:33:53,056 --> 00:33:54,946
by pretty much every
Swift app out there.


720
00:33:55,306 --> 00:33:56,646
It is a powerful API.


721
00:33:56,646 --> 00:34:00,326
But it looks and
it feels like C.


722
00:34:01,666 --> 00:34:02,636
Let's start with some code.


723
00:34:03,026 --> 00:34:04,196
I have two functions here.


724
00:34:04,466 --> 00:34:06,176
The first one transforms a --


725
00:34:06,176 --> 00:34:09,746
takes a transform and rotates
it about a given offset.


726
00:34:10,335 --> 00:34:12,956
And the second function
traces a path in red.


727
00:34:13,335 --> 00:34:15,326
Now, neither of these
functions are too complicated,


728
00:34:15,326 --> 00:34:16,505
and the details don't matter.


729
00:34:16,505 --> 00:34:18,936
But I just want to look
at how does this look?


730
00:34:18,936 --> 00:34:19,886
How does this feel?


731
00:34:20,005 --> 00:34:22,000
Go ahead and take a moment.


732
00:34:25,436 --> 00:34:28,346
So, if you notice, this
code is completely filled


733
00:34:28,346 --> 00:34:30,616
with global variables
and global functions.


734
00:34:30,876 --> 00:34:33,356
And we don't really like
global functions, of course.


735
00:34:34,136 --> 00:34:36,005
Or global variables, of course.


736
00:34:37,866 --> 00:34:41,815
So, how could we
take an API like this


737
00:34:42,146 --> 00:34:43,656
and make it look Swifty?


738
00:34:43,656 --> 00:34:45,906
How can we make it feel Swifty?


739
00:34:47,085 --> 00:34:50,696
Well, for that, we revisit
our friend NS Swift Name.


740
00:34:50,936 --> 00:34:52,606
You can use NS Swift
Name in order


741
00:34:52,606 --> 00:34:55,536
to import globals
as members of types.


742
00:34:56,065 --> 00:34:57,776
Let me start with
global variables


743
00:34:57,776 --> 00:34:58,476
to show you what I mean.


744
00:34:59,666 --> 00:35:01,696
Here at the top I have
this C definition.


745
00:35:02,166 --> 00:35:04,126
Below that the generated
Swift interface.


746
00:35:04,126 --> 00:35:05,856
And underneath that
the Swift use site.


747
00:35:05,856 --> 00:35:07,536
And we will be focusing
on the Swift use site


748
00:35:07,536 --> 00:35:09,286
and improving the
Swift use site.


749
00:35:09,936 --> 00:35:14,436
So we add NS Swift Name and we
use typename.membername in order


750
00:35:14,436 --> 00:35:20,096
to tell the Swift compiler that
kCGColorWhite should be imported


751
00:35:20,096 --> 00:35:22,886
as the static property
white on CGColor.


752
00:35:23,266 --> 00:35:27,786
And of course, the Swift use
site can now use the properly


753
00:35:28,276 --> 00:35:29,876
nested property.


754
00:35:30,516 --> 00:35:35,596
[ Applause ]


755
00:35:36,096 --> 00:35:37,586
And of course, if the
type context is clear,


756
00:35:37,586 --> 00:35:39,666
users can even omit the CGColor.


757
00:35:40,346 --> 00:35:44,346
Now Core Graphics has a lot
of different global functions


758
00:35:44,346 --> 00:35:46,936
to create all different kinds
of CG Affine Transforms.


759
00:35:46,936 --> 00:35:48,996
That's
CGAffineTransformMakeTranslation


760
00:35:48,996 --> 00:35:49,266
as well


761
00:35:49,266 --> 00:35:51,566
as CGAffineTransformMakeRotation
on all of these.


762
00:35:51,566 --> 00:35:53,826
But in Swift we prefer
Initializer.


763
00:35:53,826 --> 00:35:58,126
So we use TypeName.Init and
provide argument labels in order


764
00:35:58,126 --> 00:35:59,106
to tell the Swift compiler


765
00:35:59,216 --> 00:36:01,496
that this should really
just be an initializer.


766
00:36:01,976 --> 00:36:03,806
And we use argument
labels in order


767
00:36:03,806 --> 00:36:06,346
to clarify the roles
of the parameter.


768
00:36:06,936 --> 00:36:11,856
You can also import
as an instance member.


769
00:36:12,306 --> 00:36:14,746
Use the special argument
label self in order


770
00:36:14,746 --> 00:36:16,836
to tell the Swift
compiler what argument


771
00:36:16,876 --> 00:36:18,706
to plug the reference
to self into.


772
00:36:19,906 --> 00:36:24,556
And so now CGContextFillPath is
now just the method fill path.


773
00:36:24,916 --> 00:36:26,586
And of course, the
Swift use site,


774
00:36:27,516 --> 00:36:28,946
it just calls it like a method.


775
00:36:30,516 --> 00:36:35,546
[ Applause ]


776
00:36:36,046 --> 00:36:37,926
And the compiler will take
what's on the left of the dot


777
00:36:37,926 --> 00:36:41,706
and plug it into the appropriate
parameter position as denoted


778
00:36:41,806 --> 00:36:43,556
by the special argument
label self.


779
00:36:44,136 --> 00:36:46,936
We can get more complicated.


780
00:36:47,036 --> 00:36:50,376
You can prefix a Swift name
with getter or setter in order


781
00:36:50,376 --> 00:36:53,196
to tell the compiler
to import this function


782
00:36:53,196 --> 00:36:55,726
as a computed property
getter or setter.


783
00:36:56,326 --> 00:36:57,996
Here ArtistGetName,


784
00:36:57,996 --> 00:37:01,076
ArtistSetName are now just
the getters and setters


785
00:37:01,076 --> 00:37:02,966
for the computed
property Artist.


786
00:37:04,226 --> 00:37:05,916
Let's focus in the use site


787
00:37:06,146 --> 00:37:09,186
because good API design is
always focused on the use site.


788
00:37:09,526 --> 00:37:11,936
Before, we would use
a global function


789
00:37:11,936 --> 00:37:13,676
to remember the former
name of an artist


790
00:37:13,896 --> 00:37:16,386
and a different global
function to set a new name.


791
00:37:17,956 --> 00:37:22,006
But now, our users can use the
computed property directly.


792
00:37:23,206 --> 00:37:26,696
In all cases, this is
a zero cost overhead.


793
00:37:26,696 --> 00:37:29,856
That is, when the compiler
sees myArtist.Name it maps it


794
00:37:29,856 --> 00:37:32,046
directly to the corresponding
C function


795
00:37:32,256 --> 00:37:35,576
without calling any wrappers
or intermediaries or overlays.


796
00:37:37,926 --> 00:37:40,616
You can also use NS Swift
Name in order to nest types.


797
00:37:40,946 --> 00:37:47,306
Remember earlier when we created
a new calendar identifier type?


798
00:37:48,046 --> 00:37:49,886
Well, you can use typeName.


799
00:37:50,696 --> 00:37:52,096
-- well member name --


800
00:37:52,186 --> 00:37:54,086
nest a type name in
order to nest a type.


801
00:37:54,396 --> 00:37:58,000
So in this case we get
Calendar.Identifier.


802
00:38:06,106 --> 00:38:08,696
Now, we love the
new NS Swift Name.


803
00:38:09,536 --> 00:38:18,856
We love it so much that we went
absolutely, completely bananas.


804
00:38:19,516 --> 00:38:27,566
[ Laughter & Applause ]


805
00:38:28,066 --> 00:38:28,996
Don't clap for this.


806
00:38:31,906 --> 00:38:35,656
And we applied it
to over 600 APIs


807
00:38:35,876 --> 00:38:38,396
in Core Graphics alone, 600.


808
00:38:39,076 --> 00:38:39,816
Now you can clap.


809
00:38:40,516 --> 00:38:43,616
[ Applause ]


810
00:38:44,116 --> 00:38:44,946
That's a lot of bananas.


811
00:38:45,796 --> 00:38:48,036
So, let's revisit
the code from before.


812
00:38:48,506 --> 00:38:50,296
Before, our global variable,


813
00:38:50,296 --> 00:38:54,166
which is painfully
global, is now a member.


814
00:38:54,166 --> 00:38:56,116
And because the type
context is clearer,


815
00:38:56,276 --> 00:39:00,526
we can even omit the type name.


816
00:39:00,746 --> 00:39:03,866
Our global functions
are now methods.


817
00:39:06,516 --> 00:39:10,626
[ Applause ]


818
00:39:11,126 --> 00:39:12,656
Actually, now that
I look at this,


819
00:39:12,656 --> 00:39:14,186
I think this code
can even simpler.


820
00:39:14,186 --> 00:39:16,046
We don't need that
extra variable result.


821
00:39:17,616 --> 00:39:18,666
And so now this reads --


822
00:39:19,516 --> 00:39:23,636
[ Applause ]


823
00:39:24,136 --> 00:39:26,526
And so now this reads
nice, natural and Swifty.


824
00:39:26,926 --> 00:39:28,276
We take a transform.


825
00:39:28,436 --> 00:39:29,586
We translate it.


826
00:39:29,586 --> 00:39:30,236
We rotate it.


827
00:39:30,236 --> 00:39:31,286
And we translate it back.


828
00:39:31,616 --> 00:39:32,426
Very straightforward.


829
00:39:32,936 --> 00:39:33,436
Moving on.


830
00:39:33,936 --> 00:39:37,656
CGColorCreateGenericRGB as
well as all of the other many,


831
00:39:37,656 --> 00:39:39,326
many different ways
to create colors,


832
00:39:40,206 --> 00:39:43,446
these are now initializers
with argument labels.


833
00:39:43,586 --> 00:39:45,766
And of course --
hold your applause --


834
00:39:46,006 --> 00:39:50,376
and of course CGContextAddPath,
ContextPath and all


835
00:39:50,376 --> 00:39:54,786
of the other crazy redundant
stuff, they're now methods.


836
00:39:55,516 --> 00:40:01,546
[ Applause ]


837
00:40:02,046 --> 00:40:04,166
We hope you enjoy
these new APIs.


838
00:40:04,386 --> 00:40:08,336
So, to summarize, first we
presented the new API Design


839
00:40:08,336 --> 00:40:09,246
Guidelines in Swift.


840
00:40:09,766 --> 00:40:12,746
Good API design is always
focused on the use site.


841
00:40:13,216 --> 00:40:15,806
Second, we looked at
the Grand Renaming.


842
00:40:15,976 --> 00:40:18,136
This is also known as, "Oh, no!


843
00:40:18,166 --> 00:40:19,206
Everything's different."


844
00:40:19,636 --> 00:40:20,456
But don't panic.


845
00:40:20,806 --> 00:40:21,486
It's okay.


846
00:40:21,766 --> 00:40:22,886
The names are better.


847
00:40:22,886 --> 00:40:23,916
The code is clearer.


848
00:40:23,916 --> 00:40:25,446
And you have the
tools to migrate.


849
00:40:25,856 --> 00:40:27,916
And last, we looked at
the new functionality


850
00:40:27,946 --> 00:40:30,896
in the Swift compiler so
that you can have your own


851
00:40:30,976 --> 00:40:31,716
Great Renaming.


852
00:40:32,546 --> 00:40:36,416
For more information, visit
the page for this site


853
00:40:36,416 --> 00:40:40,516
at developer.apple.com and check
out Swift.org, the homepage


854
00:40:40,516 --> 00:40:42,886
of the open source Swift
project where you can see all


855
00:40:42,886 --> 00:40:44,146
of the Swift evolution.


856
00:40:44,436 --> 00:40:45,926
I also showed you Core Graphics.


857
00:40:46,126 --> 00:40:49,256
But Grand Central Dispatch has
had its own Great Renaming using


858
00:40:49,256 --> 00:40:51,016
many of these same
techniques I presented today.


859
00:40:51,426 --> 00:40:55,246
So, Friday, check out
concurrent programming


860
00:40:55,246 --> 00:40:57,096
with Grand Central
Dispatch in Swift 3.


861
00:40:57,626 --> 00:40:57,986
Friday.


862
00:40:59,516 --> 00:41:15,080
[ Applause ]

