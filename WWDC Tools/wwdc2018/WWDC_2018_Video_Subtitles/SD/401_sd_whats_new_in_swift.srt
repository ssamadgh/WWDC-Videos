1
00:00:07,016 --> 00:00:15,500
[ Music ]


2
00:00:25,516 --> 00:00:28,586
[ Applause ]


3
00:00:29,086 --> 00:00:31,526
>> Good morning and welcome to


4
00:00:31,526 --> 00:00:32,836
What's New in Swift.


5
00:00:33,546 --> 00:00:35,316
This has been an exciting year


6
00:00:35,396 --> 00:00:36,986
for Swift and the Swift


7
00:00:37,046 --> 00:00:37,596
Community.


8
00:00:37,966 --> 00:00:39,076
And over the next 40 minutes


9
00:00:39,136 --> 00:00:40,606
Slava and I are thrilled to give


10
00:00:40,606 --> 00:00:41,746
you an update on the major


11
00:00:41,746 --> 00:00:42,526
developments there.


12
00:00:43,696 --> 00:00:44,956
The session is roughly broken in


13
00:00:44,956 --> 00:00:45,346
to two parts.


14
00:00:46,126 --> 00:00:47,296
First I'm going to give an


15
00:00:47,296 --> 00:00:48,606
update on the Swift open source


16
00:00:48,646 --> 00:00:51,006
project and the community around


17
00:00:51,006 --> 00:00:51,126
it.


18
00:00:51,606 --> 00:00:52,796
And then we'll dive into Swift


19
00:00:52,796 --> 00:00:54,666
4.2, which is available as a


20
00:00:54,666 --> 00:00:56,646
preview today in the Xcode 10


21
00:00:58,046 --> 00:00:58,206
beta.


22
00:00:58,756 --> 00:01:00,786
Since late 2015, Swift has been


23
00:01:00,786 --> 00:01:02,476
an open source project on


24
00:01:02,476 --> 00:01:02,946
GitHub.


25
00:01:04,546 --> 00:01:06,476
With a vibrant community of


26
00:01:06,476 --> 00:01:10,226
users who discuss, propose, and


27
00:01:10,226 --> 00:01:11,556
review all changes to the


28
00:01:11,556 --> 00:01:13,366
language and standard library.


29
00:01:15,726 --> 00:01:17,476
In that time over 600


30
00:01:17,476 --> 00:01:18,776
individuals have contributed


31
00:01:18,776 --> 00:01:20,926
code to GitHub as Swift open


32
00:01:20,926 --> 00:01:21,706
source project.


33
00:01:22,576 --> 00:01:23,686
And together they have merged


34
00:01:23,686 --> 00:01:26,046
over 18,000 pull requests.


35
00:01:27,316 --> 00:01:29,386
Since Swift.org was launched


36
00:01:29,386 --> 00:01:31,326
Swift has been available for


37
00:01:31,326 --> 00:01:33,966
download on Swift.org both for


38
00:01:33,966 --> 00:01:35,136
downloadable tool chains for


39
00:01:35,166 --> 00:01:36,956
Xcode, as well as various


40
00:01:36,996 --> 00:01:38,216
version of Ubuntu.


41
00:01:38,646 --> 00:01:39,536
These are both development


42
00:01:39,536 --> 00:01:43,536
snapshots and official releases.


43
00:01:45,016 --> 00:01:46,106
Now we want Swift to be


44
00:01:46,106 --> 00:01:48,646
supported on all platforms so


45
00:01:48,796 --> 00:01:50,396
everyone can use it.


46
00:01:50,396 --> 00:01:53,086
And a critical part of that is


47
00:01:53,086 --> 00:01:54,766
extending the testing support


48
00:01:55,116 --> 00:01:56,586
provided to the community.


49
00:01:57,046 --> 00:01:58,476
Various folks in the open source


50
00:01:58,506 --> 00:02:00,336
project are working on bringing


51
00:02:00,376 --> 00:02:01,506
Swift support to other


52
00:02:01,506 --> 00:02:02,106
platforms.


53
00:02:02,476 --> 00:02:03,786
And we'd like to support those


54
00:02:03,786 --> 00:02:04,166
efforts.


55
00:02:05,396 --> 00:02:07,726
About a month ago we extended


56
00:02:07,726 --> 00:02:08,545
the public continuous


57
00:02:08,545 --> 00:02:10,006
integration systems to support


58
00:02:10,006 --> 00:02:12,066
community hosted CI notes.


59
00:02:12,566 --> 00:02:13,576
So if you are a member of the


60
00:02:13,576 --> 00:02:14,796
community interested in bringing


61
00:02:14,796 --> 00:02:16,386
Swift to another platform or


62
00:02:16,436 --> 00:02:18,046
effort, you can now seamlessly


63
00:02:18,046 --> 00:02:19,266
plug in your own hardware


64
00:02:19,266 --> 00:02:20,726
support to bring testing there.


65
00:02:21,146 --> 00:02:22,776
This is a nice prerequisite for


66
00:02:22,776 --> 00:02:23,956
supporting Swift in other


67
00:02:23,956 --> 00:02:24,566
places.


68
00:02:26,826 --> 00:02:28,816
We've also invested tremendously


69
00:02:29,056 --> 00:02:31,056
in the community around the


70
00:02:31,106 --> 00:02:32,716
Swift open source project.


71
00:02:33,056 --> 00:02:34,036
This is the community that


72
00:02:34,036 --> 00:02:35,476
discusses all changes to the


73
00:02:35,476 --> 00:02:35,966
language.


74
00:02:36,966 --> 00:02:38,936
About six months ago we moved


75
00:02:38,936 --> 00:02:40,196
from using mailing lists, which


76
00:02:40,196 --> 00:02:42,016
were very high traffic to


77
00:02:42,146 --> 00:02:42,556
forums.


78
00:02:42,986 --> 00:02:44,096
This was at the behest of the


79
00:02:44,096 --> 00:02:44,746
community.


80
00:02:45,366 --> 00:02:47,046
Various people were concerned


81
00:02:47,046 --> 00:02:48,776
that they wanted to be able to


82
00:02:48,776 --> 00:02:50,446
engage in the project at a level


83
00:02:50,446 --> 00:02:52,386
that worked well for them but


84
00:02:52,386 --> 00:02:54,126
found it difficult to do so.


85
00:02:54,666 --> 00:02:55,586
With the forums you can now


86
00:02:55,586 --> 00:02:57,656
engage the level that works well


87
00:02:57,656 --> 00:02:58,066
for you.


88
00:02:59,496 --> 00:03:00,926
The forums have also worked so


89
00:03:00,926 --> 00:03:02,476
well that we wanted to extend


90
00:03:02,476 --> 00:03:04,586
their utility out to supporting


91
00:03:04,586 --> 00:03:06,746
the general open source project.


92
00:03:07,476 --> 00:03:10,196
If you maintain a Swift open


93
00:03:10,196 --> 00:03:11,696
source project such as a popular


94
00:03:11,696 --> 00:03:13,526
Swift library, you can now use


95
00:03:13,526 --> 00:03:14,906
the forums for use to discuss


96
00:03:15,186 --> 00:03:16,436
things on that project such as


97
00:03:16,436 --> 00:03:18,506
discussions with your users or


98
00:03:18,506 --> 00:03:19,286
development.


99
00:03:20,986 --> 00:03:22,376
We've also looked at ways to


100
00:03:22,376 --> 00:03:24,386
continue to extend Swift.org to


101
00:03:24,426 --> 00:03:26,016
be of general use the community.


102
00:03:26,566 --> 00:03:27,876
This week we've moved to hosting


103
00:03:27,876 --> 00:03:28,936
the Swift programming language


104
00:03:29,006 --> 00:03:30,486
book to swift.org.


105
00:03:31,486 --> 00:03:33,706
Located at docs.swift.org, this


106
00:03:33,706 --> 00:03:35,146
will be a natural place for us


107
00:03:35,186 --> 00:03:37,716
to extend more documentation for


108
00:03:37,716 --> 00:03:39,026
use by the community.


109
00:03:39,606 --> 00:03:42,876
Now the really exciting thing


110
00:03:42,876 --> 00:03:45,006
about Swift is that people are


111
00:03:45,006 --> 00:03:46,776
really thrilled about using it.


112
00:03:46,776 --> 00:03:48,406
And they're talking about it in


113
00:03:48,406 --> 00:03:49,376
a variety of places.


114
00:03:49,606 --> 00:03:51,246
At Podcasts, Meetups,


115
00:03:51,696 --> 00:03:52,556
conferences.


116
00:03:53,126 --> 00:03:54,916
And we, Apple, thought it was


117
00:03:54,916 --> 00:03:56,726
very important for us to engage


118
00:03:56,996 --> 00:03:58,166
in those places because that's


119
00:03:58,196 --> 00:03:59,496
where a lot of the discussion is


120
00:03:59,496 --> 00:03:59,966
happening.


121
00:04:00,736 --> 00:04:02,696
Over the last year we have made


122
00:04:02,696 --> 00:04:04,116
a very conscious effort to


123
00:04:04,116 --> 00:04:06,046
engage in those conferences and


124
00:04:06,046 --> 00:04:09,016
present technical presentations


125
00:04:09,406 --> 00:04:10,826
on things that we're doing with


126
00:04:10,826 --> 00:04:13,026
Swift, or how does Swift work,


127
00:04:13,026 --> 00:04:14,386
or how you can get involved in


128
00:04:14,386 --> 00:04:15,376
the open source project.


129
00:04:16,375 --> 00:04:17,576
And this is something we're very


130
00:04:17,576 --> 00:04:19,156
committed to continuing going


131
00:04:19,245 --> 00:04:19,616
forward.


132
00:04:21,466 --> 00:04:22,466
One of these efforts I'd like to


133
00:04:22,466 --> 00:04:25,096
talk about is a event co-located


134
00:04:25,166 --> 00:04:26,896
next to WWDC on Friday and that


135
00:04:26,896 --> 00:04:27,266
is the try!


136
00:04:27,336 --> 00:04:29,226
Swift San Jose Conference.


137
00:04:29,866 --> 00:04:31,596
There there will be a workshop


138
00:04:31,836 --> 00:04:33,256
with members from the community


139
00:04:33,256 --> 00:04:34,806
to help on board people who are


140
00:04:34,806 --> 00:04:36,326
interested in contributing to


141
00:04:36,326 --> 00:04:38,196
the Swift open source project.


142
00:04:38,626 --> 00:04:39,916
And there will be members from


143
00:04:39,916 --> 00:04:41,836
Apple's compiler team there to


144
00:04:42,046 --> 00:04:43,646
also facilitate those


145
00:04:43,696 --> 00:04:44,416
conversations.


146
00:04:45,146 --> 00:04:47,896
So that's all about the


147
00:04:47,896 --> 00:04:48,446
community update.


148
00:04:49,066 --> 00:04:50,166
Let's talk about Swift 4.2.


149
00:04:50,166 --> 00:04:52,086
I think the natural place to


150
00:04:52,126 --> 00:04:53,346
start is well, what is this


151
00:04:53,346 --> 00:04:54,536
release about and how does it


152
00:04:54,536 --> 00:04:55,466
fit into the bigger picture?


153
00:04:58,276 --> 00:04:59,786
Swift updates occur -- some


154
00:04:59,856 --> 00:05:01,906
major updates occur about twice


155
00:05:01,906 --> 00:05:02,386
a year.


156
00:05:02,996 --> 00:05:04,926
And Swift 4.2 is a major update


157
00:05:04,956 --> 00:05:07,026
over Swift 4.1 and 4.0.


158
00:05:08,246 --> 00:05:10,116
Now there are in broad strokes


159
00:05:10,216 --> 00:05:11,736
two themes to this release.


160
00:05:12,316 --> 00:05:14,686
One is a huge focus on developer


161
00:05:14,686 --> 00:05:15,386
productivity.


162
00:05:15,826 --> 00:05:16,946
You can see this in a variety of


163
00:05:16,946 --> 00:05:17,136
ways.


164
00:05:17,686 --> 00:05:19,186
The faster builds for projects.


165
00:05:19,546 --> 00:05:20,826
But also just through and


166
00:05:20,826 --> 00:05:22,876
through massive improvement to


167
00:05:22,876 --> 00:05:24,676
the core tooling experience from


168
00:05:24,676 --> 00:05:26,106
the Debugger through the Editor.


169
00:05:26,186 --> 00:05:28,306
And the community has also


170
00:05:28,306 --> 00:05:30,216
focused on language improvements


171
00:05:30,616 --> 00:05:32,206
that aim to improve common


172
00:05:32,206 --> 00:05:33,796
developer workflows, remove


173
00:05:33,796 --> 00:05:34,386
boilerplate.


174
00:05:34,926 --> 00:05:36,936
And Apple has continued invested


175
00:05:36,936 --> 00:05:39,406
improvements to the SDK so that


176
00:05:39,406 --> 00:05:41,646
the Objective-C APIs better


177
00:05:41,686 --> 00:05:44,226
reflect into Swift making better


178
00:05:44,386 --> 00:05:45,456
use of the language and


179
00:05:45,456 --> 00:05:47,006
improving your use of our APIs.


180
00:05:48,266 --> 00:05:49,626
And the other side there's been


181
00:05:49,626 --> 00:05:51,766
a massive effort on under the


182
00:05:51,846 --> 00:05:53,736
hood improvements and changes to


183
00:05:53,736 --> 00:05:55,636
the runtime towards this binary


184
00:05:55,636 --> 00:05:58,156
compatibility goal, which


185
00:05:58,156 --> 00:06:01,946
culminates in Swift 5, which


186
00:06:01,946 --> 00:06:04,916
will be released in early 2019.


187
00:06:05,926 --> 00:06:07,486
So what is binary compatibility?


188
00:06:08,406 --> 00:06:09,806
Binary compatibility means that


189
00:06:09,806 --> 00:06:11,536
you can build your Swift code


190
00:06:11,576 --> 00:06:12,996
with the Swift 5 compiler and


191
00:06:12,996 --> 00:06:13,286
layer.


192
00:06:13,286 --> 00:06:15,036
And at the binary level it will


193
00:06:15,036 --> 00:06:16,626
be able to interoperate with


194
00:06:16,696 --> 00:06:17,866
other code built with that


195
00:06:17,866 --> 00:06:19,686
compiler or any other compiler


196
00:06:19,686 --> 00:06:20,016
layer.


197
00:06:20,496 --> 00:06:22,266
This is a very important


198
00:06:22,266 --> 00:06:23,966
milestone for the maturity of


199
00:06:23,966 --> 00:06:24,506
the language.


200
00:06:25,146 --> 00:06:26,606
And what this will enable is


201
00:06:26,606 --> 00:06:28,436
Apple to shift the Swift runtime


202
00:06:28,586 --> 00:06:30,746
in the operating system, which


203
00:06:30,746 --> 00:06:32,156
means apps can directly use it,


204
00:06:32,576 --> 00:06:33,496
meaning that they no longer need


205
00:06:33,496 --> 00:06:34,666
it included in the application


206
00:06:34,666 --> 00:06:34,976
bundle.


207
00:06:35,346 --> 00:06:37,446
So this is a code size win but


208
00:06:37,446 --> 00:06:38,966
it's also important that it


209
00:06:38,966 --> 00:06:40,146
impacts things like startup


210
00:06:40,146 --> 00:06:42,286
time, memory usage, it's an


211
00:06:42,286 --> 00:06:43,646
overall huge win for the


212
00:06:43,646 --> 00:06:44,056
community.


213
00:06:44,056 --> 00:06:46,876
If you're -- we've been very


214
00:06:46,876 --> 00:06:48,046
transparent on the progress


215
00:06:48,286 --> 00:06:50,196
towards ABI stability or binary


216
00:06:50,196 --> 00:06:50,906
compatibility.


217
00:06:51,286 --> 00:06:52,826
You can follow along on the ABI


218
00:06:52,826 --> 00:06:54,366
stability dashboard on


219
00:06:54,406 --> 00:06:55,806
Swift.org.


220
00:06:57,696 --> 00:07:00,186
Today's focus is on Swift 4.2,


221
00:07:00,186 --> 00:07:01,596
which is an important waypoint


222
00:07:01,916 --> 00:07:02,696
toward Swift 5.


223
00:07:03,426 --> 00:07:05,446
Let's talk about source


224
00:07:05,446 --> 00:07:06,166
compatibility.


225
00:07:07,526 --> 00:07:10,106
So just like in Xcode 9, Xcode


226
00:07:10,166 --> 00:07:12,026
10 shifts with one Swift


227
00:07:12,226 --> 00:07:12,696
compiler.


228
00:07:13,686 --> 00:07:15,086
So if you're using Xcode 10, you


229
00:07:15,086 --> 00:07:16,256
are using Swift 4.2.


230
00:07:17,226 --> 00:07:19,716
However, just like in Xcode 9,


231
00:07:20,276 --> 00:07:21,746
the compiler also supports


232
00:07:22,236 --> 00:07:23,896
multiple language compatibility


233
00:07:23,896 --> 00:07:24,366
modes.


234
00:07:25,256 --> 00:07:27,026
Now in all the modes you can use


235
00:07:27,116 --> 00:07:27,906
all the new APIs.


236
00:07:28,676 --> 00:07:29,926
You can use all the new language


237
00:07:29,926 --> 00:07:30,476
features.


238
00:07:30,856 --> 00:07:31,676
What these gate are


239
00:07:31,676 --> 00:07:33,476
source-impacting changes.


240
00:07:34,036 --> 00:07:37,286
The first two are ones that


241
00:07:37,286 --> 00:07:39,026
existed previously in Xcode 9.


242
00:07:39,426 --> 00:07:40,676
They're there to provide an out


243
00:07:40,676 --> 00:07:41,776
of the box experience that you


244
00:07:41,776 --> 00:07:43,046
can build your Swift 3 and Swift


245
00:07:43,046 --> 00:07:44,926
4 code without modifications.


246
00:07:45,656 --> 00:07:47,206
The Swift 4.2 mode is almost


247
00:07:47,206 --> 00:07:49,586
identical to the 4 mode except


248
00:07:49,586 --> 00:07:51,216
it gates those SDK improvements


249
00:07:51,476 --> 00:07:52,266
that are talked about.


250
00:07:53,426 --> 00:07:54,346
That's it.


251
00:07:54,976 --> 00:07:57,026
Just some previous versions of


252
00:07:57,086 --> 00:07:58,526
Xcode, there's Migrator Support


253
00:07:58,526 --> 00:07:59,436
that you can find in the edit


254
00:07:59,436 --> 00:08:01,116
menu to mechanize most of your


255
00:08:01,116 --> 00:08:01,556
changes.


256
00:08:02,806 --> 00:08:03,876
I want to give an important


257
00:08:03,876 --> 00:08:06,166
disclaimer about the Swift 4.2


258
00:08:06,306 --> 00:08:07,146
SDK changes.


259
00:08:07,496 --> 00:08:09,436
Later Xcode 10 betas will likely


260
00:08:09,436 --> 00:08:11,036
have further SDK improvements.


261
00:08:11,416 --> 00:08:13,206
This is to provide opportunities


262
00:08:13,206 --> 00:08:14,916
to incorporate you feedback from


263
00:08:14,916 --> 00:08:16,976
the betas of how these APIs


264
00:08:16,976 --> 00:08:18,676
should be improved and how they


265
00:08:18,676 --> 00:08:19,626
reflect into Swift.


266
00:08:20,236 --> 00:08:22,246
This means if you migrate to 4.2


267
00:08:22,416 --> 00:08:23,926
early, you should expect there


268
00:08:23,926 --> 00:08:24,806
are going to be some changes


269
00:08:24,806 --> 00:08:25,096
later.


270
00:08:25,576 --> 00:08:27,166
Or you can hold off and migrate


271
00:08:27,196 --> 00:08:27,446
later.


272
00:08:27,836 --> 00:08:28,816
It's completely up to you.


273
00:08:30,616 --> 00:08:32,176
Now with Swift 4.2 we think we


274
00:08:32,176 --> 00:08:34,126
are rapidly converging on what


275
00:08:34,166 --> 00:08:35,476
Swift code is going to look like


276
00:08:35,876 --> 00:08:36,635
going forward.


277
00:08:36,666 --> 00:08:39,155
This is an important phase in


278
00:08:39,155 --> 00:08:40,716
the maturation of the language.


279
00:08:41,506 --> 00:08:43,046
And thus we really think it's


280
00:08:43,046 --> 00:08:44,596
important for everyone to move


281
00:08:44,596 --> 00:08:47,486
off of Swift 3 and embrace using


282
00:08:47,486 --> 00:08:48,086
Swift 4.2.


283
00:08:48,086 --> 00:08:49,216
There are important code size


284
00:08:49,216 --> 00:08:50,456
improvements there and just


285
00:08:50,456 --> 00:08:51,396
overall improvements to the


286
00:08:51,396 --> 00:08:52,006
language.


287
00:08:52,836 --> 00:08:54,106
And this is Xcode 10 is going to


288
00:08:54,156 --> 00:08:55,636
be the last release to support


289
00:08:55,636 --> 00:08:58,916
that Swift 3 compatibility mode.


290
00:08:59,586 --> 00:09:00,506
So let's talk about some


291
00:09:00,506 --> 00:09:01,446
improvements to the tooling.


292
00:09:02,536 --> 00:09:04,076
In the State of the Union we


293
00:09:04,076 --> 00:09:05,006
mentioned that there are some


294
00:09:05,106 --> 00:09:06,206
significant improvements to


295
00:09:06,206 --> 00:09:07,416
build improvement for Swift


296
00:09:07,416 --> 00:09:09,366
projects over Xcode 9.


297
00:09:10,176 --> 00:09:12,176
And so these numbers are run on


298
00:09:12,176 --> 00:09:13,516
a 4-Core MacBook Pro i7.


299
00:09:13,516 --> 00:09:16,946
Let's look a little bit closer


300
00:09:16,946 --> 00:09:17,416
at one of them.


301
00:09:18,896 --> 00:09:20,456
This project is a mix and match


302
00:09:20,456 --> 00:09:21,776
of Objective-C in Swift.


303
00:09:22,066 --> 00:09:23,406
It started out as an Objective-C


304
00:09:23,406 --> 00:09:24,666
project and started


305
00:09:24,666 --> 00:09:25,526
incorporating Swift.


306
00:09:26,216 --> 00:09:27,786
This is a very common scenario.


307
00:09:28,756 --> 00:09:29,576
Now what this Build time


308
00:09:29,576 --> 00:09:32,156
improvement doesn't really


309
00:09:32,156 --> 00:09:33,826
underscore is how much faster


310
00:09:33,876 --> 00:09:34,736
building this Swift Code


311
00:09:34,736 --> 00:09:35,536
actually became.


312
00:09:36,356 --> 00:09:37,526
So if we just focus on how much


313
00:09:37,526 --> 00:09:39,826
faster the Swift code built, it


314
00:09:39,826 --> 00:09:41,146
actually builds three times


315
00:09:41,226 --> 00:09:42,896
faster than it did before.


316
00:09:43,386 --> 00:09:44,776
And so that's why the project


317
00:09:45,046 --> 00:09:47,086
has that more modest 1.6x


318
00:09:47,186 --> 00:09:47,536
speedup.


319
00:09:49,656 --> 00:09:51,096
And what you will see is that


320
00:09:51,096 --> 00:09:52,216
the overall build improvements


321
00:09:52,216 --> 00:09:53,706
will depend on the nature of


322
00:09:53,706 --> 00:09:54,766
your project, how much Swift


323
00:09:54,766 --> 00:09:56,816
code it's using, the number of


324
00:09:56,816 --> 00:09:58,606
cores on your machine, but we've


325
00:09:58,766 --> 00:10:00,146
in practice have seen from many


326
00:10:00,146 --> 00:10:01,476
projects it's a 2x speedup.


327
00:10:02,416 --> 00:10:04,366
And the win comes from observing


328
00:10:04,366 --> 00:10:06,326
that because within a Swift


329
00:10:06,326 --> 00:10:08,286
target you have cross-file


330
00:10:08,286 --> 00:10:09,846
visibility, right, that's one of


331
00:10:09,846 --> 00:10:10,896
the great features of Swift


332
00:10:10,896 --> 00:10:11,626
where you don't need header


333
00:10:11,696 --> 00:10:11,946
files.


334
00:10:12,606 --> 00:10:13,976
There was a lot of redundant


335
00:10:13,976 --> 00:10:15,586
work being done by the compiler.


336
00:10:15,586 --> 00:10:17,056
And what we've done is we've


337
00:10:17,056 --> 00:10:18,346
retooled the compilation


338
00:10:18,346 --> 00:10:20,136
pipeline to reduce a lot of this


339
00:10:20,136 --> 00:10:21,626
redundant work and make better


340
00:10:21,626 --> 00:10:22,516
use of the cores on your


341
00:10:22,516 --> 00:10:22,936
machine.


342
00:10:23,096 --> 00:10:23,996
And that's where these speedups


343
00:10:24,076 --> 00:10:24,466
come from.


344
00:10:25,206 --> 00:10:26,116
If you're interested in more


345
00:10:26,116 --> 00:10:27,616
details there's these two great


346
00:10:27,616 --> 00:10:28,886
talks later this week that dive


347
00:10:28,886 --> 00:10:30,346
into how the build process works


348
00:10:30,396 --> 00:10:31,846
under the book including more


349
00:10:31,846 --> 00:10:32,906
details about where this


350
00:10:32,946 --> 00:10:34,146
performance win comes from.


351
00:10:36,356 --> 00:10:37,906
Now this big win comes from


352
00:10:38,606 --> 00:10:40,526
debug builds.


353
00:10:41,566 --> 00:10:44,776
I want to focus on how this is


354
00:10:44,776 --> 00:10:47,336
surfacing in the Xcode build


355
00:10:47,396 --> 00:10:47,846
settings.


356
00:10:48,746 --> 00:10:49,926
Recently we separated out


357
00:10:49,926 --> 00:10:51,386
compilation mode from


358
00:10:51,386 --> 00:10:52,506
optimization level.


359
00:10:53,206 --> 00:10:55,286
Compilation mode is how your


360
00:10:55,286 --> 00:10:56,726
project builds.


361
00:10:57,256 --> 00:10:58,566
So for release builds the


362
00:10:58,566 --> 00:10:59,566
default is whole module


363
00:10:59,566 --> 00:11:01,446
compilation that means all the


364
00:11:01,446 --> 00:11:02,906
files within your target are


365
00:11:02,906 --> 00:11:04,226
always built together.


366
00:11:04,386 --> 00:11:05,836
This is to enable maximum


367
00:11:05,836 --> 00:11:07,326
opportunities for optimization.


368
00:11:07,326 --> 00:11:08,676
It's not the amount of


369
00:11:08,676 --> 00:11:09,756
optimization done but the


370
00:11:09,756 --> 00:11:11,366
opportunities for optimization.


371
00:11:12,166 --> 00:11:14,146
And for Debug builds the default


372
00:11:14,146 --> 00:11:15,176
is incremental.


373
00:11:15,386 --> 00:11:16,486
That means not all the files are


374
00:11:16,486 --> 00:11:18,256
all built, re-built always all


375
00:11:18,256 --> 00:11:18,626
together.


376
00:11:19,616 --> 00:11:20,506
So this is a tradeoff in


377
00:11:20,506 --> 00:11:22,536
performance for build times.


378
00:11:23,516 --> 00:11:24,826
Optimization level for Debug


379
00:11:24,826 --> 00:11:25,746
builds continues to be no


380
00:11:25,746 --> 00:11:26,966
optimization by default.


381
00:11:26,966 --> 00:11:27,946
This is for faster builds and


382
00:11:27,946 --> 00:11:29,806
better Debug information and the


383
00:11:29,806 --> 00:11:31,816
release builds are optimized for


384
00:11:31,816 --> 00:11:32,096
speed.


385
00:11:32,636 --> 00:11:33,186
We'll get back to the


386
00:11:33,186 --> 00:11:35,076
optimization level in a few


387
00:11:35,076 --> 00:11:35,306
minutes.


388
00:11:38,436 --> 00:11:41,886
All right so this separation of


389
00:11:41,886 --> 00:11:42,696
compilation mode and


390
00:11:42,696 --> 00:11:45,296
optimization level nicely


391
00:11:45,356 --> 00:11:46,516
highlights and interesting


392
00:11:46,516 --> 00:11:48,096
stopgap measure that various


393
00:11:48,096 --> 00:11:50,176
folds discovered that when they


394
00:11:50,176 --> 00:11:51,126
combined whole module


395
00:11:51,126 --> 00:11:53,946
compilation with no optimization


396
00:11:53,946 --> 00:11:54,876
that they sometimes would get


397
00:11:55,036 --> 00:11:56,026
faster Debug builds.


398
00:11:56,966 --> 00:11:58,786
And this is because that


399
00:11:58,786 --> 00:12:00,756
combination reduces a lot of


400
00:12:00,756 --> 00:12:02,246
that redundant work that I


401
00:12:02,246 --> 00:12:04,136
talked about before that we have


402
00:12:04,136 --> 00:12:05,986
no made great efforts to


403
00:12:06,126 --> 00:12:08,336
eliminate or significantly


404
00:12:08,336 --> 00:12:08,666
reduce.


405
00:12:10,036 --> 00:12:10,926
The problem with this


406
00:12:10,926 --> 00:12:12,496
combination is, is it impedes


407
00:12:12,496 --> 00:12:13,296
incremental builds.


408
00:12:13,506 --> 00:12:14,716
So anytime you touch a file


409
00:12:14,716 --> 00:12:16,206
within a target the whole target


410
00:12:16,206 --> 00:12:16,806
gets rebuilt.


411
00:12:17,496 --> 00:12:18,836
Now with the improvements in


412
00:12:18,836 --> 00:12:20,406
Xcode 10 to Debug builds, we


413
00:12:20,406 --> 00:12:21,936
feel you no longer need to use


414
00:12:21,986 --> 00:12:24,416
the stopgap measure and we have


415
00:12:24,416 --> 00:12:25,626
observed that the default


416
00:12:25,626 --> 00:12:27,316
incremental builds are at least


417
00:12:27,316 --> 00:12:29,036
as good as this combination or


418
00:12:29,036 --> 00:12:29,356
better.


419
00:12:29,356 --> 00:12:30,406
Especially since they support


420
00:12:30,406 --> 00:12:30,976
incremental builds.


421
00:12:34,696 --> 00:12:35,826
Let's talk about some important


422
00:12:35,826 --> 00:12:37,006
under the hood runtime


423
00:12:37,006 --> 00:12:38,256
optimizations and this is all


424
00:12:38,256 --> 00:12:39,356
part of that march towards


425
00:12:39,406 --> 00:12:40,586
binary compatibility.


426
00:12:43,436 --> 00:12:45,126
Swift uses automatic memory


427
00:12:45,126 --> 00:12:47,726
management and it uses reference


428
00:12:47,726 --> 00:12:49,236
counting just like Objective-C


429
00:12:49,386 --> 00:12:51,026
for managing object instances.


430
00:12:51,916 --> 00:12:53,526
On this slide I've illustrated


431
00:12:53,526 --> 00:12:54,786
in comments where the compiler


432
00:12:54,786 --> 00:12:56,426
inserts, retains, and releases.


433
00:12:57,516 --> 00:12:58,786
This is how it behaved in Swift


434
00:12:58,786 --> 00:13:02,116
4.1.


435
00:13:02,316 --> 00:13:03,276
When an object is created


436
00:13:03,276 --> 00:13:04,716
there's a +1 reference account


437
00:13:04,716 --> 00:13:05,896
associated with it.


438
00:13:05,896 --> 00:13:08,176
What the convention was if the


439
00:13:08,176 --> 00:13:09,596
object is passed off as an


440
00:13:09,596 --> 00:13:10,806
argument to another function,


441
00:13:11,286 --> 00:13:12,406
it's the obligation of that


442
00:13:12,466 --> 00:13:14,046
function call to release the


443
00:13:14,046 --> 00:13:14,526
object.


444
00:13:14,986 --> 00:13:16,626
So it's basically you're passing


445
00:13:16,626 --> 00:13:18,036
off the responsibility to the


446
00:13:18,036 --> 00:13:19,406
call to release it.


447
00:13:20,376 --> 00:13:21,556
This provided some performance


448
00:13:21,556 --> 00:13:22,926
opportunities to shrink the


449
00:13:22,926 --> 00:13:25,156
lifetime of some objects to like


450
00:13:25,156 --> 00:13:26,936
their smallest range of use.


451
00:13:27,806 --> 00:13:29,976
However, code often looks more


452
00:13:30,056 --> 00:13:32,076
like this where you're passing


453
00:13:32,076 --> 00:13:33,886
the object off several times to


454
00:13:34,276 --> 00:13:35,236
different APIs.


455
00:13:35,906 --> 00:13:37,096
And because you have this


456
00:13:37,136 --> 00:13:38,856
calling convention, you still


457
00:13:38,856 --> 00:13:40,226
have this dance where the


458
00:13:40,226 --> 00:13:41,316
initial reference count is


459
00:13:41,366 --> 00:13:42,466
balanced out with the final


460
00:13:42,516 --> 00:13:43,066
call.


461
00:13:43,466 --> 00:13:44,666
But the intermediate calls are


462
00:13:44,666 --> 00:13:45,776
expected to have these extra


463
00:13:45,776 --> 00:13:48,246
retains and releases because


464
00:13:48,246 --> 00:13:49,956
that's what a convention is.


465
00:13:50,876 --> 00:13:52,406
This is really wasteful because


466
00:13:52,626 --> 00:13:53,886
the object is really just going


467
00:13:53,886 --> 00:13:55,156
to be alive during the entire


468
00:13:55,156 --> 00:13:57,106
duration of this function.


469
00:13:57,816 --> 00:13:59,876
So in Swift 4.2 we changed the


470
00:13:59,876 --> 00:14:01,396
calling convention so that it


471
00:14:01,396 --> 00:14:02,606
was no longer the callee's


472
00:14:02,606 --> 00:14:04,296
obligation to release the


473
00:14:04,296 --> 00:14:04,806
object.


474
00:14:05,206 --> 00:14:06,526
This means all these retains and


475
00:14:06,526 --> 00:14:10,366
releases go away, which is a


476
00:14:10,606 --> 00:14:12,066
significant reduction in


477
00:14:12,066 --> 00:14:13,016
retained release traffic.


478
00:14:13,936 --> 00:14:15,076
This has two implications.


479
00:14:15,546 --> 00:14:16,916
It's both a code size win


480
00:14:16,986 --> 00:14:19,026
because those calls are gone and


481
00:14:19,026 --> 00:14:20,336
it has a runtime improvement.


482
00:14:21,776 --> 00:14:24,746
Another important optimization


483
00:14:24,746 --> 00:14:25,746
we did was to string.


484
00:14:26,186 --> 00:14:28,506
And Swift 4.2 string is now 16


485
00:14:28,506 --> 00:14:29,746
bytes big where it as previously


486
00:14:29,746 --> 00:14:30,316
24.


487
00:14:30,756 --> 00:14:31,976
We feel this is a good tradeoff


488
00:14:31,976 --> 00:14:33,266
between memory usage and


489
00:14:33,266 --> 00:14:33,936
performance.


490
00:14:35,346 --> 00:14:37,356
It's also, however, still large


491
00:14:37,356 --> 00:14:38,936
enough to do an important small


492
00:14:38,936 --> 00:14:40,026
string optimization.


493
00:14:40,706 --> 00:14:42,746
If the string fits within 15


494
00:14:42,746 --> 00:14:45,226
bytes then the actual string is


495
00:14:45,226 --> 00:14:46,636
represented directly in the


496
00:14:46,636 --> 00:14:48,246
string type without going to the


497
00:14:48,246 --> 00:14:49,306
heap to allocate a separate


498
00:14:49,306 --> 00:14:50,806
buffer to represent the string.


499
00:14:51,436 --> 00:14:53,456
This is obviously also a memory


500
00:14:53,456 --> 00:14:55,066
win and a performance win.


501
00:14:55,716 --> 00:14:56,546
This is as similar to an


502
00:14:56,546 --> 00:14:57,866
optimization that exists within


503
00:14:57,866 --> 00:14:58,286
a string.


504
00:14:58,586 --> 00:14:59,986
We can actually represent larger


505
00:14:59,986 --> 00:15:00,516
strings.


506
00:15:03,396 --> 00:15:05,096
Finally before I hand it off to


507
00:15:05,156 --> 00:15:06,126
Slava we'll talk about the


508
00:15:06,126 --> 00:15:07,086
language improvements.


509
00:15:07,086 --> 00:15:08,576
I want to talk a little bit more


510
00:15:08,576 --> 00:15:10,216
about the efforts to reduce code


511
00:15:10,216 --> 00:15:10,636
size.


512
00:15:12,176 --> 00:15:13,146
I talked a little bit about that


513
00:15:13,146 --> 00:15:14,586
calling convention change, which


514
00:15:14,586 --> 00:15:15,826
reduces code size.


515
00:15:15,826 --> 00:15:17,546
But we've also introduced a new


516
00:15:17,546 --> 00:15:19,936
optimization level, Optimize for


517
00:15:19,936 --> 00:15:20,256
Size.


518
00:15:21,466 --> 00:15:22,366
This can be useful for


519
00:15:22,366 --> 00:15:23,986
applications that care very much


520
00:15:24,056 --> 00:15:25,966
about app size limits such as


521
00:15:25,966 --> 00:15:27,216
from cellular over the air


522
00:15:27,216 --> 00:15:28,056
download limits.


523
00:15:29,146 --> 00:15:30,626
Swift is a very powerful


524
00:15:30,696 --> 00:15:33,656
language with static knowledge


525
00:15:33,656 --> 00:15:34,846
about what your program does.


526
00:15:35,306 --> 00:15:36,306
And so compiler has many


527
00:15:36,306 --> 00:15:38,626
opportunities to do performance


528
00:15:38,626 --> 00:15:40,016
optimizations such as function


529
00:15:40,016 --> 00:15:41,596
call inlining, speculative


530
00:15:41,596 --> 00:15:43,126
devirtualization, which trade


531
00:15:43,126 --> 00:15:44,326
off a little bit of code size


532
00:15:44,326 --> 00:15:45,846
for more performance, but


533
00:15:45,846 --> 00:15:46,936
sometimes that more performance


534
00:15:47,226 --> 00:15:49,346
isn't really needed in practice.


535
00:15:49,956 --> 00:15:51,726
This is the result of applying


536
00:15:51,786 --> 00:15:52,846
Osize to the Swift Source


537
00:15:52,846 --> 00:15:54,466
Compatibility Suite, which


538
00:15:54,466 --> 00:15:55,546
contains an assortment of


539
00:15:55,546 --> 00:15:57,446
projects from GitHub, frameworks


540
00:15:57,446 --> 00:15:58,266
and applications.


541
00:15:59,156 --> 00:16:00,176
And what you'll see is a wide


542
00:16:00,176 --> 00:16:01,626
range depending on what language


543
00:16:01,626 --> 00:16:03,456
features are used about 10% to


544
00:16:03,456 --> 00:16:05,136
30% reduction in code size.


545
00:16:05,826 --> 00:16:07,206
Now this, when I talk about code


546
00:16:07,206 --> 00:16:07,896
size I'm talking about the


547
00:16:07,896 --> 00:16:09,636
machine code that is generated


548
00:16:09,636 --> 00:16:11,046
as a result of compiling your


549
00:16:11,046 --> 00:16:12,316
Swift code, not the overall app


550
00:16:12,386 --> 00:16:12,676
size.


551
00:16:12,906 --> 00:16:14,206
The overall app size depends on


552
00:16:14,206 --> 00:16:15,466
assets and all sorts of other


553
00:16:15,466 --> 00:16:15,766
stuff.


554
00:16:17,576 --> 00:16:19,416
In practice we observe that


555
00:16:19,416 --> 00:16:20,626
runtime performance is usually


556
00:16:20,626 --> 00:16:21,836
about 5% slower.


557
00:16:21,836 --> 00:16:23,056
So you're trading off for a


558
00:16:23,056 --> 00:16:23,776
little bit of performance.


559
00:16:24,336 --> 00:16:25,766
For many applications this is


560
00:16:25,766 --> 00:16:26,496
totally fine.


561
00:16:26,926 --> 00:16:28,406
So it really depends on your use


562
00:16:28,466 --> 00:16:28,716
case.


563
00:16:29,216 --> 00:16:30,096
But if this is something you're


564
00:16:30,096 --> 00:16:31,516
interested in we encourage you


565
00:16:31,516 --> 00:16:33,956
to give it a try.


566
00:16:34,456 --> 00:16:35,476
With that I'd like to hand it


567
00:16:35,476 --> 00:16:36,916
off to Slava who will talk about


568
00:16:36,916 --> 00:16:37,806
all the great language and


569
00:16:37,806 --> 00:16:39,826
improvements with Swift 4.2


570
00:16:40,516 --> 00:16:45,546
[ Applause ]


571
00:16:46,046 --> 00:16:47,356
>> Hey everybody, I'm Slava


572
00:16:47,356 --> 00:16:47,856
Pestov.


573
00:16:47,896 --> 00:16:49,586
I work on the Swift Compiler and


574
00:16:49,586 --> 00:16:50,886
today I'm going to talk about


575
00:16:50,886 --> 00:16:52,366
how the new language features in


576
00:16:52,366 --> 00:16:54,216
Swift 4.2 allow you to write


577
00:16:54,216 --> 00:16:55,666
simpler and more maintainable


578
00:16:55,666 --> 00:16:55,956
code.


579
00:16:57,556 --> 00:16:59,156
So before we start talking about


580
00:16:59,196 --> 00:17:00,766
the new language changes, let's


581
00:17:00,766 --> 00:17:02,576
review the process for making


582
00:17:02,576 --> 00:17:03,886
improvements to the language.


583
00:17:04,516 --> 00:17:06,506
So as Ted mentioned, Swift is an


584
00:17:06,506 --> 00:17:08,506
open source project, but it also


585
00:17:08,506 --> 00:17:09,556
has an open design.


586
00:17:10,165 --> 00:17:11,435
This means that if you have an


587
00:17:11,435 --> 00:17:13,066
idea for improving the language,


588
00:17:13,386 --> 00:17:14,636
you can go and pitch it on the


589
00:17:14,715 --> 00:17:16,826
forums and if the idea gains


590
00:17:16,826 --> 00:17:18,536
enough traction and crystalizes


591
00:17:18,606 --> 00:17:20,465
into draft proposal, you can


592
00:17:20,465 --> 00:17:21,606
submit it together with


593
00:17:21,606 --> 00:17:23,435
implementation to the core team


594
00:17:23,506 --> 00:17:24,286
for review.


595
00:17:24,626 --> 00:17:26,165
At this point a formal review


596
00:17:26,165 --> 00:17:27,596
period allows members of the


597
00:17:27,626 --> 00:17:28,946
community to give additional


598
00:17:29,016 --> 00:17:30,726
feedback and then the core team


599
00:17:30,726 --> 00:17:32,486
makes a decision as to whether


600
00:17:32,486 --> 00:17:33,606
to accept the proposal.


601
00:17:34,796 --> 00:17:36,196
If you go to the Swift Evolution


602
00:17:36,196 --> 00:17:38,346
website, you can see a list of


603
00:17:38,346 --> 00:17:39,596
all the proposals that were


604
00:17:39,596 --> 00:17:41,286
accepted and implemented in


605
00:17:41,286 --> 00:17:42,406
Swift 4.2.


606
00:17:43,396 --> 00:17:44,976
And if you look at this list of


607
00:17:44,976 --> 00:17:46,646
proposals there's a lot here.


608
00:17:46,646 --> 00:17:47,946
There's more than I can cover


609
00:17:47,946 --> 00:17:48,316
today.


610
00:17:48,776 --> 00:17:50,046
But one thing I really wanted to


611
00:17:50,046 --> 00:17:51,776
emphasize was the large number


612
00:17:51,776 --> 00:17:53,086
of proposals that were both


613
00:17:53,086 --> 00:17:55,476
designed and implemented by the


614
00:17:55,476 --> 00:17:56,136
community.


615
00:17:56,566 --> 00:17:58,066
What this means is that these


616
00:17:58,066 --> 00:17:59,626
proposals address common


617
00:17:59,666 --> 00:18:01,406
pinpoints in the language that


618
00:18:01,406 --> 00:18:03,276
came up in the real world and


619
00:18:03,276 --> 00:18:05,756
you came up with the idea for


620
00:18:05,756 --> 00:18:07,636
fixing these pinpoints and you


621
00:18:07,636 --> 00:18:09,246
contributed these improvements


622
00:18:09,286 --> 00:18:11,126
back to Swift so that everybody


623
00:18:11,126 --> 00:18:11,766
benefits.


624
00:18:12,166 --> 00:18:12,516
Thank you.


625
00:18:14,516 --> 00:18:19,016
[ Applause ]


626
00:18:19,516 --> 00:18:20,936
So for the first improvement


627
00:18:21,126 --> 00:18:22,226
we're going to see how to


628
00:18:22,226 --> 00:18:23,636
eliminate a common source of


629
00:18:23,636 --> 00:18:25,226
boilerplate when working with


630
00:18:25,226 --> 00:18:25,486
enum's.


631
00:18:26,566 --> 00:18:27,896
So let's say I have to find an


632
00:18:27,896 --> 00:18:28,196
enum.


633
00:18:28,616 --> 00:18:30,486
And I want to print every


634
00:18:30,486 --> 00:18:32,096
possible value that this data


635
00:18:32,096 --> 00:18:32,846
type can have.


636
00:18:33,376 --> 00:18:36,286
So in Swift 4, I had to define a


637
00:18:36,286 --> 00:18:38,636
property perhaps with a list of


638
00:18:39,026 --> 00:18:40,386
all the possible cases.


639
00:18:41,056 --> 00:18:44,656
And if I add a new case then I


640
00:18:44,656 --> 00:18:46,016
have to remember to update that


641
00:18:46,086 --> 00:18:48,376
property, otherwise I just get


642
00:18:48,376 --> 00:18:49,706
incorrect behavior or runtime.


643
00:18:50,976 --> 00:18:53,536
And this is just not very good


644
00:18:53,536 --> 00:18:54,936
because you're repeating


645
00:18:54,936 --> 00:18:56,406
yourself to the compiler.


646
00:18:56,986 --> 00:18:59,296
So in Swift 4.2 we've added a


647
00:18:59,296 --> 00:19:01,966
new CaseIterable protocol and if


648
00:19:01,966 --> 00:19:03,346
you state a conformance to this


649
00:19:03,406 --> 00:19:04,726
protocol, the compiler will


650
00:19:04,726 --> 00:19:06,676
synthesize an all cases property


651
00:19:06,676 --> 00:19:07,096
for you.


652
00:19:07,096 --> 00:19:08,976
OK, that was short and sweet.


653
00:19:09,516 --> 00:19:12,546
[ Applause ]


654
00:19:13,046 --> 00:19:15,216
For the next improvement we're


655
00:19:15,216 --> 00:19:16,476
going to see how to eliminate


656
00:19:16,476 --> 00:19:17,806
another source of boilerplate.


657
00:19:18,016 --> 00:19:19,216
This time it's when you're


658
00:19:19,306 --> 00:19:20,436
unable to make your code


659
00:19:20,626 --> 00:19:21,786
sufficiently generic.


660
00:19:22,726 --> 00:19:24,916
So in Swift 4 we have this


661
00:19:24,956 --> 00:19:26,596
contains method on sequence.


662
00:19:27,006 --> 00:19:28,506
And this requires that the


663
00:19:28,506 --> 00:19:30,106
element type of the sequence is


664
00:19:30,106 --> 00:19:32,186
Equatable so that it can find


665
00:19:32,186 --> 00:19:33,376
the element that it's looking


666
00:19:33,446 --> 00:19:33,666
for.


667
00:19:34,636 --> 00:19:36,736
And of course I could call this


668
00:19:36,736 --> 00:19:37,966
within an array of strings


669
00:19:38,236 --> 00:19:39,616
because string is Equatable.


670
00:19:39,616 --> 00:19:41,516
But what if I call it within an


671
00:19:41,516 --> 00:19:42,346
array of arrays.


672
00:19:43,226 --> 00:19:45,736
Well array of Int, the element


673
00:19:45,736 --> 00:19:47,756
type here is not equitable,


674
00:19:48,126 --> 00:19:49,486
which meant that I would just


675
00:19:49,486 --> 00:19:50,596
get a compile time error.


676
00:19:51,796 --> 00:19:53,796
And you might ask, well why


677
00:19:53,796 --> 00:19:55,106
doesn't the standard library


678
00:19:55,196 --> 00:19:56,796
make all arrays Equatable.


679
00:19:57,136 --> 00:19:58,316
But that doesn't make sense


680
00:19:58,316 --> 00:20:00,666
either because if the element


681
00:20:00,666 --> 00:20:01,836
type of the array is not


682
00:20:01,836 --> 00:20:03,366
Equatable, like a function


683
00:20:03,396 --> 00:20:05,056
perhaps, then you can't really


684
00:20:05,056 --> 00:20:06,566
make the array Equatable either.


685
00:20:07,956 --> 00:20:09,286
But certainly if the element


686
00:20:09,326 --> 00:20:10,846
type of the array is Equatable


687
00:20:10,846 --> 00:20:12,726
then I can define an equality


688
00:20:12,726 --> 00:20:14,516
operation on arrays that just


689
00:20:14,516 --> 00:20:16,376
compares the elements pair wise.


690
00:20:17,116 --> 00:20:18,516
And this is what conditional


691
00:20:18,516 --> 00:20:20,116
conformance allows a standard


692
00:20:20,116 --> 00:20:21,286
library to do.


693
00:20:21,376 --> 00:20:23,076
So now array gets an


694
00:20:23,076 --> 00:20:24,916
implementation of Equatable for


695
00:20:24,916 --> 00:20:26,246
the case where the element type


696
00:20:26,246 --> 00:20:27,056
is equitable.


697
00:20:27,416 --> 00:20:29,776
And in Swift 4.2 this example we


698
00:20:29,776 --> 00:20:31,366
saw earlier now works.


699
00:20:31,856 --> 00:20:34,776
And in addition to arrays being


700
00:20:34,776 --> 00:20:36,146
Equatable the standard library


701
00:20:36,146 --> 00:20:37,636
defines a number of other


702
00:20:37,636 --> 00:20:38,896
conditional conformance.


703
00:20:39,436 --> 00:20:41,026
For example, optional and


704
00:20:41,026 --> 00:20:42,726
dictionaries are now Equatable


705
00:20:42,726 --> 00:20:44,126
when their element type is


706
00:20:44,126 --> 00:20:46,486
Equatable and the same works for


707
00:20:46,536 --> 00:20:49,576
Hashable, Encodable, and


708
00:20:49,576 --> 00:20:51,306
Decodable conformances.


709
00:20:52,516 --> 00:20:57,576
[ Applause ]


710
00:20:58,076 --> 00:20:59,746
And this allows you to compose


711
00:20:59,746 --> 00:21:01,156
collections in ways that were


712
00:21:01,156 --> 00:21:02,256
not possible before.


713
00:21:02,986 --> 00:21:05,886
So here I have a set of arrays


714
00:21:05,886 --> 00:21:08,166
of optional integers and


715
00:21:09,176 --> 00:21:10,366
everything just works.


716
00:21:10,916 --> 00:21:13,416
If you want to learn more


717
00:21:13,416 --> 00:21:14,656
there's a session later this


718
00:21:14,656 --> 00:21:17,026
week where you can learn about


719
00:21:17,026 --> 00:21:18,476
conditional conformance and some


720
00:21:18,476 --> 00:21:19,946
other generics improvements in


721
00:21:19,946 --> 00:21:21,256
Swift 4.2 that I won't be


722
00:21:21,256 --> 00:21:22,536
covering today.


723
00:21:23,896 --> 00:21:25,756
So what about defining your own


724
00:21:25,756 --> 00:21:26,776
Equatable and Hashable


725
00:21:26,776 --> 00:21:27,606
conformances.


726
00:21:28,596 --> 00:21:30,376
Well, a common pattern in Swift


727
00:21:30,446 --> 00:21:32,446
is that I have a struct with a


728
00:21:32,446 --> 00:21:34,516
bunch of stored properties and


729
00:21:34,516 --> 00:21:36,006
all those stored properties are


730
00:21:36,006 --> 00:21:37,096
themselves Equatable.


731
00:21:37,436 --> 00:21:38,546
And then I want to make the


732
00:21:38,546 --> 00:21:40,656
struct Equatable just by


733
00:21:40,656 --> 00:21:42,156
comparing those properties of


734
00:21:42,156 --> 00:21:43,056
the two values.


735
00:21:43,516 --> 00:21:45,616
In Swift 4 previously you had to


736
00:21:45,616 --> 00:21:46,726
write this out by hand.


737
00:21:47,166 --> 00:21:48,486
And this is just boilerplate.


738
00:21:48,706 --> 00:21:50,276
If I add a new stored property


739
00:21:50,276 --> 00:21:51,836
to my struct, I have to remember


740
00:21:51,836 --> 00:21:53,286
to update this implementation of


741
00:21:53,286 --> 00:21:54,926
Equatable and it's easy to make


742
00:21:54,926 --> 00:21:56,466
a copy and paste error or some


743
00:21:56,466 --> 00:21:57,166
other mistake.


744
00:21:57,796 --> 00:21:59,676
So in Swift 4.1 we introduce


745
00:21:59,676 --> 00:22:01,536
this ability to synthesize the


746
00:22:01,536 --> 00:22:02,926
implementation of equality.


747
00:22:03,386 --> 00:22:04,966
If you emit the implementation


748
00:22:05,186 --> 00:22:06,326
than the compiler will fill it


749
00:22:06,326 --> 00:22:08,046
in for you as long as all those


750
00:22:08,046 --> 00:22:09,556
stored properties are themselves


751
00:22:09,556 --> 00:22:10,036
Equatable.


752
00:22:11,076 --> 00:22:12,626
This also works for Hashable.


753
00:22:13,996 --> 00:22:15,726
Now what about generic types?


754
00:22:16,266 --> 00:22:17,986
So here I have a data type whose


755
00:22:17,986 --> 00:22:19,556
values are either instances of


756
00:22:19,556 --> 00:22:21,706
the left type or instances of


757
00:22:21,706 --> 00:22:22,316
the right type.


758
00:22:22,936 --> 00:22:24,586
And I might now want to make


759
00:22:24,586 --> 00:22:26,216
left and right constrained to


760
00:22:26,216 --> 00:22:27,776
Equatable because again, I want


761
00:22:27,776 --> 00:22:28,876
to be able to use this either


762
00:22:28,876 --> 00:22:31,046
type with functions, errors, and


763
00:22:31,046 --> 00:22:32,446
other non Equatable types.


764
00:22:32,916 --> 00:22:34,326
But certainly I can define a


765
00:22:34,326 --> 00:22:36,226
conditional conformance so that


766
00:22:36,226 --> 00:22:37,506
if left and right are both


767
00:22:37,506 --> 00:22:39,146
Equatable then either is


768
00:22:39,146 --> 00:22:39,726
Equatable.


769
00:22:40,116 --> 00:22:41,386
But I can do even better than


770
00:22:41,386 --> 00:22:41,696
this.


771
00:22:42,166 --> 00:22:43,666
Notice how the implementation of


772
00:22:43,666 --> 00:22:45,576
equality here there's only


773
00:22:45,576 --> 00:22:47,206
really one obviously correct way


774
00:22:47,206 --> 00:22:47,616
to do it.


775
00:22:47,946 --> 00:22:49,186
You have to check that both


776
00:22:49,186 --> 00:22:51,416
values have the same case and if


777
00:22:51,416 --> 00:22:53,286
they do you check their payloads


778
00:22:53,286 --> 00:22:53,996
for equality.


779
00:22:54,776 --> 00:22:56,396
So you might guess, well the


780
00:22:56,396 --> 00:22:57,426
compiler should be able to


781
00:22:57,426 --> 00:22:58,926
synthesize this for you and it


782
00:22:58,926 --> 00:23:00,256
can in Swift 4.2.


783
00:23:01,176 --> 00:23:02,666
And this also works for


784
00:23:02,666 --> 00:23:03,186
Hashable.


785
00:23:04,676 --> 00:23:07,166
So now I can have a set of


786
00:23:07,356 --> 00:23:09,256
either Int's or strings as one


787
00:23:09,256 --> 00:23:09,786
example.


788
00:23:11,546 --> 00:23:11,656
OK.


789
00:23:12,516 --> 00:23:15,676
[ Applause ]


790
00:23:16,176 --> 00:23:18,146
Now, there are cases where you


791
00:23:18,146 --> 00:23:19,526
really do have to implement


792
00:23:19,586 --> 00:23:22,766
equality and Hashing by hand.


793
00:23:23,436 --> 00:23:25,216
So let's look at one example of


794
00:23:25,216 --> 00:23:25,456
that.


795
00:23:26,616 --> 00:23:27,866
Let's say I have a data type


796
00:23:28,006 --> 00:23:30,796
that represents a city and it's


797
00:23:30,796 --> 00:23:32,166
got a name, it's got the state


798
00:23:32,166 --> 00:23:33,456
that it's located in, and it has


799
00:23:33,456 --> 00:23:34,296
the population.


800
00:23:34,706 --> 00:23:35,556
And let's say that for the


801
00:23:35,556 --> 00:23:38,006
purposes of this example I only


802
00:23:38,006 --> 00:23:39,536
have to compare the name and the


803
00:23:39,536 --> 00:23:41,456
state for equality and if I know


804
00:23:41,456 --> 00:23:42,826
those are equal I don't have to


805
00:23:42,826 --> 00:23:43,926
check the population.


806
00:23:44,616 --> 00:23:46,446
So if I let the compiler


807
00:23:46,446 --> 00:23:48,056
synthesize the implementation of


808
00:23:48,056 --> 00:23:49,706
equality here it's going to do


809
00:23:49,706 --> 00:23:51,046
unnecessary work because it's


810
00:23:51,046 --> 00:23:52,006
going to be comparing that


811
00:23:52,006 --> 00:23:53,046
population field.


812
00:23:53,776 --> 00:23:55,436
But I certainly write it out by


813
00:23:55,436 --> 00:23:56,976
hand and maybe in this case it's


814
00:23:56,976 --> 00:23:57,636
not too bad.


815
00:23:58,556 --> 00:23:59,796
But what about Hashable?


816
00:24:01,286 --> 00:24:02,796
So if I want to calculate the


817
00:24:02,836 --> 00:24:04,566
Hash code of the city object,


818
00:24:05,066 --> 00:24:06,986
then I'm going to calculate the


819
00:24:07,016 --> 00:24:08,336
Hash code of the name and the


820
00:24:08,336 --> 00:24:09,636
Hash code of the state and I


821
00:24:09,636 --> 00:24:11,086
have to combine them somehow.


822
00:24:11,646 --> 00:24:12,686
But how do I do that?


823
00:24:13,296 --> 00:24:15,286
Well, I can use an exclusive or


824
00:24:15,286 --> 00:24:18,246
operation or I could use some


825
00:24:18,246 --> 00:24:20,196
random math formula that I found


826
00:24:20,196 --> 00:24:21,866
on the Internet or just came up


827
00:24:21,866 --> 00:24:22,656
with myself.


828
00:24:23,246 --> 00:24:24,976
But neither one of these is very


829
00:24:24,976 --> 00:24:27,306
satisfying and it feels like


830
00:24:27,306 --> 00:24:28,896
these Hash combining functions


831
00:24:29,176 --> 00:24:30,556
have a lot of magic to them.


832
00:24:30,876 --> 00:24:32,336
And the cost of getting it wrong


833
00:24:32,336 --> 00:24:34,376
is pretty high because the


834
00:24:34,376 --> 00:24:35,846
performance properties that you


835
00:24:35,846 --> 00:24:37,526
expect to get from a dictionary


836
00:24:37,526 --> 00:24:39,716
or a set really rely on having a


837
00:24:39,716 --> 00:24:41,416
good high-quality Hash function.


838
00:24:42,146 --> 00:24:43,956
There's also a security angle


839
00:24:44,016 --> 00:24:44,266
here.


840
00:24:44,636 --> 00:24:46,966
So if an attacker is able to


841
00:24:46,966 --> 00:24:49,336
craft inputs that all Hash to


842
00:24:49,336 --> 00:24:51,086
the same value and send them to


843
00:24:51,086 --> 00:24:52,336
your app over the Internet


844
00:24:52,396 --> 00:24:54,286
somehow, then it might slow your


845
00:24:54,286 --> 00:24:55,466
app down to the point where it


846
00:24:55,466 --> 00:24:56,906
becomes unusable creating a


847
00:24:56,906 --> 00:24:58,056
denial of service attack.


848
00:24:58,536 --> 00:25:01,066
So in Swift 4.2 we've added a


849
00:25:01,066 --> 00:25:02,476
better API for this.


850
00:25:03,316 --> 00:25:05,396
Now recall the Hashable protocol


851
00:25:05,396 --> 00:25:06,896
in Swift 4 and 4.1.


852
00:25:07,486 --> 00:25:09,076
It has a single Hash value


853
00:25:09,076 --> 00:25:10,446
requirement that produces a


854
00:25:10,446 --> 00:25:11,696
single integer value.


855
00:25:12,446 --> 00:25:14,676
In Swift 4.2 we've redesigned


856
00:25:14,676 --> 00:25:16,936
the Hashable protocol so now


857
00:25:17,296 --> 00:25:19,116
there's a different Hash into


858
00:25:19,116 --> 00:25:19,746
requirement.


859
00:25:20,126 --> 00:25:21,346
And instead of producing a


860
00:25:21,346 --> 00:25:23,466
single Hash code value, Hash


861
00:25:23,466 --> 00:25:26,146
into takes a Hasher instance and


862
00:25:26,146 --> 00:25:27,636
then you can feed multiple


863
00:25:27,636 --> 00:25:29,616
values into the Hasher, which


864
00:25:29,616 --> 00:25:31,126
will combine them into one Hash


865
00:25:31,126 --> 00:25:31,376
code.


866
00:25:32,306 --> 00:25:34,096
So going back to our example of


867
00:25:34,096 --> 00:25:36,076
the city data type, all we have


868
00:25:36,076 --> 00:25:38,226
to do is implement Hash into by


869
00:25:38,226 --> 00:25:40,546
recursively calling Hash into on


870
00:25:40,546 --> 00:25:42,576
the name and the state passing


871
00:25:42,576 --> 00:25:44,596
in the Hasher object instance


872
00:25:44,596 --> 00:25:45,316
that we were given.


873
00:25:46,486 --> 00:25:49,786
And the Hash combining algorithm


874
00:25:49,786 --> 00:25:51,726
in the Hasher, it does a good


875
00:25:51,726 --> 00:25:53,526
job of balancing the quality of


876
00:25:53,526 --> 00:25:55,146
the Hash code with performance


877
00:25:55,476 --> 00:25:56,556
and as an added layer of


878
00:25:56,606 --> 00:25:57,816
protection against denial of


879
00:25:57,816 --> 00:25:59,686
service attacks, it uses a


880
00:25:59,686 --> 00:26:01,616
random preprocess seed, which is


881
00:26:01,616 --> 00:26:03,346
generated when your app starts.


882
00:26:05,136 --> 00:26:07,236
And we think that it should be


883
00:26:07,316 --> 00:26:09,136
pretty easy to migrate your code


884
00:26:09,136 --> 00:26:10,746
to using the new Hashable


885
00:26:10,746 --> 00:26:12,256
protocol and we encourage you to


886
00:26:12,256 --> 00:26:12,756
do so.


887
00:26:13,206 --> 00:26:15,016
The one caveat to watch out for


888
00:26:15,016 --> 00:26:16,936
is you might have some code


889
00:26:16,936 --> 00:26:18,746
where you're expecting that Hash


890
00:26:18,746 --> 00:26:20,426
values remain constant from


891
00:26:20,426 --> 00:26:22,296
different runs of your app or


892
00:26:22,296 --> 00:26:23,566
that if you iterate over a


893
00:26:23,566 --> 00:26:25,416
dictionary or a set you're going


894
00:26:25,416 --> 00:26:26,636
to get the elements in the same


895
00:26:26,636 --> 00:26:26,976
order.


896
00:26:27,256 --> 00:26:28,726
And this is no longer the case


897
00:26:28,726 --> 00:26:29,656
because of that random


898
00:26:29,656 --> 00:26:30,676
preprocess seed.


899
00:26:30,746 --> 00:26:31,816
So you will need to fix your


900
00:26:31,816 --> 00:26:32,116
code.


901
00:26:32,916 --> 00:26:35,096
And to make this easier we've


902
00:26:35,096 --> 00:26:37,336
added a build setting, the Swift


903
00:26:37,336 --> 00:26:38,426
Deterministic Hashing


904
00:26:38,426 --> 00:26:39,996
Environment Variable, which you


905
00:26:39,996 --> 00:26:41,666
can enable in the scheme editor


906
00:26:42,246 --> 00:26:43,736
to temporarily disable that


907
00:26:43,786 --> 00:26:45,256
preprocess random seed.


908
00:26:45,796 --> 00:26:49,466
OK, so let's talk about


909
00:26:49,606 --> 00:26:51,096
generating random numbers.


910
00:26:52,396 --> 00:26:53,656
So how do you generate random


911
00:26:53,656 --> 00:26:54,706
numbers in Swift today?


912
00:26:55,356 --> 00:26:57,916
Well, you have to use imported C


913
00:26:57,916 --> 00:26:58,376
APIs.


914
00:26:58,446 --> 00:26:59,876
And this is really not ideal


915
00:26:59,876 --> 00:27:01,446
because they are different


916
00:27:01,446 --> 00:27:03,866
between platforms and they have


917
00:27:03,866 --> 00:27:04,876
different names, different


918
00:27:04,876 --> 00:27:06,586
behavior, so you have to use


919
00:27:06,666 --> 00:27:08,156
build configuration checks.


920
00:27:08,566 --> 00:27:10,486
But also they're quite low level


921
00:27:10,486 --> 00:27:12,806
and these common operations that


922
00:27:12,806 --> 00:27:14,156
are not quite so obvious to


923
00:27:14,156 --> 00:27:14,566
implement.


924
00:27:15,316 --> 00:27:16,886
For example, if I want to get a


925
00:27:16,886 --> 00:27:19,016
random number between 1 and 6,


926
00:27:19,406 --> 00:27:21,446
then I might think to just call


927
00:27:21,446 --> 00:27:23,716
this Darwin arc4random function


928
00:27:23,826 --> 00:27:25,366
and then calculate the remainder


929
00:27:25,366 --> 00:27:26,556
of dividing by 6.


930
00:27:26,836 --> 00:27:27,916
But that actually gives you a


931
00:27:27,916 --> 00:27:29,476
result that is not uniformly


932
00:27:29,476 --> 00:27:31,566
distributed between 1 and 6.


933
00:27:32,346 --> 00:27:35,386
So in Swift 4.2 we've added a


934
00:27:35,386 --> 00:27:37,236
new set of APIs to make this


935
00:27:37,236 --> 00:27:38,086
kind of thing easier.


936
00:27:39,146 --> 00:27:41,186
First of all, all the numeric


937
00:27:41,186 --> 00:27:43,296
types now define a random method


938
00:27:43,486 --> 00:27:45,576
that takes a range and returns a


939
00:27:45,576 --> 00:27:47,326
number uniformly distributed in


940
00:27:47,326 --> 00:27:47,986
that range.


941
00:27:48,196 --> 00:27:49,816
This uses the correct algorithm


942
00:27:49,816 --> 00:27:51,316
and it even works for floats.


943
00:27:52,516 --> 00:27:58,596
[ Applause ]


944
00:27:59,096 --> 00:28:00,676
For higher level code we've


945
00:28:00,676 --> 00:28:03,076
added a random element method to


946
00:28:03,076 --> 00:28:04,196
the collection protocol.


947
00:28:04,786 --> 00:28:07,026
And just like min and max this


948
00:28:07,026 --> 00:28:08,636
returns an optional so that if


949
00:28:08,636 --> 00:28:10,376
you pass in an empty collection


950
00:28:10,526 --> 00:28:11,506
you get back no.


951
00:28:12,596 --> 00:28:14,326
And finally there's a shuffled


952
00:28:14,326 --> 00:28:17,116
method on collection where this


953
00:28:17,116 --> 00:28:18,926
gives you an array with a random


954
00:28:18,926 --> 00:28:20,876
permutation of the elements of


955
00:28:20,876 --> 00:28:21,616
that collection.


956
00:28:22,146 --> 00:28:25,216
And we think the default Random


957
00:28:25,216 --> 00:28:26,636
Number Generator is a good


958
00:28:26,636 --> 00:28:27,996
choice for most apps.


959
00:28:28,296 --> 00:28:29,816
But you can also implement your


960
00:28:29,816 --> 00:28:29,883
own.


961
00:28:30,676 --> 00:28:31,836
So there's a random number


962
00:28:31,836 --> 00:28:34,206
generator protocol and once you


963
00:28:34,206 --> 00:28:35,606
write a type that conforms to


964
00:28:35,606 --> 00:28:37,826
this protocol you can pass it to


965
00:28:37,826 --> 00:28:39,326
all these APIs that I talked


966
00:28:39,326 --> 00:28:40,846
about which have an additional


967
00:28:40,846 --> 00:28:43,416
overload with a using parameter


968
00:28:43,576 --> 00:28:44,706
that takes a random number


969
00:28:44,706 --> 00:28:45,236
generator.


970
00:28:46,746 --> 00:28:49,456
OK, so we saw these build


971
00:28:49,456 --> 00:28:51,446
configuration checks earlier.


972
00:28:51,526 --> 00:28:54,346
Let's talk some more about them.


973
00:28:54,566 --> 00:28:55,896
Well, this is a pretty common


974
00:28:55,896 --> 00:28:56,806
pattern in Swift.


975
00:28:57,026 --> 00:28:58,356
You have a little piece of Swift


976
00:28:58,356 --> 00:29:00,796
code that is shared between iOS


977
00:29:00,796 --> 00:29:03,836
and macOS and on iOS you want to


978
00:29:03,836 --> 00:29:05,206
do something with UIKit.


979
00:29:05,586 --> 00:29:06,776
On macOS you want to do


980
00:29:06,776 --> 00:29:08,156
something similar in AppKit.


981
00:29:08,896 --> 00:29:10,466
So if you want to do this today


982
00:29:10,466 --> 00:29:11,816
you're going to write a #if


983
00:29:12,236 --> 00:29:14,186
compile time condition check and


984
00:29:14,186 --> 00:29:15,386
then you have to list out those


985
00:29:15,386 --> 00:29:17,216
operating systems where UIKit is


986
00:29:17,216 --> 00:29:17,736
available.


987
00:29:18,566 --> 00:29:20,046
So but what you really care


988
00:29:20,046 --> 00:29:21,836
about is not that you're running


989
00:29:21,836 --> 00:29:23,016
on this particular operating


990
00:29:23,016 --> 00:29:24,606
system, but that you can import


991
00:29:24,606 --> 00:29:25,096
UIKit.


992
00:29:25,626 --> 00:29:27,956
So on Swift 4.2 we've added a


993
00:29:27,956 --> 00:29:30,086
has import Build Configuration


994
00:29:30,086 --> 00:29:32,486
Directive so you can better


995
00:29:32,486 --> 00:29:33,476
express your intent.


996
00:29:34,171 --> 00:29:36,171
[ Applause ]


997
00:29:36,326 --> 00:29:38,026
And with the new features of


998
00:29:38,026 --> 00:29:39,686
Swift 4.2, I can actually


999
00:29:39,686 --> 00:29:40,766
improve this code further.


1000
00:29:41,246 --> 00:29:43,326
So let's say that I'm also going


1001
00:29:43,326 --> 00:29:44,966
to explicitly check for AppKit


1002
00:29:45,306 --> 00:29:47,036
and then if neither UIKit nor


1003
00:29:47,036 --> 00:29:48,866
AppKit is available, for example


1004
00:29:48,866 --> 00:29:50,576
if I'm building on Linux, I'm


1005
00:29:50,576 --> 00:29:52,356
going to use the new #error


1006
00:29:52,546 --> 00:29:53,916
build directive to produce a


1007
00:29:53,916 --> 00:29:55,306
friendly compile time error


1008
00:29:55,306 --> 00:29:55,796
message.


1009
00:29:57,206 --> 00:29:59,376
OK, now here's another similar


1010
00:29:59,376 --> 00:30:00,416
source of boilerplate.


1011
00:30:01,616 --> 00:30:03,126
So if I want to compile


1012
00:30:03,126 --> 00:30:05,066
something conditionally when I'm


1013
00:30:05,066 --> 00:30:06,476
in the simulator environment,


1014
00:30:06,776 --> 00:30:09,266
then today in Swift 4 I have to


1015
00:30:09,266 --> 00:30:11,546
copy and paste this ugly thing


1016
00:30:11,546 --> 00:30:12,686
everywhere I want to perform


1017
00:30:12,686 --> 00:30:13,176
that check.


1018
00:30:14,056 --> 00:30:16,456
In Swift 4.2 you can use the new


1019
00:30:16,456 --> 00:30:18,596
hasTargetEnvironment condition,


1020
00:30:18,906 --> 00:30:21,216
to again better state your


1021
00:30:21,216 --> 00:30:23,006
intent and just explicitly ask


1022
00:30:23,006 --> 00:30:25,026
the compiler, am I compiling for


1023
00:30:25,026 --> 00:30:26,106
the simulator or not?


1024
00:30:26,876 --> 00:30:28,826
And while we're at it, let's


1025
00:30:28,826 --> 00:30:30,566
replace that FIXME with a


1026
00:30:30,656 --> 00:30:32,036
#warning build directive to


1027
00:30:32,076 --> 00:30:33,986
produce a message or compile


1028
00:30:34,046 --> 00:30:35,856
time so that I don't forget to


1029
00:30:35,856 --> 00:30:38,126
fix my FIXME.


1030
00:30:38,126 --> 00:30:40,916
OK, so that about wraps up all


1031
00:30:40,916 --> 00:30:42,306
the features that I'm going to


1032
00:30:42,306 --> 00:30:43,516
discuss today, but I have a


1033
00:30:43,516 --> 00:30:44,656
couple more things to talk


1034
00:30:44,656 --> 00:30:44,936
about.


1035
00:30:46,026 --> 00:30:47,646
Let's unwrap, Implicitly


1036
00:30:47,646 --> 00:30:48,586
Unwrapped Optionals.


1037
00:30:48,806 --> 00:30:49,646
That's a horrible pun.


1038
00:30:50,296 --> 00:30:52,986
OK, so Implicitly Unwrapped


1039
00:30:52,986 --> 00:30:54,326
Optionals can be a little bit


1040
00:30:54,326 --> 00:30:57,686
confusing and let's first review


1041
00:30:57,686 --> 00:30:59,246
the mental model for Implicitly


1042
00:30:59,246 --> 00:31:00,196
Unwrapped Optionals.


1043
00:31:00,196 --> 00:31:01,266
How do I think about them?


1044
00:31:01,966 --> 00:31:04,426
Well, so since Swift 3 they're


1045
00:31:04,426 --> 00:31:06,326
not the type of an expression.


1046
00:31:06,816 --> 00:31:08,006
Don't think of it as a type.


1047
00:31:08,446 --> 00:31:09,856
Instead, think of Implicitly


1048
00:31:09,856 --> 00:31:11,256
Unwrapped Optionals as an


1049
00:31:11,256 --> 00:31:13,096
attribute of a declaration.


1050
00:31:13,996 --> 00:31:15,756
And what the compiler does when


1051
00:31:15,756 --> 00:31:17,526
you reference such a declaration


1052
00:31:17,846 --> 00:31:19,186
is it will first try to type


1053
00:31:19,186 --> 00:31:21,536
check it as a plain optional and


1054
00:31:21,536 --> 00:31:23,006
then if that doesn't make sense


1055
00:31:23,006 --> 00:31:24,556
in the context where it's used,


1056
00:31:24,746 --> 00:31:26,916
it goes ahead and unwraps it and


1057
00:31:26,916 --> 00:31:28,096
then type checks it as the


1058
00:31:28,096 --> 00:31:28,876
underlined type.


1059
00:31:30,296 --> 00:31:31,746
So let's look at an example of


1060
00:31:31,746 --> 00:31:32,506
the first case.


1061
00:31:33,236 --> 00:31:34,886
So here I have two functions,


1062
00:31:34,966 --> 00:31:36,596
the first of which produces and


1063
00:31:36,596 --> 00:31:37,906
implicitly unwrapped optional


1064
00:31:37,906 --> 00:31:39,656
integer and the second of which


1065
00:31:39,656 --> 00:31:41,226
takes a value of any type.


1066
00:31:41,836 --> 00:31:43,306
And I'm going to call the second


1067
00:31:43,306 --> 00:31:44,516
function with the result of the


1068
00:31:44,516 --> 00:31:45,256
first function.


1069
00:31:45,916 --> 00:31:47,966
Now in this case I can store an


1070
00:31:47,966 --> 00:31:50,506
optional Int inside of an Any


1071
00:31:50,856 --> 00:31:52,696
and so no forced unwrapping is


1072
00:31:52,696 --> 00:31:53,206
performed.


1073
00:31:53,466 --> 00:31:55,456
The value simply becomes a plain


1074
00:31:55,456 --> 00:31:55,896
optional.


1075
00:31:55,896 --> 00:31:59,156
Let's look at an example of the


1076
00:31:59,156 --> 00:31:59,966
second case now.


1077
00:32:00,876 --> 00:32:02,856
Here, the first function now


1078
00:32:02,856 --> 00:32:05,486
produces -- sorry, the second


1079
00:32:05,486 --> 00:32:07,086
function now takes an integer.


1080
00:32:07,516 --> 00:32:09,066
So when I call the second


1081
00:32:09,066 --> 00:32:10,646
function with the result of the


1082
00:32:10,706 --> 00:32:13,006
first function then I cannot


1083
00:32:13,086 --> 00:32:14,986
pass an optional Int where an


1084
00:32:14,986 --> 00:32:16,126
Int was expected.


1085
00:32:16,596 --> 00:32:18,246
So the compiler has to insert a


1086
00:32:18,246 --> 00:32:21,296
force unwrap and then it all


1087
00:32:21,296 --> 00:32:22,656
works because now I have an Int


1088
00:32:22,836 --> 00:32:26,266
and an Int And this mental model


1089
00:32:26,346 --> 00:32:27,626
makes Implicitly Unwrapped


1090
00:32:27,626 --> 00:32:29,176
Optionals very easy to reason


1091
00:32:29,176 --> 00:32:29,506
about.


1092
00:32:30,206 --> 00:32:32,566
But until recently the compiler


1093
00:32:32,776 --> 00:32:34,166
had some edge cases where it did


1094
00:32:34,166 --> 00:32:35,636
not always follow this model.


1095
00:32:36,316 --> 00:32:38,956
So recall that you cannot have


1096
00:32:38,956 --> 00:32:40,386
an implicitly unwrapped optional


1097
00:32:40,386 --> 00:32:41,696
that is part of another type.


1098
00:32:42,416 --> 00:32:43,706
And this is still the case in


1099
00:32:43,706 --> 00:32:44,646
Swift 4.2.


1100
00:32:44,816 --> 00:32:46,616
I cannot have an array of


1101
00:32:46,676 --> 00:32:48,296
implicitly unwrapped Int's.


1102
00:32:49,136 --> 00:32:51,566
However, in Swift 4 previously,


1103
00:32:51,876 --> 00:32:53,136
there is some edge cases like


1104
00:32:53,186 --> 00:32:53,536
this.


1105
00:32:53,536 --> 00:32:55,606
I could define a type alias


1106
00:32:55,796 --> 00:32:57,596
where the underlying type was


1107
00:32:57,776 --> 00:32:59,606
implicitly unwrapped Int and


1108
00:32:59,606 --> 00:33:00,956
then I could make an array of


1109
00:33:01,016 --> 00:33:03,166
this type alias and I would get


1110
00:33:03,166 --> 00:33:04,756
very confusing behavior from the


1111
00:33:04,756 --> 00:33:06,296
compiler that made code hard to


1112
00:33:06,296 --> 00:33:06,906
understand.


1113
00:33:07,596 --> 00:33:09,516
So in Swift 4.2 we've


1114
00:33:09,516 --> 00:33:10,816
re-implemented Implicitly


1115
00:33:10,816 --> 00:33:12,556
Unwrapped Optional so that it


1116
00:33:12,666 --> 00:33:14,736
exactly matches the mental model


1117
00:33:14,736 --> 00:33:17,186
I outlined earlier and this


1118
00:33:17,386 --> 00:33:19,226
confusing code example now


1119
00:33:19,226 --> 00:33:20,986
generates a compile time warning


1120
00:33:21,306 --> 00:33:23,586
and the compiler parses that as


1121
00:33:23,946 --> 00:33:25,816
if it was just a plain array of


1122
00:33:25,816 --> 00:33:27,576
integers, of optional integers.


1123
00:33:28,546 --> 00:33:30,836
Now, most code will not be


1124
00:33:30,836 --> 00:33:32,266
affected by this change to


1125
00:33:32,266 --> 00:33:33,626
Implicitly Unwrapped Optional,


1126
00:33:34,036 --> 00:33:35,436
but if you were accidentally


1127
00:33:35,436 --> 00:33:37,426
relying on these edge cases I


1128
00:33:37,426 --> 00:33:38,696
encourage you to check out this


1129
00:33:38,746 --> 00:33:41,096
blog post on Swift.org that goes


1130
00:33:41,096 --> 00:33:42,486
into a lot of detail and has a


1131
00:33:42,486 --> 00:33:44,736
lot of examples about what


1132
00:33:44,736 --> 00:33:47,136
changed and how.


1133
00:33:47,376 --> 00:33:49,756
OK, now there's only one more


1134
00:33:49,756 --> 00:33:50,566
thing here today.


1135
00:33:50,986 --> 00:33:52,566
Let's talk about memory


1136
00:33:52,566 --> 00:33:53,866
exclusivity checking.


1137
00:33:55,196 --> 00:33:57,946
So if you recall, in Swift 4 we


1138
00:33:57,946 --> 00:33:59,896
introduced something called


1139
00:33:59,896 --> 00:34:01,386
Memory Exclusivity Checking,


1140
00:34:01,646 --> 00:34:02,896
which was a combination of


1141
00:34:02,956 --> 00:34:05,186
compile time and runtime checks


1142
00:34:05,436 --> 00:34:06,696
that restricted certain


1143
00:34:06,696 --> 00:34:08,856
operations from being performed.


1144
00:34:09,315 --> 00:34:10,976
In particular we banned


1145
00:34:11,286 --> 00:34:13,376
overlapping access to the same


1146
00:34:13,376 --> 00:34:14,356
memory location.


1147
00:34:14,856 --> 00:34:15,656
What does this mean?


1148
00:34:15,815 --> 00:34:17,096
Well, let's look at an example.


1149
00:34:17,666 --> 00:34:20,085
So here's a piece of code that


1150
00:34:20,085 --> 00:34:21,706
implements a data type for


1151
00:34:21,896 --> 00:34:23,246
operating system paths.


1152
00:34:23,766 --> 00:34:25,446
And this is represented as an


1153
00:34:25,565 --> 00:34:27,005
array of path components.


1154
00:34:27,576 --> 00:34:28,815
And there's a withAppended


1155
00:34:28,815 --> 00:34:29,206
method.


1156
00:34:30,216 --> 00:34:31,946
This method adds an element to


1157
00:34:31,946 --> 00:34:33,735
the array, then in calls a


1158
00:34:33,735 --> 00:34:35,806
closure that you pass in and


1159
00:34:35,806 --> 00:34:37,036
then it removes that element


1160
00:34:37,076 --> 00:34:37,626
from the array.


1161
00:34:38,295 --> 00:34:40,036
And this code is totally fine,


1162
00:34:40,036 --> 00:34:41,726
it's a valid Swift 4 code.


1163
00:34:42,755 --> 00:34:44,505
But let's look at this usage of


1164
00:34:44,505 --> 00:34:45,536
our path data type.


1165
00:34:46,545 --> 00:34:47,976
So here I have a path that's


1166
00:34:47,976 --> 00:34:49,746
stored and a local variable and


1167
00:34:50,056 --> 00:34:51,806
then I call withAppended on it


1168
00:34:52,295 --> 00:34:54,856
and inside the closure I access


1169
00:34:54,856 --> 00:34:56,306
that local variable again


1170
00:34:56,536 --> 00:34:57,056
printing it.


1171
00:34:57,556 --> 00:34:58,696
So what the problem here?


1172
00:34:59,436 --> 00:35:01,076
Well, it turns out this code is


1173
00:35:01,076 --> 00:35:03,756
actually ambiguous because when


1174
00:35:03,756 --> 00:35:05,866
I access that local variable


1175
00:35:06,136 --> 00:35:08,436
inside the closure, it's already


1176
00:35:08,436 --> 00:35:10,086
being modified by this


1177
00:35:10,086 --> 00:35:11,686
withAppended method, which is a


1178
00:35:11,686 --> 00:35:12,586
mutating method.


1179
00:35:13,306 --> 00:35:16,136
So the ambiguity is that do I


1180
00:35:16,136 --> 00:35:18,466
mean the original value of path


1181
00:35:18,806 --> 00:35:20,556
as it was before I called


1182
00:35:20,556 --> 00:35:22,706
withAppended or do I mean the


1183
00:35:22,706 --> 00:35:24,106
current value that is being


1184
00:35:24,106 --> 00:35:25,926
modified whatever that means.


1185
00:35:26,756 --> 00:35:28,636
Well, in Swift 4 this was a


1186
00:35:28,636 --> 00:35:30,396
compile time error because it


1187
00:35:30,396 --> 00:35:32,226
was an exclusivity violation.


1188
00:35:32,756 --> 00:35:34,716
And one way to address this is


1189
00:35:34,716 --> 00:35:35,976
to resolve the ambiguity by


1190
00:35:35,976 --> 00:35:37,926
telling the complier, hey I


1191
00:35:37,926 --> 00:35:40,496
really want the new value so I'm


1192
00:35:40,496 --> 00:35:41,766
going to just pass it in as a


1193
00:35:41,766 --> 00:35:43,636
parameter to the closure instead


1194
00:35:43,636 --> 00:35:44,986
of capturing it.


1195
00:35:45,586 --> 00:35:47,366
OK, but now look at this


1196
00:35:47,366 --> 00:35:47,936
example.


1197
00:35:48,266 --> 00:35:49,586
So this is almost the same


1198
00:35:49,586 --> 00:35:51,376
function except that it's


1199
00:35:51,376 --> 00:35:53,326
generic, it's prioritized by the


1200
00:35:53,326 --> 00:35:54,646
return type of the closure.


1201
00:35:55,306 --> 00:35:57,436
And in this case we can have the


1202
00:35:57,436 --> 00:35:59,286
same kind of ambiguity by


1203
00:35:59,286 --> 00:36:01,246
accessing the path value from


1204
00:36:01,246 --> 00:36:02,166
inside the closure.


1205
00:36:02,496 --> 00:36:04,766
But previously Swift 4 did not


1206
00:36:04,766 --> 00:36:06,556
catch this error at compile


1207
00:36:06,616 --> 00:36:06,866
time.


1208
00:36:08,286 --> 00:36:10,436
In Swift 4.2 we've improved the


1209
00:36:10,436 --> 00:36:12,526
static exclusivity checking to


1210
00:36:12,526 --> 00:36:14,446
catch ambiguities like this in


1211
00:36:14,446 --> 00:36:15,256
more cases.


1212
00:36:16,386 --> 00:36:18,546
And in addition to improving --


1213
00:36:19,146 --> 00:36:20,526
OK, and you can also fix the


1214
00:36:20,526 --> 00:36:22,236
ambiguity in the same way by


1215
00:36:22,236 --> 00:36:23,566
passing it as a parameter to the


1216
00:36:23,566 --> 00:36:24,026
closure.


1217
00:36:24,576 --> 00:36:26,876
In addition to improving the


1218
00:36:26,876 --> 00:36:28,986
static checks, we've also added


1219
00:36:28,986 --> 00:36:30,796
the ability to use the runtime


1220
00:36:30,796 --> 00:36:32,456
exclusivity checks and release


1221
00:36:32,456 --> 00:36:32,906
builds.


1222
00:36:33,336 --> 00:36:35,166
And this has some overhead but


1223
00:36:35,166 --> 00:36:36,606
if your app is not performance


1224
00:36:36,606 --> 00:36:38,096
critical, we encourage you to


1225
00:36:38,096 --> 00:36:39,746
try this out and leave it on all


1226
00:36:39,746 --> 00:36:40,216
the time.


1227
00:36:40,686 --> 00:36:42,386
In the future, we will get the


1228
00:36:42,386 --> 00:36:44,236
overhead of these dynamic checks


1229
00:36:44,306 --> 00:36:46,276
down to the point where we can


1230
00:36:46,276 --> 00:36:48,126
leave this enabled all the time


1231
00:36:48,186 --> 00:36:49,226
and it will give you an extra


1232
00:36:49,226 --> 00:36:50,846
level of protection just like


1233
00:36:50,896 --> 00:36:53,296
array bounce checking or integer


1234
00:36:53,296 --> 00:36:54,596
overflow checking today.


1235
00:36:55,166 --> 00:36:58,316
And there's a lot more in Swift


1236
00:36:58,316 --> 00:37:00,426
4.2 that I didn't talk about


1237
00:37:01,236 --> 00:37:01,576
today.


1238
00:37:02,096 --> 00:37:03,716
And we encourage you to try it


1239
00:37:03,716 --> 00:37:05,496
out on your existing apps.


1240
00:37:05,546 --> 00:37:06,776
We also want you to try out the


1241
00:37:06,776 --> 00:37:08,536
new features and if you have any


1242
00:37:08,536 --> 00:37:10,056
questions please come to the


1243
00:37:10,056 --> 00:37:11,966
labs and ask us.


1244
00:37:12,556 --> 00:37:12,956
Thank you.


1245
00:37:14,516 --> 00:37:19,500
[ Applause ]

