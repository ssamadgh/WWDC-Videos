1
00:00:21,516 --> 00:00:25,846
[Applause]


2
00:00:26,346 --> 00:00:27,886
>> IVAN KRSTIC: My name is
Ivan, and I head the Security


3
00:00:27,886 --> 00:00:31,686
and Privacy Strategy group at
Apple, and today we are going


4
00:00:31,686 --> 00:00:32,555
to talk about security.


5
00:00:32,555 --> 00:00:36,846
And, in fact, most of
today's talk will focus


6
00:00:36,846 --> 00:00:38,626
on security on devices.


7
00:00:39,436 --> 00:00:42,046
Now, as you know, we
have a very strong lineup


8
00:00:42,046 --> 00:00:43,906
of device security
features, some of them unique


9
00:00:43,966 --> 00:00:47,356
to OS X others to iOS, and some
present on both our platforms.


10
00:00:47,456 --> 00:00:50,446
We are continually working to
make these features better,


11
00:00:50,446 --> 00:00:52,126
and you're going
to see us continue


12
00:00:52,126 --> 00:00:54,046
to relentlessly innovate
in this space.


13
00:00:54,736 --> 00:00:57,256
But I'm actually here today to
have a brief interlude with you


14
00:00:57,366 --> 00:00:58,476
about network security.


15
00:00:58,476 --> 00:01:02,376
When we think about network
security most of you think


16
00:01:02,376 --> 00:01:05,135
of HTTPS, which most
of us experience


17
00:01:05,135 --> 00:01:06,846
as the lock icon in the browser.


18
00:01:07,996 --> 00:01:13,076
It used to be that
websites used HTTPS and TLS


19
00:01:13,286 --> 00:01:15,476
if they were transmitting
sensitive information.


20
00:01:16,836 --> 00:01:18,706
But we no longer think of things


21
00:01:18,706 --> 00:01:20,496
like credit card
information as sensitive.


22
00:01:20,496 --> 00:01:24,166
In fact, today we think of
all kinds of user information


23
00:01:24,296 --> 00:01:26,386
as being sensitive, and
even some things that you


24
00:01:26,386 --> 00:01:29,496
as a developer may not think
of as sensitive, a user may.


25
00:01:31,436 --> 00:01:33,356
One other really
important thing about TLS


26
00:01:33,356 --> 00:01:34,866
that we don't often
think about is


27
00:01:34,866 --> 00:01:37,756
that it doesn't just protect
the secrecy of information


28
00:01:37,756 --> 00:01:39,056
as it moves across the network.


29
00:01:39,666 --> 00:01:41,876
It also protects the
integrity of those connections.


30
00:01:42,766 --> 00:01:44,896
And the threats on the
network have changed.


31
00:01:45,866 --> 00:01:48,856
It's no longer just someone
wearing a black ski mask hiding


32
00:01:48,856 --> 00:01:50,096
on some corner of
the Internet trying


33
00:01:50,096 --> 00:01:51,336
to get your credit card numbers.


34
00:01:51,466 --> 00:01:53,936
In fact, users may want
to protect themselves


35
00:01:53,936 --> 00:01:55,196
against other kinds of threats.


36
00:01:55,606 --> 00:01:58,256
For example, Internet
service providers


37
00:01:58,256 --> 00:02:00,826
that are injecting tracking
headers into every request,


38
00:02:01,186 --> 00:02:03,476
or even outright
recording browsing histories


39
00:02:03,526 --> 00:02:04,566
to support ad targeting.


40
00:02:04,566 --> 00:02:09,795
So in 2015 we believe that TLS
is really a minimum base line


41
00:02:09,866 --> 00:02:11,856
for responsibly protecting
customer information


42
00:02:12,216 --> 00:02:12,796
on the network.


43
00:02:15,536 --> 00:02:17,756
But TLS is not quite enough.


44
00:02:18,526 --> 00:02:20,716
Many servers still
use version 1 of TLS,


45
00:02:21,256 --> 00:02:23,026
which is very old,
it's 16 years old.


46
00:02:23,126 --> 00:02:26,756
And the newest version of TLS,
1.2, which is 7 years old,


47
00:02:27,076 --> 00:02:29,206
contains a number of really
important cryptographic


48
00:02:29,206 --> 00:02:31,856
improvements to the protocol,
which make it more resilient


49
00:02:31,856 --> 00:02:33,986
to the kinds of threats
that we are seeing today


50
00:02:33,986 --> 00:02:35,336
and will be facing
in the future.


51
00:02:35,336 --> 00:02:40,036
And in fact, even TLS
1.2 is not quite enough.


52
00:02:40,586 --> 00:02:43,626
With the way TLS works,
if an attacker is able


53
00:02:43,626 --> 00:02:47,146
to compromise a server and
steal your TLS key, they can use


54
00:02:47,146 --> 00:02:50,936
that key to retroactively
decrypt all previously encrypted


55
00:02:50,936 --> 00:02:51,936
data by that server.


56
00:02:52,446 --> 00:02:53,906
That's obviously
very undesirable.


57
00:02:54,486 --> 00:02:56,146
There's a property
called forward secrecy


58
00:02:56,146 --> 00:02:57,416
that makes it not true.


59
00:02:57,526 --> 00:02:59,726
With forward secrecy,
if an attacker is able


60
00:02:59,726 --> 00:03:03,166
to compromise a server and steal
the TLS key, they can only use


61
00:03:03,166 --> 00:03:04,986
that key to decrypt
future traffic


62
00:03:05,166 --> 00:03:07,546
that the server encrypts,
but no prior traffic.


63
00:03:08,556 --> 00:03:10,816
And this is great because
it mitigates bulk recording


64
00:03:10,816 --> 00:03:13,686
of network encrypted data.


65
00:03:13,876 --> 00:03:17,246
TLS supports forward secrecy
and it does it through the use


66
00:03:17,246 --> 00:03:19,436
of what are called cipher
suites which are combinations


67
00:03:19,436 --> 00:03:21,506
of cryptographic primitives
that you actually have


68
00:03:21,506 --> 00:03:22,746
to enable on your server.


69
00:03:23,356 --> 00:03:26,786
So your server need only not
run just TLS, but in fact needs


70
00:03:26,846 --> 00:03:29,746
to run TLS 1.2, and in order
to get forward secrecy,


71
00:03:29,746 --> 00:03:31,076
you must configure
it to do that.


72
00:03:32,236 --> 00:03:33,696
So why am I telling
you all of this?


73
00:03:33,696 --> 00:03:42,506
Well, here is a quote from Tim,
and I will let you read it.


74
00:03:42,786 --> 00:03:44,366
>> "We must get this right."


75
00:03:45,026 --> 00:03:47,366
And to help you get it right,


76
00:03:48,586 --> 00:03:50,926
we're introducing a feature
called App Transport Security.


77
00:03:51,696 --> 00:03:52,666
Here's how it works.


78
00:03:53,816 --> 00:03:58,406
If you link your app against
OS X El Capitan or iOS 9,


79
00:03:59,546 --> 00:04:00,736
by default it won't be able


80
00:04:00,736 --> 00:04:03,106
to make any unprotected
HTTP connections;


81
00:04:03,106 --> 00:04:05,816
they will simply fail,
and any TLS connections


82
00:04:05,816 --> 00:04:09,276
that your app makes will have no
adhere to these best practices


83
00:04:09,276 --> 00:04:10,196
that I just described.


84
00:04:10,436 --> 00:04:12,456
And that's TLS 1.2
with forward secrecy.


85
00:04:13,016 --> 00:04:14,446
Cryptographic primitives
that are known


86
00:04:14,446 --> 00:04:16,176
to be insecure are not allowed,


87
00:04:16,505 --> 00:04:18,826
and there are minimum key size
requirements put in place.


88
00:04:19,516 --> 00:04:21,776
Now, you may not be
able to comply with all


89
00:04:21,776 --> 00:04:25,116
of these restrictions
immediately, and that's okay,


90
00:04:25,116 --> 00:04:27,636
you can specify exceptions
in your Info.plist either


91
00:04:27,636 --> 00:04:31,856
on a case-by-case basis for each
domain or as a global override.


92
00:04:32,456 --> 00:04:35,826
But, as an industry we have
to very soon get to a point


93
00:04:35,826 --> 00:04:38,366
where no user information
hits the network unencrypted,


94
00:04:39,486 --> 00:04:40,166
and we need your help.


95
00:04:41,676 --> 00:04:42,996
Thank you for that
and I will turn it


96
00:04:42,996 --> 00:04:44,986
over to my colleague Pierre
who's going to tell you


97
00:04:44,986 --> 00:04:46,276
about System Integrity
Protection.


98
00:04:47,516 --> 00:04:50,976
[Applause]


99
00:04:51,476 --> 00:04:52,086
>> PIERRE-OLIVIER
MARTEL: Thank you Ivan.


100
00:04:54,466 --> 00:04:57,466
Hi everyone, my name is
Pierre-Olivier Martel.


101
00:04:57,546 --> 00:04:59,086
I'm the engineering manager


102
00:04:59,086 --> 00:05:01,116
for Sandboxing Technologies
here at Apple.


103
00:05:01,926 --> 00:05:03,386
And today I'm here
to talk to you


104
00:05:03,386 --> 00:05:04,836
about System Integrity
Protection


105
00:05:05,396 --> 00:05:07,036
which is a new hardening
mechanism


106
00:05:07,236 --> 00:05:08,926
that we are introducing
in El Capitan.


107
00:05:10,346 --> 00:05:13,546
Before I dive into the details,
I would like to take a step back


108
00:05:13,796 --> 00:05:15,386
and provide some context


109
00:05:15,386 --> 00:05:16,646
around what we're
trying to achieve here.


110
00:05:17,906 --> 00:05:23,176
My team's mission at Apple is
to make sure that our users get


111
00:05:23,176 --> 00:05:25,766
to enjoy the great user
experience that comes


112
00:05:25,766 --> 00:05:28,056
with our product,
with the confidence


113
00:05:28,096 --> 00:05:32,376
that their personal data is
protected and that malware


114
00:05:32,656 --> 00:05:35,586
or even simply a poorly
written piece of software,


115
00:05:35,946 --> 00:05:39,196
only has a limited impact
on their user experience.


116
00:05:39,616 --> 00:05:44,376
So to that end we've designed
and integrated various pieces


117
00:05:44,376 --> 00:05:47,516
of security technologies,
as Ivan mentioned before,


118
00:05:47,996 --> 00:05:51,296
over the year in iOS and OS X.


119
00:05:51,296 --> 00:05:52,546
One of the quotas and principles


120
00:05:52,546 --> 00:05:56,446
that we applied there is the
concept of defense in depth.


121
00:05:57,196 --> 00:06:00,096
Now, the key principle here is
something you've probably heard


122
00:06:00,096 --> 00:06:03,186
before, which is that
security is all about layers.


123
00:06:04,226 --> 00:06:06,956
And for the same reason that you
shouldn't put all of your eggs


124
00:06:06,956 --> 00:06:11,106
in the same basket, you
shouldn't rely on a single layer


125
00:06:11,106 --> 00:06:12,996
of protection to
defend the device,


126
00:06:13,786 --> 00:06:18,166
because no matter how
bulletproof, or water resistant,


127
00:06:18,166 --> 00:06:21,636
or shock absorbent this layer
is, when it starts failing you,


128
00:06:22,376 --> 00:06:25,426
then it's complete game over.


129
00:06:25,666 --> 00:06:28,746
Instead, you should rely on
multiple layers of protection,


130
00:06:29,456 --> 00:06:32,796
ideally with different
security properties


131
00:06:33,296 --> 00:06:35,576
that will delay the
advance of an attacker


132
00:06:36,086 --> 00:06:37,386
and reduce your attack surface.


133
00:06:38,106 --> 00:06:41,286
Now, the concept of defense


134
00:06:41,286 --> 00:06:43,626
in depth is an old military
concept that's been used


135
00:06:43,756 --> 00:06:48,296
to defend fortresses all around
the world for centuries for now.


136
00:06:48,656 --> 00:06:49,886
Because I you know
you guys like trivia,


137
00:06:50,076 --> 00:06:52,656
I can tell that you it
was actually formalized


138
00:06:52,656 --> 00:06:57,516
by this gentleman, Sebastien
de Vauban, in the 1670s,


139
00:06:57,516 --> 00:06:59,056
when he was asked by
the King of France


140
00:06:59,496 --> 00:07:01,566
to rebuild all the
fortresses around the country


141
00:07:02,166 --> 00:07:04,766
that were used to
defend the kingdom.


142
00:07:05,696 --> 00:07:08,086
And you may not be
familiar with the character,


143
00:07:08,086 --> 00:07:11,026
but maybe you've seen
some of his work before.


144
00:07:11,286 --> 00:07:13,636
That's the design of
one of his castles.


145
00:07:14,046 --> 00:07:16,056
You can clearly see several
layers of protection here


146
00:07:16,056 --> 00:07:17,966
that are designed to stop
different kinds of attacks


147
00:07:18,946 --> 00:07:22,216
and that will basically delay
the attacker and funnel him


148
00:07:22,296 --> 00:07:27,446
through different bottlenecks
that are easier to defend.


149
00:07:28,196 --> 00:07:31,656
So let's see how this applies
to the OS X security model.


150
00:07:32,526 --> 00:07:34,906
And I don't know about you,
but I've always dreamed


151
00:07:34,906 --> 00:07:37,206
to build my own fort,
so there it is,


152
00:07:37,836 --> 00:07:41,186
and we'll put our own
security layers on it.


153
00:07:41,736 --> 00:07:44,556
Starting from the bottom,
we'll start with Gatekeeper.


154
00:07:45,736 --> 00:07:49,406
So Gatekeeper makes sure that an
application that gets downloaded


155
00:07:49,406 --> 00:07:54,046
from the Internet onto the
user's machine has to be signed


156
00:07:54,326 --> 00:07:56,596
by a -- we have a
Developer ID certificate


157
00:07:56,656 --> 00:07:58,416
that Apple has issued
to a developer,


158
00:07:59,106 --> 00:08:02,596
otherwise the application
does not get to launch.


159
00:08:03,886 --> 00:08:06,146
And combined with some
other mechanism that we have


160
00:08:06,146 --> 00:08:08,856
on the system, like some
malware detection mechanism,


161
00:08:09,306 --> 00:08:11,586
then it's actually a
pretty effective measure


162
00:08:12,446 --> 00:08:16,106
to stop a massive malware
attack on our ecosystem.


163
00:08:16,596 --> 00:08:19,436
The second layer is Sandbox.


164
00:08:20,786 --> 00:08:23,526
So back in Lion, we
introduced App Sandbox


165
00:08:23,976 --> 00:08:24,936
and we mad it mandatory


166
00:08:24,936 --> 00:08:28,676
for applications coming
from the App Store.


167
00:08:28,896 --> 00:08:32,196
We also highly recommended it
for applications coming outside


168
00:08:32,196 --> 00:08:34,546
of the App Store, like for
instance using the Developer


169
00:08:34,546 --> 00:08:35,066
ID program.


170
00:08:36,496 --> 00:08:38,476
Sandbox is a containment
mechanism.


171
00:08:39,236 --> 00:08:40,736
Which means that it
makes sure that even


172
00:08:40,736 --> 00:08:42,296
if your application
gets exploited,


173
00:08:43,106 --> 00:08:46,106
then the application only
has access to the data


174
00:08:46,106 --> 00:08:47,346
that the user actually gave it,


175
00:08:47,786 --> 00:08:50,466
which means the application
cannot steal all the user's


176
00:08:50,466 --> 00:08:53,766
data, and cannot compromise
the rest of the system.


177
00:08:54,236 --> 00:08:58,376
The third layer, if you
manage to go through


178
00:08:58,376 --> 00:09:02,426
or around the first two, is the
classic POSIX permission scheme,


179
00:09:03,196 --> 00:09:05,776
which means that your
application only runs


180
00:09:05,776 --> 00:09:09,206
with the set of privileges that
the system granted to your user.


181
00:09:09,796 --> 00:09:12,586
So the application won't be
able to access data owned


182
00:09:12,586 --> 00:09:14,826
by a different user
and it won't be able


183
00:09:14,826 --> 00:09:17,396
to modify a systemwide
configuration settings


184
00:09:17,396 --> 00:09:19,706
that are usually owned
by the root user.


185
00:09:20,226 --> 00:09:25,386
And finally, we can think of the
Keychain as yet another layer


186
00:09:25,386 --> 00:09:26,866
on top of that, which
is designed


187
00:09:26,866 --> 00:09:28,886
to protect the user's secrets.


188
00:09:29,416 --> 00:09:33,666
It relies on cryptography
and application separation


189
00:09:34,266 --> 00:09:37,866
to make sure that only the
application that's stored a


190
00:09:37,866 --> 00:09:40,736
secret in the first place
can get back to it later.


191
00:09:42,656 --> 00:09:44,366
So when you look at
the big picture here,


192
00:09:45,066 --> 00:09:46,476
you realize a couple of things.


193
00:09:47,576 --> 00:09:51,896
First, Gatekeeper will stop
untrusted code downloaded


194
00:09:51,896 --> 00:09:54,416
on the machine from
being launched.


195
00:09:55,336 --> 00:09:57,366
But it's not actually a
containment mechanism.


196
00:09:57,366 --> 00:09:59,126
It doesn't stop the application


197
00:09:59,126 --> 00:10:01,486
when it's run from
doing anything.


198
00:10:02,276 --> 00:10:05,516
Also, it does not protect code
that's already on the machine.


199
00:10:05,516 --> 00:10:07,196
So code that ships with
the OS, for instance,


200
00:10:07,196 --> 00:10:08,946
is not protected by it.


201
00:10:09,916 --> 00:10:13,926
Then, sandboxing, although it's
probably the most effective


202
00:10:14,216 --> 00:10:17,256
containment mechanism
we have on the platform,


203
00:10:17,256 --> 00:10:19,196
is only an opt-in in OS X.


204
00:10:19,856 --> 00:10:22,646
So there's no requirement
for every single process


205
00:10:22,966 --> 00:10:26,936
to actually run in a sandbox.


206
00:10:26,936 --> 00:10:30,366
Finally, when you look at the
POSIX layer, you realize that,


207
00:10:31,516 --> 00:10:36,476
well, most of the Macs out there
are actually single user systems


208
00:10:37,066 --> 00:10:40,466
where the user is the de
facto administrator running


209
00:10:40,466 --> 00:10:43,716
with administrative
privileges all the time.


210
00:10:44,836 --> 00:10:46,866
The root account is
usually protected


211
00:10:46,866 --> 00:10:52,186
or hidden behind an often weak
password or no password at all.


212
00:10:52,186 --> 00:10:55,296
And in fact, if there is a
password and you ask for it,


213
00:10:55,506 --> 00:10:56,946
the users likely give it to you.


214
00:10:58,186 --> 00:11:02,926
And finally, when you root, then
you actually have full control


215
00:11:02,926 --> 00:11:06,266
on the machine, because root can
disable all security measures


216
00:11:06,376 --> 00:11:06,986
on the device.


217
00:11:07,686 --> 00:11:10,956
It can replace the
kernel extensions,


218
00:11:11,466 --> 00:11:15,286
it can replace launchd, any
other security services,


219
00:11:15,816 --> 00:11:17,956
it can even interfere
with the Keychain layers


220
00:11:17,956 --> 00:11:20,426
that sit on top of it.


221
00:11:20,686 --> 00:11:24,036
So the reality is that once you
have code running on the Mac,


222
00:11:24,536 --> 00:11:26,706
it's actually not that
hard to become root,


223
00:11:27,196 --> 00:11:28,986
and once you are root, you have
full control of the machine.


224
00:11:29,606 --> 00:11:31,806
Which means that any piece


225
00:11:31,806 --> 00:11:33,786
of malware is actually
one password,


226
00:11:33,786 --> 00:11:35,546
or one vulnerability away


227
00:11:35,916 --> 00:11:40,336
from taking full
control of the device.


228
00:11:40,416 --> 00:11:44,336
This shows us that we
need another layer.


229
00:11:45,416 --> 00:11:48,346
We need a layer that will
eliminate the power of root


230
00:11:48,516 --> 00:11:52,046
on the machine and protect
the system by default,


231
00:11:52,086 --> 00:11:54,506
as it was installed by
Apple on the machine.


232
00:11:55,346 --> 00:11:57,026
Both on disk and at runtime.


233
00:11:57,566 --> 00:12:02,036
And because we are talking
about taking some power away


234
00:12:02,096 --> 00:12:05,276
from root, then we need


235
00:12:05,276 --> 00:12:06,856
to provide a configuration
mechanism


236
00:12:07,326 --> 00:12:09,886
that root itself
cannot compromise,


237
00:12:10,846 --> 00:12:14,126
but that can give away
this power back to root.


238
00:12:15,296 --> 00:12:18,086
This is what System
Integrated Protection is.


239
00:12:18,876 --> 00:12:21,366
It is a new security
policy that applies


240
00:12:21,406 --> 00:12:24,006
to every single process
running on the system.


241
00:12:24,646 --> 00:12:26,526
Regardless of whether
this process is running


242
00:12:26,526 --> 00:12:29,856
with extra privileges, or
if it's running unsandboxed.


243
00:12:30,296 --> 00:12:33,896
It's designed to
provide extra protections


244
00:12:34,216 --> 00:12:37,916
to system components, both
on disk and at runtime,


245
00:12:39,096 --> 00:12:43,106
and it makes it so that system
binaries are only modifiable


246
00:12:43,106 --> 00:12:46,886
by the installer, if it installs
an Apple signed package,


247
00:12:48,096 --> 00:12:50,006
or the Software Update
mechanism.


248
00:12:50,706 --> 00:12:54,316
And finally, that the system
binaries are protected


249
00:12:54,386 --> 00:12:58,426
from runtime attachments,
and from code injection.


250
00:12:58,976 --> 00:13:01,556
So before we dive
into the details here,


251
00:13:01,976 --> 00:13:05,276
let's see how this is going
to impact you the developers.


252
00:13:06,426 --> 00:13:09,556
Well the good news is that
if you ship your application


253
00:13:09,556 --> 00:13:12,256
on the App Store, then your
application is not impacted


254
00:13:12,256 --> 00:13:16,496
by any of this, because
the App Store guidelines


255
00:13:16,636 --> 00:13:18,616
and the app sandbox policy,


256
00:13:18,796 --> 00:13:20,546
already prohibits all
of these behaviors.


257
00:13:21,506 --> 00:13:23,616
However, if you ship
outside of the store,


258
00:13:24,346 --> 00:13:26,606
then your application is
potentially impacted by this,


259
00:13:27,136 --> 00:13:31,616
if it relies on being able
to modify system binaries


260
00:13:31,736 --> 00:13:32,896
or frameworks on disk.


261
00:13:33,436 --> 00:13:36,276
If it needs to be able
to install content


262
00:13:36,686 --> 00:13:39,966
in system locations, and I
will explain a little bit


263
00:13:39,966 --> 00:13:41,756
about what system
locations mean in here.


264
00:13:42,416 --> 00:13:45,176
And finally, if your
application needs


265
00:13:45,176 --> 00:13:47,986
to inspect the memory
states of any process


266
00:13:48,096 --> 00:13:52,046
on a system including system
processes, or if it needs


267
00:13:52,046 --> 00:13:56,536
to be able to inject libraries
or debug over processes,


268
00:13:56,696 --> 00:13:57,706
including system processes.


269
00:13:59,456 --> 00:14:02,576
So let's look at the key
aspects of this new mechanism.


270
00:14:03,076 --> 00:14:05,666
First, we look at new
filesystem restrictions


271
00:14:05,946 --> 00:14:08,566
that we are introducing
in Capitan,


272
00:14:08,566 --> 00:14:11,006
and then we'll see
how these extend


273
00:14:11,316 --> 00:14:13,426
to new runtime protections.


274
00:14:14,736 --> 00:14:17,206
Finally, we'll see
how this all ties


275
00:14:17,206 --> 00:14:20,166
in with the kernel
extension development workflow


276
00:14:20,166 --> 00:14:23,526
and how it potentially impacts
you if you are a kext developer.


277
00:14:23,526 --> 00:14:27,346
And then because the feature
can entirely be disabled,


278
00:14:28,006 --> 00:14:29,516
I will just show you how.


279
00:14:30,016 --> 00:14:32,536
Let's talk about the
filesystem first.


280
00:14:33,966 --> 00:14:35,456
What we're trying to
achieve here is we want


281
00:14:35,456 --> 00:14:39,866
to protect system content
from being modified.


282
00:14:40,486 --> 00:14:45,876
To do so, the installer will
actually flag system content


283
00:14:45,876 --> 00:14:47,866
as it installs the
files on disk.


284
00:14:48,646 --> 00:14:50,976
We have a new filesystem flag
that we introduced in Capitan.


285
00:14:51,986 --> 00:14:56,536
And then later on, at runtime,
the kernel will stop any attempt


286
00:14:56,846 --> 00:14:58,946
at modifying these
protected files


287
00:14:58,946 --> 00:15:02,046
or protected folders
unless the attempt comes


288
00:15:02,046 --> 00:15:05,196
from a specially
entitled process,


289
00:15:05,416 --> 00:15:07,916
of which there's only
a handful on Capitan.


290
00:15:09,016 --> 00:15:12,136
It will also stop you from
writing to the block devices


291
00:15:12,306 --> 00:15:13,886
that back this protected
content.


292
00:15:15,216 --> 00:15:16,776
And it will stop
you from mounting


293
00:15:16,966 --> 00:15:18,886
over this protected content.


294
00:15:19,846 --> 00:15:22,126
And one thing you have to
keep in mind is that for now,


295
00:15:22,406 --> 00:15:25,166
this only applies to the
root, and the boot volume


296
00:15:25,576 --> 00:15:27,906
of the currently running OS.


297
00:15:27,996 --> 00:15:30,736
So you should see this
as a way for the system


298
00:15:31,046 --> 00:15:36,126
to protect itself at runtime.


299
00:15:36,266 --> 00:15:39,316
Now, because we are trying to
protect system content on disk,


300
00:15:39,316 --> 00:15:41,326
we need to have a
clear separation


301
00:15:41,326 --> 00:15:43,596
between system content
and third-party content.


302
00:15:44,896 --> 00:15:48,876
So in Capitan, all the
locations that are on the left


303
00:15:48,876 --> 00:15:52,016
of this chart will now be
considered system locations.


304
00:15:52,846 --> 00:15:54,426
Which means that the system
will actually stop you


305
00:15:54,426 --> 00:15:56,986
from writing there,
including if it comes


306
00:15:57,036 --> 00:15:57,886
in an installer package.


307
00:15:58,366 --> 00:16:01,226
So it should not
impact many of you here


308
00:16:01,226 --> 00:16:03,686
because we've been
advising for many years now,


309
00:16:03,986 --> 00:16:05,376
that you shouldn't write
to these locations.


310
00:16:05,746 --> 00:16:08,556
But it's not going to be
a hard failure in Capitan


311
00:16:08,556 --> 00:16:10,666
if your package installs
content in there.


312
00:16:11,506 --> 00:16:13,216
So if you install
anything in /System,


313
00:16:13,216 --> 00:16:16,776
you need to move this content
into the appropriate subfolder


314
00:16:17,116 --> 00:16:20,666
of /Library, if it's supposed
to be system wide content,


315
00:16:21,256 --> 00:16:24,316
or (tilde)/Library if it's
supposed to be user content.


316
00:16:24,836 --> 00:16:32,156
If you install anything in /bin,
or /sbin, or anywhere under /usr


317
00:16:32,186 --> 00:16:36,446
like /usr/bin, /usr/lib,
/usr/libexec, then you need


318
00:16:36,446 --> 00:16:39,266
to move this content into
the appropriate subfolder


319
00:16:39,596 --> 00:16:44,336
of the /usr/local folder,
because that's the only location


320
00:16:44,336 --> 00:16:45,926
that is now available
to third-parties.


321
00:16:46,356 --> 00:16:50,466
And then a reminder
that the best location


322
00:16:50,466 --> 00:16:52,516
for your content is
still /Applications


323
00:16:52,656 --> 00:16:55,536
because that's the location
that is visible to the user


324
00:16:56,136 --> 00:16:58,796
and it's easy for them to
actually drag your application


325
00:16:58,796 --> 00:17:00,516
to the trash and just
remove all content.


326
00:17:01,856 --> 00:17:07,506
One important note here,
that when the user upgrades


327
00:17:07,685 --> 00:17:10,695
from a Yosemite install,
to a Capitan install,


328
00:17:11,435 --> 00:17:14,806
the installer will actually
migrate any third-party content


329
00:17:14,806 --> 00:17:17,766
that it finds in
system locations outside


330
00:17:17,766 --> 00:17:18,506
of these locations.


331
00:17:19,656 --> 00:17:23,165
So you need to make sure that
today you start migrating


332
00:17:23,165 --> 00:17:25,945
that content away as soon
as possible so as not


333
00:17:25,945 --> 00:17:26,816
to impact these users.


334
00:17:26,816 --> 00:17:31,606
Now, let's look at the
runtime protections.


335
00:17:33,086 --> 00:17:35,766
Being able to modify the
behavior of a process


336
00:17:35,906 --> 00:17:39,016
at runtime is more
equivalent to being able


337
00:17:39,016 --> 00:17:40,836
to modify the binary on disk.


338
00:17:41,506 --> 00:17:43,256
So if you try to protect
the binary on disk


339
00:17:43,516 --> 00:17:46,126
and the system content on
disk, we have to make sure


340
00:17:46,396 --> 00:17:49,616
that it's not possible to inject
code or modify the behavior


341
00:17:50,276 --> 00:17:51,536
of these system processes.


342
00:17:52,696 --> 00:17:56,716
To do so, we are introducing
a new restricted flag


343
00:17:57,356 --> 00:18:00,426
in the process structure
that the kernel holds


344
00:18:00,846 --> 00:18:01,806
for every single process.


345
00:18:03,046 --> 00:18:06,086
And a kernel will set
that flag at exact time


346
00:18:06,846 --> 00:18:11,116
if the main executable
is protected on disk,


347
00:18:11,256 --> 00:18:13,306
or if the main executable
is signed


348
00:18:13,306 --> 00:18:14,606
with an Apple-private
entitlement.


349
00:18:15,036 --> 00:18:22,546
And then later on, the system
will actually treat these


350
00:18:22,846 --> 00:18:24,906
restricted processes
slightly differently


351
00:18:24,906 --> 00:18:26,076
than regular processes.


352
00:18:26,196 --> 00:18:29,406
For one, the task-for-pid


353
00:18:29,956 --> 00:18:35,016
and the processor-set-tasks SPI
will now fail if they are called


354
00:18:35,116 --> 00:18:36,296
on a restricted process.


355
00:18:37,236 --> 00:18:39,626
And will set an 0 to EPERM.


356
00:18:40,616 --> 00:18:44,196
Which means that if part of your
product relies on being able


357
00:18:44,196 --> 00:18:48,076
to attach to a system process
at runtime, for instance,


358
00:18:48,266 --> 00:18:51,226
the Finder, and that you expect
to be able to inject code


359
00:18:51,226 --> 00:18:56,246
into the Finder, that is
not going to work anymore.


360
00:18:56,276 --> 00:19:00,676
Then if you fork an exec,
a binary that will result


361
00:19:00,796 --> 00:19:03,236
in the child process
being restricted,


362
00:19:03,286 --> 00:19:07,246
then the system will
automatically reset the mach


363
00:19:07,246 --> 00:19:08,956
special ports on
this child process,


364
00:19:09,666 --> 00:19:11,976
which means you won't
be able to keep control


365
00:19:12,366 --> 00:19:13,576
over the child process.


366
00:19:14,436 --> 00:19:18,156
So if you expect to be able
to fork a privileged tool


367
00:19:18,586 --> 00:19:19,776
and then keep control on it,


368
00:19:19,896 --> 00:19:23,156
that's not going
to work anymore.


369
00:19:23,256 --> 00:19:27,526
The linker is going to ignore
all the dyld environment


370
00:19:27,526 --> 00:19:29,486
variables on these
protected binaries.


371
00:19:30,256 --> 00:19:33,396
So if you expect to be
able to inject the library


372
00:19:33,566 --> 00:19:35,506
into a system binary
when you exec it,


373
00:19:36,116 --> 00:19:38,746
the linker will just
ignore the new library.


374
00:19:39,286 --> 00:19:44,386
And finally, if you use
dtrace, all dtrace probes


375
00:19:44,556 --> 00:19:49,176
that target a restricted process
will not be matched anymore,


376
00:19:49,876 --> 00:19:51,786
which means you won't be
able to see an interaction


377
00:19:51,786 --> 00:19:55,076
between the process
and the kernel.


378
00:19:55,076 --> 00:19:58,716
You won't be able to inspect the
restricted process memory space


379
00:19:58,926 --> 00:20:00,956
and you won't be able to
inspect the kernel memory.


380
00:20:01,556 --> 00:20:05,386
Of course, this applies
to our own debugger, LLDB.


381
00:20:05,386 --> 00:20:09,586
If you try to invoke lldb
even as root and try to attach


382
00:20:09,586 --> 00:20:15,046
to the Finder, then
this is going to fail.


383
00:20:15,276 --> 00:20:17,386
Now, when it comes to
the kext signing program,


384
00:20:17,756 --> 00:20:21,336
I'm sure you know by now, all
extensions have to be signed


385
00:20:21,606 --> 00:20:24,966
with a Developer ID for Kexts
certificate that was issued


386
00:20:24,966 --> 00:20:28,856
by Apple, and then these
extensions have to be installed


387
00:20:29,236 --> 00:20:31,096
into /Library/Extensions.


388
00:20:31,576 --> 00:20:33,826
The new thing here is


389
00:20:33,826 --> 00:20:37,626
that because we are pulling
the kext signing program


390
00:20:38,346 --> 00:20:42,026
under the System Integrity
Protection umbrella,


391
00:20:42,576 --> 00:20:45,116
the kext-dev-mode
boot-arg is now obsolete.


392
00:20:46,196 --> 00:20:49,996
If you are a kext developer,
you need to be able to test


393
00:20:50,096 --> 00:20:52,416
with unsigned kernel
extensions, you will need


394
00:20:52,416 --> 00:20:55,596
to disable this protection, and
I'll show you how in a minute.


395
00:20:56,036 --> 00:20:59,696
But it also means that,
this comment line here


396
00:20:59,696 --> 00:21:02,846
that you probably saw out
there to disable kext signing,


397
00:21:03,096 --> 00:21:04,196
is not doing anything anymore.


398
00:21:04,196 --> 00:21:10,326
So let's talk about the
configuration mechanism.


399
00:21:10,326 --> 00:21:14,506
We strongly believe
that this new mechanism,


400
00:21:14,506 --> 00:21:17,126
this new protection, is
critical for our users.


401
00:21:17,536 --> 00:21:21,856
That being said, we realize that
it gets in the way of people


402
00:21:21,856 --> 00:21:24,416
who want to have complete
control over their machine,


403
00:21:25,386 --> 00:21:26,636
and because of what
I said before,


404
00:21:26,876 --> 00:21:28,406
because it protects
the kernel on disk


405
00:21:28,906 --> 00:21:31,536
and requires all kernel
extensions to be signed,


406
00:21:32,196 --> 00:21:34,806
then it also gets in the way
of kext developers who want


407
00:21:34,806 --> 00:21:36,766
to be able to test
with unsigned kext.


408
00:21:37,716 --> 00:21:40,186
So because of that, it
can be entirely disabled.


409
00:21:41,206 --> 00:21:44,776
The configuration is stored
in your NVRAM setting,


410
00:21:45,256 --> 00:21:48,136
which means that it applies
to the entire machine.


411
00:21:48,476 --> 00:21:50,416
So if you have several
installs of Capitan,


412
00:21:50,766 --> 00:21:52,496
they will all be
configured the same way


413
00:21:53,466 --> 00:21:55,516
and it's persistent
across OS install.


414
00:21:55,646 --> 00:21:59,196
So as you move from seed 1 to
seed 2 up to GM and even later,


415
00:21:59,766 --> 00:22:01,306
the configuration will persist.


416
00:22:01,446 --> 00:22:03,256
So we won't reset it
every time we install.


417
00:22:03,256 --> 00:22:08,156
Now, because root can
actually set a NVRAM setting


418
00:22:08,266 --> 00:22:10,636
and we can't trust root to
do the right thing here,


419
00:22:11,086 --> 00:22:13,326
it means we cannot have
the configuration mechanism


420
00:22:13,426 --> 00:22:14,446
in the OS itself.


421
00:22:15,076 --> 00:22:17,556
So we actually pulled it and
installed it in the Recovery OS.


422
00:22:17,716 --> 00:22:20,656
So this NVRAM setting can
only be set in Recovery.


423
00:22:21,766 --> 00:22:23,026
If you want to change
the configuration,


424
00:22:23,786 --> 00:22:26,336
you need to reboot your machine
in Recovery OS, and you can do


425
00:22:26,336 --> 00:22:29,526
so by holding the
Command+R key on boot.


426
00:22:30,546 --> 00:22:32,566
Then all you have to do
is launch the Security


427
00:22:32,566 --> 00:22:35,246
Configuration application
from the Utilities menu,


428
00:22:36,326 --> 00:22:38,556
and check the System
Integrity Protection box,


429
00:22:39,376 --> 00:22:40,706
apply and reboot.


430
00:22:41,536 --> 00:22:44,506
Keep in mind that these types
that I just describe are likely


431
00:22:44,506 --> 00:22:46,316
to change in an upcoming seed.


432
00:22:46,446 --> 00:22:49,416
So make sure you read
the release notes


433
00:22:49,536 --> 00:22:51,666
to know what the new steps are.


434
00:22:53,676 --> 00:22:57,066
So let's summarize what
we discussed so far.


435
00:22:57,276 --> 00:22:59,996
System Integrity Protection
is a new policy that applies


436
00:22:59,996 --> 00:23:01,196
to every process on the system.


437
00:23:02,276 --> 00:23:06,516
It protects the system as it was
installed by Apple, both on disk


438
00:23:06,616 --> 00:23:10,436
and at runtime, by
restricting write access


439
00:23:10,846 --> 00:23:14,986
to system locations, and by
preventing runtime attachment


440
00:23:15,946 --> 00:23:18,596
and code injection
on system processes.


441
00:23:19,076 --> 00:23:23,216
The installer will actively
migrate third-party content


442
00:23:23,336 --> 00:23:25,216
outside of system locations,


443
00:23:25,216 --> 00:23:27,046
so make sure you actually
migrate your content as soon


444
00:23:27,046 --> 00:23:29,396
as possible or that you
fall back gracefully


445
00:23:29,396 --> 00:23:30,726
when you can't find it.


446
00:23:31,356 --> 00:23:35,526
Then finally, the feature can be
disabled using the configuration


447
00:23:35,526 --> 00:23:38,526
mechanism that is
in the Recovery OS.


448
00:23:39,416 --> 00:23:40,216
That's it for me.


449
00:23:40,456 --> 00:23:41,236
Thank you very much, guys.


450
00:23:41,646 --> 00:23:42,556
I will leave the
stage to Andrew.


451
00:23:43,516 --> 00:23:48,506
[Applause]


452
00:23:49,006 --> 00:23:49,526
>> ANDREW WHALLEY:
Thank you, Pierre.


453
00:23:51,666 --> 00:23:54,716
I'm Andrew Whalley, and I
manage the data security group


454
00:23:54,846 --> 00:23:56,966
within Core OS Security
Engineering.


455
00:23:57,516 --> 00:24:01,466
You heard about app
transport security,


456
00:24:02,136 --> 00:24:04,626
and how it helps
protect data in motion,


457
00:24:05,026 --> 00:24:07,006
through the network
connections your app makes.


458
00:24:07,626 --> 00:24:09,746
I'm going to look
at the various ways


459
00:24:09,746 --> 00:24:12,326
that you can protect
data at rest.


460
00:24:12,876 --> 00:24:16,206
I will touch on the Keychain
and storing user secrets,


461
00:24:17,496 --> 00:24:21,796
look at Touch ID and how you
can use it to balance security


462
00:24:21,846 --> 00:24:24,186
and convenience in your app.


463
00:24:25,236 --> 00:24:29,306
Along the way, I will be looking
at existing technologies as well


464
00:24:29,306 --> 00:24:32,936
as what's new in iOS 9 and
how they can fit together


465
00:24:33,406 --> 00:24:37,256
to deliver a level of security
appropriate for your apps.


466
00:24:39,696 --> 00:24:42,656
So let's start with a quick
overview of the Keychain.


467
00:24:43,226 --> 00:24:46,586
You can think of it as a
very specialized database.


468
00:24:47,456 --> 00:24:51,416
You store data by adding rows,
which we call Keychain items,


469
00:24:51,896 --> 00:24:54,696
and then query for them
with the attributes.


470
00:24:55,196 --> 00:25:01,316
It's optimized for small secrets
and by secret I mean a password,


471
00:25:01,316 --> 00:25:04,766
a token or cookie,
or cryptographic key.


472
00:25:06,126 --> 00:25:10,516
If you have tens of thousands,
thousands of megabytes to store,


473
00:25:10,856 --> 00:25:15,556
consider using file-based data
protection or a bulk encryption


474
00:25:16,036 --> 00:25:18,326
through an API like
Common Crypto


475
00:25:18,406 --> 00:25:20,176
and then just store the
key in the Keychain.


476
00:25:24,956 --> 00:25:27,976
These SecItem APIs have
been around a long time,


477
00:25:28,256 --> 00:25:30,646
but they're still the best
place to store secrets,


478
00:25:30,946 --> 00:25:33,066
including in your
new Swift apps.


479
00:25:34,176 --> 00:25:37,906
So here we have a secret
and we want to store it


480
00:25:37,906 --> 00:25:40,206
in the Keychain using
SecItemAdd.


481
00:25:41,146 --> 00:25:44,356
To do that, we construct
a dictionary


482
00:25:44,716 --> 00:25:46,486
which includes both the secret


483
00:25:46,956 --> 00:25:51,726
and some attributes describing
how to find it in the future


484
00:25:52,296 --> 00:25:54,166
and what protection
it should have.


485
00:25:55,576 --> 00:25:59,606
This pattern of creating a
dictionary to describe or query


486
00:25:59,606 --> 00:26:05,106
for an item, is also used by
the calls to query, delete,


487
00:26:05,106 --> 00:26:08,536
and update an item, as well
as some of the other APIs,


488
00:26:08,536 --> 00:26:10,046
I should be talking about later.


489
00:26:11,396 --> 00:26:13,466
There's a lot more
about Keychain APIs


490
00:26:13,506 --> 00:26:17,076
in Session 709 from 2013's WWDC.


491
00:26:17,076 --> 00:26:21,866
So here's some things
to consider


492
00:26:22,416 --> 00:26:25,156
when you are writing code
to access the Keychain.


493
00:26:26,696 --> 00:26:30,866
The first is dealing with user
secrets is a really security


494
00:26:30,866 --> 00:26:32,326
sensitive part of your code.


495
00:26:33,106 --> 00:26:37,456
So you should factor it into
small, simple, testable units.


496
00:26:37,926 --> 00:26:44,256
Often this is done
with a wrapper class.


497
00:26:44,426 --> 00:26:46,586
Whether you are using it
directly or through a wrapper,


498
00:26:47,116 --> 00:26:49,716
make sure it has the
highest level of protection


499
00:26:50,396 --> 00:26:52,296
that your application can use.


500
00:26:53,666 --> 00:26:56,996
We describe and talk about
data protection classes,


501
00:26:57,526 --> 00:27:02,926
which are the times at which
cryptographic access is provided


502
00:27:02,926 --> 00:27:03,796
to those items.


503
00:27:03,926 --> 00:27:06,366
For example, when the
device is unlocked.


504
00:27:06,956 --> 00:27:11,646
In iOS 8, we added the
AfterFirstUnlock --


505
00:27:11,646 --> 00:27:15,046
I beg your pardon.


506
00:27:15,046 --> 00:27:18,326
That's been around for a while,
but you can use it if you have


507
00:27:18,576 --> 00:27:21,776
to access items in the
background, for example,


508
00:27:21,776 --> 00:27:26,926
if you are a VoIP app.


509
00:27:27,156 --> 00:27:30,636
Always accessible is going
to be deprecated in iOS 9.


510
00:27:31,056 --> 00:27:33,126
So you need to start
moving items out of


511
00:27:33,246 --> 00:27:34,686
that into a higher level.


512
00:27:40,216 --> 00:27:44,496
We have WatchKit 2, your
Watch apps now have access


513
00:27:44,556 --> 00:27:49,006
to the SecItem APIs, though
entering a full user name


514
00:27:49,006 --> 00:27:52,486
and password on the Watch is
probably not the user experience


515
00:27:52,486 --> 00:27:52,876
you want.


516
00:27:54,416 --> 00:27:58,496
If your Watch app is displaying
data from a paired iOS device,


517
00:27:59,076 --> 00:28:01,406
consider just sending
that content across


518
00:28:01,736 --> 00:28:03,756
and not a persistent credential.


519
00:28:04,416 --> 00:28:07,956
If your Watch app does
need direct access


520
00:28:08,806 --> 00:28:11,566
to a credential then
consider rather


521
00:28:11,566 --> 00:28:14,456
than storing a full
user name and password,


522
00:28:15,166 --> 00:28:18,076
have your server send
you a token or a cookie


523
00:28:18,376 --> 00:28:22,506
that only has the permissions
to access the content


524
00:28:22,686 --> 00:28:26,136
that the focused functionality
of your Watch app requires.


525
00:28:26,676 --> 00:28:33,546
It's not just on the
Watch that user name


526
00:28:33,546 --> 00:28:35,726
and password prompts
can be inconvenient,


527
00:28:36,406 --> 00:28:39,566
and over the last few releases
we have introduced a couple


528
00:28:39,566 --> 00:28:42,836
of technologies to help you
prompt for passwords less often.


529
00:28:44,516 --> 00:28:47,076
The first is shared
web credentials.


530
00:28:48,576 --> 00:28:51,796
We all know and love
Safari saved passwords


531
00:28:52,276 --> 00:28:55,506
and how it will suggest
and store them for us.


532
00:28:56,096 --> 00:29:00,436
With iCloud Keychain, passwords
will be synced and autofilled


533
00:29:00,436 --> 00:29:01,486
on all of your devices.


534
00:29:02,006 --> 00:29:05,226
However, it's common
for a service


535
00:29:05,226 --> 00:29:08,166
to have both a website
and an iOS app.


536
00:29:08,766 --> 00:29:12,606
So it would be great to have
those applications participate


537
00:29:12,766 --> 00:29:14,366
in Safari saved passwords


538
00:29:15,106 --> 00:29:19,506
and with shared web
credentials you can.


539
00:29:19,686 --> 00:29:22,276
Here's some code you might
want to include in the sign-up


540
00:29:22,346 --> 00:29:24,706
or the registration flow
of your application.


541
00:29:27,316 --> 00:29:29,896
SecCreateShared
WebCredentialPassword will


542
00:29:29,896 --> 00:29:33,476
return a random string in the
same format that Safari uses


543
00:29:33,476 --> 00:29:34,946
for it's suggested passwords.


544
00:29:36,296 --> 00:29:38,606
Can you can call
SecAddSharedWebCredential


545
00:29:38,606 --> 00:29:42,396
to let Safari know that there's
a new user name and password


546
00:29:42,646 --> 00:29:44,636
to autofill for a
specific domain.


547
00:29:47,396 --> 00:29:51,086
In iOS 9, we've made it easy to
give this functionality a try


548
00:29:51,486 --> 00:29:53,476
by relaxing some of
the security checks


549
00:29:53,476 --> 00:29:54,766
when you're running
in the Simulator.


550
00:29:54,766 --> 00:29:59,086
So let's have a look at that.


551
00:29:59,196 --> 00:30:02,816
Here I'm going through the
registration flow of my app


552
00:30:03,226 --> 00:30:06,306
to which I just added the code
I showed you a few moments ago.


553
00:30:06,306 --> 00:30:12,026
After that, just pop in
to the settings for Safari


554
00:30:12,026 --> 00:30:15,746
and make sure that name and
password autofill is enabled.


555
00:30:16,386 --> 00:30:19,426
Go to Safari and
see the results.


556
00:30:19,426 --> 00:30:25,336
Here we are back in the
app, being presented


557
00:30:25,826 --> 00:30:29,146
with a user name
and password prompt.


558
00:30:29,236 --> 00:30:32,826
Shared web credentials
allows the application


559
00:30:32,826 --> 00:30:36,716
to display a picker, which lists
all the accounts Safari has


560
00:30:36,716 --> 00:30:37,696
saved for that domain.


561
00:30:38,246 --> 00:30:43,036
When the user has
picked one, the user name


562
00:30:43,036 --> 00:30:46,456
and password is returned to your
app in the completion handler


563
00:30:46,456 --> 00:30:51,616
for SharedWebCredential and
you can then log the user


564
00:30:51,726 --> 00:30:52,246
straight in.


565
00:30:52,246 --> 00:30:58,116
If you want to use this
on device and not just


566
00:30:58,116 --> 00:31:01,216
in the simulator, you're going
to have to add an entitlement


567
00:31:01,216 --> 00:31:04,026
to your application,
and you can do this


568
00:31:04,026 --> 00:31:06,116
in the Associated
Domains section


569
00:31:06,236 --> 00:31:08,186
of the Capabilities
tab in Xcode.


570
00:31:08,736 --> 00:31:13,776
You are also going to
need to put a JSON file


571
00:31:13,886 --> 00:31:16,376
up on your server, but you
might have this already.


572
00:31:16,726 --> 00:31:19,256
As it's the same one
used for Handoff,


573
00:31:19,816 --> 00:31:24,926
as well as in iOS 9 app links.


574
00:31:29,796 --> 00:31:31,646
One change we have made in iOS 9


575
00:31:31,646 --> 00:31:35,116
to make adoption even easier is
you no longer need separately


576
00:31:35,116 --> 00:31:35,996
sign that file.


577
00:31:36,546 --> 00:31:39,406
It's going to be protected
with a secure TLS connection.


578
00:31:45,216 --> 00:31:49,256
I mentioned that Safari saved
passwords uses iCloud Keychain,


579
00:31:49,646 --> 00:31:52,046
but you can also use it
directly in your own apps.


580
00:31:53,156 --> 00:31:59,066
Imagine you have an iOS, iPad,
iPhone, and OS X App Store app


581
00:31:59,376 --> 00:32:01,986
and you want to make
logging into one the same


582
00:32:01,986 --> 00:32:03,426
as logging into them all.


583
00:32:03,866 --> 00:32:08,016
So for all of your apps
passwords that can be used


584
00:32:08,016 --> 00:32:12,056
on multiple devices, consider
just adding the synchronizable


585
00:32:12,056 --> 00:32:13,886
attribute to all SecItem calls.


586
00:32:13,886 --> 00:32:17,256
There are a few things that
you've got to think about,


587
00:32:17,256 --> 00:32:19,976
for example, deleting an item
will delete it everywhere,


588
00:32:20,116 --> 00:32:22,696
so make sure you only do that
under the right circumstances.


589
00:32:23,166 --> 00:32:27,036
There are a few more
caveats, and you can see the,


590
00:32:27,036 --> 00:32:32,056
in SecItem.h. If you are
interested in finding out more


591
00:32:32,056 --> 00:32:34,256
about the security
of iCloud Keychain


592
00:32:34,746 --> 00:32:37,906
and how synced passwords are
never accessible to anyone


593
00:32:37,906 --> 00:32:41,116
but the user, see the
iOS Security White Paper.


594
00:32:41,536 --> 00:32:43,096
There's a link at the
end of the session.


595
00:32:43,666 --> 00:32:51,306
So to recap, on the Keychain,
store all your secrets there.


596
00:32:51,476 --> 00:32:53,376
There really is no
place for passwords


597
00:32:53,376 --> 00:32:55,316
in plain text files or plists.


598
00:32:56,506 --> 00:32:58,976
Protect them at the
highest level possible


599
00:32:59,456 --> 00:33:03,026
and if appropriate use
SharedWedCredentials


600
00:33:03,026 --> 00:33:06,276
like our Keychain to sync them
around your user's devices


601
00:33:06,336 --> 00:33:08,906
and present fewer
password prompts.


602
00:33:12,636 --> 00:33:15,586
So iCloud Keychain is great
for the secrets that can go


603
00:33:15,586 --> 00:33:18,486
on multiple devices but
sometimes you want them


604
00:33:18,486 --> 00:33:21,546
to stay firmly and
securely on just one device.


605
00:33:22,176 --> 00:33:25,636
An example might be a
secure messaging app,


606
00:33:26,006 --> 00:33:29,956
where encryption is device to
device rather than user to user.


607
00:33:30,516 --> 00:33:35,536
The various protection classes
I already mentions have a


608
00:33:35,536 --> 00:33:37,236
ThisDeviceOnly variant.


609
00:33:38,126 --> 00:33:40,906
Items will be backed up,
but only ever restored


610
00:33:40,906 --> 00:33:44,366
to the device they came from.


611
00:33:44,366 --> 00:33:47,796
Last year, we added the
WhenPassCodeSet class,


612
00:33:48,286 --> 00:33:50,476
that ensures items
are always protected


613
00:33:50,576 --> 00:33:52,546
by a local device passcode.


614
00:33:53,096 --> 00:33:56,166
And you can use AccessControl
lists


615
00:33:56,166 --> 00:33:59,356
for even finer grained
control over items.


616
00:33:59,356 --> 00:34:04,696
So since we are talking


617
00:34:04,816 --> 00:34:07,446
about protecting
device-specific credentials,


618
00:34:07,866 --> 00:34:10,906
let's look at the security
domains on an iOS device.


619
00:34:12,315 --> 00:34:14,806
User space, where
your application runs,


620
00:34:15,666 --> 00:34:19,106
and the kernel, which as Pierre
mentioned provides process


621
00:34:19,106 --> 00:34:21,216
separation and other
security functionality.


622
00:34:22,545 --> 00:34:25,835
But it also provides many,
many other OS facilities,


623
00:34:26,045 --> 00:34:28,335
which means it has quite
a large attack service.


624
00:34:29,036 --> 00:34:32,315
So with iPhone 5s, we
added Secure Enclave.


625
00:34:34,795 --> 00:34:40,676
Secure Enclave is a separate on
core that has been architected


626
00:34:40,815 --> 00:34:43,525
from the ground up
with security in mind.


627
00:34:44,176 --> 00:34:48,266
That's where we put Touch
ID to ensure the privacy


628
00:34:48,266 --> 00:34:50,866
and the security of your
fingerprint biometrics.


629
00:34:52,636 --> 00:34:55,696
We also moved the KeyStore
component from the kernel


630
00:34:55,696 --> 00:34:58,516
into Secure Enclave
and it's that component


631
00:34:58,876 --> 00:35:02,056
which controls the cryptography
around Keychain items


632
00:35:02,166 --> 00:35:03,076
and the data protection.


633
00:35:07,016 --> 00:35:11,026
So let's focus for a
moment on Touch ID.


634
00:35:11,306 --> 00:35:13,546
While we think of it as
a security technology,


635
00:35:13,946 --> 00:35:16,356
where it really excels
is convenience.


636
00:35:17,156 --> 00:35:18,936
You can unlock your
device without having


637
00:35:18,936 --> 00:35:20,316
to enter your passcode
all the time,


638
00:35:20,846 --> 00:35:24,456
but that itself can give
us some security benefits.


639
00:35:25,116 --> 00:35:29,036
For example it's now much easier
to have a long, complex passcode


640
00:35:29,896 --> 00:35:32,126
which improves the
security of data protection.


641
00:35:33,466 --> 00:35:37,976
Or your phone can now lock
immediately so it's vulnerable


642
00:35:37,976 --> 00:35:44,756
and unlocked for as
small a time as possible.


643
00:35:44,756 --> 00:35:48,646
In iOS 8, we provided some
APIs so you can use Touch ID


644
00:35:48,646 --> 00:35:50,026
in your own applications


645
00:35:50,076 --> 00:35:52,486
as you balance security
and convenience.


646
00:35:53,176 --> 00:35:55,556
But why two and how
do they differ?


647
00:35:56,886 --> 00:35:59,566
Well to understand you're going
to have to know how Touch ID


648
00:35:59,566 --> 00:36:01,496
and biometrics security works.


649
00:36:01,846 --> 00:36:03,616
But luckily, it's very simple.


650
00:36:03,616 --> 00:36:05,366
It boils down to
an if statement.


651
00:36:06,306 --> 00:36:10,006
If a presented finger matches
one that's been enrolled,


652
00:36:10,546 --> 00:36:11,786
then do something.


653
00:36:12,176 --> 00:36:16,386
It's what that something
is, and where it happens


654
00:36:16,946 --> 00:36:17,826
that makes the difference.


655
00:36:18,306 --> 00:36:22,806
Let's start with
Local Authentication.


656
00:36:24,496 --> 00:36:28,496
A finger is placed on the
Touch ID sensor and is matched


657
00:36:28,496 --> 00:36:29,556
within the Secure Enclave.


658
00:36:31,776 --> 00:36:33,246
With Local Authentication,


659
00:36:33,296 --> 00:36:36,156
knowledge of the match
just a Boolean success


660
00:36:36,156 --> 00:36:38,906
or failure, is sent to your app.


661
00:36:39,776 --> 00:36:43,226
And it's there that
your app does something


662
00:36:43,356 --> 00:36:46,576
with that knowledge.


663
00:36:46,736 --> 00:36:51,746
So while the process started
in Secure Enclave, ultimately,


664
00:36:51,746 --> 00:36:54,976
it's the application
in user space


665
00:36:55,436 --> 00:36:59,006
where a security
decision is being made.


666
00:37:00,976 --> 00:37:02,906
So when might you
want to use Touch ID


667
00:37:02,906 --> 00:37:04,146
with Local Authentication?


668
00:37:05,476 --> 00:37:09,076
Think about your app and if
you have any security barriers,


669
00:37:09,546 --> 00:37:12,796
such as requiring a passcode
to confirm an operation,


670
00:37:13,346 --> 00:37:15,326
even though the user
is already logged in.


671
00:37:15,326 --> 00:37:19,236
Touch ID at that
would be much easier.


672
00:37:19,316 --> 00:37:24,696
Or maybe you always wanted
to have an extra step


673
00:37:24,696 --> 00:37:27,626
in an authentication
process but without Touch ID,


674
00:37:27,626 --> 00:37:30,486
it would have been really
just too much of a barrier.


675
00:37:31,156 --> 00:37:37,066
So, for example, you could
prompt before viewing,


676
00:37:37,066 --> 00:37:38,446
especially sensitive data.


677
00:37:39,036 --> 00:37:49,616
Or before an operation like
permanently deleting an account.


678
00:37:49,786 --> 00:37:52,356
One pattern is to have
a Touch ID prompt early


679
00:37:52,486 --> 00:37:53,666
in your application's flow.


680
00:37:55,026 --> 00:37:58,246
But this can lead to a situation
where the user has just unlocked


681
00:37:58,246 --> 00:38:01,666
with Touch ID, and then moments
later has been prompted again


682
00:38:01,666 --> 00:38:02,536
by your application.


683
00:38:04,476 --> 00:38:09,216
In iOS 9, we have added
the TouchIDAuthentication


684
00:38:09,216 --> 00:38:11,946
AllowableReuseDuration,
which is a property


685
00:38:11,946 --> 00:38:13,696
on the Local Authentication
context.


686
00:38:14,816 --> 00:38:17,696
You can use this to
specify a window during


687
00:38:17,696 --> 00:38:19,596
which you won't need
to prompt again


688
00:38:20,086 --> 00:38:22,356
if the user has recently
unlocked their device


689
00:38:22,526 --> 00:38:23,846
with Touch ID.


690
00:38:24,776 --> 00:38:28,546
So that's one way to make
your policy a little more lax.


691
00:38:29,376 --> 00:38:32,366
But maybe you want to make your
policy a little more strict


692
00:38:32,526 --> 00:38:33,576
in some situations.


693
00:38:33,576 --> 00:38:39,756
For example, by reacting to a
new fingerprint being enrolled.


694
00:38:40,416 --> 00:38:44,146
Also new, we have the
evaluatedPolicyDomainState


695
00:38:44,146 --> 00:38:44,616
property.


696
00:38:45,216 --> 00:38:47,836
It's a totally opaque value


697
00:38:48,266 --> 00:38:51,066
that represents the current
set of enrolled fingers.


698
00:38:51,156 --> 00:38:55,626
All you can really do with
it is compare it over time.


699
00:38:56,406 --> 00:39:00,566
If it changed, then a finger
has been added or removed


700
00:39:00,566 --> 00:39:02,406
to the enrolled set in settings.


701
00:39:02,956 --> 00:39:07,056
If you detect that,
and it's appropriate


702
00:39:07,056 --> 00:39:11,266
for your application, maybe
you can prompt again to see


703
00:39:11,266 --> 00:39:14,056
if users still wants to use
Touch ID on your application,


704
00:39:14,566 --> 00:39:17,226
or require a password
to reenable it.


705
00:39:19,336 --> 00:39:22,876
So let's recap what's new for
Local Authentication in iOS 9.


706
00:39:23,466 --> 00:39:27,146
I have already mentioned
AllowableReuseDuration,


707
00:39:27,326 --> 00:39:28,666
and PolicyDomainState.


708
00:39:29,266 --> 00:39:34,396
You can also invalidate a
Local Authentication context


709
00:39:34,896 --> 00:39:38,836
and if a Touch ID prompt is
currently being presented


710
00:39:38,836 --> 00:39:42,746
to the user, it will behave as
if the user had hit canceled


711
00:39:43,176 --> 00:39:46,116
and tear down the dialogue.


712
00:39:46,236 --> 00:39:50,316
evaluateAccessControl allows
Local Authentication to be used


713
00:39:50,366 --> 00:39:53,396
with Keychain Access
Control Lists, I will touch


714
00:39:53,396 --> 00:39:56,126
on that later and there's
also a lot more examples


715
00:39:56,226 --> 00:40:00,256
in some example code
we are releasing today.


716
00:40:01,736 --> 00:40:04,306
So talking of Keychain
Access Control Lists,


717
00:40:04,306 --> 00:40:06,486
that's the second way
you can use Touch ID


718
00:40:06,486 --> 00:40:07,606
within your application,


719
00:40:08,216 --> 00:40:10,966
by using it to protect
specific Keychain items.


720
00:40:12,306 --> 00:40:13,956
Here's our architecture
diagram again.


721
00:40:15,136 --> 00:40:18,916
As before, the Touch ID match
occurs in Secure Enclave


722
00:40:19,646 --> 00:40:22,626
but this time, knowledge
of the match is sent


723
00:40:23,156 --> 00:40:27,286
within Secure Enclave
to the KeyStore.


724
00:40:27,366 --> 00:40:32,486
Only then will your Keychain
item be released back


725
00:40:32,926 --> 00:40:33,676
to your application.


726
00:40:34,286 --> 00:40:39,886
So this is useful in you
want to add protection


727
00:40:39,886 --> 00:40:41,796
to a particular saved
credential.


728
00:40:42,356 --> 00:40:46,286
And to take advantage
of additional security


729
00:40:46,696 --> 00:40:48,616
around Secure Enclave.


730
00:40:48,616 --> 00:40:54,106
Maybe at the moment you've
looked at the security tradeoffs


731
00:40:54,106 --> 00:40:55,526
of your particular application


732
00:40:55,776 --> 00:40:58,216
and there are some things you
really don't want to save,


733
00:40:58,216 --> 00:41:00,406
you're prompting every
time or very frequently.


734
00:41:01,866 --> 00:41:04,236
Maybe using Access Control
Lists you can save it,


735
00:41:04,386 --> 00:41:05,386
protect it with Touch ID


736
00:41:05,386 --> 00:41:07,906
and provide a more
convenient experience.


737
00:41:09,666 --> 00:41:12,396
Or you could use it to
increase the security


738
00:41:12,686 --> 00:41:14,646
of something you're
already saving.


739
00:41:17,676 --> 00:41:19,586
You create access control lists


740
00:41:19,586 --> 00:41:21,686
by specifying two
security properties.


741
00:41:21,686 --> 00:41:25,876
The first is effectively
the data protection class.


742
00:41:26,656 --> 00:41:30,296
That's when the data is
cryptographically accessible


743
00:41:31,086 --> 00:41:33,096
to the Secure Enclave.


744
00:41:33,096 --> 00:41:34,926
Next, you specify a policy.


745
00:41:35,556 --> 00:41:38,306
The policy describes a condition


746
00:41:38,306 --> 00:41:41,996
that must be met before Secure
Enclave will release the item


747
00:41:42,126 --> 00:41:44,906
even if it has cryptographic
access to it.


748
00:41:47,236 --> 00:41:50,826
So let's have a look
at the policy types.


749
00:41:51,676 --> 00:41:53,466
The first is .UserPresence.


750
00:41:54,036 --> 00:41:56,826
This will prompt for a
Touch ID match and fall back


751
00:41:56,826 --> 00:41:57,936
to the device passcode.


752
00:41:58,036 --> 00:42:00,276
And you can go straight


753
00:42:00,276 --> 00:42:02,376
to .DevicePasscode
as well if you want.


754
00:42:02,976 --> 00:42:07,006
New in iOS 9, it's .TouchIDAny.


755
00:42:08,406 --> 00:42:12,156
This will require a Touch ID
match and there is no fallback.


756
00:42:13,786 --> 00:42:17,986
Also new, and stricter
still, is .TouchIDCurrentSet.


757
00:42:19,186 --> 00:42:22,446
With this, items will only
be released if the set


758
00:42:22,446 --> 00:42:24,606
of enrolled fingers
has not changed


759
00:42:24,916 --> 00:42:26,346
since the item was stored.


760
00:42:26,816 --> 00:42:31,496
I'm going to focus on
this because it might be


761
00:42:31,496 --> 00:42:33,356
that your application
could benefit


762
00:42:33,356 --> 00:42:36,416
from this providing a form of
multifactor authentication.


763
00:42:36,416 --> 00:42:40,726
When you think about multiple
factors, you often talk


764
00:42:40,726 --> 00:42:46,086
about something you know, like a
password, and something you have


765
00:42:46,086 --> 00:42:49,776
and carry with you, like a
physical token, a smart card,


766
00:42:50,806 --> 00:42:54,686
or maybe an iOS device with
Secure Enclave and Touch ID.


767
00:42:56,576 --> 00:42:59,066
If you store an item, protected


768
00:42:59,176 --> 00:43:02,986
with the TouchIDCurrentSet
policy, there's no way to get


769
00:43:02,986 --> 00:43:06,266
at the item without a
successful Touch ID match.


770
00:43:07,506 --> 00:43:08,576
There's no fallback.


771
00:43:09,316 --> 00:43:13,956
And if maybe an adversary
has the device passcode,


772
00:43:14,616 --> 00:43:17,246
they can't go into
settings, enroll a finger,


773
00:43:17,246 --> 00:43:24,496
and then have access
to that item.


774
00:43:24,716 --> 00:43:27,266
The last two policies,
.ApplicationPassword


775
00:43:27,266 --> 00:43:29,716
and .PrivateKeyUsage allow you


776
00:43:29,716 --> 00:43:31,706
to implement some
advanced functionality


777
00:43:31,706 --> 00:43:33,606
that goes beyond Touch ID.


778
00:43:34,536 --> 00:43:36,506
The first is
ApplicationPassword.


779
00:43:36,996 --> 00:43:40,226
To help illustrate,
let's look at how an item


780
00:43:40,226 --> 00:43:43,166
in the WhenUnlocked class is
cryptographically protected.


781
00:43:43,716 --> 00:43:47,716
In the same way that even
the best door lock is useless


782
00:43:47,716 --> 00:43:49,186
if you've left your
key in the door,


783
00:43:49,596 --> 00:43:52,026
encrypted data isn't
actually protected


784
00:43:52,466 --> 00:43:54,296
if stored alongside the key.


785
00:43:55,716 --> 00:43:59,636
The security of data protection
and the Keychain comes


786
00:43:59,636 --> 00:44:03,066
down to the device passcode
and that's stored in one


787
00:44:03,066 --> 00:44:06,176
of the most complex systems
we know, the user's brain.


788
00:44:08,176 --> 00:44:10,576
They remember it, enter
it into the device,


789
00:44:10,686 --> 00:44:14,306
and we take that passcode and
derive a cryptographic key


790
00:44:14,526 --> 00:44:19,786
and it's that, which
decrypts the item.


791
00:44:20,006 --> 00:44:22,436
Now, let's look at
an item protected


792
00:44:22,436 --> 00:44:23,726
with ApplicationPassword.


793
00:44:28,156 --> 00:44:32,086
Just the device passcode
is no longer sufficient.


794
00:44:33,636 --> 00:44:36,516
Your application has also got
to provide its own password.


795
00:44:37,566 --> 00:44:41,496
Again, we derive a cryptographic
key from it, and it's only


796
00:44:41,496 --> 00:44:45,366
when the device passcode and the
app password are both present


797
00:44:45,966 --> 00:44:48,806
that access is granted
to the Keychain item.


798
00:44:49,356 --> 00:44:55,266
As I mentioned, if you store the
password on device or it's baked


799
00:44:55,266 --> 00:44:57,866
into your app, this
really doesn't offer any


800
00:44:57,866 --> 00:44:58,736
additional protection.


801
00:44:58,736 --> 00:45:00,796
So you have to think
about where off


802
00:45:00,796 --> 00:45:02,916
that device you can
store that password.


803
00:45:04,406 --> 00:45:07,506
Maybe it's up on a server, which
can implement its own policy


804
00:45:07,506 --> 00:45:09,766
about when it's released
back to your app.


805
00:45:10,816 --> 00:45:13,866
Or perhaps you have a
physical accessory and you want


806
00:45:13,866 --> 00:45:16,766
to prove the user has it.


807
00:45:16,766 --> 00:45:19,506
If the accessory can't
give your app a password,


808
00:45:20,376 --> 00:45:22,666
then it can't decrypt
a Keychain item


809
00:45:23,136 --> 00:45:25,426
and you know it's not present.


810
00:45:28,696 --> 00:45:34,076
To use ApplicationPasswords, you
create both a AccessControl list


811
00:45:34,616 --> 00:45:36,526
and a Local Authentication
context.


812
00:45:37,626 --> 00:45:39,506
The first says please
use application password


813
00:45:39,506 --> 00:45:43,176
for this item, and the second
specifies the password itself.


814
00:45:43,706 --> 00:45:47,296
You then take both of
these and add to them


815
00:45:47,296 --> 00:45:49,446
to the dictionary you
passed the SecItem call.


816
00:45:49,446 --> 00:45:56,746
This is an example of using a
Local Authentication context


817
00:45:56,966 --> 00:45:59,106
in conjunction with
the Keychain item.


818
00:45:59,106 --> 00:46:03,136
So that was ApplicationPassword.


819
00:46:04,436 --> 00:46:07,116
The final new policy,
it's Private Key Usage.


820
00:46:07,576 --> 00:46:10,636
Here's the diagram from earlier,


821
00:46:11,236 --> 00:46:14,086
where we saw a Keychain item
being released from the KeyStore


822
00:46:14,086 --> 00:46:16,696
in Secure Enclave, back
to your application.


823
00:46:17,166 --> 00:46:21,896
This obviously is needed if you
take that password and use it


824
00:46:21,896 --> 00:46:22,656
to log into a server,


825
00:46:22,736 --> 00:46:27,026
but it exposes the password
it a potentially compromised


826
00:46:27,476 --> 00:46:28,806
user space.


827
00:46:28,986 --> 00:46:30,776
So wouldn't it be
great if there's a way


828
00:46:30,916 --> 00:46:33,636
to keep the secret
inside Secure Enclave


829
00:46:33,906 --> 00:46:35,096
but still have it be usable?


830
00:46:35,916 --> 00:46:38,126
And there is, using
asymmetric cryptography.


831
00:46:39,486 --> 00:46:42,766
There we don't just have a
single key, but a key pair.


832
00:46:43,606 --> 00:46:47,306
A public key that doesn't
require any protection,


833
00:46:47,826 --> 00:46:53,906
and a private key we
have to keep safe.


834
00:46:54,116 --> 00:46:58,656
Using this requires the
SecKey API and the details


835
00:46:58,656 --> 00:47:00,336
that are somewhat
beyond the scope


836
00:47:00,336 --> 00:47:03,106
of the few minutes I have left,
but here is an overview just


837
00:47:03,106 --> 00:47:05,506
so you can see the flow.


838
00:47:05,506 --> 00:47:09,436
Calling SecKeyGeneratePair
will cause the private key


839
00:47:09,796 --> 00:47:11,946
to be stored in Secure Enclave,


840
00:47:12,176 --> 00:47:14,576
if you specify some new
additional parameters.


841
00:47:15,796 --> 00:47:18,366
But the public key
is still returned


842
00:47:18,366 --> 00:47:19,676
to your application to store.


843
00:47:23,716 --> 00:47:26,396
If you try and retrieve
the private key,


844
00:47:26,676 --> 00:47:30,966
using SecItemCopyMatching,
you can get a reference,


845
00:47:31,006 --> 00:47:35,216
but cannot get the actual
data out of Secure Enclave.


846
00:47:35,766 --> 00:47:38,936
So how do you actually use it?


847
00:47:39,736 --> 00:47:42,566
Well, you might have some
data you want to be signed.


848
00:47:43,206 --> 00:47:47,736
So you can call SecKeyRawSign
and pass the data


849
00:47:47,736 --> 00:47:52,016
into Secure Enclave, and if
you've set up the private key


850
00:47:52,016 --> 00:47:53,826
to be protected by Touch ID,


851
00:47:54,886 --> 00:47:59,246
only after a successful match
will the private key be used


852
00:47:59,416 --> 00:48:02,936
to sign that data, and have it
returned to your application.


853
00:48:09,036 --> 00:48:10,626
So one place you might want


854
00:48:10,626 --> 00:48:13,716
to use this is strengthening
Touch ID as a second factor.


855
00:48:13,786 --> 00:48:18,246
I'm going to give an example
flow, but bear in mind


856
00:48:18,246 --> 00:48:20,916
that there are a lot
of intricate details


857
00:48:20,916 --> 00:48:22,656
in writing cryptographic
protocol.


858
00:48:22,906 --> 00:48:24,746
So please don't take this
to be too prescriptive.


859
00:48:25,156 --> 00:48:28,906
First of all, for
the enrollment flow,


860
00:48:29,086 --> 00:48:33,946
you would generate a key pair,
and send the public key back


861
00:48:33,946 --> 00:48:37,746
to the server, along with a
user's regular login details.


862
00:48:39,656 --> 00:48:43,836
The server would record the
public key as being associated


863
00:48:43,836 --> 00:48:47,206
with that user, and
that's enrollment.


864
00:48:47,206 --> 00:48:52,316
Later on, when the server wants
to verify that you're logging


865
00:48:52,316 --> 00:48:55,436
in from the same physical
device that you were before,


866
00:48:55,836 --> 00:48:59,036
it can send a challenge
to your application,


867
00:48:59,946 --> 00:49:02,336
which in turn calls
SecKeyRawSign.


868
00:49:04,556 --> 00:49:06,716
The user will present
their finger


869
00:49:07,156 --> 00:49:08,356
and have a Touch ID match.


870
00:49:08,906 --> 00:49:12,596
That will result in the
challenge being signed


871
00:49:12,656 --> 00:49:14,136
and you can send it
back to the server.


872
00:49:14,736 --> 00:49:19,446
And the server can then use the
public key it previously stored


873
00:49:19,996 --> 00:49:21,056
to validate the signature.


874
00:49:21,576 --> 00:49:27,156
Just a few more details
on this topic.


875
00:49:27,706 --> 00:49:30,466
The supported keys are
Elliptic Curve P256,


876
00:49:31,726 --> 00:49:34,376
the private key is not
extractible in any form,


877
00:49:34,376 --> 00:49:37,776
even protected, and the
applications are RawSign


878
00:49:37,806 --> 00:49:38,566
and RawVerify.


879
00:49:42,656 --> 00:49:46,616
So in summary, I have given
an overview of the Keychain,


880
00:49:47,616 --> 00:49:50,666
and some situations where
you might want to use it.


881
00:49:52,076 --> 00:49:53,966
I talked about the
technologies we have


882
00:49:53,966 --> 00:49:56,626
to avoid presenting the
user with password prompts.


883
00:49:57,096 --> 00:50:02,336
Looked at the two Touch ID
APIs, Local Authentication


884
00:50:02,736 --> 00:50:04,396
and Keychain Access Controls.


885
00:50:04,916 --> 00:50:10,056
And told you about some new
advanced features you can build


886
00:50:10,236 --> 00:50:13,536
on top the new things we
added to those APIs iOS 9.


887
00:50:17,436 --> 00:50:22,966
App passwords and Secure
Enclave protected private keys.


888
00:50:24,086 --> 00:50:27,076
I'm always fascinated to find


889
00:50:27,076 --> 00:50:28,976
out what wonderful
things you are going


890
00:50:28,976 --> 00:50:30,736
to make using these new APIs


891
00:50:31,156 --> 00:50:34,856
and how you can better balance
security and convenience


892
00:50:34,856 --> 00:50:36,106
in your own applications.


893
00:50:38,856 --> 00:50:41,986
There's some more
information available online,


894
00:50:42,206 --> 00:50:46,226
including the iOS Security
White Paper I mentioned earlier.


895
00:50:46,226 --> 00:50:52,126
There's more information
about app transport security


896
00:50:52,336 --> 00:50:55,196
on Thursday's Networking
with NSURL Session, session.


897
00:50:55,856 --> 00:51:02,246
And come and visit us tomorrow
morning and Thursday morning


898
00:51:02,656 --> 00:51:04,396
in the Security and
Privacy labs.


899
00:51:05,106 --> 00:51:06,066
Thank you very much, indeed.


900
00:51:07,516 --> 00:51:11,500
[Applause]

