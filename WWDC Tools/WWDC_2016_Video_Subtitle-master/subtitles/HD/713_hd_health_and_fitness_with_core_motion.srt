1
00:00:07,516 --> 00:00:17,500
[ Music ]


2
00:00:21,516 --> 00:00:27,006
[ Applause ]


3
00:00:27,506 --> 00:00:28,046
>> Thank you.


4
00:00:29,006 --> 00:00:29,786
Hello everyone.


5
00:00:30,376 --> 00:00:32,595
A very good afternoon
and welcome.


6
00:00:33,306 --> 00:00:34,546
My name is Bharath Rao.


7
00:00:34,546 --> 00:00:36,726
I'm an engineer with
the Core Motion Team,


8
00:00:37,056 --> 00:00:39,416
and today I'm really
excited to be talking to you


9
00:00:39,416 --> 00:00:41,536
about health and fitness.


10
00:00:42,436 --> 00:00:45,446
In this talk, I'll be showing
you how you can use Core Motion


11
00:00:45,446 --> 00:00:49,646
framework to add some
interesting and engaging health


12
00:00:49,646 --> 00:00:53,166
and fitness features
into your apps.


13
00:00:53,236 --> 00:00:55,816
Before we get started, for
those of you who are new


14
00:00:55,816 --> 00:00:58,036
to Core Motion, I'd like
to remind you to go check


15
00:00:58,036 --> 00:00:59,606
out some of our past sessions.


16
00:00:59,936 --> 00:01:01,716
They have some excellent
information


17
00:01:01,716 --> 00:01:06,356
about how sensors work, and
how we use, in Core Motion,


18
00:01:06,356 --> 00:01:08,666
those sensors to provide APIs


19
00:01:09,106 --> 00:01:13,866
that help your apps
observe stats and activity


20
00:01:13,866 --> 00:01:16,166
and Device Motion,
and a whole lot more.


21
00:01:16,636 --> 00:01:17,306
Go check them out.


22
00:01:18,716 --> 00:01:20,806
So with that, let's get started.


23
00:01:21,536 --> 00:01:23,346
Here's what we have in
store for you today.


24
00:01:23,926 --> 00:01:26,266
I have an update to the
Historical Accelerometer


25
00:01:26,266 --> 00:01:27,546
that I would like
to share with you.


26
00:01:29,206 --> 00:01:31,656
We have a new pedometer
events API,


27
00:01:31,656 --> 00:01:34,326
both for the iPhone
and the Apple Watch.


28
00:01:35,526 --> 00:01:38,926
And finally, we are also
bringing the Device Motion APIs


29
00:01:39,066 --> 00:01:41,456
to Apple Watch, with watchOS 3.


30
00:01:43,376 --> 00:01:45,226
Thank you.


31
00:01:46,626 --> 00:01:51,296
First up is Historical
Accelerometer.


32
00:01:54,176 --> 00:01:57,756
Last year, we introduced
the CM Sensor Recorder API.


33
00:01:58,176 --> 00:02:01,156
With this API, now
your apps have access


34
00:02:01,156 --> 00:02:04,746
to raw accelerometer samples,
or long durations of time.


35
00:02:05,226 --> 00:02:09,106
And you can also get this
access with very low power.


36
00:02:09,106 --> 00:02:11,356
After your apps have
requested the framework


37
00:02:11,356 --> 00:02:14,166
to start recording these
samples, they can get suspended.


38
00:02:14,166 --> 00:02:16,756
And the OS will offer
those samples,


39
00:02:16,756 --> 00:02:18,286
even across device sleeps.


40
00:02:18,396 --> 00:02:21,466
And when your app is ready to
consume them, it can launch


41
00:02:21,656 --> 00:02:24,386
and make a query,
and get access to all


42
00:02:24,386 --> 00:02:26,206
of those buffered samples.


43
00:02:28,696 --> 00:02:32,356
In watchOS 3, we have a
couple of important updates.


44
00:02:32,456 --> 00:02:34,856
First of which is
the greater duration.


45
00:02:35,866 --> 00:02:40,136
Now, your apps have a 36-hour
window in which they can launch


46
00:02:40,216 --> 00:02:42,596
and get access to all
of that Historical


47
00:02:42,596 --> 00:02:43,946
Accelerometer samples.


48
00:02:45,936 --> 00:02:48,276
The second update should not
come as a surprise to you,


49
00:02:48,276 --> 00:02:51,626
this is one of the most
requested updates for this API.


50
00:02:52,236 --> 00:02:54,576
So I'm happy to announce
that in watchOS 3,


51
00:02:54,576 --> 00:02:57,786
now the sample delay is
as little as 3 seconds.


52
00:03:00,266 --> 00:03:03,516
With these updates, now you
can use Sensor Recorder,


53
00:03:03,516 --> 00:03:07,526
not only to observe user
activity, or at long durations,


54
00:03:07,526 --> 00:03:10,016
but there are some
real time applications


55
00:03:10,016 --> 00:03:13,176
for which you can use the
sensor recorder now maybe


56
00:03:13,176 --> 00:03:18,596
to track sports activities or
to record workouts at the gym


57
00:03:18,786 --> 00:03:20,126
or even health diagnosis.


58
00:03:20,716 --> 00:03:23,096
Imagine an app on
the Apple Watch


59
00:03:23,096 --> 00:03:24,676
that can detect hand tremors.


60
00:03:24,806 --> 00:03:28,406
So now, whenever the user
experiences some hand tremors,


61
00:03:28,716 --> 00:03:29,806
they can launch the app.


62
00:03:30,256 --> 00:03:31,856
Your app will be
able to pull all


63
00:03:31,856 --> 00:03:35,236
of the historical accelerometer
samples, do some analysis


64
00:03:35,236 --> 00:03:41,076
on them and get a report that
says how severe that tremor was,


65
00:03:41,076 --> 00:03:44,366
and what kind of tremor it
was and share it with the user


66
00:03:44,366 --> 00:03:46,546
and maybe even with the
physician with consent,


67
00:03:46,876 --> 00:03:49,106
so that it can speed
up the diagnosis


68
00:03:49,226 --> 00:03:51,516
and the treatment
of such conditions.


69
00:03:53,276 --> 00:03:54,696
So that was a great update


70
00:03:54,736 --> 00:03:57,236
to Historical Accelerometer
in watchOS 3.


71
00:03:57,856 --> 00:03:59,846
Next up is pedometer.


72
00:04:06,156 --> 00:04:08,966
CMPedometer is a versatile API.


73
00:04:09,706 --> 00:04:13,986
It records stats and
distance, and flights of stairs


74
00:04:13,986 --> 00:04:16,245
that the users climb
throughout the day.


75
00:04:16,505 --> 00:04:19,666
So you could use it to build
an all-day activity tracker


76
00:04:19,666 --> 00:04:23,016
where you set some interesting
goals for your users to achieve.


77
00:04:23,066 --> 00:04:24,946
And that way you
can motivate them


78
00:04:25,036 --> 00:04:26,356
to lead a healthier lifestyle.


79
00:04:27,366 --> 00:04:31,376
But where CMPedometer
is really powerful is


80
00:04:31,376 --> 00:04:33,026
in the context of workouts.


81
00:04:34,176 --> 00:04:36,586
Take for example,
the pace metric.


82
00:04:36,586 --> 00:04:39,276
We have stride estimation
algorithms that are running both


83
00:04:39,276 --> 00:04:42,706
on the iPhone and Apple
Watch and using those,


84
00:04:42,976 --> 00:04:45,716
we are able to provide
really accurate pace


85
00:04:45,716 --> 00:04:47,176
and distance metrics, even


86
00:04:47,176 --> 00:04:49,226
when the phone doesn't
have a GPS signal.


87
00:04:49,226 --> 00:04:51,286
Or when you go run
with your Apple Watch,


88
00:04:51,286 --> 00:04:53,756
and you leave the phone
behind, even then,


89
00:04:53,996 --> 00:04:55,926
the users get very
accurate metrics.


90
00:04:57,056 --> 00:05:01,766
The pedometer events API that
we are adding today is actually


91
00:05:01,766 --> 00:05:05,376
going to help you make those
workout experiences even more


92
00:05:05,376 --> 00:05:06,956
engaging and accurate.


93
00:05:09,516 --> 00:05:13,596
Let's consider a typical
running workout; an urban run.


94
00:05:14,026 --> 00:05:16,726
As third packet [inaudible],
one of the challenges


95
00:05:16,726 --> 00:05:19,586
that you'll face with this
scenario is how do you detect


96
00:05:19,586 --> 00:05:22,336
all those starts and stops
that the users experience


97
00:05:22,336 --> 00:05:24,896
at intersections while
they're running in a city?


98
00:05:25,476 --> 00:05:27,856
So the user comes to a
stop at the stoplight,


99
00:05:28,106 --> 00:05:32,186
and your app will continue to
accumulate all of that time


100
00:05:32,186 --> 00:05:33,326
that they're just
standing around.


101
00:05:34,166 --> 00:05:36,576
So by the time they get
to the end of their run,


102
00:05:37,016 --> 00:05:39,066
now you have accumulated
enough time, and you --


103
00:05:39,176 --> 00:05:42,286
if you try to compute
their average pace


104
00:05:42,286 --> 00:05:45,046
over their entire run, you'll
probably end up with something


105
00:05:45,046 --> 00:05:47,496
that will resemble
that of their granddad.


106
00:05:49,566 --> 00:05:53,476
Or maybe granddad's gone faster
than them, so never mind.


107
00:05:53,776 --> 00:05:56,306
So what I mean to say is,


108
00:05:56,306 --> 00:05:59,116
you'll end up with
really inaccurate pace,


109
00:05:59,246 --> 00:06:01,596
which is probably much lower
than their running pace.


110
00:06:02,436 --> 00:06:06,946
So one probable solution is you
could provide a manual pause


111
00:06:06,946 --> 00:06:07,786
and resume option.


112
00:06:08,366 --> 00:06:11,936
But now, once they have paused,
they will also have to remember


113
00:06:11,936 --> 00:06:14,126
to resume the workout
when they start running.


114
00:06:14,606 --> 00:06:16,006
And if they don't, now all


115
00:06:16,006 --> 00:06:18,846
of the running they do
while their app is paused,


116
00:06:18,946 --> 00:06:21,646
is going to be not recorded
towards their workout.


117
00:06:21,646 --> 00:06:25,816
So if they forget to pause,
then they get inaccurate pace.


118
00:06:25,816 --> 00:06:29,396
If they forget to resume,
they lose out on distance.


119
00:06:30,616 --> 00:06:35,706
So clearly, you need some auto
pause and resume detection


120
00:06:35,706 --> 00:06:38,846
that is not only accurate, but
it also has to be responsive.


121
00:06:38,846 --> 00:06:41,456
It has to feel like your
app is doing a good job


122
00:06:41,906 --> 00:06:44,436
of detecting those
starts and stops.


123
00:06:45,766 --> 00:06:47,466
At this point, you
might be wondering,


124
00:06:47,466 --> 00:06:49,126
why not just use GPS and steps.


125
00:06:49,126 --> 00:06:51,666
After all, you have access
to those in your apps.


126
00:06:52,776 --> 00:06:55,566
If you have ever used GPS
before, you know that you have


127
00:06:55,566 --> 00:06:57,626
to do a considerable
amount of filtering on it,


128
00:06:57,626 --> 00:06:59,226
so that you can remove
all the noise.


129
00:06:59,796 --> 00:07:02,736
Which means that it is going
to be again, slow to respond.


130
00:07:03,576 --> 00:07:06,556
And with the steps that you
receive from CMpedometer,


131
00:07:06,556 --> 00:07:07,626
it has a built in delay.


132
00:07:08,066 --> 00:07:11,306
And we do that because we
want to avoid false positives.


133
00:07:11,726 --> 00:07:13,866
We use steps to estimate stride.


134
00:07:14,256 --> 00:07:16,426
And from that we compute
distance and pace.


135
00:07:16,426 --> 00:07:18,186
So it's very important for us


136
00:07:18,226 --> 00:07:22,666
to have accurate step
counts at the first step.


137
00:07:25,296 --> 00:07:28,626
So in this release, we are
giving you pedometer events


138
00:07:28,806 --> 00:07:31,836
that is going to help you
detect those starts and stops,


139
00:07:31,836 --> 00:07:35,126
not only with good accuracy,
but with low latency.


140
00:07:36,286 --> 00:07:39,466
Our pedometer events
solution, or the auto-pause


141
00:07:39,536 --> 00:07:42,496
and resume solution uses
a predictive algorithm.


142
00:07:43,016 --> 00:07:45,546
This predictive algorithm
was trained on user data


143
00:07:45,776 --> 00:07:48,086
so that we can improve
the likelihood estimate


144
00:07:48,086 --> 00:07:49,766
of whether the user is moving,


145
00:07:50,036 --> 00:07:52,046
or have they come
to a complete stop?


146
00:07:52,576 --> 00:07:54,496
Of course, all in a
pedestrian context.


147
00:07:55,656 --> 00:07:59,216
By doing this, now we are able
to recover most of the delay


148
00:07:59,216 --> 00:08:01,976
that is associated with the
step counting algorithm.


149
00:08:02,346 --> 00:08:05,226
But we are able to do so
with pretty good accuracy.


150
00:08:07,566 --> 00:08:09,026
I would also like to point out,


151
00:08:09,026 --> 00:08:11,756
because the predictive
algorithm keeps track


152
00:08:11,756 --> 00:08:15,096
of whether the user is moving,
or if they have come to a stop,


153
00:08:15,276 --> 00:08:17,686
we can also support walk base.


154
00:08:17,816 --> 00:08:21,026
So when you are -- when
the user comes to a stop,


155
00:08:21,786 --> 00:08:24,816
whether from a walk or a run,
you'll get a pause event.


156
00:08:25,066 --> 00:08:27,886
And as soon as the user
starts to run or walk,


157
00:08:28,156 --> 00:08:30,356
you'll get a resume
event within your app.


158
00:08:32,155 --> 00:08:35,196
Pedometer Events API,
they look identical both


159
00:08:35,196 --> 00:08:37,006
on iOS X and watchOS 3.


160
00:08:37,226 --> 00:08:42,876
Let's take a look
at the API itself.


161
00:08:42,876 --> 00:08:44,616
You have the pause
and resume events.


162
00:08:45,276 --> 00:08:47,546
Each event is timestamped
with the exact time


163
00:08:47,546 --> 00:08:50,256
when the algorithm detected
the transition from moving


164
00:08:50,316 --> 00:08:52,526
to not moving state,
and vice versa.


165
00:08:53,286 --> 00:08:57,566
And you had to start and stop a
pace to help your app register


166
00:08:57,566 --> 00:08:59,016
and deregister for these events.


167
00:09:01,766 --> 00:09:06,936
I've been talking about how
pedometer events can be used


168
00:09:06,936 --> 00:09:10,806
to clearly demarcate just
the running segments during a


169
00:09:10,886 --> 00:09:14,466
complete running workout
and how you can, using that,


170
00:09:14,466 --> 00:09:15,946
derive accurate metrics.


171
00:09:16,746 --> 00:09:19,026
But you can also
use pedometer events


172
00:09:19,026 --> 00:09:21,036
in some other interesting ways.


173
00:09:21,196 --> 00:09:22,866
Let's take a look at an example.


174
00:09:24,246 --> 00:09:26,676
This is a trail-running
app on the iPhone.


175
00:09:27,006 --> 00:09:29,796
So here we are going to use
pedometer events to see --


176
00:09:30,636 --> 00:09:34,176
to figure out when we can engage
with the user, and when we do,


177
00:09:34,516 --> 00:09:35,646
how we can present them


178
00:09:35,646 --> 00:09:38,116
with some interesting
information that's going


179
00:09:38,116 --> 00:09:41,346
to make them respond
to those more actively.


180
00:09:42,076 --> 00:09:44,146
And because this is
a trail-running app,


181
00:09:44,146 --> 00:09:46,156
there is going to be an
elevation change throughout the


182
00:09:46,156 --> 00:09:47,406
run so we are going to see


183
00:09:47,406 --> 00:09:49,276
if there is some
meaningful information there.


184
00:09:54,246 --> 00:09:57,206
We are going to use the
CMpedometer class to register


185
00:09:57,206 --> 00:09:58,686
for the pause and resume events.


186
00:09:58,806 --> 00:10:01,306
And we are going to get the
relative altitude updates


187
00:10:01,366 --> 00:10:04,846
or the elevation changes
using the CMAltimeter class.


188
00:10:06,626 --> 00:10:09,386
If you want to continue to
receive pedometer events


189
00:10:09,386 --> 00:10:11,676
within your app, even
when the screen turns off,


190
00:10:11,836 --> 00:10:13,516
your app has to stay running.


191
00:10:14,666 --> 00:10:17,846
And one way of doing that on
the iPhone is to subscribe


192
00:10:17,936 --> 00:10:19,926
to continuous background
location.


193
00:10:20,216 --> 00:10:22,196
If you are interested in
knowing more about this,


194
00:10:22,466 --> 00:10:24,076
I suggest that you go check


195
00:10:24,076 --> 00:10:26,266
out the Core Location
Best Practices session


196
00:10:26,526 --> 00:10:28,456
that is happening at WWDC today.


197
00:10:30,346 --> 00:10:31,496
Next, we are going to register


198
00:10:31,496 --> 00:10:33,346
for the relative
altitude updates first


199
00:10:33,626 --> 00:10:35,166
availability check.


200
00:10:35,166 --> 00:10:37,686
And then we provide
an operations queue,


201
00:10:37,686 --> 00:10:39,636
and provide a callback handler


202
00:10:39,736 --> 00:10:41,146
to start receiving
those updates.


203
00:10:41,936 --> 00:10:45,376
In this example, I'm
just going to make a note


204
00:10:45,376 --> 00:10:46,826
of the most recent update.


205
00:10:46,826 --> 00:10:50,706
But potentially in your app, you
can cache all of those updates.


206
00:10:50,926 --> 00:10:53,846
And at the end of the workout
you can potentially provide a


207
00:10:53,846 --> 00:10:56,756
nice elevation profile
for the entire run.


208
00:10:59,146 --> 00:11:01,846
Next, we'll register for the
pedometer events themselves.


209
00:11:02,106 --> 00:11:03,936
So first an availability check.


210
00:11:03,936 --> 00:11:06,966
And then register by
providing a callback handler.


211
00:11:08,406 --> 00:11:12,006
This is just a quick tip to
make sure that I don't run


212
00:11:12,006 --> 00:11:15,036
into any concurrence issues,
I'm doing work from all


213
00:11:15,036 --> 00:11:17,046
of the handlers on the
same operations queue.


214
00:11:19,706 --> 00:11:23,206
So now that the app is
set up to exactly figure


215
00:11:23,206 --> 00:11:24,986
out when the user
has started running,


216
00:11:24,986 --> 00:11:26,396
and when they have
stopped running.


217
00:11:26,396 --> 00:11:29,516
We are ready to see
if they can use


218
00:11:29,516 --> 00:11:31,126
that in a very contextual
manner.


219
00:11:31,856 --> 00:11:33,726
As soon as they start
running, we are going


220
00:11:33,726 --> 00:11:36,246
to get the resume
event in the app.


221
00:11:36,246 --> 00:11:40,496
At this time you could make
a note of that exact time


222
00:11:40,496 --> 00:11:42,966
when we got the resume
event, so that way at the end


223
00:11:42,966 --> 00:11:45,756
of the workout, you can
basically add up all


224
00:11:45,756 --> 00:11:46,986
of those running times


225
00:11:47,536 --> 00:11:51,366
to compute very accurate
average pace for the entire run.


226
00:11:51,936 --> 00:11:53,916
In this example, I'm
just going to make a note


227
00:11:53,916 --> 00:11:56,866
of the most recent
elevation update,


228
00:11:56,866 --> 00:11:59,516
so that I know exactly
what elevation they started


229
00:11:59,516 --> 00:12:00,366
when they started running.


230
00:12:01,806 --> 00:12:03,626
And when the user
comes to a stop,


231
00:12:03,626 --> 00:12:05,736
now this is a very
good opportunity for us


232
00:12:05,736 --> 00:12:08,496
to figure out, because we
have elevation, we can figure


233
00:12:08,496 --> 00:12:09,966
out if they have run up a hill.


234
00:12:10,796 --> 00:12:11,896
And if they have done so,


235
00:12:11,896 --> 00:12:13,766
this might be their
first ever hill run.


236
00:12:13,766 --> 00:12:16,536
So why not just give them
a hill bagging achievement.


237
00:12:17,286 --> 00:12:20,186
Or if they have been doing that
same hill run multiple times,


238
00:12:20,186 --> 00:12:24,366
because we have exact, accurate
timings for each of those runs,


239
00:12:24,686 --> 00:12:27,516
now we can compare those
and give them a stat


240
00:12:27,516 --> 00:12:29,706
of how well they are doing
on that particular hill run.


241
00:12:31,126 --> 00:12:35,166
So that was an example where we
use pedometer events not only


242
00:12:35,166 --> 00:12:37,526
to arrive as very
accurate metrics


243
00:12:37,526 --> 00:12:39,156
and demarcate those
running segments.


244
00:12:39,156 --> 00:12:42,686
But it's also an example
where you could use --


245
00:12:42,686 --> 00:12:44,956
do something interesting
with those events.


246
00:12:46,446 --> 00:12:49,306
At the end of the run, of
course you go ahead and pay


247
00:12:49,306 --> 00:12:53,036
down the registrations and this
will also release any block


248
00:12:53,036 --> 00:12:55,046
handlers that have been
captured in the framework.


249
00:12:56,856 --> 00:13:00,786
Pedometer events are available
on iPhone 6s and later iPhones,


250
00:13:00,916 --> 00:13:02,286
and of course the Apple Watch.


251
00:13:03,056 --> 00:13:07,226
So that's pedometer in
iOS X and watchOS 3.


252
00:13:08,496 --> 00:13:10,156
Next, let's talk
about Device Motion.


253
00:13:12,626 --> 00:13:16,016
As you're all aware,
Device Motion APIs have been


254
00:13:16,016 --> 00:13:18,076
on the iPhone since iOS 5.


255
00:13:18,906 --> 00:13:22,086
With watchOS 3, now we are
bringing the exact same APIs


256
00:13:22,296 --> 00:13:23,716
to the Apple Watch.


257
00:13:26,096 --> 00:13:30,036
With the Apple Watch, we have
a very capable sensor package


258
00:13:30,036 --> 00:13:32,436
that is at a fixed
location on our wrist


259
00:13:32,686 --> 00:13:34,316
and we use it throughout
the day.


260
00:13:34,716 --> 00:13:37,616
And because we use our
hands for almost everything


261
00:13:37,616 --> 00:13:41,036
that we do throughout the day,
it's a really powerful tool


262
00:13:41,036 --> 00:13:42,946
to observe all of
that user activity.


263
00:13:43,936 --> 00:13:46,806
And what Device Motion does
is it takes the samples


264
00:13:46,806 --> 00:13:49,726
from the accelerometer and
the gyroscope, and it fuses it


265
00:13:50,136 --> 00:13:53,326
to give you a very clear picture
of all of that user activity,


266
00:13:53,456 --> 00:13:55,466
and all of this right
on your wrist.


267
00:13:57,166 --> 00:14:00,546
All of that motion at wrist
is described by Device Motion,


268
00:14:00,636 --> 00:14:04,386
using four distinct
properties: Attitude, gravity,


269
00:14:04,686 --> 00:14:07,426
rotation rate, and
user acceleration.


270
00:14:09,686 --> 00:14:14,206
If you want to know in depth how
these properties are derived,


271
00:14:14,206 --> 00:14:16,746
and how they behave, I
encourage you to go check


272
00:14:16,746 --> 00:14:20,326
out these sessions
from 2011 and 2012.


273
00:14:20,656 --> 00:14:23,846
In this talk though, I'll be
giving you a very brief overview


274
00:14:23,846 --> 00:14:27,176
of this property so that we can
build some infusion and go look


275
00:14:27,176 --> 00:14:31,086
at some examples of how you
can apply them in some health


276
00:14:31,086 --> 00:14:33,166
and fitness apps in
interesting ways.


277
00:14:34,316 --> 00:14:36,326
The first property is attitude.


278
00:14:37,676 --> 00:14:42,266
Using attitude in your apps,
you can get an observation


279
00:14:42,316 --> 00:14:44,616
of the orientation
of device and space.


280
00:14:44,906 --> 00:14:46,916
And when you use CMDeviceMotion,


281
00:14:46,916 --> 00:14:49,726
you get these three
representations of attitude.


282
00:14:50,496 --> 00:14:54,426
As Quaternion, rotation
matrix, and as Euler angles.


283
00:14:55,426 --> 00:14:57,786
Whenever you are using
attitude within your app,


284
00:14:57,786 --> 00:15:01,726
one thing to note is every
single attitude observation is


285
00:15:01,726 --> 00:15:04,776
going to be relative to
a fixed reference frame.


286
00:15:05,986 --> 00:15:10,176
What this means is every single
orientation observation is going


287
00:15:10,176 --> 00:15:11,686
to be observed from a point


288
00:15:11,686 --> 00:15:13,536
that is not fixed to
the device itself.


289
00:15:13,536 --> 00:15:17,036
So the reference frame remains
static while the device can move


290
00:15:17,036 --> 00:15:19,396
around, and that's
how you observe


291
00:15:19,396 --> 00:15:20,926
orientation-using attitude.


292
00:15:22,516 --> 00:15:26,196
And furthermore, when
your app registers


293
00:15:26,286 --> 00:15:27,806
to start receiving the updates,


294
00:15:27,936 --> 00:15:30,916
that is when the
reference frame is set.


295
00:15:30,916 --> 00:15:33,396
And so every subsequent
sample that you receive


296
00:15:33,396 --> 00:15:36,286
within your app is going
to be computed using


297
00:15:36,576 --> 00:15:39,046
that relative reference
frame that was set


298
00:15:39,046 --> 00:15:40,426
at the start of updates.


299
00:15:40,786 --> 00:15:43,766
So this is something that
you need to kind of be aware


300
00:15:43,766 --> 00:15:46,146
of when you use attitude
in your apps.


301
00:15:46,586 --> 00:15:48,906
And so that you don't
make assumptions


302
00:15:48,906 --> 00:15:52,476
about where the device is
oriented in absolute space.


303
00:15:53,846 --> 00:15:56,006
The next property is gravity.


304
00:15:57,376 --> 00:16:00,586
Gravity is -- well,
it's gravity.


305
00:16:00,586 --> 00:16:02,356
It is the force that
is pulling us all


306
00:16:02,356 --> 00:16:04,426
down to the center of the Earth.


307
00:16:04,426 --> 00:16:06,716
And within Device
Motion, it is represented


308
00:16:06,716 --> 00:16:08,646
as a unit vector in
the device frame.


309
00:16:09,696 --> 00:16:13,366
Using gravity, you
can observe the tip


310
00:16:14,116 --> 00:16:15,726
and the tilt of the device.


311
00:16:17,036 --> 00:16:18,016
But you might be wondering,


312
00:16:18,016 --> 00:16:20,716
isn't different tilt also the
orientation just like attitude?


313
00:16:21,056 --> 00:16:24,206
But one key difference is,
now you're observing all


314
00:16:24,206 --> 00:16:26,776
of this orientation
from the device frame.


315
00:16:27,116 --> 00:16:29,026
So take for example, if I were


316
00:16:29,026 --> 00:16:31,376
to hold my hand perfectly
parallel to the ground


317
00:16:31,376 --> 00:16:35,466
to my side, and then I move it
to my front, you won't be able


318
00:16:35,466 --> 00:16:36,746
to observe this using gravity.


319
00:16:36,746 --> 00:16:39,266
Because the x, y, z
components of gravity are going


320
00:16:39,266 --> 00:16:42,056
to remain exactly same
between these two orientations.


321
00:16:42,056 --> 00:16:45,456
To observe something like this,
you need a point of observation


322
00:16:45,456 --> 00:16:49,326
that is external or fixed
while the device is moving.


323
00:16:49,326 --> 00:16:50,526
Which is basically attitude.


324
00:16:50,526 --> 00:16:53,806
So you could use gravity
to observe orientation,


325
00:16:53,806 --> 00:16:55,706
but only in a limited form.


326
00:16:56,096 --> 00:16:59,036
But it might work just
good for the kind of app


327
00:16:59,036 --> 00:17:01,406
that you are thinking of.


328
00:17:01,586 --> 00:17:03,526
One other thing about gravity is


329
00:17:03,526 --> 00:17:05,816
when you hold the
device perfectly still,


330
00:17:05,816 --> 00:17:07,965
you can observe it
using the accelerometer.


331
00:17:07,965 --> 00:17:09,566
It's a constant acceleration


332
00:17:09,566 --> 00:17:11,036
that the accelerometer
will pick up,


333
00:17:11,496 --> 00:17:14,445
and you can read it right
out of accelerometer.


334
00:17:15,146 --> 00:17:17,876
But as soon as you
start moving the device,


335
00:17:17,876 --> 00:17:19,336
now the accelerometer is picking


336
00:17:19,336 --> 00:17:21,806
up not just the gravity
component, but it's also picking


337
00:17:21,806 --> 00:17:24,195
up all of the user-generated
motion.


338
00:17:24,665 --> 00:17:26,126
So it becomes harder and harder


339
00:17:26,205 --> 00:17:27,896
to just get the gravity
component.


340
00:17:28,556 --> 00:17:31,616
What Device Motion does, is
by using sense of fusion,


341
00:17:31,726 --> 00:17:33,366
we switch over to the gyroscope


342
00:17:33,526 --> 00:17:40,276
to start tracking the
gravity unit vector.


343
00:17:40,276 --> 00:17:42,826
Next property is rotation rate.


344
00:17:43,476 --> 00:17:45,376
As the name suggests,
it's the rate


345
00:17:45,376 --> 00:17:47,146
of change of angular motion.


346
00:17:47,656 --> 00:17:50,636
It's very good for observing
something like wrist rotation.


347
00:17:50,636 --> 00:17:52,396
When you are rotating
your wrist,


348
00:17:52,396 --> 00:17:55,196
there is a rotational motion
around the x-axis of the device,


349
00:17:55,196 --> 00:17:57,556
and you can observe that
using rotation rate.


350
00:17:58,276 --> 00:18:01,146
You can also observe any
rotation around the body.


351
00:18:01,436 --> 00:18:05,566
Because most of us, we fix
our torso and we move our arms


352
00:18:05,696 --> 00:18:08,876
so there is going to be some
kind of an arcing motion.


353
00:18:08,876 --> 00:18:13,016
So there is rotation and you can
observe it using the rotation


354
00:18:13,016 --> 00:18:14,646
rate property of Device Motion.


355
00:18:17,116 --> 00:18:19,966
The last of the properties
is user acceleration.


356
00:18:19,966 --> 00:18:22,406
And the user acceleration
that you get


357
00:18:22,406 --> 00:18:24,706
through Device Motion is
compensated for gravity.


358
00:18:25,216 --> 00:18:28,026
Recall how I mentioned
that accelerometer picks


359
00:18:28,026 --> 00:18:29,416
up both the gravity component


360
00:18:29,416 --> 00:18:30,906
and the user-generated
component.


361
00:18:30,986 --> 00:18:33,206
So this is just the
user-generated component.


362
00:18:33,676 --> 00:18:35,936
But it has been compensated
with gravity


363
00:18:35,936 --> 00:18:39,566
that was derived using
device sensor fusion.


364
00:18:40,776 --> 00:18:44,416
So that was a very quick
overview of these properties.


365
00:18:44,696 --> 00:18:46,866
Now let's take a look
at a few examples


366
00:18:46,866 --> 00:18:48,786
of how you can use
them in your apps.


367
00:18:50,536 --> 00:18:52,786
The first property is attitude.


368
00:18:53,146 --> 00:18:55,116
Attitude is very good


369
00:18:55,116 --> 00:18:57,686
for observing any kind
of repetitive motion.


370
00:18:57,916 --> 00:18:59,536
Like rep counting
in weightlifting.


371
00:18:59,536 --> 00:19:03,536
So when you are lifting
weights, you are literally going


372
00:19:03,536 --> 00:19:05,626
through a set of
orientation changes.


373
00:19:05,756 --> 00:19:09,996
So just by looking at how
those orientation changes are


374
00:19:09,996 --> 00:19:12,006
repeating, you can
count the reps.


375
00:19:12,296 --> 00:19:14,336
And the best part about
using attitude for doing


376
00:19:14,336 --> 00:19:16,656
that is now they might
be using a machine


377
00:19:16,656 --> 00:19:19,846
where they're pulling
horizontally or from the top


378
00:19:19,846 --> 00:19:22,576
and you can observe all of
those reps using attitude.


379
00:19:24,636 --> 00:19:26,746
Gravity, as I already
mentioned, it's very good


380
00:19:26,746 --> 00:19:28,326
for measuring tip and tilt.


381
00:19:28,856 --> 00:19:31,646
Which basically means you
can use it in a yoga app.


382
00:19:32,436 --> 00:19:37,806
So if they're doing a downward
dog or holding a warrior pose,


383
00:19:37,806 --> 00:19:40,706
then you can figure out whether
-- how still they're holding it.


384
00:19:41,076 --> 00:19:43,906
And when they're also going
from one pose to another,


385
00:19:43,906 --> 00:19:46,506
you can figure out whether
they're really doing it


386
00:19:46,506 --> 00:19:48,986
in a graceful way, or just
falling over themselves.


387
00:19:52,686 --> 00:19:57,266
One of the most useful ways
of using rotation rate is


388
00:19:57,266 --> 00:19:59,566
to observe the speed
of circular motion.


389
00:19:59,946 --> 00:20:01,946
Take, for example,
a batting cage.


390
00:20:01,986 --> 00:20:04,056
So when you are swinging
the bat,


391
00:20:04,446 --> 00:20:06,856
you're not only rotating
your arms around your body,


392
00:20:06,856 --> 00:20:08,766
but there is also the
rotation around wrist.


393
00:20:09,146 --> 00:20:12,166
So you could use both of those
components of rotation rate


394
00:20:12,166 --> 00:20:13,876
to estimate the bat speed.


395
00:20:14,206 --> 00:20:17,076
Of course you'll need to
know how long of a bat it is,


396
00:20:17,076 --> 00:20:19,806
and at what point on the bat
you want to measure the speed.


397
00:20:22,436 --> 00:20:24,686
User acceleration is best used


398
00:20:24,686 --> 00:20:26,316
when there is some
abrupt motion.


399
00:20:26,716 --> 00:20:30,046
Because accelerometer
picks up all of the motion


400
00:20:30,046 --> 00:20:33,946
that the user is doing, if
you try to do some kind of app


401
00:20:33,996 --> 00:20:35,556
where you're using
user acceleration


402
00:20:35,556 --> 00:20:36,966
to measure some small movements,


403
00:20:36,966 --> 00:20:38,836
it might get drowned
out by noise.


404
00:20:39,226 --> 00:20:42,706
So wherever there is a very
abrupt motion is the best place


405
00:20:42,736 --> 00:20:44,096
to use user acceleration.


406
00:20:44,456 --> 00:20:46,186
So something like
a punch and recoil.


407
00:20:46,186 --> 00:20:49,646
You can tell how much
pain they're inflicting


408
00:20:49,896 --> 00:20:52,716
on that sandbag,
or that opponent


409
00:20:52,716 --> 00:20:54,176
that is hopefully
made out of air.


410
00:20:56,476 --> 00:20:59,936
So those were only a
very few set of examples


411
00:20:59,936 --> 00:21:02,526
of how you can use Device
Motion within your apps.


412
00:21:03,166 --> 00:21:04,816
By -- after going through this,


413
00:21:04,816 --> 00:21:06,736
if you feel that
you have an app idea


414
00:21:06,736 --> 00:21:09,386
that could use Device Motion
and you want to find out more


415
00:21:09,386 --> 00:21:12,366
about how you can apply
Device Motion, please do stop


416
00:21:12,366 --> 00:21:14,546
by our lab tomorrow,
and we would be more


417
00:21:14,546 --> 00:21:16,496
than happy to help you.


418
00:21:16,496 --> 00:21:20,406
Now let's take a look
at that API itself.


419
00:21:20,406 --> 00:21:21,606
You have the four properties.


420
00:21:21,986 --> 00:21:24,146
Attitude and gravity,
they're unitlness.


421
00:21:24,146 --> 00:21:25,246
Gravity's the uniflector.


422
00:21:26,006 --> 00:21:29,456
User acceleration is in
G's and rotation rate is


423
00:21:29,456 --> 00:21:30,686
in radians per second.


424
00:21:32,656 --> 00:21:35,626
Before you can start
receiving Device Motion updates


425
00:21:35,626 --> 00:21:38,226
within your app, you have
to set their sample rate.


426
00:21:38,876 --> 00:21:41,296
You can set sample
rates up to 100 hertz.


427
00:21:41,716 --> 00:21:44,266
And once you have set that
sample rate, you can go ahead


428
00:21:44,266 --> 00:21:47,526
and register for updates
using the startup date method.


429
00:21:48,786 --> 00:21:51,286
From this point onwards,
you can either choose


430
00:21:51,286 --> 00:21:53,626
to poll the Device Motion
property periodically


431
00:21:53,626 --> 00:21:55,466
to receive the most
recent sample.


432
00:21:56,016 --> 00:21:58,106
Or you could provide
a callback handler


433
00:21:58,106 --> 00:22:01,186
on which you can get every
single update the Device Motion


434
00:22:01,186 --> 00:22:02,206
is generating for you.


435
00:22:03,676 --> 00:22:06,486
And of course, once you
are done with the --


436
00:22:06,486 --> 00:22:08,696
listening to the Device Motion
updates, you can go ahead


437
00:22:08,696 --> 00:22:11,956
and deregister using the
stopDeviceMotionUpdates.


438
00:22:12,296 --> 00:22:15,916
That brings me to the end
of my section of the talk.


439
00:22:16,146 --> 00:22:18,956
Now I'll be handing it forward
to Paul, who will be walking you


440
00:22:18,956 --> 00:22:21,706
through an example
app on the Apple Watch


441
00:22:21,836 --> 00:22:24,166
that uses Device Motion
in an interesting manner.


442
00:22:24,906 --> 00:22:25,456
Thank you very much.


443
00:22:25,456 --> 00:22:25,976
Over to you Paul.


444
00:22:26,516 --> 00:22:33,546
[ Applause ]


445
00:22:34,046 --> 00:22:36,166
>> Thank you Bharath.


446
00:22:36,226 --> 00:22:36,736
Hello everyone.


447
00:22:37,696 --> 00:22:38,696
My name is Paul Thompson,


448
00:22:38,976 --> 00:22:40,076
and I'm an engineer
with Core Motion.


449
00:22:41,516 --> 00:22:42,816
So Bharath just talked
about what's new


450
00:22:42,816 --> 00:22:43,956
with Core Motion APIs.


451
00:22:44,556 --> 00:22:47,376
What I'd like to do is show
you how to use one of them


452
00:22:47,376 --> 00:22:50,166
in an Apple Watch fitness app.


453
00:22:50,446 --> 00:22:52,136
So in this app, what we'd


454
00:22:52,136 --> 00:22:54,126
like to do is create a
tennis workout session.


455
00:22:54,606 --> 00:22:56,086
Then we'll do -- we'll subscribe


456
00:22:56,086 --> 00:22:58,026
to sensor updates
with Device Motion.


457
00:22:59,216 --> 00:23:02,266
Finally, we'll detect
swings and differentiate


458
00:23:02,266 --> 00:23:04,146
between a forehand
and a backhand swing.


459
00:23:04,716 --> 00:23:09,136
Now to do this, what we'll need
to do is leverage capabilities


460
00:23:09,136 --> 00:23:10,936
from Core Motion, as well


461
00:23:10,936 --> 00:23:14,526
as some new capabilities
from HealthKit.


462
00:23:14,526 --> 00:23:18,676
Now as you may remember,
watchOS 2 apps strongly relied


463
00:23:18,676 --> 00:23:21,286
on HealthKit and Core Motion
to do real-time analysis


464
00:23:21,286 --> 00:23:23,576
and sensor output and
provide you with values


465
00:23:23,576 --> 00:23:29,056
such as step count, flights,
distance, and calorie estimates.


466
00:23:29,056 --> 00:23:32,736
Now, during a workout session,
your app can do limited work


467
00:23:33,466 --> 00:23:36,696
and process Device Motion
samples while the user's not


468
00:23:36,696 --> 00:23:38,286
directly engaged in your app.


469
00:23:39,976 --> 00:23:43,276
But of course, this ability
comes with some caveats.


470
00:23:44,446 --> 00:23:47,106
To begin with, you must have
enabled this new HealthKit


471
00:23:47,106 --> 00:23:48,916
entitlement in your
Xcode project.


472
00:23:50,416 --> 00:23:54,376
Further, this background work
can only be done during an


473
00:23:54,376 --> 00:23:55,336
active workout session.


474
00:23:55,796 --> 00:24:00,766
And in addition,
while backgrounded,


475
00:24:00,766 --> 00:24:03,056
you must minimize
your CPU usage.


476
00:24:04,106 --> 00:24:05,806
If you do not minimize
your CPU usage,


477
00:24:06,116 --> 00:24:07,196
your app will be suspended


478
00:24:07,576 --> 00:24:13,176
until the user explicitly
foregrounds it again.


479
00:24:13,386 --> 00:24:15,346
Now since this background
capability is being provided


480
00:24:15,346 --> 00:24:18,286
by HealthKit, I encourage you
to view the earlier session


481
00:24:18,286 --> 00:24:22,056
to learn more in
detail about this.


482
00:24:22,276 --> 00:24:24,026
With that in mind, let's think


483
00:24:24,026 --> 00:24:25,096
about what our app
might look like.


484
00:24:26,556 --> 00:24:29,576
Well with app, you would
expect you and a friend to out


485
00:24:29,576 --> 00:24:31,206
to the tennis courts
with your Apple Watches,


486
00:24:31,366 --> 00:24:32,626
and practicing volleying
for a bit.


487
00:24:33,926 --> 00:24:35,526
There, you simply
start a quick workout,


488
00:24:35,956 --> 00:24:37,806
and hit the ball back and forth.


489
00:24:39,356 --> 00:24:43,156
Then, you'd expect that at any
time you take a quick glance


490
00:24:43,156 --> 00:24:44,976
at your watch, and get some
media feedback on the play.


491
00:24:53,366 --> 00:24:54,126
So with that in mind,


492
00:24:54,796 --> 00:24:56,146
let's think about the
structure of our project.


493
00:24:57,126 --> 00:24:59,226
Here, there'll be three layers
that we want to care about.


494
00:24:59,696 --> 00:25:03,146
First is the UI, where
we'll ultimately present


495
00:25:03,146 --> 00:25:05,536
to the user what we've done.


496
00:25:05,756 --> 00:25:07,966
Then, we'll have
our workout manager.


497
00:25:08,826 --> 00:25:11,836
We'll interact with
HealthKit and start


498
00:25:11,836 --> 00:25:13,256
and stop our workout sessions


499
00:25:13,596 --> 00:25:14,996
and enable our background
inability.


500
00:25:16,936 --> 00:25:19,576
Then we'll enable our -- then
we'll have our motion manager.


501
00:25:20,166 --> 00:25:23,316
Here we'll interact with
Core Motion directly,


502
00:25:23,356 --> 00:25:25,606
and implement our
detection algorithm.


503
00:25:27,066 --> 00:25:29,576
There we'll respond to 50
hertz Device Motion updates,


504
00:25:29,906 --> 00:25:31,676
and add the resulting
samples to a running buffer.


505
00:25:33,106 --> 00:25:34,716
Afterwards, on every update,


506
00:25:35,346 --> 00:25:37,446
we'll assess whether a
swing occurred, and if so,


507
00:25:37,496 --> 00:25:38,296
we'll implement the UI.


508
00:25:43,046 --> 00:25:45,406
So how do we want to -- how
do we want to model the swing


509
00:25:45,406 --> 00:25:46,226
that we wish to detect?


510
00:25:48,156 --> 00:25:49,876
Well, tennis is a
complicated sport.


511
00:25:50,666 --> 00:25:52,806
So in this case, all
we'll do is we'll look


512
00:25:52,806 --> 00:25:54,406
at the essence of two gestures.


513
00:25:55,116 --> 00:25:56,996
A full forehand and
backhand swing.


514
00:25:58,256 --> 00:26:01,366
We'll do this using the
gravity and rotation vectors


515
00:26:01,366 --> 00:26:04,566
as provided by Device Motion.


516
00:26:04,676 --> 00:26:08,196
So if you expect the watch
to be in the dominant arm,


517
00:26:08,936 --> 00:26:10,556
then you would expect
a full forehand swing


518
00:26:10,556 --> 00:26:14,356
to include a simple
rotation about the user.


519
00:26:14,356 --> 00:26:18,066
So if we take the dot
product of the rotation rate


520
00:26:18,066 --> 00:26:20,736
from a potential swing with
the gravity unit vector,


521
00:26:21,506 --> 00:26:24,416
we can isolate this movement
while ignoring the attitude


522
00:26:24,416 --> 00:26:25,076
of the device.


523
00:26:25,696 --> 00:26:27,556
And also ignoring some
extraneous movement.


524
00:26:29,496 --> 00:26:33,906
Then, once we've got
enough samples of this,


525
00:26:34,316 --> 00:26:35,756
we'll see if we've
rotated far enough


526
00:26:36,236 --> 00:26:37,866
and fast enough to
count as a swing.


527
00:26:37,866 --> 00:26:41,876
So now that we know what to do,


528
00:26:41,876 --> 00:26:44,186
let's take a look
at our sample app.


529
00:26:46,016 --> 00:26:48,656
To begin, we'll envision
our simple UI.


530
00:26:49,186 --> 00:26:54,096
We'll display our
information to the user.


531
00:26:54,096 --> 00:26:56,826
Here we'll have three watch kit
interface labels that we'll want


532
00:26:56,826 --> 00:26:57,826
to update during runtime.


533
00:26:58,906 --> 00:27:00,766
These will include
the workout label.


534
00:27:01,656 --> 00:27:03,076
The forehand count label.


535
00:27:03,196 --> 00:27:04,986
And the backhand count label.


536
00:27:05,546 --> 00:27:07,946
And what the workout label will
do, will simply tell a user


537
00:27:07,946 --> 00:27:10,306
when we've started and
stopped the workout session.


538
00:27:11,136 --> 00:27:14,346
And the forehand and backhand
count labels will simply show


539
00:27:14,546 --> 00:27:16,826
how many times we've
detected the right movement.


540
00:27:18,076 --> 00:27:20,576
Here we'll also have a
force touch menu to start


541
00:27:20,576 --> 00:27:21,726
and stop the workout session.


542
00:27:21,726 --> 00:27:29,916
So now that we know what the
UI will show, let's take a look


543
00:27:29,916 --> 00:27:30,786
at our workout manager.


544
00:27:32,056 --> 00:27:35,976
Here, we'll handle our
interactions with HealthKit,


545
00:27:35,976 --> 00:27:37,836
as well as create
our workout session.


546
00:27:39,236 --> 00:27:42,266
We'll also direct our motion
manager below to start


547
00:27:42,266 --> 00:27:43,476
and stop sensor updates.


548
00:27:44,036 --> 00:27:50,746
So here, in our workout manager,
we'll have to start a workout.


549
00:27:51,316 --> 00:27:55,066
So to begin, we'll create
our workout configuration


550
00:27:55,316 --> 00:27:57,146
which we'll use to initiate
the workout session.


551
00:27:57,686 --> 00:27:59,876
Since we're creating
a tennis app,


552
00:28:00,356 --> 00:28:01,936
let's use tennis as
the activity type.


553
00:28:02,526 --> 00:28:03,766
And outdoors as the location.


554
00:28:05,176 --> 00:28:07,556
Then, after initialization,


555
00:28:08,306 --> 00:28:11,316
we'll have HealthKit start the
workout session and subscribe


556
00:28:11,316 --> 00:28:12,426
to Device Motion updates.


557
00:28:13,486 --> 00:28:14,986
At this point, we'll now be able


558
00:28:14,986 --> 00:28:16,726
to do work while
the screen is off.


559
00:28:20,576 --> 00:28:22,946
In addition, we'll also
need to stop our workout.


560
00:28:24,246 --> 00:28:27,916
Here, we'll simply do the
reverse motion and unsubscribe


561
00:28:27,916 --> 00:28:30,116
from sensor updates,
and then tell HealthKit


562
00:28:30,116 --> 00:28:31,156
to end the workout session.


563
00:28:31,966 --> 00:28:38,186
At this point, normal
backgrounding rules will apply.


564
00:28:38,376 --> 00:28:40,706
So now, let's take a look
at our motion manager.


565
00:28:41,256 --> 00:28:43,616
He will interface with
Core Motion directly,


566
00:28:43,616 --> 00:28:44,946
and implement our
detection algorithm.


567
00:28:50,076 --> 00:28:54,026
So to begin, what we'll do
here is we'll create a link


568
00:28:54,026 --> 00:28:55,086
to the CM motion manager.


569
00:28:55,616 --> 00:28:58,186
As well as create an
NS operation queue for


570
00:28:58,186 --> 00:28:59,236
or samples to do work on.


571
00:28:59,696 --> 00:29:03,136
At this point, we'll
also ask if the watch is


572
00:29:03,136 --> 00:29:04,716
on the left or the right wrist.


573
00:29:05,076 --> 00:29:06,866
There's a difference
between the forehand


574
00:29:06,866 --> 00:29:09,256
and the backhand swing
will depend entirely


575
00:29:09,256 --> 00:29:09,916
on this perspective.


576
00:29:10,246 --> 00:29:15,996
We'll also keep a local count of
a forehand and backhand swings,


577
00:29:16,716 --> 00:29:22,616
as well as mark as whether
we've recently seen a swing.


578
00:29:22,756 --> 00:29:24,666
We'll also choose 50
hertz as our sample rate.


579
00:29:25,276 --> 00:29:26,166
And create a running buffer


580
00:29:26,166 --> 00:29:27,786
that should hold no more
than a second's data.


581
00:29:27,786 --> 00:29:31,836
Now as Bharath mentioned
earlier,


582
00:29:32,476 --> 00:29:34,176
Device Motion samples
can be provided


583
00:29:34,176 --> 00:29:35,506
at a rate up to 100 hertz.


584
00:29:36,126 --> 00:29:38,836
While you generally want to pick
the sample rate that's as small


585
00:29:38,836 --> 00:29:40,646
as you can get away with,
while also providing you


586
00:29:40,646 --> 00:29:42,326
with fidelity that you need.


587
00:29:44,696 --> 00:29:48,276
In addition, we'll set three
constants which we'll use


588
00:29:48,276 --> 00:29:49,176
in our detection algorithm.


589
00:29:50,216 --> 00:29:52,846
These will include the minimum
angle's [inaudible] swing,


590
00:29:52,956 --> 00:29:55,766
the lower bound on the peak
speed through the swing,


591
00:29:56,916 --> 00:29:58,886
and an upper bound on the
settling speed of the swing.


592
00:29:59,416 --> 00:30:03,386
Now we chose these values
based on experimentation


593
00:30:03,386 --> 00:30:04,576
and sample data that
we collected.


594
00:30:05,526 --> 00:30:08,116
But generally, you'll find
that the process of collecting


595
00:30:08,116 --> 00:30:12,406
and picking these values will
be half the battle of your app.


596
00:30:12,656 --> 00:30:15,176
Finally, we'll create this
delegate reference here,


597
00:30:15,466 --> 00:30:20,796
which we'll use to
communicate back to the UI.


598
00:30:20,956 --> 00:30:23,466
So now, after we set
all of our properties,


599
00:30:24,116 --> 00:30:27,136
we'll adjust the operation queue
to reflect as a serial queue


600
00:30:27,566 --> 00:30:29,876
that we'll use to handle all
of our Device Motion samples.


601
00:30:31,226 --> 00:30:33,756
I'd like to emphasize
here, that we chose --


602
00:30:33,966 --> 00:30:36,736
we created this operation
queue to ensure that all


603
00:30:36,736 --> 00:30:38,886
of our data processing
happens off of the main queue.


604
00:30:39,496 --> 00:30:44,736
So now we'll also create
this function which we'll use


605
00:30:44,736 --> 00:30:46,296
to reset all the
statement class,


606
00:30:46,716 --> 00:30:50,846
as well as zero out the UI.


607
00:30:50,846 --> 00:30:53,606
And then, as a final set
of convenience methods,


608
00:30:54,266 --> 00:30:56,886
we'll create some complementary
update delegate functions.


609
00:30:58,256 --> 00:31:01,276
Here, we'll simply implement
our count of the swing,


610
00:31:02,156 --> 00:31:03,566
mark that we've recently
seen a swing,


611
00:31:03,566 --> 00:31:05,986
and then let the UI know it.


612
00:31:09,716 --> 00:31:12,546
So let's start interfacing
with Core Motion.


613
00:31:13,986 --> 00:31:17,886
So as always, the first thing
we should do is ask whether the


614
00:31:17,886 --> 00:31:20,316
API's supported on the
device we're running on.


615
00:31:21,496 --> 00:31:25,686
Then, we'll tell Core Motion to
update us at a 50 hertz cadence.


616
00:31:26,376 --> 00:31:30,166
And finally, we'll subscribe
to Device Motion updates


617
00:31:30,686 --> 00:31:33,386
by passing our operation
queue, as well as a block


618
00:31:33,386 --> 00:31:36,296
that we'll use to respond to all
incoming Device Motion samples.


619
00:31:37,686 --> 00:31:40,166
All this block will do
is simply check to see


620
00:31:40,166 --> 00:31:43,016
if there are any errors with
the update, then pass it along


621
00:31:43,016 --> 00:31:43,966
to our detection function.


622
00:31:43,966 --> 00:31:50,806
So let's take a look at what
our detection function's going


623
00:31:50,806 --> 00:31:51,736
to do.


624
00:31:52,556 --> 00:31:54,036
So as Bharath mentioned earlier,


625
00:31:54,446 --> 00:31:56,066
Device Motion gives
us quite a few things.


626
00:31:56,726 --> 00:31:59,106
But in this example, we're only
going to look at the gravity


627
00:31:59,236 --> 00:32:00,486
and rotation rate vectors.


628
00:32:00,486 --> 00:32:03,256
Now, as you may remember,


629
00:32:03,726 --> 00:32:06,106
the gravity vector is simply
Core Motion's destination.


630
00:32:06,466 --> 00:32:07,486
The gravity univector,


631
00:32:07,836 --> 00:32:09,346
regardless of how much
the device has moved.


632
00:32:10,276 --> 00:32:12,896
And the rotation rate is
simply a rotation vector


633
00:32:12,896 --> 00:32:16,766
for the device, giving
us radians per second.


634
00:32:16,876 --> 00:32:21,286
So now, what our [inaudible]
will do is we'll take the dot


635
00:32:21,286 --> 00:32:24,286
product -- will take the dot
product of the rotation vector


636
00:32:24,286 --> 00:32:26,896
from a potential swing
with a gravity univector.


637
00:32:27,606 --> 00:32:28,956
So we only analyzed
the proportion


638
00:32:28,956 --> 00:32:29,896
of motion about gravity.


639
00:32:31,676 --> 00:32:34,336
Then, we'll add the
resulting scaler


640
00:32:34,416 --> 00:32:36,746
to a running buffer holding
no more than a second's data.


641
00:32:37,236 --> 00:32:40,726
Once we have enough
content, we begin to analyze


642
00:32:40,726 --> 00:32:44,116
in the content within.


643
00:32:44,256 --> 00:32:46,596
So the two metrics we'll use


644
00:32:46,596 --> 00:32:49,586
to analyze the swing are the
accumulated angle of rotation


645
00:32:50,236 --> 00:32:51,356
and the peak speed of the swing.


646
00:32:51,906 --> 00:32:56,806
Here, to get the accumulating
rotation simply integrate all


647
00:32:56,806 --> 00:32:58,926
the accumulated samples that
we've collected from rotation


648
00:32:59,956 --> 00:33:02,326
over the second that
we've collected them.


649
00:33:02,326 --> 00:33:05,226
Then you have peak rate, you
simply take a min or max,


650
00:33:05,526 --> 00:33:06,886
depending on the
direction of rotation.


651
00:33:07,336 --> 00:33:12,806
Further down our
function, we'll check to see


652
00:33:13,206 --> 00:33:17,646
if we subtended far enough and
fast enough to count as a swing.


653
00:33:17,826 --> 00:33:21,956
If so, we'll choose forehand or
backhand conveying the position


654
00:33:21,956 --> 00:33:24,196
of the Apple Watch and
the sign of the scalers.


655
00:33:24,736 --> 00:33:31,316
And finally, to end the
function, we'll add a check


656
00:33:31,316 --> 00:33:32,436
to see that the swing
is settled.


657
00:33:33,346 --> 00:33:35,476
This way we can reject
some of the recoil movement


658
00:33:35,686 --> 00:33:39,776
as the user's arm moves back in
position for the next volley.


659
00:33:39,946 --> 00:33:42,056
And finally, to finish
off the class,


660
00:33:42,466 --> 00:33:43,956
we'll have the stopUpdates
function.


661
00:33:44,486 --> 00:33:46,936
Which we'll use to unsubscribe
from DeviceMotionUpdates


662
00:33:47,266 --> 00:33:48,216
when the workout has ended.


663
00:33:48,776 --> 00:33:54,066
And that concludes the
basics of our sample app.


664
00:33:54,416 --> 00:33:56,366
We simply described a
simple user interface.


665
00:33:57,126 --> 00:33:58,746
We then created a
workout management.


666
00:33:59,066 --> 00:34:00,386
Handle interfacing
with HealthKit.


667
00:34:00,976 --> 00:34:04,456
And then we created our motion
manager to handle Core Motion,


668
00:34:04,456 --> 00:34:06,316
as well as implement
our detection algorithm.


669
00:34:06,876 --> 00:34:10,896
So I hope you all have
gotten a good feel for how


670
00:34:10,896 --> 00:34:13,596
to use Device Motion as newly
brought to the Apple Watch.


671
00:34:17,516 --> 00:34:20,775
So before I wrap up, I'd like
to emphasize a few details


672
00:34:20,775 --> 00:34:21,746
on the use of this API.


673
00:34:22,476 --> 00:34:26,576
So now while you may expect
the watch to be in a fixed


674
00:34:26,576 --> 00:34:29,376
and predictable location,
always remember to check


675
00:34:29,626 --> 00:34:32,726
which wrist the device
is on as this difference


676
00:34:32,726 --> 00:34:35,116
of position can have significant
impact on your analysis.


677
00:34:35,636 --> 00:34:40,356
Further, when using
inertial senses,


678
00:34:40,666 --> 00:34:41,616
always try to remember --


679
00:34:42,335 --> 00:34:44,356
try to understand what
the reference frame you're


680
00:34:44,356 --> 00:34:45,396
operating in.


681
00:34:46,775 --> 00:34:50,746
And further, as we said earlier,
Device Motion provides you


682
00:34:50,746 --> 00:34:52,636
with samples at a
rate up to 100 hertz.


683
00:34:53,545 --> 00:34:54,926
We always want to
strike a balance


684
00:34:55,376 --> 00:34:57,656
between the resources required
to service your sample rate,


685
00:34:57,956 --> 00:34:59,986
and the fidelity demanded
by your application.


686
00:35:01,086 --> 00:35:02,216
This is especially important,


687
00:35:02,576 --> 00:35:04,376
given the restrictions
placed during backgrounding


688
00:35:04,446 --> 00:35:05,286
of a workout session.


689
00:35:05,816 --> 00:35:11,676
And so to summarize the talk
as a whole, we earlier talked


690
00:35:11,676 --> 00:35:12,966
about the performance
improvements


691
00:35:12,966 --> 00:35:14,136
to historical accelerometer.


692
00:35:14,646 --> 00:35:17,746
Then we demonstrated how
you can use pedometer events


693
00:35:18,056 --> 00:35:20,386
to precisely tag
segments, provide important,


694
00:35:20,386 --> 00:35:24,146
contextual feedback to users,
and then we introduced you


695
00:35:24,146 --> 00:35:26,056
to Device Motion
on the Apple Watch.


696
00:35:26,706 --> 00:35:28,476
And walked you through
an app to detect forehand


697
00:35:28,516 --> 00:35:30,906
and backhand swings
during a tennis workout.


698
00:35:32,896 --> 00:35:35,696
So now if you'd like to
find out more information,


699
00:35:36,136 --> 00:35:37,776
such as documentation
and sample code,


700
00:35:38,616 --> 00:35:40,086
please check out this link.


701
00:35:42,296 --> 00:35:45,986
And further, as you saw, this
app interacts with new features


702
00:35:45,986 --> 00:35:47,816
from HealthKit so
I encourage you all


703
00:35:47,816 --> 00:35:49,806
to view this HealthKit
session to learn more


704
00:35:49,806 --> 00:35:52,216
in detail what's
new for watchOS 3.


705
00:35:53,196 --> 00:35:56,146
In addition, Core Location has
some Best Practices for you


706
00:35:56,146 --> 00:35:58,386
to review, and encourage you
to check them out as well.


707
00:35:58,926 --> 00:36:02,966
And finally, I also recommend
checking out what else we have


708
00:36:02,966 --> 00:36:04,476
in store in watchOS 3.


709
00:36:05,706 --> 00:36:05,976
Thank you.


710
00:36:06,516 --> 00:36:09,500
[ Applause ]

