1
00:00:00,506 --> 00:00:10,546
[ Silence ]


2
00:00:11,046 --> 00:00:11,396
>> Morning.


3
00:00:11,396 --> 00:00:12,846
Everyone hear me?


4
00:00:13,226 --> 00:00:16,966
All right, welcome to
Efficient Design with XPC.


5
00:00:16,966 --> 00:00:19,866
Thanks for choosing Russian
Hill for your post-lunch siesta.


6
00:00:20,516 --> 00:00:21,276
Let's get started.


7
00:00:22,126 --> 00:00:25,856
So on the agenda for today, this
a talk that's going to focus


8
00:00:25,856 --> 00:00:29,586
on performance and the two
dimensions of that are going


9
00:00:29,586 --> 00:00:32,555
to be architectural
design and implementation.


10
00:00:32,866 --> 00:00:33,926
And towards those ends,


11
00:00:33,926 --> 00:00:36,386
we're going to be covering
some new features in XPC


12
00:00:36,686 --> 00:00:38,856
and cover some more advanced


13
00:00:38,856 --> 00:00:41,426
and more efficient usage
patterns beyond some


14
00:00:41,486 --> 00:00:43,866
of the basics that you might
have been exposed to over time.


15
00:00:44,956 --> 00:00:50,216
So last time we gave a talk
on XPC, it was WWDC 2011.


16
00:00:50,836 --> 00:00:53,006
So, let's do a short recap.


17
00:00:54,216 --> 00:00:59,136
XPC is combined service
bootstrapping and IPC.


18
00:00:59,136 --> 00:01:02,416
So, everything relating to
getting a service up and running


19
00:01:02,416 --> 00:01:05,596
and talking to it,
exchanging messages,


20
00:01:05,596 --> 00:01:08,156
it's all in the same library.


21
00:01:08,986 --> 00:01:11,316
And this enables you to
easily factor your app


22
00:01:11,316 --> 00:01:16,086
into different services so that
one service can be responsible


23
00:01:16,086 --> 00:01:17,976
for, say, network communication,


24
00:01:18,226 --> 00:01:19,886
they can have additional
privilege levels,


25
00:01:19,886 --> 00:01:20,536
things like that.


26
00:01:21,136 --> 00:01:23,686
And they are all deployed
within the App Bundle


27
00:01:23,686 --> 00:01:25,146
and they never leave
the App Bundle.


28
00:01:25,766 --> 00:01:28,226
So why would you use this?


29
00:01:28,226 --> 00:01:31,156
Well, separate address basis
provide some key benefits.


30
00:01:31,156 --> 00:01:33,686
The first big one
is Fault Isolation.


31
00:01:33,996 --> 00:01:36,236
So if you have a piece of code
that's going to be running


32
00:01:36,236 --> 00:01:38,956
in your app, let's say it's
dealing with untrusted data


33
00:01:38,956 --> 00:01:41,306
and you don't necessarily
want bugs in your parser


34
00:01:41,306 --> 00:01:43,016
to bring down the entire app.


35
00:01:43,816 --> 00:01:45,356
Putting in another process means


36
00:01:45,356 --> 00:01:47,716
that if you do encounter
a bug parsing some


37
00:01:47,716 --> 00:01:52,536
of that untrusted data,
you'll end up crashing, say,


38
00:01:52,536 --> 00:01:55,186
the service but the main
app is free to try again


39
00:01:55,446 --> 00:01:57,146
or display some UI
to the user saying,


40
00:01:57,146 --> 00:01:58,276
"Sorry, I couldn't do this."


41
00:01:58,996 --> 00:02:01,236
And also, on the other
side of this coin,


42
00:02:01,446 --> 00:02:03,726
you'll have a different
set of privilege levels


43
00:02:03,726 --> 00:02:06,016
for that same-- for
that service.


44
00:02:06,336 --> 00:02:09,256
So your app might have a set
of entitlements for example


45
00:02:09,515 --> 00:02:11,566
that allow it to,
say, talk to iCloud


46
00:02:11,566 --> 00:02:15,536
or read the contacts database
but the service that's working


47
00:02:15,536 --> 00:02:18,566
with untrusted data doesn't
necessarily need all of that.


48
00:02:18,706 --> 00:02:21,836
So, even if there is a
bug in a parser to exploit


49
00:02:21,896 --> 00:02:24,596
to get random code
running, code running


50
00:02:24,596 --> 00:02:28,396
in that process will not be able
to really do a whole lot that,


51
00:02:28,396 --> 00:02:29,996
say, the main app
would be able to do.


52
00:02:29,996 --> 00:02:32,876
And this allows you to
design with the principle


53
00:02:32,876 --> 00:02:34,636
of least required
privilege in mind.


54
00:02:35,316 --> 00:02:38,796
And we also provide a
completely managed lifecycle


55
00:02:38,796 --> 00:02:39,956
for all these services.


56
00:02:40,156 --> 00:02:44,086
So, you don't have to worry
about spawning them yourself


57
00:02:44,086 --> 00:02:46,396
or setting up an idle exit
timer so that they exit


58
00:02:46,396 --> 00:02:49,066
in an appropriate time.


59
00:02:49,276 --> 00:02:51,026
We completely manage
all of it for you


60
00:02:51,026 --> 00:02:53,086
and there's a lot less
boilerplate for you to write.


61
00:02:54,246 --> 00:02:57,996
So we have two ways that
XPC is kind of exported


62
00:02:57,996 --> 00:02:58,956
to you, the developer.


63
00:02:58,956 --> 00:03:01,476
The main one is Bundled
Services.


64
00:03:01,476 --> 00:03:03,676
These are the things that
we were just talking about.


65
00:03:03,946 --> 00:03:04,826
They ship in the app.


66
00:03:05,026 --> 00:03:06,036
They never leave there.


67
00:03:06,256 --> 00:03:07,516
They're completely--
they're meant


68
00:03:07,516 --> 00:03:10,366
to be basically stateless
on-demand helpers that come


69
00:03:10,366 --> 00:03:13,346
up to do something, maybe a
service, few more request,


70
00:03:13,346 --> 00:03:16,066
and can then be reclaimed
by the system later.


71
00:03:16,156 --> 00:03:18,296
And that's part of that
fully managed lifecycle.


72
00:03:18,706 --> 00:03:21,296
And this is the supported
way on the App Store


73
00:03:21,296 --> 00:03:25,876
to have multiple processes
running in your application.


74
00:03:26,856 --> 00:03:31,646
We also support launchd services
so that you can XPC to talk


75
00:03:31,646 --> 00:03:33,466
to a launchd job that
you put on the system.


76
00:03:33,826 --> 00:03:36,976
But this requires an additional
step for installation.


77
00:03:36,976 --> 00:03:38,516
You have to have
the launchd plist


78
00:03:38,516 --> 00:03:41,516
in either Library LaunchDaemons
or Library LaunchAgents.


79
00:03:41,906 --> 00:03:43,926
And so the App Store
does not like that.


80
00:03:44,076 --> 00:03:45,676
We want everything to
stay in the bundle.


81
00:03:45,806 --> 00:03:47,096
So you can actually
use this part


82
00:03:47,126 --> 00:03:49,296
of the technology on the Store.


83
00:03:49,506 --> 00:03:51,766
But if you have a Gatekeeper
app or you're a sysadmin,


84
00:03:51,996 --> 00:03:53,276
it's still useful for you.


85
00:03:54,406 --> 00:03:57,856
So all of this means a little
more boilerplate code for you


86
00:03:57,856 --> 00:04:00,336
to write, but you do get
additional capabilities.


87
00:04:00,376 --> 00:04:02,256
You can run as root for one,


88
00:04:02,256 --> 00:04:04,146
which is not allowed
for App Store apps.


89
00:04:04,566 --> 00:04:06,736
And you can also run
your code independent


90
00:04:06,736 --> 00:04:08,916
of the lifecycle
of an application.


91
00:04:09,196 --> 00:04:11,116
So if you just have some
background piece of work


92
00:04:11,456 --> 00:04:16,116
that needs to happen every so
often, you can use XPC to talk


93
00:04:16,116 --> 00:04:17,636
to it, initiate it,
and get it running.


94
00:04:18,206 --> 00:04:21,896
So here's what we provide today.


95
00:04:22,276 --> 00:04:25,176
All of this is built
on top of libobjc


96
00:04:25,176 --> 00:04:26,996
which is the Objective
C runtime.


97
00:04:27,246 --> 00:04:31,616
So-- and XPC is very
heavily built on libdispatch,


98
00:04:31,616 --> 00:04:32,806
and both of those kinds


99
00:04:32,806 --> 00:04:37,186
of objects are actually objc
objects in Mountain Lion


100
00:04:37,186 --> 00:04:40,576
and later so they can
participate in ARC.


101
00:04:40,896 --> 00:04:46,496
And then way up in a space
somewhere is NSXPC connection


102
00:04:46,496 --> 00:04:47,916
which was introduced
in Mountain Lion.


103
00:04:47,916 --> 00:04:52,896
And that's a really nice set of
Cocoa APIs that aren't just kind


104
00:04:52,896 --> 00:04:54,766
of like square bracket
wrappers for XPC.


105
00:04:54,856 --> 00:04:59,186
They enable a lot of very
powerful Cocoa programing idioms


106
00:04:59,426 --> 00:05:02,366
that we just really can't do
down at the libSystem Layer


107
00:05:02,366 --> 00:05:04,086
where the C Library exits.


108
00:05:04,186 --> 00:05:08,486
So let's get started by
talking about architecture.


109
00:05:09,756 --> 00:05:12,776
So here are our architectural
goals with XPC.


110
00:05:12,986 --> 00:05:16,226
The first one we want is to
avoid long running processes.


111
00:05:16,456 --> 00:05:17,656
These are things
that just kind of sit


112
00:05:17,656 --> 00:05:19,056
around on the system forever.


113
00:05:19,556 --> 00:05:20,996
They might be listening
for an event.


114
00:05:20,996 --> 00:05:22,366
They might be doing
periodic work.


115
00:05:22,366 --> 00:05:25,066
But we would much rather that
they launch on-demand and exit


116
00:05:25,066 --> 00:05:28,106
when they're not needed so that
there's no risk of them, say,


117
00:05:28,106 --> 00:05:29,326
going crazy and starting


118
00:05:29,326 --> 00:05:31,086
to consume resources
in the background.


119
00:05:32,226 --> 00:05:35,256
We also want to be able to
adapt to changes on the system.


120
00:05:35,576 --> 00:05:38,226
So, the system's resource
availability is changing all the


121
00:05:38,226 --> 00:05:42,496
time when the user opens an app,
new sets of services come up.


122
00:05:42,496 --> 00:05:44,956
The user might log in,
more users log out.


123
00:05:44,956 --> 00:05:48,866
This means that memory, CPU
and Joules are all things


124
00:05:48,866 --> 00:05:52,006
that are being shared across the
system and we want to be able


125
00:05:52,006 --> 00:05:55,196
to say you-- you know,
you're part of a--


126
00:05:55,556 --> 00:05:57,806
you're part of a collective
and we need to divvy


127
00:05:57,806 --> 00:05:58,946
out these resources fairly.


128
00:05:59,076 --> 00:06:02,246
And finally, we want
things to initialize lazily.


129
00:06:02,246 --> 00:06:04,526
So this goes with
the on-demand theme.


130
00:06:04,716 --> 00:06:08,586
In other words, don't do work
unless the user has actually


131
00:06:08,696 --> 00:06:12,176
done something where you need
to initialize all of that.


132
00:06:12,276 --> 00:06:15,316
So, you know, be as
on-demand as possible.


133
00:06:15,906 --> 00:06:19,886
So the support list in Lion,


134
00:06:19,886 --> 00:06:24,066
we have the technology called
XPC Events and this is kind


135
00:06:24,066 --> 00:06:27,776
of a-- it's using XPC but
without actually having,


136
00:06:27,776 --> 00:06:29,486
say, an app messaging you.


137
00:06:29,486 --> 00:06:32,066
It's more like the system
is a source of demand.


138
00:06:32,206 --> 00:06:35,476
And some of those demand
sources are IOKit events.


139
00:06:35,526 --> 00:06:37,316
So, you can have a launchd job


140
00:06:37,316 --> 00:06:39,046
that will kick off
whenever changes


141
00:06:39,046 --> 00:06:40,896
in the IO Registry happen.


142
00:06:41,966 --> 00:06:43,996
And we support BSD
Notifications.


143
00:06:43,996 --> 00:06:47,146
So if you're familiar with
Notify APIs in libSystem,


144
00:06:47,396 --> 00:06:50,566
you can just post a notification
and a launchd job kicks off.


145
00:06:50,716 --> 00:06:53,756
In Mountain Lion, we
all-- sorry, in Sea Lion--


146
00:06:53,756 --> 00:06:57,526
sorry, in [laughter] Mavericks,


147
00:06:58,396 --> 00:07:01,206
we also introduced CF
Distributed Notifications.


148
00:07:01,356 --> 00:07:04,096
So if that's your preferred
way to post a notification


149
00:07:04,096 --> 00:07:05,366
and kick a job off on-demand,


150
00:07:05,736 --> 00:07:08,126
that is now supported
by XPC Events.


151
00:07:09,506 --> 00:07:12,526
And-- so, this technology
is really only available


152
00:07:12,526 --> 00:07:14,586
to launchd services
because you need


153
00:07:14,586 --> 00:07:16,266
to specify it in your plist.


154
00:07:16,426 --> 00:07:17,506
So here's how that works.


155
00:07:18,036 --> 00:07:20,676
So in your launchd plist, you
have this Launch Events Key


156
00:07:21,046 --> 00:07:23,626
and you're going to specify
"These are the kinds of events


157
00:07:23,626 --> 00:07:24,976
that I want launch
be on-demand."


158
00:07:25,056 --> 00:07:28,356
In this case, we're going to
talk about IOKit Matching.


159
00:07:28,916 --> 00:07:30,696
So here we have a dictionary


160
00:07:30,696 --> 00:07:32,676
of all the IOKit
Events that I want.


161
00:07:32,816 --> 00:07:33,996
In this case, it's just the one.


162
00:07:34,326 --> 00:07:37,826
And this is, you know, my
company's device was attached.


163
00:07:37,826 --> 00:07:40,166
And in this case, it's
just a matching dictionary.


164
00:07:40,646 --> 00:07:43,526
So you're going to have the
product ID, the vendor ID


165
00:07:43,896 --> 00:07:46,816
and the provider class all
in that matching dictionary


166
00:07:47,176 --> 00:07:50,796
and XPC will implicitly install
this matching dictionary,


167
00:07:50,796 --> 00:07:52,076
listen for it on your behalf,


168
00:07:52,386 --> 00:07:55,316
and kick you off
when this happens.


169
00:07:55,806 --> 00:07:57,576
And for Legacy reasons, you have


170
00:07:57,576 --> 00:08:01,216
to add this IOMatchLaunchStream
key and set it to true,


171
00:08:01,606 --> 00:08:04,486
just do that, I won't
explain why.


172
00:08:05,956 --> 00:08:07,676
And once these events
are posted,


173
00:08:07,676 --> 00:08:08,826
they need to be consumed.


174
00:08:08,826 --> 00:08:12,456
And you consume them by setting
a handler and this is a lot


175
00:08:12,456 --> 00:08:14,736
like a handler on
an XPC Connection.


176
00:08:15,126 --> 00:08:18,126
So you just call this XPC set
of Event Stream Handler API.


177
00:08:18,836 --> 00:08:22,976
And the first argument is that
com.apple.iokit.matching name


178
00:08:22,976 --> 00:08:25,826
which says, "This is the
handler for the IOKit Events."


179
00:08:26,176 --> 00:08:28,756
And then it takes a
dispatch queue and a block.


180
00:08:28,926 --> 00:08:31,266
And the block gets
invoked on that queue.


181
00:08:31,766 --> 00:08:33,785
And then once that
block has been invoked,


182
00:08:33,785 --> 00:08:35,106
the event has been consumed.


183
00:08:35,556 --> 00:08:38,546
And this event is treated
like an IPC message.


184
00:08:38,546 --> 00:08:41,086
So if you don't consume
the event, say,


185
00:08:41,086 --> 00:08:43,576
by not setting a handler,
after you'll exit,


186
00:08:43,576 --> 00:08:45,796
you'll be relaunched
to process it.


187
00:08:46,036 --> 00:08:49,766
In the case of the IOKit
Notification system,


188
00:08:50,486 --> 00:08:54,956
each notification has a
payload that allows you


189
00:08:54,956 --> 00:08:59,296
to extract the registry ID of
the thing of the node that fired


190
00:08:59,526 --> 00:09:00,916
and then you can reconstruct it


191
00:09:00,916 --> 00:09:04,966
and turn it into
an IO service T.


192
00:09:06,026 --> 00:09:09,136
So we've taken this
idea of things


193
00:09:09,136 --> 00:09:11,306
that can launch you
on-demand and extended it


194
00:09:11,306 --> 00:09:13,306
to Centralized Task Scheduling.


195
00:09:13,596 --> 00:09:15,836
And you interact
with this technology


196
00:09:15,836 --> 00:09:18,446
through the XPC Activity APIs.


197
00:09:18,786 --> 00:09:21,066
And what this let's you
do is schedule things kind


198
00:09:21,066 --> 00:09:22,786
of on an opportunistic basis.


199
00:09:23,536 --> 00:09:26,616
If you have some piece of work,
let's say it's a network fetch


200
00:09:26,676 --> 00:09:29,406
or doing some random
housekeeping, you might not want


201
00:09:29,406 --> 00:09:30,606
to have it happen now.


202
00:09:30,606 --> 00:09:32,586
You just want it to
happen at some point.


203
00:09:32,586 --> 00:09:33,996
You don't really care when.


204
00:09:34,556 --> 00:09:36,756
And you'd rather
just the system--


205
00:09:37,036 --> 00:09:38,226
leave it up to the system


206
00:09:38,226 --> 00:09:40,356
and let the system
determine when a good time is.


207
00:09:40,956 --> 00:09:44,786
And the idea here is to minimize
the disruption of this work


208
00:09:44,856 --> 00:09:46,366
to the user experience.


209
00:09:46,736 --> 00:09:49,026
So if the user is not
using the machine,


210
00:09:49,026 --> 00:09:51,856
that might be a good
time to do some activity


211
00:09:51,856 --> 00:09:54,826
that synchronizes a bunch
IO to disk for example.


212
00:09:55,176 --> 00:09:58,536
And this allows us to more
efficiently utilize the battery


213
00:09:58,776 --> 00:10:00,786
because we can take
certain tasks


214
00:10:00,786 --> 00:10:02,766
that have similar
characteristics like, say,


215
00:10:02,766 --> 00:10:06,056
run every 15 minutes, and
run all of those tasks


216
00:10:06,546 --> 00:10:09,766
on the same 15-minute interval
rather than letting them run


217
00:10:09,766 --> 00:10:12,966
on their own kind of
15-minute intervals.


218
00:10:13,046 --> 00:10:14,916
And this is new in Mavericks.


219
00:10:14,916 --> 00:10:17,176
So we have two basic
activity types.


220
00:10:17,176 --> 00:10:18,686
There's maintenance and utility.


221
00:10:19,066 --> 00:10:20,766
Maintenance and stuff
like garbage collection.


222
00:10:20,766 --> 00:10:23,346
Let's say, you periodically
write some files out to disk


223
00:10:23,346 --> 00:10:25,946
and you don't really need
to keep track of them.


224
00:10:26,246 --> 00:10:28,286
These tasks are going
to be interrupted


225
00:10:28,596 --> 00:10:30,606
when the user starts
using the machine.


226
00:10:30,606 --> 00:10:31,846
And they're going
to be kicked off


227
00:10:31,846 --> 00:10:33,696
when the user is basically idle.


228
00:10:34,116 --> 00:10:36,896
We also have a utility
type which is stuff


229
00:10:36,896 --> 00:10:38,116
like fetching network data.


230
00:10:38,526 --> 00:10:41,626
So this task is more directly
important to the user.


231
00:10:41,626 --> 00:10:45,176
So we're only going to interrupt
it when resources become scarce.


232
00:10:46,236 --> 00:10:50,806
So the criteria by which
you can specify an activity


233
00:10:50,806 --> 00:10:54,786
to kick off are things like
being on or off AC power.


234
00:10:55,066 --> 00:10:57,026
Whether the battery level
is at a certain percentage,


235
00:10:57,026 --> 00:10:58,556
whether the hard
disk is spinning


236
00:10:58,886 --> 00:11:00,116
and whether the screen
is asleep.


237
00:11:00,116 --> 00:11:03,086
So we can actually do your
work while the user is, say,


238
00:11:03,086 --> 00:11:06,246
not using the machine but
it's plugged in to AC power.


239
00:11:06,246 --> 00:11:08,196
That might be a great
time to do some--


240
00:11:08,246 --> 00:11:11,246
any kind of indexing task that
your app might need to do.


241
00:11:11,246 --> 00:11:16,016
And this is available to
launchd and XPC services.


242
00:11:17,986 --> 00:11:19,426
And what's really neat here is


243
00:11:19,426 --> 00:11:21,546
that it'll persist
across launches.


244
00:11:21,896 --> 00:11:25,476
So, we can interrupt an
ongoing activity that you have


245
00:11:26,356 --> 00:11:28,766
and then exit your process


246
00:11:28,766 --> 00:11:30,546
because it's not a good
time to do the activity.


247
00:11:30,816 --> 00:11:33,556
But then when a good time to do
the activity does come along,


248
00:11:33,556 --> 00:11:37,626
we'll launch you
on-demand to keep going


249
00:11:37,626 --> 00:11:39,506
and potentially complete
that task.


250
00:11:39,506 --> 00:11:41,566
And everything just kind of
picks up where it left off.


251
00:11:43,166 --> 00:11:46,266
So here's how you would just
create a basic activity.


252
00:11:46,266 --> 00:11:49,686
In this case, the activity
criteria are specified


253
00:11:49,686 --> 00:11:52,886
in an XPC dictionary and
we're going to set a few keys.


254
00:11:53,266 --> 00:11:54,846
In this case, we
have an interval.


255
00:11:54,846 --> 00:11:56,206
So we have a desired interval


256
00:11:56,206 --> 00:11:58,106
of every five minutes
this thing should go.


257
00:11:58,566 --> 00:12:02,656
And the grace periods, you know,
we have a 10-minute slack time.


258
00:12:02,656 --> 00:12:04,956
So it's like we'd like every
five minutes but it's okay


259
00:12:04,956 --> 00:12:07,626
to kind of play with
that up to 10 minutes.


260
00:12:07,986 --> 00:12:11,636
And then we're going to set
this XPC Activity Handler.


261
00:12:11,956 --> 00:12:15,146
So you just name your
activity, give the criteria


262
00:12:15,146 --> 00:12:16,236
and then a Handler Block.


263
00:12:17,006 --> 00:12:22,396
And the Handler Block delivers
the activity object that's being


264
00:12:22,466 --> 00:12:24,966
invoked to you so
that you can figure


265
00:12:24,966 --> 00:12:27,786
out which activity you're
dealing with, if you have many


266
00:12:27,786 --> 00:12:30,876
of them, and where to pick
up after you left off.


267
00:12:31,306 --> 00:12:34,106
So right now, we've
been invoked.


268
00:12:34,476 --> 00:12:37,696
So we're going to get some
piece of data from somewhere


269
00:12:38,046 --> 00:12:40,576
and then we're going to set
the activity state to continue.


270
00:12:41,066 --> 00:12:43,146
And that just means that,
you know, yes, we're going.


271
00:12:44,186 --> 00:12:46,356
And then, as the
activity is going,


272
00:12:46,496 --> 00:12:51,216
we're going to dispatch Async to
the main queue to update a view.


273
00:12:51,516 --> 00:12:53,966
And then once that block
completes, we say, "Hey,


274
00:12:53,966 --> 00:12:55,286
now this activity is done


275
00:12:55,286 --> 00:12:56,516
and you don't have
to do it anymore."


276
00:12:56,856 --> 00:12:59,456
But if that block never gets
invoked for whatever reason,


277
00:12:59,456 --> 00:13:03,346
let's-- and then let's say the
app is killed before it can be


278
00:13:03,346 --> 00:13:06,526
invoked, we'll bring you back
and then you'll be invoked


279
00:13:06,526 --> 00:13:07,646
with this Handler Block again


280
00:13:07,646 --> 00:13:08,806
and you'll get another
opportunity


281
00:13:08,806 --> 00:13:10,146
to try completing that task.


282
00:13:10,706 --> 00:13:13,946
So that's what we
have architecturally.


283
00:13:13,946 --> 00:13:17,436
This is how to-- this helps
you design more efficient apps


284
00:13:17,436 --> 00:13:18,696
that play better on the system.


285
00:13:19,066 --> 00:13:23,306
So, let's dive into the actual
ways you can use the APIs better


286
00:13:23,566 --> 00:13:24,986
to get more efficient
performance.


287
00:13:24,986 --> 00:13:28,146
Let's start by covering what we
have a service lifecycle now.


288
00:13:28,466 --> 00:13:30,696
So right now, we have
an app and we have one


289
00:13:30,696 --> 00:13:32,786
of its services there
on the right.


290
00:13:33,246 --> 00:13:36,666
The app is going to send some
messages to that service.


291
00:13:36,906 --> 00:13:38,426
The service gets
launched on-demand


292
00:13:38,426 --> 00:13:39,976
and it starts doing stuff.


293
00:13:40,296 --> 00:13:42,936
While it's doing this
stuff, it's protected


294
00:13:42,936 --> 00:13:45,936
from sudden termination
which means that the system


295
00:13:46,006 --> 00:13:49,726
under Memory Refresher won't
see that this is something


296
00:13:49,726 --> 00:13:50,616
that can be reclaimed.


297
00:13:51,136 --> 00:13:54,416
But, as the replies for all
those message got sent back,


298
00:13:54,416 --> 00:13:57,656
you saw that that green
bubble kind of faded away


299
00:13:58,126 --> 00:14:01,006
and that means that as soon
as the last one goes away


300
00:14:01,136 --> 00:14:03,436
or as soon as the last reply is
delivered, the system is free


301
00:14:03,436 --> 00:14:04,816
to reclaim that service again.


302
00:14:07,066 --> 00:14:09,176
So we have the service
launched on-demand.


303
00:14:09,386 --> 00:14:11,976
The system stops it as needed.


304
00:14:12,466 --> 00:14:14,336
These conditions can
be Memory Refresher


305
00:14:14,386 --> 00:14:17,696
or idleness and lack of use.


306
00:14:18,106 --> 00:14:23,156
And we will also tear everything
down when the app quits.


307
00:14:23,256 --> 00:14:25,726
So, Sudden Termination
as it applies


308
00:14:25,726 --> 00:14:28,796
to XPC is automatically handled.


309
00:14:29,106 --> 00:14:32,426
So since XPC knows when
you're receiving a message


310
00:14:32,426 --> 00:14:35,006
or sending a reply to a
message, we can disable


311
00:14:35,236 --> 00:14:36,746
and enable Sudden Termination


312
00:14:37,026 --> 00:14:38,996
as we see those events
coming and going.


313
00:14:39,316 --> 00:14:41,366
So in this case,
we get a message


314
00:14:41,366 --> 00:14:43,976
and then we immediately disable
Sudden Termination for you.


315
00:14:43,976 --> 00:14:45,566
And then when we see
that you've replied


316
00:14:45,566 --> 00:14:47,566
to that message,
we'll re-enable it.


317
00:14:47,566 --> 00:14:49,696
And as soon as all your
replies have been sent,


318
00:14:49,916 --> 00:14:51,256
you're killable by
the system again.


319
00:14:51,366 --> 00:14:53,916
So we've taken the same
idea and applied it


320
00:14:53,986 --> 00:14:55,786
to something called
Importance Boosting


321
00:14:55,786 --> 00:14:57,156
which is new to Mavericks.


322
00:14:57,686 --> 00:15:01,086
And this is the default behavior
now for bundled services.


323
00:15:01,276 --> 00:15:03,646
And what happens is that they
are background by default.


324
00:15:03,886 --> 00:15:07,246
So whatever the service does
will by default not interfere


325
00:15:07,246 --> 00:15:09,496
with any UI applications
that might be running.


326
00:15:10,046 --> 00:15:12,866
But, if the UI application
does message that service,


327
00:15:13,076 --> 00:15:15,596
the service's priority
gets promoted temporarily


328
00:15:15,596 --> 00:15:16,816
to handle that request.


329
00:15:17,216 --> 00:15:19,166
And the idea here is
with everything else is


330
00:15:19,166 --> 00:15:22,446
to minimize the disruption of
your work to the user experience


331
00:15:22,496 --> 00:15:25,016
if it's not directly aiding it.


332
00:15:25,076 --> 00:15:26,556
So here's how that
lifecycle works.


333
00:15:26,886 --> 00:15:30,166
It's very similar to how the
transactional lifecycle was


334
00:15:30,166 --> 00:15:30,946
managed before.


335
00:15:31,476 --> 00:15:34,836
So the app comes up, sends
some messages to the service,


336
00:15:35,466 --> 00:15:37,526
and then the service
gets launched on-demand,


337
00:15:37,526 --> 00:15:40,886
and now it's protected but now
it's boosted for that entire--


338
00:15:41,176 --> 00:15:42,556
for all three of those messages.


339
00:15:42,896 --> 00:15:46,306
And then once those messages get
sent, then the boost goes away.


340
00:15:46,306 --> 00:15:50,096
And then any work after that
point, any work the service does


341
00:15:50,146 --> 00:15:53,216
on its own behalf like, say,
from a timer or something


342
00:15:53,216 --> 00:15:56,146
like that does not
interfere with the app.


343
00:15:56,206 --> 00:15:58,436
The app will win any
resource contention fights.


344
00:15:58,996 --> 00:16:03,366
So that's bundled XPC
services by default.


345
00:16:03,366 --> 00:16:06,436
But if you have a launchd job,
you can also opt into this.


346
00:16:06,436 --> 00:16:11,856
And we have a new plist key
called Process Type in Mavericks


347
00:16:11,856 --> 00:16:15,406
that you can use on your launchd
job to opt into this behavior.


348
00:16:15,656 --> 00:16:16,666
And once you've opted in,


349
00:16:16,986 --> 00:16:20,446
it all just works
basically transparently


350
00:16:21,606 --> 00:16:23,836
because through the same
mechanisms that we use


351
00:16:23,836 --> 00:16:25,796
for tracking, sudden
termination.


352
00:16:26,866 --> 00:16:29,856
We also have some other values
for that Process Type key.


353
00:16:30,006 --> 00:16:32,906
Adaptive is the one we
would prefer that you use


354
00:16:32,906 --> 00:16:35,166
because it means that you'll
only contend with apps


355
00:16:35,426 --> 00:16:36,926
when you're doing
work on their behalf.


356
00:16:37,246 --> 00:16:39,696
And this is useful when
you have a launchd job


357
00:16:39,696 --> 00:16:40,746
that your app communicates with.


358
00:16:42,216 --> 00:16:46,656
If the launchd job never really
needs to steal resources away


359
00:16:46,656 --> 00:16:49,216
from apps on the system, you
can set it to background.


360
00:16:49,596 --> 00:16:52,606
And this is useful if you
have a launchd job that's part


361
00:16:52,606 --> 00:16:55,986
of the app but doesn't-- the app
doesn't really have a dependency


362
00:16:55,986 --> 00:16:57,356
on anything that the job does.


363
00:16:57,356 --> 00:17:01,226
So it's not supposed to update
its UI in response to something


364
00:17:01,226 --> 00:17:02,566
that that launchd job is doing.


365
00:17:02,936 --> 00:17:04,455
We also have this
Interactive key.


366
00:17:04,606 --> 00:17:08,846
We'd rather that you simply
not use it because it will mean


367
00:17:08,846 --> 00:17:10,415
that your service,
whatever it does,


368
00:17:10,415 --> 00:17:12,626
can always potentially
steal resources away


369
00:17:12,626 --> 00:17:13,626
from an application


370
00:17:13,996 --> 00:17:16,486
and potentially results
in a stuttering UI.


371
00:17:16,685 --> 00:17:18,925
And then there's a
Standard which is the same


372
00:17:18,925 --> 00:17:20,476
as just not specifying
something.


373
00:17:20,476 --> 00:17:22,306
So if you really just
want to have this key


374
00:17:22,306 --> 00:17:28,465
in your plist, use that value.


375
00:17:28,465 --> 00:17:31,706
So, we do a manner of
Automated Boost Tracking,


376
00:17:31,826 --> 00:17:33,446
but you might want to
persist your boosts.


377
00:17:33,446 --> 00:17:36,966
So you might have a work that
is going on outside the scope


378
00:17:36,966 --> 00:17:39,086
of what XPC can know about.


379
00:17:40,116 --> 00:17:42,926
So when you get a message,


380
00:17:42,996 --> 00:17:45,396
by the time you've gotten
the boosting message,


381
00:17:45,426 --> 00:17:47,096
we've already applied
this boost to you.


382
00:17:47,566 --> 00:17:50,676
And-- so if you want to persist
it, the first thing you're going


383
00:17:50,676 --> 00:17:52,226
to do is create a
reply of that message.


384
00:17:52,266 --> 00:17:55,316
And that means that the boost's
lifetime goes from the message


385
00:17:55,316 --> 00:17:57,676
that you received into
that reply object.


386
00:17:58,646 --> 00:18:01,206
And then we're going to do
some work asynchronously.


387
00:18:01,466 --> 00:18:03,296
Since we're using
ARC in this example,


388
00:18:03,576 --> 00:18:06,906
the reply object is
captured and retained.


389
00:18:06,906 --> 00:18:08,706
And therefore, the
boost stays alive


390
00:18:09,196 --> 00:18:12,756
until that reply object
goes out of scope at the end


391
00:18:12,756 --> 00:18:15,626
of this block and then
the message gets dropped--


392
00:18:15,626 --> 00:18:19,656
sorry, and then you
send the reply


393
00:18:19,656 --> 00:18:21,556
with XPC Connection
Send Message,


394
00:18:21,646 --> 00:18:24,926
and then the runtime
asynchronously sends the reply


395
00:18:24,926 --> 00:18:25,746
behind the scenes.


396
00:18:25,746 --> 00:18:28,636
And then when its final
reference gets dropped,


397
00:18:28,696 --> 00:18:31,126
the reply-- when the reply
message gets de-allocated,


398
00:18:31,696 --> 00:18:33,046
you'll end up dropping
your boost.


399
00:18:34,006 --> 00:18:36,076
There's another pattern
where you might want


400
00:18:36,106 --> 00:18:40,806
to say send multiple
replies to a single request


401
00:18:41,606 --> 00:18:44,436
and also maintain the
boost for that duration


402
00:18:44,556 --> 00:18:46,506
but the API only
directly allows you


403
00:18:46,506 --> 00:18:47,956
to send one reply to a message.


404
00:18:48,286 --> 00:18:50,056
Well we've got a--
there's a usage pattern


405
00:18:50,056 --> 00:18:53,666
where you can actually do
this using multiple replies.


406
00:18:53,776 --> 00:18:56,306
And you do that by having
an anonymous connection.


407
00:18:56,786 --> 00:19:00,346
And to create that
connection, you just give Null


408
00:19:00,346 --> 00:19:02,556
as the first parameter
to XPC Connection Create.


409
00:19:03,616 --> 00:19:06,406
So once we've created this,
we're going to send it


410
00:19:06,406 --> 00:19:09,146
to the other side to the
service in a message.


411
00:19:09,496 --> 00:19:11,886
And it's just like sending
any other key or value.


412
00:19:12,156 --> 00:19:14,376
We're just going to send
the anonymous connection


413
00:19:15,026 --> 00:19:17,666
in a message key to
the key back channel.


414
00:19:18,146 --> 00:19:21,246
And-- so once we've sent the
message, the other side gets it.


415
00:19:22,716 --> 00:19:26,936
And then we're going
to setup our end points


416
00:19:27,016 --> 00:19:29,436
to receive the replies
from that other side.


417
00:19:30,276 --> 00:19:32,206
So once we've created
the connection,


418
00:19:32,406 --> 00:19:34,836
we're going to set an event
handler on it and this is going


419
00:19:34,836 --> 00:19:37,996
to be a similar kind of
event handler to the one


420
00:19:37,996 --> 00:19:41,056
that you will set
for launchd's job


421
00:19:41,386 --> 00:19:44,046
when you use XPC Connection
Create with MockService.


422
00:19:44,426 --> 00:19:47,666
In this case, we're going
to say expect five replies


423
00:19:48,076 --> 00:19:50,736
and we're going to expect--


424
00:19:50,926 --> 00:19:53,756
or each invocation of this
event handler is going


425
00:19:53,756 --> 00:19:55,216
to deliver a connection to me.


426
00:19:55,466 --> 00:19:57,096
In this case, I'm only
ever going to get one


427
00:19:57,386 --> 00:19:59,196
because I've only ever
sent it to one person.


428
00:20:00,676 --> 00:20:03,766
So, once I get the new
connection in that handler,


429
00:20:04,026 --> 00:20:05,976
then I set the message
handler on that connection.


430
00:20:06,366 --> 00:20:10,256
And that handler gets invoked
whenever there's a new reply


431
00:20:10,736 --> 00:20:14,546
to send to-- to be given to me
and I'm just going to do stuff


432
00:20:14,546 --> 00:20:15,816
with that message and then


433
00:20:16,366 --> 00:20:18,926
that function will tell
me, "Yes, I'm done now."


434
00:20:18,926 --> 00:20:21,406
And if that's the case, we
just cancel the connection.


435
00:20:23,616 --> 00:20:27,216
So on the other side, when it
receives the message containing


436
00:20:27,216 --> 00:20:30,386
that anonymous connection,
it's going to extract it


437
00:20:30,386 --> 00:20:32,406
with XPC Dictionary
Create Connection.


438
00:20:32,406 --> 00:20:35,806
And then it just sets an event
handler on it and resumes it.


439
00:20:36,016 --> 00:20:38,536
So this is only-- it's
only ever going to be used


440
00:20:38,536 --> 00:20:39,636
for sending a message.


441
00:20:39,996 --> 00:20:42,066
So we have an event handler


442
00:20:42,066 --> 00:20:45,496
that all it does is just
cancel the connect ion.


443
00:20:45,496 --> 00:20:47,496
And we need to have
some sort of reference


444
00:20:47,496 --> 00:20:49,206
to the connection in that block.


445
00:20:49,206 --> 00:20:52,196
Otherwise, there will be
an implicit cancellation


446
00:20:52,406 --> 00:20:55,336
of the connection
because ARC will see


447
00:20:55,336 --> 00:20:56,956
that the variable
has gone out of scope


448
00:20:56,956 --> 00:20:58,266
in not referenced from anywhere.


449
00:21:01,716 --> 00:21:04,966
So here's the interesting
part where the server is going


450
00:21:04,966 --> 00:21:08,796
to send back however many
replies to the client it wants.


451
00:21:09,066 --> 00:21:13,106
In this case, we're just going
to dispatch apply five things


452
00:21:13,106 --> 00:21:15,126
on a concurrent dispatch queue.


453
00:21:15,606 --> 00:21:18,576
And then we're going to send
them all to that connection


454
00:21:18,576 --> 00:21:22,616
that we got out of the message
the same way we would send


455
00:21:22,676 --> 00:21:24,766
to any normal connection
that we created with, say,


456
00:21:24,826 --> 00:21:26,216
XPC Connection Create.


457
00:21:26,306 --> 00:21:27,146
So we'll do stuff.


458
00:21:27,146 --> 00:21:28,226
We'll populate the message.


459
00:21:28,226 --> 00:21:34,136
And then we just send the
reply or the iterate of reply


460
00:21:34,136 --> 00:21:36,126
over to the backchannel
connection.


461
00:21:36,496 --> 00:21:39,376
And ARC will capture
that reply--


462
00:21:39,376 --> 00:21:41,826
sorry, ARC will capture
that message object


463
00:21:41,876 --> 00:21:43,416
in all five of these blocks.


464
00:21:43,746 --> 00:21:45,626
So when the last of
them runs and gets--


465
00:21:45,936 --> 00:21:49,566
and goes away, the message will
have its last reference released


466
00:21:49,606 --> 00:21:50,796
and then your boost drops.


467
00:21:51,366 --> 00:21:57,136
So we've also made some
changes to how large chunks


468
00:21:57,136 --> 00:21:58,356
of data are handled in XPC.


469
00:21:58,486 --> 00:22:02,596
The runtime recognizes
very large data objects.


470
00:22:02,686 --> 00:22:06,516
And when it sees one of these,
it goes down a fast path


471
00:22:06,516 --> 00:22:09,446
to avoid copying
as much as it can.


472
00:22:09,446 --> 00:22:11,676
So what this means to you is


473
00:22:11,676 --> 00:22:15,566
that there is now a path
you can take to make sure


474
00:22:15,566 --> 00:22:18,286
that when you give XPC
a large buffer of data


475
00:22:18,286 --> 00:22:20,986
that it is never
copied from the time


476
00:22:20,986 --> 00:22:23,476
that you created data
object out of it to the time


477
00:22:23,476 --> 00:22:27,026
that the other guy receives it,
and it's completely copyless.


478
00:22:27,116 --> 00:22:32,396
So, how this works is that
we deal with the VM Object


479
00:22:32,426 --> 00:22:35,526
that backs your large buffer
and then we just share it


480
00:22:35,526 --> 00:22:37,976
as a copy-on-write
shared memory.


481
00:22:38,246 --> 00:22:40,726
And this is a page
granular allocation.


482
00:22:41,176 --> 00:22:45,826
So, you can't really share--
since we use VM memory sharing


483
00:22:45,826 --> 00:22:48,396
to do this, you can't really
share less than a page


484
00:22:48,566 --> 00:22:50,916
and you can't share, say,
one and a half pages.


485
00:22:50,916 --> 00:22:54,756
So it has to be a page-aligned
allocation that you own.


486
00:22:54,886 --> 00:22:59,006
So a VM allocation that you've
actually taken ownership of


487
00:22:59,006 --> 00:23:01,596
and created and know
the characteristics of.


488
00:23:01,676 --> 00:23:03,946
And here's why that
part is important.


489
00:23:04,266 --> 00:23:07,836
So let's say we have a process
that wants to share some memory.


490
00:23:07,836 --> 00:23:10,916
And let's say that this
memory-- you got it from malloc.


491
00:23:11,706 --> 00:23:15,426
Malloc might have taken this
little chunk of memory denoted


492
00:23:15,496 --> 00:23:19,346
by the green in that address
range and put it on a page


493
00:23:19,536 --> 00:23:21,366
and then it gives out
that pointer to you.


494
00:23:22,016 --> 00:23:24,806
Now, let's say that you
take that pointer and put it


495
00:23:24,806 --> 00:23:28,316
in an IPC message to share
it to the other side.


496
00:23:28,716 --> 00:23:32,456
The VM isn't going to just
share that green region there.


497
00:23:32,626 --> 00:23:35,716
The VM is going to share
everything on that page.


498
00:23:35,716 --> 00:23:37,806
And what this means is
that if you do this,


499
00:23:37,806 --> 00:23:41,816
it will end up leaking random
heap data to the other side.


500
00:23:42,086 --> 00:23:47,166
And since XPC-- one of
XPC's primary advantages is


501
00:23:47,516 --> 00:23:50,306
implementing a more secure
architecture, this would kind


502
00:23:50,986 --> 00:23:55,286
of defeat the purpose of that
since arbitrary code executing


503
00:23:55,286 --> 00:23:58,226
in the other process would
have access to your heap data


504
00:23:58,226 --> 00:23:59,636
or at least a part of it.


505
00:23:59,696 --> 00:24:01,076
And there might be
a password in there.


506
00:24:01,076 --> 00:24:03,346
There could be any
number of little gems


507
00:24:03,346 --> 00:24:07,536
for a security attacker
to take advantage of.


508
00:24:08,206 --> 00:24:12,486
So, now that we've covered how
you would safely share a piece


509
00:24:12,486 --> 00:24:18,426
of data, let's dive into the
nuts and bolts of how you do it


510
00:24:18,426 --> 00:24:19,786
or how you this with XPC.


511
00:24:20,226 --> 00:24:21,256
The first step you're going


512
00:24:21,256 --> 00:24:23,346
to do is create a
dispatch data object.


513
00:24:23,846 --> 00:24:28,486
And there's a new destructor to
dispatch data that you specify


514
00:24:28,486 --> 00:24:30,046
which is the MUNMAP Destructor.


515
00:24:30,396 --> 00:24:33,606
And, this tells dispatch
that, "Hey, this was allocated


516
00:24:33,606 --> 00:24:36,406
with either MMAP or
MockVM Allocate."


517
00:24:36,926 --> 00:24:40,856
So, you can use this-- you can
use the appropriate destructor


518
00:24:40,856 --> 00:24:41,406
to free it.


519
00:24:41,826 --> 00:24:44,196
And, once you have that
dispatch data object,


520
00:24:44,326 --> 00:24:46,196
you wrap it in an XPC data.


521
00:24:46,406 --> 00:24:48,986
And since we're dealing
with objects in this case,


522
00:24:49,226 --> 00:24:52,396
we're not copying
that buffer locally.


523
00:24:52,396 --> 00:24:54,676
So, you're transferring
ownership of that large buffer


524
00:24:54,706 --> 00:24:57,156
into the dispatch
and XPC subsystems.


525
00:24:58,456 --> 00:25:00,856
So here's how you do it in code.


526
00:25:00,856 --> 00:25:02,816
So we create that
dispatch data object


527
00:25:02,816 --> 00:25:04,806
with the MUNMAP Destructor.


528
00:25:05,166 --> 00:25:09,906
And we give it a buffer
that points to a large chunk


529
00:25:09,906 --> 00:25:14,236
of memory that we've allocated
using MMAP or MockVM Allocate,


530
00:25:14,236 --> 00:25:15,166
the two are equivalent.


531
00:25:15,766 --> 00:25:16,916
And we just tell it the size.


532
00:25:17,476 --> 00:25:20,296
And the target queue for
the destructor to run on.


533
00:25:20,296 --> 00:25:21,526
In this case, it
doesn't really matter.


534
00:25:21,826 --> 00:25:25,026
So we just use Dispatch
Target Queue Default.


535
00:25:25,316 --> 00:25:26,656
Once we have that data object,


536
00:25:26,656 --> 00:25:29,716
we give it to XPC Data
Create with Dispatch Data.


537
00:25:29,766 --> 00:25:32,676
And then we just send
the XPC data object


538
00:25:32,676 --> 00:25:36,096
in the message we've
completely avoided any copies


539
00:25:36,096 --> 00:25:38,356
of that really large
memory region,


540
00:25:38,596 --> 00:25:40,416
so it's been transferred
much more efficiently.


541
00:25:45,316 --> 00:25:50,216
So this isn't just available
to the low level C APIs.


542
00:25:50,216 --> 00:25:54,816
Also doable from the NSXPC
data-- NSXPC connection layer.


543
00:25:55,286 --> 00:25:58,716
And this is now because
in Mavericks,


544
00:25:58,986 --> 00:26:01,916
dispatch data is toll
free bridge with NSData.


545
00:26:02,206 --> 00:26:05,776
So you can create a dispatch
data object and just cast it


546
00:26:05,776 --> 00:26:08,996
to NSData safely to insert it


547
00:26:08,996 --> 00:26:10,786
into whatever Cocoa
object graph you want.


548
00:26:11,126 --> 00:26:13,046
There are some constraints
around this behavior


549
00:26:13,336 --> 00:26:15,346
and that subclasses
are not going


550
00:26:15,346 --> 00:26:16,776
to be toll free bridged here.


551
00:26:16,776 --> 00:26:18,366
So if you subclassed NSData,


552
00:26:18,366 --> 00:26:21,066
that's not safely
interchangeable with dispatch.


553
00:26:21,506 --> 00:26:23,666
And you can't have
created this data objects


554
00:26:23,766 --> 00:26:25,296
with No Copy method.


555
00:26:25,866 --> 00:26:27,636
And when you did
create this object,


556
00:26:27,756 --> 00:26:31,036
any of those following
deallocators will work.


557
00:26:31,036 --> 00:26:35,266
They just basically say it's a
piece of-- it's a VM allocation.


558
00:26:39,016 --> 00:26:43,496
So also new-ish in our
last big cat release,


559
00:26:43,766 --> 00:26:45,926
we implemented a
message receive path


560
00:26:45,926 --> 00:26:48,066
and since we didn't
have a talk last year,


561
00:26:48,066 --> 00:26:49,546
we'll talk about it now.


562
00:26:49,546 --> 00:26:51,296
Basically, this is
now a much faster.


563
00:26:51,296 --> 00:26:54,336
When XPC receives a message,
it doesn't actually have


564
00:26:54,336 --> 00:26:56,666
to create an entire
objects graph


565
00:26:56,666 --> 00:26:57,906
out of that message upfront.


566
00:26:58,276 --> 00:27:00,196
So the act of receiving
a message


567
00:27:00,246 --> 00:27:03,376
in prior releases would end
up creating this big storm


568
00:27:03,376 --> 00:27:06,376
of allocations and copies while
we unserialized everything.


569
00:27:06,566 --> 00:27:08,586
Now, we just deal with
the message directly


570
00:27:08,586 --> 00:27:09,706
in a serialized form.


571
00:27:10,026 --> 00:27:12,606
And this let's you drain
messages really quickly,


572
00:27:13,626 --> 00:27:16,626
you know, and just start
processing stuff asynchronously


573
00:27:16,626 --> 00:27:18,846
as fast as you can.


574
00:27:19,806 --> 00:27:22,166
So there are certain kinds
of messages that we do this--


575
00:27:22,166 --> 00:27:23,456
that we don't do this for.


576
00:27:23,576 --> 00:27:26,516
Mainly, those messages
are things


577
00:27:26,516 --> 00:27:28,036
that contain out-of-line types.


578
00:27:28,446 --> 00:27:30,276
So if you have like
a file descriptor


579
00:27:30,276 --> 00:27:32,796
or a shared memory region
inside of the message,


580
00:27:33,126 --> 00:27:34,696
then we'll unpack
it all upfront.


581
00:27:34,976 --> 00:27:37,326
This isn't too bad
because the assumption is


582
00:27:37,326 --> 00:27:39,526
that if you're sending one of
these objects in a message,


583
00:27:39,766 --> 00:27:43,996
it's probably to avoid
larger data transfers anyway.


584
00:27:43,996 --> 00:27:46,586
So, the cost of unpacking,
it is pretty trivial.


585
00:27:46,586 --> 00:27:48,346
And you're not going to
send a whole ton of them.


586
00:27:48,346 --> 00:27:50,946
So, they won't be too
damaging to your throughput.


587
00:27:53,066 --> 00:27:55,546
You can also take-- there's also
things you can do that will wind


588
00:27:55,546 --> 00:27:57,636
up forcing the slow path.


589
00:27:57,636 --> 00:28:00,136
So, for example, if you
get one of these messages


590
00:28:00,246 --> 00:28:03,476
and then you start-- and then
you say you want to copy it,


591
00:28:03,786 --> 00:28:06,556
we have to actually unpack
the entire thing in order


592
00:28:06,556 --> 00:28:08,516
to create a copy of it.


593
00:28:08,516 --> 00:28:12,426
Similarly, if you use the
XPC Dictionary Apply Routine,


594
00:28:12,666 --> 00:28:16,046
we have to unpack
an XPC object T


595
00:28:16,306 --> 00:28:19,396
for every key value
pair in that dictionary.


596
00:28:19,686 --> 00:28:26,516
So, that will wind up forcing
a full unpack of everything.


597
00:28:26,516 --> 00:28:29,756
And same thing there,
XPC Dictionary Get Value,


598
00:28:29,756 --> 00:28:33,956
it returns an XPC object that
you can retain independently.


599
00:28:33,956 --> 00:28:37,406
So that will actually unpack
the entire value associated


600
00:28:37,406 --> 00:28:38,136
with that key.


601
00:28:38,486 --> 00:28:39,326
And so, what that means is


602
00:28:39,326 --> 00:28:41,876
that if you have a
nested container inside


603
00:28:41,876 --> 00:28:43,756
of that message object,


604
00:28:44,106 --> 00:28:47,166
then we'll unpack the
entirety of that container.


605
00:28:47,736 --> 00:28:51,706
And then finally, if you modify
the dictionary, which is safe,


606
00:28:51,706 --> 00:28:54,166
you're totally allowed to do
that, but if you modify it,


607
00:28:54,166 --> 00:28:56,836
we have to unpack everything
to get it into a form


608
00:28:57,076 --> 00:28:58,256
where it's safely mutable.


609
00:29:01,356 --> 00:29:02,756
So that's we have
new in the runtime.


610
00:29:02,756 --> 00:29:08,016
I wanted to also cover
the issue of timeouts


611
00:29:08,016 --> 00:29:12,756
because there's a
lot of disagreement


612
00:29:12,756 --> 00:29:15,896
over the best policy here
with local machine IPC.


613
00:29:15,986 --> 00:29:20,496
You might have noticed that the
XPC APIs don't actually have any


614
00:29:20,496 --> 00:29:23,456
support for timeouts, and
this is very intentional.


615
00:29:24,456 --> 00:29:29,136
They're just really not needed
in most cases of the API usage


616
00:29:30,056 --> 00:29:32,686
because local machine--


617
00:29:32,686 --> 00:29:34,746
so two processes talking
on the same machine


618
00:29:34,746 --> 00:29:36,076
and two processes talking


619
00:29:36,076 --> 00:29:38,806
on two different machines
are actually different.


620
00:29:38,916 --> 00:29:42,226
So as software engineers
and as computer scientists,


621
00:29:42,836 --> 00:29:45,726
we all like to try and
consolidate two problem spaces.


622
00:29:46,066 --> 00:29:47,886
This is one area
where they're separate


623
00:29:47,886 --> 00:29:49,036
and they really should be.


624
00:29:49,036 --> 00:29:52,706
And the key differentiator here
is that the kernel is not flaky.


625
00:29:52,956 --> 00:29:54,086
It's not like the network.


626
00:29:54,086 --> 00:29:56,246
It doesn't just kind
of like come and go.


627
00:29:56,726 --> 00:29:58,056
It's your transport medium


628
00:29:58,056 --> 00:30:01,396
and it can actually make a
guarantee for message delivery.


629
00:30:02,046 --> 00:30:05,276
So once you have this guarantee,
there's really no reason


630
00:30:05,606 --> 00:30:09,216
that the remote server process
shouldn't always be responsive.


631
00:30:09,536 --> 00:30:10,546
So here's an example.


632
00:30:11,596 --> 00:30:16,386
Well, here's an example of
kind of the bad side of, say,


633
00:30:16,386 --> 00:30:19,466
using a timeout in one of
the send and reply routines.


634
00:30:19,806 --> 00:30:23,806
It will confuse the
expectations of the client side.


635
00:30:24,126 --> 00:30:28,136
So, for example, if the server
end is doing a network operation


636
00:30:28,136 --> 00:30:33,196
on your behalf, you might want
to attach a timeout to the reply


637
00:30:33,536 --> 00:30:36,006
on the client side so that
the client says, "Well,


638
00:30:36,006 --> 00:30:38,686
if I don't get a reply-- it
is a networking operation,


639
00:30:38,686 --> 00:30:41,466
so if I don't get a
reply within 10 seconds,


640
00:30:41,516 --> 00:30:42,906
then that's a timeout."


641
00:30:43,296 --> 00:30:47,626
But what that does is it
confuses the network operation


642
00:30:47,626 --> 00:30:50,386
timing out and the server
process having a bug.


643
00:30:50,736 --> 00:30:54,736
So, it might be that the network
operation would've succeeded


644
00:30:54,936 --> 00:30:57,566
but there's a deadlock in your
server or there are some sort--


645
00:30:57,566 --> 00:31:00,016
or there's kind of
mismanagement of resources


646
00:31:00,016 --> 00:31:02,606
that prevented the server from
sending the reply in time.


647
00:31:02,996 --> 00:31:05,126
But those two conditions
are going to be expressed


648
00:31:05,126 --> 00:31:08,496
to the client identically and
you as a developer might end


649
00:31:08,496 --> 00:31:11,416
up shipping the app with a bug


650
00:31:11,416 --> 00:31:12,806
that you didn't actually
know existed.


651
00:31:15,316 --> 00:31:18,766
So, how would we
optimally handle this case?


652
00:31:18,766 --> 00:31:21,536
Well, it's not that the network
operations shouldn't have


653
00:31:21,536 --> 00:31:22,186
the timeout.


654
00:31:22,286 --> 00:31:25,216
That's just kind of a reality
of network programming.


655
00:31:25,666 --> 00:31:28,546
But you don't want the client
side to manage that timeout.


656
00:31:28,546 --> 00:31:29,776
You want it to be managed


657
00:31:30,026 --> 00:31:32,506
on the thing that's actually
doing the network operation.


658
00:31:32,836 --> 00:31:36,516
So the server sets up
whatever socket it needs to do


659
00:31:36,516 --> 00:31:38,886
that operation, attaches
the timeout


660
00:31:38,886 --> 00:31:41,736
that it thinks is appropriate
and then if that's--


661
00:31:41,736 --> 00:31:45,406
if the server sees that the
request has taken too long,


662
00:31:45,656 --> 00:31:47,326
then that means it can return--


663
00:31:47,326 --> 00:31:49,866
it will return a message
to the client that just has


664
00:31:49,866 --> 00:31:51,836
like an E-timed out
error in there.


665
00:31:52,156 --> 00:31:54,756
And so, the client
knows that, you know,


666
00:31:54,756 --> 00:31:56,476
the server should
always be responsive


667
00:31:56,806 --> 00:31:59,446
and if it didn't respond to me
then that means I have a bug


668
00:31:59,446 --> 00:32:00,436
and I should investigate.


669
00:32:00,896 --> 00:32:06,046
That being said, there
are cases where IPC--


670
00:32:06,216 --> 00:32:09,596
local machine IPC timeouts
are actually appropriate,


671
00:32:09,906 --> 00:32:12,646
but they're not really
terribly common.


672
00:32:12,796 --> 00:32:16,276
Usually, those cases derive
from, say, hard deadlines.


673
00:32:16,576 --> 00:32:19,446
And this is also when transit
time makes a difference.


674
00:32:19,446 --> 00:32:22,786
So the time it takes to send
the message to the other side


675
00:32:22,786 --> 00:32:24,606
and for the other side
to send the reply back,


676
00:32:25,246 --> 00:32:27,616
if that actually
matters in your use case,


677
00:32:27,616 --> 00:32:29,706
you might have a legitimate need


678
00:32:29,706 --> 00:32:31,536
for a timeout on
the client side.


679
00:32:31,986 --> 00:32:35,656
And usually, this will be some
sort of realtime application


680
00:32:35,896 --> 00:32:38,476
where your timeout isn't
just completely arbitrary.


681
00:32:38,476 --> 00:32:40,296
It's not, you know, 10 seconds


682
00:32:40,296 --> 00:32:42,076
or my favorite number
or whatever.


683
00:32:42,326 --> 00:32:45,366
It's actually derived from
a desired throughput rate.


684
00:32:45,616 --> 00:32:48,306
So if you're measuring
things like frames per second


685
00:32:48,626 --> 00:32:54,186
or samples of audio process per
second, then timeouts are needed


686
00:32:54,366 --> 00:32:56,676
so that you can know that
an operation won't complete.


687
00:32:56,756 --> 00:32:59,646
And if it can't complete
in that amount of time


688
00:32:59,746 --> 00:33:02,406
that you've given it,
there's really no need


689
00:33:02,566 --> 00:33:04,696
to keep waiting for it.


690
00:33:04,696 --> 00:33:05,786
You can just move on.


691
00:33:06,146 --> 00:33:10,456
But like I said, these are
not exactly common use cases.


692
00:33:10,766 --> 00:33:14,756
So we don't really have
support in the API for timeouts.


693
00:33:15,096 --> 00:33:18,436
You can also-- but using
the asynchronous APIs,


694
00:33:18,496 --> 00:33:19,676
you can implement your own.


695
00:33:19,726 --> 00:33:24,766
And I'm sure a lot of you
have figured that out.


696
00:33:24,766 --> 00:33:28,116
So, let's also talk a
little bit about debugging


697
00:33:28,116 --> 00:33:33,096
and what we've got in
Mavericks for debugger support.


698
00:33:34,236 --> 00:33:39,706
The first big one is that Xcode
now transparently supports


699
00:33:39,756 --> 00:33:41,376
debugging XPC services.


700
00:33:41,846 --> 00:33:45,466
So, you can just take a
service, set a breakpoint


701
00:33:45,466 --> 00:33:47,546
on the file that's associate--


702
00:33:47,606 --> 00:33:49,916
in a source file that
your service uses,


703
00:33:50,036 --> 00:33:51,356
and then you can run your app.


704
00:33:51,356 --> 00:33:54,216
And then if your app takes
a code path where it talks


705
00:33:54,216 --> 00:33:56,406
to the service and
launches it on-demand,


706
00:33:56,876 --> 00:33:59,956
then those breakpoints that
you set will be honored.


707
00:33:59,956 --> 00:34:03,056
You don't actually have
to do any other work.


708
00:34:04,606 --> 00:34:04,976
[applause] Yeah.


709
00:34:05,386 --> 00:34:10,516
So, it's important to note
that this functionality relies


710
00:34:10,996 --> 00:34:13,896
on enhancements to
the host that we made.


711
00:34:14,196 --> 00:34:19,096
So, it's only available
on Mavericks or later.


712
00:34:19,446 --> 00:34:20,426
So, yeah, it just works.


713
00:34:20,755 --> 00:34:23,746
And also nice, there's a
copy files destination now


714
00:34:23,746 --> 00:34:27,005
for the XPC services
subdirectory in your app.


715
00:34:27,005 --> 00:34:29,076
So, you don't have to
select wrapper directory


716
00:34:29,076 --> 00:34:31,096
and then specify XPC
services anymore.


717
00:34:31,826 --> 00:34:37,446
We also have a tool for
debugging, importance boosting,


718
00:34:37,446 --> 00:34:38,686
and leaking of boosts.


719
00:34:38,686 --> 00:34:41,755
So if you're running into leak
boost, there's this iptrace tool


720
00:34:41,755 --> 00:34:46,005
that will tell you why you were
boosted and who boosted you.


721
00:34:47,996 --> 00:34:51,866
So in terms of debugging,
just debugging tips, a lot--


722
00:34:51,946 --> 00:34:57,126
what a lot of people run into
is they will set everything up


723
00:34:57,126 --> 00:34:58,686
and they'll run their
app the first time.


724
00:34:58,686 --> 00:35:01,776
And then, immediately, when they
try and talk to their service,


725
00:35:01,776 --> 00:35:03,736
they get a connection
invalid right away.


726
00:35:03,736 --> 00:35:05,776
That almost always indicates


727
00:35:05,856 --> 00:35:08,226
that there's been a
configuration error.


728
00:35:08,226 --> 00:35:10,536
You know, the service
isn't in the right place


729
00:35:10,536 --> 00:35:12,636
or the bundle isn't
structured properly.


730
00:35:12,986 --> 00:35:16,746
But when you see this, just a
couple of things to make sure,


731
00:35:16,746 --> 00:35:19,876
make sure that the service is
a dependency of the app target.


732
00:35:19,876 --> 00:35:22,596
So when the app gets
run, the service should--


733
00:35:22,596 --> 00:35:24,326
sorry, when the app gets built,


734
00:35:24,616 --> 00:35:26,636
the service should also
get built before it.


735
00:35:26,636 --> 00:35:29,666
And then that service
product should be


736
00:35:29,666 --> 00:35:32,646
in the copy files build phase
of your app so that it winds


737
00:35:32,646 --> 00:35:37,386
up in Contents XPC
services inside the app.


738
00:35:37,386 --> 00:35:39,676
And then the other
easy mistake to make is


739
00:35:39,676 --> 00:35:42,856
that you might just be using
the wrong service identifier.


740
00:35:43,116 --> 00:35:45,966
So the one-- the name of the
service that you want to connect


741
00:35:45,966 --> 00:35:50,326
to is the CFBundleIdentifier
for that service bundle.


742
00:35:50,376 --> 00:35:53,016
And sometimes that's
easy to confuse


743
00:35:53,016 --> 00:35:57,036
because when you view
the info plist in Xcode,


744
00:35:57,036 --> 00:36:00,136
it will actually be-- it
will have dollar, you know,


745
00:36:00,176 --> 00:36:03,246
product identifier that gets
filled in at build time.


746
00:36:03,396 --> 00:36:06,066
So, you want to make
sure that you're using--


747
00:36:06,066 --> 00:36:08,236
you're identifying your
service consistently.


748
00:36:11,066 --> 00:36:13,466
XPC is also defensive.


749
00:36:13,706 --> 00:36:14,956
It's really easily offended.


750
00:36:15,316 --> 00:36:17,046
And this is also intentional.


751
00:36:17,406 --> 00:36:23,346
So, we do our best to detect
noticeable cases of API misuse


752
00:36:23,416 --> 00:36:27,216
and then we abort the
process with that back trace


753
00:36:27,316 --> 00:36:31,426
so that you can fix the bug
before actually deploying


754
00:36:31,426 --> 00:36:31,796
your app.


755
00:36:32,416 --> 00:36:37,016
And so, we'll do this when,
you know, we detect conditions


756
00:36:37,016 --> 00:36:39,406
that will almost certainly
lead to data corruption


757
00:36:39,406 --> 00:36:41,646
or where data corruption
has clearly happened.


758
00:36:42,376 --> 00:36:44,686
Things like underflowing
the retain count,


759
00:36:44,776 --> 00:36:48,566
if you're still using manual
retain/release on XPC objects


760
00:36:48,706 --> 00:36:52,426
and just other examples
of obvious API misuse.


761
00:36:52,806 --> 00:36:57,226
A lot of this is detailed
in the XPC Abort Man Page


762
00:36:57,226 --> 00:36:58,446
which is in section three.


763
00:36:58,846 --> 00:37:01,036
And you'll-- the
tell-tale sign for this is


764
00:37:01,036 --> 00:37:04,356
that you'll see an illegal
instruction being issued


765
00:37:04,356 --> 00:37:06,576
and you're process
will terminate.


766
00:37:11,206 --> 00:37:15,676
So, in the case where you
got crash report that--


767
00:37:16,276 --> 00:37:18,156
where this has happened,
you'll see stuff


768
00:37:18,156 --> 00:37:21,416
in the applications specific
information telling you why


769
00:37:21,416 --> 00:37:23,216
this-- why the process
was aborted.


770
00:37:24,516 --> 00:37:28,306
But you might be attached to the
service or the app with LLDB.


771
00:37:28,706 --> 00:37:30,756
In which case, you're not
going to get a crash report.


772
00:37:30,756 --> 00:37:31,116
You're not going


773
00:37:31,116 --> 00:37:33,066
to get applications
specific information.


774
00:37:33,176 --> 00:37:39,116
But we provide a debugger
specific API called xpc debugger


775
00:37:39,116 --> 00:37:42,456
api misuse info that you can
call from within the debugger


776
00:37:42,456 --> 00:37:45,216
and that will-- the result
of that will be a pointer


777
00:37:45,216 --> 00:37:48,406
to the string that
we would've printed


778
00:37:48,406 --> 00:37:51,726
in the application specific
information of the crash report.


779
00:37:52,496 --> 00:37:54,646
So here's what it would
look like in a crash report.


780
00:37:54,746 --> 00:37:57,436
You just have the application,
specific information


781
00:37:57,436 --> 00:38:00,396
and it says API MISUSE:
Over-release of an object.


782
00:38:00,466 --> 00:38:04,086
So in this case, we called
XPC release more times


783
00:38:04,086 --> 00:38:05,596
that we have references
to the object.


784
00:38:07,306 --> 00:38:10,386
In LLDB, you'll probably
see something


785
00:38:10,386 --> 00:38:13,266
like Program received
EXC BAD INSTRUCTION


786
00:38:13,266 --> 00:38:16,586
which is the Mock exception in
this case but it maps to SIGILL.


787
00:38:17,086 --> 00:38:21,376
And then from the LLDB
command line, we just do a p


788
00:38:21,656 --> 00:38:25,836
and then call that debugger
API that I mentioned before


789
00:38:25,836 --> 00:38:29,016
and then it will print the
string that's associated


790
00:38:29,116 --> 00:38:31,406
that that API would've returned.


791
00:38:34,776 --> 00:38:38,306
And if you're hounding
your syslog looking


792
00:38:38,306 --> 00:38:40,146
for every little thing that's
happening on the system,


793
00:38:40,426 --> 00:38:42,046
you might have seen a
message that looks like this.


794
00:38:42,046 --> 00:38:44,996
This is what it looks
like in Mavericks.


795
00:38:45,596 --> 00:38:47,956
In previous releases, the part


796
00:38:48,096 --> 00:38:50,846
where it says assertion
failed says bug.


797
00:38:52,916 --> 00:38:58,516
This is cryptic and--
to file a bug


798
00:38:58,636 --> 00:39:01,806
because we now how
to make sense of it.


799
00:39:02,136 --> 00:39:05,196
If you're curious, it's just
the program counter offset


800
00:39:05,536 --> 00:39:09,626
from the beginning of the
libxpc image in the process


801
00:39:10,066 --> 00:39:13,676
where we encountered some weird
error that we didn't expect


802
00:39:13,676 --> 00:39:16,566
and that last part is the
error code that we encountered.


803
00:39:16,946 --> 00:39:18,896
Like I said, we know
how to make sense of it.


804
00:39:18,896 --> 00:39:22,486
If you see of these, file
a bug with that log line


805
00:39:22,486 --> 00:39:24,366
and any other relevant
contextual information


806
00:39:24,366 --> 00:39:27,126
that you have and we'll look
into it and hopefully fix it.


807
00:39:27,206 --> 00:39:32,046
So, that's pretty much
of what we've got.


808
00:39:32,046 --> 00:39:34,956
So for more information on
any of these technologies,


809
00:39:34,986 --> 00:39:38,686
Paul Danbold is the Core
OS Technology Evangelist.


810
00:39:38,686 --> 00:39:41,976
The documentation for
XPC, we have a full suite


811
00:39:41,976 --> 00:39:43,716
of man pages in section three.


812
00:39:44,166 --> 00:39:47,176
I'm sure there are some
great man page viewer apps


813
00:39:47,176 --> 00:39:49,386
on the store if you don't like
viewing them in the terminal.


814
00:39:49,566 --> 00:39:50,666
But I encourage you to read them


815
00:39:50,666 --> 00:39:53,186
because they're very
well put together.


816
00:39:53,546 --> 00:39:54,736
And we also have a full set


817
00:39:54,736 --> 00:39:58,436
of HeaderDoc inside the
actual headers of XPC.


818
00:39:58,436 --> 00:40:01,936
So, look in User
Include XPC and then all


819
00:40:01,936 --> 00:40:05,186
of those public interfaces
are documented with HeaderDoc.


820
00:40:05,926 --> 00:40:08,546
And then the Daemons and
Services Programming Guide


821
00:40:08,546 --> 00:40:13,296
which is on the developer
documentation website covers


822
00:40:13,466 --> 00:40:16,596
when you would want to use a
launch daemon and the lifecycle


823
00:40:16,596 --> 00:40:18,766
of XPC services and
all that fun stuff.


824
00:40:18,946 --> 00:40:22,866
And if none of these resources
can answer your specific


825
00:40:22,866 --> 00:40:26,306
question or you still have
questions about things


826
00:40:26,306 --> 00:40:28,756
that aren't covered there,
there's always the Dev Forums


827
00:40:28,756 --> 00:40:29,906
where you can just ask us


828
00:40:29,906 --> 00:40:33,566
and we occasionally check
the Dev Forums as engineers


829
00:40:33,566 --> 00:40:37,276
and if we can answer
you, we will.


830
00:40:38,136 --> 00:40:43,516
Relatedly, the debugging
support for XPC and Xcode


831
00:40:43,516 --> 00:40:46,856
that I mentioned is going to
be demoed in the Debugging


832
00:40:46,856 --> 00:40:51,136
with Xcode session and that's
in Pac Heights tomorrow at 2:00.


833
00:40:51,136 --> 00:40:54,436
There's also a session later
today which also cover some


834
00:40:54,436 --> 00:40:56,486
of the architectural
things that we talked


835
00:40:56,486 --> 00:40:59,646
about like XPC activities,
centralized tasks scheduling,


836
00:41:00,006 --> 00:41:02,446
and making more efficient apps.


837
00:41:02,686 --> 00:41:04,546
And that's Building
Efficient OS X Apps.


838
00:41:04,546 --> 00:41:06,036
That's in Nob Hill later today.


839
00:41:06,036 --> 00:41:07,126
And that's it.


840
00:41:07,126 --> 00:41:08,486
Enjoy the rest of
the conference.


841
00:41:09,516 --> 00:41:15,730
[ Silence ]

