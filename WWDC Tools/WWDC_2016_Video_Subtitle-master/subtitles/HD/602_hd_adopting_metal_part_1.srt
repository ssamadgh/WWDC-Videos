1
00:00:07,516 --> 00:00:18,516
[ Music ]


2
00:00:19,516 --> 00:00:25,976
[ Applause ]


3
00:00:26,476 --> 00:00:29,206
>> Good afternoon, and welcome
to Adopting Metal, Part I.


4
00:00:29,796 --> 00:00:33,116
I'm Warren Moore from the GPU
Software Team, and I'm joined


5
00:00:33,116 --> 00:00:34,376
by my colleague, Matt Collins,


6
00:00:34,376 --> 00:00:35,826
who will be driving
the demos today.


7
00:00:36,276 --> 00:00:39,236
I want to start off by
asking a deceptively,


8
00:00:39,236 --> 00:00:41,546
simple question: what is Metal?


9
00:00:42,336 --> 00:00:45,286
You've heard us say that Metal
is Apple's low overhead API


10
00:00:45,286 --> 00:00:48,886
for GPUs, that it has a unified
graphics compute language,


11
00:00:49,336 --> 00:00:51,366
and that it's built for
efficient multithreading,


12
00:00:52,096 --> 00:00:53,736
and is designed for
our platforms.


13
00:00:54,006 --> 00:00:54,926
And all of this is true,


14
00:00:54,926 --> 00:00:58,496
but Metal is a lot more
than Metal.framework.


15
00:00:59,276 --> 00:01:04,936
Metal is supported by additional
frameworks and tools and so on.


16
00:01:04,936 --> 00:01:08,406
And they make it a lot more than
just the metal framework API.


17
00:01:09,376 --> 00:01:11,936
In particular, last year
we introduced MetalKit,


18
00:01:12,456 --> 00:01:14,986
which includes utilities
for doing common tasks


19
00:01:14,986 --> 00:01:18,536
like interacting UIKit, and
AppKit, and loading textures,


20
00:01:18,536 --> 00:01:22,436
as well as Metal Performance
Shaders, which allow you


21
00:01:22,436 --> 00:01:25,326
to do common tasks such
as imaging processing,


22
00:01:25,356 --> 00:01:28,776
and contain hand-tuned,
highly optimized Shaders


23
00:01:29,236 --> 00:01:32,366
that you can drop right into
your app to do these tasks.


24
00:01:33,366 --> 00:01:36,236
Metal is also tightly integrated
with our developer tools,


25
00:01:36,236 --> 00:01:37,756
Xcode and Instruments.


26
00:01:39,976 --> 00:01:41,906
When you have Shaders
in your app,


27
00:01:42,446 --> 00:01:44,466
they're actually compiled
right along with your app,


28
00:01:44,586 --> 00:01:48,236
including your app bundle to do
Metal's integration with Xcode.


29
00:01:49,546 --> 00:01:52,356
And the GPU Frame Debugger,
allows you to take a snapshot


30
00:01:52,356 --> 00:01:55,916
of your app at any given point,
and see exactly what's going on.


31
00:01:56,816 --> 00:02:00,096
Metal System Trace in
Instruments allows you


32
00:02:00,096 --> 00:02:02,006
to get an ongoing view
of the performance


33
00:02:02,006 --> 00:02:04,746
and behavior of your Metal apps.


34
00:02:05,446 --> 00:02:08,776
So two years ago, we introduced
Metal on iOS, and since then,


35
00:02:08,776 --> 00:02:13,936
we've brought Metal
to Mac OS and tvOS.


36
00:02:13,936 --> 00:02:16,426
So it really has broad
support across our platforms.


37
00:02:17,086 --> 00:02:19,556
And it's also widely
supported by our hardware.


38
00:02:20,056 --> 00:02:24,096
It's supported on our desktop
and mobile architectures


39
00:02:24,096 --> 00:02:27,106
from Apple, AMD,
Intel, and NVIDIA,


40
00:02:27,546 --> 00:02:31,306
and this includes all Apple
Macs introduced since 2012,


41
00:02:31,306 --> 00:02:34,666
and all iOS devices since 2013,
as well as the new Apple TV.


42
00:02:35,166 --> 00:02:37,506
So Metal gives your applications
access to the performance


43
00:02:37,506 --> 00:02:40,386
and power of the GPU in
literally hundreds of millions


44
00:02:40,466 --> 00:02:44,966
of our most popular products.


45
00:02:45,046 --> 00:02:47,716
And Metal is also a foundational
technology on these platforms.


46
00:02:48,316 --> 00:02:53,146
It powers Core Graphics, Core
Animation, as well as our Games


47
00:02:53,146 --> 00:02:55,006
and Graphics Libraries
such as SpriteKit,


48
00:02:55,006 --> 00:02:56,706
SceneKit, and Model I/O.


49
00:02:57,316 --> 00:02:58,676
And it's also an
important component


50
00:02:59,086 --> 00:03:02,426
in key system applications
like Preview and Safari.


51
00:03:03,086 --> 00:03:06,666
And Metal has been widely
adopted by developers


52
00:03:06,666 --> 00:03:10,596
of all sizes, from AAA
Studios, game engine providers,


53
00:03:11,016 --> 00:03:13,796
independent developers, and
creators of professional tools,


54
00:03:13,936 --> 00:03:16,176
and they've built
amazing games and apps


55
00:03:16,176 --> 00:03:17,386
across all of our platforms.


56
00:03:18,526 --> 00:03:19,766
These are just a few examples,


57
00:03:19,946 --> 00:03:21,026
but I'd like to highlight
a couple.


58
00:03:22,406 --> 00:03:24,656
For instance, Fancy
Guo used Metal


59
00:03:24,656 --> 00:03:26,076
to dramatically improve
performance


60
00:03:26,306 --> 00:03:27,796
and bring amazing visual effects


61
00:03:27,796 --> 00:03:31,516
to their highly popular
MORPG, Furious Wings.


62
00:03:32,606 --> 00:03:34,336
And Metal has also been used


63
00:03:34,336 --> 00:03:36,836
to build inspiring professional
content creation tools,


64
00:03:36,876 --> 00:03:39,356
like the upcoming version
of Affinity Photos for iPad.


65
00:03:39,356 --> 00:03:44,676
And I'd like to show you just a
quick preview of what's coming.


66
00:03:45,256 --> 00:03:48,566
This is Affinity Photos
built by Serif Labs.


67
00:03:48,776 --> 00:03:51,256
And they're building a fully
featured, photo editing app


68
00:03:51,256 --> 00:03:52,856
for the iPad Pro, allowing them


69
00:03:52,856 --> 00:03:54,506
to achieve truly
stunning results.


70
00:03:58,046 --> 00:04:00,956
And this year at WWDC, we
want to give you the tools


71
00:04:00,956 --> 00:04:02,796
to help you start using Metal


72
00:04:02,796 --> 00:04:05,826
to build amazing experiences
in your apps as well.


73
00:04:06,916 --> 00:04:10,556
We have a lot of phenomenal
content this year at WWDC,


74
00:04:10,876 --> 00:04:12,616
five sessions dedicated
to Metal.


75
00:04:13,256 --> 00:04:16,386
Of course, this is the first
session, Adopting Metal, Part I.


76
00:04:17,125 --> 00:04:19,315
And during this session,
we'll talk a little bit


77
00:04:19,315 --> 00:04:23,326
about some foundational
concepts in Metal, go on to talk


78
00:04:23,326 --> 00:04:26,656
about doing 2D drawing and
then actually add lighting,


79
00:04:26,656 --> 00:04:29,896
texturing, and animation
as well as we move into 3D.


80
00:04:30,366 --> 00:04:33,266
In Part II of this session,
happening in this room


81
00:04:33,266 --> 00:04:36,256
after this session, we'll talk
about dynamic data management


82
00:04:36,256 --> 00:04:38,196
and go on and talk about
some of the finer points


83
00:04:38,666 --> 00:04:40,426
of synchronizing
the GPU and CPU,


84
00:04:40,706 --> 00:04:42,686
and really taking your
performance to the next level


85
00:04:43,246 --> 00:04:44,426
with multi-threaded encoding.


86
00:04:46,926 --> 00:04:49,526
Of course, we're also going to
talk about what's new in Metal.


87
00:04:49,956 --> 00:04:53,076
And there's really a
tremendous list of new features


88
00:04:53,076 --> 00:04:55,366
that you probably saw teased
during the Platform State


89
00:04:55,366 --> 00:04:56,066
of Union yesterday.


90
00:04:57,846 --> 00:04:59,346
I won't go through all
of these in detail,


91
00:04:59,346 --> 00:05:01,126
but if you're interested in
implementing any of these


92
00:05:01,126 --> 00:05:02,646
in your apps, you
should definitely check


93
00:05:02,646 --> 00:05:03,736
out the What's New sessions.


94
00:05:05,566 --> 00:05:07,116
And finally, we have
an awesome talk


95
00:05:07,116 --> 00:05:08,716
on advanced Shader optimization.


96
00:05:09,246 --> 00:05:12,366
And this is really a hardcore
talk for the people who want


97
00:05:12,366 --> 00:05:14,836
to get the absolute most
out of their Metal Shaders.


98
00:05:14,836 --> 00:05:17,336
We'll talk specifically
about how the hardware works


99
00:05:17,336 --> 00:05:20,596
and how you can use Metal to
really drive it to the max,


100
00:05:21,186 --> 00:05:22,606
and tune your Shader code.


101
00:05:23,456 --> 00:05:25,426
Throughout the course
of these sessions,


102
00:05:25,426 --> 00:05:26,836
we'll build a sample project,


103
00:05:26,886 --> 00:05:30,106
starting with just a simple
Hello Triangle, and Hello world


104
00:05:30,166 --> 00:05:31,496
of graphics programming.


105
00:05:32,356 --> 00:05:35,406
And then as I mentioned, we'll
move to animation and texturing.


106
00:05:35,776 --> 00:05:39,286
And in Part II, we'll take
it to the next level and talk


107
00:05:39,286 --> 00:05:42,456
about updating object data
in real time and also,


108
00:05:42,756 --> 00:05:44,576
performing draw calls
across multiple threads.


109
00:05:46,026 --> 00:05:47,226
Now of course, we have
to make some assumptions


110
00:05:47,226 --> 00:05:48,056
about who you are.


111
00:05:48,476 --> 00:05:50,846
We assume that you're
familiar with the fundamentals


112
00:05:50,846 --> 00:05:55,746
of graphics programming, ideally
with a programmable pipeline.


113
00:05:56,016 --> 00:05:58,186
So you're familiar
with Shaders and so on.


114
00:05:58,446 --> 00:06:00,106
And also of course
that you're interested


115
00:06:00,106 --> 00:06:01,946
in actually using Metal
to make your games


116
00:06:01,946 --> 00:06:03,726
and apps even more awesome
than they already are.


117
00:06:04,366 --> 00:06:07,076
I assume that everybody here
is on the same page with that.


118
00:06:07,076 --> 00:06:08,246
That's why you're here, right?


119
00:06:08,746 --> 00:06:11,236
So just to go through
the agenda.


120
00:06:12,126 --> 00:06:13,906
We'll kick things off
with a conceptual overview


121
00:06:13,906 --> 00:06:16,536
that will sort of introduce
the philosophy of Metal


122
00:06:16,536 --> 00:06:17,926
and why Metal is
shaped the way it is.


123
00:06:18,516 --> 00:06:20,216
Then we'll actually get right
down to the nitty gritty


124
00:06:20,216 --> 00:06:21,716
and talk about creating
a Metal device.


125
00:06:22,496 --> 00:06:24,226
We'll go on to talk
about loading data


126
00:06:24,736 --> 00:06:26,386
into memory that's
accessible by the GPU.


127
00:06:26,386 --> 00:06:28,716
And we'll talk about the Metal
shading language briefly.


128
00:06:28,716 --> 00:06:31,986
We'll talk about creating
pre-validated pipeline states.


129
00:06:32,856 --> 00:06:36,156
And then talk about issuing GPU
commands, including draw calls.


130
00:06:36,156 --> 00:06:39,706
And then we'll finish up
with a discussion of how


131
00:06:39,706 --> 00:06:42,976
to perform animation
and texturing in Metal.


132
00:06:43,746 --> 00:06:45,226
Part II will take
things even further,


133
00:06:45,746 --> 00:06:47,186
and I've already mentioned
what we'll discuss there.


134
00:06:47,656 --> 00:06:48,546
So let's just forward ahead.


135
00:06:49,086 --> 00:06:51,006
Starting off with the
conceptual overview.


136
00:06:51,476 --> 00:06:53,506
There are a few things that
I want to emphasize here.


137
00:06:54,856 --> 00:06:57,456
Use and API that matches
the hardware and driver.


138
00:06:58,746 --> 00:07:00,326
Favor explicit over implicit.


139
00:07:01,136 --> 00:07:03,796
And do expensive
work less often.


140
00:07:04,256 --> 00:07:07,146
Let's start with using an API
that matches the hardware.


141
00:07:08,216 --> 00:07:09,936
Metal is a thoroughly
modern API.


142
00:07:10,576 --> 00:07:12,246
And by that, I mean
that it integrates with


143
00:07:12,246 --> 00:07:13,976
and exposes the latest
hardware features,


144
00:07:15,326 --> 00:07:18,336
and it matches very closely to
how the hardware actually works.


145
00:07:18,886 --> 00:07:22,466
And being a comparatively
new API, it's very thin


146
00:07:22,566 --> 00:07:25,736
and has no historical cruft that
you get with other legacy APIs.


147
00:07:25,736 --> 00:07:28,316
So there are no fancy
tricks required


148
00:07:28,316 --> 00:07:29,626
for low overhead operation.


149
00:07:29,946 --> 00:07:33,176
It's baked in to how Metal
is shaped and how it operates


150
00:07:33,176 --> 00:07:34,316
at the most fundamental level.


151
00:07:34,316 --> 00:07:37,186
And fortunately,
it's unique by design


152
00:07:37,706 --> 00:07:39,236
across all -- across
our platforms.


153
00:07:40,586 --> 00:07:42,986
When we say that we
want to favor explicit


154
00:07:42,986 --> 00:07:46,066
over implicit operation, we
mean that we put in your hands,


155
00:07:46,066 --> 00:07:49,946
the responsibility to
perform some explicit control


156
00:07:49,946 --> 00:07:51,806
over how commands are
submitted to the GPU,


157
00:07:52,126 --> 00:07:53,996
as well as how you manage
and synchronize your data.


158
00:07:53,996 --> 00:07:57,276
And this puts on you, a
lot of responsibility,


159
00:07:57,786 --> 00:08:00,466
but with great responsibility
comes great performance.


160
00:08:02,066 --> 00:08:04,356
So, just to illustrate
what we mean when we say


161
00:08:04,356 --> 00:08:08,876
"to do expensive work less
often," there are kind


162
00:08:08,876 --> 00:08:12,626
of three regimes of time
that we can think about.


163
00:08:12,876 --> 00:08:14,026
The time that your app is built,


164
00:08:14,116 --> 00:08:17,396
the time that your app is
loading, loading assets


165
00:08:17,396 --> 00:08:19,696
and so on, and then draw time,


166
00:08:19,696 --> 00:08:21,856
the things that happen
60 times per second.


167
00:08:23,346 --> 00:08:27,376
So with a legacy API, like
OpenGL, you pay the cost of work


168
00:08:27,376 --> 00:08:30,396
like state validation every
time you issue a draw call.


169
00:08:30,396 --> 00:08:31,866
You take the hit for
recompiling Shaders


170
00:08:31,866 --> 00:08:33,236
on the fly in the worst case.


171
00:08:33,836 --> 00:08:36,676
And all this adds overhead
on top of the necessary work


172
00:08:37,626 --> 00:08:41,936
of encoding the actual work for
the GPU, like your draw calls.


173
00:08:42,006 --> 00:08:44,285
With Metal, we push some of this
work earlier in the process.


174
00:08:45,056 --> 00:08:46,696
So, as I alluded to earlier,


175
00:08:47,236 --> 00:08:48,966
Shader compilation
can actually happen


176
00:08:48,966 --> 00:08:50,936
at application build
time with Metal.


177
00:08:52,126 --> 00:08:54,776
And additionally, we allow
you to validate the state


178
00:08:54,776 --> 00:08:57,286
that you're going to be using
for your draw calls in advance


179
00:08:57,956 --> 00:08:59,616
at load time, so you don't pay


180
00:08:59,616 --> 00:09:01,196
that cost every time
you issue a draw call.


181
00:09:01,776 --> 00:09:04,616
Instead, the only work
that remains to be done


182
00:09:04,616 --> 00:09:07,016
when you're issuing your draw
calls, is to do your draw calls.


183
00:09:10,076 --> 00:09:11,486
So with that conceptual
overview,


184
00:09:11,686 --> 00:09:13,116
let's talk about where
the rubber hits the road,


185
00:09:13,116 --> 00:09:14,896
and that's, the Metal device.


186
00:09:15,896 --> 00:09:17,776
So there's a Class MTL device,


187
00:09:17,776 --> 00:09:21,076
and it's an abstract
representation of your GPU.


188
00:09:21,626 --> 00:09:24,866
And it functions as the root
object in your Metal app,


189
00:09:25,386 --> 00:09:27,486
meaning that you'll
use it to create things


190
00:09:27,486 --> 00:09:30,906
like command queues, resources,
pipeline state objects,


191
00:09:31,076 --> 00:09:32,756
and other objects
that you'll be using.


192
00:09:34,156 --> 00:09:37,646
It's very easy to
create a Metal device.


193
00:09:38,026 --> 00:09:40,836
You'll just call
MTLCreateSystemDefaultDevice.


194
00:09:41,846 --> 00:09:44,246
Now devices are persistent
objects, so you'll probably want


195
00:09:44,246 --> 00:09:46,306
to create one at the
beginning of your application


196
00:09:46,306 --> 00:09:47,746
and then hold onto reference


197
00:09:47,746 --> 00:09:49,696
to it throughout your
application life cycle.


198
00:09:50,336 --> 00:09:52,196
It's just that easy.


199
00:09:54,066 --> 00:09:55,976
So now let's talk a little
bit about how to get data


200
00:09:56,516 --> 00:09:58,266
into a place where
the GPU can access it,


201
00:09:58,486 --> 00:09:59,846
so that you can issue
your draw calls.


202
00:10:01,096 --> 00:10:04,046
And in Metal, we'll store
our data in buffers.


203
00:10:04,476 --> 00:10:08,066
So buffers are just allocations
of memory that can store data


204
00:10:08,066 --> 00:10:08,976
in any format that you choose.


205
00:10:09,106 --> 00:10:15,256
These might be vertex data,
index data, constant data.


206
00:10:15,566 --> 00:10:17,166
And you write data
into these buffers


207
00:10:17,166 --> 00:10:19,846
and then access them
later on in your vertex


208
00:10:19,846 --> 00:10:20,606
and fragmentFunctions.


209
00:10:21,226 --> 00:10:23,606
Let's take a look at what
that might look like.


210
00:10:24,126 --> 00:10:26,116
So here is an example
of a couple of buffers


211
00:10:26,116 --> 00:10:28,696
that you might create, as
you're loading your data.


212
00:10:28,916 --> 00:10:31,556
We have a vertexBuffer,
containing some vertices.


213
00:10:31,666 --> 00:10:34,216
And an indexBuffer, containing
some contiguous indices.


214
00:10:34,826 --> 00:10:38,466
To get a little bit more
concrete, each instance


215
00:10:38,466 --> 00:10:42,056
of this vertex type
might be a Swift struct


216
00:10:42,496 --> 00:10:44,916
that contains a position
vector for the vertex,


217
00:10:44,916 --> 00:10:47,236
as well as a color
for the vertex.


218
00:10:47,886 --> 00:10:49,626
You can just lay them out
contiguously in memory.


219
00:10:49,626 --> 00:10:53,126
Now let's talk about how
you actually create buffers.


220
00:10:53,706 --> 00:10:57,496
So the API for this
is on the device


221
00:10:57,496 --> 00:10:58,296
that you've already created.


222
00:10:58,776 --> 00:11:00,786
And you simply call
newBufferWithLength


223
00:11:01,086 --> 00:11:02,746
to get a buffer of
a particular size


224
00:11:03,096 --> 00:11:04,996
that doesn't have any
data loaded into it.


225
00:11:05,536 --> 00:11:07,736
Or you can call
newBufferWithBytes


226
00:11:07,906 --> 00:11:10,226
and pass a pointer to data
that already lives in memory.


227
00:11:10,636 --> 00:11:12,346
And Metal will then
copy that data


228
00:11:12,706 --> 00:11:14,296
into the newly created
Metal buffer,


229
00:11:14,526 --> 00:11:15,836
and it will be ready
for your use.


230
00:11:17,366 --> 00:11:19,746
You can also memcpy into
the contents pointer


231
00:11:19,746 --> 00:11:20,766
of the buffer if you choose.


232
00:11:21,346 --> 00:11:26,576
So, since we're going to
be showing a 2D triangle


233
00:11:26,726 --> 00:11:27,986
as the first part of our demo,


234
00:11:28,146 --> 00:11:32,996
let's talk about defining the
geometry for this triangle here.


235
00:11:33,216 --> 00:11:35,236
So, since we want to
keep the vertex shader


236
00:11:35,236 --> 00:11:37,156
and fragment shader
as simple as possible,


237
00:11:37,876 --> 00:11:40,896
we'll actually provide these
coordinates in Clip Space.


238
00:11:41,816 --> 00:11:44,796
And Metal's Clip
Space is interesting.


239
00:11:44,856 --> 00:11:47,596
It differs from some APIs and
it's similar to some APIs.


240
00:11:47,596 --> 00:11:49,346
This is like the
DirectX Clip Space.


241
00:11:49,886 --> 00:11:53,086
It runs from negative 1
to 1 in X, negative 1 to 1


242
00:11:53,086 --> 00:11:55,876
in Y, and zero to 1 in Z.


243
00:11:56,166 --> 00:11:58,046
So this is the coordinate space


244
00:11:58,046 --> 00:11:59,406
that we'll specify
our vertices in.


245
00:12:00,066 --> 00:12:02,496
So in code, it looks like this.


246
00:12:02,876 --> 00:12:04,996
We create a Swift
array of vertices,


247
00:12:05,406 --> 00:12:07,306
and then we just
append vertices each


248
00:12:07,346 --> 00:12:09,206
with a position and a color.


249
00:12:12,556 --> 00:12:15,316
Now, we don't strictly
need to use index drawing


250
00:12:15,506 --> 00:12:19,256
to do the simple of a used
case, but we'll go ahead


251
00:12:19,256 --> 00:12:22,596
and create an indexBuffer and
append the indices 0, 1, and 2,


252
00:12:23,016 --> 00:12:25,246
which correspond to of
course, the first, second,


253
00:12:25,246 --> 00:12:26,526
and third vertices
of our triangle.


254
00:12:26,616 --> 00:12:29,006
And then we'll create a couple
of buffers with our device.


255
00:12:29,656 --> 00:12:32,076
So we'll create the vertexBuffer
by calling newBuffer(withBytes,


256
00:12:32,076 --> 00:12:34,776
which loads our vertex data
into this Metal buffer,


257
00:12:34,776 --> 00:12:36,856
and we'll call a
newBuffer(withBytes again


258
00:12:36,926 --> 00:12:40,356
and pass the index data and
get back the indexBuffer.


259
00:12:40,986 --> 00:12:44,396
So, now that we have
our data and memory,


260
00:12:44,646 --> 00:12:47,146
let's talk a little bit about
Metal's unique shading language.


261
00:12:47,816 --> 00:12:51,956
The Metal shading language is
an extended subset of C++ 14,


262
00:12:52,456 --> 00:12:54,896
and it's a unified language
for graphics and compute,


263
00:12:55,406 --> 00:12:56,906
meaning that you can
do a whole lot more


264
00:12:56,906 --> 00:12:58,236
than just 3D graphics with it.


265
00:12:58,236 --> 00:13:01,046
It really just lets you
write programs for the GPU.


266
00:13:01,726 --> 00:13:05,786
So here's a block diagram of
the stages of the pipeline.


267
00:13:05,786 --> 00:13:08,756
And what we're really talking
about now is the vertex


268
00:13:08,756 --> 00:13:10,186
and fragment processing stages.


269
00:13:10,696 --> 00:13:13,396
Each of these has an associated
function that you'll write,


270
00:13:13,756 --> 00:13:16,986
that's used to either process
the vertices or the fragments


271
00:13:16,986 --> 00:13:18,046
that will wind up on screen.


272
00:13:19,266 --> 00:13:21,236
Syntax-wise, it looks
a little bit like this.


273
00:13:21,416 --> 00:13:25,656
And we're not actually going to
go through this in any detail.


274
00:13:25,836 --> 00:13:26,876
I just want to call
your attention


275
00:13:26,876 --> 00:13:30,246
to these function qualifiers:
vertex and fragment.


276
00:13:30,676 --> 00:13:32,946
You'll notice that right out
in front of these functions,


277
00:13:33,346 --> 00:13:35,856
unlike in say a regular
C++ program,


278
00:13:36,306 --> 00:13:38,416
we actually have these
qualifiers that denote


279
00:13:38,666 --> 00:13:40,906
which stage this function
is associated with.


280
00:13:40,906 --> 00:13:42,726
So we have a vertex
function up top,


281
00:13:42,806 --> 00:13:44,576
and a fragmentFunction
down below.


282
00:13:45,016 --> 00:13:48,456
And I'll show you shortly how
to actually associate these


283
00:13:49,556 --> 00:13:51,856
with your pipeline so that
you can use them to draw.


284
00:13:52,276 --> 00:13:55,046
And we'll also look at the
internals of these functions


285
00:13:55,386 --> 00:13:58,096
for our 2D demo and
later on for our 3D demo.


286
00:13:59,016 --> 00:14:01,166
Now, I've mentioned a couple
of times that Metal allows you


287
00:14:01,166 --> 00:14:03,446
to compile your Shaders
directly into your app bundle.


288
00:14:03,526 --> 00:14:05,306
And the way that happens is,


289
00:14:05,306 --> 00:14:07,986
if you have even a
single .Metal file


290
00:14:07,986 --> 00:14:11,006
in your Compile Sources
Phase of your project,


291
00:14:11,596 --> 00:14:14,296
the Metal will automatically
generate what's called a Metal


292
00:14:14,296 --> 00:14:16,376
Lib file, the default.Metallib
file,


293
00:14:16,786 --> 00:14:17,966
and copy it into your bundle


294
00:14:18,156 --> 00:14:19,686
at the time your
application is built


295
00:14:20,026 --> 00:14:21,356
with no further effort
on your part.


296
00:14:21,356 --> 00:14:24,336
So there's the insides
of your app bundle.


297
00:14:25,896 --> 00:14:27,016
There's your default.Metallib.


298
00:14:27,566 --> 00:14:29,336
So just to recap.


299
00:14:29,426 --> 00:14:32,946
You can build Metal
Shaders at runtime.


300
00:14:33,656 --> 00:14:36,386
Again, if you have a .Metal file
in your app, it will be compiled


301
00:14:36,386 --> 00:14:37,876
by Xcode using the
Metal toolchain.


302
00:14:38,236 --> 00:14:40,236
And then produce
default.Metallib which will wind


303
00:14:40,236 --> 00:14:40,826
up in your app bundle.


304
00:14:42,256 --> 00:14:44,316
And the natural question you
have at this point is, "Well,


305
00:14:44,316 --> 00:14:48,006
how do you actually get
these functions at runtime?"


306
00:14:48,006 --> 00:14:49,896
And the answer is that
you'll use a class called


307
00:14:49,896 --> 00:14:50,776
Metal Library.


308
00:14:51,196 --> 00:14:52,546
So Metal Library is a collection


309
00:14:52,546 --> 00:14:54,576
of these compiled
function objects,


310
00:14:54,576 --> 00:14:55,596
produced by the compiler.


311
00:14:56,066 --> 00:14:57,656
And there are multiple
ways to create it.


312
00:14:57,656 --> 00:14:59,396
You can go through the flow
that we just discussed,


313
00:14:59,896 --> 00:15:02,556
which is to build
a default.Metallib


314
00:15:02,556 --> 00:15:04,636
into your app bundle, and
then load it at runtime.


315
00:15:04,946 --> 00:15:06,316
You can also build .metallibs


316
00:15:06,316 --> 00:15:09,576
with a command line
toolchain that we provide.


317
00:15:10,486 --> 00:15:13,406
And you can also build directly
from a source string at runtime


318
00:15:13,506 --> 00:15:15,176
if you're for example,
building Shaders


319
00:15:15,176 --> 00:15:16,386
through string concatenation.


320
00:15:17,876 --> 00:15:19,416
So in code, it looks like this.


321
00:15:19,416 --> 00:15:22,096
In order to load up
the default.Metallib,


322
00:15:22,096 --> 00:15:24,506
you simply call
newDefaultLibrary


323
00:15:25,056 --> 00:15:26,306
on your existing Metal device.


324
00:15:27,456 --> 00:15:30,326
And there's other API for
loading from, for example,


325
00:15:30,496 --> 00:15:32,866
an offline compiled
.Metallib, or from source.


326
00:15:32,866 --> 00:15:37,586
And you can consult
the API docs for that.


327
00:15:37,796 --> 00:15:40,106
So, you have a Metal Library.


328
00:15:40,316 --> 00:15:41,456
What do you get from
Metal Library?


329
00:15:41,556 --> 00:15:42,596
You get a Metal function.


330
00:15:42,596 --> 00:15:44,696
Now a Metal function
is simply an object


331
00:15:44,696 --> 00:15:46,366
that represents a
single function.


332
00:15:46,986 --> 00:15:49,316
And it's associated with a
particular pipeline stage.


333
00:15:49,316 --> 00:15:50,826
Remember that we saw
the diagram earlier,


334
00:15:51,046 --> 00:15:52,526
the vertex or fragment stage.


335
00:15:52,866 --> 00:15:55,146
And we also have an additional
function qualifier called


336
00:15:55,276 --> 00:16:01,836
kernel, that signifies a data
parallel of compute function.


337
00:16:02,006 --> 00:16:04,476
So here's that code snippet
again, and you can see


338
00:16:04,476 --> 00:16:07,766
that the function named
here is vertex transform,


339
00:16:08,116 --> 00:16:11,116
and the fragmentFunction
name is fragment lighting.


340
00:16:11,866 --> 00:16:14,546
And I rehash this so that
I can show you the API


341
00:16:14,546 --> 00:16:16,376
for loading these
functions from your library,


342
00:16:16,886 --> 00:16:17,656
which looks like this.


343
00:16:18,126 --> 00:16:19,566
We simply call
NewFunctionWithName


344
00:16:19,966 --> 00:16:22,246
and pass a string that
represents the name


345
00:16:22,356 --> 00:16:25,756
of your function, and get
back a Metal function object,


346
00:16:25,756 --> 00:16:26,516
and then hold onto it.


347
00:16:27,746 --> 00:16:28,476
Now, I'll show you how


348
00:16:28,476 --> 00:16:30,356
to actually use all these
objects in a moment.


349
00:16:30,526 --> 00:16:32,206
But that was just a
brief introduction


350
00:16:32,206 --> 00:16:33,226
to the Metal Shading language.


351
00:16:35,106 --> 00:16:38,236
So let's talk about building
pre-validated pipeline states.


352
00:16:40,766 --> 00:16:42,486
But first, let's
motivate it a little.


353
00:16:43,076 --> 00:16:45,436
So, with an API like OpenGL,


354
00:16:45,836 --> 00:16:47,996
you're often setting
a lot of state.


355
00:16:48,526 --> 00:16:50,096
And then you issue draw calls.


356
00:16:50,096 --> 00:16:53,346
And in between those, the
driver is obligated to validate


357
00:16:53,346 --> 00:16:57,136
that the safety you've set, is
in fact a valid state and again,


358
00:16:57,136 --> 00:16:59,046
in the worst case, you
can even pay the cost


359
00:16:59,356 --> 00:17:01,266
of recompiling Shaders
at runtime.


360
00:17:01,926 --> 00:17:03,316
This is what we want to avoid.


361
00:17:04,715 --> 00:17:07,566
So with Metal, it
looks more like this.


362
00:17:08,356 --> 00:17:10,276
You set a pre-validated
pipeline state object,


363
00:17:10,386 --> 00:17:12,756
and maybe set a few other
bits of ancillary state,


364
00:17:12,756 --> 00:17:14,266
and then issue your draw call.


365
00:17:14,266 --> 00:17:17,146
Now what we're trying to do
here is to reduce the overhead


366
00:17:17,146 --> 00:17:19,556
of draw calls by again,
pushing more work earlier


367
00:17:19,556 --> 00:17:20,386
into the process.


368
00:17:21,506 --> 00:17:24,246
So here are a few examples of
state that you'll want to set


369
00:17:24,246 --> 00:17:25,536
on your pipeline state object,


370
00:17:25,705 --> 00:17:26,856
which we'll talk
about in a moment.


371
00:17:27,306 --> 00:17:29,266
First, let's state that you
can set pretty much anytime


372
00:17:29,266 --> 00:17:29,966
when you're drawing.


373
00:17:30,736 --> 00:17:32,166
You'll notice that in
the left hand column,


374
00:17:32,166 --> 00:17:34,046
the state that you'll set
on the pipeline state,


375
00:17:34,046 --> 00:17:35,756
includes the vertex
and fragmentFunction


376
00:17:35,756 --> 00:17:36,866
that will be used to draw.


377
00:17:36,956 --> 00:17:39,726
And it also includes things
like your alpha blending state.


378
00:17:42,266 --> 00:17:44,416
On the right hand side,
instead we see the state


379
00:17:44,416 --> 00:17:46,766
that you can set before
issuing any given draw call,


380
00:17:46,766 --> 00:17:49,866
including the front face
winding and the call mode.


381
00:17:51,056 --> 00:17:53,256
So let's talk about how
you actually create objects


382
00:17:53,256 --> 00:17:55,546
that contain this
pre-validated state.


383
00:17:56,096 --> 00:17:58,866
The chief object is the
Metal RenderPipelineState.


384
00:17:59,886 --> 00:18:01,856
It represents the
sort of configuration


385
00:18:01,896 --> 00:18:04,306
of the GPU pipeline, and
it contains a set of --


386
00:18:04,306 --> 00:18:06,836
of validated state that you'll
create during load time.


387
00:18:08,166 --> 00:18:09,236
Like devices,


388
00:18:09,606 --> 00:18:12,126
RenderPipelineStates
are persistent objects


389
00:18:12,126 --> 00:18:14,326
that you'll want to keep
alive throughout the lifetime


390
00:18:14,326 --> 00:18:17,716
of your application,
though if you have a lot


391
00:18:17,716 --> 00:18:20,116
of different functions, you can
create pipeline state objects


392
00:18:20,116 --> 00:18:21,866
asynchronously while
your app is running.


393
00:18:23,146 --> 00:18:25,176
To actually create a
RenderPipelineState,


394
00:18:25,576 --> 00:18:26,726
we don't create one directly.


395
00:18:26,726 --> 00:18:30,426
Instead, we use an object
called a Descriptor that bundles


396
00:18:30,696 --> 00:18:32,586
up all the parameters
that we're going to use


397
00:18:32,586 --> 00:18:34,016
to create this
RenderPipelineState.


398
00:18:34,596 --> 00:18:37,726
Often in Metal, we'll
create Descriptor objects


399
00:18:37,726 --> 00:18:40,426
that really just bring together
all of the different parameters


400
00:18:40,426 --> 00:18:42,696
that we need to create
yet another object.


401
00:18:42,776 --> 00:18:45,226
And so for the
RenderPipelineState object,


402
00:18:45,226 --> 00:18:46,656
that's called a Render
Pipeline Descriptor.


403
00:18:47,406 --> 00:18:50,396
You'll notice that it contains
pointers to the vertex function


404
00:18:50,396 --> 00:18:52,096
and fragmentFunction,
as I mentioned earlier.


405
00:18:52,376 --> 00:18:55,186
And it also contains a
collection of attachments.


406
00:18:55,666 --> 00:18:59,746
And attachments signify the type
of texture that will be rendered


407
00:18:59,746 --> 00:19:01,346
into when we actually
do our drawing.


408
00:19:01,826 --> 00:19:04,356
Now in Metal, all rendering
is rendered to texture,


409
00:19:04,786 --> 00:19:08,066
but we don't need pointers to
those textures right up front.


410
00:19:08,506 --> 00:19:11,416
Instead we just need you
to supply the pixel formats


411
00:19:11,516 --> 00:19:12,906
that you'll be rendering into so


412
00:19:12,906 --> 00:19:14,766
that we can optimize the
pipeline state for them.


413
00:19:15,696 --> 00:19:18,456
Additionally, if you're using
a Depth or Stencil Buffer,


414
00:19:18,456 --> 00:19:21,366
then you can also specify the
pixel format of those targets.


415
00:19:22,316 --> 00:19:24,816
So once you've constructed a
render pipeline descriptor,


416
00:19:25,316 --> 00:19:27,276
you can pass it off
to your Metal device


417
00:19:27,406 --> 00:19:29,606
and get back a
MTLRenderPipelineState object.


418
00:19:30,006 --> 00:19:31,636
Let's take a look
at that in code.


419
00:19:32,766 --> 00:19:35,106
Here's a minimal configuration
for a RenderPipelineState.


420
00:19:35,536 --> 00:19:37,596
You'll notice that we're
setting our vertex function


421
00:19:37,686 --> 00:19:39,836
and fragmentFunction
properties to the vertex


422
00:19:39,836 --> 00:19:41,066
and fragmentFunction objects


423
00:19:41,066 --> 00:19:42,826
that we created earlier
from our library.


424
00:19:42,826 --> 00:19:46,526
And we're also configuring
the pixel format


425
00:19:46,526 --> 00:19:50,446
of the primary color attachment
to be .bgra8Unorm, which is one


426
00:19:50,446 --> 00:19:53,556
of our renderable and
displayable pixel formats.


427
00:19:55,416 --> 00:19:57,396
This represents basically
the texture that will --


428
00:19:57,396 --> 00:19:59,326
ultimately be drawn to
when we do our drawing.


429
00:19:59,836 --> 00:20:02,006
And finally, once
we've constructed


430
00:20:02,326 --> 00:20:03,286
that pipeline descriptor,


431
00:20:03,876 --> 00:20:06,556
we can use the new
RenderPipelineState function


432
00:20:06,616 --> 00:20:11,936
on the device to actually get
back this pre-validated object.


433
00:20:12,066 --> 00:20:13,096
I want to emphasize once more


434
00:20:13,096 --> 00:20:14,766
that PipelineStates
are persistent objects,


435
00:20:14,766 --> 00:20:17,046
and you should create them
during load time and keep them


436
00:20:17,046 --> 00:20:18,756
around as you do your
device and resources.


437
00:20:19,356 --> 00:20:20,986
You can switch among them
when doing drawing in order


438
00:20:20,986 --> 00:20:22,096
to achieve different effects.


439
00:20:22,916 --> 00:20:25,896
You'll generally have about
one per pair of vertex


440
00:20:25,896 --> 00:20:26,706
and fragmentFunctions.


441
00:20:28,866 --> 00:20:29,826
So now that we've
talked about how


442
00:20:29,826 --> 00:20:32,936
to construct pre-validated
state and how to load some


443
00:20:32,936 --> 00:20:34,156
of your resources into memory,


444
00:20:34,736 --> 00:20:36,876
let's talk about actually
issuing GPU commands,


445
00:20:36,876 --> 00:20:38,466
including draw calls.


446
00:20:39,646 --> 00:20:41,336
We'll go through this
in several stages.


447
00:20:41,416 --> 00:20:43,876
We'll talk about interfacing
with UIKit and AppKit,


448
00:20:44,486 --> 00:20:47,016
talk about -- a bit about the
Metal command submission model,


449
00:20:47,546 --> 00:20:50,086
and then get into render passes
and draw calls, and finally,


450
00:20:50,086 --> 00:20:51,566
how to present your
content on the screen.


451
00:20:52,366 --> 00:20:55,316
So in terms of interacting
with UIKit and AppKit,


452
00:20:55,516 --> 00:20:59,076
we're going to use a utility
for MetalKit called MTKView.


453
00:20:59,736 --> 00:21:02,806
And MTKView is a
cross-platform, view class.


454
00:21:02,806 --> 00:21:05,276
It inherits from
NSView on Mac OS


455
00:21:05,866 --> 00:21:08,076
and from UIView on iOS and tvOS.


456
00:21:09,256 --> 00:21:11,466
And it reduces the amount of
code that you have to write


457
00:21:11,466 --> 00:21:12,846
in order to get up
and running on Metal.


458
00:21:13,566 --> 00:21:16,496
For example, it creates and
manages a CA Metal Layer


459
00:21:16,496 --> 00:21:20,216
for you, which is a specialized
CALayer subclass that interacts


460
00:21:20,216 --> 00:21:23,846
with the Windows server or
with the display loop in order


461
00:21:23,846 --> 00:21:25,016
to get your content on screen.


462
00:21:25,556 --> 00:21:29,246
It can also, by use of
CV or CA display link,


463
00:21:29,586 --> 00:21:31,906
manage the draw callback
cycle for you


464
00:21:32,106 --> 00:21:33,626
by issuing periodic callbacks


465
00:21:34,086 --> 00:21:35,456
in which you'll actually
do your drawing.


466
00:21:35,866 --> 00:21:38,516
And it also manages the textures
that you'll be rendering into.


467
00:21:38,876 --> 00:21:41,826
I want to emphasize
on particular aspect


468
00:21:42,266 --> 00:21:45,436
of what this does for
you, and that's drawables.


469
00:21:46,406 --> 00:21:50,936
So, inside of the CA Metal Layer
that's managed by your MTKView,


470
00:21:51,056 --> 00:21:52,906
there is a collection
of drawables.


471
00:21:53,126 --> 00:21:54,916
And drawables wrap a texture


472
00:21:54,916 --> 00:21:56,796
that will ultimately
be displayed on screen.


473
00:21:56,796 --> 00:21:59,616
And these are kept in an
internal queue, and then reused


474
00:21:59,616 --> 00:22:02,156
across frames because they're
comparatively expensive


475
00:22:02,606 --> 00:22:05,176
and they need to be
managed by the system


476
00:22:05,176 --> 00:22:07,726
because they actually
are very tightly bound


477
00:22:07,726 --> 00:22:09,866
to how things actually get
displayed on the screen.


478
00:22:09,866 --> 00:22:13,186
So we manage them for you and
we hand you the drawable object


479
00:22:13,186 --> 00:22:15,336
that wraps up one of these
textures that you can draw into.


480
00:22:16,226 --> 00:22:18,346
So here's how you can --
there are numerous properties


481
00:22:18,346 --> 00:22:20,356
that you can configure
on an MTKView


482
00:22:20,476 --> 00:22:22,406
to determine how it
manages the textures


483
00:22:22,406 --> 00:22:24,096
that you're going
to be drawing into.


484
00:22:24,096 --> 00:22:26,966
In particular, you can set a
clear color that will determine


485
00:22:26,966 --> 00:22:29,546
which color, the primary
color target is clear to.


486
00:22:29,546 --> 00:22:32,766
You can specify the
color pixel format,


487
00:22:33,216 --> 00:22:36,186
which should match the color
format that you specified


488
00:22:36,186 --> 00:22:37,456
on your pipeline state object,


489
00:22:37,956 --> 00:22:41,216
as well as specifying a depth
and/or stencil pixel format.


490
00:22:41,216 --> 00:22:44,096
And this last property is
probably the most important.


491
00:22:44,096 --> 00:22:45,386
This is where we
set the delegate.


492
00:22:45,826 --> 00:22:49,796
So, MTKView doesn't actually do
any drawing in and of itself.


493
00:22:49,796 --> 00:22:50,796
You can either subclass it,


494
00:22:51,336 --> 00:22:53,596
or you can implement a
delegate that's responsible


495
00:22:53,596 --> 00:22:54,416
for doing the drawing.


496
00:22:54,416 --> 00:22:56,576
And we'll talk through
the later use case.


497
00:22:56,936 --> 00:22:59,586
So let's take a look at
what you have to do in order


498
00:22:59,586 --> 00:23:02,086
to become an MTKView delegate.


499
00:23:03,576 --> 00:23:05,796
It really boils down to
implementing two methods:


500
00:23:06,456 --> 00:23:09,426
drawable sizeable
change, and draw.


501
00:23:10,096 --> 00:23:13,206
So in drawable sizeable
change, you are responsible


502
00:23:13,206 --> 00:23:16,906
for responding to things
like the window resizing


503
00:23:16,906 --> 00:23:18,156
or the device rotating.


504
00:23:18,216 --> 00:23:20,726
So for example, if your
projection matrix is dependent


505
00:23:20,726 --> 00:23:23,676
on the window size, then
this gives you an opportunity


506
00:23:23,676 --> 00:23:26,256
to respond to that instead
of rebuilding it every frame.


507
00:23:27,046 --> 00:23:30,506
So the draw method will
be called periodically,


508
00:23:30,736 --> 00:23:33,436
in order for you to
actually encode the commands


509
00:23:33,436 --> 00:23:35,896
that you want to have executed,
including your draw calls.


510
00:23:36,326 --> 00:23:38,286
And we're not showing
the complete internals


511
00:23:38,286 --> 00:23:42,846
of that method here, but this is
just a taste of what's to come


512
00:23:42,846 --> 00:23:44,146
when we talk about
command submission.


513
00:23:44,656 --> 00:23:47,156
So you'll create a
commandBuffer, do some things


514
00:23:47,156 --> 00:23:48,526
with it, and then commit it.


515
00:23:48,886 --> 00:23:51,976
We'll talk a lot more about that
in a moment, but this is sort


516
00:23:51,976 --> 00:23:55,056
of your hook for doing the
drawing if you're using MTKView.


517
00:23:55,916 --> 00:23:57,396
And we recommend using MTKView,


518
00:23:57,396 --> 00:23:59,136
especially as you're getting
started, because it takes care


519
00:23:59,136 --> 00:24:00,016
of a lot of things for you.


520
00:24:01,226 --> 00:24:03,296
So let's talk about Metal's
command submission model.


521
00:24:04,396 --> 00:24:05,996
This is the picture that
we're going to be building


522
00:24:05,996 --> 00:24:07,396
up over the next several slides.


523
00:24:08,526 --> 00:24:10,056
And it's not important for you


524
00:24:10,056 --> 00:24:11,676
to memorize everything
that's going on here.


525
00:24:12,116 --> 00:24:14,186
We're going to be
building this up.


526
00:24:14,296 --> 00:24:15,646
This is just sort
of an overview.


527
00:24:15,816 --> 00:24:19,346
The objects that we're going to
be constructing as we go along.


528
00:24:20,736 --> 00:24:24,466
So, Metals Command Submission
Model is fairly explicit,


529
00:24:24,826 --> 00:24:27,016
meaning that your
obligated to construct


530
00:24:27,016 --> 00:24:28,966
and submit commandBuffers
yourself.


531
00:24:29,406 --> 00:24:32,246
And you can think of a
commandBuffer as a parcel


532
00:24:32,246 --> 00:24:34,006
of work to be executed
by the GPU,


533
00:24:34,326 --> 00:24:36,796
in contrast to what we're
calling a Metal buffer,


534
00:24:36,946 --> 00:24:37,756
which stores data.


535
00:24:38,196 --> 00:24:40,436
Command buffers store work
to be done by the GPU.


536
00:24:40,436 --> 00:24:43,026
And commandBuffer submission
is under your control,


537
00:24:43,196 --> 00:24:45,026
meaning that when you
have a commandBuffer


538
00:24:45,026 --> 00:24:48,006
that you've constructed, you're
obligated to tell the GPU


539
00:24:48,006 --> 00:24:49,276
when it's ready to be executed.


540
00:24:49,696 --> 00:24:50,916
We'll talk all about
this in a moment.


541
00:24:51,596 --> 00:24:53,646
Additionally, we'll talk
about command encoders


542
00:24:53,646 --> 00:24:56,376
which are objects that are used
to translate from API calls


543
00:24:56,896 --> 00:24:58,166
into work for the GPU.


544
00:24:58,576 --> 00:24:59,426
It's important to realize


545
00:24:59,466 --> 00:25:01,696
that these command encoders
perform no deferred state


546
00:25:01,696 --> 00:25:02,416
of validation.


547
00:25:02,766 --> 00:25:05,376
So all of the pre-validated
state that bundled


548
00:25:05,376 --> 00:25:06,806
up in your pipeline,
state objects,


549
00:25:06,806 --> 00:25:09,206
we assume that that's valid


550
00:25:09,206 --> 00:25:10,876
because we validated
it in advance.


551
00:25:11,266 --> 00:25:13,516
And so there's no additional
work to be done by the encoder


552
00:25:13,516 --> 00:25:14,506
or the driver at the point


553
00:25:14,506 --> 00:25:17,126
that you're issuing
commands to be rendered.


554
00:25:19,736 --> 00:25:22,396
Additionally, Metal's Command
Submission Model is inherently


555
00:25:22,396 --> 00:25:23,616
multi-threaded, which allows you


556
00:25:23,616 --> 00:25:26,336
to construct multiple
Command Buffers in parallel,


557
00:25:26,496 --> 00:25:28,886
and have your app decide
the execution order.


558
00:25:29,296 --> 00:25:32,386
This allows you to scale to,
and beyond, tens of thousands


559
00:25:32,386 --> 00:25:33,526
of draw calls per frame.


560
00:25:34,076 --> 00:25:36,386
Adopting Metal Part II will
talk about this in depth,


561
00:25:36,576 --> 00:25:39,336
but I wanted to mention it
now to hint at what's to come.


562
00:25:39,336 --> 00:25:43,986
So let's talk a little bit more
about these objects in depth.


563
00:25:44,316 --> 00:25:47,106
The first thing we'll talk
about is the Command Queue.


564
00:25:48,086 --> 00:25:50,496
And the Command Queue,
which corresponds


565
00:25:50,496 --> 00:25:53,496
to a Metal class called Metal
Command Queue, manages the work


566
00:25:53,496 --> 00:25:55,546
that has been queued up
for the device to execute.


567
00:25:56,036 --> 00:25:59,376
Like the device and
resources and pipeline states,


568
00:25:59,926 --> 00:26:02,166
queues are persistent objects
that you'll want to create


569
00:26:02,166 --> 00:26:05,596
up front and then keep a handle
on for the lifetime of your app.


570
00:26:05,596 --> 00:26:07,926
You'll often only
need to create one.


571
00:26:08,616 --> 00:26:11,796
And this is how thread safety
is introduced into the Metal API


572
00:26:12,356 --> 00:26:15,986
in the sense that you can create
Command Buffers and render


573
00:26:15,986 --> 00:26:18,456
into -- and use them
on multiple threads.


574
00:26:18,896 --> 00:26:22,336
And the queue allows you
to create and commit them


575
00:26:22,726 --> 00:26:24,486
in a thread safe fashion,
without you having


576
00:26:24,486 --> 00:26:25,766
to do your own locking.


577
00:26:27,466 --> 00:26:29,306
It's really simple to
create a Command Queue.


578
00:26:29,876 --> 00:26:32,166
You simply call a new
Command Queue on your device,


579
00:26:32,586 --> 00:26:33,996
and you'll get back a
Metal Command Queue.


580
00:26:34,636 --> 00:26:39,096
Of course, a queue can't do much
unless you actually put work


581
00:26:39,096 --> 00:26:44,016
into to, so let's
talk about that.


582
00:26:44,216 --> 00:26:45,476
So I've already mentioned
Command Buffers.


583
00:26:45,476 --> 00:26:48,996
And Command Buffers are the
parcels of work to be executed


584
00:26:48,996 --> 00:26:51,686
by the GPU, and in
Metal, they're represented


585
00:26:51,686 --> 00:26:53,486
by a class called
Metal Command Buffer.


586
00:26:53,486 --> 00:26:56,176
So a Metal Command Buffer
contains a set of commands


587
00:26:56,176 --> 00:26:59,976
to be executed by the GPU,
and these are each enqueued


588
00:26:59,976 --> 00:27:02,106
onto a Command Queue for
scheduling by the driver.


589
00:27:02,876 --> 00:27:04,936
These, in contrast to almost
everything we're talked


590
00:27:04,936 --> 00:27:07,056
about thus far, are
transient objects,


591
00:27:07,116 --> 00:27:09,636
meaning that you'll create
one or more of them per frame,


592
00:27:10,336 --> 00:27:12,476
and then encode commands
into them,


593
00:27:12,596 --> 00:27:15,126
and then let them
go off to the GPU.


594
00:27:15,246 --> 00:27:16,066
You won't reuse them.


595
00:27:16,066 --> 00:27:17,616
You won't hold onto
a reference to them.


596
00:27:18,396 --> 00:27:19,296
They're just fire and forget.


597
00:27:20,846 --> 00:27:23,076
To create a Command
Buffer, you simply call


598
00:27:23,076 --> 00:27:24,666
up the Command Buffer
on a Command Queue.


599
00:27:25,326 --> 00:27:31,456
So we've talked a bit
about Buffers, and Queues,


600
00:27:31,456 --> 00:27:33,186
and now let's actually
talk about how we get data


601
00:27:33,726 --> 00:27:36,156
and commands into a
commandBuffer, and that's done


602
00:27:36,156 --> 00:27:38,626
with a special class of
objects called Command Encoders.


603
00:27:39,166 --> 00:27:40,876
And there are several
types of Command Encoders,


604
00:27:41,066 --> 00:27:43,226
including Render,
Blit, and Compute.


605
00:27:43,226 --> 00:27:45,676
And these each allow you
to do different things.


606
00:27:45,826 --> 00:27:49,016
And they all have this common
thread though allowing you


607
00:27:49,166 --> 00:27:51,646
to encode work into
a Command Buffer.


608
00:27:52,016 --> 00:27:55,706
So for example, a Render
Command Encoder will allow you


609
00:27:55,706 --> 00:27:57,636
to set state and
perform draw calls.


610
00:27:58,016 --> 00:28:00,526
A Compute Command Encoder
will allow you to enqueue work


611
00:28:00,906 --> 00:28:04,776
for the GPU to execute in a
data parallel fashion that's not


612
00:28:04,776 --> 00:28:05,306
rendering work.


613
00:28:05,456 --> 00:28:07,956
That's your GP, GPU, and
other stuff like that.


614
00:28:08,776 --> 00:28:11,116
And the Blit Command Encoder
allows you to copy data


615
00:28:11,116 --> 00:28:14,006
between buffers and
textures, and vice versa.


616
00:28:14,006 --> 00:28:17,526
We're going to look in detail


617
00:28:17,526 --> 00:28:19,336
at the Render Command
Encoder in this session.


618
00:28:20,566 --> 00:28:23,326
And as I mentioned, it
has the responsibility


619
00:28:23,326 --> 00:28:24,826
of encoding commands.


620
00:28:24,826 --> 00:28:27,186
And each Render Command
Encoder, encodes the work


621
00:28:27,186 --> 00:28:30,216
of a single pass into
a Command Buffer.


622
00:28:30,686 --> 00:28:32,646
So you'll issue some
state changes


623
00:28:32,646 --> 00:28:37,416
and then you'll issue some
draws and it manages a set


624
00:28:37,466 --> 00:28:40,046
of Render target attachments,
that represent the textures


625
00:28:40,046 --> 00:28:44,216
that are going to be drawn into
by this one particular pass.


626
00:28:44,216 --> 00:28:45,986
So schematically,
what we're talking


627
00:28:45,986 --> 00:28:48,096
about here is sort
of the last stage.


628
00:28:48,096 --> 00:28:50,416
You can see we have
these attachments sort


629
00:28:50,416 --> 00:28:55,176
of hanging off the frame buffer
right stage of the pipeline.


630
00:28:55,886 --> 00:28:59,026
And if we were doing multi pass
rendering, then one or more


631
00:28:59,026 --> 00:29:01,566
of the render targets in
this pass might become inputs


632
00:29:01,566 --> 00:29:02,656
for a subsequent pass.


633
00:29:02,706 --> 00:29:05,836
But this is sort of the
single pass, simple use case.


634
00:29:06,836 --> 00:29:09,876
So the again, the attachments
represent the textures


635
00:29:09,876 --> 00:29:14,076
that we're going to be drawing
into at the end of this pass.


636
00:29:14,676 --> 00:29:17,246
So in terms of actually creating
a render command encoder,


637
00:29:17,306 --> 00:29:19,146
we use another type
of descriptor object,


638
00:29:19,196 --> 00:29:20,556
called a RenderPassDescriptor.


639
00:29:21,096 --> 00:29:23,446
So a RenderPassDescriptor
contains a collection


640
00:29:23,446 --> 00:29:26,586
of attachments, each of which
has an associated load store


641
00:29:26,586 --> 00:29:28,676
action, a clear color,
clear value,


642
00:29:28,676 --> 00:29:31,266
and an associated Metal
Texture to be rendered into.


643
00:29:31,266 --> 00:29:34,536
And we'll talk a little bit more
about load and store actions


644
00:29:34,536 --> 00:29:35,446
in a couple of slides.


645
00:29:35,866 --> 00:29:37,946
But the important
thing to realize here,


646
00:29:38,286 --> 00:29:41,816
is that you'll be constructing
a RenderPassDescriptor


647
00:29:42,236 --> 00:29:45,746
at the beginning of your frame,
and actually associating it


648
00:29:45,746 --> 00:29:47,446
with the textures that
are going to be drawn.


649
00:29:47,816 --> 00:29:51,326
So in contrast to the
renderPipelineState object


650
00:29:51,736 --> 00:29:54,416
that only needs to know the
pixel format, this is sort


651
00:29:54,416 --> 00:29:56,106
of where the rubber hits the
road and you actually have


652
00:29:56,106 --> 00:29:59,376
to give us the textures that
we're going to be drawing into.


653
00:30:00,996 --> 00:30:03,706
So again, a RenderPassDescriptor
contains a collection


654
00:30:03,706 --> 00:30:06,466
of render pass attachments,
each of which might be a color,


655
00:30:06,466 --> 00:30:07,776
depth, or stencil target,


656
00:30:08,196 --> 00:30:10,006
and refers to a texture
to render into.


657
00:30:10,006 --> 00:30:12,576
And it also specifies
these things called load


658
00:30:12,576 --> 00:30:13,396
and store actions.


659
00:30:13,806 --> 00:30:16,166
Let's talk in more depth about
what that actually means.


660
00:30:17,116 --> 00:30:20,196
So, at the beginning of a pass,
you have your color buffer


661
00:30:20,196 --> 00:30:23,586
and your depth buffer and
they contain unknown content.


662
00:30:24,046 --> 00:30:26,606
And in order to actually
do any meaningful work,


663
00:30:26,726 --> 00:30:28,056
we'll need to clear them.


664
00:30:28,056 --> 00:30:30,896
And we do this by setting
their associated load action


665
00:30:31,336 --> 00:30:32,656
on the RenderPassDescriptor.


666
00:30:33,716 --> 00:30:37,636
So we set a load action of clear
on the color and depth targets,


667
00:30:38,166 --> 00:30:40,826
and that clears them to their
corresponding clear color


668
00:30:40,976 --> 00:30:42,636
or clear value, as
the case may be.


669
00:30:43,396 --> 00:30:44,576
Then we'll do some drawing,


670
00:30:44,956 --> 00:30:46,246
which will actually
put the results


671
00:30:46,246 --> 00:30:48,036
of our draw calls
into these textures.


672
00:30:48,676 --> 00:30:50,996
And then the store
action will be performed.


673
00:30:51,266 --> 00:30:53,826
And the store action here is
going to be one of two things.


674
00:30:54,286 --> 00:30:57,496
The store action of
store, signifies the result


675
00:30:57,496 --> 00:30:59,416
of rendering should
actually be written back


676
00:30:59,416 --> 00:31:00,956
to memory and stored.


677
00:31:00,956 --> 00:31:03,336
And in the case of the color
buffer, we're actually going


678
00:31:03,336 --> 00:31:04,666
to present it potentially
on screen.


679
00:31:04,766 --> 00:31:08,046
In the case of the depth buffer,
we're really only using it


680
00:31:08,046 --> 00:31:11,426
when we're actually drawing and
rendering, and so we don't care


681
00:31:11,676 --> 00:31:15,216
about where the results of
that go at the end of the pass.


682
00:31:15,506 --> 00:31:17,866
So we can set a store action
of "Don't Care" in order


683
00:31:17,866 --> 00:31:18,786
to save some bandwidth.


684
00:31:19,266 --> 00:31:21,076
This is an optimization
that you can do


685
00:31:21,076 --> 00:31:23,516
if you don't actually need
to write back the results


686
00:31:23,516 --> 00:31:25,206
of rendering into
the render target.


687
00:31:25,206 --> 00:31:29,636
So to go in a little bit more
depth on load and store actions,


688
00:31:29,636 --> 00:31:31,386
these determine how
texture contents are handled


689
00:31:31,546 --> 00:31:33,736
at the start and
end of your pass.


690
00:31:33,736 --> 00:31:36,666
In addition to the clear
load action that we just saw,


691
00:31:36,666 --> 00:31:39,436
there's also a Load-Load
action that allows you


692
00:31:39,436 --> 00:31:43,126
to load pixel contents
of your textures


693
00:31:43,506 --> 00:31:44,956
with the results
of a previous pass.


694
00:31:45,186 --> 00:31:46,376
There's also "Don't Care."


695
00:31:46,676 --> 00:31:49,896
For example, if you're going to
be rendering across all pixels


696
00:31:49,896 --> 00:31:53,486
of a given target, then you
don't actually care what was


697
00:31:53,486 --> 00:31:56,596
in the texture previously,
nor do you need to clear it


698
00:31:57,096 --> 00:31:58,686
because you know
that you're going


699
00:31:58,686 --> 00:32:00,956
to actually be setting every
single pixel to some value.


700
00:32:01,326 --> 00:32:02,896
So that's another way
that you can optimize,


701
00:32:02,896 --> 00:32:04,526
if you know that in
fact you are going


702
00:32:04,526 --> 00:32:09,966
to be hitting every
single pixel in this pass.


703
00:32:10,176 --> 00:32:11,176
Now, I could walk
you through how


704
00:32:11,176 --> 00:32:13,526
to create a RenderPassDescriptor


705
00:32:13,846 --> 00:32:16,376
and then create a Render Command
Encoder, but fortunately,


706
00:32:16,696 --> 00:32:18,866
MTKView makes this
really easy on you.


707
00:32:19,406 --> 00:32:21,706
You saw earlier that we
configured the MTKView,


708
00:32:22,086 --> 00:32:23,236
with a couple of properties


709
00:32:23,236 --> 00:32:25,456
that by now I hope you become
familiar, like the clear color


710
00:32:25,846 --> 00:32:27,676
and the texture formats
of your render targets.


711
00:32:28,306 --> 00:32:30,326
So you can actually
just ask the view


712
00:32:30,526 --> 00:32:32,216
for its current
RenderPassDescriptor


713
00:32:32,376 --> 00:32:35,126
and you'll get back a
configured RenderPassDescriptor


714
00:32:35,496 --> 00:32:37,086
that you can then go on to use


715
00:32:37,086 --> 00:32:39,956
to create a Render
Command Encoder.


716
00:32:40,526 --> 00:32:42,856
And this is how you do that.


717
00:32:42,856 --> 00:32:45,676
You simply call Render Command
Encoder on your Command Buffer.


718
00:32:46,146 --> 00:32:47,106
Now it's important to note here


719
00:32:47,106 --> 00:32:49,256
that current
RenderPassDescriptor is


720
00:32:49,326 --> 00:32:50,606
potentially a blocking call.


721
00:32:51,176 --> 00:32:53,616
And the reason for that is
that it will actually call


722
00:32:53,616 --> 00:32:57,156
into the CA Metal Layers
next drawable function,


723
00:32:57,606 --> 00:33:00,486
which we won't talk about in
detail now, but which is used


724
00:33:00,486 --> 00:33:02,656
to obtain the drawable
that wraps the texture


725
00:33:02,656 --> 00:33:03,936
that can be presented on screen.


726
00:33:04,446 --> 00:33:06,636
And because that is
a finite resource,


727
00:33:07,176 --> 00:33:09,836
if there is not a drawable
currently available,


728
00:33:09,836 --> 00:33:13,046
if all of them are in flight,
then this call will block.


729
00:33:13,046 --> 00:33:14,986
So it' something to be aware of.


730
00:33:15,636 --> 00:33:18,916
So we've talked about
loading resources into memory,


731
00:33:18,916 --> 00:33:21,116
and we've talked about
creating pre-validated state


732
00:33:21,116 --> 00:33:24,126
and we've talked about
now, created Render Passes


733
00:33:24,366 --> 00:33:25,376
and Render Command Encoders.


734
00:33:25,916 --> 00:33:28,146
So how do we actually get
data into our Shaders?


735
00:33:29,486 --> 00:33:32,226
First, we need to talk a little
bit about argument tables.


736
00:33:33,276 --> 00:33:35,106
So argument tables are mappings


737
00:33:35,106 --> 00:33:38,806
from Metal resources
to Shader parameters.


738
00:33:39,316 --> 00:33:41,836
And each type of resource that
you're going to be working with,


739
00:33:41,836 --> 00:33:43,166
such as a buffer or a texture,


740
00:33:43,486 --> 00:33:45,466
has its own separate
buffer argument table.


741
00:33:45,936 --> 00:33:47,076
So you can see here
on the right,


742
00:33:47,076 --> 00:33:49,476
that we have the
buffer argument table


743
00:33:49,476 --> 00:33:52,716
and the texture argument table,
each of which contain a couple


744
00:33:52,716 --> 00:33:55,706
of buffers that are maps
to particular indices


745
00:33:55,946 --> 00:33:56,836
in the argument table.


746
00:33:57,676 --> 00:33:59,556
Now the number of slots
that are available


747
00:33:59,556 --> 00:34:02,176
in any given argument table
are actually dependent upon


748
00:34:02,176 --> 00:34:02,746
the device.


749
00:34:02,836 --> 00:34:05,446
So you should query for them.


750
00:34:05,566 --> 00:34:07,066
Let's make that a
little bit more concrete.


751
00:34:07,636 --> 00:34:10,335
So, on the Render Command
Encoder there's a function


752
00:34:10,335 --> 00:34:12,766
called Set Over Text
Buffer, and you'll notice


753
00:34:12,766 --> 00:34:14,056
that it has three parameters.


754
00:34:14,376 --> 00:34:17,255
It takes a buffer, and
offset, and an index.


755
00:34:17,556 --> 00:34:19,906
So this last parameter is
what we care about the most


756
00:34:20,045 --> 00:34:23,286
because it's our
argument table index.


757
00:34:23,866 --> 00:34:29,806
So this is sort of the host
side of setting resources


758
00:34:29,806 --> 00:34:31,226
that are going to be
used in your Shader.


759
00:34:31,936 --> 00:34:34,606
And there's a corresponding
Shader side


760
00:34:34,976 --> 00:34:36,025
which looks like this.


761
00:34:36,565 --> 00:34:38,656
So this is in the
middle shading language.


762
00:34:38,886 --> 00:34:41,896
Inside your Shader file,
you'll specify that the --


763
00:34:42,255 --> 00:34:46,525
that each given parameter
that corresponds to a resource


764
00:34:46,525 --> 00:34:50,116
that you want to access, has an
attribute that looks like this.


765
00:34:50,606 --> 00:34:53,016
So, this is the first
buffer index.


766
00:34:53,045 --> 00:34:54,775
Buffer Index Zero in
the Argument Table,


767
00:34:55,295 --> 00:34:58,476
corresponds to the buffer
that we just set back


768
00:34:58,476 --> 00:34:59,536
on our Render Command Encoder.


769
00:35:01,866 --> 00:35:04,616
And we'll look at a little
bit more about this in detail


770
00:35:04,616 --> 00:35:06,536
when we actually talk
about doing drawing in 2D.


771
00:35:10,866 --> 00:35:12,276
We've already created
a renderPipelineState,


772
00:35:12,276 --> 00:35:14,806
but we actually need to tell
our Render Command Encoder


773
00:35:15,026 --> 00:35:17,576
which pipeline state to use
before doing any drawing.


774
00:35:17,926 --> 00:35:19,036
So this is API for that.


775
00:35:19,036 --> 00:35:21,356
We simple call
setRenderPipelineState


776
00:35:21,356 --> 00:35:23,636
with the previously created
PipelineState object,


777
00:35:24,076 --> 00:35:27,266
and that configures the pipeline
with the Shaders that we've --


778
00:35:27,266 --> 00:35:30,016
that we created earlier that
we're going to be using to draw.


779
00:35:30,886 --> 00:35:32,746
Now of course, the
RenderPipelineState,


780
00:35:32,746 --> 00:35:36,186
has associated -- an associated
vertex and fragments function.


781
00:35:36,556 --> 00:35:38,656
So let's take a look at the
vertex and fragmentFunction


782
00:35:38,656 --> 00:35:40,936
that we're actually going
to be using to draw in 2D.


783
00:35:41,816 --> 00:35:44,166
Back in Metal Shading
language, it looks like this.


784
00:35:44,796 --> 00:35:48,556
So, this is basically a
pass through vertex function


785
00:35:48,556 --> 00:35:49,376
which means that we're not going


786
00:35:49,376 --> 00:35:50,876
to be doing any fancy
math in here.


787
00:35:50,876 --> 00:35:53,216
It's really just going to
copy all these attributes,


788
00:35:53,216 --> 00:35:53,966
straight on through.


789
00:35:54,666 --> 00:35:59,876
So, the first parameter to this
function is a list of vertices


790
00:36:00,066 --> 00:36:02,176
which is the buffer
that we just bound.


791
00:36:02,756 --> 00:36:05,346
And the second parameter is
this thing that's attributed


792
00:36:05,346 --> 00:36:08,456
with the vertex ID attribute,
which is something that's going


793
00:36:08,456 --> 00:36:11,696
to be populated by Metal
with the index of the vertex


794
00:36:11,696 --> 00:36:13,086
that we're currently
operating on.


795
00:36:13,476 --> 00:36:14,816
And the reason that's
important is


796
00:36:14,816 --> 00:36:17,736
because the vertexBuffer
contains all the vertices,


797
00:36:17,736 --> 00:36:18,986
and we can access it at random.


798
00:36:18,986 --> 00:36:21,056
But what we actually want to do


799
00:36:21,056 --> 00:36:22,946
in our vertex function
is operate


800
00:36:22,946 --> 00:36:24,726
on one particular
vertex at a time.


801
00:36:25,136 --> 00:36:27,056
So this tells us which
vertex we're operating on.


802
00:36:27,706 --> 00:36:30,686
So, we create an instance
of this struct VertexOut,


803
00:36:30,916 --> 00:36:34,286
which represents all the
varying properties of the vertex


804
00:36:34,896 --> 00:36:36,676
that we want to pass
through to the rasterizer.


805
00:36:37,216 --> 00:36:39,886
So we create an instance of
this and set its position


806
00:36:40,166 --> 00:36:44,366
to the position vector of the
vertex indexed at vertexId.


807
00:36:44,746 --> 00:36:45,976
And similarly for the color.


808
00:36:46,026 --> 00:36:48,906
And this just passes that data
on through from the vertexBuffer


809
00:36:49,336 --> 00:36:52,106
to the struct that will be
interpolated by the rasterizer.


810
00:36:52,716 --> 00:36:56,246
And then we return that
structure back on out.


811
00:36:57,196 --> 00:36:58,756
Now let's look at
the fragmentFunction.


812
00:36:59,406 --> 00:37:00,576
It's even simpler.


813
00:37:01,196 --> 00:37:05,836
So we take in the interpolated
struct, using the stage


814
00:37:05,836 --> 00:37:07,786
in attribute, and that signifies


815
00:37:07,826 --> 00:37:10,346
that this is the data that's
coming in from the rasterizer.


816
00:37:10,346 --> 00:37:12,476
And we just extract
that color --


817
00:37:12,796 --> 00:37:15,696
the color from the
incoming structure,


818
00:37:16,046 --> 00:37:17,296
and then pass it back on out.


819
00:37:17,716 --> 00:37:20,086
And so, what's happened in
this process is the vertices,


820
00:37:20,086 --> 00:37:23,286
which were already specified
in Clip Space in this example,


821
00:37:23,806 --> 00:37:27,576
are being interpolated and
then rasterized and then


822
00:37:27,576 --> 00:37:29,016
for each fragment
that we're processing,


823
00:37:29,466 --> 00:37:31,066
we simple return the
interpolated color


824
00:37:31,066 --> 00:37:32,766
that was created for
us by the rasterizer.


825
00:37:34,796 --> 00:37:37,666
So once we've specified
the RenderPipelineState


826
00:37:37,796 --> 00:37:39,596
which contains our vertex
and fragmentFunction,


827
00:37:39,896 --> 00:37:42,036
we can also set additional
state, kind of like the stuff


828
00:37:42,036 --> 00:37:42,806
that I mentioned earlier,


829
00:37:43,156 --> 00:37:45,846
including the front
facing state.


830
00:37:46,176 --> 00:37:49,266
So if you want to specify a
different front facing winding


831
00:37:49,266 --> 00:37:52,016
order, than Metal's
default of clockwise,


832
00:37:52,326 --> 00:37:53,256
then you can do that here.


833
00:37:53,866 --> 00:37:56,966
It's a lot of configuration,
but we're actually


834
00:37:56,966 --> 00:38:00,166
about to see some draw
calls happen, right now.


835
00:38:00,876 --> 00:38:02,196
So Metal has numerous functions


836
00:38:02,196 --> 00:38:05,166
for drawing geometry including
indexed, instance, and indirect,


837
00:38:05,366 --> 00:38:07,286
but we'll just look at
basic index drawing.


838
00:38:07,786 --> 00:38:10,226
Let's say that we want to draw
that triangle, at long last.


839
00:38:10,896 --> 00:38:13,236
So, here we call
drawIndexedPrimitives,


840
00:38:13,896 --> 00:38:16,656
and we specify that the
prototype is triangle


841
00:38:16,986 --> 00:38:19,076
because we want to
draw a triangle.


842
00:38:19,076 --> 00:38:21,266
We pass an index count of
three to signify that we want


843
00:38:21,266 --> 00:38:22,476
to draw a single triangle,


844
00:38:22,666 --> 00:38:25,186
and then we also specify
the type of indices.


845
00:38:27,086 --> 00:38:31,116
We made our Swift array a
collection of UN 16s earlier,


846
00:38:31,116 --> 00:38:32,506
so we mirror that here.


847
00:38:32,506 --> 00:38:34,246
And we also pass
in the indexBuffer


848
00:38:34,246 --> 00:38:36,046
that we created earlier
that signifies


849
00:38:36,636 --> 00:38:38,046
which vertices should be drawn,


850
00:38:38,386 --> 00:38:40,226
and then we pass in
an offset of zero.


851
00:38:40,706 --> 00:38:42,576
And this is actually
going to result


852
00:38:42,786 --> 00:38:45,056
in a single triangle
being drawn to the screen.


853
00:38:45,636 --> 00:38:48,766
We might also additionally
set some more state


854
00:38:48,766 --> 00:38:50,806
and issue other draw
calls, but for the purposes


855
00:38:50,806 --> 00:38:53,056
of this first demo, this
is all there is to it.


856
00:38:53,746 --> 00:38:55,406
So in order to conclude
a render pass,


857
00:38:55,946 --> 00:38:59,326
we simple call it endEncoding
on the Render Command Encoder.


858
00:39:00,706 --> 00:39:04,136
To recap all of that, you
will create a request,


859
00:39:04,196 --> 00:39:06,696
a RenderPassDescriptor, at
the beginning of your frame.


860
00:39:07,626 --> 00:39:09,896
Then you'll create a
Render Command Encoder


861
00:39:10,066 --> 00:39:10,906
with that Descriptor.


862
00:39:11,886 --> 00:39:13,266
Set the RenderPipelineState.


863
00:39:13,266 --> 00:39:15,576
Set any other necessary state.


864
00:39:15,976 --> 00:39:18,546
Issue draw calls, and
finally end encoding.


865
00:39:18,886 --> 00:39:21,396
So here's a recap of all the
code that we've seen thus far.


866
00:39:22,376 --> 00:39:23,056
Nothing new here.


867
00:39:23,456 --> 00:39:26,106
Exactly what we've seen and
exactly what I just said.


868
00:39:26,246 --> 00:39:32,106
Create a Render Command
Encoder, set state, set state,


869
00:39:32,816 --> 00:39:34,576
bind some buffers, and draw.


870
00:39:35,866 --> 00:39:37,966
So you've rendered all
this great content,


871
00:39:38,556 --> 00:39:39,836
but how do you actually
get it on the screen?


872
00:39:40,226 --> 00:39:41,306
It's pretty straightforward.


873
00:39:42,056 --> 00:39:44,576
So, first color attachment


874
00:39:44,666 --> 00:39:47,146
of your render pass is
usually a drawables texture


875
00:39:47,386 --> 00:39:48,296
that you've either gotten


876
00:39:48,296 --> 00:39:50,836
from a CA Metal Layer
or from and MKTView.


877
00:39:51,656 --> 00:39:54,146
So in order to request that that
texture actually get presented


878
00:39:54,146 --> 00:39:57,266
on screen, you can
actually just call present


879
00:39:57,266 --> 00:39:59,306
on the commandBuffer, and
pass in that drawable,


880
00:39:59,716 --> 00:40:01,606
and that will be displayed


881
00:40:01,606 --> 00:40:04,636
to the screen once all the
preceding passes are complete.


882
00:40:05,856 --> 00:40:08,546
Then to finally actually
finish up the frame,


883
00:40:08,846 --> 00:40:10,576
since we've been encoding
into this commandBuffer,


884
00:40:10,996 --> 00:40:12,076
we need to signify
that we're done


885
00:40:12,076 --> 00:40:13,636
with the commandBuffer
by calling commit.


886
00:40:14,566 --> 00:40:16,536
Committing tells the driver
that the commandBuffer's ready


887
00:40:16,536 --> 00:40:19,706
to be executed by the GPU.


888
00:40:19,916 --> 00:40:24,396
So to recap that, we created
a command queue at start-up,


889
00:40:24,686 --> 00:40:26,486
and since it's a
persistent object,


890
00:40:26,486 --> 00:40:28,586
we hold onto reference to it.


891
00:40:28,586 --> 00:40:31,406
Each frame we create a
commandBuffer, encode one


892
00:40:31,406 --> 00:40:33,896
or more rendering passes into it
with a render command encoder.


893
00:40:33,896 --> 00:40:36,206
Present the drawable
to the screen


894
00:40:36,206 --> 00:40:37,436
and then commit the
commandBuffer.


895
00:40:39,256 --> 00:40:41,286
And now I'm going to hand
things off to my colleague Matt,


896
00:40:41,676 --> 00:40:43,596
to walk us through the
demo of drawing in 2D.


897
00:40:44,036 --> 00:40:44,506
>> Thanks Warren.


898
00:40:47,516 --> 00:40:52,776
[ Applause ]


899
00:40:53,276 --> 00:40:54,176
>> So here's the proof.


900
00:40:54,176 --> 00:40:57,466
A 2D triangle, this is the Metal
triangle demo as you can tell


901
00:40:57,466 --> 00:41:00,366
by our awesome title,
is very simple.


902
00:41:00,406 --> 00:41:01,626
Just a triangle, three colors


903
00:41:01,626 --> 00:41:03,916
on the ends interpolated
nicely over the edges.


904
00:41:05,316 --> 00:41:06,186
Let's take a look at the code.


905
00:41:08,016 --> 00:41:09,566
Now first I want to
show you what it takes


906
00:41:09,566 --> 00:41:11,176
to become a delegate of MTKView,


907
00:41:11,646 --> 00:41:13,496
and Warren mentioned we have
two functions to implement.


908
00:41:13,846 --> 00:41:16,986
So here we have MTKView,
drawable, sizeable change.


909
00:41:17,436 --> 00:41:19,146
And this is what is called
when you need to respond


910
00:41:19,176 --> 00:41:21,176
to changes in your window.


911
00:41:22,156 --> 00:41:24,386
This sample is very simple so
we didn't actually implement it.


912
00:41:24,386 --> 00:41:26,876
We'll leave that up to you
guys for your own applications.


913
00:41:28,116 --> 00:41:29,786
And the other thing
is simple the draw.


914
00:41:31,446 --> 00:41:33,086
We chose to put this
into a render function.


915
00:41:33,626 --> 00:41:36,856
So, when our draw gets
called, we go into our render.


916
00:41:39,426 --> 00:41:40,436
Render's also quite simple.


917
00:41:40,696 --> 00:41:41,456
I just wanted to show you.


918
00:41:41,456 --> 00:41:45,716
When we take MTKView's
current RenderPassDescriptor,


919
00:41:46,806 --> 00:41:48,106
you just grab it out
like Warren said,


920
00:41:48,106 --> 00:41:50,436
and then you create the
RenderPassDescriptor


921
00:41:50,556 --> 00:41:51,396
and your encoder with it.


922
00:41:51,936 --> 00:41:53,146
And I'd like to draw
your attention here,


923
00:41:53,606 --> 00:41:54,416
"push debug group."


924
00:41:54,416 --> 00:41:57,136
And this is how you talk
to the awesome Metal tools.


925
00:41:57,496 --> 00:42:00,356
So when you do a frame
capture, this will then sort all


926
00:42:00,356 --> 00:42:02,626
of your draws by whatever
debug group you've had.


927
00:42:02,726 --> 00:42:04,896
So here, we have one
draw and a draw triangle


928
00:42:05,706 --> 00:42:08,696
and then we pop the debug
group after we've drawn,


929
00:42:08,976 --> 00:42:11,206
and so this draw will show up
labeled as "Draw Triangle."


930
00:42:13,396 --> 00:42:14,706
Let's take a look at the Shader.


931
00:42:17,316 --> 00:42:19,006
Now Warren mentioned,
we had structs.


932
00:42:19,006 --> 00:42:21,206
We have a vertex end
struct, which is the format


933
00:42:21,206 --> 00:42:23,206
of the data we're putting
into the Shader, as you see.


934
00:42:23,206 --> 00:42:24,516
That's just a position
and a color.


935
00:42:25,486 --> 00:42:26,796
And we have the vertex
out struct,


936
00:42:27,286 --> 00:42:28,976
which is what we're passing
down to the rasterizer.


937
00:42:28,976 --> 00:42:31,226
And you see here the
position has been tagged


938
00:42:31,266 --> 00:42:32,436
with this position attribute.


939
00:42:32,986 --> 00:42:34,676
And this represents the
Clip Space position.


940
00:42:34,826 --> 00:42:37,596
And every vertex Shader that you
have or vertex function, sorry,


941
00:42:37,956 --> 00:42:38,846
must have one of these.


942
00:42:40,426 --> 00:42:41,566
And as you saw, these
should look kind


943
00:42:41,566 --> 00:42:42,906
of familiar, they're
very simple.


944
00:42:43,536 --> 00:42:44,336
Vertices come in.


945
00:42:44,336 --> 00:42:45,686
We have a pass through.


946
00:42:45,686 --> 00:42:46,996
And you write them out.


947
00:42:47,636 --> 00:42:51,326
And in the fragmentFunction, we
take in the vertices that came


948
00:42:51,326 --> 00:42:52,136
out of the rasterizer


949
00:42:52,206 --> 00:42:54,476
and we read the color,
and send that down.


950
00:42:55,476 --> 00:42:56,556
So that's the simple
triangle demo.


951
00:42:56,556 --> 00:42:58,066
I'll send it back
to your Warren.


952
00:42:58,516 --> 00:43:02,436
>> Thanks Matt.


953
00:43:03,916 --> 00:43:06,506
So, we've shown how to
actually draw 2D content.


954
00:43:07,486 --> 00:43:10,096
And 2D is cool, but you
know what's even cooler?


955
00:43:10,656 --> 00:43:14,056
Three-D. So let's talk a
little bit about animation


956
00:43:14,056 --> 00:43:15,066
and texturing in Metal.


957
00:43:18,486 --> 00:43:19,596
In order to actually
get into 3D --


958
00:43:20,966 --> 00:43:23,016
alright well, we'll go through
this in a couple stages.


959
00:43:23,016 --> 00:43:24,406
We'll talk about how to
actually get into 3D.


960
00:43:24,406 --> 00:43:26,836
And we'll talk about animating
with a constant buffer,


961
00:43:26,836 --> 00:43:29,636
and then we'll talk a little
bit about texturing a sampling.


962
00:43:30,596 --> 00:43:31,826
In order to move into 3D,


963
00:43:32,596 --> 00:43:35,026
whereas we've been specifying
our vertices in Clip Space,


964
00:43:35,026 --> 00:43:37,736
we now need to specify them
in a model local space.


965
00:43:38,326 --> 00:43:39,666
And then multiply them


966
00:43:39,666 --> 00:43:42,916
by a suitable model
view projection matrix,


967
00:43:43,346 --> 00:43:45,156
in order to move them
back into Clip Space.


968
00:43:45,936 --> 00:43:49,686
And we'll also add properties
for a vertex normal as well


969
00:43:49,686 --> 00:43:51,796
as texture coordinates so
that we can actually use those


970
00:43:51,796 --> 00:43:54,616
in our fragmentFunction,
to determine lighting


971
00:43:54,856 --> 00:43:56,666
and to determine how to
apply the texture map.


972
00:43:58,246 --> 00:44:00,636
So, here's our extended vertex.


973
00:44:01,106 --> 00:44:03,636
We have removed the color
attribute and we've added


974
00:44:03,636 --> 00:44:07,006
in a normal vector as well as
a set of texture coordinates.


975
00:44:08,206 --> 00:44:12,696
And similarly to how we had
in 2D, we'll just be adding


976
00:44:12,696 --> 00:44:16,846
on a new buffer that will store
all the constants that we need


977
00:44:17,336 --> 00:44:21,466
to reference from our various
vertex and fragmentFunctions


978
00:44:21,466 --> 00:44:25,226
in order to actually transform
those vertices appropriately.


979
00:44:25,226 --> 00:44:27,236
Now, you'll notice
that the outline


980
00:44:27,236 --> 00:44:31,006
of this buffer is dashed, and
there's a good reason for that.


981
00:44:31,596 --> 00:44:35,256
Because I don't want to create
another Metal buffer in order


982
00:44:35,256 --> 00:44:37,346
to manage this tiny
amount of data.


983
00:44:37,346 --> 00:44:38,656
This is only a couple
of matrices.


984
00:44:39,036 --> 00:44:41,396
And it turns out that Metal
actually has an awesome API


985
00:44:42,036 --> 00:44:45,446
for binding very small buffers
and managing them for you.


986
00:44:47,516 --> 00:44:49,536
So again, for small
bits of data,


987
00:44:49,656 --> 00:44:53,356
less than about 4 kilobytes,
you can use this API set


988
00:44:53,356 --> 00:44:57,406
of vertex bytes and pass it --
a pointer directly to your data.


989
00:44:57,836 --> 00:44:59,396
And of course, tell
us what size it is.


990
00:44:59,996 --> 00:45:04,216
And Metal will create
and or reuse a buffer


991
00:45:04,386 --> 00:45:05,456
that contains that data.


992
00:45:06,206 --> 00:45:10,046
And again, you can actually
specify the argument table index


993
00:45:10,046 --> 00:45:12,086
here, specifying it as 1,


994
00:45:12,086 --> 00:45:14,776
because our vertices are
already bound at Index 0,


995
00:45:15,376 --> 00:45:18,266
so we bind at Index 1 so that
we can then read from that,


996
00:45:18,266 --> 00:45:20,076
inside of our functions.


997
00:45:20,866 --> 00:45:22,866
So let's take a look at how
our functions actually change


998
00:45:22,866 --> 00:45:23,716
and respond to this.


999
00:45:25,156 --> 00:45:26,696
Before that, we'll
see an example of how


1000
00:45:26,696 --> 00:45:30,396
to actually call setForTextBytes
inside your application code.


1001
00:45:30,776 --> 00:45:32,906
So, we'll create
this constant struct


1002
00:45:32,986 --> 00:45:34,066
that again creates these --


1003
00:45:34,116 --> 00:45:37,276
contains these two matrices that
we're going to be multiplying


1004
00:45:37,316 --> 00:45:40,696
by the Model View Projection
Matrix, and the normal matrix,


1005
00:45:40,696 --> 00:45:42,466
which is the matrix that
transforms the normal


1006
00:45:42,466 --> 00:45:45,086
from local space into iSpace.


1007
00:45:45,646 --> 00:45:47,856
We'll construct them using
whatever matrix utilities we're


1008
00:45:47,856 --> 00:45:50,276
comfortable with, and then
multiply them together.


1009
00:45:50,586 --> 00:45:53,996
And finally use setVertexBytes,
passing a reference


1010
00:45:54,046 --> 00:45:57,316
to that structure and then
Metal will copy that into again,


1011
00:45:57,316 --> 00:46:00,206
this implicit buffer that's
going to be used for drawing


1012
00:46:00,326 --> 00:46:03,386
in our subsequent draw call.


1013
00:46:03,946 --> 00:46:07,846
Now, last year at
WWDC, we introduced


1014
00:46:07,846 --> 00:46:09,806
and awesome framework
called Model I/O,


1015
00:46:10,366 --> 00:46:13,586
and Model I/O contains a
lot of awesome utilities.


1016
00:46:14,096 --> 00:46:16,326
But one of the great
things about Model I/O is


1017
00:46:16,326 --> 00:46:19,966
that it also allows you
to generate common shapes.


1018
00:46:20,706 --> 00:46:22,466
And because of MetalKit,


1019
00:46:22,606 --> 00:46:25,406
it actually has very tight
integration with Metal


1020
00:46:25,406 --> 00:46:27,866
so that you can create
vertex data


1021
00:46:27,866 --> 00:46:29,996
that can be rendered
directly by Metal.


1022
00:46:31,086 --> 00:46:33,756
So, instead of actually
specifying all these vertices


1023
00:46:33,756 --> 00:46:37,366
by hand, I can for example,
draw my model in some sort


1024
00:46:37,416 --> 00:46:40,046
of content creation
package, export it,


1025
00:46:40,226 --> 00:46:41,236
and load it with Model I/O.


1026
00:46:41,526 --> 00:46:43,736
Or in this case,
generate it procedurally.


1027
00:46:44,016 --> 00:46:46,666
So let's take a look
at that in code.


1028
00:46:46,846 --> 00:46:48,236
So I want to generate
some vertexBuffers


1029
00:46:48,236 --> 00:46:49,856
that represent this cube.


1030
00:46:50,606 --> 00:46:53,546
Well, in order to actually get
Model I/O to speak in Metal,


1031
00:46:54,006 --> 00:46:56,446
I'll create this thing
called a MeshBufferAllocator.


1032
00:46:57,516 --> 00:47:00,116
So MTKMeshBufferAllocator
is the glue


1033
00:47:00,116 --> 00:47:02,046
between Model I/O and Metal.


1034
00:47:03,066 --> 00:47:05,906
By passing a device to
a Mesh Buffer Allocator,


1035
00:47:06,306 --> 00:47:09,276
we allow Model I/O to create
Metal buffers directly


1036
00:47:09,406 --> 00:47:13,226
and then hand them back to us.


1037
00:47:13,226 --> 00:47:15,906
So we create an MDLMesh
using this utility method


1038
00:47:16,236 --> 00:47:20,256
boxWithExtent, etcetera,
pass in our allocator,


1039
00:47:20,256 --> 00:47:23,136
and this will create an
MDLMesh - a Model I/O Mesh -


1040
00:47:23,806 --> 00:47:26,346
that contains the relevant data.


1041
00:47:26,906 --> 00:47:30,456
We then need to extract it
by using MetalKit's utilities


1042
00:47:31,036 --> 00:47:32,316
that are provided
for this purpose.


1043
00:47:32,456 --> 00:47:33,896
And that looks like this.


1044
00:47:34,366 --> 00:47:36,596
So first, we generate
and MTKMesh that takes


1045
00:47:36,596 --> 00:47:39,776
in the MDLMesh that we just
generated, as well as a device.


1046
00:47:40,176 --> 00:47:44,826
And then in order to extract
the vertexBuffer, we just index


1047
00:47:44,826 --> 00:47:46,736
into the mesh and pull it out.


1048
00:47:47,396 --> 00:47:48,706
Similarly, for the indexBuffer.


1049
00:47:49,406 --> 00:47:51,146
And there are also a
couple of parameters here


1050
00:47:51,146 --> 00:47:52,366
that we've already
seen that we'll need


1051
00:47:52,366 --> 00:47:53,656
to supply to our draw call.


1052
00:47:53,656 --> 00:47:56,926
But the emphasis here is on
the fact that it's very easy


1053
00:47:57,196 --> 00:47:59,836
to use Model I/O to
generate procedural geometry


1054
00:48:00,136 --> 00:48:01,736
and subsequently
pull out buffers


1055
00:48:01,736 --> 00:48:05,136
that you can use
directly in Metal.


1056
00:48:05,346 --> 00:48:06,916
And now let's talk a
little bit about textures.


1057
00:48:07,576 --> 00:48:08,556
We have our vertex data.


1058
00:48:08,676 --> 00:48:10,326
We want to apply a
texture map to it


1059
00:48:10,326 --> 00:48:11,366
to add a little bit more detail.


1060
00:48:12,066 --> 00:48:14,496
Well, as you know, textures
are blocks of memory


1061
00:48:14,686 --> 00:48:16,836
in some pre-specified,
pixel format.


1062
00:48:17,116 --> 00:48:19,856
And they predominantly are
used to store image data.


1063
00:48:21,086 --> 00:48:24,796
In Metal, it's no great surprise
that you create textures


1064
00:48:24,916 --> 00:48:25,956
with a descriptor object,


1065
00:48:26,296 --> 00:48:28,516
specifically a Metal
Texture Descriptor.


1066
00:48:29,216 --> 00:48:31,326
And texture descriptors
are parameter objects


1067
00:48:31,326 --> 00:48:34,446
that brings together texture
properties like height and width


1068
00:48:34,446 --> 00:48:37,996
and pixel format, and
are used by the device


1069
00:48:37,996 --> 00:48:41,356
to actually generate the
texture object: Metal texture.


1070
00:48:41,926 --> 00:48:44,086
Let's take a look at that.


1071
00:48:44,756 --> 00:48:46,146
So we have these
convenience functions


1072
00:48:46,206 --> 00:48:48,746
on Metal Texture Descriptor,
that allow you to ask


1073
00:48:48,746 --> 00:48:51,396
for the descriptor that
corresponds to a 2D texture,


1074
00:48:51,946 --> 00:48:55,366
supplying on the necessary
parameters: height, width,


1075
00:48:55,866 --> 00:48:58,606
pixel format, and whether or
not you want it to be mipmapped.


1076
00:48:59,016 --> 00:49:02,226
You can then ask
for a new texture


1077
00:49:02,226 --> 00:49:04,836
by calling newTexture
on the device.


1078
00:49:04,836 --> 00:49:07,456
Now, this texture doesn't
actually have any image content


1079
00:49:07,456 --> 00:49:09,356
in it, so you'll
need to use a method


1080
00:49:09,356 --> 00:49:11,286
like Replace Region or similar.


1081
00:49:11,286 --> 00:49:14,386
You can consult the docs for
that, but we're going to use


1082
00:49:14,386 --> 00:49:16,736
yet another utility to make
that a little bit easier to day.


1083
00:49:16,736 --> 00:49:19,116
And that's called
MTKTextureLoader.


1084
00:49:19,496 --> 00:49:22,556
So this is a utility provided by
MetalKit, and it can load images


1085
00:49:22,556 --> 00:49:24,976
from a number of sources,
including your asset catalogs


1086
00:49:24,976 --> 00:49:27,846
or from a file URL,
or from CG images


1087
00:49:27,846 --> 00:49:29,416
that you have already
sitting in memory,


1088
00:49:29,416 --> 00:49:31,626
in the form of an MS
image or a UI image.


1089
00:49:32,236 --> 00:49:34,616
And this generates and
populates Metal textures


1090
00:49:34,616 --> 00:49:36,796
of the appropriate size
and format that correspond


1091
00:49:36,796 --> 00:49:38,066
to the image data
that you already have.


1092
00:49:38,166 --> 00:49:40,566
Now let's take a
look at that in code.


1093
00:49:40,776 --> 00:49:43,696
So you can create
an MTKTextureLoader


1094
00:49:43,796 --> 00:49:45,256
by simply passing
your Metal device.


1095
00:49:45,836 --> 00:49:46,856
You'll get back a TextureLoader,


1096
00:49:47,656 --> 00:49:51,026
and you can subsequently fetch a
data asset or whatever have you


1097
00:49:51,026 --> 00:49:52,056
from your asset catalog.


1098
00:49:52,056 --> 00:49:54,286
And as long as you
get the data back,


1099
00:49:54,286 --> 00:49:56,956
then you can call
texture Loader.newTexture,


1100
00:49:57,666 --> 00:50:00,426
and hand it to data, and it will
hand you back a Metal texture.


1101
00:50:03,756 --> 00:50:07,516
You might also be acquainted
with the notion called Samplers.


1102
00:50:07,666 --> 00:50:10,326
Now, Samplers and Metal are
distinct objects from textures.


1103
00:50:10,326 --> 00:50:12,096
They're not bound together.


1104
00:50:13,296 --> 00:50:15,336
And Samplers simply
contain the state related


1105
00:50:15,336 --> 00:50:16,246
to texture sampling.


1106
00:50:16,806 --> 00:50:20,506
So parameters such as
filtering modes, address modes,


1107
00:50:20,506 --> 00:50:22,316
as well as level of detail.


1108
00:50:22,476 --> 00:50:24,786
And so we support
all those shown here.


1109
00:50:25,236 --> 00:50:28,806
In order to get a Sampler
state that we'll bind later


1110
00:50:28,806 --> 00:50:31,206
on in our Render Command
encoder, to do textured drawing,


1111
00:50:32,336 --> 00:50:34,486
we'll create a Metal
Sampler Descriptor,


1112
00:50:34,486 --> 00:50:35,536
and that looks like this.


1113
00:50:36,506 --> 00:50:38,826
So we create an empty
Metal Sampler Descriptor


1114
00:50:39,256 --> 00:50:40,476
that has default properties,


1115
00:50:40,476 --> 00:50:42,446
and we specify whichever
properties we want.


1116
00:50:42,716 --> 00:50:44,976
Here, I'm specifying that we
want the texture to repeat


1117
00:50:45,616 --> 00:50:48,706
in both axes, and
that when minifying,


1118
00:50:48,706 --> 00:50:50,106
we want to use the
nearest filtering


1119
00:50:50,106 --> 00:50:52,226
and when magnifying
we linear filtering.


1120
00:50:52,976 --> 00:50:54,686
So once we've created
this descriptor object,


1121
00:50:55,456 --> 00:50:56,676
we call newSamplerState,


1122
00:50:56,676 --> 00:50:59,206
and we get back a Metal
Sampler State Object,


1123
00:50:59,606 --> 00:51:03,686
that we can subsequently use to
bind and sample from a texture.


1124
00:51:03,686 --> 00:51:06,866
In the Render Command Encoder,
the API looks like this.


1125
00:51:07,586 --> 00:51:11,326
We create a texture so
we set it at Slot Zero


1126
00:51:11,956 --> 00:51:13,846
of the Fragment Texture
Argument Table.


1127
00:51:13,846 --> 00:51:18,736
And then we bind our
Sampler State at Index Zero


1128
00:51:18,836 --> 00:51:21,856
of the Sampler State Argument
Table for the fragmentFunction.


1129
00:51:23,866 --> 00:51:25,896
And let's look at those
functions in turn.


1130
00:51:26,856 --> 00:51:29,186
So the vertex function this
time around, will multiply


1131
00:51:29,186 --> 00:51:31,426
by the MVP Matrix that
we're going to get


1132
00:51:31,426 --> 00:51:32,896
out of -- a constant buffer.


1133
00:51:33,076 --> 00:51:35,326
It will then transform
the vertex positions


1134
00:51:35,326 --> 00:51:37,186
from all the local
space into Clip Space,


1135
00:51:37,626 --> 00:51:40,226
which is what we're obligated to
return from the vertex function.


1136
00:51:40,276 --> 00:51:42,796
And it will also transform
those vertex normal


1137
00:51:42,796 --> 00:51:44,566
from Models Local
Space into Eye Space,


1138
00:51:44,566 --> 00:51:45,736
so that we can do our lighting.


1139
00:51:46,406 --> 00:51:47,426
Here's what it looks
like in code.


1140
00:51:48,216 --> 00:51:50,346
So notice that we've added
a parameter attributed


1141
00:51:50,346 --> 00:51:52,706
with Buffer 1, and like
I mentioned earlier,


1142
00:51:52,706 --> 00:51:54,406
this corresponds to
the constants buffer.


1143
00:51:54,936 --> 00:51:56,346
So we've created a struct type


1144
00:51:56,346 --> 00:51:58,996
in our metal shaving
language code that corresponds


1145
00:51:58,996 --> 00:52:01,146
to the constant struct that
we created in our SWF code,


1146
00:52:01,146 --> 00:52:04,016
that allows us to fetch out
the Model View Projection


1147
00:52:04,016 --> 00:52:04,946
in normal matrices.


1148
00:52:05,296 --> 00:52:08,036
And again, this is bound
at Argument Table Index 1.


1149
00:52:08,406 --> 00:52:11,046
So that corresponds to the
attribute that you see there.


1150
00:52:12,296 --> 00:52:16,236
So, to actually move into Clip
Space, we index once again


1151
00:52:16,236 --> 00:52:18,276
into the vertexBuffer
at Vertex ID.


1152
00:52:18,976 --> 00:52:20,056
Get up a position vector.


1153
00:52:20,346 --> 00:52:22,436
Multiply it by the MVP
matrix and assign it


1154
00:52:22,436 --> 00:52:23,346
to the outgoing struct.


1155
00:52:24,036 --> 00:52:25,456
Similarly, for the normal.


1156
00:52:25,986 --> 00:52:29,526
And also, we just copy
through the texture coordinates


1157
00:52:29,526 --> 00:52:30,976
to the outgoing struct as well.


1158
00:52:31,016 --> 00:52:32,736
And all of these of
course will be interpolated


1159
00:52:32,736 --> 00:52:33,516
by the rasterizer.


1160
00:52:34,086 --> 00:52:35,426
So we just go ahead
and return that struct.


1161
00:52:36,366 --> 00:52:38,596
The fragmentFunction is a
little bit more involved


1162
00:52:38,696 --> 00:52:39,346
than previously.


1163
00:52:39,836 --> 00:52:41,976
We want to actually
compute some basic lighting,


1164
00:52:42,246 --> 00:52:44,696
so we'll include two terms of
ambient and diffuse lighting,


1165
00:52:44,696 --> 00:52:48,076
and also sample from the texture
[inaudible] you just bound


1166
00:52:48,076 --> 00:52:50,346
to apply the texture
to the surface.


1167
00:52:51,276 --> 00:52:52,246
It looks like this.


1168
00:52:52,576 --> 00:52:55,156
We're not going to talk
through this in exacting detail,


1169
00:52:55,856 --> 00:52:57,296
but the important
thing to note here is


1170
00:52:57,296 --> 00:52:59,476
that we've added a parameter
that corresponds to the texture


1171
00:52:59,476 --> 00:53:00,696
that we've created and bound,


1172
00:53:01,316 --> 00:53:03,626
we've given it an access
qualifier of sample


1173
00:53:03,856 --> 00:53:05,196
which allows us to
sample from it.


1174
00:53:05,756 --> 00:53:07,486
It's sitting at Argument
Table Index Zero.


1175
00:53:07,946 --> 00:53:09,666
The Sampler State that
we created is sitting


1176
00:53:09,706 --> 00:53:13,906
at Argument Slot Zero for the
sampler, and all we need to do


1177
00:53:13,906 --> 00:53:15,736
to actually read a
[inaudible] from the --


1178
00:53:15,736 --> 00:53:18,106
a filtered value
from the texture,


1179
00:53:18,716 --> 00:53:20,596
is call Sample, on the texture.


1180
00:53:20,806 --> 00:53:23,996
So Text2D.Sample, actually
it takes the sampler state,


1181
00:53:24,946 --> 00:53:26,366
as well as the texture
coordinates


1182
00:53:26,366 --> 00:53:28,456
and gives us back
the color vector.


1183
00:53:29,796 --> 00:53:33,566
We'll also go ahead and do
all of our fancy lighting,


1184
00:53:33,636 --> 00:53:35,366
but I won't talk
through any detail.


1185
00:53:35,486 --> 00:53:39,196
But it's just dependent upon the
dot product between the normal


1186
00:53:39,196 --> 00:53:40,056
and the lighting direction.


1187
00:53:40,056 --> 00:53:43,926
And we specified some constants
related to the light earlier


1188
00:53:43,926 --> 00:53:45,616
in our Shader file that
we'll see during the demo.


1189
00:53:45,616 --> 00:53:47,596
And that's pretty much it.


1190
00:53:47,686 --> 00:53:52,176
So we constructed the color
for this particular fragment


1191
00:53:52,506 --> 00:53:54,846
by multiplying through the value
that we sample from the texture,


1192
00:53:55,056 --> 00:53:56,196
by the lighting intensity,


1193
00:53:56,336 --> 00:54:00,356
to result in an animated
textured lit cube.


1194
00:54:00,816 --> 00:54:05,306
And I will now let Matt
show you exactly that.


1195
00:54:05,556 --> 00:54:07,096
>> Alright, let's take
a look at this demo.


1196
00:54:08,046 --> 00:54:09,466
Here's the Metal texture mesh.


1197
00:54:09,676 --> 00:54:11,416
You can see, it's a
very complicated cube.


1198
00:54:12,066 --> 00:54:13,446
Some simple lighting,
and texturing,


1199
00:54:14,066 --> 00:54:15,926
on a nice colored background.


1200
00:54:18,586 --> 00:54:19,886
Go ahead and admire
it in all its glory,


1201
00:54:20,136 --> 00:54:22,216
and now we'll take a
look at the Shader.


1202
00:54:23,406 --> 00:54:24,666
So you can see some new stuff


1203
00:54:24,666 --> 00:54:25,966
in our Shader compared
to last time.


1204
00:54:26,536 --> 00:54:28,866
The first thing we take a look
at is this constant struct.


1205
00:54:29,346 --> 00:54:30,726
This corresponds
the Swift's direct


1206
00:54:30,756 --> 00:54:34,636
that has a 4 X 4 Model View
Projection Matrix, and a 3 X 3,


1207
00:54:34,636 --> 00:54:35,866
normal matrix, and
those are used


1208
00:54:35,866 --> 00:54:36,996
for the appropriate transforms.


1209
00:54:37,446 --> 00:54:40,716
As Warren mentioned, we
have some light data here.


1210
00:54:41,386 --> 00:54:43,176
Ambient light intensity,
which is quite low.


1211
00:54:43,486 --> 00:54:45,456
And the diffused light
intensity, which is quite high,


1212
00:54:45,586 --> 00:54:47,176
and the direction of
the light that we'll use


1213
00:54:47,596 --> 00:54:49,306
to actually compute
the dot product.


1214
00:54:49,306 --> 00:54:52,946
Our input and output structs
are slightly different.


1215
00:54:52,946 --> 00:54:54,076
We've got a little
more information


1216
00:54:54,076 --> 00:54:55,156
that we need to pass down now.


1217
00:54:55,956 --> 00:54:56,706
We have position.


1218
00:54:56,756 --> 00:54:58,296
We have the normal, which
we needed for the lighting,


1219
00:54:58,426 --> 00:54:59,396
and the texture coordinates


1220
00:54:59,396 --> 00:55:00,606
which we need to
apply the texture.


1221
00:55:01,616 --> 00:55:04,136
And similarly, when we output
from our vertex function,


1222
00:55:05,616 --> 00:55:06,636
we need that same data again.


1223
00:55:06,946 --> 00:55:08,236
So let's take a look
at the vertex function.


1224
00:55:08,636 --> 00:55:09,556
Just as Warren said,


1225
00:55:10,066 --> 00:55:12,676
it's basically just a couple
simple matrix, multiplies,


1226
00:55:12,746 --> 00:55:14,496
and then a pass through for
the texture coordinates.


1227
00:55:16,176 --> 00:55:18,226
And a quick look at
our fragmentFunction,


1228
00:55:18,226 --> 00:55:20,636
which is exactly what
Warren just showed you.


1229
00:55:22,066 --> 00:55:24,566
Now let's see how
the renderer looks.


1230
00:55:26,136 --> 00:55:27,496
A little more going on now.


1231
00:55:29,076 --> 00:55:30,266
So we have a little
bit of animation.


1232
00:55:30,316 --> 00:55:32,786
So we need to update a little
time step to know how much


1233
00:55:32,836 --> 00:55:33,856
to rotate our cube by.


1234
00:55:34,696 --> 00:55:36,136
So here we have a
little helper function


1235
00:55:36,136 --> 00:55:37,986
to update my time step
-- update with Time Step.


1236
00:55:38,846 --> 00:55:42,806
And that will change
our constants.


1237
00:55:43,986 --> 00:55:45,816
Just like Warren said, we
don't have much data that we'd


1238
00:55:45,816 --> 00:55:48,446
like to send over to the GPU,
so when you set vertex bytes,


1239
00:55:48,846 --> 00:55:50,266
send a small structure over,


1240
00:55:50,266 --> 00:55:51,936
which was the two
matrices before.


1241
00:55:51,936 --> 00:55:53,376
And that's what we'll use


1242
00:55:53,376 --> 00:55:57,076
to compute the animated
positions of our vertices.


1243
00:55:58,416 --> 00:56:00,496
Put the texture, the
samplers, and issue your Draws.


1244
00:56:01,356 --> 00:56:02,826
Highly recommend you
guys always remember


1245
00:56:02,826 --> 00:56:04,616
to push your debug
groups so you know,


1246
00:56:04,996 --> 00:56:06,366
exactly what you're looking
at if you're going to look


1247
00:56:06,366 --> 00:56:07,426
at a frame capture later on.


1248
00:56:08,096 --> 00:56:12,856
Present your drawable and
commit, and then you're done.


1249
00:56:14,846 --> 00:56:19,316
>> Cool. Thanks again, Matt.


1250
00:56:19,936 --> 00:56:23,006
So with these adopting Metal
sessions, we really wanted


1251
00:56:23,006 --> 00:56:25,666
to take advantage of the
fact that we've had a couple


1252
00:56:25,666 --> 00:56:27,096
of years now, teaching Metal,


1253
00:56:27,586 --> 00:56:29,316
and introducing awesome
new utilities


1254
00:56:29,706 --> 00:56:31,196
that make Metal easy to use.


1255
00:56:31,286 --> 00:56:32,786
And so we hope that these --


1256
00:56:33,276 --> 00:56:36,116
this two-part session
is useful for that.


1257
00:56:36,116 --> 00:56:38,396
You've seen that
Metal is a powerful


1258
00:56:38,396 --> 00:56:42,436
and low overhead GPU programming
technology, and fortunately now,


1259
00:56:42,436 --> 00:56:44,696
you've become acquainted
with some of the APIs


1260
00:56:44,696 --> 00:56:47,066
that are available inside of it.


1261
00:56:48,056 --> 00:56:50,196
Metal is a very closely --


1262
00:56:50,196 --> 00:56:54,026
is very much informed by how
the GPU actually operates


1263
00:56:54,026 --> 00:56:57,666
and is you know, philosophically
of course, we want you to push


1264
00:56:57,666 --> 00:57:00,656
as much expensive work
up front as possible.


1265
00:57:00,756 --> 00:57:02,466
And so you've seen sort
of some of the ways


1266
00:57:02,466 --> 00:57:04,896
that that informs
the API as well.


1267
00:57:05,466 --> 00:57:09,486
And the emphasis of course
is not on the restrictions


1268
00:57:09,486 --> 00:57:10,616
that that entails,
but of course,


1269
00:57:10,616 --> 00:57:12,146
the power that it
imbues you with.


1270
00:57:12,596 --> 00:57:14,476
So you've seen how
explicit memory management


1271
00:57:14,476 --> 00:57:17,346
and command submission can let
you work a little bit smarter,


1272
00:57:17,416 --> 00:57:19,816
in a sense that if you know
how your application is shaped


1273
00:57:19,816 --> 00:57:21,916
and you know what it's
doing, then you can actually,


1274
00:57:22,526 --> 00:57:25,466
you can take the reins and
control the GPU directly.


1275
00:57:26,336 --> 00:57:30,106
And of course, over the next
few sessions on Metal here


1276
00:57:30,666 --> 00:57:33,426
at WWDC this year,
we'll show you even more


1277
00:57:33,626 --> 00:57:34,816
that Metal has in store.


1278
00:57:34,876 --> 00:57:36,936
And then of course, it
will be your turn to go


1279
00:57:36,936 --> 00:57:38,346
and build awesome
new experiences.


1280
00:57:39,016 --> 00:57:41,386
So for more information on this
session, Session Number 602,


1281
00:57:41,386 --> 00:57:43,826
you can go to this
URL, and of course,


1282
00:57:43,826 --> 00:57:45,006
there are some related sessions.


1283
00:57:45,496 --> 00:57:48,936
Part II will be happening in
this very room, very shortly.


1284
00:57:49,866 --> 00:57:53,966
And tomorrow we have, What's
New in Metal, Parts I and II.


1285
00:57:54,116 --> 00:57:56,826
And the Advanced Metal
Shader Optimization talk


1286
00:57:56,826 --> 00:57:57,366
that I mentioned.


1287
00:57:57,736 --> 00:57:59,976
So thank you, and
have a wonderful WWDC.


1288
00:58:00,016 --> 00:58:02,000
[ Applause ]

