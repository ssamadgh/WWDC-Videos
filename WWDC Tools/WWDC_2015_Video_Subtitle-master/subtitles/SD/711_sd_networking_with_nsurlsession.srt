1
00:00:25,516 --> 00:00:31,796
[Applause]


2
00:00:32,296 --> 00:00:32,776
>> LUKE CASE: Good morning!


3
00:00:34,116 --> 00:00:35,336
Thanks for coming
out and welcome


4
00:00:35,336 --> 00:00:37,196
to "Networking with
NSURL Session."


5
00:00:37,716 --> 00:00:40,266
I'm Luke Case and I'm an
engineer on the CF Network team.


6
00:00:40,266 --> 00:00:41,836
We have got some
great stuff lined


7
00:00:41,836 --> 00:00:42,906
up for you guys this morning.


8
00:00:43,416 --> 00:00:45,846
First, we're going
to talk a little bit


9
00:00:45,846 --> 00:00:49,126
about app transport security
and following that we will talk


10
00:00:49,126 --> 00:00:52,216
about some new protocol support
we've added in NSURL Session.


11
00:00:53,086 --> 00:00:56,136
Now, we all heard about
watchOS on Monday.


12
00:00:56,546 --> 00:00:59,936
We'll talk about the NSURL
Session features we've added


13
00:01:00,576 --> 00:01:01,666
for watchOS.


14
00:01:02,026 --> 00:01:05,495
Following that, we will wrap
things up with some API changes


15
00:01:05,495 --> 00:01:07,776
and some new additions we've
added to the NSURL Session.


16
00:01:08,366 --> 00:01:11,906
Now, to begin, I would like
to start with a little bit


17
00:01:11,906 --> 00:01:15,686
of background on NSURL
Session and the HTTP protocol.


18
00:01:16,166 --> 00:01:19,976
NSURL Session is a networking
API that is mainly used


19
00:01:19,976 --> 00:01:23,666
to download content, HTTP
content, from the web.


20
00:01:24,576 --> 00:01:27,906
It has a rich set of delegate
methods that can be used


21
00:01:27,906 --> 00:01:32,016
for authentication and other
important event handling.


22
00:01:32,616 --> 00:01:35,846
And one of the greatest
features about NSURL Session is


23
00:01:35,846 --> 00:01:36,886
that it allows you


24
00:01:37,436 --> 00:01:41,906
to do networking even while
your app is not running via the


25
00:01:42,066 --> 00:01:44,216
background download APIs.


26
00:01:44,216 --> 00:01:47,456
Now, for those of you
that aren't familiar


27
00:01:47,456 --> 00:01:49,746
with NSURL Session,
it's recommended


28
00:01:49,746 --> 00:01:53,826
that you go back a few years
to the previous WWDC sessions


29
00:01:54,246 --> 00:01:55,986
on the introduction
of NSURL Session.


30
00:01:56,356 --> 00:01:59,196
So now let's talk a little bit


31
00:01:59,196 --> 00:02:02,096
about the hypertext
transfer protocol.


32
00:02:02,166 --> 00:02:04,286
It's a very well-known
protocol and many


33
00:02:04,286 --> 00:02:06,136
of you x probably
are familiar with it.


34
00:02:06,846 --> 00:02:08,106
Essentially at its core,


35
00:02:08,106 --> 00:02:11,356
what you are doing is you are
making requests to the server


36
00:02:11,556 --> 00:02:14,396
and you are pulling
in data in response.


37
00:02:15,196 --> 00:02:20,686
Now, HTTP in itself, as
some of you may know,


38
00:02:20,686 --> 00:02:22,096
is sent out over cleartext.


39
00:02:22,096 --> 00:02:23,766
So it's inherently insecure.


40
00:02:24,726 --> 00:02:26,086
And in today's environment,


41
00:02:26,686 --> 00:02:28,566
there's many hostile
parties going


42
00:02:29,006 --> 00:02:31,156
after the data that's
leaving your app


43
00:02:31,156 --> 00:02:32,636
and going out onto the network.


44
00:02:36,396 --> 00:02:41,356
Now, there was a time when
using cleartext HTTP alone was


45
00:02:41,356 --> 00:02:42,346
perfectly reasonable.


46
00:02:42,736 --> 00:02:44,586
But that time has passed.


47
00:02:45,216 --> 00:02:48,426
Now, fortunately for all of us,
this problem has been solved


48
00:02:48,426 --> 00:02:49,646
for many years and
there's a tried


49
00:02:49,646 --> 00:02:56,786
and true solution
known as HTTPS.


50
00:02:56,786 --> 00:03:00,066
Now, HTTPS is essentially
HTTP layered on top


51
00:03:00,066 --> 00:03:02,746
of another protocol known
as transport layer security.


52
00:03:03,416 --> 00:03:06,656
And transport layer security
performs a multi-leg handshake


53
00:03:07,106 --> 00:03:10,026
using public key
cryptography and, when complete,


54
00:03:10,246 --> 00:03:11,806
creates a secure connection.


55
00:03:11,806 --> 00:03:15,216
Now this connection
is considered secure


56
00:03:15,536 --> 00:03:16,806
because of three properties.


57
00:03:17,576 --> 00:03:21,866
The first being that the data
that's leaving your app goes


58
00:03:21,866 --> 00:03:23,026
over the network encrypted.


59
00:03:23,396 --> 00:03:24,256
So it can't be read.


60
00:03:25,146 --> 00:03:28,036
The second that it
provides message integrity


61
00:03:28,676 --> 00:03:31,096
so the message can't be
altered without detection.


62
00:03:31,916 --> 00:03:34,816
And finally, the third,
it provides authentication


63
00:03:34,816 --> 00:03:37,856
so you can actually prove
the identity of exactly


64
00:03:37,856 --> 00:03:42,766
who you are talking to.


65
00:03:43,016 --> 00:03:47,046
Now, NSURL Session has
excellent HTTPS support embedded


66
00:03:47,046 --> 00:03:51,206
within in it, and so often in
your client code, it's as easy


67
00:03:51,396 --> 00:03:54,296
as using HTTPS instead
of using HTTP.


68
00:03:54,946 --> 00:03:57,456
Now, do note that some
additional server support is


69
00:03:57,456 --> 00:04:04,016
required, but HTTPS is supported
by most server vendors today.


70
00:04:04,196 --> 00:04:09,386
Also keep in mind that most data
should be considered sensitive,


71
00:04:09,386 --> 00:04:13,296
and this is because even
if you might not think


72
00:04:13,296 --> 00:04:15,996
that the data that's
leaving your app going


73
00:04:16,286 --> 00:04:17,976
out onto the network
is not sensitive,


74
00:04:18,815 --> 00:04:21,726
your customer may,
in fact, think it is.


75
00:04:22,005 --> 00:04:24,616
For example, if you
have a TV streaming app,


76
00:04:26,086 --> 00:04:27,966
you may think, well,
it's just TV.


77
00:04:28,086 --> 00:04:30,406
You know? He's just watching TV.


78
00:04:30,786 --> 00:04:32,916
He or she is just
watching TV, but to them,


79
00:04:33,376 --> 00:04:37,376
it may mean that they
don't want people


80
00:04:37,756 --> 00:04:39,176
to know what they are
watching, essentially.


81
00:04:39,246 --> 00:04:39,966
Let's put it that way.


82
00:04:40,486 --> 00:04:42,486
[Laughter]


83
00:04:42,956 --> 00:04:46,586
So -- now, why is it
important to use HTTPS?


84
00:04:46,586 --> 00:04:49,076
Well, it's essentially,
it comes down to this:


85
00:04:49,416 --> 00:04:52,586
your customers trust you with
their data and their privacy.


86
00:04:53,526 --> 00:04:56,596
And we at Apple, we really want
to work together with you guys


87
00:04:56,596 --> 00:04:59,866
to make sure that we build
upon and maintain that trust.


88
00:05:00,236 --> 00:05:01,146
And today, I'm proud


89
00:05:01,146 --> 00:05:03,556
to introduce App
Transport Security.


90
00:05:04,096 --> 00:05:08,726
Now, App Transport Security
is a new feature from Apple


91
00:05:09,096 --> 00:05:11,766
in iOS 9 and OS X, El Capitan.


92
00:05:11,766 --> 00:05:17,366
And essentially, at its core
it helps prevent accidental


93
00:05:17,366 --> 00:05:19,736
disclosure of sensitive
customer data.


94
00:05:21,836 --> 00:05:26,186
Now, ATS also strengthens the
default policy of NSURL Session.


95
00:05:27,336 --> 00:05:30,826
And perhaps the most important
aspect of that strengthening is


96
00:05:30,826 --> 00:05:33,436
that now NSURL Session,
by default,


97
00:05:33,726 --> 00:05:36,266
will disallow cleartext
HTTP loads.


98
00:05:36,626 --> 00:05:38,776
It'll only use HTTPS
connections.


99
00:05:39,236 --> 00:05:41,466
Now, these connections that
it does make uses today's


100
00:05:41,466 --> 00:05:42,496
best practices.


101
00:05:43,216 --> 00:05:46,226
So ATS places restrictions
on TLS versions,


102
00:05:47,006 --> 00:05:49,776
cipher suites used,
certificate trusts,


103
00:05:50,176 --> 00:05:52,756
and certificate key sizes that
are used in that transaction.


104
00:05:53,466 --> 00:05:59,066
Now ATS is simply configured
via your apps Info.plist.


105
00:05:59,706 --> 00:06:00,976
And you can see an example here.


106
00:06:02,166 --> 00:06:03,966
Essentially what we
are asking you to do is


107
00:06:03,966 --> 00:06:08,346
to declare your intended network
behavior within your app.


108
00:06:10,536 --> 00:06:15,216
So at its core, ATS wants you to
really describe what you intend


109
00:06:15,216 --> 00:06:19,016
to do with the network, and we
really want you to worry less


110
00:06:19,336 --> 00:06:21,646
about the security of your
app and rely more heavily


111
00:06:21,996 --> 00:06:23,406
on the system to
do the right thing.


112
00:06:23,916 --> 00:06:27,216
So describing your network
transaction is, of course,


113
00:06:27,216 --> 00:06:28,836
easiest when it's all secure.


114
00:06:30,496 --> 00:06:34,956
So if your app exclusively
uses secure connections,


115
00:06:35,156 --> 00:06:37,266
and they only use best
practice properties,


116
00:06:37,916 --> 00:06:39,386
then there's nothing
else you have to do


117
00:06:39,386 --> 00:06:41,526
to configure ATS
within your app.


118
00:06:42,666 --> 00:06:45,426
So if you are writing a
new app, this is exactly


119
00:06:45,426 --> 00:06:48,606
where we want you to start,
and if you have an existing app


120
00:06:48,606 --> 00:06:50,046
or you are supporting
legacy code,


121
00:06:50,046 --> 00:06:54,796
this is where you
should aim to be.


122
00:06:55,056 --> 00:07:00,546
Now, we understand that this
may not be always the case


123
00:07:00,546 --> 00:07:02,016
that you have a server
that can comply


124
00:07:02,016 --> 00:07:06,506
with these new restrictions on
TLS versions or cipher suites,


125
00:07:06,966 --> 00:07:11,136
so we allowed that to --
through the use of exceptions.


126
00:07:11,516 --> 00:07:14,976
And essentially, with ATS
you can declare exceptions


127
00:07:15,996 --> 00:07:18,606
and let us know what versions
of TLS you want to use,


128
00:07:18,606 --> 00:07:19,386
or if you want to opt


129
00:07:19,386 --> 00:07:21,686
out of forward secrecy,
or other options.


130
00:07:22,246 --> 00:07:24,956
Now, we do understand


131
00:07:24,956 --> 00:07:27,896
that existing apps may
have different constraints.


132
00:07:28,466 --> 00:07:32,686
Let's say for the most part
you do use secure connections,


133
00:07:33,396 --> 00:07:37,346
but in some cases,
you have servers


134
00:07:37,346 --> 00:07:41,556
that just don't support
HTTPS or the best practices.


135
00:07:42,036 --> 00:07:44,306
So, for example, if
you have a media server


136
00:07:44,596 --> 00:07:46,856
that doesn't support
HTTPS and only HTTP,


137
00:07:46,856 --> 00:07:52,046
you can easily describe this
behavior using an exception.


138
00:07:53,276 --> 00:07:56,736
Essentially all you have to do
is declare which domain needs


139
00:07:56,736 --> 00:08:00,256
to load over HTTP and NSURL
Session will still allow


140
00:08:00,256 --> 00:08:01,586
that cleartext load.


141
00:08:04,336 --> 00:08:06,556
Now we also know that some


142
00:08:06,556 --> 00:08:09,116
of you may be supporting a
general purpose web browser


143
00:08:09,196 --> 00:08:13,006
or another app that loads URLs
based off dynamic user input,


144
00:08:13,006 --> 00:08:14,946
and we've allowed for that case.


145
00:08:15,396 --> 00:08:19,656
In this case here, you can't
possibly describe what secure


146
00:08:19,656 --> 00:08:22,876
connections you need ahead of
time, and so you can simply opt


147
00:08:22,876 --> 00:08:25,606
out by declaring an
allow-all policy.


148
00:08:26,746 --> 00:08:31,446
Now the allow-all policy can
be used to allow NSURL Session


149
00:08:31,446 --> 00:08:35,366
to load any HTTP
or HTTPS resource.


150
00:08:36,186 --> 00:08:40,076
Now, do note that this is
a useful tool for debugging


151
00:08:40,525 --> 00:08:42,236
that I believe is already
out on the Internet.


152
00:08:42,645 --> 00:08:46,486
So we ask, if you do
use it for debugging,


153
00:08:46,566 --> 00:08:48,826
to do it temporarily
for obvious reasons.


154
00:08:49,466 --> 00:08:52,836
Now, even if you
are in this state,


155
00:08:52,836 --> 00:08:56,476
you can still protect
specific servers and domains.


156
00:08:57,786 --> 00:08:59,676
So you are in this state where
you are allowing everything,


157
00:08:59,896 --> 00:09:01,466
but you have your
own servers, say,


158
00:09:01,466 --> 00:09:04,526
that you pull the configuration
data from or metadata from,


159
00:09:05,186 --> 00:09:08,636
and to do this, again, is
just an exception within ATS.


160
00:09:09,626 --> 00:09:13,166
You simply declare this domain
that you want to protect


161
00:09:13,166 --> 00:09:16,046
as an exception to
the allow-all policy.


162
00:09:16,646 --> 00:09:19,426
And this will allow
NSURL Session to continue


163
00:09:19,426 --> 00:09:23,016
to protect this resource
by only loading over HTTPS


164
00:09:23,746 --> 00:09:25,256
and with best practices.


165
00:09:26,546 --> 00:09:32,546
Now, the SDK has been
out since Monday,


166
00:09:33,226 --> 00:09:36,066
and there's probably
a few of you that woke


167
00:09:36,066 --> 00:09:39,526
up at this awful hour, just to
find out what ATS is all about


168
00:09:39,596 --> 00:09:41,416
and why your network
loads are failing.


169
00:09:42,296 --> 00:09:45,006
Well, we understand that and we
want to work together with you


170
00:09:45,336 --> 00:09:47,276
to get you up and running.


171
00:09:48,976 --> 00:09:52,706
So, do note that ATS is
only active if you build


172
00:09:52,706 --> 00:09:53,736
against a current SDK.


173
00:09:53,736 --> 00:09:56,616
If you are targeting
the previous release,


174
00:09:57,066 --> 00:10:00,716
ATS rules do not apply.


175
00:10:00,926 --> 00:10:06,756
NSURL Session will transfer all
HTTP resources or loads URLs


176
00:10:07,066 --> 00:10:08,926
to HTTPS automatically.


177
00:10:09,516 --> 00:10:14,826
And, again, as I said earlier,
some of you already know


178
00:10:14,826 --> 00:10:18,466
about the allow-all key, and we
ask you to use this temporarily


179
00:10:18,676 --> 00:10:22,346
to find out if the new network
failures in your app are


180
00:10:22,346 --> 00:10:24,096
because of ATS or not.


181
00:10:24,356 --> 00:10:28,346
And this will kind of help
you narrow things down.


182
00:10:28,546 --> 00:10:32,336
So the next step, if
you allow-all ATS loads,


183
00:10:32,606 --> 00:10:36,256
or allow-all loads,
and you've determined


184
00:10:36,256 --> 00:10:39,336
that the problem is ATS,
the next step would be


185
00:10:39,336 --> 00:10:42,396
to log the NSURL Session
errors that you are seeing,


186
00:10:42,706 --> 00:10:44,346
so you can try to
determine and narrow


187
00:10:44,346 --> 00:10:46,076
down which load is
actually failing,


188
00:10:46,076 --> 00:10:48,546
and what the underlying
error is.


189
00:10:50,496 --> 00:10:55,216
There is also a great debugging
tool that's an environment


190
00:10:55,216 --> 00:10:57,506
variable known as CF
Network Diagnostics.


191
00:10:58,706 --> 00:11:01,186
If you set CF Network
Diagnostics to level 1,


192
00:11:01,936 --> 00:11:04,036
all the failing URL loads --


193
00:11:04,166 --> 00:11:07,206
so, all the loads that
failed will log the URLs


194
00:11:07,576 --> 00:11:09,426
and the underlying TLS error.


195
00:11:10,276 --> 00:11:12,376
And so what you can do
in the next step is take


196
00:11:12,376 --> 00:11:16,406
that underlying TLS error, and
look up and secure transport.h,


197
00:11:16,906 --> 00:11:20,336
and see exactly what
the underlying issue is.


198
00:11:21,026 --> 00:11:24,036
Usually it's a failure in
negotiation between client


199
00:11:24,036 --> 00:11:26,156
and server at the TLS layer.


200
00:11:28,956 --> 00:11:34,196
So now, do understand
that this is a new API,


201
00:11:34,196 --> 00:11:35,946
and it's still under
development.


202
00:11:36,466 --> 00:11:38,826
So we strongly encourage
you guys to pay attention


203
00:11:38,826 --> 00:11:43,056
to the seed notes and
release notes, and also,


204
00:11:43,186 --> 00:11:46,576
please file radars so
we can track any issues


205
00:11:46,576 --> 00:11:48,326
that you guys are hitting


206
00:11:48,576 --> 00:11:55,146
and help you guys
get up and running.


207
00:11:55,766 --> 00:11:57,336
So I hope it's clear
that the time


208
00:11:57,336 --> 00:11:58,636
for secure networking is now.


209
00:11:59,356 --> 00:12:01,466
And we really want to
work with you in order


210
00:12:01,466 --> 00:12:03,056
to protect your customers' data.


211
00:12:04,396 --> 00:12:09,696
So, again, if you are writing
a new app, start with HTTPS


212
00:12:09,696 --> 00:12:12,306
and try to get your
servers up and running


213
00:12:12,926 --> 00:12:14,796
with the best practices.


214
00:12:15,366 --> 00:12:20,056
Now, for those of you
with existing apps,


215
00:12:20,186 --> 00:12:24,016
we ask that you first start by
moving what you can to HTTPS,


216
00:12:24,016 --> 00:12:26,946
and for the places where
you can't, go ahead


217
00:12:26,946 --> 00:12:29,036
and use the exceptions
that are available


218
00:12:29,336 --> 00:12:30,906
through your Info.plist.


219
00:12:32,296 --> 00:12:35,336
Now, do keep in mind that
your customers trust you


220
00:12:35,946 --> 00:12:39,856
with their data, and it is
truly sensitive in all cases.


221
00:12:40,326 --> 00:12:42,266
And so Apple wants to
work together with you


222
00:12:43,226 --> 00:12:45,886
to provide a more secure
environment for your customers.


223
00:12:46,416 --> 00:12:50,536
So, again, please give
us feedback via radar,


224
00:12:51,156 --> 00:12:54,006
come see us down at the lab
after this session and tomorrow.


225
00:12:54,556 --> 00:12:57,316
We really want to work with
you to protect our customers.


226
00:12:58,186 --> 00:13:01,336
Thank you all for being here and
I will be followed up by Andreas


227
00:13:01,336 --> 00:13:03,936
who will talk about new protocol
support and NSURL Session.


228
00:13:04,266 --> 00:13:05,276
Have a great conference.


229
00:13:06,516 --> 00:13:10,936
[Applause]


230
00:13:11,436 --> 00:13:12,246
>> ANDREAS GARKUSCHA:
Thanks, Luke.


231
00:13:12,866 --> 00:13:16,316
Good morning, everyone!


232
00:13:16,316 --> 00:13:18,576
My name is Andreas
and I'm going to talk


233
00:13:18,576 --> 00:13:21,186
about new protocol
support in NSURL Session.


234
00:13:23,376 --> 00:13:30,436
Yes, NSURL Session
supports HTTP/2 protocol.


235
00:13:31,916 --> 00:13:35,056
Your apps are ready to
communicate using HTTP/2


236
00:13:35,186 --> 00:13:37,296
and it's very easy to adopt.


237
00:13:37,666 --> 00:13:40,496
Let me play it one more time.


238
00:13:41,196 --> 00:13:41,826
All right!


239
00:13:42,836 --> 00:13:45,786
If you are already using
NSURL Session in your code,


240
00:13:46,146 --> 00:13:48,726
you are automatically
a part of all of that.


241
00:13:49,226 --> 00:13:51,416
Future of the web,
major milestone


242
00:13:51,416 --> 00:13:54,606
in the web's evolution, your
apps are running faster.


243
00:13:55,036 --> 00:13:56,986
You don't need to
change your source code.


244
00:13:57,076 --> 00:13:58,766
Everything works automatically.


245
00:14:00,346 --> 00:14:04,686
So today, we are going to
talk about three things.


246
00:14:05,616 --> 00:14:09,286
Why do we need a new protocol
and what are the common problems


247
00:14:09,766 --> 00:14:12,426
of the current HTTP/1.1
protocol?


248
00:14:12,496 --> 00:14:17,776
We will learn about the most
important HTTP/2 features.


249
00:14:18,696 --> 00:14:20,656
And finally, we will talk


250
00:14:20,656 --> 00:14:26,546
about HTTP/2 protocol
adoption in your apps.


251
00:14:27,656 --> 00:14:29,876
So, why another new protocol?


252
00:14:31,716 --> 00:14:34,746
We already have a
lot of protocols


253
00:14:35,076 --> 00:14:36,826
for every kind of communication.


254
00:14:37,686 --> 00:14:39,096
The reason is that most


255
00:14:39,096 --> 00:14:42,636
of the protocols were
designed many years ago


256
00:14:42,636 --> 00:14:44,236
for the needs of their time.


257
00:14:45,056 --> 00:14:49,916
Look at one of the
first Apple websites.


258
00:14:51,216 --> 00:14:54,186
Today's needs look
significantly different


259
00:14:54,506 --> 00:14:56,726
than those 15 years ago.


260
00:14:57,236 --> 00:14:58,776
So it is time for an update.


261
00:14:59,436 --> 00:15:03,316
HTTP has been around since
the beginning of the web,


262
00:15:03,866 --> 00:15:06,746
and it is not a secret
that it has many issues.


263
00:15:07,816 --> 00:15:11,026
The most famous HTTP
issue is the problem


264
00:15:11,026 --> 00:15:14,526
of only one outstanding
request per TCP connection.


265
00:15:16,546 --> 00:15:19,146
The solution for this
was HTTP pipelining,


266
00:15:19,826 --> 00:15:22,706
but HTTP pipelining
is not available


267
00:15:22,706 --> 00:15:24,136
on all servers or networks.


268
00:15:24,786 --> 00:15:29,326
In fact, it's disabled on most
popular desktop web browsers.


269
00:15:31,376 --> 00:15:34,866
Another solution was to open
multiple connections to a host.


270
00:15:35,806 --> 00:15:39,166
This could help to fetch
multiple resources faster,


271
00:15:39,596 --> 00:15:43,606
but together with other things
like textual protocol overhead,


272
00:15:44,456 --> 00:15:47,426
the lack of header
compression, it just adds


273
00:15:47,506 --> 00:15:51,296
up to higher system requirements
and lower performance


274
00:15:51,576 --> 00:15:58,216
on both the client
and the server.


275
00:15:58,386 --> 00:16:01,576
Last year, we introduced SPDY
Support in NSURL Session.


276
00:16:02,586 --> 00:16:04,876
SPDY was an attempt to
make the web faster.


277
00:16:05,456 --> 00:16:09,896
It was an experimental
protocol, however, it was chosen


278
00:16:10,326 --> 00:16:12,896
as a basis for a
new version of HTTP.


279
00:16:13,636 --> 00:16:18,086
The specification for the
new protocol version went


280
00:16:18,086 --> 00:16:20,686
through the IETF
standardization,


281
00:16:20,956 --> 00:16:24,566
and officially got an RFC
number assigned last month.


282
00:16:25,626 --> 00:16:30,476
So today, as you already know,
NSURL Session is extended


283
00:16:30,666 --> 00:16:33,646
to support HTTP/2 protocol.


284
00:16:34,336 --> 00:16:37,736
Let's take a look at
the key differences


285
00:16:37,736 --> 00:16:40,546
between HTTP/1.1 and HTTP/2.


286
00:16:41,856 --> 00:16:43,766
As opposed to HTTP/1.1,


287
00:16:44,166 --> 00:16:48,096
HTTP/2 opens only one
TCP connection to a host.


288
00:16:49,446 --> 00:16:52,756
It's network friendly and
requires less system resources


289
00:16:52,876 --> 00:16:57,016
on both the client
and the server.


290
00:16:57,836 --> 00:17:00,186
HTTP/2 is fully multiplexed.


291
00:17:00,976 --> 00:17:04,415
That means that a new
request does not need to wait


292
00:17:04,415 --> 00:17:06,915
until the server
sends the response


293
00:17:06,915 --> 00:17:08,066
for the previous request.


294
00:17:09,876 --> 00:17:12,826
HTTP/2 has request priorities,


295
00:17:13,396 --> 00:17:16,496
so that more important
resources can be delivered


296
00:17:16,915 --> 00:17:20,675
at a higher priority
to the client.


297
00:17:22,165 --> 00:17:28,386
Let's take a look at how HTTP/2
multiplexing resolves the


298
00:17:28,386 --> 00:17:30,696
Head-of-Line Blocking problem.


299
00:17:32,086 --> 00:17:35,406
We have three requests for
resources on a web server.


300
00:17:36,986 --> 00:17:40,856
We sent out the first
request and we get a response.


301
00:17:41,956 --> 00:17:45,076
Only after this, we can
send out the second request


302
00:17:46,016 --> 00:17:47,396
and get the second response.


303
00:17:48,016 --> 00:17:50,996
Same happens with
the third request.


304
00:17:51,386 --> 00:17:58,586
Now, with pipelining enabled, we
can send out all the requests,


305
00:17:59,206 --> 00:18:01,726
one after another,
without waiting


306
00:18:01,726 --> 00:18:03,516
for the previous
responses to arrive.


307
00:18:05,296 --> 00:18:09,636
But we still get the
responses in the same order.


308
00:18:10,716 --> 00:18:13,796
And you see that the first
response for the image in blue,


309
00:18:15,236 --> 00:18:17,096
blocks the following
two responses.


310
00:18:17,726 --> 00:18:23,626
With HTTP/2, we have
the same three requests,


311
00:18:24,426 --> 00:18:25,576
with different priorities.


312
00:18:27,016 --> 00:18:30,846
We still can send out all the
requests at the beginning,


313
00:18:32,236 --> 00:18:37,946
but we are receiving all the
responses at the same time.


314
00:18:38,166 --> 00:18:42,076
Moreover, the requests
with the higher priority,


315
00:18:43,486 --> 00:18:45,646
I get and deliver
faster to the client.


316
00:18:46,846 --> 00:18:52,846
You see that the second
response was a medium priority


317
00:18:52,846 --> 00:18:56,606
and the third response for
request was a high priority,


318
00:18:57,306 --> 00:19:01,346
arrived prior to the first
response even though they were


319
00:19:01,346 --> 00:19:02,206
scheduled later.


320
00:19:02,976 --> 00:19:06,266
The image does not block them
anymore and this is great.


321
00:19:06,606 --> 00:19:08,786
Great for your applications
and the performance.


322
00:19:10,606 --> 00:19:12,736
Let's continue with
the comparison.


323
00:19:13,376 --> 00:19:18,206
HTTP/2 is a binary protocol.


324
00:19:20,476 --> 00:19:24,916
That makes data processing
and parsing faster.


325
00:19:25,596 --> 00:19:30,006
HTTP/1.1 does not use
header compression.


326
00:19:30,656 --> 00:19:33,546
SPDY also could not
use header compression


327
00:19:33,686 --> 00:19:35,406
because of a security exploit.


328
00:19:36,266 --> 00:19:40,376
HTTP/2 uses HPACK, a
more secure mechanism


329
00:19:40,376 --> 00:19:41,386
for header compression.


330
00:19:42,566 --> 00:19:44,966
Let's talk about HPACK.


331
00:19:48,006 --> 00:19:50,516
HPACK header compression
is based on two tables,


332
00:19:51,326 --> 00:19:53,746
a static table and
a dynamic one.


333
00:19:55,336 --> 00:19:59,146
The static table contains
the most used HTTP headers


334
00:19:59,666 --> 00:20:00,766
and is unchangeable.


335
00:20:03,066 --> 00:20:06,776
The headers, which are not
included in the static table,


336
00:20:07,066 --> 00:20:08,876
can be added to the
dynamic table.


337
00:20:09,846 --> 00:20:13,516
The headers from the tables
can be referenced by index.


338
00:20:15,246 --> 00:20:19,476
As an example, you see a
simple HTTP/1.1 request.


339
00:20:20,936 --> 00:20:26,986
Highlighted is the data which is
going to be sent to the server.


340
00:20:26,986 --> 00:20:30,736
And here's HTTP/2 representation
of the same request.


341
00:20:30,736 --> 00:20:33,566
So let's encode this request.


342
00:20:35,396 --> 00:20:42,046
The pseudo headers,
method, scheme, and path,


343
00:20:43,386 --> 00:20:46,016
can be referenced
using the static table.


344
00:20:47,756 --> 00:20:51,196
The authority header is
included in the static table,


345
00:20:51,326 --> 00:20:52,626
but without its value.


346
00:20:53,696 --> 00:20:58,456
So to encode this request,
we need three bytes


347
00:20:58,876 --> 00:21:02,546
for the first three headers,
plus an additional byte,


348
00:21:03,356 --> 00:21:07,466
which tells that we want
to add the authority header


349
00:21:07,596 --> 00:21:10,446
to the dynamic table
and the value


350
00:21:10,446 --> 00:21:13,086
of the authority
with its length.


351
00:21:13,966 --> 00:21:18,706
And this is what
is going to be sent


352
00:21:19,026 --> 00:21:24,166
to the server plus additional
overhead for the header frame.


353
00:21:24,776 --> 00:21:28,056
Now with the second request,


354
00:21:28,056 --> 00:21:31,966
and you see that the
authority header goes


355
00:21:32,006 --> 00:21:32,946
in the dynamic table.


356
00:21:33,966 --> 00:21:35,196
So with the second request,


357
00:21:35,396 --> 00:21:41,346
HTTP/1.1 would send the same
headers over and over again.


358
00:21:43,586 --> 00:21:46,966
In HTTP/2 case, in
that particular case,


359
00:21:47,256 --> 00:21:51,306
we can reference all the
headers using the static


360
00:21:51,306 --> 00:21:53,226
and the dynamic table.


361
00:21:53,386 --> 00:21:55,586
We are using only one
byte for each header.


362
00:21:56,146 --> 00:21:57,926
It is a huge savings
of the bandwidth


363
00:21:58,276 --> 00:22:00,926
and it's remarkable how
few bytes are needed


364
00:22:01,356 --> 00:22:09,376
to encode a request or
response header in HTTP/2.


365
00:22:10,246 --> 00:22:11,966
So let's talk about
what you need


366
00:22:11,966 --> 00:22:14,636
to adopt HTTP/2 protocol
in your apps.


367
00:22:16,266 --> 00:22:18,786
There's not much work to do.


368
00:22:18,786 --> 00:22:22,256
HTTP/2 protocol is
seamlessly integrated


369
00:22:22,296 --> 00:22:23,836
into NSURL Session API.


370
00:22:25,356 --> 00:22:30,426
If you are already using NSURL
Session in your code, your apps


371
00:22:30,426 --> 00:22:34,536
and OS X programs will get this
functionality automatically.


372
00:22:35,746 --> 00:22:38,216
You will not need to
write any new code


373
00:22:38,416 --> 00:22:43,796
or provide any additional
configuration to turn it on.


374
00:22:44,406 --> 00:22:46,396
Let's take a look at
the source code example.


375
00:22:46,966 --> 00:22:49,126
This source code looks exactly


376
00:22:49,126 --> 00:22:51,646
like the code you guys
already have in your apps.


377
00:22:52,126 --> 00:22:55,956
You see, there's no difference,
no new configuration flags.


378
00:22:56,226 --> 00:22:57,856
It just works.


379
00:22:58,516 --> 00:23:05,546
[Chuckles]


380
00:23:06,046 --> 00:23:10,006
Yes, you only need
an HTTP/2 server.


381
00:23:11,776 --> 00:23:12,526
But it's okay.


382
00:23:13,516 --> 00:23:16,526
[Laughter]


383
00:23:17,026 --> 00:23:18,396
Your apps are ready


384
00:23:18,506 --> 00:23:22,126
to communicate using
HTTP/2 protocol.


385
00:23:22,576 --> 00:23:25,626
If you do not deploy
an HTTP/2 server yet,


386
00:23:26,686 --> 00:23:30,776
then your apps will
use HTTP/1.1 directly,


387
00:23:31,506 --> 00:23:35,096
or the best available protocol
will be selected automatically


388
00:23:35,096 --> 00:23:36,496
for the network communication.


389
00:23:37,276 --> 00:23:41,046
Once you start using a web
server which supports HTTP/2,


390
00:23:41,756 --> 00:23:43,916
there is no additional
work needed.


391
00:23:44,726 --> 00:23:50,926
Your apps will use HTTP/2
protocol automatically.


392
00:23:56,536 --> 00:24:01,216
Please keep in mind that NSURL
Session supports HTTP/2 protocol


393
00:24:01,446 --> 00:24:03,586
only over an encrypted
connection.


394
00:24:04,846 --> 00:24:10,596
And that your HTTP/2 server
requires to support ALPN or NPN


395
00:24:11,026 --> 00:24:12,286
for protocol negotiation.


396
00:24:16,716 --> 00:24:21,036
Currently at Apple, HomeKit
remote access via iCloud is


397
00:24:21,036 --> 00:24:23,826
using HTTP/2 protocol
for communication


398
00:24:23,826 --> 00:24:27,806
between HomeKit accessories
and iCloud.


399
00:24:29,026 --> 00:24:32,166
Many big companies are
already using HTTP/2 protocol.


400
00:24:32,666 --> 00:24:35,176
Google provides its
services in HTTP/2.


401
00:24:35,916 --> 00:24:38,236
Twitter is using HTTP/2 as well.


402
00:24:39,406 --> 00:24:43,456
There are many HTTP/2 open
source web servers out there,


403
00:24:44,326 --> 00:24:48,286
and finally, some CDN
service providers are working


404
00:24:48,516 --> 00:24:51,016
on the HTTP/2 protocol
support today.


405
00:24:54,736 --> 00:24:58,116
We worked hard to provide
HTTP/2 protocol support


406
00:24:58,116 --> 00:25:01,006
in NSURL Session so
that you guys can adopt


407
00:25:01,006 --> 00:25:03,276
and use it as easy as possible.


408
00:25:03,426 --> 00:25:07,676
HTTP/2 is available
today in WWDC seed.


409
00:25:08,216 --> 00:25:11,936
It's seamlessly integrated
into NSURL Session API


410
00:25:11,936 --> 00:25:17,826
and it's enabled in Safari,
on OS X, 10.11, and iOS 9.


411
00:25:19,566 --> 00:25:20,096
Thank you.


412
00:25:21,186 --> 00:25:23,816
And now I would like to
invite Dan up to the stage.


413
00:25:23,816 --> 00:25:23,976
Dan?


414
00:25:24,516 --> 00:25:31,126
[Applause]


415
00:25:31,626 --> 00:25:32,316
>> DAN VINEGRAD: Good
morning, everyone.


416
00:25:32,746 --> 00:25:33,756
My name is Dan.


417
00:25:33,756 --> 00:25:36,306
I'm a software engineer on
the CF Network team at Apple,


418
00:25:36,306 --> 00:25:37,786
and the first thing
I would like to talk


419
00:25:37,786 --> 00:25:40,656
about today is using
NSURL Session on watchOS.


420
00:25:42,266 --> 00:25:46,076
With the WatchKit SDK that was
released alongside watchOS 2


421
00:25:46,076 --> 00:25:48,496
in beta earlier this
week, I'm pleased to say


422
00:25:48,496 --> 00:25:51,506
that HTTPS loads are fully
supported on watchOS.


423
00:25:52,386 --> 00:25:54,326
And this means that
everything we've already talked


424
00:25:54,326 --> 00:25:57,766
about today, like App
Transport Security and HTTP/2,


425
00:25:57,766 --> 00:25:58,816
are built into this support.


426
00:26:00,666 --> 00:26:04,296
One major difference between
using NSURL Session on watchOS


427
00:26:04,296 --> 00:26:07,316
and using it on other platforms
is that underneath the hood,


428
00:26:07,316 --> 00:26:10,156
we actually will use the best
connectivity mechanism that's


429
00:26:10,156 --> 00:26:11,606
available to us at the time.


430
00:26:12,016 --> 00:26:14,026
And this means that
in most circumstances,


431
00:26:14,396 --> 00:26:17,766
if the users' watch is nearby
their paired iPhone device,


432
00:26:18,196 --> 00:26:20,656
then we will actually leverage
the Bluetooth connection


433
00:26:20,656 --> 00:26:24,496
between them, perform the HTTP
loads on the phone itself,


434
00:26:24,496 --> 00:26:27,196
and deliver the results back
to the watch over Bluetooth.


435
00:26:28,366 --> 00:26:31,026
If the user happens to be out
and away from their phone,


436
00:26:31,026 --> 00:26:33,116
but with their watch, and
the watch is connected


437
00:26:33,116 --> 00:26:35,706
to a known Wi-Fi network,
then we can actually use


438
00:26:35,706 --> 00:26:37,026
that Wi-Fi network directly.


439
00:26:38,316 --> 00:26:39,366
But the good news for you is


440
00:26:39,366 --> 00:26:42,356
that this is all abstracted
away from the API itself.


441
00:26:42,356 --> 00:26:45,066
You can use the API just as you
have been on other platforms.


442
00:26:45,066 --> 00:26:46,786
You don't need to worry
about how we are connecting.


443
00:26:47,056 --> 00:26:50,096
It just works like magic.


444
00:26:50,436 --> 00:26:53,256
So, with that said, there are
a few best practices and things


445
00:26:53,256 --> 00:26:55,976
to keep in mind when using
NSURL Session on watchOS.


446
00:26:56,706 --> 00:26:58,506
The first is that
you should really try


447
00:26:58,506 --> 00:27:00,726
to just download the
minimal size assets


448
00:27:00,726 --> 00:27:02,746
that are actually required
for your app to function.


449
00:27:03,376 --> 00:27:06,956
Keep in mind that the watch
has a very small screen.


450
00:27:07,166 --> 00:27:09,196
So if you are downloading
images you don't really need


451
00:27:09,196 --> 00:27:12,056
to download the full resolution
images that you would want


452
00:27:12,056 --> 00:27:15,346
to display on an iPhone 6 Plus
or a Mac with a retina display.


453
00:27:15,716 --> 00:27:18,276
The screen's a lot smaller; you
can download smaller images.


454
00:27:18,946 --> 00:27:23,276
And also keep in mind that the
watch has a lot less processing


455
00:27:23,276 --> 00:27:25,726
power than a phone or a Mac,


456
00:27:26,576 --> 00:27:29,136
and additionally will often
be limited by the bandwidth


457
00:27:29,136 --> 00:27:30,206
and latency constraints


458
00:27:30,206 --> 00:27:31,786
of the Bluetooth
connection to your phone.


459
00:27:32,006 --> 00:27:34,306
So we're not really going to be
able to get you bytes as quickly


460
00:27:34,306 --> 00:27:35,916
to the watch as we would
on other platforms.


461
00:27:35,916 --> 00:27:38,656
So keep that in mind as well.


462
00:27:38,846 --> 00:27:43,026
Another thing to note is that
apps on watch will generally run


463
00:27:43,026 --> 00:27:45,526
for a much shorter period
of time than iPhone apps


464
00:27:45,526 --> 00:27:46,796
or definitely Mac apps.


465
00:27:47,196 --> 00:27:49,266
You will mostly be limited
by how long the user wants


466
00:27:49,266 --> 00:27:51,436
to sit there standing with
his wrist raised staring


467
00:27:51,436 --> 00:27:52,956
at the watch and
interacting with it.


468
00:27:53,966 --> 00:27:57,046
So if you are using a
default session configuration


469
00:27:57,046 --> 00:27:59,656
or an ephemeral session
configuration, keep in mind


470
00:27:59,656 --> 00:28:03,646
that these networking transfers
will happen only while your app


471
00:28:03,646 --> 00:28:05,726
is actually running.


472
00:28:05,726 --> 00:28:08,136
So this is totally fine if
you are sending small amounts


473
00:28:08,136 --> 00:28:10,546
of data like fetching stock
quotes or weather data


474
00:28:10,936 --> 00:28:12,586
or social network
status updates,


475
00:28:13,106 --> 00:28:16,036
but for any larger content
like videos, for instance,


476
00:28:16,036 --> 00:28:18,156
you 'll want to use
background uploads or downloads,


477
00:28:18,156 --> 00:28:19,546
which can continue


478
00:28:19,546 --> 00:28:22,036
out of process while your
app is no longer running.


479
00:28:22,316 --> 00:28:23,806
And for more information
on background uploads


480
00:28:23,806 --> 00:28:25,536
and downloads, I highly
encourage you to check


481
00:28:25,536 --> 00:28:27,326
out the WWDC sessions


482
00:28:27,326 --> 00:28:29,316
on Foundation Networking
from previous years.


483
00:28:29,316 --> 00:28:35,836
Next up, I would like to
talk about some API changes


484
00:28:35,836 --> 00:28:37,476
that we have made in
this year's releases.


485
00:28:38,586 --> 00:28:40,966
The first thing I would like to
talk about is NSURL Connection,


486
00:28:40,966 --> 00:28:42,876
something we have not
talked about today so far.


487
00:28:43,466 --> 00:28:44,946
So, this year, I'm announcing


488
00:28:44,946 --> 00:28:47,626
that NSURL Connection
is deprecated on OS X,


489
00:28:47,626 --> 00:28:49,196
El Capitan, and iOS 9.


490
00:28:50,216 --> 00:28:52,596
And let's just take a moment
to think about what that means.


491
00:28:52,666 --> 00:28:54,126
Deprecation does not mean


492
00:28:54,126 --> 00:28:56,706
that NSURL Connection
is going away entirely.


493
00:28:56,756 --> 00:28:58,776
We know that there are
a lot of apps out there


494
00:28:58,776 --> 00:29:00,046
that are using NSURL Connection,


495
00:29:00,246 --> 00:29:01,546
and we're not just
going to break them.


496
00:29:01,956 --> 00:29:02,886
So it will still work.


497
00:29:02,886 --> 00:29:05,716
Those transfers will still
work, but keep in mind


498
00:29:05,716 --> 00:29:08,386
that new features are really
only going to be added


499
00:29:08,386 --> 00:29:09,866
to NSURL Session at this point.


500
00:29:09,866 --> 00:29:14,866
We highly encourage you to
switch over existing code


501
00:29:15,156 --> 00:29:18,146
from NSURL Connection to NSURL
Session if you haven't already,


502
00:29:19,406 --> 00:29:22,206
and if you are writing new
code, we would really hope


503
00:29:22,206 --> 00:29:24,356
that you would only use NSURL
Session and not Connection.


504
00:29:25,046 --> 00:29:26,846
Another thing to keep in mind is


505
00:29:26,846 --> 00:29:30,086
that NSURL Connection is not
supported at all on watchOS.


506
00:29:30,086 --> 00:29:31,996
So if you need to
load HTTP content


507
00:29:31,996 --> 00:29:34,706
from a WatchKit extension,
you have to use NSURL Session.


508
00:29:35,396 --> 00:29:37,556
But luckily for you, if you
haven't done so already,


509
00:29:37,556 --> 00:29:39,236
switching from NSURL Connection


510
00:29:39,236 --> 00:29:40,916
to NSURL Session is
actually very easy.


511
00:29:41,236 --> 00:29:44,596
So I would like to walk
through an example of that now.


512
00:29:44,596 --> 00:29:47,036
Here's a simple use
of NSURL Connection


513
00:29:47,096 --> 00:29:49,246
to perform an asynchronous
HTTP request,


514
00:29:49,246 --> 00:29:51,326
which probably looks similar
to the things that a lot


515
00:29:51,326 --> 00:29:53,346
of you have in your apps.


516
00:29:53,346 --> 00:29:57,926
Here, we're connecting to
www.example.com over HTTPS,


517
00:29:57,976 --> 00:30:00,356
and we have an NSURL
object to represent that.


518
00:30:01,166 --> 00:30:04,806
We then construct an
NSURLRequest, wrapping that URL,


519
00:30:05,686 --> 00:30:08,766
and we use NSURL Connection's
'send asynchronous request'


520
00:30:08,766 --> 00:30:11,966
method to fire off that
request asynchronously.


521
00:30:12,536 --> 00:30:16,886
And we receive the result
in the form of this closure,


522
00:30:16,886 --> 00:30:20,316
which includes an NSURL Response
object representing the HTTP


523
00:30:20,466 --> 00:30:23,636
response headers that are
received, an NSData object


524
00:30:23,636 --> 00:30:26,366
for the response body
data, and an error


525
00:30:26,766 --> 00:30:28,196
if a transmission
error occurred.


526
00:30:29,246 --> 00:30:30,916
So let's take a look
at what that would look


527
00:30:30,916 --> 00:30:32,236
like with NSURL Session.


528
00:30:33,316 --> 00:30:34,556
It's very similar.


529
00:30:34,726 --> 00:30:36,846
You will notice that the NSURL


530
00:30:36,846 --> 00:30:39,736
and NSURL request objects are
still in use and this is true


531
00:30:39,736 --> 00:30:42,756
for a lot of the other
NSURL family of objects,


532
00:30:42,756 --> 00:30:46,136
like NSURL Credential Storage
and NSHTTP Cookie Storage.


533
00:30:46,866 --> 00:30:48,596
The main difference
here is that instead


534
00:30:48,596 --> 00:30:49,946
of using NSURL Connection


535
00:30:49,946 --> 00:30:51,876
to send an asynchronous
request method,


536
00:30:52,236 --> 00:30:55,326
we are using the 'data
task with request' method


537
00:30:55,546 --> 00:30:58,396
on the NSURL Session
shared session.


538
00:30:58,396 --> 00:31:02,866
Then once we resume the task, we
would again receive the results


539
00:31:02,866 --> 00:31:05,056
of that transaction,
asynchronously,


540
00:31:05,056 --> 00:31:08,626
in the form of the response
data, the response headers,


541
00:31:08,626 --> 00:31:11,166
and an error if a
transmission error occurred.


542
00:31:11,846 --> 00:31:15,796
So that's how easy it is to
switch from NSURL Connection


543
00:31:15,796 --> 00:31:17,786
into NSURL Session in your apps.


544
00:31:18,976 --> 00:31:20,796
So, next I would like
to switch gears and talk


545
00:31:20,796 --> 00:31:22,356
about some new additions
that we've added


546
00:31:22,356 --> 00:31:24,936
to the NSURL Session
family of APIs this year.


547
00:31:25,856 --> 00:31:29,026
The first thing I would like to
talk about deals with cookies.


548
00:31:29,926 --> 00:31:34,136
Last year at WWDC we introduced
a great new feature called app


549
00:31:34,136 --> 00:31:36,596
extensions, which
lets you embed parts


550
00:31:36,596 --> 00:31:38,636
of your app's functionality
other places on the system


551
00:31:38,636 --> 00:31:39,846
like notification center.


552
00:31:40,886 --> 00:31:45,966
But applications and their
extensions have different data


553
00:31:45,966 --> 00:31:48,076
containers by default,
which means that even


554
00:31:48,076 --> 00:31:49,466
if you are using NSURL Session


555
00:31:49,466 --> 00:31:52,766
and already leveraging our
great built-in cookie handling


556
00:31:52,766 --> 00:31:54,996
support, those cookies
are actually being stored


557
00:31:54,996 --> 00:31:55,856
in different places.


558
00:31:56,386 --> 00:32:00,076
But you can use what's
called an application group


559
00:32:00,256 --> 00:32:03,106
to actually get access to
a shared data container,


560
00:32:03,106 --> 00:32:05,496
which both your app and
its extensions can access.


561
00:32:06,066 --> 00:32:08,016
And this year we have
introduced new API


562
00:32:08,016 --> 00:32:10,686
to let you create a
cookie storage associated


563
00:32:10,686 --> 00:32:11,646
with that group container.


564
00:32:11,646 --> 00:32:14,186
And I would like to
show you how to do that.


565
00:32:14,586 --> 00:32:19,176
So what you want to use here
is NSHTTP cookie storage's new


566
00:32:19,176 --> 00:32:21,996
'shared cookie storage for group
container identifier' method.


567
00:32:22,586 --> 00:32:26,456
And you just simply create a
cookie storage with the passing


568
00:32:26,456 --> 00:32:28,226
in the name of your
application group,


569
00:32:28,226 --> 00:32:31,316
and application groups can be
configured while editing your


570
00:32:31,316 --> 00:32:33,096
project's build settings
in Xcode and going


571
00:32:33,096 --> 00:32:34,186
to the Capabilities tab.


572
00:32:35,616 --> 00:32:39,076
Once you've created the cookie
storage, you just need to set it


573
00:32:39,076 --> 00:32:40,816
as the HTTP cookie
storage property


574
00:32:41,036 --> 00:32:43,326
on an NSURL Session
configuration object,


575
00:32:43,976 --> 00:32:46,496
create an NSURL Session
from that configuration,


576
00:32:46,536 --> 00:32:49,906
and then any tasks that you
create in that session will use


577
00:32:50,056 --> 00:32:55,396
that cookie storage in
the group container.


578
00:32:56,486 --> 00:32:58,596
So for the entirety of
the presentations today,


579
00:32:58,596 --> 00:33:01,776
we have been talking about using
NSURL Session in the context


580
00:33:01,776 --> 00:33:03,186
of loading HTTP content.


581
00:33:04,206 --> 00:33:06,106
But there are some cases


582
00:33:06,106 --> 00:33:10,026
where you really need a protocol
other than HTTP or HTTPS.


583
00:33:10,546 --> 00:33:13,596
So if you are implementing
a chat application,


584
00:33:13,976 --> 00:33:20,426
a video calling app, or
-- or something like that,


585
00:33:20,426 --> 00:33:23,146
you really need -- you might
need a protocol that's not HTTP,


586
00:33:23,146 --> 00:33:25,856
and you want to do
something custom directly


587
00:33:25,856 --> 00:33:28,246
on top of TCP/IP networking.


588
00:33:28,766 --> 00:33:32,056
So NSURL Session Stream
Task is a new API this year,


589
00:33:32,056 --> 00:33:33,706
which is a Foundation
extraction,


590
00:33:33,866 --> 00:33:35,446
directly over a TCP connection.


591
00:33:36,556 --> 00:33:39,686
Now, in the past, you might
have used NSInput Stream


592
00:33:39,686 --> 00:33:43,366
and NSOutput Stream to do
something similar, but we think


593
00:33:43,366 --> 00:33:46,396
that NSUSRLSession Stream
Task has a few key advantages


594
00:33:46,396 --> 00:33:48,076
over the NSStream APIs.


595
00:33:48,676 --> 00:33:50,656
First of all, it
offers a very simple,


596
00:33:50,656 --> 00:33:53,026
convenient asynchronous
read and write interface,


597
00:33:53,776 --> 00:33:56,976
whereas with NSStream you had
to set up a delegate to listen


598
00:33:56,976 --> 00:33:59,656
for events or when to read, and
the read and writes could block,


599
00:33:59,656 --> 00:34:00,576
and it was kind of a mess.


600
00:34:00,946 --> 00:34:02,506
But this is a lot
easier and cleaner.


601
00:34:03,686 --> 00:34:07,126
Secondly, NSURL Session
has great built-in support


602
00:34:07,126 --> 00:34:09,456
for automatically getting
through HTTP proxies,


603
00:34:09,835 --> 00:34:12,426
and NSURL Session Stream Task
can leverage this support


604
00:34:12,426 --> 00:34:15,226
so that you can connect
to a remote server even


605
00:34:15,226 --> 00:34:17,045
if there's an HTTP
proxy between it,


606
00:34:17,045 --> 00:34:18,516
and NSStream can't
really do this.


607
00:34:18,996 --> 00:34:21,426
And there are a few
other new API goodies


608
00:34:21,426 --> 00:34:23,045
that I will talk
about later as well.


609
00:34:24,536 --> 00:34:26,896
We also know that NSStream
is a very pervasive API.


610
00:34:26,896 --> 00:34:30,696
There are a lot of other
frameworks and APIs that accept


611
00:34:30,696 --> 00:34:32,315
and work with NSStream objects.


612
00:34:32,806 --> 00:34:35,806
So we also have some support
to be compatible with NSStreams


613
00:34:35,806 --> 00:34:37,416
as well and I will
show you that later on.


614
00:34:38,775 --> 00:34:42,835
So as I said, NSURL Session
Stream Task supports TCP/IP


615
00:34:42,835 --> 00:34:45,896
connections, which you
can create explicitly


616
00:34:45,896 --> 00:34:47,005
with a host name and port,


617
00:34:47,335 --> 00:34:50,936
or if you are using
the NSNetService's APIs


618
00:34:50,936 --> 00:34:53,766
to discover Bonjour
services in your app,


619
00:34:53,766 --> 00:34:56,016
then we can actually accept
that NSNetService and resolve


620
00:34:56,016 --> 00:34:57,096
that for you automatically.


621
00:34:58,636 --> 00:35:02,496
Stream Task uses the existing
NSURL Session configuration


622
00:35:02,496 --> 00:35:07,376
options and delegate methods to
communicate events to you, and,


623
00:35:07,376 --> 00:35:10,406
of course, we support
TLS-secured connections


624
00:35:10,406 --> 00:35:12,916
and you can even dynamically
change this once you've actually


625
00:35:12,916 --> 00:35:14,226
established a connection
to a server.


626
00:35:14,226 --> 00:35:19,366
So let's take a look at how you
would perform a read operation


627
00:35:19,366 --> 00:35:21,086
with a Stream Task.


628
00:35:21,086 --> 00:35:23,606
First, to create a Stream Task
you can simply use the 'Stream


629
00:35:23,606 --> 00:35:26,496
Task with Host Name
and Port' method.


630
00:35:26,626 --> 00:35:28,386
And you just pass in
the host name and port


631
00:35:28,386 --> 00:35:29,366
that you want to connect to.


632
00:35:29,366 --> 00:35:32,816
And then after resuming
the task,


633
00:35:32,816 --> 00:35:34,836
you can use this 'Read
Data of Min Length,


634
00:35:34,836 --> 00:35:36,326
Max Length, Timeout' method.


635
00:35:37,136 --> 00:35:40,406
And what this will do is you
can pass in a range of bytes


636
00:35:40,406 --> 00:35:42,946
that you want to read and a
timeout for that operation.


637
00:35:43,336 --> 00:35:45,716
So if we managed to read
something within that range


638
00:35:45,716 --> 00:35:49,176
or we hit an EOF, or there's a
transmission error or timeout


639
00:35:49,176 --> 00:35:52,056
that occurs, we will invoke
this closure with the results.


640
00:35:53,266 --> 00:35:55,576
Writing is very similar.


641
00:35:55,576 --> 00:35:58,976
We -- unlike -- with NSStream we
can work directly with NSData,


642
00:35:58,976 --> 00:36:01,206
you just pass in the NSData
object that you want us to write


643
00:36:01,206 --> 00:36:03,256
and a timeout for that
operation, and, again,


644
00:36:03,526 --> 00:36:05,726
this closure will be
invoked with a nil error


645
00:36:05,726 --> 00:36:08,646
if that occurred successfully
or an error if a timeout


646
00:36:08,646 --> 00:36:11,186
or a transmission
error occurred.


647
00:36:11,366 --> 00:36:12,976
Enabling TLS is as simple


648
00:36:12,976 --> 00:36:18,946
as calling the 'Start Secure
Connection' method on the task.


649
00:36:19,126 --> 00:36:21,816
I mentioned before that we
also have some built-in support


650
00:36:21,816 --> 00:36:25,136
to work with NSStream,
NSURL Session Stream Task.


651
00:36:25,596 --> 00:36:27,476
So the reason we do
this is because we know


652
00:36:27,476 --> 00:36:29,386
that there are a lot of
APIs out there that work


653
00:36:29,386 --> 00:36:31,086
with NSStream objects
already and we want


654
00:36:31,086 --> 00:36:33,596
to give you something that can
still be compatible with those.


655
00:36:34,016 --> 00:36:37,366
So, you can actually convert
an NSURLSession Stream Task


656
00:36:37,366 --> 00:36:39,566
to NSStreams, and I will show
you the very simple code to do


657
00:36:39,566 --> 00:36:40,826
that on the next slide.


658
00:36:41,326 --> 00:36:45,136
Just keep in mind that when you
do this, any pending async reads


659
00:36:45,136 --> 00:36:46,606
or writes that you have enqueued


660
00:36:46,606 --> 00:36:49,166
on the Stream Task will
complete before we give you


661
00:36:49,166 --> 00:36:49,816
the NSStreams.


662
00:36:50,556 --> 00:36:52,776
And that doing this
also detaches the task


663
00:36:52,996 --> 00:36:53,646
from the session.


664
00:36:53,646 --> 00:36:55,096
And so its connection,


665
00:36:55,306 --> 00:36:58,626
its underlying connection will
no longer count against a limit


666
00:36:58,626 --> 00:37:00,986
that you may have set on
the session's maximum number


667
00:37:00,986 --> 00:37:04,166
of connections per host,
and it will no longer be


668
00:37:04,166 --> 00:37:07,726
in the session's set
of outstanding tasks.


669
00:37:08,736 --> 00:37:10,706
So to convert a Stream
Task to Streams,


670
00:37:10,706 --> 00:37:13,506
you simply call the 'Capture
Streams' method on the Task,


671
00:37:14,176 --> 00:37:17,586
and then those input streams and
output streams will be delivered


672
00:37:17,586 --> 00:37:19,886
to your delegate with
a new delegate message.


673
00:37:21,116 --> 00:37:24,756
We also have a few other
informational delegate messages


674
00:37:24,756 --> 00:37:26,796
that we have introduced
on Stream Task.


675
00:37:26,856 --> 00:37:27,966
The first is interesting.


676
00:37:27,966 --> 00:37:30,506
It's a better route
discovered for Stream Task.


677
00:37:31,106 --> 00:37:33,376
So let's say, you have a
Stream Task that's connected


678
00:37:33,376 --> 00:37:36,016
to your server over a
cellular data connection.


679
00:37:36,456 --> 00:37:39,256
If the user then
joins a Wi-Fi network,


680
00:37:39,416 --> 00:37:41,256
then we would deliver this
notification to your app


681
00:37:41,256 --> 00:37:43,176
to tell you that there might
be a better way to connect.


682
00:37:43,826 --> 00:37:47,326
And what you might want to do in
this situation, if you want to,


683
00:37:47,326 --> 00:37:50,236
is tear down your existing
Stream Task and create a new one


684
00:37:50,626 --> 00:37:55,206
to that host and port,
and try to connect


685
00:37:55,206 --> 00:37:56,616
over the better connection.


686
00:37:56,866 --> 00:37:58,486
And we leave it up to
you to decide whether


687
00:37:58,486 --> 00:37:59,616
or not you want to do this.


688
00:37:59,706 --> 00:38:03,026
You know, if you are 99% of the
way through transferring a lot


689
00:38:03,026 --> 00:38:04,956
of data it might not make
sense to actually tear


690
00:38:04,956 --> 00:38:07,046
down the existing connection
and create a new one.


691
00:38:07,426 --> 00:38:10,186
And we also have some
informational delegate methods


692
00:38:10,186 --> 00:38:11,816
to tell you when to
read or write sides


693
00:38:11,816 --> 00:38:13,856
of the underlying TCP
connections have been closed.


694
00:38:16,756 --> 00:38:19,736
I also talked before about our
automatic support for dealing


695
00:38:19,736 --> 00:38:21,476
with HTTP proxies
in Stream Task.


696
00:38:21,856 --> 00:38:24,596
And the way you can do deal with
this is actually by starting


697
00:38:24,596 --> 00:38:27,766
with an existing NSURL Session
Data Task, which generally deals


698
00:38:27,766 --> 00:38:30,706
with HTTP content, and
converting it to a Stream Task.


699
00:38:31,626 --> 00:38:33,636
And this you can do
when the response


700
00:38:33,636 --> 00:38:35,026
for that Data Task is received.


701
00:38:36,206 --> 00:38:38,526
So to convert a Data
Task to a Stream Task,


702
00:38:38,526 --> 00:38:40,986
and let you communicate
directly over the TCP connection


703
00:38:40,986 --> 00:38:44,696
without the HTTP framing,
you would simply respond


704
00:38:44,696 --> 00:38:46,116
to this completion handler


705
00:38:46,116 --> 00:38:48,156
in the 'Did Receive
Response' delegate method


706
00:38:48,156 --> 00:38:50,256
with the new 'Become
Stream' disposition.


707
00:38:50,916 --> 00:38:52,566
And then we will
inform your delegate


708
00:38:52,566 --> 00:38:55,826
that the Data Task has been
converted to a Stream Task


709
00:38:55,826 --> 00:38:59,206
with the 'URL Session Data Task
Did Become Stream Task' method.


710
00:39:02,016 --> 00:39:04,156
Before we finish up today,
I would just like to go


711
00:39:04,156 --> 00:39:06,456
over a few things that we
discussed this morning.


712
00:39:07,006 --> 00:39:11,026
We first talked about how you
can use App Transport Security


713
00:39:11,316 --> 00:39:14,036
to guarantee that only
secure connections are made


714
00:39:14,036 --> 00:39:16,696
from your app and how you
can declare exceptions


715
00:39:16,696 --> 00:39:17,676
to those as needed.


716
00:39:18,056 --> 00:39:20,136
We then talked about how you
can make your apps faster


717
00:39:20,136 --> 00:39:22,016
by supporting HTTP/2
on your servers,


718
00:39:22,256 --> 00:39:25,606
which requires no additional
changes on the client.


719
00:39:26,446 --> 00:39:29,276
We talked about best practices
for using NSURL Session


720
00:39:29,276 --> 00:39:33,946
on watch apps, and went over the
new API changes this release,


721
00:39:34,006 --> 00:39:36,506
the deprecation of NSURL
Connection and how to migrate


722
00:39:36,506 --> 00:39:40,266
to Session, how to share cookies
between apps and extensions,


723
00:39:40,666 --> 00:39:44,156
and how to get a great
foundation level abstraction


724
00:39:44,156 --> 00:39:47,246
if you need to communicate
using a TCP connection


725
00:39:47,296 --> 00:39:49,126
without HTTP to your servers.


726
00:39:49,636 --> 00:39:55,586
As always, I would like to
refer you to the documentation


727
00:39:55,586 --> 00:39:58,136
that we have available on
our website, and remind you


728
00:39:58,236 --> 00:40:00,786
about the developer forums
that you can participate in,


729
00:40:00,786 --> 00:40:03,246
and any questions that you
might have while you are here


730
00:40:03,246 --> 00:40:05,816
at WWDC this week, Paul
Danbold is our Evangelist


731
00:40:05,816 --> 00:40:06,706
and you can talk to him.


732
00:40:06,706 --> 00:40:10,106
There are a few other
related sessions


733
00:40:10,106 --> 00:40:10,976
that you might want to attend.


734
00:40:10,976 --> 00:40:13,296
I highly encourage you
to attend "Your App


735
00:40:13,296 --> 00:40:15,226
and Next Generation
Networks," tomorrow,


736
00:40:15,226 --> 00:40:17,576
which will be a lower level
discussion of networking.


737
00:40:18,116 --> 00:40:21,336
And the networking labs
occur this week as well


738
00:40:21,336 --> 00:40:23,346
and you can talk to us directly
for any questions you have.


739
00:40:23,836 --> 00:40:25,546
With that, I would like to
thank you for coming out today,


740
00:40:25,976 --> 00:40:29,236
and we look forward to seeing
the amazing apps that you create


741
00:40:29,356 --> 00:40:31,766
with iOS 9, OS X, El
Capitan, and watchOS 2.


742
00:40:31,766 --> 00:40:31,976
Thanks.


743
00:40:32,516 --> 00:40:35,500
[Applause]

