1
00:00:13,176 --> 00:00:15,276
>> Welcome to Power,
Performance and Diagnostics:


2
00:00:15,776 --> 00:00:17,076
What's new in GCD and XPC.


3
00:00:17,886 --> 00:00:20,626
I'm Daniel Steffen, I'm one
of the Engineers responsible


4
00:00:20,626 --> 00:00:22,806
for GCD and XPC in Core OS,


5
00:00:23,736 --> 00:00:26,476
and today we'll go
over some background.


6
00:00:27,306 --> 00:00:30,756
Some -- a new concept called
Quality of Service Classes


7
00:00:30,756 --> 00:00:33,766
that we're introducing this
year, the new APIs associated


8
00:00:33,766 --> 00:00:38,366
to that, and the concept of
propagation of this quality


9
00:00:38,366 --> 00:00:42,856
of service and execution context
across threads and processes,


10
00:00:43,276 --> 00:00:46,496
and finally, some pointers
to great new features


11
00:00:46,596 --> 00:00:49,266
around diagnostics and
queue debugging this year.


12
00:00:49,826 --> 00:00:53,606
So GCD, for those
who might be new


13
00:00:53,846 --> 00:00:56,366
to the topic even though
given the number of people,


14
00:00:56,366 --> 00:01:00,026
maybe everybody knows
about it [laughter],


15
00:01:00,026 --> 00:01:03,196
GCD is a low-level frame maker
on asynchronous execution,


16
00:01:03,536 --> 00:01:05,776
concurrent execution,
and synchronization.


17
00:01:06,956 --> 00:01:08,996
Today, we are mostly
going to be focusing


18
00:01:08,996 --> 00:01:13,996
on the asynchronous execution
aspect of it, and you can think


19
00:01:14,866 --> 00:01:19,066
of asynchronous execution
with GCD as a way to run code


20
00:01:19,066 --> 00:01:21,866
in a separate environment
in your process.


21
00:01:22,256 --> 00:01:24,356
The reasons you might
want to do that are things


22
00:01:24,356 --> 00:01:26,626
like avoid interfering
with the current thread,


23
00:01:26,756 --> 00:01:29,186
a typical example would be the
main thread of your application,


24
00:01:29,776 --> 00:01:31,666
or execute at a different
priority level,


25
00:01:31,846 --> 00:01:34,986
which is something we'll talk a
lot more about in this session,


26
00:01:35,196 --> 00:01:38,526
or coordination between
multiple clients in the process.


27
00:01:39,096 --> 00:01:43,296
This leads us to XPC, which
is our low level IPC framework


28
00:01:43,486 --> 00:01:46,396
on the system, and that
can be thought of as a way


29
00:01:46,396 --> 00:01:49,156
to asynchronously execute
code in a separate process,


30
00:01:49,256 --> 00:01:51,876
for which you might do
for very similar reasons:


31
00:01:51,876 --> 00:01:54,946
avoid interfering with the
current process as a whole,


32
00:01:55,266 --> 00:01:57,016
say if you're running
on un-trusted data


33
00:01:57,366 --> 00:02:00,466
that you might not want to
crash the main application


34
00:02:00,466 --> 00:02:03,706
for if it goes wrong,
or you might need to run


35
00:02:03,706 --> 00:02:06,176
at a different privilege level
say in a different sandbox,


36
00:02:06,506 --> 00:02:09,066
and maybe you need to
coordinate with multiple clients


37
00:02:09,066 --> 00:02:11,106
if you're writing
a Daemon on OS X.


38
00:02:11,586 --> 00:02:15,096
And that's really all I'm
going to go over in terms


39
00:02:15,096 --> 00:02:18,226
of background for
these two topics.


40
00:02:18,226 --> 00:02:20,936
This is sort of a "what's new
session" this year, so I --


41
00:02:20,936 --> 00:02:24,206
here are a number of sessions
from past years if you're new


42
00:02:24,206 --> 00:02:26,116
to this technology
or to the platforms.


43
00:02:26,696 --> 00:02:29,046
That will get you up to speed,
you should be able to see all


44
00:02:29,046 --> 00:02:32,306
of those in your WWDC app
or on the developer website.


45
00:02:32,616 --> 00:02:37,056
So let's take a step
back and think


46
00:02:37,056 --> 00:02:40,516
about what our goal should
be as application developers.


47
00:02:41,376 --> 00:02:43,526
We'll see one of
the primary goals is


48
00:02:43,556 --> 00:02:45,596
to provide the best
user experience


49
00:02:45,596 --> 00:02:47,556
for the person using the device.


50
00:02:48,086 --> 00:02:49,356
What do they care about?


51
00:02:50,776 --> 00:02:54,116
The frontmost app and its
user interface, that that be


52
00:02:54,116 --> 00:02:55,426
as responsive as possible.


53
00:02:56,016 --> 00:02:58,266
What do you need to
provide on the system


54
00:02:59,586 --> 00:03:02,966
as application developers
to make this possible?


55
00:03:02,966 --> 00:03:04,586
This responsive user
interface well,


56
00:03:04,956 --> 00:03:07,146
there must be enough
resources available


57
00:03:07,496 --> 00:03:09,376
so that the main thread
of the frontmost app,


58
00:03:09,716 --> 00:03:13,166
which is where all the UI event
handling and UI drawing occurs,


59
00:03:13,616 --> 00:03:16,966
can proceed unimpeded, as well


60
00:03:16,966 --> 00:03:19,356
as all the associated
infrastructure that is involved


61
00:03:19,356 --> 00:03:21,856
in pushing pixels to the
screen or getting events


62
00:03:22,166 --> 00:03:24,946
from the input devices.


63
00:03:26,616 --> 00:03:28,746
Other work that is
not directly related


64
00:03:28,746 --> 00:03:30,756
to this task should
execute off the main thread


65
00:03:30,756 --> 00:03:33,676
of the application independently
off the main thread,


66
00:03:33,676 --> 00:03:35,366
and ideally at lower-priority.


67
00:03:36,636 --> 00:03:37,956
Let's talk about priorities.


68
00:03:39,946 --> 00:03:42,976
Very generically
priorities are a mechanism


69
00:03:43,036 --> 00:03:46,376
to resolve resource
contention on the system.


70
00:03:47,256 --> 00:03:49,166
The idea is that
under contention,


71
00:03:49,166 --> 00:03:51,986
the high priorities win, but
if there's no contention,


72
00:03:52,716 --> 00:03:55,216
the low priorities aren't
really a restriction they will


73
00:03:55,286 --> 00:03:56,846
proceed normally.


74
00:03:57,556 --> 00:04:00,076
So an example of that that
you are probably familiar


75
00:04:00,076 --> 00:04:01,206
with is scheduling priority.


76
00:04:01,846 --> 00:04:04,326
This is something you
can set on your threads


77
00:04:04,326 --> 00:04:08,016
that tells the Kernel scheduler
how you would like access


78
00:04:08,016 --> 00:04:12,046
to the CPU prioritized, and the
idea is that under contention,


79
00:04:12,046 --> 00:04:14,096
high priorities get
to the CPU first.


80
00:04:14,586 --> 00:04:17,666
But even if you set low-priority
there's no restriction


81
00:04:17,755 --> 00:04:19,646
to your execution if
they're no contention,


82
00:04:20,076 --> 00:04:21,736
but then if something
high-priority comes along


83
00:04:21,736 --> 00:04:25,546
like a UI action, then you might
not run for a period of time


84
00:04:25,546 --> 00:04:26,456
if you're at low-priority.


85
00:04:27,536 --> 00:04:30,586
Similar concept for I/O that
we've had for a long time


86
00:04:30,586 --> 00:04:33,096
that you might be familiar with
on the GDC background queue,


87
00:04:33,476 --> 00:04:35,886
the I/O that you perform
on that queue are tagged


88
00:04:35,886 --> 00:04:36,796
as low-priority.


89
00:04:37,316 --> 00:04:38,516
Again, this is no restriction


90
00:04:38,516 --> 00:04:40,296
if there's no high-priority
I/O present,


91
00:04:40,386 --> 00:04:42,296
it will just proceed
normally in that case.


92
00:04:42,766 --> 00:04:44,606
But if there is say,
the main thread


93
00:04:44,606 --> 00:04:47,156
of an application loading an
image for display in the UI,


94
00:04:47,596 --> 00:04:50,606
if such high-priority
I/O is present,


95
00:04:50,856 --> 00:04:54,026
the low-priority I/O
will be deprioritized.


96
00:04:56,736 --> 00:04:59,866
But it turns out that our system
actually has many other resource


97
00:04:59,866 --> 00:05:02,366
controls of this type,
and to configure all


98
00:05:02,366 --> 00:05:03,916
of this correctly
is very complex


99
00:05:03,976 --> 00:05:05,996
and a lot of knobs involved.


100
00:05:06,476 --> 00:05:08,256
There isn't really any
unified approach for you


101
00:05:08,256 --> 00:05:11,476
to know what settings
that should be used in all


102
00:05:11,476 --> 00:05:13,616
of these cases, and
no good way for you


103
00:05:13,616 --> 00:05:17,046
to tell the system your
intent behind setting specific


104
00:05:17,046 --> 00:05:19,746
configuration values, and
this is what we wanted


105
00:05:19,746 --> 00:05:22,236
to address this year
with the introduction


106
00:05:22,236 --> 00:05:23,996
of Quality of Service Classes.


107
00:05:23,996 --> 00:05:30,276
Quality of Service Classes are
a new concept whose goal is


108
00:05:30,546 --> 00:05:33,396
to allow you the developer to
communicate intent to the system


109
00:05:33,766 --> 00:05:36,116
by giving an explicit
classification of work


110
00:05:36,326 --> 00:05:37,726
that your application performs


111
00:05:38,076 --> 00:05:41,056
with a single abstract
parameter, and move away


112
00:05:41,056 --> 00:05:42,786
from this situation of having


113
00:05:42,786 --> 00:05:45,256
to dictate very specific
configuration values


114
00:05:45,256 --> 00:05:47,406
for all the possible things
that you could configure.


115
00:05:48,656 --> 00:05:52,336
Among the effects of
setting Quality of Service,


116
00:05:52,506 --> 00:05:54,636
the two we talked about,
CPU scheduling priority


117
00:05:54,636 --> 00:05:57,526
and I/O priority, but
also configuration


118
00:05:57,526 --> 00:06:00,336
of timer coalescing
and hints to the CPU


119
00:06:00,536 --> 00:06:02,456
that it should prefer throughput


120
00:06:02,456 --> 00:06:05,206
versus more energy
efficient modes of execution,


121
00:06:05,726 --> 00:06:10,166
and potentially more parameters
today or in the future


122
00:06:10,166 --> 00:06:11,156
that you don't need to know


123
00:06:11,156 --> 00:06:14,186
about as an application
developer or can't even know


124
00:06:14,186 --> 00:06:15,566
about yet because
they don't exist yet.


125
00:06:15,566 --> 00:06:19,476
In particular, we might be
tuning these configuration


126
00:06:19,476 --> 00:06:21,246
values that are actually
used underneath the colors


127
00:06:21,246 --> 00:06:23,776
differently for different
platforms of different devices,


128
00:06:24,206 --> 00:06:25,656
but you don't have
to know about that.


129
00:06:25,656 --> 00:06:28,136
You can just specify
this abstract parameter.


130
00:06:28,726 --> 00:06:32,966
So the core Quality of Service
Classes we're introducing are


131
00:06:32,996 --> 00:06:34,996
user-interactive,
user-initiated,


132
00:06:35,166 --> 00:06:36,426
utility, and background.


133
00:06:36,946 --> 00:06:40,406
I'll go through each
of those in turn.


134
00:06:40,606 --> 00:06:43,676
User-Interactive is the quality
of service of the main thread


135
00:06:43,676 --> 00:06:46,316
of the application, and we set
that up for you automatically.


136
00:06:46,906 --> 00:06:48,886
It's -- should be used


137
00:06:48,886 --> 00:06:51,406
for anything that's directly
involved in event handling,


138
00:06:51,716 --> 00:06:55,146
UI drawing, and anything
of that nature,


139
00:06:55,846 --> 00:06:59,126
but overall for an
application we expect


140
00:06:59,126 --> 00:07:01,446
that this should be a small
fraction of the total work


141
00:07:01,446 --> 00:07:03,816
that an application does,
especially in the case


142
00:07:03,816 --> 00:07:05,256
where the user isn't
directly interacting


143
00:07:05,256 --> 00:07:06,016
with the application.


144
00:07:08,236 --> 00:07:12,006
The User-Initiated Quality
of Service class is intended


145
00:07:12,006 --> 00:07:13,756
for work that's asynchronous
to the UI


146
00:07:13,756 --> 00:07:17,326
but directly UI-initiated, or
anything that a user is waiting


147
00:07:17,326 --> 00:07:18,546
for immediate results.


148
00:07:19,066 --> 00:07:23,096
This could be things that are
required for the user to be able


149
00:07:23,096 --> 00:07:25,846
to continue his interaction
with the current action


150
00:07:25,846 --> 00:07:30,356
that he's doing in the UI.


151
00:07:30,356 --> 00:07:32,276
Anything that is not of
that nature should run


152
00:07:32,276 --> 00:07:34,546
at the lower Quality of
Service class like Utility


153
00:07:34,826 --> 00:07:36,656
which is intended for
long running tasks


154
00:07:36,656 --> 00:07:40,066
but user visible progress such
as a long learning computation,


155
00:07:40,256 --> 00:07:43,506
intensive I/O, or
networking, but anything


156
00:07:43,506 --> 00:07:47,466
that really feeds data
to the user interface


157
00:07:47,466 --> 00:07:49,156
on a long running basis.


158
00:07:49,946 --> 00:07:51,886
You might also put
things like getting ready


159
00:07:51,886 --> 00:07:54,516
for the next UI request if
you can confidently predict


160
00:07:54,516 --> 00:07:57,046
that that will be needed very
soon, that Quality of Service.


161
00:07:57,446 --> 00:08:00,386
But this is already one of
the energy efficient Quality


162
00:08:00,386 --> 00:08:03,366
of Service Classes, so it's
important to put as much work


163
00:08:03,616 --> 00:08:08,106
as feasible in your application
at this Quality of Service Class


164
00:08:08,106 --> 00:08:11,806
or lower in order to maximize
your user's battery life.


165
00:08:14,536 --> 00:08:17,066
The next level is Background.


166
00:08:17,496 --> 00:08:20,446
That is intended for work
that the user is unaware of,


167
00:08:20,876 --> 00:08:22,686
that the work is
currently occurring.


168
00:08:22,986 --> 00:08:25,456
He may have opted into the
performance of that work


169
00:08:25,456 --> 00:08:27,436
in the past saying like, "I want


170
00:08:27,436 --> 00:08:30,816
to have an hourly backup
occurring," but he doesn't see


171
00:08:30,816 --> 00:08:33,706
that occurring currently
when it's going on.


172
00:08:34,145 --> 00:08:35,436
Anything that might
be prefetching,


173
00:08:35,436 --> 00:08:38,686
opportunistic prefetching of
data, or that might be work


174
00:08:38,686 --> 00:08:40,655
that could be deferrable
for long periods of time


175
00:08:41,046 --> 00:08:43,285
or just generally
maintenance or cleanup


176
00:08:43,285 --> 00:08:44,636
where I can tunnel
to an application.


177
00:08:44,916 --> 00:08:47,816
So how do you go
about choosing one


178
00:08:47,816 --> 00:08:49,216
of these Quality
of Service classes?


179
00:08:50,276 --> 00:08:52,196
There's a couple of
questions you can ask yourself


180
00:08:52,196 --> 00:08:54,236
that will help with that.


181
00:08:54,946 --> 00:08:56,426
Going through the list
for User-Interactive,


182
00:08:56,426 --> 00:08:57,606
you should ask yourself,


183
00:08:57,606 --> 00:09:00,396
"Is this work actively
involved in updating the UI?"


184
00:09:00,476 --> 00:09:02,476
If that's not the case
it probably shouldn't run


185
00:09:02,476 --> 00:09:03,576
at this Quality of Service.


186
00:09:04,056 --> 00:09:06,406
For User Initiated,
similarly, is this work required


187
00:09:06,406 --> 00:09:07,826
to continue the user
interaction?


188
00:09:07,826 --> 00:09:09,986
Like we said, if
that's not the case,


189
00:09:09,986 --> 00:09:11,246
this is not the right level.


190
00:09:12,536 --> 00:09:14,836
Utility, the question
is, is the user aware


191
00:09:14,836 --> 00:09:15,956
of the progress of the work?


192
00:09:16,736 --> 00:09:17,866
So, there's exceptions to this


193
00:09:17,866 --> 00:09:20,996
but that's typically
the criteria for being


194
00:09:20,996 --> 00:09:23,126
at this level, and
for Background,


195
00:09:23,316 --> 00:09:24,796
should you be at
Background or not.


196
00:09:25,526 --> 00:09:27,866
Can this work be deferred
to start at a better time?


197
00:09:28,606 --> 00:09:30,646
If the answer to that
question is, yes,


198
00:09:30,646 --> 00:09:32,246
then you probably shouldn't
actually be scheduling


199
00:09:32,246 --> 00:09:33,096
that work right now.


200
00:09:33,436 --> 00:09:35,096
You should be using an
alternative mechanism


201
00:09:35,096 --> 00:09:36,936
to start the work
in the first place


202
00:09:36,936 --> 00:09:38,516
like this background
activity scheduler.


203
00:09:38,996 --> 00:09:42,456
For more on that, please see the
Writing Energy Efficient Code,


204
00:09:42,456 --> 00:09:44,346
Part one session from yesterday.


205
00:09:46,536 --> 00:09:48,586
So once you've picked
one of these Quality


206
00:09:48,586 --> 00:09:50,836
of Service classes,
say User-Initiated,


207
00:09:51,096 --> 00:09:54,216
another way to think about
your choices are to compare


208
00:09:54,416 --> 00:09:56,266
with the other classes
above and below you.


209
00:09:56,266 --> 00:09:57,596
So, you could ask
questions like,


210
00:09:57,976 --> 00:10:01,266
Is it okay for user-interactive
work to happen before my work


211
00:10:01,396 --> 00:10:04,776
at User-Initiated, or,
is it okay for my work


212
00:10:04,776 --> 00:10:06,696
at User-Initiated to
compete with other work


213
00:10:06,866 --> 00:10:08,396
at User-Initiated
Quality of Service?


214
00:10:08,396 --> 00:10:10,846
If the answer to
that question is, no,


215
00:10:10,846 --> 00:10:13,126
then you should probably
move on below User-Initiated,


216
00:10:13,956 --> 00:10:18,086
and similarly, is it okay for
my work to take precedence


217
00:10:18,116 --> 00:10:20,406
over work at Utility
Quality of Service?


218
00:10:21,736 --> 00:10:23,296
So to recap this section,


219
00:10:23,476 --> 00:10:29,176
we talked about the facilities
we have and need for being able


220
00:10:29,176 --> 00:10:31,006
to provide a responsive
user interface,


221
00:10:31,136 --> 00:10:32,896
particularly asynchronous
execution,


222
00:10:33,266 --> 00:10:36,786
at the correct priority, but
it wasn't really very easy


223
00:10:36,856 --> 00:10:40,956
until now to express your intent
as far as priority is concerned,


224
00:10:41,536 --> 00:10:43,476
and that we were addressing
that with the Quality


225
00:10:43,476 --> 00:10:47,096
of Service Classes which provide
an explicit classification


226
00:10:47,096 --> 00:10:49,576
of work for you and we talked


227
00:10:49,576 --> 00:10:51,196
about the questions
you can ask yourself


228
00:10:51,196 --> 00:10:52,616
to choose the right QoS Class.


229
00:10:53,756 --> 00:10:57,766
So let's look at the
Quality of Service Class API


230
00:10:58,626 --> 00:11:00,196
that you'll be writing
code with.


231
00:11:00,696 --> 00:11:04,676
You can provide Quality of
Service Classes at a number


232
00:11:04,676 --> 00:11:07,556
of levels in the system,
starting with threads


233
00:11:07,766 --> 00:11:11,326
if you use manually-created
NSThreads or Pthreads,


234
00:11:11,646 --> 00:11:12,506
you can provide Quality


235
00:11:12,506 --> 00:11:14,476
of Service Class on
those at creation.


236
00:11:14,956 --> 00:11:17,356
We won't talk about
this in detail here,


237
00:11:17,606 --> 00:11:19,056
but it's pretty simple.


238
00:11:19,056 --> 00:11:21,966
You can look that up
in the documentation.


239
00:11:22,526 --> 00:11:24,796
We'll talk about how to
provide Quality of Service


240
00:11:24,796 --> 00:11:28,726
on dispatch queues and dispatch
blocks, and yesterday's session


241
00:11:28,956 --> 00:11:31,056
on writing energy efficient
code talked about how


242
00:11:31,056 --> 00:11:32,536
to provide Quality of Service


243
00:11:32,536 --> 00:11:34,396
on NSOperation queue
and NSOperation.


244
00:11:35,386 --> 00:11:38,276
In rare cases, it's also useful
to provide Quality of Service


245
00:11:38,276 --> 00:11:39,596
on processes at a whole.


246
00:11:39,856 --> 00:11:41,326
Again, that's something
that you can look


247
00:11:41,326 --> 00:11:42,456
up in the documentation.


248
00:11:42,916 --> 00:11:47,056
So here under Quality of
Service Class Constants


249
00:11:47,056 --> 00:11:49,036
that we've provided in
the headers that will pass


250
00:11:49,036 --> 00:11:51,886
through the APIs, these are the
four classes we talked about.


251
00:11:52,336 --> 00:11:55,476
The sys/qos.h header has
constants that you typically use


252
00:11:55,476 --> 00:11:59,066
at the lower level APIs, and
foundation.h has a coolant,


253
00:11:59,236 --> 00:12:01,276
and in fact, interchangeable
constants


254
00:12:01,616 --> 00:12:04,716
for user at the NS APIs.


255
00:12:04,876 --> 00:12:07,606
But the QS.h header has
two additional values


256
00:12:07,606 --> 00:12:09,556
that we'll talk about right now.


257
00:12:10,136 --> 00:12:14,466
The QoS Class default is a
class that fits in the middle


258
00:12:14,466 --> 00:12:16,976
between User-Interactive
-- the UI classes, rather,


259
00:12:16,976 --> 00:12:20,336
and the non UI classes,
and this is what we use


260
00:12:20,336 --> 00:12:23,236
when we have no more
specific QoS information.


261
00:12:24,006 --> 00:12:25,706
For instant, for a
thread that was created


262
00:12:25,706 --> 00:12:26,966
without any specific QoS,


263
00:12:26,966 --> 00:12:29,336
it will run at the
default Quality of Service.


264
00:12:29,806 --> 00:12:32,906
Similarly, for the PCD
Global Default Queue,


265
00:12:33,356 --> 00:12:36,246
that runs at Quality
of Service default.


266
00:12:36,966 --> 00:12:40,416
It's not in itself intended as
a work classification for you


267
00:12:40,416 --> 00:12:42,376
to use to specify intent,


268
00:12:42,836 --> 00:12:46,426
it's just so you shouldn't
typically set it, except maybe


269
00:12:46,426 --> 00:12:48,126
when you're resetting
to a previous state


270
00:12:48,216 --> 00:12:50,456
or maybe propagating a state
from one place to another.


271
00:12:50,456 --> 00:12:53,656
The other special value
is QoS underscore Class


272
00:12:53,656 --> 00:12:54,746
underscore Unspecified.


273
00:12:54,746 --> 00:12:56,866
This isn't an actually
class, this is the absence


274
00:12:56,866 --> 00:12:59,366
of QoS information, the
nil value if you will,


275
00:12:59,896 --> 00:13:01,436
and this indicates to us


276
00:13:01,436 --> 00:13:05,476
that maybe they should be
inferring the Quality of Service


277
00:13:05,476 --> 00:13:07,596
from a different place
like the work origin.


278
00:13:08,176 --> 00:13:10,526
It is also something that
you'll might see returned


279
00:13:11,026 --> 00:13:15,256
from the thread header APIs if a
thread was opted out of Quality


280
00:13:15,256 --> 00:13:17,286
of Service by use
of a legacy API.


281
00:13:18,116 --> 00:13:20,626
These are things that might
manipulate these underlying


282
00:13:20,626 --> 00:13:22,216
knobs directly that we talked


283
00:13:22,216 --> 00:13:26,296
about that then become
incompatible with the Quality


284
00:13:26,296 --> 00:13:29,566
of Service unified
concept in which case,


285
00:13:29,626 --> 00:13:31,816
so this would be
things like skipparam,


286
00:13:31,916 --> 00:13:34,236
in which case we will opt
out the thread out of Quality


287
00:13:34,236 --> 00:13:36,596
of Service and you
will see this value


288
00:13:36,596 --> 00:13:39,586
as the one returned
from the current QoS.


289
00:13:39,986 --> 00:13:43,576
In addition to the classes,


290
00:13:43,896 --> 00:13:45,616
we also provide you
an initial parameter


291
00:13:46,366 --> 00:13:48,556
that indicates relative position


292
00:13:48,556 --> 00:13:51,546
within a QoS class band,
or relative priority.


293
00:13:52,506 --> 00:13:59,066
So rather than having five
discreet classes, we can think


294
00:13:59,066 --> 00:14:02,046
of QoS really as a set
of five priority bands


295
00:14:02,506 --> 00:14:05,346
where you can position yourself
inside one of these bands,


296
00:14:05,796 --> 00:14:08,556
and you can only lower
yourself from the default.


297
00:14:08,606 --> 00:14:11,966
So, you can provide a value
between minus 15 and zero


298
00:14:12,246 --> 00:14:17,076
to position yourself lower than
most other people in that band,


299
00:14:17,646 --> 00:14:20,566
and it's really only intended
for unusual situations.


300
00:14:20,566 --> 00:14:23,276
We expect that in most
cases, the zero value --


301
00:14:23,476 --> 00:14:25,956
default zero value will
be perfectly sufficient,


302
00:14:26,506 --> 00:14:28,086
but if you have special
situations


303
00:14:28,086 --> 00:14:30,876
like interdependent work at the
same Quality of Service class


304
00:14:30,876 --> 00:14:32,476
that needs slightly
differing priority


305
00:14:32,896 --> 00:14:36,116
or produce a consumer scenario
so one or other side might need


306
00:14:36,116 --> 00:14:38,306
to be slightly high-priority
to get a good flow,


307
00:14:39,076 --> 00:14:40,826
this is the tool for that.


308
00:14:40,826 --> 00:14:46,716
Now let's talk about the
API you'll use with threads.


309
00:14:48,276 --> 00:14:52,676
As mentioned, QoS is kind of
a thread specific concept,


310
00:14:53,086 --> 00:14:56,996
and you can get the QoS class
off the currently running thread


311
00:14:56,996 --> 00:14:58,856
with the qos class
self function.


312
00:14:59,396 --> 00:15:01,466
This will return what the
thread is currently running at.


313
00:15:01,466 --> 00:15:04,716
This is not only in the cases
of manually-created threads,


314
00:15:04,716 --> 00:15:07,656
but if work starts running
where your specified QoS would,


315
00:15:08,126 --> 00:15:09,786
the GCD or NSOperation APIs,


316
00:15:09,786 --> 00:15:13,316
once it starts running the
thread will have a QoS value


317
00:15:13,316 --> 00:15:14,806
and this is how you get it.


318
00:15:15,356 --> 00:15:18,696
The other thread concept we
have is the Initial QoS Class


319
00:15:18,806 --> 00:15:20,256
of the main thread.


320
00:15:20,426 --> 00:15:22,656
This is something the system
chooses for you when it brings


321
00:15:22,656 --> 00:15:25,526
up the main thread, and
that's selected depending


322
00:15:25,636 --> 00:15:26,926
on what kind of process you are.


323
00:15:27,336 --> 00:15:30,126
If you're an App, that will be
the User-Interactive Quality


324
00:15:30,126 --> 00:15:30,726
of Service.


325
00:15:30,726 --> 00:15:32,566
If you were an XPC
service or Daemon,


326
00:15:32,786 --> 00:15:34,706
it will be the default
Quality of Service,


327
00:15:34,786 --> 00:15:36,516
and because that
can change later


328
00:15:36,516 --> 00:15:40,226
on if the main thread changes
itself, then you can go back


329
00:15:40,226 --> 00:15:41,786
to that original
value with this API.


330
00:15:41,786 --> 00:15:47,826
For the APIs in GCD and QoS,


331
00:15:47,826 --> 00:15:51,816
let's look at the existing
global queues that we've had


332
00:15:52,156 --> 00:15:56,186
since the beginning, and you'll
see we'll be mapping those


333
00:15:56,186 --> 00:15:57,636
to Quality of Service Classes.


334
00:15:58,186 --> 00:16:00,876
So the main queue, which
in an application maps


335
00:16:00,876 --> 00:16:02,736
through the main thread of
the application obviously runs


336
00:16:02,806 --> 00:16:04,606
that User Interactive
quality of service.


337
00:16:05,156 --> 00:16:07,856
You know, mapping the
high default and low queue


338
00:16:07,856 --> 00:16:10,846
to User Initiated, Default
and Utility respectively,


339
00:16:11,666 --> 00:16:16,496
and the Background priority,
concurrent queue is mapped


340
00:16:16,496 --> 00:16:17,936
to the background QoS class.


341
00:16:18,326 --> 00:16:20,206
That one is pretty much
a one-to-one mapping.


342
00:16:20,206 --> 00:16:23,696
The others, it's worth noting,
are a slightly larger spread


343
00:16:24,226 --> 00:16:27,066
of behavior than what you've
had before with high, default,


344
00:16:27,066 --> 00:16:28,276
and low, which were
very similar.


345
00:16:28,626 --> 00:16:31,766
So, this might be something
to watch out for when you move


346
00:16:32,186 --> 00:16:35,176
up to current releases.


347
00:16:35,626 --> 00:16:41,786
Getting a Global Queue with
QoS directly is also easy.


348
00:16:41,786 --> 00:16:44,886
Just use the existing dispatch
to get global Queue API


349
00:16:45,146 --> 00:16:48,626
with the utility QoS constant,
that's the first constant


350
00:16:48,626 --> 00:16:51,606
in this example rather than the
existing priority constants.


351
00:16:52,316 --> 00:16:54,946
And this is really what we
recommend you start doing


352
00:16:54,946 --> 00:16:58,056
from now on to be able to
express that intent directly


353
00:16:58,056 --> 00:17:00,636
of what you want rather
than take advantage


354
00:17:00,636 --> 00:17:01,766
of the compatibility mapping.


355
00:17:02,936 --> 00:17:05,826
Once you have a queue, you
can also ask for its QoS class


356
00:17:05,826 --> 00:17:08,445
with the dispatch queue
get QoS class getter.


357
00:17:08,695 --> 00:17:11,915
Not that QoS class is an
immutable property of the queue


358
00:17:12,165 --> 00:17:13,986
that is specified when
the queue is created.


359
00:17:14,826 --> 00:17:17,096
For a queue that you create
yourself, how do you do that?


360
00:17:17,215 --> 00:17:21,066
With the dispatch queue adder
make with QoS class API.


361
00:17:21,066 --> 00:17:24,726
This will really turn an
attribute for the QoS Class


362
00:17:24,726 --> 00:17:27,576
that you have requested,
like Utility in this example,


363
00:17:27,976 --> 00:17:31,456
and you then pass that attribute
to the dispatch you create API


364
00:17:32,226 --> 00:17:35,326
and get a Utility serial
queue in this example.


365
00:17:38,606 --> 00:17:41,256
Now let's move onto
a new concept


366
00:17:41,416 --> 00:17:44,316
that we're introducing
this year for QoS


367
00:17:45,156 --> 00:17:48,936
and other reasons called
Dispatch Block Objects.


368
00:17:49,886 --> 00:17:52,316
We've always had
blocks in GCD as sort


369
00:17:52,316 --> 00:17:54,096
of a fundamental unit
of work, of course.


370
00:17:54,586 --> 00:17:56,516
We are enhancing that
concept slightly this year


371
00:17:56,516 --> 00:17:58,756
with Dispatch Block
Objects to allow you


372
00:17:58,756 --> 00:18:00,946
to configure properties
of individual units


373
00:18:00,946 --> 00:18:02,496
of work on a queue directly.


374
00:18:03,186 --> 00:18:06,246
And it will also allow you to
address individual work units


375
00:18:06,626 --> 00:18:09,546
for the purposes of
waiting for their completion


376
00:18:10,006 --> 00:18:12,706
or getting notified
about their completion


377
00:18:12,706 --> 00:18:14,186
or being able to cancel them.


378
00:18:14,916 --> 00:18:16,876
So, this is something that
lots of people have requested


379
00:18:16,876 --> 00:18:19,676
over year that you be able to
cancel blocks in the GCD queue.


380
00:18:19,676 --> 00:18:21,846
Hopefully this helps
out with that.


381
00:18:23,056 --> 00:18:26,926
Otherwise, we are -- the goal
was to integrate transparently


382
00:18:26,926 --> 00:18:29,486
with the existing API that
we already had without having


383
00:18:29,486 --> 00:18:31,906
to introduce a lot of
additional functionality.


384
00:18:32,436 --> 00:18:33,916
So, the way we achieve that is


385
00:18:33,956 --> 00:18:36,156
by using the concept
of a wrapper block.


386
00:18:36,576 --> 00:18:40,346
You start with an existing GCD
block of type dispatch block t


387
00:18:40,806 --> 00:18:43,436
which is that function
at the right of a block


388
00:18:43,436 --> 00:18:46,906
that takes no arguments and
returns no return value,


389
00:18:47,466 --> 00:18:50,016
and we wrap that in another
block of the same type


390
00:18:50,626 --> 00:18:53,306
which contains these additional
configuration parameters


391
00:18:53,306 --> 00:18:55,086
of QoS Class and Flags.


392
00:18:56,236 --> 00:18:58,876
That operation creates
a heap object of course,


393
00:18:58,876 --> 00:19:02,576
so this is really like
similar to calling block copy


394
00:19:02,576 --> 00:19:05,566
on the nested block, so in
a seed program you will have


395
00:19:05,566 --> 00:19:09,516
to call block release on the
return object to get rid of it,


396
00:19:09,756 --> 00:19:13,296
or in Objective-C programs,
send a release message


397
00:19:13,296 --> 00:19:14,596
or let arch do that for you.


398
00:19:16,956 --> 00:19:18,936
Quick example of
that API in action,


399
00:19:19,256 --> 00:19:22,326
we create a local variable
of this type dispatch block t


400
00:19:22,486 --> 00:19:26,326
and send it to the result of the
dispatch block create function.


401
00:19:26,636 --> 00:19:29,196
Here passing no flags
and just a block literal,


402
00:19:29,586 --> 00:19:32,416
and this is very similar to
block create at this point,


403
00:19:33,016 --> 00:19:34,776
and then we can just
pass that block object


404
00:19:34,776 --> 00:19:39,186
to the existing dispatch, async
API and do some work while


405
00:19:39,186 --> 00:19:41,596
that is synchronous and
this log is occurring,


406
00:19:41,996 --> 00:19:44,986
and finally maybe we need
to wait on that result,


407
00:19:45,326 --> 00:19:46,886
so we call the dispatch
wait API,


408
00:19:47,006 --> 00:19:48,796
passing in that block
object directly


409
00:19:49,116 --> 00:19:51,276
and now we don't need any
additional setup to wait


410
00:19:51,276 --> 00:19:53,676
for the result to face
[inaudible] like we might have


411
00:19:53,676 --> 00:19:57,026
in the patch with dispatch
group or dispatch centerfolds.


412
00:19:57,526 --> 00:20:00,556
And finally as mentioned,
in a C program you have


413
00:20:00,616 --> 00:20:02,306
to block release that
reference created


414
00:20:02,346 --> 00:20:06,606
by dispatch block create.


415
00:20:06,746 --> 00:20:09,436
Second example here we use
the dispatch block create


416
00:20:09,436 --> 00:20:11,846
with QoS Class API to
create a block object


417
00:20:11,846 --> 00:20:14,086
that has a specific assigned
Quality of Service Class


418
00:20:14,136 --> 00:20:15,556
that we want for
just that block.


419
00:20:15,666 --> 00:20:19,756
So here we've chosen Utility
minus 8 derivative just


420
00:20:19,756 --> 00:20:22,846
as an example, and we
pass, again, that block,


421
00:20:22,846 --> 00:20:26,736
to dispatch async, and maybe we
do some work and then decide,


422
00:20:26,736 --> 00:20:30,716
"Oh we really didn't need this
Utility Quality of Service work


423
00:20:30,716 --> 00:20:34,406
at all," so we then pass it to
the block to dispatch cancel


424
00:20:34,876 --> 00:20:37,146
which will mark that
block as cancelled


425
00:20:37,146 --> 00:20:38,726
and if it hasn't
started executing


426
00:20:38,726 --> 00:20:42,046
yet when it gets de-queued it
will just return straight away.


427
00:20:42,616 --> 00:20:45,836
So, this allows you to sort
of take back the end queue


428
00:20:45,946 --> 00:20:48,016
that we thought in the
past was not possible.


429
00:20:48,016 --> 00:20:53,956
It's important to note this
cancellation is not preemptive.


430
00:20:53,956 --> 00:20:54,546
It's very similar


431
00:20:54,546 --> 00:20:56,596
to the dispatch source
cancellation that we've had.


432
00:20:56,596 --> 00:20:57,706
If the block is started,


433
00:20:58,086 --> 00:21:00,586
cancellation will not stop
it from doing anything.


434
00:21:00,976 --> 00:21:03,436
The block can check for
cancellation on itself


435
00:21:03,636 --> 00:21:06,006
with the test cancel
API of course.


436
00:21:08,936 --> 00:21:13,086
Finally, last example here we'll
be showing the use of a flag


437
00:21:13,086 --> 00:21:15,516
when we call the
dispatch block create API.


438
00:21:15,516 --> 00:21:18,586
We're using the detached
flag here which is something


439
00:21:18,586 --> 00:21:21,916
that you might have heard about
in the Activity Tracing Session


440
00:21:21,916 --> 00:21:23,356
if you went to that
this morning.


441
00:21:23,676 --> 00:21:26,946
It's a concept of being able
to disassociate that block


442
00:21:26,946 --> 00:21:29,326
that you're going to schedule
from what is currently going


443
00:21:29,326 --> 00:21:33,166
on in the thread that caused the
dispatch block create for work


444
00:21:33,166 --> 00:21:35,866
that should not be correlated
such as internal work


445
00:21:35,866 --> 00:21:38,966
to the application like
clean caches in this example.


446
00:21:39,416 --> 00:21:41,506
You know of course, we pass
that again to dispatch async,


447
00:21:41,626 --> 00:21:44,246
and in this case we will
use the dispatch notify API


448
00:21:44,246 --> 00:21:48,696
to schedule a notification block
on the main queue to tell us


449
00:21:48,696 --> 00:21:51,066
when that clean cache
block is completed.


450
00:21:51,986 --> 00:21:53,356
This is very similar


451
00:21:53,356 --> 00:21:56,396
to the dispatch group
notifier API that we've had.


452
00:21:57,586 --> 00:21:59,726
Now that we've talked
about the interaction --


453
00:21:59,846 --> 00:22:01,696
at least talked about
the various levels


454
00:22:01,696 --> 00:22:04,626
where you can specify Quality
of Service, we have to talk


455
00:22:04,626 --> 00:22:07,796
about how they interact when you
specify them at multiple levels


456
00:22:07,796 --> 00:22:12,056
at once, and for Asynchronous
Blocks, the default behavior is


457
00:22:12,056 --> 00:22:14,326
that we will always prefer
the Quality of Service Class


458
00:22:14,326 --> 00:22:17,406
of the queue if it has a
Quality of Service Class.


459
00:22:17,826 --> 00:22:20,846
Or if it doesn't, we will look
at the immediate target queue


460
00:22:20,846 --> 00:22:23,506
if that's one of the global
target queues with Quality


461
00:22:23,506 --> 00:22:26,056
of Service like the default --


462
00:22:26,056 --> 00:22:28,886
sorry, like the high/low
Background but not the default,


463
00:22:29,176 --> 00:22:31,496
or one of the ones that
you specifically requested


464
00:22:31,646 --> 00:22:32,586
with Quality of Service.


465
00:22:32,586 --> 00:22:34,806
In that case, we
really use that as sort


466
00:22:34,806 --> 00:22:38,446
of a backwards compatibility
method with the existing way


467
00:22:38,446 --> 00:22:41,726
to specify priority in
GCD, or the target queue.


468
00:22:42,576 --> 00:22:45,776
If you don't have any of these
two pieces of information,


469
00:22:45,776 --> 00:22:48,476
we will use the Block
Quality of Service class


470
00:22:48,476 --> 00:22:51,146
if you've specified it
with the creation API,


471
00:22:51,146 --> 00:22:54,776
or otherwise we will use
Quality of Service inferred


472
00:22:54,776 --> 00:22:55,856
from the submitting thread.


473
00:22:56,906 --> 00:22:58,856
What do we mean by
that inferred QoS?


474
00:22:59,206 --> 00:23:01,196
This is the Quality of
Service that we captured


475
00:23:01,376 --> 00:23:03,176
at the time the block was
submitted to the queue,


476
00:23:03,176 --> 00:23:05,076
so this is the Quality of
Service that was active


477
00:23:05,496 --> 00:23:07,516
on the thread that
called dispatch async


478
00:23:07,516 --> 00:23:09,666
at the time the block
was submitted.


479
00:23:10,036 --> 00:23:12,826
We will -- because this
is an automatic mechanism,


480
00:23:12,826 --> 00:23:15,576
we will translate User
Incorrective to User Initiated


481
00:23:15,576 --> 00:23:18,606
for you to make sure that you
don't propagate the main thread


482
00:23:19,186 --> 00:23:22,896
priority inadvertently to lots
of places in the application.


483
00:23:23,796 --> 00:23:26,866
But otherwise, if there's no
Quality of Service specified


484
00:23:26,866 --> 00:23:29,156
on the queue, we will
use this mechanism.


485
00:23:29,156 --> 00:23:31,206
This is intended for queues


486
00:23:31,256 --> 00:23:34,506
that might not have
a specific identity


487
00:23:34,506 --> 00:23:36,386
that it can assign a
Quality of Service to


488
00:23:36,796 --> 00:23:39,076
or that don't really
serve a single purpose


489
00:23:39,076 --> 00:23:42,066
where it is appropriate for
the Quality of Service Class


490
00:23:42,066 --> 00:23:44,166
from the client, if
you roll off the queue,


491
00:23:44,306 --> 00:23:46,276
to actually determine
what you run it.


492
00:23:46,736 --> 00:23:49,186
So things that mediate between
many different clients would be


493
00:23:49,866 --> 00:23:51,446
a good candidate for that.


494
00:23:52,516 --> 00:23:55,196
For synchronous blocks, the
rules are slightly different,


495
00:23:55,196 --> 00:23:57,036
but you will default
to the Quality


496
00:23:57,036 --> 00:24:00,256
of Service Class off the
block if there's such a thing,


497
00:24:00,506 --> 00:24:02,356
or otherwise use the one
off the current thread.


498
00:24:02,476 --> 00:24:04,386
This is very similar to
what has always happened


499
00:24:04,386 --> 00:24:05,146
with this batch sync.


500
00:24:05,146 --> 00:24:06,616
It actually executes
the block that you pass


501
00:24:06,616 --> 00:24:08,756
on the calling thread itself.


502
00:24:09,336 --> 00:24:11,696
Note that this will only ever
raise the Quality of Service,


503
00:24:11,696 --> 00:24:14,196
so as not to prevent any
work later on in the thread


504
00:24:14,196 --> 00:24:17,026
after the dispatch sync
returns from making progress.


505
00:24:18,306 --> 00:24:19,256
These are just default.


506
00:24:19,256 --> 00:24:23,356
We also provide you explicit
control over these options.


507
00:24:23,656 --> 00:24:26,266
You can use the Dispatch
Block Inherent QoS flag


508
00:24:26,266 --> 00:24:30,156
when you create a block -- a
special block object to tell us


509
00:24:30,156 --> 00:24:33,466
to prefer, always prefer the
QoS of the queue or the thread,


510
00:24:34,126 --> 00:24:38,636
or conversely to pass the
Dispatch Block Enforce QoS Class


511
00:24:38,636 --> 00:24:41,776
flag so that we will always
prefer the block's Quality


512
00:24:41,776 --> 00:24:44,256
of Service even if we go to
a queue that has a Quality


513
00:24:44,256 --> 00:24:46,156
of Service itself, but again,


514
00:24:46,156 --> 00:24:48,446
in these cases we only
ever raise the Quality


515
00:24:48,446 --> 00:24:49,866
of Service to something higher.


516
00:24:52,876 --> 00:24:55,266
Now that we've talked about
all these different ways


517
00:24:55,266 --> 00:24:58,546
of introducing different
priorities into your process,


518
00:24:58,546 --> 00:25:00,276
we have to talk about
the priority inversions.


519
00:25:01,066 --> 00:25:03,246
What is a priority inversion?"


520
00:25:03,356 --> 00:25:07,076
In general, it's just some
situation where the progress


521
00:25:07,076 --> 00:25:10,136
of high-priority work
depends on either the results


522
00:25:10,266 --> 00:25:11,366
of some low-priority work


523
00:25:11,746 --> 00:25:15,496
or a resource held
by low-priority work.


524
00:25:15,706 --> 00:25:18,456
And in the debugging
scenario you would see this


525
00:25:18,456 --> 00:25:20,836
as high-priority threats
that are either blocked


526
00:25:21,206 --> 00:25:25,056
or maybe even spinning
or polling results


527
00:25:25,056 --> 00:25:28,916
from a low-priority thread that
you might also see present.


528
00:25:30,066 --> 00:25:31,136
So in a synchronous situation


529
00:25:31,136 --> 00:25:33,896
like that it would
be high Quality


530
00:25:33,896 --> 00:25:36,676
of Service thread waiting on
lower Quality of Service work.


531
00:25:37,246 --> 00:25:39,496
We will actually try
to resolve inversions


532
00:25:39,666 --> 00:25:42,646
in very specific cases for you,


533
00:25:42,646 --> 00:25:47,236
namely when you call dispatch
sync and dispatch wait the block


534
00:25:47,436 --> 00:25:50,636
on a serial queue, or when
you call pthread mutex lock


535
00:25:51,326 --> 00:25:54,276
or any facilities built
on top it like NSLock.


536
00:25:54,866 --> 00:25:58,626
In those cases, the system
will try to raise the Quality


537
00:25:58,626 --> 00:26:03,156
of Service of the work that is
being waited on to the Quality


538
00:26:03,156 --> 00:26:03,996
of Service of the waiter.


539
00:26:06,116 --> 00:26:08,646
The asynchronous case is
obviously also possible.


540
00:26:08,926 --> 00:26:11,226
Say you have submitted a
high Quality of Service block


541
00:26:11,226 --> 00:26:14,006
to a serial queue that was
created with lower Quality


542
00:26:14,006 --> 00:26:16,676
of Service or that contains
some blocks with lower Quality


543
00:26:16,676 --> 00:26:17,696
of Service earlier on.


544
00:26:18,156 --> 00:26:21,376
Now this block is -- some
high-priority work is backed


545
00:26:21,376 --> 00:26:23,436
up behind lower-priority
work asynchronously.


546
00:26:24,106 --> 00:26:26,476
In the case of a serial
queue specifically again,


547
00:26:26,716 --> 00:26:28,856
the system will attempt
to automatically resolve


548
00:26:28,856 --> 00:26:31,366
that for you by raising
the Quality of Service


549
00:26:31,366 --> 00:26:33,876
of the queue temporarily
until you have reached


550
00:26:33,876 --> 00:26:35,336
that high Quality
of Service work.


551
00:26:36,716 --> 00:26:39,946
But of course, rather than
relying on the system to try


552
00:26:39,946 --> 00:26:41,996
and resolve these situations
for you, it's much better


553
00:26:41,996 --> 00:26:44,286
if you can avoid these
inversions in the first place.


554
00:26:44,686 --> 00:26:47,586
So if that's possible,
you should attempt to do


555
00:26:47,586 --> 00:26:49,296
that if you see that
type of problem.


556
00:26:49,726 --> 00:26:52,846
One technique is to
decouple shared data


557
00:26:53,006 --> 00:26:55,876
between multiple priority
levels as much as you can


558
00:26:56,166 --> 00:27:00,226
by using finer grade
synchronization mechanisms,


559
00:27:00,226 --> 00:27:03,896
finer granularity, and
move work outside of blocks


560
00:27:03,896 --> 00:27:05,576
or serial queues if
that is possible.


561
00:27:06,436 --> 00:27:10,866
Another technique is to
prefer asynchronous execution


562
00:27:10,866 --> 00:27:12,186
over synchronous waiting,


563
00:27:12,546 --> 00:27:14,956
because synchronous
waiting typically leads


564
00:27:14,956 --> 00:27:17,546
to chain soft waiters
in situations like this


565
00:27:17,546 --> 00:27:19,356
where one guy is waiting
on the next is waiting


566
00:27:19,356 --> 00:27:20,446
on something else, etcetera.


567
00:27:20,976 --> 00:27:22,586
But in asynchronous execution,


568
00:27:23,086 --> 00:27:25,246
so now that is much
easier to resolve.


569
00:27:26,516 --> 00:27:31,286
And also something worth looking
at here is spinning or polling


570
00:27:31,286 --> 00:27:33,906
for completion where
my high quality


571
00:27:33,906 --> 00:27:35,946
of service thread might
actually be, by doing that,


572
00:27:35,946 --> 00:27:38,546
holding off the low-priority
work that it's waiting for,


573
00:27:38,956 --> 00:27:42,466
and particularly look at for
timer-based "synchronization"


574
00:27:42,726 --> 00:27:46,636
in quotes, which is some
kind of checking for a result


575
00:27:46,776 --> 00:27:49,626
after an amount of time, that
might not immediately appear


576
00:27:49,626 --> 00:27:51,206
to be a polling loop,
but in fact is,


577
00:27:51,206 --> 00:27:53,776
especially if it's some
priority inversion situation.


578
00:27:54,096 --> 00:27:57,396
So to recap this section,


579
00:27:57,396 --> 00:28:01,446
we talked about the QoS Class
constants that you can use,


580
00:28:01,906 --> 00:28:04,966
the concept of relative
Quality of Service priority,


581
00:28:05,476 --> 00:28:11,196
the APIs for queues and
blocks, and the interaction


582
00:28:11,196 --> 00:28:13,386
of multiple Quality of
Service specifications


583
00:28:13,386 --> 00:28:15,486
if you've given them to blocks
of queues at the same time,


584
00:28:15,986 --> 00:28:18,896
along with what we do
for priority inversions


585
00:28:18,896 --> 00:28:22,896
and what you can
do to avoid them.


586
00:28:23,096 --> 00:28:25,406
Our next section is
about the Propagation


587
00:28:25,406 --> 00:28:26,926
of Execution Context.


588
00:28:28,176 --> 00:28:31,266
What is Execution Context
here, this is a set


589
00:28:31,266 --> 00:28:33,916
of thread-local attributes that
the system maintains for you.


590
00:28:34,286 --> 00:28:37,736
This includes the Activity ID
that we heard about this morning


591
00:28:37,736 --> 00:28:39,556
in the Activity Tracing session


592
00:28:40,006 --> 00:28:43,406
that underlies the correlation
aspect of Activity Tracing.


593
00:28:43,886 --> 00:28:46,886
It also includes properties
of the current IPC request


594
00:28:46,886 --> 00:28:52,316
if you say in a XPC Event
Handler, such as the originator


595
00:28:52,416 --> 00:28:55,126
of a chain of IPC across
multiple processes,


596
00:28:55,556 --> 00:28:58,716
or the importance of that
originator, and we'll talk more


597
00:28:58,716 --> 00:28:59,846
about that in a while.


598
00:29:01,736 --> 00:29:06,376
The interesting thing about
this Execution Context is


599
00:29:06,376 --> 00:29:09,266
that we automatically
propagate it for you.


600
00:29:09,266 --> 00:29:12,186
We propagate it across
threads and processes with GCD,


601
00:29:12,186 --> 00:29:14,036
NSOperationQueue, and
other Foundation APIs,


602
00:29:14,036 --> 00:29:16,806
and we propagate
it across processes


603
00:29:17,136 --> 00:29:19,896
like XPC and other IPC APIs.


604
00:29:20,886 --> 00:29:23,866
So an example of that
graphically would be we have two


605
00:29:23,866 --> 00:29:25,356
queues here that are running


606
00:29:25,356 --> 00:29:27,076
with two different
execution contexts,


607
00:29:27,456 --> 00:29:31,086
two different activity IDs
as a proxy for one and two.


608
00:29:31,446 --> 00:29:34,806
If you do a Dispatch Async from
Q1 to Q3, that will transport


609
00:29:34,856 --> 00:29:38,456
that activity ID1 transparently
for you to that other Q,


610
00:29:38,826 --> 00:29:41,876
or if that Q1 talks to
a different processor


611
00:29:41,876 --> 00:29:44,916
at XPC we will transport
that execution context


612
00:29:45,216 --> 00:29:47,946
across process, and then of
course inside that process,


613
00:29:47,946 --> 00:29:49,706
we can continue to
propagate, as well.


614
00:29:52,196 --> 00:29:54,106
Now because this is
automatic propagation,


615
00:29:54,106 --> 00:29:56,276
sometimes you may
need to prevent


616
00:29:56,276 --> 00:29:58,306
that because it might
be inappropriate


617
00:29:58,306 --> 00:29:59,826
in some situations, and that is


618
00:29:59,826 --> 00:30:01,986
where the DISPATCH
BLOCK DETACHED flag


619
00:30:02,076 --> 00:30:03,926
to the dispatch block
create API comes in.


620
00:30:04,686 --> 00:30:07,946
This would be used for any type
of work that's asynchronous


621
00:30:08,496 --> 00:30:11,226
and to be disassociated from
the principle activity that's


622
00:30:11,276 --> 00:30:14,816
currently ongoing, so anything
that is not directly related


623
00:30:14,816 --> 00:30:18,376
to say, the UI action that an
application is undertaking right


624
00:30:18,376 --> 00:30:19,486
now, or in a Daemon.


625
00:30:19,826 --> 00:30:25,666
You can't IPC request if you
have to do some related but work


626
00:30:25,746 --> 00:30:27,736
that may not be directly
attributable


627
00:30:27,736 --> 00:30:29,396
to say, the IPC request.


628
00:30:30,006 --> 00:30:32,256
A typical example of that
is an asynchronous long


629
00:30:32,256 --> 00:30:34,456
running-cleanup or
Daemon of that nature.


630
00:30:36,116 --> 00:30:38,836
We have a couple of things
that are detached by default.


631
00:30:39,256 --> 00:30:41,996
The Dispatch source handlers,
the blocks that specify


632
00:30:42,216 --> 00:30:44,026
as Dispatch source
handlers, or the blocks


633
00:30:44,026 --> 00:30:46,296
that pass the dispatch after
are detached by default.


634
00:30:47,156 --> 00:30:49,726
So same animation as before.


635
00:30:49,726 --> 00:30:53,186
The upper half, we have
asynchronous propagation


636
00:30:53,186 --> 00:30:57,206
of the activities automatically,
but say Q3 now discovers


637
00:30:57,206 --> 00:30:58,826
that it has to do some
maintenance operation


638
00:30:59,166 --> 00:31:01,276
that really shouldn't be
associated to this activity.


639
00:31:01,276 --> 00:31:07,786
It uses the Detached Block
API to create a separate unit


640
00:31:08,506 --> 00:31:11,266
of work that is not
related to this activity,


641
00:31:11,516 --> 00:31:15,116
which then maybe later on can
create its own Activity ID


642
00:31:15,116 --> 00:31:19,616
that is separate from the
one that it originated from.


643
00:31:19,746 --> 00:31:21,176
We also provide facilities
for you


644
00:31:21,176 --> 00:31:23,336
to manually propagate
this execution context


645
00:31:23,756 --> 00:31:26,466
with the DISPATCH BLOCK
ASSIGN CURRENT flag.


646
00:31:27,036 --> 00:31:29,606
This assigns the current
Quality of Service Class


647
00:31:29,606 --> 00:31:30,786
and Execution Context


648
00:31:30,786 --> 00:31:33,726
at the time you call the
dispatch block create API


649
00:31:33,856 --> 00:31:34,316
to the block.


650
00:31:35,116 --> 00:31:37,386
And this is particularly
useful in cases where you want


651
00:31:37,386 --> 00:31:39,626
to store the block yourself
in some data structure.


652
00:31:39,626 --> 00:31:41,606
Say you have your
own thread pool


653
00:31:41,966 --> 00:31:45,836
or your own threading model, and
you then later on want to call


654
00:31:45,836 --> 00:31:48,366
that block on one of those
threads and we can't really make


655
00:31:48,366 --> 00:31:51,276
that connection that you
transported work across threads


656
00:31:51,276 --> 00:31:54,196
for you in that case
because we don't understand


657
00:31:54,196 --> 00:31:55,006
that relationship.


658
00:31:55,126 --> 00:31:59,856
Similarly, you might decide
to later on submit a block


659
00:31:59,856 --> 00:32:01,836
to a dispatch queue but you
want to capture this state


660
00:32:02,376 --> 00:32:04,876
that occurred when
you stored the work.


661
00:32:08,936 --> 00:32:12,626
For XPC, as mentioned, the
propagation is automatic.


662
00:32:12,626 --> 00:32:15,526
XPC connections propagate
both Quality of Service Class


663
00:32:15,526 --> 00:32:17,746
and Execution Context
automatically


664
00:32:17,836 --> 00:32:21,326
to the remote XPC Event Handler.


665
00:32:21,896 --> 00:32:27,166
Worth noting that the capture
of the current state happens


666
00:32:27,166 --> 00:32:28,796
when the Send operation occurs,


667
00:32:29,136 --> 00:32:33,296
so we call the XPC
Connection Send API.


668
00:32:33,296 --> 00:32:35,946
That's what Message Send
API, this is what --


669
00:32:35,946 --> 00:32:38,826
that's the point at which
we captured that state,


670
00:32:39,156 --> 00:32:42,376
and note that XPC handlers
prefer the propagated Quality


671
00:32:42,376 --> 00:32:44,056
of Service over that
on the queues


672
00:32:44,056 --> 00:32:45,356
that they run on by default.


673
00:32:48,856 --> 00:32:53,026
For XPC Services that you
might be writing in OS X,


674
00:32:53,396 --> 00:32:55,936
we have talked about in
the past about the concept


675
00:32:55,936 --> 00:32:58,776
of importance boosting
in past years' sessions.


676
00:32:59,166 --> 00:33:02,436
This is still present this
year, but it's slightly changed.


677
00:33:02,816 --> 00:33:05,496
We -- this is a mechanism
that's used


678
00:33:05,496 --> 00:33:08,166
to initially clamp the
XPC Service process


679
00:33:08,166 --> 00:33:09,556
to Background Quality of Service


680
00:33:09,886 --> 00:33:14,256
and only unclamp it during
the IPC with the UI process.


681
00:33:14,786 --> 00:33:18,426
So this allows XPC services
to have as little impact


682
00:33:18,426 --> 00:33:20,916
on the system as a whole when
they're not directly in use,


683
00:33:21,616 --> 00:33:26,496
and XPC manages the lifetime of
that boost automatically for you


684
00:33:26,606 --> 00:33:28,386
until either the reply is sent


685
00:33:28,386 --> 00:33:29,976
or you've released
the last reference


686
00:33:29,976 --> 00:33:31,716
of the XPC message
that you've received.


687
00:33:32,286 --> 00:33:36,466
Additionally this
year, the lifetime


688
00:33:36,466 --> 00:33:38,456
of that boost will also be
maintained while there is


689
00:33:38,456 --> 00:33:41,496
asynchronous work that was
submitted from the context


690
00:33:41,946 --> 00:33:45,026
of the handler, the XPC
Handler was submitted --


691
00:33:45,606 --> 00:33:46,696
is ongoing, sorry.


692
00:33:47,086 --> 00:33:50,366
So this is done right at
propagation of execution context


693
00:33:50,366 --> 00:33:51,896
that contains this
important state.


694
00:33:52,456 --> 00:33:55,026
So this is typically what
you want in a process


695
00:33:55,026 --> 00:33:56,596
if you're creating
asynchronous work


696
00:33:56,596 --> 00:33:58,286
that is related to
the IPC request.


697
00:33:58,856 --> 00:34:01,646
The process shouldn't
become clamped again


698
00:34:01,646 --> 00:34:05,256
until that work is done, but
of course, it is also possible


699
00:34:05,256 --> 00:34:07,386
that you might have
unrelated work generated there


700
00:34:07,466 --> 00:34:10,016
and in those cases you
should make sure to use


701
00:34:10,016 --> 00:34:13,866
that Detached Block flag
to submit that work,


702
00:34:13,996 --> 00:34:16,706
because otherwise you might
be keeping the XPC service


703
00:34:16,706 --> 00:34:22,576
unboostered, unclamped, for
a longer period of time.


704
00:34:22,576 --> 00:34:26,295
Now to recap, we talked
about execution context


705
00:34:26,356 --> 00:34:29,416
and the attributes
that we track therein.


706
00:34:29,826 --> 00:34:33,186
Automatic propagation of
this context along with QoS


707
00:34:33,186 --> 00:34:35,545
and how you can control
that propagation manually,


708
00:34:36,196 --> 00:34:42,235
as well as, the aspects
pertaining to XPC propagation


709
00:34:42,235 --> 00:34:45,335
and importance boosting.


710
00:34:45,446 --> 00:34:49,826
So finally, I want to give
a shout out to a couple


711
00:34:49,826 --> 00:34:52,416
of very exciting new features
that we're introducing this year


712
00:34:52,416 --> 00:34:54,966
around Diagnostics
of Asynchronous Code


713
00:34:54,966 --> 00:34:56,346
and Debugging of
Asynchronous Code.


714
00:34:56,346 --> 00:34:59,046
First off, the Xcode
6 CPU Report --


715
00:34:59,206 --> 00:35:04,086
this is what you would
use to diagnose or confirm


716
00:35:04,086 --> 00:35:06,206
that you have done your
adoption of Quality


717
00:35:06,206 --> 00:35:07,396
of Service classes correctly.


718
00:35:07,876 --> 00:35:11,616
If you stop in the debugger
at the breakpoint say,


719
00:35:11,996 --> 00:35:15,906
you can click on the CPU gauge
tab to get the CPU report,


720
00:35:16,456 --> 00:35:19,196
and here you can see the
total amount of CPU used


721
00:35:19,196 --> 00:35:21,126
by the process in a graph.


722
00:35:21,126 --> 00:35:22,636
And new this year for each


723
00:35:22,636 --> 00:35:24,986
of the threads involved we
will also show you the Quality


724
00:35:24,986 --> 00:35:29,036
of Service of that thread that
it is currently running at.


725
00:35:29,036 --> 00:35:31,306
So in this example,
if you want to confirm


726
00:35:31,306 --> 00:35:33,806
that you have correctly
adopted Utility Quality


727
00:35:33,806 --> 00:35:36,576
of Service class, this would
provide that confirmation


728
00:35:36,576 --> 00:35:38,396
since we see most
of the CPU time


729
00:35:38,596 --> 00:35:41,396
in the overall graph is actually
in that thread that was running


730
00:35:41,396 --> 00:35:43,326
at Utility Quality of Service.


731
00:35:43,426 --> 00:35:48,346
Next up, Xcode 6
CPU debugging --


732
00:35:48,346 --> 00:35:49,816
you may have seen
this on Monday.


733
00:35:50,196 --> 00:35:52,746
It's a really exciting feature
that hopefully will help


734
00:35:52,746 --> 00:35:54,546
out a lot with debugging
asynchronous code.


735
00:35:55,656 --> 00:36:00,066
Not only does the Xcode
debugger now show back traces


736
00:36:00,066 --> 00:36:02,896
from the currently running
code, which in the case


737
00:36:02,896 --> 00:36:05,696
of an asynchronously-executed
block isn't always


738
00:36:05,696 --> 00:36:06,876
as helpful as it could be.


739
00:36:06,916 --> 00:36:13,326
It will also stitch in the
back trace that was captured


740
00:36:13,326 --> 00:36:14,436
when the block was enqueued.


741
00:36:14,626 --> 00:36:18,716
So this shows you a past
historical back trace of when


742
00:36:18,716 --> 00:36:20,176
that block was submitted
to the queue,


743
00:36:20,906 --> 00:36:24,136
and you can distinguish the two
halves by seeing that the icons


744
00:36:24,136 --> 00:36:26,806
for the currently live
back trace are colored


745
00:36:26,866 --> 00:36:29,966
and the historically-captured
back traces


746
00:36:30,456 --> 00:36:36,306
from the enqueue event
are colored on gray.


747
00:36:36,536 --> 00:36:40,006
In addition to showing you
currently running blocks,


748
00:36:40,306 --> 00:36:45,076
the queue view of the debugger
can also show you the set


749
00:36:45,076 --> 00:36:46,366
of enqueued blocks on a queue.


750
00:36:46,916 --> 00:36:49,376
So these are things that are not
running yet but will be running


751
00:36:49,376 --> 00:36:52,306
on that queue in the future,
which sometimes other source


752
00:36:52,306 --> 00:36:54,666
of something not occurring, and
that can be really difficult


753
00:36:54,666 --> 00:36:56,416
to track down if you don't
have something like this.


754
00:36:56,986 --> 00:37:01,286
So here, it will also show you
how many pending blocks exist


755
00:37:01,286 --> 00:37:03,916
on this queue, and
for each of the blocks


756
00:37:03,916 --> 00:37:05,706
if you just close the
triangle we can see


757
00:37:05,706 --> 00:37:06,846
where that block was enqueued.


758
00:37:07,956 --> 00:37:11,306
Finally, a really exciting
feature we're introducing this


759
00:37:11,306 --> 00:37:13,536
year called Activity Tracing
that I've mentioned already.


760
00:37:13,996 --> 00:37:15,186
It was covered this morning.


761
00:37:15,706 --> 00:37:19,976
Just a quick reference,
this will allow you


762
00:37:19,976 --> 00:37:24,066
to have additional
information about asynchronous


763
00:37:24,126 --> 00:37:26,046
or past events in
your crash reports.


764
00:37:26,516 --> 00:37:31,106
You're adding concept
of bread crumb trails


765
00:37:31,106 --> 00:37:33,886
which are past high-level
events that occurred leading


766
00:37:33,886 --> 00:37:35,106
up to the point of the crash,


767
00:37:35,456 --> 00:37:36,736
directing into your
crash report,


768
00:37:36,736 --> 00:37:39,426
as well as the Activity ID.


769
00:37:39,426 --> 00:37:42,346
This is the Activity ID that
I was talking about before


770
00:37:42,346 --> 00:37:44,446
in being tracked in
the execution context.


771
00:37:44,446 --> 00:37:49,416
That is also available directly
in your crash report along


772
00:37:49,416 --> 00:37:51,096
with the meta data
associated to it,


773
00:37:51,466 --> 00:37:55,496
and in particular the most
interesting part, trace messages


774
00:37:55,496 --> 00:37:58,186
for that activity scoped
to that specific activity


775
00:37:58,186 --> 00:38:01,536
from both the crashing
process and any processes


776
00:38:01,536 --> 00:38:05,296
that the activity has propagated
to by this propagation


777
00:38:05,296 --> 00:38:07,006
of execution context
that we talked about.


778
00:38:07,516 --> 00:38:11,196
And this is also available
directly in the debugger when,


779
00:38:11,486 --> 00:38:14,176
say in this case, you have
crashed with the sync abort.


780
00:38:14,176 --> 00:38:16,776
You can type the thread
info command and see


781
00:38:16,776 --> 00:38:19,496
that there was an activity
present, with its name


782
00:38:19,496 --> 00:38:22,826
and 5 messages, and it will
show you the meta data,


783
00:38:22,826 --> 00:38:25,756
the bread crumb, and those
trace messages directly


784
00:38:25,756 --> 00:38:26,236
in the debugger.


785
00:38:26,316 --> 00:38:28,116
So this can be a
really powerful way


786
00:38:28,116 --> 00:38:31,096
of debugging asynchronous
code as well


787
00:38:31,096 --> 00:38:33,646
by inserting trace message
the system keeps for you


788
00:38:33,646 --> 00:38:37,866
and displays to you when you
crash in the same activity


789
00:38:38,136 --> 00:38:39,286
that we've propagated for you.


790
00:38:42,516 --> 00:38:45,766
So in summary, we went
over some background,


791
00:38:46,026 --> 00:38:49,686
then talked about Quality of
Service Classes, the new concept


792
00:38:49,686 --> 00:38:51,116
that we're introducing
this year,


793
00:38:51,116 --> 00:38:54,256
and then the APIs surrounding
that, as well as the propagation


794
00:38:54,256 --> 00:38:57,326
of Quality of Service and
Execution Context across threads


795
00:38:57,326 --> 00:39:01,696
and processes, and finally some
exciting news about diagnostics


796
00:39:01,726 --> 00:39:04,476
and queue debugging that
we're introducing this year.


797
00:39:05,596 --> 00:39:08,706
For more information,
please see Paul Danbold,


798
00:39:08,706 --> 00:39:10,406
our Core OS Technologies
Evangelist,


799
00:39:11,336 --> 00:39:14,436
and the documentation on
GCD on the developers site,


800
00:39:14,436 --> 00:39:17,046
as well as all the
related sessions


801
00:39:17,046 --> 00:39:19,996
that have already occurred
this week, in particular,


802
00:39:20,396 --> 00:39:23,016
the Writing Energy Efficient
Code Part 1 session went


803
00:39:23,016 --> 00:39:25,286
into more detail on
Quality of Service


804
00:39:25,286 --> 00:39:26,826
with different set of examples.


805
00:39:27,326 --> 00:39:29,096
If you would like
more information


806
00:39:29,096 --> 00:39:31,906
on that please see that,
as well as the Debugging


807
00:39:32,116 --> 00:39:34,446
in Xcode session,
view the live demo


808
00:39:34,446 --> 00:39:35,686
of the queue debugging feature,


809
00:39:36,186 --> 00:39:38,466
and provides some more
information on that as well.


810
00:39:39,246 --> 00:39:42,126
The Fix Bugs Faster using
Activity Tracing session


811
00:39:42,126 --> 00:39:45,356
of this morning goes into lots
of detail about that Activity ID


812
00:39:45,356 --> 00:39:50,526
and Activity Tracing mechanism
that you saw, and that is it.


813
00:39:50,636 --> 00:39:50,986
Thank you.


814
00:39:51,916 --> 00:39:58,610
[ Applause ]

