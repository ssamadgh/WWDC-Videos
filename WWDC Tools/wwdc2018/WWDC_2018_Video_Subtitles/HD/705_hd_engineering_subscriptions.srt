1
00:00:07,516 --> 00:00:15,500
[ Music ]


2
00:00:23,106 --> 00:00:23,726
>> Good afternoon.


3
00:00:24,516 --> 00:00:29,956
[ Applause ]


4
00:00:30,456 --> 00:00:31,466
My name is Pete Hare and I'm an


5
00:00:31,466 --> 00:00:32,846
engineering manager on the App


6
00:00:32,846 --> 00:00:33,776
Store team here at Apple.


7
00:00:34,286 --> 00:00:35,836
We're here to discuss the best


8
00:00:35,836 --> 00:00:37,176
ways to build your app and


9
00:00:37,176 --> 00:00:39,026
server infrastructure to support


10
00:00:39,026 --> 00:00:39,806
the subscriptions.


11
00:00:40,286 --> 00:00:41,446
I'm going to go over a few


12
00:00:41,446 --> 00:00:42,206
topics here today.


13
00:00:42,796 --> 00:00:43,956
Firstly, we'll discuss the best


14
00:00:43,956 --> 00:00:45,226
ways to actually build your app


15
00:00:45,306 --> 00:00:46,276
and server architecture.


16
00:00:47,106 --> 00:00:48,066
We've got some tips and tricks


17
00:00:48,066 --> 00:00:49,716
around how to enhance the in-app


18
00:00:49,716 --> 00:00:50,776
experience for your user.


19
00:00:52,186 --> 00:00:53,226
My colleague Michael will get up


20
00:00:53,226 --> 00:00:54,806
and talk a bit about reducing


21
00:00:54,856 --> 00:00:55,596
subscriber churn.


22
00:00:55,596 --> 00:00:57,886
And then finally, we've got some


23
00:00:57,886 --> 00:00:58,896
new announcements around


24
00:00:58,896 --> 00:01:00,226
analytics and reporting tools


25
00:01:00,266 --> 00:01:01,036
available to you.


26
00:01:02,246 --> 00:01:03,456
But first up let's talk a bit


27
00:01:03,456 --> 00:01:04,906
about how to build your app and


28
00:01:04,906 --> 00:01:05,856
server infrastructure.


29
00:01:07,406 --> 00:01:08,456
Let's start off by asking a


30
00:01:08,516 --> 00:01:10,776
simple question, what is a


31
00:01:10,776 --> 00:01:11,286
subscription?


32
00:01:12,626 --> 00:01:14,216
Well a subscription gives a user


33
00:01:14,366 --> 00:01:15,406
access to your content or


34
00:01:15,406 --> 00:01:17,026
service by them repeatedly


35
00:01:17,026 --> 00:01:18,476
paying you some amount of money.


36
00:01:19,176 --> 00:01:19,926
When you look at this at the


37
00:01:19,926 --> 00:01:21,596
engineering layer a subscription


38
00:01:21,596 --> 00:01:22,946
is really just a set of


39
00:01:22,946 --> 00:01:24,666
repeating transactions each of


40
00:01:24,666 --> 00:01:26,796
which unlock some subscription


41
00:01:26,866 --> 00:01:27,266
period.


42
00:01:28,576 --> 00:01:30,276
To use subscriptions in your app


43
00:01:30,646 --> 00:01:31,366
there's a couple of things that


44
00:01:31,366 --> 00:01:32,696
you need to do as a developer to


45
00:01:32,696 --> 00:01:33,516
be able to handle these


46
00:01:33,516 --> 00:01:34,766
transactions as they come in.


47
00:01:35,436 --> 00:01:36,216
Let's go through each of these


48
00:01:36,216 --> 00:01:36,566
steps.


49
00:01:36,566 --> 00:01:39,156
Firstly, it starts off with your


50
00:01:39,156 --> 00:01:40,616
app receiving a transaction.


51
00:01:42,056 --> 00:01:42,866
Once your app has received a


52
00:01:42,866 --> 00:01:44,166
transaction you need to go ahead


53
00:01:44,166 --> 00:01:45,226
and verify that it's an


54
00:01:45,226 --> 00:01:46,646
authentic transaction, that


55
00:01:46,646 --> 00:01:48,186
money really has changed hands.


56
00:01:49,466 --> 00:01:51,376
Then it's up to you to update


57
00:01:51,376 --> 00:01:52,466
and maintain that user's


58
00:01:52,466 --> 00:01:54,196
subscription state for ongoing


59
00:01:54,196 --> 00:01:55,766
access to your service.


60
00:01:56,656 --> 00:01:57,786
So let's go into each of these


61
00:01:57,786 --> 00:01:58,656
in a little more detail.


62
00:01:58,656 --> 00:02:00,306
Firstly, let's talk a bit about


63
00:02:00,306 --> 00:02:01,826
receiving that transaction in


64
00:02:01,826 --> 00:02:02,726
your app.


65
00:02:03,756 --> 00:02:05,376
Now whether it's the initial


66
00:02:05,426 --> 00:02:06,966
purchase of a subscription or a


67
00:02:06,966 --> 00:02:08,306
renewal transaction for a


68
00:02:08,306 --> 00:02:10,916
prescription your app is set up


69
00:02:10,916 --> 00:02:12,166
to handle subscriptions and


70
00:02:12,166 --> 00:02:13,376
transactions using the StoreKit


71
00:02:13,426 --> 00:02:13,766
framework.


72
00:02:14,766 --> 00:02:15,636
Now when you are set up to


73
00:02:15,636 --> 00:02:16,676
handle transactions using


74
00:02:16,676 --> 00:02:18,696
StoreKit the App Store will make


75
00:02:18,696 --> 00:02:20,276
these charges on a user's credit


76
00:02:20,276 --> 00:02:21,216
card in the background.


77
00:02:21,726 --> 00:02:23,226
And anytime a transaction occurs


78
00:02:23,226 --> 00:02:24,836
it informs your app of these


79
00:02:24,836 --> 00:02:26,286
transactions via a thing called


80
00:02:26,346 --> 00:02:26,466
the


81
00:02:26,516 --> 00:02:28,196
SKPaymentTransactionsObserver.


82
00:02:28,906 --> 00:02:31,496
This transaction observer object


83
00:02:31,496 --> 00:02:32,866
is really the central piece of


84
00:02:32,866 --> 00:02:34,456
in-app purchases when it comes


85
00:02:34,456 --> 00:02:35,626
to your application.


86
00:02:35,836 --> 00:02:37,156
It's actually just a protocol in


87
00:02:37,156 --> 00:02:38,556
StoreKit, it looks like this and


88
00:02:38,556 --> 00:02:39,836
you can set it on any object.


89
00:02:40,336 --> 00:02:41,206
In this example we're just


90
00:02:41,206 --> 00:02:42,266
setting it on the AppDelegate


91
00:02:42,266 --> 00:02:44,636
itself, but the really important


92
00:02:44,636 --> 00:02:45,376
thing is that you add a


93
00:02:45,466 --> 00:02:46,706
Transaction Observer to the


94
00:02:46,706 --> 00:02:48,106
default payment queue as early


95
00:02:48,106 --> 00:02:49,586
on in the application lifecycle


96
00:02:49,586 --> 00:02:50,106
as possible.


97
00:02:51,516 --> 00:02:52,586
Once you've got a Transaction


98
00:02:53,026 --> 00:02:54,066
Observer registered on the


99
00:02:54,066 --> 00:02:55,086
default payment queue you're


100
00:02:55,086 --> 00:02:56,156
ready to start receiving


101
00:02:56,156 --> 00:02:57,906
transactions as they occur in


102
00:02:58,836 --> 00:02:59,946
the background.


103
00:02:59,946 --> 00:03:01,296
You receive transactions on a


104
00:03:01,296 --> 00:03:02,466
callback in the Transaction


105
00:03:02,466 --> 00:03:03,056
Observed called


106
00:03:03,126 --> 00:03:05,316
updatedTransactions and it's


107
00:03:05,316 --> 00:03:06,976
here that StoreKit will inform


108
00:03:06,976 --> 00:03:08,196
your app of a set of


109
00:03:08,196 --> 00:03:09,706
transactions for you to process.


110
00:03:09,996 --> 00:03:11,126
They can come in various


111
00:03:11,126 --> 00:03:11,986
different states that we're not


112
00:03:11,986 --> 00:03:13,106
going to go completely into in


113
00:03:13,106 --> 00:03:14,556
this talk, but keep an eye out


114
00:03:14,556 --> 00:03:15,606
for a transaction in the


115
00:03:15,726 --> 00:03:16,546
purchased state.


116
00:03:17,266 --> 00:03:18,126
That's a transaction that


117
00:03:18,126 --> 00:03:19,996
StoreKit is telling your app is


118
00:03:19,996 --> 00:03:21,436
ready for verification and


119
00:03:21,436 --> 00:03:21,766
unlocking.


120
00:03:21,766 --> 00:03:25,726
Once you've got a transaction


121
00:03:25,726 --> 00:03:26,606
the purchase state you're ready


122
00:03:26,606 --> 00:03:27,826
to go with that next step, which


123
00:03:27,826 --> 00:03:29,356
is to verify that it is an


124
00:03:29,356 --> 00:03:30,366
authentic transaction.


125
00:03:30,906 --> 00:03:33,826
So when it comes to checking for


126
00:03:33,826 --> 00:03:34,936
authenticity how can you know


127
00:03:34,936 --> 00:03:36,086
that money really has changed


128
00:03:37,016 --> 00:03:37,176
hands?


129
00:03:37,696 --> 00:03:38,826
You use a thing called the App


130
00:03:38,826 --> 00:03:39,396
Store receipt.


131
00:03:40,526 --> 00:03:41,446
The App Store receipt is just


132
00:03:41,446 --> 00:03:42,716
like a receipt you'd get in a


133
00:03:42,716 --> 00:03:43,896
department store, it's a proof


134
00:03:43,896 --> 00:03:45,066
of purchase that a user has


135
00:03:45,296 --> 00:03:46,436
bought something that they say


136
00:03:46,436 --> 00:03:46,836
they've bought.


137
00:03:46,836 --> 00:03:48,726
In this case it's a trusted


138
00:03:48,726 --> 00:03:50,146
record of the initial app


139
00:03:50,196 --> 00:03:51,266
download and any in-app


140
00:03:51,346 --> 00:03:52,796
purchases that have occurred for


141
00:03:52,796 --> 00:03:53,166
this app.


142
00:03:54,606 --> 00:03:55,706
This is a digital document, it's


143
00:03:55,706 --> 00:03:57,286
stored on the user's device, we


144
00:03:57,286 --> 00:03:58,756
provide an API for you to access


145
00:03:58,756 --> 00:04:00,576
it and it's put there by the App


146
00:04:00,576 --> 00:04:00,846
Store.


147
00:04:02,376 --> 00:04:04,216
We also sign this document using


148
00:04:04,436 --> 00:04:05,376
certificates so that you can


149
00:04:05,376 --> 00:04:06,866
check to make sure that it is an


150
00:04:06,866 --> 00:04:07,836
authentic document that's


151
00:04:08,226 --> 00:04:09,356
actually issued by Apple.


152
00:04:10,576 --> 00:04:12,096
And finally, the document is for


153
00:04:12,096 --> 00:04:13,976
your app on that device only.


154
00:04:14,166 --> 00:04:14,946
So if you've worked with


155
00:04:14,946 --> 00:04:16,586
subscriptions before you'll


156
00:04:16,586 --> 00:04:18,096
notice that maybe one user with


157
00:04:18,096 --> 00:04:20,366
multiple devices has receipts


158
00:04:20,366 --> 00:04:21,346
that look slightly different on


159
00:04:21,346 --> 00:04:21,946
each device.


160
00:04:21,946 --> 00:04:24,836
When it comes to actually


161
00:04:24,836 --> 00:04:26,276
verifying this transaction that


162
00:04:26,276 --> 00:04:27,636
your app's been told about the


163
00:04:27,636 --> 00:04:28,506
first step that you need to do


164
00:04:28,506 --> 00:04:29,556
is to actually verify that the


165
00:04:29,616 --> 00:04:30,916
document in question, the App


166
00:04:30,916 --> 00:04:32,106
Store receipt, is authentic.


167
00:04:32,476 --> 00:04:33,106
So how do you do that?


168
00:04:33,656 --> 00:04:36,206
You can do this in two ways.


169
00:04:36,206 --> 00:04:37,406
Firstly, you can use on-device


170
00:04:37,406 --> 00:04:39,296
validation and this is where


171
00:04:39,536 --> 00:04:40,806
directly on the user's device


172
00:04:40,806 --> 00:04:41,846
you can use a series of checks


173
00:04:41,916 --> 00:04:43,556
to check the certificates used


174
00:04:43,556 --> 00:04:45,216
to sign this app and verify that


175
00:04:45,216 --> 00:04:45,766
it's authentic.


176
00:04:46,286 --> 00:04:47,536
Or you can use the technique


177
00:04:47,536 --> 00:04:48,296
called server-to-server


178
00:04:48,296 --> 00:04:48,836
validation.


179
00:04:49,746 --> 00:04:50,776
This second technique is where


180
00:04:50,776 --> 00:04:52,486
you take that binary encoded


181
00:04:52,486 --> 00:04:54,276
receipt data, send it up to your


182
00:04:54,276 --> 00:04:55,676
own server, and then from your


183
00:04:55,676 --> 00:04:57,066
server over to the App Store for


184
00:04:57,106 --> 00:04:57,606
processing.


185
00:04:57,606 --> 00:04:59,066
And the App Store will actually


186
00:04:59,066 --> 00:05:00,196
do those checks for you.


187
00:05:00,776 --> 00:05:03,136
You can use either of these


188
00:05:03,136 --> 00:05:04,646
techniques, but whichever one


189
00:05:04,646 --> 00:05:05,816
you choose it's important not to


190
00:05:05,816 --> 00:05:07,256
use online validation directly


191
00:05:07,256 --> 00:05:08,826
from the user's device, this is


192
00:05:08,826 --> 00:05:10,076
not a secure way of actually


193
00:05:10,306 --> 00:05:11,656
validating this document is


194
00:05:11,656 --> 00:05:12,096
authentic.


195
00:05:13,096 --> 00:05:14,256
But let's compare each of these


196
00:05:14,256 --> 00:05:15,396
two approaches in a little more


197
00:05:15,396 --> 00:05:16,536
detail, especially around


198
00:05:16,536 --> 00:05:17,736
subscription management and


199
00:05:17,736 --> 00:05:19,166
order renewable subscriptions.


200
00:05:20,466 --> 00:05:21,466
Both of these techniques give


201
00:05:21,466 --> 00:05:23,086
you a way to validate that this


202
00:05:23,136 --> 00:05:24,206
is an authentic document.


203
00:05:25,636 --> 00:05:26,696
They also give you access to the


204
00:05:26,696 --> 00:05:27,766
contents of the receipt, any


205
00:05:27,766 --> 00:05:29,356
transactions that have occurred


206
00:05:29,356 --> 00:05:30,416
for this particular user.


207
00:05:31,436 --> 00:05:32,306
But when it comes to auto


208
00:05:32,306 --> 00:05:33,426
renewable subscriptions there's


209
00:05:33,456 --> 00:05:34,716
a few key advantages that


210
00:05:34,786 --> 00:05:35,836
server-to-server receipt


211
00:05:35,836 --> 00:05:37,096
validation actually gives you


212
00:05:37,376 --> 00:05:38,396
over on-device receipt


213
00:05:38,396 --> 00:05:38,886
validation.


214
00:05:39,496 --> 00:05:40,496
Firstly, we include some


215
00:05:40,496 --> 00:05:41,686
additional subscription


216
00:05:41,686 --> 00:05:43,676
information in the response to


217
00:05:43,966 --> 00:05:44,976
that validation check.


218
00:05:45,406 --> 00:05:46,786
You can use this, Michael will


219
00:05:46,786 --> 00:05:47,526
talk about a little later in


220
00:05:47,526 --> 00:05:47,886
this talk.


221
00:05:47,886 --> 00:05:51,126
Your server is always on to


222
00:05:51,126 --> 00:05:51,906
handle those renewal


223
00:05:51,906 --> 00:05:53,206
transactions in the background.


224
00:05:53,206 --> 00:05:54,166
This is really important if


225
00:05:54,166 --> 00:05:55,476
you've got a service with maybe


226
00:05:55,476 --> 00:05:56,416
multiple platforms.


227
00:05:56,946 --> 00:05:59,676
Your server is not susceptible


228
00:05:59,716 --> 00:06:01,106
to a device clock change.


229
00:06:01,786 --> 00:06:02,996
If you're using on-device


230
00:06:02,996 --> 00:06:03,946
receipt validation for


231
00:06:03,946 --> 00:06:05,246
subscription management on the


232
00:06:05,246 --> 00:06:06,256
user's device there's actually


233
00:06:06,256 --> 00:06:07,306
nothing stopping the user from


234
00:06:07,536 --> 00:06:08,656
winding their clock back and


235
00:06:08,886 --> 00:06:10,216
putting themselves into a valid


236
00:06:10,216 --> 00:06:11,336
subscription period, maybe a


237
00:06:11,426 --> 00:06:12,996
free trial that they've actually


238
00:06:12,996 --> 00:06:14,206
lapsed their subscription from.


239
00:06:14,796 --> 00:06:17,396
And finally, it's just a little


240
00:06:17,466 --> 00:06:17,756
simpler.


241
00:06:18,616 --> 00:06:19,986
The server-to-server validation


242
00:06:19,986 --> 00:06:21,046
you're dealing with JSON API,


243
00:06:21,046 --> 00:06:23,506
you don't have to build OpenSSL


244
00:06:23,506 --> 00:06:24,956
or use ASN.1 decoding.


245
00:06:24,956 --> 00:06:26,526
So with all these things in mind


246
00:06:26,526 --> 00:06:27,556
we're really encouraging more


247
00:06:27,556 --> 00:06:28,516
and more people to actually


248
00:06:28,516 --> 00:06:29,636
adopt server-to-server


249
00:06:29,636 --> 00:06:30,896
validation when it comes to


250
00:06:30,896 --> 00:06:32,486
maintaining an auto renewable


251
00:06:32,486 --> 00:06:33,346
subscription state.


252
00:06:34,526 --> 00:06:36,436
If you've got a simple utility


253
00:06:36,436 --> 00:06:37,506
app that doesn't need any kind


254
00:06:37,506 --> 00:06:38,976
of networking you can still use


255
00:06:38,976 --> 00:06:40,186
on-device validation for


256
00:06:40,376 --> 00:06:41,316
subscription management.


257
00:06:41,646 --> 00:06:42,246
And if you're interested in


258
00:06:42,246 --> 00:06:43,446
finding more about that I'd


259
00:06:43,446 --> 00:06:44,556
invite you to check out the


260
00:06:44,556 --> 00:06:45,736
video from last year's events


261
00:06:45,836 --> 00:06:47,126
StoreKit Talk where we went into


262
00:06:47,126 --> 00:06:48,466
more detail about on-device


263
00:06:48,466 --> 00:06:49,246
receipt validation.


264
00:06:50,306 --> 00:06:51,336
But for the purposes of this


265
00:06:51,336 --> 00:06:52,356
talk we're really going to focus


266
00:06:52,356 --> 00:06:53,616
more on the server to server


267
00:06:53,616 --> 00:06:55,186
techniques outlined here.


268
00:06:56,256 --> 00:06:57,496
So let's go back to our example


269
00:06:57,496 --> 00:06:58,326
and see how we can use


270
00:06:58,326 --> 00:06:59,536
server-to-server validation for


271
00:06:59,536 --> 00:07:00,386
this transaction that we're


272
00:07:00,426 --> 00:07:00,886
processing.


273
00:07:01,886 --> 00:07:02,956
Back here in our Transaction


274
00:07:02,956 --> 00:07:04,676
Observer you can access that


275
00:07:04,676 --> 00:07:05,946
binary receipt data using the


276
00:07:05,946 --> 00:07:08,486
App Store receipt URL API on the


277
00:07:08,486 --> 00:07:09,066
main bundle.


278
00:07:09,956 --> 00:07:11,046
Once you have this URL you can


279
00:07:11,136 --> 00:07:13,146
pull out the binary data located


280
00:07:13,146 --> 00:07:14,976
at that spot on the file system


281
00:07:15,016 --> 00:07:16,286
and you can pull out that


282
00:07:16,286 --> 00:07:18,066
receiptData and base64Encode and


283
00:07:18,066 --> 00:07:19,406
this will give you a nice string


284
00:07:19,406 --> 00:07:20,576
that you can send up to your own


285
00:07:20,576 --> 00:07:21,586
server for processing.


286
00:07:21,786 --> 00:07:23,386
You might provide some in-app


287
00:07:23,386 --> 00:07:25,156
networking API for the current


288
00:07:25,836 --> 00:07:25,986
user.


289
00:07:26,916 --> 00:07:28,306
When you're sending that data up


290
00:07:28,306 --> 00:07:29,486
to your server for processing


291
00:07:29,486 --> 00:07:30,866
firstly you'll do this securely


292
00:07:30,866 --> 00:07:31,296
obviously.


293
00:07:31,676 --> 00:07:32,616
You can send it up to maybe a


294
00:07:32,616 --> 00:07:34,146
process transaction endpoint on


295
00:07:34,146 --> 00:07:34,586
your server.


296
00:07:35,476 --> 00:07:36,816
In this endpoint you might have


297
00:07:36,816 --> 00:07:38,546
a user ID associated with the


298
00:07:38,546 --> 00:07:40,166
current user for an account on


299
00:07:40,166 --> 00:07:40,736
your own system.


300
00:07:41,786 --> 00:07:42,946
You can send this receipt data


301
00:07:42,946 --> 00:07:44,566
up to your server and then once


302
00:07:44,566 --> 00:07:45,566
you get that on your server you


303
00:07:45,566 --> 00:07:46,506
can establish a secure


304
00:07:46,506 --> 00:07:47,896
connection to the App Store's


305
00:07:47,896 --> 00:07:49,526
verify receipt endpoint.


306
00:07:50,036 --> 00:07:51,376
And you can send over that


307
00:07:51,376 --> 00:07:52,856
receipt data to the App Store.


308
00:07:52,856 --> 00:07:55,546
Here you can include a password


309
00:07:55,546 --> 00:07:56,666
field, this is just a shared


310
00:07:56,666 --> 00:07:58,526
secret between your app and the


311
00:07:58,526 --> 00:07:59,006
App Store.


312
00:07:59,006 --> 00:08:00,176
You can set this up in App Store


313
00:08:00,176 --> 00:08:01,416
Connect and store it on your


314
00:08:01,416 --> 00:08:01,696
server.


315
00:08:03,086 --> 00:08:04,206
And when you send this receipt


316
00:08:04,206 --> 00:08:05,556
data to the verify receipt


317
00:08:05,556 --> 00:08:06,946
endpoint the verify receipt


318
00:08:06,946 --> 00:08:08,406
endpoint will respond with JSON


319
00:08:08,406 --> 00:08:10,546
payload that looks a little like


320
00:08:11,496 --> 00:08:11,596
this.


321
00:08:11,816 --> 00:08:13,336
The first thing to check when


322
00:08:13,336 --> 00:08:14,326
you're verifying that this


323
00:08:14,326 --> 00:08:15,666
transaction is authentic is this


324
00:08:15,836 --> 00:08:16,476
status field.


325
00:08:17,236 --> 00:08:18,476
This is an indication that Apple


326
00:08:18,476 --> 00:08:19,706
has actually issued this


327
00:08:19,706 --> 00:08:20,876
document in the first place.


328
00:08:21,766 --> 00:08:22,886
Once you've verified that the


329
00:08:22,886 --> 00:08:24,486
status is zero like this you can


330
00:08:24,486 --> 00:08:25,346
check the contents of the


331
00:08:25,346 --> 00:08:27,676
receipt portion of this payload.


332
00:08:27,986 --> 00:08:29,236
This is the decoded version of


333
00:08:29,236 --> 00:08:30,496
that binary data that you just


334
00:08:30,556 --> 00:08:32,385
sent to verify receipt endpoint.


335
00:08:32,385 --> 00:08:33,645
So in here you can do things


336
00:08:33,645 --> 00:08:35,336
like verify that the bundle ID


337
00:08:35,336 --> 00:08:37,426
in this receipt matches your


338
00:08:37,426 --> 00:08:38,246
app's bundle ID.


339
00:08:39,076 --> 00:08:40,446
And then you can inspect the


340
00:08:40,446 --> 00:08:42,326
in-app array, this contains a


341
00:08:42,326 --> 00:08:43,556
list of transactions for this


342
00:08:43,556 --> 00:08:45,156
particular user for your app.


343
00:08:45,156 --> 00:08:46,596
And you can verify that the


344
00:08:46,596 --> 00:08:49,356
product ID associated with this


345
00:08:49,356 --> 00:08:50,846
receipt is the one associated


346
00:08:50,846 --> 00:08:51,296
with your app.


347
00:08:52,566 --> 00:08:53,886
So assuming that these all match


348
00:08:54,476 --> 00:08:55,856
you're determining that this


349
00:08:55,856 --> 00:08:57,326
receipt entitles this particular


350
00:08:57,326 --> 00:08:58,676
user to your subscription


351
00:08:58,676 --> 00:08:59,986
product you're ready to go ahead


352
00:08:59,986 --> 00:09:01,096
now with that third step,


353
00:09:01,756 --> 00:09:02,806
updating the user's subscription


354
00:09:02,806 --> 00:09:02,926
state.


355
00:09:07,516 --> 00:09:08,476
Now in the same way that each


356
00:09:08,476 --> 00:09:10,166
subscription period starts with


357
00:09:10,166 --> 00:09:12,206
a transaction it also ends with


358
00:09:12,206 --> 00:09:13,086
an expiry date.


359
00:09:14,116 --> 00:09:15,516
And the response from verify


360
00:09:15,516 --> 00:09:17,456
receipt tells us each of these


361
00:09:17,456 --> 00:09:18,796
expiry dates for each


362
00:09:18,876 --> 00:09:19,476
transaction.


363
00:09:19,536 --> 00:09:21,426
So looking back at this response


364
00:09:21,426 --> 00:09:22,776
from verify receipt you'll


365
00:09:22,776 --> 00:09:24,086
notice that there's this expires


366
00:09:24,116 --> 00:09:25,766
date field in the transaction


367
00:09:25,766 --> 00:09:26,476
and the response.


368
00:09:27,746 --> 00:09:29,036
Let's bring up the user table


369
00:09:29,036 --> 00:09:30,266
now that you might be saving


370
00:09:30,266 --> 00:09:31,356
this data on your server.


371
00:09:33,026 --> 00:09:34,346
You can take this expires date


372
00:09:34,346 --> 00:09:35,526
from this transaction and


373
00:09:35,526 --> 00:09:36,776
actually populate this into a


374
00:09:36,776 --> 00:09:38,276
field on your own server, maybe


375
00:09:38,276 --> 00:09:39,766
the latest expires date field


376
00:09:39,796 --> 00:09:40,686
for this particular user.


377
00:09:40,976 --> 00:09:42,446
And this field is going to


378
00:09:42,446 --> 00:09:44,206
become the new source of truth


379
00:09:44,206 --> 00:09:45,326
on your server for whether or


380
00:09:45,326 --> 00:09:46,976
not this user is a subscriber.


381
00:09:48,386 --> 00:09:49,026
While you're here you should


382
00:09:49,026 --> 00:09:50,606
also keep track of this other


383
00:09:50,606 --> 00:09:51,936
field, original transaction ID,


384
00:09:51,936 --> 00:09:53,736
and you can save that in the


385
00:09:53,736 --> 00:09:54,556
field called original


386
00:09:54,556 --> 00:09:55,846
transaction ID against this


387
00:09:55,886 --> 00:09:56,866
current user as well.


388
00:09:56,986 --> 00:09:57,966
Well come back to this one in


389
00:09:57,966 --> 00:09:58,636
just a moment as to why that's


390
00:09:58,636 --> 00:09:58,976
important.


391
00:10:00,096 --> 00:10:02,496
But once you've saved these two


392
00:10:02,496 --> 00:10:04,036
bits of information against this


393
00:10:04,136 --> 00:10:05,136
current user on your server


394
00:10:05,426 --> 00:10:06,146
you're ready to go ahead with


395
00:10:06,146 --> 00:10:07,636
the last step, which is to tell


396
00:10:07,636 --> 00:10:09,276
the device that this transaction


397
00:10:09,276 --> 00:10:10,066
has actually passed your


398
00:10:10,066 --> 00:10:11,146
verification checks.


399
00:10:11,946 --> 00:10:13,016
And then when your device gets


400
00:10:13,046 --> 00:10:14,756
this callback it can call Finish


401
00:10:14,756 --> 00:10:16,256
Transaction back down in your


402
00:10:16,256 --> 00:10:17,146
Transaction Observer.


403
00:10:18,276 --> 00:10:19,456
This is a really important step


404
00:10:19,456 --> 00:10:20,106
because finishing the


405
00:10:20,106 --> 00:10:21,146
transactional will actually


406
00:10:21,146 --> 00:10:22,606
clear it out of your payment


407
00:10:22,606 --> 00:10:22,866
queue.


408
00:10:22,866 --> 00:10:23,816
And if you don't call Finish


409
00:10:23,816 --> 00:10:25,626
Transaction it might reappear


410
00:10:25,626 --> 00:10:26,516
there the next time the app


411
00:10:26,756 --> 00:10:27,876
launches for processing.


412
00:10:27,946 --> 00:10:28,886
So make sure you finish every


413
00:10:28,886 --> 00:10:31,506
transaction that begins in


414
00:10:32,516 --> 00:10:32,756
StoreKit.


415
00:10:32,856 --> 00:10:33,396
Once you've finished the


416
00:10:33,396 --> 00:10:35,136
transaction you've got an


417
00:10:35,136 --> 00:10:36,236
updated subscription state in


418
00:10:36,236 --> 00:10:37,226
your server, the user is now


419
00:10:37,336 --> 00:10:38,896
free to enjoy that subscription


420
00:10:38,896 --> 00:10:40,136
period on your service.


421
00:10:43,176 --> 00:10:44,106
Now let's take another look at


422
00:10:44,106 --> 00:10:45,486
that user table I mentioned that


423
00:10:45,486 --> 00:10:46,506
you're storing on your server.


424
00:10:47,846 --> 00:10:48,966
Each user who purchases a


425
00:10:48,966 --> 00:10:50,396
subscription using this setup


426
00:10:50,396 --> 00:10:51,556
will be assigned a unique


427
00:10:51,726 --> 00:10:53,286
original transaction ID, that's


428
00:10:53,286 --> 00:10:55,046
that field that you saved from


429
00:10:55,046 --> 00:10:56,216
the transaction response.


430
00:10:56,896 --> 00:10:58,186
And this identifier essentially


431
00:10:58,186 --> 00:10:59,716
becomes that user's subscription


432
00:10:59,946 --> 00:11:00,106
ID.


433
00:11:01,256 --> 00:11:02,206
And it's important because it


434
00:11:02,206 --> 00:11:03,436
shows up in all subsequent


435
00:11:03,436 --> 00:11:04,786
renewal transactions.


436
00:11:05,136 --> 00:11:06,456
Let's take a look at how this


437
00:11:06,456 --> 00:11:06,796
works.


438
00:11:07,206 --> 00:11:07,746
So let's say that you're


439
00:11:07,746 --> 00:11:09,366
verifying a renewal transaction,


440
00:11:09,676 --> 00:11:10,646
this happens in just the same


441
00:11:10,646 --> 00:11:11,466
way you might use the same


442
00:11:11,466 --> 00:11:12,996
process transaction endpoint on


443
00:11:12,996 --> 00:11:13,546
your own server.


444
00:11:14,716 --> 00:11:16,236
When you do those techniques of


445
00:11:16,236 --> 00:11:18,186
verifying the transactions a


446
00:11:18,186 --> 00:11:19,736
valid one, and you get up to


447
00:11:19,736 --> 00:11:20,806
that stage of updating the


448
00:11:20,806 --> 00:11:22,766
user's subscription state you'll


449
00:11:22,766 --> 00:11:23,686
observe here that there's now


450
00:11:23,686 --> 00:11:25,216
multiple transactions since this


451
00:11:25,216 --> 00:11:26,556
is a renewal transaction.


452
00:11:27,976 --> 00:11:29,766
Now according to your existing


453
00:11:29,766 --> 00:11:31,576
server-side logic this latest


454
00:11:31,576 --> 00:11:32,836
expires date is now a date in


455
00:11:32,836 --> 00:11:34,296
the past, so the user is not


456
00:11:34,396 --> 00:11:35,516
currently a subscriber and you


457
00:11:35,516 --> 00:11:36,726
need to figure out are they


458
00:11:36,726 --> 00:11:38,306
still a subscriber based on the


459
00:11:38,306 --> 00:11:39,206
data in this receipt.


460
00:11:40,126 --> 00:11:41,926
So how can you use this receipt


461
00:11:41,926 --> 00:11:43,656
data and make that deduction?


462
00:11:43,886 --> 00:11:46,026
Well for discovering whether or


463
00:11:46,026 --> 00:11:47,176
not the user has an active


464
00:11:47,176 --> 00:11:48,366
subscription you can pull out


465
00:11:48,366 --> 00:11:50,406
the transactions associated with


466
00:11:50,406 --> 00:11:52,106
that original transaction ID.


467
00:11:53,346 --> 00:11:54,536
And then you can find the


468
00:11:54,536 --> 00:11:55,776
transaction that has the latest


469
00:11:55,806 --> 00:11:56,606
expires date.


470
00:11:57,226 --> 00:11:58,476
Now if you find a date in the


471
00:11:58,476 --> 00:12:00,226
past that's an indication that


472
00:12:00,226 --> 00:12:01,266
this user is no longer a


473
00:12:01,266 --> 00:12:02,176
subscriber anymore.


474
00:12:02,206 --> 00:12:03,616
But if you find a date in the


475
00:12:03,616 --> 00:12:05,186
future that's an indication that


476
00:12:05,186 --> 00:12:06,346
this user is in a valid


477
00:12:06,346 --> 00:12:07,246
subscription period.


478
00:12:08,396 --> 00:12:09,816
So let's look at how this works


479
00:12:09,816 --> 00:12:11,696
in the example that we're going


480
00:12:13,056 --> 00:12:13,156
through.


481
00:12:13,366 --> 00:12:14,836
Grab that original transaction


482
00:12:14,836 --> 00:12:16,986
ID associated with this user and


483
00:12:16,986 --> 00:12:18,536
pull out all the transactions


484
00:12:18,536 --> 00:12:19,336
associated with this


485
00:12:19,336 --> 00:12:19,836
subscription.


486
00:12:20,776 --> 00:12:22,256
Then sort those transactions by


487
00:12:22,256 --> 00:12:24,066
that expires date field and grab


488
00:12:24,066 --> 00:12:25,026
the one that has the latest


489
00:12:25,026 --> 00:12:25,786
expires date.


490
00:12:26,176 --> 00:12:27,516
Now you can take that expires


491
00:12:27,556 --> 00:12:29,436
date and update that latest


492
00:12:29,436 --> 00:12:30,926
expires date field associated


493
00:12:30,926 --> 00:12:31,396
with this user.


494
00:12:31,396 --> 00:12:33,346
And when you do that you're


495
00:12:33,346 --> 00:12:34,486
effectively extending that


496
00:12:34,486 --> 00:12:36,326
user's subscription by another


497
00:12:36,456 --> 00:12:37,626
length of time and your


498
00:12:37,626 --> 00:12:38,956
server-side logic now knows that


499
00:12:38,956 --> 00:12:39,806
the user is in a valid


500
00:12:39,806 --> 00:12:40,576
subscription window.


501
00:12:41,866 --> 00:12:42,696
Of course when you're dealing


502
00:12:42,696 --> 00:12:43,826
with renewal transactions like


503
00:12:43,826 --> 00:12:44,806
this that have come through


504
00:12:44,806 --> 00:12:45,876
StoreKit you still need to


505
00:12:45,876 --> 00:12:47,626
inform the device that it passed


506
00:12:47,706 --> 00:12:48,886
those validation checks.


507
00:12:49,486 --> 00:12:50,646
And have your device, your app


508
00:12:51,086 --> 00:12:52,446
call Finish Transaction back


509
00:12:52,446 --> 00:12:52,976
down in StoreKit again.


510
00:12:57,376 --> 00:12:58,576
So let's say you have this set


511
00:12:58,576 --> 00:12:59,646
up and working correctly.


512
00:13:00,566 --> 00:13:01,456
The App Store is charging the


513
00:13:01,456 --> 00:13:02,276
user's credit card in the


514
00:13:02,276 --> 00:13:03,626
background and you're using


515
00:13:03,626 --> 00:13:05,046
StoreKit to process these


516
00:13:05,046 --> 00:13:06,436
transactions as they come in


517
00:13:06,836 --> 00:13:07,306
through the app.


518
00:13:07,306 --> 00:13:09,086
And then your server is updating


519
00:13:09,086 --> 00:13:10,566
and maintaining this latest


520
00:13:10,566 --> 00:13:12,106
expires date field on your


521
00:13:12,106 --> 00:13:12,436
server.


522
00:13:12,436 --> 00:13:13,706
So you've got that server-side


523
00:13:13,976 --> 00:13:15,176
source of truth as to whether or


524
00:13:15,176 --> 00:13:16,466
not a user is subscribed.


525
00:13:17,746 --> 00:13:18,906
Let's now introduce a slightly


526
00:13:18,906 --> 00:13:20,056
more complex example though to


527
00:13:20,056 --> 00:13:21,236
the mix, which is maybe that you


528
00:13:21,236 --> 00:13:22,236
offer your service through a


529
00:13:22,236 --> 00:13:23,196
website as well.


530
00:13:24,276 --> 00:13:25,956
Now when the user accesses your


531
00:13:25,956 --> 00:13:26,956
subscription service through a


532
00:13:26,956 --> 00:13:29,006
website you know based on that


533
00:13:29,006 --> 00:13:30,156
latest expires date field that


534
00:13:30,156 --> 00:13:31,216
the user is a subscriber.


535
00:13:32,606 --> 00:13:34,006
But as much as we'd like to


536
00:13:34,076 --> 00:13:35,296
think that people use our apps


537
00:13:35,356 --> 00:13:37,296
all the time let's say that the


538
00:13:37,296 --> 00:13:38,266
user doesn't use your app for a


539
00:13:38,266 --> 00:13:39,006
number of days.


540
00:13:39,546 --> 00:13:40,426
And then during this time the


541
00:13:40,426 --> 00:13:41,606
App Store actually successfully


542
00:13:41,606 --> 00:13:43,696
renews a user's subscription in


543
00:13:43,696 --> 00:13:44,226
the background.


544
00:13:45,226 --> 00:13:46,526
When the user tries to access


545
00:13:46,696 --> 00:13:47,496
your servers through your


546
00:13:47,496 --> 00:13:49,716
website that latest expires date


547
00:13:49,716 --> 00:13:50,776
is now out of date because your


548
00:13:50,776 --> 00:13:52,036
server hasn't learned about that


549
00:13:52,036 --> 00:13:52,756
new transaction.


550
00:13:52,826 --> 00:13:54,606
So how can your server know


551
00:13:54,606 --> 00:13:56,036
about this transaction that's


552
00:13:56,036 --> 00:13:59,926
occurred on the App Store?


553
00:14:00,146 --> 00:14:01,116
You use a technique for this


554
00:14:01,116 --> 00:14:02,556
called status polling, this


555
00:14:02,556 --> 00:14:03,886
allows you to discover these


556
00:14:03,886 --> 00:14:05,306
transactions directly from your


557
00:14:05,306 --> 00:14:05,616
server.


558
00:14:06,496 --> 00:14:07,566
In order to get set up to be


559
00:14:07,566 --> 00:14:09,116
able to status poll from your


560
00:14:09,226 --> 00:14:11,316
server you just save a latest


561
00:14:11,316 --> 00:14:12,796
version of that encoded receipt


562
00:14:12,796 --> 00:14:14,796
data that you send up associated


563
00:14:14,796 --> 00:14:15,386
with each user.


564
00:14:16,196 --> 00:14:17,196
And what you can do is you can


565
00:14:17,256 --> 00:14:19,166
treat that encoded data just


566
00:14:19,166 --> 00:14:19,786
like a token.


567
00:14:20,636 --> 00:14:21,666
The reason why it can treat it


568
00:14:21,666 --> 00:14:22,886
like a token is every time you


569
00:14:22,886 --> 00:14:25,216
send up that encoded receipt


570
00:14:25,216 --> 00:14:26,386
data to the verify receipt


571
00:14:26,386 --> 00:14:28,046
endpoint the verify receipt


572
00:14:28,046 --> 00:14:29,536
endpoint doesn't just respond


573
00:14:29,536 --> 00:14:31,256
with a decoded version of that


574
00:14:31,736 --> 00:14:32,986
receipt data, it also includes


575
00:14:32,986 --> 00:14:34,506
any new transactions that have


576
00:14:34,506 --> 00:14:36,166
occurred for this particular


577
00:14:36,166 --> 00:14:37,166
user's subscription.


578
00:14:37,696 --> 00:14:38,816
It's located in a field called


579
00:14:38,816 --> 00:14:40,916
the latest receipt info field in


580
00:14:40,916 --> 00:14:42,106
that JSON response.


581
00:14:42,806 --> 00:14:44,036
And you can use that info to


582
00:14:44,036 --> 00:14:45,406
unlock those new subscription


583
00:14:45,406 --> 00:14:46,956
periods for this particular user


584
00:14:46,956 --> 00:14:48,436
without the app having to launch


585
00:14:48,436 --> 00:14:48,776
at all.


586
00:14:50,046 --> 00:14:50,916
Let's see how this works.


587
00:14:50,916 --> 00:14:52,156
So when you're verifying


588
00:14:52,156 --> 00:14:53,436
transactions just like we saw


589
00:14:53,436 --> 00:14:54,796
before you're sending up that


590
00:14:54,796 --> 00:14:55,396
receipt data.


591
00:14:56,676 --> 00:14:57,976
Now once you've determined that


592
00:14:57,976 --> 00:14:59,966
this transaction in question has


593
00:14:59,966 --> 00:15:01,456
passed those same checks that


594
00:15:01,456 --> 00:15:03,156
you did before you can take that


595
00:15:03,156 --> 00:15:05,186
receipt data and store that in a


596
00:15:05,186 --> 00:15:06,686
field called latest receipt data


597
00:15:06,836 --> 00:15:08,086
against the current user.


598
00:15:09,496 --> 00:15:10,426
And now that you have that


599
00:15:10,426 --> 00:15:11,846
latest receipt data stored,


600
00:15:12,276 --> 00:15:13,956
that's a base64Encode string


601
00:15:14,216 --> 00:15:14,706
with the user.


602
00:15:15,326 --> 00:15:16,296
When it comes time to answer


603
00:15:16,296 --> 00:15:18,156
that question, does my user have


604
00:15:18,156 --> 00:15:19,136
an active subscription you can


605
00:15:19,136 --> 00:15:20,416
just take that latest receipt


606
00:15:20,416 --> 00:15:22,216
data from your server directly


607
00:15:22,216 --> 00:15:23,596
and send it to the verify


608
00:15:23,596 --> 00:15:24,366
receipt endpoint.


609
00:15:25,276 --> 00:15:26,416
You can also include here an


610
00:15:26,416 --> 00:15:28,186
optional flag that's the exclude


611
00:15:28,186 --> 00:15:30,096
old transactions flag, this is


612
00:15:30,096 --> 00:15:31,256
just telling verify receipt that


613
00:15:31,256 --> 00:15:32,026
you don't even want to know


614
00:15:32,026 --> 00:15:33,316
about that decoded version of


615
00:15:33,316 --> 00:15:34,396
the receipt you just want to


616
00:15:34,396 --> 00:15:35,416
find out about any new


617
00:15:35,416 --> 00:15:36,076
transactions.


618
00:15:37,376 --> 00:15:39,456
Verify receipt will respond with


619
00:15:39,456 --> 00:15:41,326
that particular object, the


620
00:15:41,326 --> 00:15:42,646
latest receipt info object.


621
00:15:43,026 --> 00:15:44,506
And inside this object is those


622
00:15:44,506 --> 00:15:45,736
new transactions that have


623
00:15:45,736 --> 00:15:47,316
occurred before this receipt


624
00:15:47,316 --> 00:15:48,296
data was actually generated.


625
00:15:48,296 --> 00:15:50,306
And you can take the expires


626
00:15:50,336 --> 00:15:52,126
date directly from the response


627
00:15:52,796 --> 00:15:53,936
of the latest receipt info


628
00:15:53,936 --> 00:15:56,556
object and update it against the


629
00:15:56,556 --> 00:15:58,266
current user, again extending


630
00:15:58,266 --> 00:15:59,586
them access to that next


631
00:15:59,586 --> 00:16:00,386
subscription window.


632
00:16:00,756 --> 00:16:02,376
And so the user who is on your


633
00:16:02,376 --> 00:16:03,796
website trying to access your


634
00:16:03,796 --> 00:16:05,666
content can now access that next


635
00:16:05,666 --> 00:16:06,956
subscription period all without


636
00:16:06,956 --> 00:16:08,636
the app having to launch with


637
00:16:08,636 --> 00:16:09,646
that new transaction.


638
00:16:10,276 --> 00:16:12,546
If you are using this technique


639
00:16:12,546 --> 00:16:13,466
though status polling it's


640
00:16:13,466 --> 00:16:14,546
important to remember one thing


641
00:16:14,546 --> 00:16:15,456
and that's that when your app


642
00:16:15,566 --> 00:16:16,946
does come back online again


643
00:16:17,256 --> 00:16:19,076
transactions will still appear


644
00:16:19,316 --> 00:16:20,576
through StoreKit in the updated


645
00:16:20,576 --> 00:16:21,556
transactions callback.


646
00:16:21,556 --> 00:16:22,866
And you still should handle


647
00:16:22,866 --> 00:16:24,966
these transactions passing them


648
00:16:24,966 --> 00:16:25,596
up to your server for


649
00:16:25,686 --> 00:16:27,316
verification and finishing them


650
00:16:27,316 --> 00:16:28,546
back down on the user's device


651
00:16:28,546 --> 00:16:29,676
again, even if your server


652
00:16:29,676 --> 00:16:31,316
already knows about them through


653
00:16:31,426 --> 00:16:33,386
a status poll.


654
00:16:33,586 --> 00:16:34,536
We'd encourage you to use that


655
00:16:34,536 --> 00:16:35,916
as an opportunity just to send


656
00:16:35,916 --> 00:16:37,736
up that new latest receipt data


657
00:16:37,736 --> 00:16:39,146
for storage against the current


658
00:16:39,146 --> 00:16:39,936
user on the server.


659
00:16:44,316 --> 00:16:45,646
Now status polling works great


660
00:16:46,096 --> 00:16:47,116
when the user's credit card is


661
00:16:47,116 --> 00:16:49,206
able to be charged, but what if


662
00:16:50,086 --> 00:16:51,266
some subscription period the


663
00:16:51,266 --> 00:16:52,766
user's credit card has some kind


664
00:16:52,766 --> 00:16:54,036
of billing issue and the App


665
00:16:54,036 --> 00:16:55,246
Store isn't able to charge it


666
00:16:55,776 --> 00:16:57,016
for the next subscription


667
00:16:57,016 --> 00:16:57,366
period.


668
00:16:57,996 --> 00:16:59,346
Is this user destined to remain


669
00:16:59,346 --> 00:17:00,756
unsubscribed involuntarily?


670
00:17:01,516 --> 00:17:01,936
Not at all.


671
00:17:03,226 --> 00:17:04,445
When reacting to billing issues


672
00:17:04,445 --> 00:17:05,606
like this you can do three


673
00:17:05,685 --> 00:17:06,476
simple steps.


674
00:17:06,476 --> 00:17:08,136
Firstly, you can observe that


675
00:17:08,136 --> 00:17:09,296
there's been no renewal


676
00:17:09,296 --> 00:17:10,796
transaction for this particular


677
00:17:10,796 --> 00:17:12,455
user, their subscription has now


678
00:17:12,455 --> 00:17:12,796
lapsed.


679
00:17:13,816 --> 00:17:15,766
Secondly, you can direct that


680
00:17:15,766 --> 00:17:17,256
particular user to go and update


681
00:17:17,256 --> 00:17:18,546
their billing info.


682
00:17:19,925 --> 00:17:21,955
And then the third step, when a


683
00:17:21,955 --> 00:17:23,546
renewal transaction occurs


684
00:17:23,876 --> 00:17:25,526
unblock that user immediately


685
00:17:25,756 --> 00:17:26,516
after it happens.


686
00:17:27,286 --> 00:17:28,376
Now, steps one and two are


687
00:17:28,826 --> 00:17:29,826
pretty straightforward using the


688
00:17:29,826 --> 00:17:30,996
status polling techniques that


689
00:17:30,996 --> 00:17:32,286
we just went through, but step


690
00:17:32,286 --> 00:17:34,006
number three here uses a feature


691
00:17:34,006 --> 00:17:35,086
that we actually launched last


692
00:17:35,086 --> 00:17:36,566
year server-to-server


693
00:17:36,566 --> 00:17:37,406
notifications.


694
00:17:38,426 --> 00:17:39,526
Let's walk through this example,


695
00:17:39,526 --> 00:17:40,976
let's say that one subscription


696
00:17:40,976 --> 00:17:42,496
period the App Store has an


697
00:17:42,496 --> 00:17:43,966
error when trying to charge this


698
00:17:43,966 --> 00:17:44,696
user's credit card.


699
00:17:45,356 --> 00:17:47,696
And then you find out about the


700
00:17:47,696 --> 00:17:48,706
fact that there is no new


701
00:17:48,806 --> 00:17:49,886
renewal transaction for this


702
00:17:49,886 --> 00:17:50,936
user through a status poll.


703
00:17:52,136 --> 00:17:53,786
Your server correctly makes the


704
00:17:54,326 --> 00:17:55,416
calculation that this user is


705
00:17:55,416 --> 00:17:56,866
not a subscriber anymore and so


706
00:17:56,866 --> 00:17:57,916
when the user comes along to


707
00:17:57,916 --> 00:17:59,046
access your service through the


708
00:17:59,046 --> 00:18:00,396
website you give them some


709
00:18:00,396 --> 00:18:01,866
appropriate error message about


710
00:18:01,866 --> 00:18:02,806
the fact that their subscription


711
00:18:03,106 --> 00:18:03,986
wasn't able to be renewed.


712
00:18:04,666 --> 00:18:05,726
And you can direct that user to


713
00:18:05,726 --> 00:18:07,526
go and update their billing info


714
00:18:07,636 --> 00:18:08,456
in the App Store.


715
00:18:09,476 --> 00:18:10,826
Now when the user does update


716
00:18:10,826 --> 00:18:11,746
their billing info, maybe they


717
00:18:11,746 --> 00:18:12,966
just need to update an expiry


718
00:18:12,966 --> 00:18:14,676
date or something, two things


719
00:18:14,676 --> 00:18:14,986
happen.


720
00:18:15,916 --> 00:18:17,176
Firstly, the App Store will


721
00:18:17,176 --> 00:18:18,866
actually immediately charge that


722
00:18:18,866 --> 00:18:20,286
user's credit card and make a


723
00:18:20,286 --> 00:18:21,276
successful transaction.


724
00:18:21,806 --> 00:18:22,866
And when the App Store does do


725
00:18:22,866 --> 00:18:24,446
this the second part of what it


726
00:18:24,446 --> 00:18:26,016
does is it sends your server a


727
00:18:26,016 --> 00:18:28,956
direct HTTP post upon the


728
00:18:28,956 --> 00:18:29,786
successful renewal.


729
00:18:29,786 --> 00:18:31,576
And then the payload of this


730
00:18:31,636 --> 00:18:33,876
post includes the new


731
00:18:33,876 --> 00:18:35,016
transaction info for the


732
00:18:35,016 --> 00:18:36,026
transaction that's just


733
00:18:36,026 --> 00:18:36,266
occurred.


734
00:18:37,046 --> 00:18:37,906
You can use that original


735
00:18:37,906 --> 00:18:39,546
transaction ID field located in


736
00:18:39,546 --> 00:18:41,426
the payload to locate which user


737
00:18:41,426 --> 00:18:42,506
this notification is for.


738
00:18:43,346 --> 00:18:44,736
Once you find out which user


739
00:18:44,736 --> 00:18:45,746
you're talking about, well you


740
00:18:45,746 --> 00:18:47,376
can grab that latest expires


741
00:18:47,376 --> 00:18:49,006
date and update it for this new


742
00:18:49,006 --> 00:18:51,166
user giving them access again to


743
00:18:51,166 --> 00:18:52,366
that next subscription period.


744
00:18:52,366 --> 00:18:54,586
And then the user who's probably


745
00:18:54,586 --> 00:18:55,756
still sitting on your website


746
00:18:55,756 --> 00:18:57,056
trying to get access to your


747
00:18:57,056 --> 00:18:59,326
content will be able to


748
00:18:59,326 --> 00:19:01,116
immediately be unlocked since


749
00:19:01,116 --> 00:19:02,886
your server received that push


750
00:19:03,016 --> 00:19:05,716
straight from the App Store.


751
00:19:05,956 --> 00:19:07,416
It's really important to unlock


752
00:19:07,416 --> 00:19:09,076
users in a speedy manner when


753
00:19:09,076 --> 00:19:09,866
this sort of thing happens,


754
00:19:09,866 --> 00:19:10,916
especially when they go to all


755
00:19:10,916 --> 00:19:12,066
that effort for updating their


756
00:19:12,066 --> 00:19:13,866
credit card info manually and


757
00:19:13,866 --> 00:19:14,846
waiting for access to the


758
00:19:14,846 --> 00:19:15,326
servers.


759
00:19:15,626 --> 00:19:16,436
But there's one thing to note


760
00:19:16,436 --> 00:19:17,656
here and that's the notification


761
00:19:17,656 --> 00:19:19,386
is only sent if the subscription


762
00:19:19,386 --> 00:19:20,846
actually lapsed like we just


763
00:19:20,846 --> 00:19:21,166
saw.


764
00:19:22,026 --> 00:19:23,476
To discover successful renewal


765
00:19:23,476 --> 00:19:24,936
transactions you still need to


766
00:19:24,936 --> 00:19:26,036
rely on status polling


767
00:19:26,036 --> 00:19:27,256
techniques we just outlined


768
00:19:27,256 --> 00:19:27,626
before.


769
00:19:28,616 --> 00:19:30,016
But it's really easy to set up


770
00:19:30,016 --> 00:19:30,926
to use server-to-server


771
00:19:30,926 --> 00:19:31,646
notifications.


772
00:19:31,876 --> 00:19:34,096
All you do is enter a URL in App


773
00:19:34,096 --> 00:19:34,506
Store Connect.


774
00:19:35,306 --> 00:19:36,426
This is just an endpoint on your


775
00:19:36,426 --> 00:19:38,146
own server and if you enter it


776
00:19:38,146 --> 00:19:39,746
into App Store Connect the App


777
00:19:39,746 --> 00:19:40,736
Store will begin to send your


778
00:19:40,736 --> 00:19:42,936
server HTTPS posts for these


779
00:19:43,026 --> 00:19:44,056
status change events.


780
00:19:44,466 --> 00:19:45,926
And as we saw included in the


781
00:19:45,926 --> 00:19:47,336
post is that latest transaction


782
00:19:47,376 --> 00:19:49,276
info for the transaction that


783
00:19:49,276 --> 00:19:49,566
triggered it.


784
00:19:50,666 --> 00:19:51,866
You do make sure your server is


785
00:19:51,866 --> 00:19:53,896
ATS in order to receive these,


786
00:19:54,096 --> 00:19:55,186
but it's a really simple step


787
00:19:55,186 --> 00:19:56,656
that you can do to give a bunch


788
00:19:56,656 --> 00:19:57,526
of users a much better


789
00:19:57,526 --> 00:19:57,976
experience.


790
00:20:02,096 --> 00:20:04,276
So those are some tips and


791
00:20:04,276 --> 00:20:05,606
tricks around how to build your


792
00:20:05,606 --> 00:20:07,086
app and server architecture.


793
00:20:07,086 --> 00:20:08,666
Let's talk about three tips that


794
00:20:08,666 --> 00:20:09,926
you can use in your in-app


795
00:20:09,926 --> 00:20:11,526
experience to really enhance the


796
00:20:11,526 --> 00:20:12,456
user's experience.


797
00:20:13,526 --> 00:20:14,906
Firstly, we made the assumption


798
00:20:14,946 --> 00:20:16,726
earlier that the user was signed


799
00:20:16,726 --> 00:20:17,946
in to an account on your own


800
00:20:17,946 --> 00:20:18,556
service.


801
00:20:19,776 --> 00:20:21,666
In order to keep track of each


802
00:20:21,666 --> 00:20:22,896
subscription ID you need this


803
00:20:22,936 --> 00:20:24,736
particular user table located on


804
00:20:24,736 --> 00:20:25,146
your server.


805
00:20:25,746 --> 00:20:26,646
Now when it comes to actually


806
00:20:26,646 --> 00:20:28,156
creating accounts we think it's


807
00:20:28,196 --> 00:20:29,696
best to offer in-app purchase


808
00:20:29,886 --> 00:20:31,606
before an account creation step.


809
00:20:32,666 --> 00:20:33,156
Why is that?


810
00:20:33,156 --> 00:20:34,576
Well as the user it's a much


811
00:20:34,576 --> 00:20:35,576
better experience, you can just


812
00:20:35,716 --> 00:20:36,996
open the app for the first time


813
00:20:36,996 --> 00:20:38,256
and buy the subscription


814
00:20:38,256 --> 00:20:39,326
immediately getting access to


815
00:20:39,326 --> 00:20:40,106
the content you're after.


816
00:20:40,106 --> 00:20:41,746
For you it's better because you


817
00:20:41,746 --> 00:20:43,056
get higher conversion rates,


818
00:20:43,296 --> 00:20:44,196
users don't have to go through


819
00:20:44,236 --> 00:20:45,726
funnels of entering emails and


820
00:20:45,936 --> 00:20:47,086
passwords to be able to get


821
00:20:47,086 --> 00:20:48,066
access to giving you money.


822
00:20:49,316 --> 00:20:50,396
Now you can use the techniques


823
00:20:50,426 --> 00:20:51,836
that we just went through by


824
00:20:51,836 --> 00:20:53,406
using an anonymous account in


825
00:20:53,406 --> 00:20:54,116
these instances.


826
00:20:55,646 --> 00:20:58,156
And you can rely on the original


827
00:20:58,156 --> 00:20:59,636
transaction ID if you need to


828
00:20:59,636 --> 00:21:01,206
associate multiple devices.


829
00:21:02,506 --> 00:21:03,476
If you're using anonymous


830
00:21:03,476 --> 00:21:04,906
accounts like this, when it


831
00:21:04,906 --> 00:21:06,546
comes time down the road to


832
00:21:06,546 --> 00:21:08,126
actually give the user an


833
00:21:08,126 --> 00:21:09,476
account creation flow, you can


834
00:21:09,476 --> 00:21:10,716
just simply take them through a


835
00:21:10,716 --> 00:21:12,176
deanonymization step where you


836
00:21:12,176 --> 00:21:13,956
update those email fields and


837
00:21:13,956 --> 00:21:14,896
maybe other personally


838
00:21:14,896 --> 00:21:16,056
identifiable fields.


839
00:21:16,606 --> 00:21:19,266
So that's tip number one.


840
00:21:19,266 --> 00:21:20,856
Tip number two is around selling


841
00:21:20,856 --> 00:21:21,966
your in-app purchase.


842
00:21:22,296 --> 00:21:23,146
When it comes to selling your


843
00:21:23,146 --> 00:21:24,836
subscription, you can use a


844
00:21:24,926 --> 00:21:25,946
feature that we launched last


845
00:21:25,946 --> 00:21:26,966
year Introductory Pricing.


846
00:21:27,916 --> 00:21:28,946
Now there's an important step


847
00:21:28,946 --> 00:21:30,656
with Introductory Pricing which


848
00:21:30,656 --> 00:21:31,826
is that you need to know at


849
00:21:31,826 --> 00:21:33,166
runtime whether or not a user is


850
00:21:33,166 --> 00:21:34,576
actually eligible for an


851
00:21:34,576 --> 00:21:35,466
introductory price.


852
00:21:35,686 --> 00:21:36,696
And the reason you need to know


853
00:21:36,696 --> 00:21:38,106
this is you have to know which


854
00:21:38,216 --> 00:21:39,636
price to render to your user,


855
00:21:40,096 --> 00:21:41,016
whether to render the normal


856
00:21:41,016 --> 00:21:42,236
StoreKit price or the


857
00:21:42,236 --> 00:21:43,716
introductory offer that you want


858
00:21:43,716 --> 00:21:44,786
to offer a user to get them in


859
00:21:44,786 --> 00:21:45,136
the door.


860
00:21:46,386 --> 00:21:47,576
Now you can set yourself up to


861
00:21:47,576 --> 00:21:48,816
actually know this ahead of time


862
00:21:48,816 --> 00:21:50,176
by monitoring the transactions


863
00:21:50,176 --> 00:21:51,456
that are occurring in the


864
00:21:51,456 --> 00:21:52,626
background as they come in.


865
00:21:53,516 --> 00:21:54,456
Let's see how this works.


866
00:21:54,456 --> 00:21:55,896
When you're verifying


867
00:21:55,896 --> 00:21:57,126
transactions like we just saw


868
00:21:57,126 --> 00:21:58,336
earlier keep an eye out for


869
00:21:58,336 --> 00:21:59,076
these two fields.


870
00:21:59,736 --> 00:22:01,356
The is trial period field and


871
00:22:01,516 --> 00:22:03,466
the is in intro offer period


872
00:22:03,726 --> 00:22:03,976
field.


873
00:22:04,556 --> 00:22:05,826
If either of these fields are


874
00:22:05,826 --> 00:22:07,556
true that's an indication that


875
00:22:07,606 --> 00:22:09,446
an introductory offer or a free


876
00:22:09,446 --> 00:22:10,576
trial was used for this


877
00:22:10,616 --> 00:22:11,626
particular transaction.


878
00:22:12,536 --> 00:22:13,686
And if it was you should keep


879
00:22:13,686 --> 00:22:15,506
track of the product ID in


880
00:22:15,506 --> 00:22:17,436
question against this current


881
00:22:17,436 --> 00:22:17,646
user.


882
00:22:17,646 --> 00:22:18,806
You might store them in a field


883
00:22:18,806 --> 00:22:20,566
called consumedProductDiscounts.


884
00:22:21,676 --> 00:22:23,106
Now if you're keeping track of


885
00:22:23,106 --> 00:22:24,756
which products were used with


886
00:22:24,756 --> 00:22:26,216
introductory offers, when it


887
00:22:26,216 --> 00:22:27,856
comes time to render the price


888
00:22:27,856 --> 00:22:29,416
of some new subscription product


889
00:22:29,416 --> 00:22:30,986
that you want to show your user


890
00:22:31,916 --> 00:22:32,816
this is how you can do it.


891
00:22:33,136 --> 00:22:34,266
You can take those consumed


892
00:22:34,316 --> 00:22:36,156
product discounts saved against


893
00:22:36,156 --> 00:22:38,136
the current user and execute an


894
00:22:38,136 --> 00:22:39,426
SKProductsRequest with them.


895
00:22:39,926 --> 00:22:41,046
And the reason why is that the


896
00:22:41,096 --> 00:22:42,676
response from SKProductRequest


897
00:22:42,676 --> 00:22:44,386
now in iOS 12 includes the


898
00:22:44,386 --> 00:22:46,476
subscription group identifier so


899
00:22:46,476 --> 00:22:47,536
you know which subscription


900
00:22:47,536 --> 00:22:48,866
group this particular product is


901
00:22:48,896 --> 00:22:49,136
from.


902
00:22:49,986 --> 00:22:51,406
And now armed with this


903
00:22:51,406 --> 00:22:52,586
subscription group identifier


904
00:22:52,586 --> 00:22:54,096
you can keep track of that in a


905
00:22:54,166 --> 00:22:56,516
set of consumed group discounts


906
00:22:56,676 --> 00:22:57,556
for this particular user.


907
00:22:57,826 --> 00:22:59,016
So you know which subscription


908
00:22:59,016 --> 00:23:01,056
groups this user has used offers


909
00:23:01,106 --> 00:23:01,356
for.


910
00:23:02,866 --> 00:23:03,776
Now when you want to render the


911
00:23:03,776 --> 00:23:05,306
price string of say product A it


912
00:23:06,136 --> 00:23:07,196
becomes a simpler check.


913
00:23:07,606 --> 00:23:08,976
You can check to see if this


914
00:23:08,976 --> 00:23:10,616
user's list of consumed group


915
00:23:10,616 --> 00:23:12,316
discounts contains the group


916
00:23:12,316 --> 00:23:13,346
identifier for the one you want


917
00:23:13,346 --> 00:23:14,196
to sell them, in this case


918
00:23:14,266 --> 00:23:14,646
product A.


919
00:23:14,646 --> 00:23:17,196
And if it does, that's an


920
00:23:17,196 --> 00:23:18,406
indication that this user has


921
00:23:18,406 --> 00:23:19,576
actually used an introductory


922
00:23:19,576 --> 00:23:20,876
offer here before, so you can


923
00:23:20,876 --> 00:23:22,666
render the normal price string


924
00:23:22,856 --> 00:23:23,676
to this particular user.


925
00:23:24,286 --> 00:23:25,776
But if not, they're still


926
00:23:25,776 --> 00:23:27,016
eligible for that introductory


927
00:23:27,016 --> 00:23:28,156
offer so you can use that


928
00:23:28,156 --> 00:23:29,976
introductory price located on


929
00:23:29,976 --> 00:23:31,036
the SKProductObject.


930
00:23:31,566 --> 00:23:33,666
Now when rendering the price


931
00:23:33,666 --> 00:23:35,306
string nothing's really changed


932
00:23:35,306 --> 00:23:37,206
here it's the same techniques


933
00:23:37,206 --> 00:23:38,366
that you use for rendering any


934
00:23:38,366 --> 00:23:39,676
in-app purchase and I'm not


935
00:23:39,676 --> 00:23:40,546
going to go into too much more


936
00:23:40,546 --> 00:23:41,776
detail here, but I'd encourage


937
00:23:41,776 --> 00:23:42,746
you to check out the video of


938
00:23:42,746 --> 00:23:44,086
the session just before this one


939
00:23:44,316 --> 00:23:45,036
where they talked about


940
00:23:45,036 --> 00:23:46,356
rendering these price strings a


941
00:23:46,356 --> 00:23:47,276
little more dynamically.


942
00:23:48,176 --> 00:23:49,106
For more information about


943
00:23:49,186 --> 00:23:50,376
setting up introductory offers


944
00:23:50,376 --> 00:23:51,536
I'd also recommend you go to the


945
00:23:51,536 --> 00:23:52,616
What's New in App Store Connect


946
00:23:52,616 --> 00:23:54,586
session on Wednesday at 5 p.m.


947
00:23:54,586 --> 00:23:55,166
in hall three.


948
00:23:55,766 --> 00:23:58,296
So that's tip number two around


949
00:23:58,296 --> 00:23:59,056
introductory pricing.


950
00:23:59,056 --> 00:24:00,616
The third tip here is around


951
00:24:00,616 --> 00:24:01,626
subscription management.


952
00:24:03,046 --> 00:24:04,406
You can offer the user upgrades


953
00:24:04,406 --> 00:24:05,376
and downgrades between


954
00:24:05,376 --> 00:24:07,286
subscription tiers right in your


955
00:24:07,286 --> 00:24:07,676
app's UI.


956
00:24:08,516 --> 00:24:09,656
And to do this you can actually


957
00:24:09,656 --> 00:24:10,796
treat it just like selling an


958
00:24:10,796 --> 00:24:11,686
initial subscription.


959
00:24:12,326 --> 00:24:14,646
Now if the subscription you're


960
00:24:14,646 --> 00:24:15,996
selling the user is part of the


961
00:24:15,996 --> 00:24:17,456
same subscription group, so it's


962
00:24:17,456 --> 00:24:18,786
a different tier than the one


963
00:24:18,786 --> 00:24:19,846
the user has already subscribed


964
00:24:19,916 --> 00:24:22,656
to you can basically just create


965
00:24:22,746 --> 00:24:23,966
an SKPayment just like you would


966
00:24:23,966 --> 00:24:24,906
if you were selling them an


967
00:24:24,906 --> 00:24:25,706
initial subscription.


968
00:24:26,026 --> 00:24:27,306
And when you do this StoreKit


969
00:24:27,306 --> 00:24:28,336
actually handles the fact that


970
00:24:28,336 --> 00:24:29,786
it's an upgrade or downgrade for


971
00:24:29,786 --> 00:24:29,966
you.


972
00:24:30,636 --> 00:24:31,846
So you don't have to worry about


973
00:24:31,846 --> 00:24:32,866
that user being subscribed


974
00:24:32,866 --> 00:24:33,276
twice.


975
00:24:34,346 --> 00:24:35,576
Now if you don't want to provide


976
00:24:35,576 --> 00:24:37,246
your own UI for upgrades and


977
00:24:37,246 --> 00:24:38,626
downgrades in your app you can


978
00:24:38,626 --> 00:24:39,976
also just provide a link out to


979
00:24:39,976 --> 00:24:41,436
the App Store subscription


980
00:24:41,436 --> 00:24:42,106
management screen.


981
00:24:42,106 --> 00:24:43,356
We provide a link for you to be


982
00:24:43,356 --> 00:24:44,356
able to get to this screen


983
00:24:44,476 --> 00:24:46,276
directly from your app and here


984
00:24:46,276 --> 00:24:47,676
the user can upgrade, downgrade


985
00:24:47,676 --> 00:24:48,486
or even cancel their


986
00:24:48,486 --> 00:24:49,006
subscription.


987
00:24:50,276 --> 00:24:51,546
Now your app is often the first


988
00:24:51,636 --> 00:24:52,676
place a user will go for


989
00:24:52,676 --> 00:24:53,786
subscription management, to be


990
00:24:53,786 --> 00:24:54,856
able to upgrade, downgrade or


991
00:24:54,856 --> 00:24:55,226
cancel.


992
00:24:55,226 --> 00:24:56,296
So it's a really good idea to


993
00:24:56,296 --> 00:24:57,836
give some kind of link maybe in


994
00:24:57,836 --> 00:24:59,486
your app's settings for a user


995
00:24:59,486 --> 00:25:00,426
to be able to do this.


996
00:25:01,286 --> 00:25:02,416
To actually get to this screen


997
00:25:02,416 --> 00:25:03,546
there's a link available on our


998
00:25:03,546 --> 00:25:04,676
In-App Purchase Programming


999
00:25:04,676 --> 00:25:06,746
Guide and here it is if you


1000
00:25:06,746 --> 00:25:07,666
enjoy writing down links.


1001
00:25:09,106 --> 00:25:10,016
So these are some simple


1002
00:25:10,016 --> 00:25:11,716
techniques you can implement in


1003
00:25:11,716 --> 00:25:12,686
your app to give a user a


1004
00:25:12,686 --> 00:25:14,126
pleasant experience using


1005
00:25:14,126 --> 00:25:14,766
subscriptions.


1006
00:25:14,766 --> 00:25:15,706
Next, I'm going to hand it over


1007
00:25:15,706 --> 00:25:16,896
to my colleague Michael who's


1008
00:25:16,896 --> 00:25:17,836
going to go over some great


1009
00:25:17,836 --> 00:25:19,206
techniques for reducing your


1010
00:25:19,206 --> 00:25:19,826
subscriber churn.


1011
00:25:19,826 --> 00:25:19,976
Thanks.


1012
00:25:20,516 --> 00:25:26,500
[ Applause ]


1013
00:25:30,046 --> 00:25:31,136
>> Good afternoon, my name is


1014
00:25:31,136 --> 00:25:32,226
Michael Gargas and I'm a


1015
00:25:32,276 --> 00:25:33,606
technical advocate on the App


1016
00:25:33,606 --> 00:25:34,526
Store operations team.


1017
00:25:35,496 --> 00:25:36,716
Today I want to talk about


1018
00:25:36,766 --> 00:25:38,586
reducing subscriber churn inside


1019
00:25:38,586 --> 00:25:40,336
your applications by using some


1020
00:25:40,336 --> 00:25:41,796
of the tactics and methods that


1021
00:25:41,796 --> 00:25:43,426
Pete just walked you through.


1022
00:25:44,536 --> 00:25:46,176
Today we'll cover involuntary


1023
00:25:46,176 --> 00:25:48,006
churn and voluntary churn, the


1024
00:25:48,006 --> 00:25:49,116
two types of churn you'll see


1025
00:25:49,116 --> 00:25:50,046
inside of your subscription


1026
00:25:50,046 --> 00:25:51,986
applications, as well as some


1027
00:25:51,986 --> 00:25:53,116
ways to win back those


1028
00:25:53,116 --> 00:25:54,496
subscribers that you potentially


1029
00:25:54,496 --> 00:25:56,566
may have lost or will lose.


1030
00:25:57,436 --> 00:25:59,536
First, let's talk about


1031
00:25:59,536 --> 00:26:00,326
involuntary churn.


1032
00:26:01,446 --> 00:26:03,326
Involuntary churn is the loss of


1033
00:26:03,326 --> 00:26:04,756
a subscriber due to a failed


1034
00:26:04,756 --> 00:26:07,466
payment or billing issue on the


1035
00:26:08,176 --> 00:26:08,496
platform.


1036
00:26:08,496 --> 00:26:10,206
Now last year at Dub Dub DC we


1037
00:26:10,396 --> 00:26:11,836
walked you through what we're


1038
00:26:11,836 --> 00:26:13,186
doing in order to minimize


1039
00:26:13,186 --> 00:26:14,826
involuntary churn inside of your


1040
00:26:14,826 --> 00:26:15,486
applications.


1041
00:26:16,306 --> 00:26:17,726
We announced our updated Billing


1042
00:26:17,726 --> 00:26:19,756
Retry service where we expanded


1043
00:26:19,756 --> 00:26:21,596
our retry duration from 24 hours


1044
00:26:21,596 --> 00:26:22,996
to up to 60 days.


1045
00:26:24,046 --> 00:26:25,646
We also implemented new retry


1046
00:26:25,646 --> 00:26:27,476
strategies and we tuned them


1047
00:26:27,746 --> 00:26:29,346
over time to recover more and


1048
00:26:29,346 --> 00:26:30,606
more of your subscriptions.


1049
00:26:31,166 --> 00:26:34,666
A date to remember is July 13th,


1050
00:26:34,666 --> 00:26:37,146
2017 because this is the day


1051
00:26:37,316 --> 00:26:39,096
that Apple actively started


1052
00:26:39,566 --> 00:26:40,816
recovering subscriptions for


1053
00:26:40,816 --> 00:26:40,996
you.


1054
00:26:41,596 --> 00:26:45,186
If we look at the performance of


1055
00:26:45,186 --> 00:26:47,106
Billing Retry since launch we


1056
00:26:47,106 --> 00:26:48,456
can see that our recovery rate


1057
00:26:48,906 --> 00:26:49,786
has more than doubled.


1058
00:26:49,786 --> 00:26:52,706
And when we look at involuntary


1059
00:26:52,706 --> 00:26:54,946
churn we've cut this by over 2%


1060
00:26:54,946 --> 00:26:55,956
platform-wide.


1061
00:26:56,516 --> 00:27:02,546
[ Applause ]


1062
00:27:03,046 --> 00:27:04,276
Now if we look at how our tuning


1063
00:27:04,516 --> 00:27:05,876
has impacted the recovery of


1064
00:27:05,876 --> 00:27:07,966
subscriptions we can see that


1065
00:27:08,006 --> 00:27:09,636
quarter over quarter we've been


1066
00:27:09,636 --> 00:27:11,416
able to continue to recover more


1067
00:27:11,416 --> 00:27:13,146
and more of your subscriptions.


1068
00:27:13,706 --> 00:27:17,456
Now the net result of this has


1069
00:27:17,456 --> 00:27:19,766
been 12 million of your


1070
00:27:19,766 --> 00:27:21,076
subscriptions recovered since


1071
00:27:21,116 --> 00:27:21,966
the launch of Billing Retry.


1072
00:27:22,516 --> 00:27:26,636
[ Applause ]


1073
00:27:27,136 --> 00:27:28,436
So that's what Apple's doing to


1074
00:27:28,436 --> 00:27:29,756
minimize involuntary churn for


1075
00:27:29,756 --> 00:27:29,986
you.


1076
00:27:30,846 --> 00:27:31,986
But there's also some tactics


1077
00:27:32,056 --> 00:27:33,526
that you as a developer can do


1078
00:27:33,606 --> 00:27:35,046
to minimize voluntary churn


1079
00:27:35,366 --> 00:27:36,636
inside of your subscription


1080
00:27:36,636 --> 00:27:37,216
applications.


1081
00:27:38,386 --> 00:27:39,626
You can leverage some of the


1082
00:27:39,686 --> 00:27:41,136
subscription specific receipt


1083
00:27:41,176 --> 00:27:42,236
fields that Pete mentioned


1084
00:27:42,236 --> 00:27:42,596
earlier.


1085
00:27:43,516 --> 00:27:44,926
You can implement grace periods


1086
00:27:45,066 --> 00:27:47,436
and during that time you can


1087
00:27:47,586 --> 00:27:49,236
deploy some effective customer


1088
00:27:49,236 --> 00:27:49,716
messaging.


1089
00:27:51,106 --> 00:27:52,216
So let's take a look at an


1090
00:27:52,216 --> 00:27:53,226
example subscription.


1091
00:27:54,356 --> 00:27:55,656
Here we can see that our


1092
00:27:55,656 --> 00:27:57,406
subscriber was set to renew on


1093
00:27:57,406 --> 00:28:00,206
April 26th, however, they


1094
00:28:00,206 --> 00:28:01,266
encountered a billing issue.


1095
00:28:02,506 --> 00:28:04,196
So in order to let you know that


1096
00:28:04,196 --> 00:28:06,126
Apple is actively attempting to


1097
00:28:06,126 --> 00:28:07,756
collect funds from that user via


1098
00:28:07,756 --> 00:28:10,066
the Billing Retry service we are


1099
00:28:10,066 --> 00:28:11,166
going to surface a field in the


1100
00:28:11,166 --> 00:28:14,346
JSON response aptly titled is in


1101
00:28:14,346 --> 00:28:15,346
billing retry period.


1102
00:28:16,046 --> 00:28:18,226
A value of one signifying that


1103
00:28:18,226 --> 00:28:19,316
we're attempting to collect


1104
00:28:19,316 --> 00:28:20,756
funds for that subscriber.


1105
00:28:21,436 --> 00:28:24,576
If we go back to our example of


1106
00:28:24,576 --> 00:28:25,836
subscription you can see that


1107
00:28:25,836 --> 00:28:27,126
this has been added to JSON


1108
00:28:27,126 --> 00:28:27,576
response.


1109
00:28:27,576 --> 00:28:29,716
And when you see this in


1110
00:28:29,716 --> 00:28:30,986
conjunction with the expires


1111
00:28:30,986 --> 00:28:32,946
date this is your signal as a


1112
00:28:32,946 --> 00:28:34,826
developer to implement what we


1113
00:28:34,826 --> 00:28:37,206
call a grace period.


1114
00:28:37,306 --> 00:28:38,416
You may ask yourself what is a


1115
00:28:38,416 --> 00:28:38,976
grace period.


1116
00:28:42,416 --> 00:28:44,116
A grace period is free


1117
00:28:44,176 --> 00:28:46,016
subscription access while in a


1118
00:28:46,016 --> 00:28:47,756
billing retry state, however


1119
00:28:47,906 --> 00:28:49,456
it's before you have lost that


1120
00:28:49,456 --> 00:28:50,586
subscriber, before they've


1121
00:28:50,586 --> 00:28:51,386
churned out.


1122
00:28:52,066 --> 00:28:53,426
The goal of the grace period is


1123
00:28:53,426 --> 00:28:54,486
to improve recovery.


1124
00:28:54,486 --> 00:28:56,826
So let's take a look at how we


1125
00:28:56,826 --> 00:28:58,176
can do that leveraging some of


1126
00:28:58,176 --> 00:28:59,286
the information in the receipt


1127
00:28:59,286 --> 00:28:59,676
response.


1128
00:29:00,876 --> 00:29:02,116
If we flip back to our example


1129
00:29:02,116 --> 00:29:04,076
subscription you can see that


1130
00:29:04,076 --> 00:29:05,206
our subscriber is in a billing


1131
00:29:05,206 --> 00:29:06,956
retry state and was set to renew


1132
00:29:07,006 --> 00:29:08,026
on April 26th.


1133
00:29:09,246 --> 00:29:10,576
Here we want to add some


1134
00:29:10,646 --> 00:29:12,036
server-side logic to use that


1135
00:29:12,036 --> 00:29:14,296
expires date field and the is in


1136
00:29:14,296 --> 00:29:16,446
billing retry period in order to


1137
00:29:16,446 --> 00:29:18,026
add a period of time, in this


1138
00:29:18,026 --> 00:29:20,326
example three days where that


1139
00:29:20,326 --> 00:29:21,516
user will continue to have


1140
00:29:21,516 --> 00:29:23,086
access to the service and


1141
00:29:23,086 --> 00:29:25,346
technically stay subscribed.


1142
00:29:26,796 --> 00:29:27,966
Now why would you do this?


1143
00:29:28,436 --> 00:29:30,666
Well it's an opportune time to


1144
00:29:30,666 --> 00:29:32,236
deploy some effective customer


1145
00:29:32,236 --> 00:29:33,986
messaging to contextually


1146
00:29:33,986 --> 00:29:34,866
communicate with your


1147
00:29:34,866 --> 00:29:36,626
subscribers and let them know


1148
00:29:36,626 --> 00:29:37,956
that there may be an issue with


1149
00:29:37,956 --> 00:29:38,716
their subscription.


1150
00:29:39,836 --> 00:29:41,016
You may want to do things like


1151
00:29:41,166 --> 00:29:42,856
ask them to update their payment


1152
00:29:42,856 --> 00:29:45,336
method or have them restate the


1153
00:29:45,336 --> 00:29:46,526
value proposition of the


1154
00:29:46,526 --> 00:29:47,646
subscription offering that


1155
00:29:47,646 --> 00:29:48,456
they're subscribed to.


1156
00:29:49,336 --> 00:29:50,826
And during this time you can


1157
00:29:50,826 --> 00:29:52,376
offer limited service as well,


1158
00:29:52,676 --> 00:29:54,166
such as a browse but not watch


1159
00:29:54,166 --> 00:29:55,606
experience in an entertainment


1160
00:29:56,236 --> 00:29:56,326
app.


1161
00:29:57,956 --> 00:29:59,446
Here we can see Peak, a


1162
00:29:59,496 --> 00:30:00,586
subscription developer on the


1163
00:30:00,586 --> 00:30:00,886
App Store.


1164
00:30:02,496 --> 00:30:03,846
Peak is leveraging the Billing


1165
00:30:03,846 --> 00:30:05,886
Retry status fields in order to


1166
00:30:05,926 --> 00:30:07,506
surface a contextual message to


1167
00:30:07,506 --> 00:30:09,236
their subscribers letting them


1168
00:30:09,236 --> 00:30:10,386
know that there's been an issue


1169
00:30:10,386 --> 00:30:11,256
with their subscription.


1170
00:30:12,476 --> 00:30:14,416
When engaged upon they're taken


1171
00:30:14,416 --> 00:30:16,026
to an additional screen which


1172
00:30:16,026 --> 00:30:17,626
clearly states what the issue is


1173
00:30:18,126 --> 00:30:19,806
and how they can resolve it.


1174
00:30:21,116 --> 00:30:22,886
But it would be really effective


1175
00:30:23,116 --> 00:30:24,506
if from this screen you could


1176
00:30:24,506 --> 00:30:26,166
drive that user or subscriber


1177
00:30:26,426 --> 00:30:27,876
directly to our systems to


1178
00:30:27,876 --> 00:30:29,046
update their payment details.


1179
00:30:29,606 --> 00:30:32,056
So I'm excited today to announce


1180
00:30:32,056 --> 00:30:33,806
that we have two new URLs coming


1181
00:30:33,806 --> 00:30:35,396
shortly after Dub Dub DC this


1182
00:30:35,396 --> 00:30:37,346
year, one to drive users


1183
00:30:37,346 --> 00:30:38,616
directly to update their billing


1184
00:30:38,616 --> 00:30:40,166
information and the others to


1185
00:30:40,166 --> 00:30:41,016
take them to manage their


1186
00:30:41,016 --> 00:30:42,836
subscriptions as Pete alluded to


1187
00:30:42,836 --> 00:30:44,536
earlier for upgrades, downgrades


1188
00:30:44,536 --> 00:30:44,976
and crossgrades.


1189
00:30:45,516 --> 00:30:48,500
[ Applause ]


1190
00:30:51,106 --> 00:30:52,306
With that being said, a lot of


1191
00:30:52,306 --> 00:30:54,016
developers will ask well when


1192
00:30:54,106 --> 00:30:55,386
are we seeing our users be


1193
00:30:55,386 --> 00:30:55,826
recovered.


1194
00:30:56,906 --> 00:30:58,446
And on average we see the


1195
00:30:58,446 --> 00:30:59,876
majority of users recovered


1196
00:30:59,876 --> 00:31:01,536
within the first seven days of


1197
00:31:01,536 --> 00:31:03,016
entering a Billing Retry state


1198
00:31:03,016 --> 00:31:03,656
on the platform.


1199
00:31:03,656 --> 00:31:07,406
This might be a time to offer a


1200
00:31:07,406 --> 00:31:09,466
full access grace period because


1201
00:31:09,466 --> 00:31:10,416
we see a lot of users


1202
00:31:10,516 --> 00:31:12,626
self-recovering during this


1203
00:31:13,696 --> 00:31:13,806
time.


1204
00:31:14,026 --> 00:31:15,176
You may want to deploy that


1205
00:31:15,176 --> 00:31:16,496
customer messaging towards the


1206
00:31:16,496 --> 00:31:18,006
tail end of this to bring in


1207
00:31:18,006 --> 00:31:19,066
some of those subscribers that


1208
00:31:19,066 --> 00:31:20,196
might've taken longer to come


1209
00:31:20,196 --> 00:31:20,976
back into your application.


1210
00:31:25,156 --> 00:31:26,406
Let's flip back to our example


1211
00:31:26,516 --> 00:31:26,916
subscription.


1212
00:31:27,356 --> 00:31:28,756
What happens if this is


1213
00:31:28,756 --> 00:31:30,016
effective and we're able to


1214
00:31:30,016 --> 00:31:31,096
recover these customers?


1215
00:31:31,606 --> 00:31:34,236
When a retry attempt is


1216
00:31:34,236 --> 00:31:36,726
successful the date of the retry


1217
00:31:36,726 --> 00:31:38,276
or recovery becomes the new


1218
00:31:38,276 --> 00:31:39,646
subscription anniversary date


1219
00:31:39,646 --> 00:31:41,306
moving forward and this will be


1220
00:31:41,306 --> 00:31:43,196
reflected in JSON response when


1221
00:31:43,196 --> 00:31:44,376
validating that successful


1222
00:31:44,376 --> 00:31:46,466
transaction and finishing it.


1223
00:31:47,676 --> 00:31:48,846
But we're not going to stop


1224
00:31:48,846 --> 00:31:50,756
there we're also going to deploy


1225
00:31:50,756 --> 00:31:51,646
our server-to-server


1226
00:31:51,646 --> 00:31:53,266
notifications so that you can


1227
00:31:53,266 --> 00:31:55,226
immediately unlock access on all


1228
00:31:55,226 --> 00:31:57,206
platforms and close the loop


1229
00:31:57,206 --> 00:31:58,566
with your customer letting them


1230
00:31:58,566 --> 00:32:00,116
know hey you're all set.


1231
00:32:00,606 --> 00:32:03,886
So that's involuntary churn


1232
00:32:04,216 --> 00:32:05,196
where the customer didn't


1233
00:32:05,196 --> 00:32:06,306
technically make a choice to


1234
00:32:06,306 --> 00:32:07,456
unsubscribe from your


1235
00:32:07,456 --> 00:32:07,926
application.


1236
00:32:08,486 --> 00:32:10,906
But what is voluntary churn?


1237
00:32:12,086 --> 00:32:14,256
Voluntary churn is the loss of a


1238
00:32:14,256 --> 00:32:16,326
subscriber due to customer


1239
00:32:16,326 --> 00:32:18,916
choice, either cancellation or


1240
00:32:18,916 --> 00:32:19,676
refund requests.


1241
00:32:20,776 --> 00:32:23,176
To be clear, this user actively


1242
00:32:23,176 --> 00:32:24,466
made the choice to leave your


1243
00:32:24,516 --> 00:32:25,346
subscription offering.


1244
00:32:26,876 --> 00:32:28,446
So what can you do as a


1245
00:32:28,446 --> 00:32:30,576
developer to minimize voluntary


1246
00:32:30,576 --> 00:32:31,426
churn inside of your


1247
00:32:31,426 --> 00:32:31,946
applications?


1248
00:32:33,366 --> 00:32:34,476
Well Pete walked you through how


1249
00:32:34,476 --> 00:32:35,766
to status poll earlier and you


1250
00:32:35,766 --> 00:32:37,096
can implement that to get some


1251
00:32:37,256 --> 00:32:39,016
key subscription details about


1252
00:32:39,016 --> 00:32:41,296
your users and when you get that


1253
00:32:41,296 --> 00:32:42,726
information you can use it to


1254
00:32:42,726 --> 00:32:44,476
offer attractive alternative


1255
00:32:44,526 --> 00:32:45,936
subscription offerings to


1256
00:32:45,936 --> 00:32:46,976
potentially save that user.


1257
00:32:51,156 --> 00:32:52,556
So let's talk a little bit more


1258
00:32:52,556 --> 00:32:53,536
about status polling.


1259
00:32:54,086 --> 00:32:55,976
With the release of


1260
00:32:55,976 --> 00:32:57,346
server-to-server notifications


1261
00:32:57,816 --> 00:32:59,336
there's really only two key


1262
00:32:59,336 --> 00:33:00,606
reasons that you still need to


1263
00:33:00,706 --> 00:33:01,906
status poll.


1264
00:33:02,936 --> 00:33:05,396
The first is understanding will


1265
00:33:05,396 --> 00:33:07,076
my subscriber churn in the


1266
00:33:07,076 --> 00:33:08,556
subsequent subscription period


1267
00:33:09,576 --> 00:33:11,156
and the second being has my


1268
00:33:11,156 --> 00:33:12,026
subscriber renewed.


1269
00:33:12,576 --> 00:33:16,276
We often get asked when should I


1270
00:33:16,276 --> 00:33:17,736
status poll as a developer, when


1271
00:33:17,736 --> 00:33:18,776
should I try to catch those


1272
00:33:18,776 --> 00:33:20,896
users and see their subscription


1273
00:33:20,896 --> 00:33:21,526
state changes.


1274
00:33:23,276 --> 00:33:24,966
The most effective times that we


1275
00:33:25,036 --> 00:33:27,066
see are doing that status poll


1276
00:33:27,066 --> 00:33:28,416
at the beginning or end of a


1277
00:33:28,486 --> 00:33:29,346
subscription period.


1278
00:33:30,156 --> 00:33:31,646
By deploying this responsibly


1279
00:33:32,396 --> 00:33:33,316
you're most likely going to


1280
00:33:33,346 --> 00:33:35,656
catch most users that may want


1281
00:33:35,656 --> 00:33:37,016
to voluntarily churn from your


1282
00:33:37,016 --> 00:33:37,836
subscription offering.


1283
00:33:40,596 --> 00:33:42,256
But when you status poll you'll


1284
00:33:42,256 --> 00:33:43,456
also get access to some


1285
00:33:43,456 --> 00:33:45,086
additional subscriber status


1286
00:33:45,086 --> 00:33:45,406
fields.


1287
00:33:45,886 --> 00:33:47,906
And you may want to take those


1288
00:33:47,906 --> 00:33:49,886
fields and save the decoded JSON


1289
00:33:49,886 --> 00:33:51,316
response from the verify receipt


1290
00:33:51,346 --> 00:33:53,566
call in the user tables on your


1291
00:33:53,566 --> 00:33:54,086
databases.


1292
00:33:55,496 --> 00:33:57,146
Or alternatively, you can parse


1293
00:33:57,146 --> 00:33:59,456
out specific fields such as the


1294
00:33:59,456 --> 00:34:00,906
Billing Retry Status in order to


1295
00:34:00,906 --> 00:34:02,856
segment your customers and maybe


1296
00:34:02,856 --> 00:34:03,996
understand those that are in a


1297
00:34:03,996 --> 00:34:05,976
retry state and those that are


1298
00:34:06,566 --> 00:34:06,666
not.


1299
00:34:07,656 --> 00:34:09,436
But the signal to understand if


1300
00:34:09,436 --> 00:34:10,666
a customer will voluntarily


1301
00:34:10,666 --> 00:34:12,466
churn is shown via a field


1302
00:34:13,386 --> 00:34:17,065
called auto renew status.


1303
00:34:17,216 --> 00:34:18,846
Auto renew status will let you


1304
00:34:18,846 --> 00:34:20,295
know with a value of one that


1305
00:34:20,295 --> 00:34:22,045
that subscriber will return in


1306
00:34:22,045 --> 00:34:23,176
the subsequent subscription


1307
00:34:23,176 --> 00:34:25,396
period and a value of zero


1308
00:34:25,596 --> 00:34:26,755
letting you know that they will


1309
00:34:26,755 --> 00:34:28,426
voluntarily churn at their next


1310
00:34:28,426 --> 00:34:29,596
subscription anniversary date.


1311
00:34:30,106 --> 00:34:32,676
Let's see what this would look


1312
00:34:32,676 --> 00:34:33,416
like in our example


1313
00:34:33,416 --> 00:34:33,985
subscription.


1314
00:34:35,436 --> 00:34:36,835
Here we have a subscriber


1315
00:34:37,315 --> 00:34:39,266
purchased on March 26th and


1316
00:34:40,376 --> 00:34:42,226
they've made the choice to


1317
00:34:42,226 --> 00:34:43,505
disable auto renew via the


1318
00:34:43,505 --> 00:34:44,686
manage subscription setting


1319
00:34:44,686 --> 00:34:45,005
screen.


1320
00:34:45,606 --> 00:34:48,856
Now coincidentally, we status


1321
00:34:48,856 --> 00:34:49,936
polled shortly after this


1322
00:34:49,936 --> 00:34:52,176
happened and we were able to see


1323
00:34:52,636 --> 00:34:54,416
via the receipt response that


1324
00:34:54,416 --> 00:34:55,516
the auto renew status has


1325
00:34:55,516 --> 00:34:56,326
changed to zero.


1326
00:34:57,016 --> 00:34:59,806
It's at this point that you can


1327
00:34:59,806 --> 00:35:01,386
update your user tables on your


1328
00:35:01,386 --> 00:35:03,676
database or on your server and


1329
00:35:03,726 --> 00:35:04,876
segment that customer as a


1330
00:35:04,876 --> 00:35:06,716
potential voluntary churning


1331
00:35:06,766 --> 00:35:07,146
customer.


1332
00:35:07,716 --> 00:35:11,096
If we go back to the example


1333
00:35:11,136 --> 00:35:12,816
subscription we've status


1334
00:35:12,816 --> 00:35:15,426
polled, we've captured this


1335
00:35:15,476 --> 00:35:16,976
customer might leave, so what


1336
00:35:16,976 --> 00:35:17,476
should we do?


1337
00:35:18,726 --> 00:35:19,926
As a developer this is your


1338
00:35:19,926 --> 00:35:21,196
opportunity to present an


1339
00:35:21,196 --> 00:35:22,646
attractive downgrade offer


1340
00:35:22,646 --> 00:35:23,666
potentially in the same


1341
00:35:23,666 --> 00:35:24,686
subscription group.


1342
00:35:25,536 --> 00:35:27,476
Here we can see Peak trying to


1343
00:35:27,646 --> 00:35:29,006
save that user by potentially


1344
00:35:29,006 --> 00:35:30,756
having them take a lesser term


1345
00:35:30,756 --> 00:35:32,606
or a lesser price subscription


1346
00:35:32,826 --> 00:35:34,286
of a different duration or maybe


1347
00:35:34,286 --> 00:35:35,056
a different offering.


1348
00:35:35,716 --> 00:35:39,806
If that subscriber decides to


1349
00:35:39,806 --> 00:35:41,616
engage with this the same way


1350
00:35:41,616 --> 00:35:42,676
that Pete showed you by


1351
00:35:42,746 --> 00:35:43,766
surfacing upgrades and


1352
00:35:43,766 --> 00:35:44,626
downgrades within your


1353
00:35:44,626 --> 00:35:47,036
applications we want to let you


1354
00:35:47,036 --> 00:35:48,946
know what product they will


1355
00:35:48,946 --> 00:35:50,326
renew on in the subsequent


1356
00:35:50,326 --> 00:35:50,636
period.


1357
00:35:51,256 --> 00:35:54,266
We do this via the auto renew


1358
00:35:54,306 --> 00:35:55,906
product ID field in the JSON


1359
00:35:55,906 --> 00:35:56,286
response.


1360
00:35:57,236 --> 00:35:58,996
So this differs from product ID


1361
00:35:59,096 --> 00:36:00,696
in that this is what the next


1362
00:36:00,696 --> 00:36:02,256
offering will be after that


1363
00:36:02,296 --> 00:36:03,116
subscriber renews.


1364
00:36:03,276 --> 00:36:07,546
Here we can see in the example


1365
00:36:07,546 --> 00:36:09,986
subscription our subscriber has


1366
00:36:09,986 --> 00:36:11,276
elected to downgrade instead of


1367
00:36:11,276 --> 00:36:11,706
churn out.


1368
00:36:12,956 --> 00:36:13,966
We've changed the auto renew


1369
00:36:13,966 --> 00:36:16,566
status to one and we've added


1370
00:36:16,566 --> 00:36:18,406
auto renew product ID.


1371
00:36:19,346 --> 00:36:21,276
It would also be beneficial to


1372
00:36:21,276 --> 00:36:22,346
be notified of this change


1373
00:36:22,346 --> 00:36:24,976
immediately, so for this we'll


1374
00:36:24,976 --> 00:36:26,316
also send a server-to-server


1375
00:36:26,316 --> 00:36:27,896
notification letting you know


1376
00:36:27,996 --> 00:36:30,296
that your subscriber did change


1377
00:36:30,296 --> 00:36:31,176
their renewal preference.


1378
00:36:31,666 --> 00:36:34,846
This is useful if you want to


1379
00:36:34,846 --> 00:36:36,366
maybe state the differing


1380
00:36:36,456 --> 00:36:38,156
service levels between what


1381
00:36:38,156 --> 00:36:39,406
they're currently subscribed to


1382
00:36:39,646 --> 00:36:40,686
and what they will have in the


1383
00:36:40,686 --> 00:36:41,516
subsequent period.


1384
00:36:42,126 --> 00:36:46,016
Now it's impossible to run a


1385
00:36:46,016 --> 00:36:47,946
100% retention subscription


1386
00:36:47,946 --> 00:36:49,736
business, so it's important to


1387
00:36:49,736 --> 00:36:50,586
understand how you could


1388
00:36:50,646 --> 00:36:52,786
possibly win back some of those


1389
00:36:52,786 --> 00:36:54,416
subscribers that you might have


1390
00:36:54,666 --> 00:36:54,806
lost.


1391
00:36:56,416 --> 00:36:58,226
A win back is reengaging


1392
00:36:58,276 --> 00:36:59,506
subscribers after they've


1393
00:36:59,506 --> 00:37:01,236
churned by showing them


1394
00:37:01,236 --> 00:37:03,386
resubscription offers or


1395
00:37:03,386 --> 00:37:04,566
potentially surveying them to


1396
00:37:04,566 --> 00:37:06,236
understand why they've left.


1397
00:37:06,856 --> 00:37:09,166
If we look at our example


1398
00:37:09,166 --> 00:37:10,846
subscription let's see what a


1399
00:37:10,846 --> 00:37:12,116
voluntary cancellation would


1400
00:37:12,116 --> 00:37:13,236
look like and how we can


1401
00:37:13,236 --> 00:37:14,656
leverage that inside of our app.


1402
00:37:16,066 --> 00:37:18,596
Here our user has elected to


1403
00:37:18,596 --> 00:37:19,736
cancel via AppleCare.


1404
00:37:20,946 --> 00:37:22,856
In order to let you know we're


1405
00:37:22,856 --> 00:37:24,156
going to surface a cancellation


1406
00:37:24,156 --> 00:37:25,626
date field in the JSON response.


1407
00:37:26,586 --> 00:37:27,416
This is your signal to


1408
00:37:27,416 --> 00:37:29,286
understand this customer has


1409
00:37:29,356 --> 00:37:31,126
contacted AppleCare and either


1410
00:37:31,156 --> 00:37:32,756
canceled or requested a refund.


1411
00:37:33,766 --> 00:37:36,056
But as a developer you would


1412
00:37:36,056 --> 00:37:37,206
want to know this information


1413
00:37:37,266 --> 00:37:37,816
immediately.


1414
00:37:38,986 --> 00:37:40,136
For this we'll deploy a


1415
00:37:40,136 --> 00:37:41,506
server-to-server notification.


1416
00:37:42,836 --> 00:37:43,996
This is important because you'll


1417
00:37:43,996 --> 00:37:45,366
immediately want to shut off


1418
00:37:45,366 --> 00:37:47,096
access to those users on all


1419
00:37:47,096 --> 00:37:49,376
platforms and potentially


1420
00:37:49,446 --> 00:37:50,536
prompting them to see


1421
00:37:50,536 --> 00:37:52,036
alternative subscription offers.


1422
00:37:52,586 --> 00:37:55,926
Now after this user has churned


1423
00:37:56,276 --> 00:37:57,766
it would be important to easily


1424
00:37:57,836 --> 00:37:59,066
segment between those that have


1425
00:37:59,066 --> 00:38:00,306
voluntarily chosen to


1426
00:38:00,336 --> 00:38:02,836
unsubscribe and those that have


1427
00:38:02,896 --> 00:38:04,506
involuntarily been unsubscribed


1428
00:38:04,506 --> 00:38:05,436
due to a payment issue or


1429
00:38:05,436 --> 00:38:06,046
billing issue.


1430
00:38:07,056 --> 00:38:09,196
So for that we have the field


1431
00:38:09,226 --> 00:38:11,256
expiration intent in the JSON


1432
00:38:11,256 --> 00:38:11,646
response.


1433
00:38:12,696 --> 00:38:14,436
Now to be clear, this will only


1434
00:38:14,436 --> 00:38:16,266
show up after the subscription


1435
00:38:16,426 --> 00:38:16,926
has lapsed.


1436
00:38:18,016 --> 00:38:19,236
And we really want to focus on


1437
00:38:19,286 --> 00:38:22,146
two key values, the first being


1438
00:38:22,146 --> 00:38:23,826
value one which signifies


1439
00:38:23,866 --> 00:38:26,296
voluntary churn, the second


1440
00:38:27,556 --> 00:38:28,996
signifying involuntary churn


1441
00:38:29,886 --> 00:38:32,896
with a value of two.


1442
00:38:33,146 --> 00:38:34,486
If we flip back to our example


1443
00:38:34,486 --> 00:38:36,106
subscription where our customer


1444
00:38:36,106 --> 00:38:37,906
canceled via AppleCare you can


1445
00:38:37,956 --> 00:38:38,816
see that we've added the


1446
00:38:38,846 --> 00:38:40,496
expiration intent field to the


1447
00:38:40,496 --> 00:38:42,156
receipt response with a value of


1448
00:38:42,156 --> 00:38:42,416
one.


1449
00:38:42,416 --> 00:38:47,496
So what do you do as a developer


1450
00:38:47,496 --> 00:38:48,756
when you see your subscribers in


1451
00:38:48,756 --> 00:38:50,006
this state after they've already


1452
00:38:50,006 --> 00:38:51,686
churned and you've segmented


1453
00:38:51,686 --> 00:38:52,486
between those that have


1454
00:38:52,486 --> 00:38:54,266
voluntarily and involuntarily


1455
00:38:54,266 --> 00:38:54,566
churned?


1456
00:38:55,066 --> 00:38:58,536
Well for voluntary you may want


1457
00:38:58,536 --> 00:39:00,256
to survey those subscribers who


1458
00:39:00,256 --> 00:39:01,506
have opted into an account on


1459
00:39:01,506 --> 00:39:02,056
your system.


1460
00:39:02,586 --> 00:39:04,006
You can ask them maybe why the


1461
00:39:04,076 --> 00:39:05,366
service wasn't appropriate for


1462
00:39:05,366 --> 00:39:07,186
them and what you can do to


1463
00:39:07,296 --> 00:39:08,556
tailor it moving forward to


1464
00:39:08,556 --> 00:39:09,786
provide a better experience for


1465
00:39:09,786 --> 00:39:11,246
them or other users.


1466
00:39:12,536 --> 00:39:13,926
Additionally, you can always


1467
00:39:13,926 --> 00:39:14,916
just show alternative


1468
00:39:14,966 --> 00:39:15,816
subscription products


1469
00:39:16,326 --> 00:39:17,426
potentially within the same


1470
00:39:17,426 --> 00:39:18,566
group because if they


1471
00:39:18,566 --> 00:39:19,926
re-subscribe you want to


1472
00:39:19,926 --> 00:39:21,236
continue accruing your time


1473
00:39:21,236 --> 00:39:22,916
towards that 85/15 revenue


1474
00:39:22,916 --> 00:39:23,166
share.


1475
00:39:23,166 --> 00:39:27,136
Here we can see Peak when a user


1476
00:39:27,136 --> 00:39:29,646
has voluntarily churned being


1477
00:39:29,646 --> 00:39:31,516
shown a resubscription offer, in


1478
00:39:31,516 --> 00:39:32,976
this case a 60% discount.


1479
00:39:37,046 --> 00:39:38,386
For involuntary churn since the


1480
00:39:38,386 --> 00:39:39,896
user did not actively make the


1481
00:39:39,896 --> 00:39:41,446
choice to unsubscribe it's


1482
00:39:41,446 --> 00:39:42,446
appropriate to just show the


1483
00:39:42,506 --> 00:39:43,906
same or alternative subscription


1484
00:39:43,906 --> 00:39:44,296
products.


1485
00:39:45,316 --> 00:39:46,296
You may want to leave some


1486
00:39:46,296 --> 00:39:47,576
persistent messaging if that


1487
00:39:47,576 --> 00:39:48,716
user is logged in inside the


1488
00:39:48,716 --> 00:39:50,476
application experience letting


1489
00:39:50,476 --> 00:39:51,676
them know that they have lapsed,


1490
00:39:52,026 --> 00:39:53,016
but that they can always come


1491
00:39:53,016 --> 00:39:53,226
back.


1492
00:39:54,486 --> 00:39:55,926
And you may also want to deploy


1493
00:39:55,926 --> 00:39:57,016
a limited subscription


1494
00:39:57,016 --> 00:39:59,176
experience, such as a browse but


1495
00:39:59,176 --> 00:40:00,536
not watch experience in an


1496
00:40:00,536 --> 00:40:00,976
entertainment app.


1497
00:40:01,066 --> 00:40:04,956
Here we can see Tinder, when


1498
00:40:04,956 --> 00:40:07,176
users interact with pro level or


1499
00:40:07,176 --> 00:40:08,816
subscription level features they


1500
00:40:08,816 --> 00:40:10,476
are continually prompted to


1501
00:40:10,476 --> 00:40:11,746
subscribe.


1502
00:40:12,616 --> 00:40:14,656
So in summary, if you take


1503
00:40:14,656 --> 00:40:15,906
anything away from this section


1504
00:40:15,906 --> 00:40:17,136
on reducing subscriber churn


1505
00:40:17,706 --> 00:40:18,386
it's that you should be


1506
00:40:18,386 --> 00:40:19,896
leveraging these subscription


1507
00:40:19,896 --> 00:40:21,476
receipt fields effectively.


1508
00:40:22,016 --> 00:40:25,116
You can then implement status


1509
00:40:25,116 --> 00:40:26,646
polling to understand when your


1510
00:40:26,646 --> 00:40:27,776
subscribers may voluntarily


1511
00:40:27,776 --> 00:40:27,976
churn.


1512
00:40:32,546 --> 00:40:33,606
You can then use that status


1513
00:40:33,676 --> 00:40:35,196
polling to deploy some targeted


1514
00:40:35,196 --> 00:40:36,106
and effective customer


1515
00:40:36,106 --> 00:40:36,676
messaging.


1516
00:40:37,266 --> 00:40:40,816
And then to close it out,


1517
00:40:40,976 --> 00:40:42,116
presenting contextual


1518
00:40:42,166 --> 00:40:43,316
subscription offers to these


1519
00:40:43,316 --> 00:40:45,106
users to hopefully win them back


1520
00:40:45,386 --> 00:40:46,536
or prevent them from churning in


1521
00:40:46,536 --> 00:40:47,666
the first place.


1522
00:40:48,996 --> 00:40:50,586
So with that I'd like to hand it


1523
00:40:50,586 --> 00:40:51,696
back to my colleague Pete to


1524
00:40:51,696 --> 00:40:53,026
discuss analytics and reporting.


1525
00:40:53,396 --> 00:40:53,696
Thank you.


1526
00:40:54,516 --> 00:40:58,500
[ Applause ]


1527
00:41:03,046 --> 00:41:03,436
>> Thanks Michael.


1528
00:41:04,636 --> 00:41:05,546
If you haven't implemented


1529
00:41:05,546 --> 00:41:06,946
handling of these JSON fields


1530
00:41:06,946 --> 00:41:08,506
yet we highly recommend you try


1531
00:41:08,506 --> 00:41:09,546
it and watch the great effect it


1532
00:41:09,546 --> 00:41:10,856
has on your retention rates.


1533
00:41:11,496 --> 00:41:12,666
It's not often as engineers we


1534
00:41:12,666 --> 00:41:13,616
get the chance to make such


1535
00:41:13,736 --> 00:41:15,136
simple architectural tweaks that


1536
00:41:15,136 --> 00:41:17,226
can have such a big effect on a


1537
00:41:17,226 --> 00:41:18,826
business' revenue, so take a


1538
00:41:18,826 --> 00:41:18,996
look.


1539
00:41:20,066 --> 00:41:21,266
Now we've got some great new


1540
00:41:21,266 --> 00:41:22,536
updates today in the areas of


1541
00:41:22,536 --> 00:41:23,606
analytics and reporting.


1542
00:41:24,756 --> 00:41:26,526
Located in App Store Connect the


1543
00:41:26,526 --> 00:41:27,736
sales and trends section


1544
00:41:27,736 --> 00:41:29,126
contains a huge amount of useful


1545
00:41:29,126 --> 00:41:29,686
information.


1546
00:41:30,146 --> 00:41:31,156
Now you can get even more


1547
00:41:31,156 --> 00:41:32,096
insight into your app's


1548
00:41:32,146 --> 00:41:32,726
performance.


1549
00:41:33,416 --> 00:41:34,886
This existing subscription


1550
00:41:34,886 --> 00:41:36,766
summary dashboard now includes


1551
00:41:36,766 --> 00:41:38,126
monitoring for subscriptions


1552
00:41:38,126 --> 00:41:39,526
that are in those Billing Retry


1553
00:41:39,526 --> 00:41:40,076
windows.


1554
00:41:41,256 --> 00:41:42,456
This is great for gaining


1555
00:41:42,456 --> 00:41:43,686
insight into your subscriber


1556
00:41:43,686 --> 00:41:44,826
behavior and to determine the


1557
00:41:44,826 --> 00:41:46,106
most effective amount of time to


1558
00:41:46,106 --> 00:41:47,396
offer those grace periods for


1559
00:41:47,396 --> 00:41:49,306
like Michael just talked about.


1560
00:41:50,196 --> 00:41:52,116
This year we're also introducing


1561
00:41:52,116 --> 00:41:53,666
a brand-new dashboard for


1562
00:41:53,666 --> 00:41:54,726
subscription retention.


1563
00:41:55,906 --> 00:41:57,226
This page offers a glance at how


1564
00:41:57,226 --> 00:41:58,266
your introductory prices are


1565
00:41:58,266 --> 00:41:59,966
going, as well as how many of


1566
00:41:59,966 --> 00:42:01,376
the users are subscribed to the


1567
00:42:01,376 --> 00:42:02,496
higher proceeds rate, that's


1568
00:42:02,496 --> 00:42:04,596
that 85 to 15% split you get


1569
00:42:04,796 --> 00:42:05,936
when a user has been subscribed


1570
00:42:05,976 --> 00:42:06,356
for a year.


1571
00:42:07,156 --> 00:42:09,046
The dashboard includes new


1572
00:42:09,046 --> 00:42:11,216
graphs to help you quickly


1573
00:42:11,216 --> 00:42:12,446
identify which subscription


1574
00:42:12,446 --> 00:42:13,466
cohorts are the highest


1575
00:42:13,506 --> 00:42:15,456
performing and you can monitor


1576
00:42:15,726 --> 00:42:17,106
your subscription performance


1577
00:42:17,106 --> 00:42:18,876
over time and compare your app's


1578
00:42:18,926 --> 00:42:20,566
performance across different


1579
00:42:20,566 --> 00:42:21,196
territories.


1580
00:42:22,386 --> 00:42:23,576
Now all this new information is


1581
00:42:23,576 --> 00:42:25,366
not just available inside the


1582
00:42:25,366 --> 00:42:26,706
App Store Connect report, but


1583
00:42:26,996 --> 00:42:27,916
it's now available through the


1584
00:42:27,916 --> 00:42:29,316
new App Store Connect API.


1585
00:42:30,796 --> 00:42:31,806
The report data here is


1586
00:42:31,806 --> 00:42:33,406
available to you daily and you


1587
00:42:33,406 --> 00:42:36,096
can script your own setups to


1588
00:42:36,096 --> 00:42:37,216
import this maybe into your own


1589
00:42:37,216 --> 00:42:38,496
data warehouses for further


1590
00:42:38,526 --> 00:42:39,216
analysis.


1591
00:42:39,926 --> 00:42:41,136
We're not going to go into any


1592
00:42:41,136 --> 00:42:42,036
more information on the App


1593
00:42:42,036 --> 00:42:43,186
Store Connect API here, but I


1594
00:42:43,186 --> 00:42:44,336
really recommend you check out


1595
00:42:44,336 --> 00:42:45,576
the automating App Store Connect


1596
00:42:45,636 --> 00:42:47,266
session in the hall three on


1597
00:42:47,266 --> 00:42:49,006
Thursday at 3 p.m., there's some


1598
00:42:49,006 --> 00:42:50,506
really exciting enhancements in


1599
00:42:50,506 --> 00:42:51,456
the area of automation.


1600
00:42:52,086 --> 00:42:54,036
Now we've talked a bit about


1601
00:42:54,036 --> 00:42:55,356
what you can get from receipts


1602
00:42:55,356 --> 00:42:56,326
and what you can get from these


1603
00:42:56,466 --> 00:42:57,886
App Store Connect reports.


1604
00:42:57,886 --> 00:42:59,976
So as a bit of a summary, App


1605
00:42:59,976 --> 00:43:01,696
Store receipts are useful for


1606
00:43:01,696 --> 00:43:02,856
validating those StoreKit


1607
00:43:02,856 --> 00:43:04,416
transactions and updating user


1608
00:43:04,416 --> 00:43:05,856
subscription states, maintaining


1609
00:43:05,856 --> 00:43:06,706
the state on your server.


1610
00:43:07,396 --> 00:43:08,426
And you can also use them to


1611
00:43:08,426 --> 00:43:10,206
understand individual subscriber


1612
00:43:10,206 --> 00:43:11,266
behavior just like Michael


1613
00:43:11,266 --> 00:43:11,696
showed you.


1614
00:43:11,696 --> 00:43:14,576
For App Store Connect reports


1615
00:43:14,926 --> 00:43:15,846
it's for a slightly different


1616
00:43:15,846 --> 00:43:16,606
reason, they're better at that


1617
00:43:16,606 --> 00:43:18,626
macrolevel analysis, maybe


1618
00:43:18,626 --> 00:43:19,746
understanding subscription


1619
00:43:19,746 --> 00:43:21,516
pathways of users of your app


1620
00:43:21,516 --> 00:43:23,046
and maybe most importantly,


1621
00:43:23,046 --> 00:43:24,366
understanding how much money is


1622
00:43:24,366 --> 00:43:25,496
going to get deposited into your


1623
00:43:25,496 --> 00:43:26,616
bank account for your


1624
00:43:26,616 --> 00:43:27,356
subscriptions.


1625
00:43:27,926 --> 00:43:30,586
Now we've covered a lot of


1626
00:43:30,586 --> 00:43:32,086
topics here today, but as a bit


1627
00:43:32,086 --> 00:43:33,606
of a summary remember that


1628
00:43:33,606 --> 00:43:35,016
server-side state management


1629
00:43:35,016 --> 00:43:36,836
offers you much more flexibility


1630
00:43:37,236 --> 00:43:38,476
when it comes to managing


1631
00:43:38,476 --> 00:43:39,266
subscriptions.


1632
00:43:40,746 --> 00:43:42,116
If you haven't done it yet add


1633
00:43:42,116 --> 00:43:43,396
that URL to receive


1634
00:43:43,396 --> 00:43:44,576
notifications from the App


1635
00:43:44,576 --> 00:43:44,886
Store.


1636
00:43:46,386 --> 00:43:47,136
Consider offering an


1637
00:43:47,136 --> 00:43:48,316
introductory price in your app,


1638
00:43:48,316 --> 00:43:49,596
it's a great way to get users in


1639
00:43:49,596 --> 00:43:50,536
the door to your own


1640
00:43:50,536 --> 00:43:51,166
subscriptions.


1641
00:43:52,696 --> 00:43:54,186
Add some simple messaging to


1642
00:43:54,186 --> 00:43:55,766
reduce subscriber churn, using


1643
00:43:55,766 --> 00:43:56,906
those fields that Michael walked


1644
00:43:56,906 --> 00:43:57,296
us through.


1645
00:43:57,876 --> 00:43:59,556
And for users that have actually


1646
00:43:59,556 --> 00:44:01,756
lapsed offer some alternative


1647
00:44:01,756 --> 00:44:02,906
subscription options maybe to


1648
00:44:02,906 --> 00:44:03,436
win them back.


1649
00:44:04,796 --> 00:44:05,926
Finally, remember to check out


1650
00:44:05,926 --> 00:44:06,886
these new reporting tools


1651
00:44:06,886 --> 00:44:09,126
available in App Store Connect.


1652
00:44:09,756 --> 00:44:11,506
For more information on this


1653
00:44:11,506 --> 00:44:12,656
session and for the video, this


1654
00:44:12,656 --> 00:44:14,166
has been session 705.


1655
00:44:14,596 --> 00:44:15,346
We're also going to be in the


1656
00:44:15,346 --> 00:44:16,796
labs this week right after this


1657
00:44:17,376 --> 00:44:19,006
and also on Thursday at 9 a.m.


1658
00:44:19,006 --> 00:44:19,856
we'll have engineers from the


1659
00:44:19,856 --> 00:44:21,786
StoreKit team and for App Store


1660
00:44:21,786 --> 00:44:22,886
Connect ready to answer any


1661
00:44:22,886 --> 00:44:23,786
questions that you might have


1662
00:44:23,786 --> 00:44:25,216
about engineering subscriptions.


1663
00:44:25,626 --> 00:44:25,976
Thanks a lot.


1664
00:44:26,516 --> 00:44:31,500
[ Applause ]

