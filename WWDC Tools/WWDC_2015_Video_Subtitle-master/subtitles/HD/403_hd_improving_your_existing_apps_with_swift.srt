1
00:00:24,516 --> 00:00:31,906
[ Applause ]


2
00:00:32,406 --> 00:00:32,846
>> WOODY LIDSTONE: Hi, everyone.


3
00:00:34,116 --> 00:00:36,746
I made a comment to Stefan
earlier today, saying,


4
00:00:36,746 --> 00:00:37,956
I hope some people
come out to this.


5
00:00:38,886 --> 00:00:39,866
And it's incredible.


6
00:00:39,866 --> 00:00:40,816
You are just packing the place.


7
00:00:41,016 --> 00:00:42,026
So, thank you for coming out.


8
00:00:42,026 --> 00:00:44,346
My name is Woody, and I
would like to introduce you


9
00:00:44,346 --> 00:00:46,406
to Improving Your
Existing Apps with Swift.


10
00:00:46,986 --> 00:00:48,696
Can I get a show of hands,


11
00:00:48,696 --> 00:00:49,996
how many of you are
actually using Swift


12
00:00:49,996 --> 00:00:53,296
in your code right now?


13
00:00:53,526 --> 00:00:54,366
Okay. Excellent.


14
00:00:54,476 --> 00:00:55,746
Then you are all at
the right session,


15
00:00:56,426 --> 00:00:57,606
whether you've done it or not.


16
00:00:57,786 --> 00:00:59,876
Hopefully by the end of it
you will all be using Swift


17
00:01:00,246 --> 00:01:01,946
with your existing
Objective-C projects.


18
00:01:01,946 --> 00:01:07,066
You know, last year I was also
in this room, I was sitting


19
00:01:07,066 --> 00:01:11,316
in the back corner as an
attendee, using my laptop,


20
00:01:11,316 --> 00:01:14,776
trying to figure out how to
use some of the technologies


21
00:01:14,776 --> 00:01:16,616
that I learned about
in an earlier session,


22
00:01:16,966 --> 00:01:19,396
replying to work email even
though I told them I wouldn't,


23
00:01:20,006 --> 00:01:23,126
and half paying attention to
the presenter that was up here,


24
00:01:23,176 --> 00:01:25,266
as I am sure many
of us are right now.


25
00:01:25,866 --> 00:01:29,196
Well, since then,
I've switched sides


26
00:01:29,406 --> 00:01:31,486
from the attendee to the stage.


27
00:01:31,786 --> 00:01:34,506
I have moved sides of the
continent from Halifax,


28
00:01:34,536 --> 00:01:38,836
Nova Scotia, to California,
and I am out today


29
00:01:38,836 --> 00:01:41,486
to help you learn some
techniques to work


30
00:01:41,486 --> 00:01:42,986
with Swift and Objective-C.


31
00:01:44,056 --> 00:01:47,856
I don't have to go
over and move it.


32
00:01:47,856 --> 00:01:51,216
I've got a remote control now.


33
00:01:51,656 --> 00:01:57,626
So what I want to do is
take you through some


34
00:01:57,626 --> 00:02:00,966
of the techniques you can use to
add Swift to an existing project


35
00:02:00,966 --> 00:02:02,076
to make that project better.


36
00:02:02,456 --> 00:02:04,706
And I thought the approach
I would use would be


37
00:02:04,706 --> 00:02:06,216
to do exactly that
in this session.


38
00:02:06,806 --> 00:02:10,116
So I went to Infinite Loop, I
went down to the parking garage,


39
00:02:10,116 --> 00:02:12,796
and down to a floor below that
where we have our catacombs,


40
00:02:13,216 --> 00:02:16,006
and I went past the three-headed
dog that guards the entrance


41
00:02:16,066 --> 00:02:17,876
to industrial design, to the end


42
00:02:17,876 --> 00:02:19,026
where we keep our
software vault.


43
00:02:19,196 --> 00:02:21,176
And I opened the
software vault and I took


44
00:02:21,176 --> 00:02:24,876
out an app called The Elements
that we haven't seen at WWDC


45
00:02:24,876 --> 00:02:26,276
for maybe two or three years.


46
00:02:26,666 --> 00:02:28,726
I'd like to show you
how it is right now.


47
00:02:30,666 --> 00:02:32,366
Alright, this is The Elements.


48
00:02:32,366 --> 00:02:34,276
Do you remember seeing
this before?


49
00:02:34,536 --> 00:02:36,286
Yeah? Some of you do,
some of you don't.


50
00:02:36,506 --> 00:02:37,536
Somebody really like it.


51
00:02:37,536 --> 00:02:38,176
I like it too.


52
00:02:38,556 --> 00:02:42,846
So it's a standard
UIKit-based table view app.


53
00:02:42,846 --> 00:02:45,326
We have got a bunch
of cells for each


54
00:02:45,616 --> 00:02:47,486
of the elements in
the atomic table.


55
00:02:47,486 --> 00:02:49,176
We have this small,
little detail view


56
00:02:49,176 --> 00:02:50,526
with a little bit
of information.


57
00:02:50,526 --> 00:02:53,056
And if you tap on
one of the cells,


58
00:02:53,056 --> 00:02:57,666
we have this navigation
controllers push presentation


59
00:02:58,766 --> 00:03:04,286
to show some details about that.


60
00:03:05,236 --> 00:03:09,906
Great. I figure it's something


61
00:03:09,906 --> 00:03:11,666
that probably a lot
of you have to do.


62
00:03:11,666 --> 00:03:13,636
You move around between
different applications,


63
00:03:13,886 --> 00:03:15,276
and you come back and
you revisit an app


64
00:03:15,276 --> 00:03:17,306
that you haven't used in a
while or you haven't programmed


65
00:03:17,306 --> 00:03:19,276
in a while and you are asked
to add new features to it


66
00:03:19,276 --> 00:03:21,316
or support a new
operating system, a new SDK.


67
00:03:22,006 --> 00:03:23,666
So that's exactly what
we are going to do.


68
00:03:23,666 --> 00:03:25,396
We are going to modernize
this Objective-C app


69
00:03:25,396 --> 00:03:27,526
and we're going to
do it using Swift.


70
00:03:28,136 --> 00:03:31,836
The pitch to you is this: if
you have an existing application


71
00:03:31,836 --> 00:03:33,866
and you have got to
write new code for it


72
00:03:33,866 --> 00:03:36,456
and that existing application
is an Objective-C app,


73
00:03:36,786 --> 00:03:39,466
consider taking advantage of
Swift's features by writing


74
00:03:39,466 --> 00:03:42,346
that new code in Swift,
while, at the same time,


75
00:03:43,216 --> 00:03:46,376
leave your original
Objective-C code in Objective-C.


76
00:03:46,606 --> 00:03:47,466
That's perfectly fine too.


77
00:03:48,426 --> 00:03:53,286
In this session, we are going
to start by doing a makeover


78
00:03:53,286 --> 00:03:55,426
on the application to
bring its user interface


79
00:03:55,556 --> 00:03:57,096
to a more contemporary
appearance.


80
00:03:57,406 --> 00:03:59,186
We are going to do
that using Swift.


81
00:03:59,396 --> 00:04:01,776
Then we are also going to
take a look at, for example,


82
00:04:01,776 --> 00:04:05,346
Swift's structs and its
functions like mapping


83
00:04:05,346 --> 00:04:06,696
and reducing to find ways


84
00:04:06,696 --> 00:04:08,326
that we can add new
features to the application.


85
00:04:08,846 --> 00:04:15,506
This application has small
tiles and large tiles.


86
00:04:15,866 --> 00:04:17,305
The small tile is
the table view,


87
00:04:17,305 --> 00:04:18,636
the large tile is
the detail view.


88
00:04:19,586 --> 00:04:21,836
And the tiles consist
of a background,


89
00:04:22,116 --> 00:04:24,516
plus the text that's rendered
on top of that background.


90
00:04:25,556 --> 00:04:27,316
Because this app
is an older app,


91
00:04:27,646 --> 00:04:30,386
the backgrounds were originally
rendered in Photoshop,


92
00:04:30,386 --> 00:04:32,316
and then they are just
embedded inside the application.


93
00:04:33,126 --> 00:04:35,276
But these backgrounds
which exist


94
00:04:35,276 --> 00:04:38,276
in different colors depending
on the atomic states, solid,


95
00:04:38,276 --> 00:04:41,316
liquid, synthetics,
gaseous, are only rendered


96
00:04:41,316 --> 00:04:43,456
for the original iPhone.


97
00:04:43,456 --> 00:04:45,286
There is no Retina
artwork included.


98
00:04:45,656 --> 00:04:47,896
Which means when we take
this older app and we run it


99
00:04:47,896 --> 00:04:52,376
on newer hardware, we have to
scale up, and when we scale


100
00:04:52,376 --> 00:04:54,616
up this older, this
older artwork,


101
00:04:54,616 --> 00:04:57,306
we end up getting these
artifacts, called aliasing,


102
00:04:57,536 --> 00:04:59,876
on the rounded corners because
we don't have enough pixel data


103
00:04:59,876 --> 00:05:01,286
to represent those
corners smoothly.


104
00:05:01,286 --> 00:05:03,216
So that's something that we
definitely are going to fix


105
00:05:03,216 --> 00:05:04,606
up in this presentation.


106
00:05:05,116 --> 00:05:09,016
The other thing is,
do you ever look


107
00:05:10,016 --> 00:05:11,576
at your middle school yearbook,


108
00:05:12,046 --> 00:05:15,176
maybe in the '80s
or '90s [applause]?


109
00:05:15,176 --> 00:05:15,746
Yeah, right?


110
00:05:15,746 --> 00:05:16,896
You see a picture of yourself,


111
00:05:17,456 --> 00:05:19,216
and you are there
wearing a vest with, like,


112
00:05:19,216 --> 00:05:22,166
this embroidered kitten on it,
and you are holding a keyboard


113
00:05:22,166 --> 00:05:23,506
because it was cool at the time,


114
00:05:24,136 --> 00:05:25,756
and you've got this
laser background


115
00:05:25,756 --> 00:05:26,766
because that was also cool.


116
00:05:26,766 --> 00:05:27,616
And now you are looking at it


117
00:05:27,616 --> 00:05:29,976
and you are just thinking,
what was I thinking?


118
00:05:30,516 --> 00:05:34,546
[ Laughter ]


119
00:05:35,046 --> 00:05:36,656
Sometimes we look back
at our apps and we think,


120
00:05:37,006 --> 00:05:37,926
what were we thinking?


121
00:05:38,446 --> 00:05:40,486
With the shine and the
gloss and the reflection.


122
00:05:41,246 --> 00:05:43,246
So we are going to fix that.


123
00:05:43,436 --> 00:05:44,196
Fashions change.


124
00:05:44,196 --> 00:05:44,996
Styles change.


125
00:05:45,276 --> 00:05:46,496
And one of the ways
that we can do


126
00:05:46,496 --> 00:05:49,246
that with this app is
simply removing the gloss


127
00:05:49,816 --> 00:05:50,626
on the background.


128
00:05:50,966 --> 00:05:54,896
We get a very contemporary,
rendered rectangle outline.


129
00:05:55,556 --> 00:05:57,926
It looks good in the
small tile as well


130
00:05:57,926 --> 00:05:59,166
as in the large tile
for this app.


131
00:06:00,186 --> 00:06:02,086
Now, we could rerender the
new backgrounds in Photoshop,


132
00:06:02,086 --> 00:06:03,366
and embed them inside
the application,


133
00:06:03,816 --> 00:06:05,376
but clearly this is
an app that we don't,


134
00:06:06,166 --> 00:06:07,396
we don't get into very often.


135
00:06:07,396 --> 00:06:13,156
You know, it might not be until
WWDC 2020 before we come back


136
00:06:13,156 --> 00:06:14,396
to The Elements, and
I'd like to make sure


137
00:06:14,396 --> 00:06:16,786
that it looks good not
just on past hardware


138
00:06:16,786 --> 00:06:19,516
and current hardware, but also
on potential future hardware.


139
00:06:19,516 --> 00:06:23,916
So I am going to choose to put
in some custom drawing code just


140
00:06:23,916 --> 00:06:25,596
to draw the rounded
rectangle background


141
00:06:25,596 --> 00:06:26,636
because it's just a
rounded rectangle.


142
00:06:26,686 --> 00:06:29,136
I am going to do that
in Swift, but I am going


143
00:06:29,136 --> 00:06:30,286
to call it from Objective-C.


144
00:06:30,286 --> 00:06:35,806
To do that, the technique I
am going to use is called Mix


145
00:06:35,806 --> 00:06:38,626
and Match, and we have
numerous sessions both last year


146
00:06:38,626 --> 00:06:40,746
and this year on
interoperability between Swift


147
00:06:40,746 --> 00:06:43,056
and Objective-C, the mechanics


148
00:06:43,056 --> 00:06:44,856
of which can be covered
better in those sessions.


149
00:06:45,206 --> 00:06:46,926
What I would like to do at
this point is just give you an


150
00:06:46,926 --> 00:06:48,746
overview of how the
technology works


151
00:06:49,066 --> 00:06:53,996
and then we'll actually dive
into a demo and you can see it.


152
00:06:54,246 --> 00:06:56,496
Typically when we think
about classes in Objective-C,


153
00:06:56,496 --> 00:06:58,696
we have a header file and
an implementation file,


154
00:06:58,986 --> 00:07:01,226
and those two things together
form our class definition.


155
00:07:02,056 --> 00:07:03,386
But it's possible
that we can have some


156
00:07:03,386 --> 00:07:06,006
of our methods implemented
in a category,


157
00:07:06,006 --> 00:07:07,296
and that's perfectly fine,


158
00:07:07,296 --> 00:07:10,596
and then our class definition
is our base class plus


159
00:07:10,906 --> 00:07:12,016
our category.


160
00:07:12,556 --> 00:07:13,146
And there's nothing to say


161
00:07:13,146 --> 00:07:14,836
that you can't have
multiple categories.


162
00:07:14,836 --> 00:07:17,046
In fact, this is something
that we do with UI table view.


163
00:07:17,046 --> 00:07:19,266
If you look at this header file
in Objective-C, you will see


164
00:07:19,266 --> 00:07:21,866
that there's many
categories on UI table view.


165
00:07:22,946 --> 00:07:26,286
Now, there's also
nothing to say that one


166
00:07:26,286 --> 00:07:28,306
of those categories couldn't
be implemented in Swift,


167
00:07:28,976 --> 00:07:30,436
in which case the
terminology changes


168
00:07:30,436 --> 00:07:31,526
but the concept is the same.


169
00:07:31,526 --> 00:07:34,736
We just call it a Swift
extension on the Objective-C,


170
00:07:34,736 --> 00:07:36,186
in this case, base class.


171
00:07:36,186 --> 00:07:37,276
And there's also nothing


172
00:07:37,276 --> 00:07:40,916
to say you couldn't have
multiple Objective-C categories


173
00:07:40,916 --> 00:07:44,086
mixed in with multiple Swift
extensions and the content


174
00:07:44,086 --> 00:07:47,366
of all of them forms your class.


175
00:07:47,916 --> 00:07:50,116
This lets us have some
of our functions written


176
00:07:50,116 --> 00:07:53,066
in Objective-C, and it lets you
have newer functions be written


177
00:07:53,066 --> 00:07:53,476
in Swift.


178
00:07:53,926 --> 00:07:57,756
For this interoperability
technique to work, we use a set


179
00:07:57,756 --> 00:07:59,946
of bridging headers -- not
a set of bridging headers --


180
00:07:59,946 --> 00:08:01,666
we use a bridging header
and a generated header.


181
00:08:02,266 --> 00:08:06,176
Now, the bridging
header is made in Xcode.


182
00:08:06,176 --> 00:08:07,976
The first time that
you introduce Swift


183
00:08:07,976 --> 00:08:10,166
into an existing
Objective-C project.


184
00:08:10,166 --> 00:08:11,806
And then you maintain it.


185
00:08:11,806 --> 00:08:14,126
You just basically go into it,
and put some import statements


186
00:08:14,126 --> 00:08:16,756
so you can selectively
choose which data types


187
00:08:16,756 --> 00:08:17,446
and header files


188
00:08:17,446 --> 00:08:19,896
from Objective-C you are
going to expose to Swift.


189
00:08:21,136 --> 00:08:22,096
Then on the reciprocal,


190
00:08:22,096 --> 00:08:23,916
the Swift compiler
makes a generated header


191
00:08:24,126 --> 00:08:26,726
which you can import into your
Objective-C implementation files


192
00:08:26,766 --> 00:08:29,776
to expose Swift, in
this case, extensions


193
00:08:30,266 --> 00:08:32,976
and other data types,
to Objective-C.


194
00:08:32,976 --> 00:08:34,606
So we have these
two header files.


195
00:08:34,816 --> 00:08:36,226
You are going to see them
in the demonstration,


196
00:08:37,135 --> 00:08:38,856
which is coming up right now.


197
00:08:50,156 --> 00:08:51,296
Okay. So in my project,


198
00:08:51,296 --> 00:08:53,546
I have this class called
atomic element tile view.


199
00:08:53,546 --> 00:08:56,366
That's the one that actually
draws the background.


200
00:08:56,366 --> 00:08:58,156
There is a method in it.


201
00:08:58,156 --> 00:08:59,936
It's actually not just
drawing the background,


202
00:08:59,936 --> 00:09:01,856
it's drawing the background and
all the text that goes on top


203
00:09:01,856 --> 00:09:03,816
of it for both the small
tile and the large tile.


204
00:09:03,816 --> 00:09:06,266
So I am going to introduce the
new drawing code, but I am going


205
00:09:06,266 --> 00:09:08,496
to do it in Swift, so I will go
ahead and make a new Swift file.


206
00:09:09,106 --> 00:09:10,266
It's command-N in Xcode.


207
00:09:10,266 --> 00:09:15,696
We will choose a
Swift file, create it,


208
00:09:16,106 --> 00:09:18,016
and because it's the first
time that I've added Swift


209
00:09:18,016 --> 00:09:19,466
to this project,
I have the option


210
00:09:19,466 --> 00:09:20,596
to create the bridging
header now.


211
00:09:21,276 --> 00:09:24,056
I want to create
it, so press Return.


212
00:09:24,936 --> 00:09:29,786
And now I have my two files
that consist of the base class


213
00:09:29,786 --> 00:09:32,166
in Objective-C plus
the Swift file.


214
00:09:32,936 --> 00:09:34,496
I also have the bridging
header down here.


215
00:09:34,496 --> 00:09:36,546
Let's just make this
a little bit wider.


216
00:09:36,646 --> 00:09:38,746
There we go.


217
00:09:38,966 --> 00:09:41,466
You might notice that I chose
to use the exact same file name


218
00:09:41,746 --> 00:09:44,156
for my Swift file as I
did for the Objective-C.


219
00:09:44,156 --> 00:09:46,076
That's not a requirement,
but it's a convenience


220
00:09:46,556 --> 00:09:49,746
because it means that in
Xcode, I can use the shortcut


221
00:09:49,746 --> 00:09:52,946
of control-command-up arrow and
just cycle through the Swift


222
00:09:52,946 --> 00:09:55,146
and the Objective-C
header and implementation,


223
00:09:55,286 --> 00:09:57,336
just quickly move back and
forth between all three.


224
00:09:57,806 --> 00:10:01,336
Now, the bridging
header is where I choose


225
00:10:01,336 --> 00:10:04,396
to expose data types that
I've declared in Objective-C


226
00:10:04,436 --> 00:10:06,886
to Swift, and I do that by
importing their header files.


227
00:10:07,586 --> 00:10:11,746
Since I want to extend atomic
element tile view into Swift


228
00:10:11,746 --> 00:10:15,556
or using Swift, I have to import
it into the bridging header.


229
00:10:16,336 --> 00:10:18,566
The only one that I really
need at the moment is the one


230
00:10:18,566 --> 00:10:20,406
that I've highlighted,
atomic element tile view,


231
00:10:20,666 --> 00:10:22,726
but later on in the presentation
I will need the other ones,


232
00:10:22,726 --> 00:10:24,446
so I am just going to go ahead
and get them all imported now.


233
00:10:24,446 --> 00:10:27,766
Now we can go over
to the Swift file,


234
00:10:27,766 --> 00:10:32,796
and I will write an extension
on atomic element tile view.


235
00:10:41,066 --> 00:10:43,716
So now the class atomic element
tile view has this new function


236
00:10:43,716 --> 00:10:45,526
called draw raw background.


237
00:10:45,736 --> 00:10:48,736
And you can see I am also
using the new Xcode 7 markup


238
00:10:48,846 --> 00:10:51,156
to give a document comment,
a documentation comment,


239
00:10:51,156 --> 00:10:53,496
in this case, draw an atomic
elements background tile.


240
00:10:53,496 --> 00:10:55,346
I will go ahead and put the code


241
00:10:55,346 --> 00:10:58,846
in that actually
does the drawing.


242
00:11:02,376 --> 00:11:03,796
And that's it for
the Swift part.


243
00:11:03,796 --> 00:11:07,006
But now I want to call this
Swift function from Objective-C


244
00:11:07,336 --> 00:11:10,496
so that instead of having
the pre-rendered images being


245
00:11:10,496 --> 00:11:12,776
loaded, I am going to
draw using this method.


246
00:11:14,036 --> 00:11:16,016
So I'll switch over to
atomic element tile view.m,


247
00:11:16,016 --> 00:11:19,246
and I want to make sure that it
sees the code that I just added


248
00:11:19,246 --> 00:11:24,916
in Swift, so I will go ahead
and import the generated header.


249
00:11:24,916 --> 00:11:26,966
Generated header uses the
same name as the product,


250
00:11:26,966 --> 00:11:35,136
so the elements, then you
append hyphen Swift.h. And now,


251
00:11:35,256 --> 00:11:37,466
in this method, where
I typically loaded the


252
00:11:37,466 --> 00:11:40,026
pre-rendered backgrounds,
I'll comment that out.


253
00:11:41,226 --> 00:11:45,876
And instead call 'self draw,'
and you can see that the method


254
00:11:45,876 --> 00:11:48,426
from Swift is showing
up as a native method


255
00:11:48,486 --> 00:11:49,646
with everything else
that's there.


256
00:11:49,926 --> 00:11:51,246
You can even see the
comment is showing


257
00:11:51,246 --> 00:11:54,266
up 'draw an atomic
elements background tile.'


258
00:11:54,756 --> 00:11:57,426
So I will pass over the element.


259
00:11:57,426 --> 00:12:04,616
Pass it to bounding rectangle


260
00:12:04,616 --> 00:12:06,026
in which it will draw
the rounded rectangle.


261
00:12:06,836 --> 00:12:10,746
Run the app.


262
00:12:14,596 --> 00:12:15,266
There we go.


263
00:12:15,266 --> 00:12:17,246
So we are having some rounded
rectangles being drawn using


264
00:12:17,246 --> 00:12:18,596
Swift code with Objective-C
[applause].


265
00:12:19,436 --> 00:12:19,886
Thank you.


266
00:12:24,706 --> 00:12:28,436
It's the benefit of planting
your friends in the audience.


267
00:12:29,516 --> 00:12:37,596
[ Laughter ]


268
00:12:38,096 --> 00:12:40,456
Now for the most part, it
looks kind of like I expected.


269
00:12:40,456 --> 00:12:41,336
It's a rounded rectangle.


270
00:12:41,336 --> 00:12:43,166
But the rounded rectangles
themselves,


271
00:12:43,166 --> 00:12:44,376
they don't look the
way I intended.


272
00:12:44,896 --> 00:12:48,786
In fact, if we zoom in on it,
you can see that it's rounded


273
00:12:48,786 --> 00:12:50,786
on the inside but it's not
rounded on the outside,


274
00:12:51,086 --> 00:12:52,246
and that wasn't the intent.


275
00:12:52,406 --> 00:12:54,696
I wanted pure rounded,
pure roundedness


276
00:12:54,696 --> 00:12:55,856
on both the inside
and the outside.


277
00:12:56,716 --> 00:12:59,906
So let's explore in more
detail why that's happening


278
00:12:59,906 --> 00:13:02,886
as we take a look
at Swift structures.


279
00:13:03,276 --> 00:13:04,966
And how Swift makes it easier


280
00:13:04,966 --> 00:13:06,316
and more natural to
work with structs.


281
00:13:06,316 --> 00:13:10,086
So we have a lot of primitive
structs, for example,


282
00:13:10,086 --> 00:13:12,066
in the Core Graphics framework.


283
00:13:12,066 --> 00:13:17,506
We have things like CGrects,
CGpoints, CGsize, and so forth.


284
00:13:17,706 --> 00:13:21,146
And what we did when we drew
is I have a bounding rectangle,


285
00:13:21,146 --> 00:13:23,836
which is a CGrect, and
I drew this bezier path.


286
00:13:23,836 --> 00:13:26,196
Now, the bezier path
is the grey outline


287
00:13:26,536 --> 00:13:29,286
on the screen, drew
the bezier path.


288
00:13:29,696 --> 00:13:31,666
Next it was put inside of
the bounding rectangle,


289
00:13:31,666 --> 00:13:33,046
and you can see the
bounding rectangle here.


290
00:13:34,096 --> 00:13:36,496
Bezier paths themselves are
not something that you see.


291
00:13:36,496 --> 00:13:39,096
They don't render until
you apply a line to them,


292
00:13:39,096 --> 00:13:40,986
like a line stroke, and
then that's what you see,


293
00:13:40,986 --> 00:13:42,626
that's what's rendered
against the bezier path.


294
00:13:43,736 --> 00:13:47,026
So we draw the bezier path.


295
00:13:47,026 --> 00:13:48,186
We then put a stroke on it.


296
00:13:48,536 --> 00:13:51,696
The stroke is, for example, ten
units wide, ten points wide,


297
00:13:52,356 --> 00:13:53,866
but it's going outside
the boundaries


298
00:13:53,866 --> 00:13:54,736
of the bounding rectangle.


299
00:13:55,316 --> 00:13:58,016
And that results in clipping.


300
00:13:58,746 --> 00:14:00,816
So the rounded rectangle is
actually there on the outside,


301
00:14:00,816 --> 00:14:01,916
but this clipping
that's happening


302
00:14:01,916 --> 00:14:03,746
with the bounding rectangle is
preventing it from being there.


303
00:14:05,046 --> 00:14:07,836
I know some of you in the
audience might think, well,


304
00:14:07,836 --> 00:14:08,836
if you have an issue
with clipping,


305
00:14:08,836 --> 00:14:11,386
just turn clipping off, and
then that issue is fixed


306
00:14:11,386 --> 00:14:12,376
and you go on to the next thing.


307
00:14:14,156 --> 00:14:15,496
Which is, I suppose, true.


308
00:14:15,496 --> 00:14:19,526
It's kind of like solving
issues with Swift, though,


309
00:14:19,596 --> 00:14:23,396
in Xcode by just shuffling
around Swift's exclamation marks


310
00:14:23,646 --> 00:14:24,596
until it compiles [laughter].


311
00:14:27,156 --> 00:14:30,116
You can do it, but I would
never call that a best practice.


312
00:14:30,766 --> 00:14:33,406
And when it comes to clipping,


313
00:14:33,406 --> 00:14:36,646
there's a performance
issue with this.


314
00:14:36,746 --> 00:14:39,696
With every API that you
call, with every task


315
00:14:39,746 --> 00:14:42,606
that you initiate, with
every move that you make


316
00:14:42,606 --> 00:14:43,776
and every breath that
you take - [laughter] --


317
00:14:44,026 --> 00:14:47,706
you need to consider the impact
on power and performance.


318
00:14:48,246 --> 00:14:49,596
And it's not very performant


319
00:14:49,596 --> 00:14:52,016
to be constantly calculating the
intersection of two rectangles


320
00:14:52,016 --> 00:14:53,056
and performing clipping on it.


321
00:14:53,056 --> 00:14:55,756
It's more performant
just to set the rectangle


322
00:14:55,756 --> 00:14:57,336
to be the right size
in the first place.


323
00:14:57,336 --> 00:14:59,856
That's what we are going to do.


324
00:14:59,856 --> 00:15:02,266
We are just going to
inset the bezier path


325
00:15:02,266 --> 00:15:03,536
so that it doesn't clip itself.


326
00:15:04,146 --> 00:15:07,216
Now, to do that, we are
going to use some methods --


327
00:15:07,216 --> 00:15:10,796
and I do mean methods,
available on CGrect,


328
00:15:11,056 --> 00:15:12,936
when it's being used in Swift.


329
00:15:14,006 --> 00:15:15,966
Think about how these primitive
types are used normally.


330
00:15:15,966 --> 00:15:18,176
We have things like CGrect
and CGpoint, and so forth,


331
00:15:18,176 --> 00:15:20,846
as I said, and they
might exist over here.


332
00:15:20,846 --> 00:15:23,266
And then separately
you have got the set


333
00:15:23,266 --> 00:15:28,126
of global utility functions that
work on them, like CGrectZero,


334
00:15:28,126 --> 00:15:31,256
CGrectMake, or GetWidth,
or some actual functions


335
00:15:31,256 --> 00:15:33,426
like get the union
or the intersection.


336
00:15:33,926 --> 00:15:35,786
There's this cognitive
separation between the two.


337
00:15:35,786 --> 00:15:37,636
We know that this is the
type, and then we have to know


338
00:15:37,636 --> 00:15:40,136
that these are the
methods -- or sorry --


339
00:15:40,246 --> 00:15:42,526
the functions that act upon it.


340
00:15:43,056 --> 00:15:45,586
Well, when we work in Swift,
we actually change how things


341
00:15:45,586 --> 00:15:49,556
like CGrect and CGpoint
and CGsize come into Swift.


342
00:15:50,476 --> 00:15:52,896
We basically use encapsulation
and take all those,


343
00:15:53,406 --> 00:15:56,326
those global, formerly
global functions that can act


344
00:15:56,326 --> 00:15:59,096
on that structure and build
it into the structure,


345
00:16:00,546 --> 00:16:02,776
which makes it much easier
to have code completion,


346
00:16:02,776 --> 00:16:06,846
makes it more awesome to
predict what the API is,


347
00:16:06,846 --> 00:16:09,356
because you can just
do my struct dot


348
00:16:09,646 --> 00:16:11,746
and then you get code
completion for all the methods


349
00:16:11,826 --> 00:16:12,906
and properties that it has.


350
00:16:14,006 --> 00:16:16,036
But if we left the
names like this,


351
00:16:16,486 --> 00:16:17,866
it wouldn't really feel native.


352
00:16:18,346 --> 00:16:22,976
So the names are actually
remapped to have a feel


353
00:16:22,976 --> 00:16:25,856
to make them first-class
methods on these data types.


354
00:16:26,366 --> 00:16:30,316
The benefit of this is the way
that you work with structures


355
00:16:30,316 --> 00:16:34,406
in Swift, calling functions
or calling methods really


356
00:16:34,406 --> 00:16:36,816
or accessing their
properties, exactly the same way


357
00:16:37,046 --> 00:16:38,736
that you work with classes.


358
00:16:38,736 --> 00:16:42,336
It's exactly the same way that
you work with enums, or enums.


359
00:16:42,946 --> 00:16:45,186
It's all the same
consistent style.


360
00:16:45,596 --> 00:16:48,196
We also get to use
initializers that are the same


361
00:16:48,196 --> 00:16:49,586
across all the different
data types.


362
00:16:49,886 --> 00:16:51,846
We get to have better
code completion.


363
00:16:51,846 --> 00:16:56,116
So all in all, working with
these types is much more natural


364
00:16:56,116 --> 00:16:57,646
in Swift because they behave


365
00:16:57,646 --> 00:17:00,746
as first-class data
types with methods.


366
00:17:01,406 --> 00:17:04,386
Okay. The other thing
that we are going to do


367
00:17:04,386 --> 00:17:06,836
in the following demonstration
is, I don't know about you,


368
00:17:06,836 --> 00:17:07,925
but when I work with
graphics code,


369
00:17:07,925 --> 00:17:09,965
especially some Core Graphics
stuff, one of the approaches


370
00:17:09,965 --> 00:17:15,756
that I would use is, I
would render the code,


371
00:17:15,756 --> 00:17:18,046
and then I would run it, and
then it builds and it copies


372
00:17:18,046 --> 00:17:20,016
into the simulator, then
I navigate to that part


373
00:17:20,016 --> 00:17:22,945
in the simulator where the
code is actually activated,


374
00:17:22,945 --> 00:17:23,626
where it's used.


375
00:17:23,786 --> 00:17:25,906
Then I inspect it, and if
I don't like it, I go back


376
00:17:25,906 --> 00:17:27,616
and I tweak the code and
I run the whole thing.


377
00:17:27,616 --> 00:17:29,516
This is a -- this loop,


378
00:17:29,906 --> 00:17:32,096
this round-trip can be
really expensive time-wise.


379
00:17:32,176 --> 00:17:34,406
Just to see what it looks like
when you change a line width


380
00:17:34,406 --> 00:17:37,226
from three to four or you
turn off rasterization


381
00:17:37,226 --> 00:17:38,906
or you do some sort of
setting change as you try


382
00:17:38,906 --> 00:17:39,646
to get things to work.


383
00:17:40,396 --> 00:17:42,946
So there's a better approach


384
00:17:43,776 --> 00:17:45,306
that doesn't have
this round-tripping,


385
00:17:45,816 --> 00:17:48,296
and it doesn't have you
often commenting out portions


386
00:17:48,296 --> 00:17:50,276
of your code just to
experiment with how it looks.


387
00:17:50,276 --> 00:17:51,366
If you really want
to experiment,


388
00:17:51,366 --> 00:17:54,646
and play around with some code,
and see how it, how it works,


389
00:17:54,996 --> 00:17:56,046
that's what we have
playgrounds for.


390
00:17:56,726 --> 00:17:58,586
With playgrounds, this
loop gets switched


391
00:17:58,586 --> 00:17:59,466
to just something like this.


392
00:17:59,466 --> 00:18:01,716
You just tweak the code, and
you see the change right away,


393
00:18:01,716 --> 00:18:03,236
and if you don't like it,
just change it right away.


394
00:18:03,616 --> 00:18:05,366
There's none of that copying
to the simulator, navigate


395
00:18:05,366 --> 00:18:06,126
and see what it looks like.


396
00:18:06,526 --> 00:18:07,846
So we are going to
fix up the problem


397
00:18:07,846 --> 00:18:10,456
with our rounded
rectangles, using a playground


398
00:18:10,456 --> 00:18:13,496
and using the methods
that are part of CGrect


399
00:18:13,796 --> 00:18:15,096
to get a better CGrect
out of it.


400
00:18:15,526 --> 00:18:15,966
Let me show you.


401
00:18:24,086 --> 00:18:26,236
The drawing code is over
in atomic element tile view


402
00:18:26,236 --> 00:18:26,786
dot Swift.


403
00:18:26,786 --> 00:18:27,226
That's here.


404
00:18:27,596 --> 00:18:29,116
And this is the function
that I just copied


405
00:18:29,116 --> 00:18:30,406
in the previous demonstration.


406
00:18:30,846 --> 00:18:32,266
It's the one I want to play
with, so I am just going


407
00:18:32,266 --> 00:18:33,366
to copy it into a playground.


408
00:18:33,776 --> 00:18:35,996
So I've copied it,
I'll hit command-N


409
00:18:35,996 --> 00:18:36,976
and make a new iOS playground.


410
00:18:47,046 --> 00:18:47,396
Paste it in.


411
00:18:48,256 --> 00:18:49,586
And now I have the
drawing function.


412
00:18:50,446 --> 00:18:53,086
No developer is an island.


413
00:18:53,676 --> 00:18:55,846
No drawing functions
live in isolation either.


414
00:18:56,286 --> 00:18:58,586
Drawing functions have to
draw in the context of --


415
00:18:58,796 --> 00:19:00,526
well, a drawing context
or graphics context.


416
00:19:00,526 --> 00:19:02,826
And the easiest way to get
a graphics context is just


417
00:19:02,826 --> 00:19:04,166
to make a subclass of UIView.


418
00:19:04,396 --> 00:19:05,806
So that's exactly
what I am going to do.


419
00:19:05,806 --> 00:19:09,226
I am just going to declare
a subclass of UIView here.


420
00:19:09,226 --> 00:19:13,966
All it does is call
that drawing function,


421
00:19:13,966 --> 00:19:18,756
and then I'll instantiate
that class here.


422
00:19:19,756 --> 00:19:25,326
And then I can take the image
that's drawn as a result


423
00:19:25,326 --> 00:19:27,496
of my drawing function
and just add it directly


424
00:19:27,496 --> 00:19:28,696
to the storyboard here.


425
00:19:29,226 --> 00:19:32,396
Make it larger so we can see it.


426
00:19:32,726 --> 00:19:35,296
And then you can
experiment with it.


427
00:19:35,296 --> 00:19:36,716
You can kind of figure
out what you need to do


428
00:19:36,716 --> 00:19:38,516
to make it draw the way
you want it to draw.


429
00:19:38,516 --> 00:19:40,426
So, for example, I
want to see if it looks


430
00:19:40,426 --> 00:19:42,526
like if it has only
120 points across.


431
00:19:43,806 --> 00:19:44,706
There's the result right away.


432
00:19:46,236 --> 00:19:47,156
Maybe I want to see
what it looks


433
00:19:47,156 --> 00:19:49,766
like if the line width
isn't 6 but is actually 60,


434
00:19:50,396 --> 00:19:54,766
with a corner radius of 356.


435
00:19:55,106 --> 00:19:56,456
That's what we get.


436
00:19:56,456 --> 00:19:58,616
So you can keep experimenting
with it.


437
00:19:58,616 --> 00:20:00,556
And then once you have the code
working the way that you like,


438
00:20:00,886 --> 00:20:01,896
you just copy and paste it back


439
00:20:01,896 --> 00:20:03,326
into the actual file
from which it came.


440
00:20:04,486 --> 00:20:08,396
So in this case, I want to have
my line width scale so that


441
00:20:08,396 --> 00:20:10,396
if it's the small tile
view in the table view,


442
00:20:10,926 --> 00:20:13,006
it's got thin edges, and
if it's the larger one,


443
00:20:13,006 --> 00:20:14,486
it has proportionately
thicker edges.


444
00:20:14,696 --> 00:20:18,006
So I am going to make
it related to the width


445
00:20:18,006 --> 00:20:18,846
of the background rectangle.


446
00:20:19,496 --> 00:20:24,066
So background rectangle.width
divided by, in this case, 36.


447
00:20:24,166 --> 00:20:26,956
And I will do the same
thing for the corner radius.


448
00:20:27,846 --> 00:20:30,316
Backgroundrectangle.width
divided


449
00:20:30,316 --> 00:20:32,496
by something smaller, like 16.


450
00:20:33,066 --> 00:20:36,846
So now it's starting to
look like I want it to look,


451
00:20:36,846 --> 00:20:38,326
but I still have the
problem where I am clipping,


452
00:20:38,386 --> 00:20:39,966
so I am not able to
see the full extent


453
00:20:40,406 --> 00:20:42,536
of the stroke nor the
rounded rectangles.


454
00:20:42,536 --> 00:20:45,686
So, to do that, on
background rectangle,


455
00:20:45,776 --> 00:20:50,596
I will use the method
called rect by insetting,


456
00:20:50,596 --> 00:20:53,386
and I will inset it to
be half the line width.


457
00:20:53,936 --> 00:20:58,546
So that's line width
divided by 2 and same thing,


458
00:20:58,756 --> 00:21:00,526
line width divided by 2.


459
00:21:01,076 --> 00:21:05,126
And there, now I have a
perfectly rounded rectangle


460
00:21:05,126 --> 00:21:07,386
exactly like I expected to
have in the first place.


461
00:21:08,026 --> 00:21:13,466
I will copy this code from
here back to the extension,


462
00:21:13,826 --> 00:21:15,336
replacing the file -- sorry --


463
00:21:15,336 --> 00:21:16,366
replacing the method
that's there.


464
00:21:17,446 --> 00:21:18,776
Rerun the app with command-R.


465
00:21:19,596 --> 00:21:25,186
And that's exactly what I wanted
to have, rounded rectangles.


466
00:21:25,956 --> 00:21:26,506
Yeah, please.


467
00:21:26,616 --> 00:21:26,776
Yeah.


468
00:21:27,516 --> 00:21:33,836
[ Applause ]


469
00:21:34,336 --> 00:21:36,806
Yeah, pretty much at
WWDC, if ever you feel


470
00:21:36,806 --> 00:21:37,806
like applauding, just applaud.


471
00:21:38,516 --> 00:21:39,976
Nobody is going to
say stop that.


472
00:21:40,346 --> 00:21:40,856
It's all good [applause].


473
00:21:41,536 --> 00:21:42,426
See, thank you.


474
00:21:45,086 --> 00:21:46,386
So the app is looking okay.


475
00:21:46,386 --> 00:21:47,476
I've got these rounded
rectangles.


476
00:21:47,476 --> 00:21:48,596
That's great, that's
what I want.


477
00:21:48,916 --> 00:21:49,886
But the next thing I want


478
00:21:49,886 --> 00:21:51,826
to do is make this app feel
more like a current app.


479
00:21:51,896 --> 00:21:55,606
Now, I don't know about
you, but have you ever gone


480
00:21:55,876 --> 00:21:59,366
to your client after
especially WWDC and said, hey,


481
00:21:59,366 --> 00:22:01,036
there's this new version
of iOS coming out,


482
00:22:01,036 --> 00:22:02,606
for example, iOS
9 is coming out.


483
00:22:02,696 --> 00:22:06,126
I think we should just
not support iOS 8 anymore,


484
00:22:06,426 --> 00:22:09,276
and we are only going to support
the new upcoming operating


485
00:22:09,276 --> 00:22:09,466
system [applause].


486
00:22:10,576 --> 00:22:12,206
Yeah. Have you done
that [applause]?


487
00:22:15,576 --> 00:22:16,886
Yeah, and then you are looking
for another client [laughter].


488
00:22:18,046 --> 00:22:22,246
Because they all want you to
support these old versions,


489
00:22:22,696 --> 00:22:26,016
iOS 7, 8, and now 9 is
probably going to be on slate


490
00:22:26,016 --> 00:22:27,096
for this fall for many of you.


491
00:22:27,586 --> 00:22:31,376
So to do that, we have this new
availability feature introduced


492
00:22:31,376 --> 00:22:32,266
in Swift 2.0.


493
00:22:32,266 --> 00:22:33,996
So as long as you are writing
some code in Swift 2.0,


494
00:22:33,996 --> 00:22:37,706
we have a great way to check
to see what SDK you are on


495
00:22:37,706 --> 00:22:40,326
and if you can actually
use this feature or not.


496
00:22:40,646 --> 00:22:43,446
Now, last year at WWDC,


497
00:22:43,446 --> 00:22:47,266
we introduced some new view
controller presentation APIs


498
00:22:47,386 --> 00:22:50,396
that allow for popover
presentations on iPhone.


499
00:22:51,076 --> 00:22:53,816
So what I want to do in my
elements app is when I am


500
00:22:53,816 --> 00:22:57,626
on any device that supports it
-- for example, an iOS 8 device


501
00:22:57,626 --> 00:23:00,016
or newer -- I want to use
a popover presentation.


502
00:23:00,196 --> 00:23:01,636
But when I am on iOS 7,


503
00:23:01,636 --> 00:23:04,526
I want to continue using
the navigation push


504
00:23:04,526 --> 00:23:05,286
presentation style.


505
00:23:05,286 --> 00:23:06,626
All right.


506
00:23:06,626 --> 00:23:07,766
So how do we do this?


507
00:23:07,766 --> 00:23:12,756
Well, this is the classic
way of checking to see


508
00:23:12,756 --> 00:23:13,786
if you support an API.


509
00:23:14,026 --> 00:23:16,726
We do whatever the type
is, we check and see


510
00:23:16,726 --> 00:23:17,936
if it responds to selector.


511
00:23:17,936 --> 00:23:20,076
And if so, then we
just use the selector.


512
00:23:20,076 --> 00:23:22,006
If not, then we do
something else.


513
00:23:23,496 --> 00:23:27,216
This is the way that we do
it in Swift, as of Swift 2.0.


514
00:23:27,686 --> 00:23:32,426
We have this hashtag available,
and you specify the SDK


515
00:23:32,426 --> 00:23:36,466
that you want, so iOS 8.3 in
this case, and then if so,


516
00:23:36,466 --> 00:23:38,736
we use a popover, and if not,
we use the other approach.


517
00:23:39,236 --> 00:23:41,996
And the benefit of this style
is that you are not waiting


518
00:23:41,996 --> 00:23:44,136
to runtime to see if
it actually works.


519
00:23:44,186 --> 00:23:47,336
At compilation time, the
compiler can tell you, yes,


520
00:23:47,586 --> 00:23:49,426
this will work, or it
won't work depending


521
00:23:49,426 --> 00:23:50,856
on your deployment target.


522
00:23:50,856 --> 00:23:53,806
So if I am deploying to iOS
7, it's able to tell me,


523
00:23:54,016 --> 00:23:55,736
popover isn't available.


524
00:23:55,736 --> 00:23:57,156
But because I've
properly guarded it


525
00:23:57,456 --> 00:23:59,506
by giving it another path,
it's able to compile.


526
00:24:00,096 --> 00:24:05,056
In this case, if I hadn't put
that guard in, if I hadn't said,


527
00:24:05,356 --> 00:24:09,476
here's the check and I tried to
compile this and it was trying


528
00:24:09,476 --> 00:24:12,886
to deploy back to
iOS 7, it would say,


529
00:24:13,066 --> 00:24:15,016
popover presentation
controller is not available.


530
00:24:15,136 --> 00:24:16,236
It's only available
on 8 or newer.


531
00:24:17,036 --> 00:24:18,276
And then it gives
you some fixes.


532
00:24:18,396 --> 00:24:19,826
But instead of just showing
you some more slides,


533
00:24:19,826 --> 00:24:21,016
let me actually show
it to you in code.


534
00:24:22,006 --> 00:24:22,826
Alright. So first of all,


535
00:24:22,826 --> 00:24:25,666
the code that presents the
second view controller is kept


536
00:24:25,666 --> 00:24:28,496
over in
elementsviewcontroller.m. It's


537
00:24:28,496 --> 00:24:32,466
just an implementation of table
view accessory but in tapped


538
00:24:32,466 --> 00:24:33,566
for row with index path.


539
00:24:34,756 --> 00:24:36,326
And because I want to use
availability checking,


540
00:24:36,326 --> 00:24:38,896
I have to have this implemented
in Swift, not Objective-C.


541
00:24:38,896 --> 00:24:40,176
So I am just going
to comment it out.


542
00:24:40,176 --> 00:24:43,746
And then I am going to
create a class extension much


543
00:24:43,746 --> 00:24:46,706
like the original demo
from 20 minutes or so ago,


544
00:24:46,706 --> 00:24:50,946
so that I can extend elements
view controller and have some


545
00:24:50,946 --> 00:24:52,636
of its functionality
implemented in Swift.


546
00:24:52,636 --> 00:24:56,006
So I will hit command-N to make
a new file, it's a Swift file.


547
00:24:56,776 --> 00:24:59,676
It's elements view
controller dot Swift.


548
00:25:01,086 --> 00:25:03,616
Then I will write a class
extension on it here.


549
00:25:05,276 --> 00:25:08,256
Extension, elements
view controller,


550
00:25:09,966 --> 00:25:14,286
and inside of there I will
just take the equivalent


551
00:25:14,436 --> 00:25:15,166
Swift function.


552
00:25:15,246 --> 00:25:16,866
So this is essentially
the same code


553
00:25:16,866 --> 00:25:17,846
that I already had
there in Swift.


554
00:25:17,846 --> 00:25:19,286
There's nothing new
at this point.


555
00:25:19,286 --> 00:25:21,136
It's just the same thing
now implemented in Swift,


556
00:25:21,676 --> 00:25:23,516
but this lets me bring up
the availability checking.


557
00:25:24,126 --> 00:25:29,766
This particular application
is targeting iOS 7.1,


558
00:25:30,756 --> 00:25:34,216
and I want to use this new
popover presentation controller


559
00:25:34,796 --> 00:25:40,346
technique in it, so I am going
to comment out this line and put


560
00:25:40,346 --> 00:25:42,846
in code that tries to directly
call the popover presentation.


561
00:25:47,316 --> 00:25:48,646
So I am getting some errors.


562
00:25:49,036 --> 00:25:50,406
One of the errors it's
complaining about is


563
00:25:50,406 --> 00:25:52,906
that I don't actually conform
to the delegate protocol


564
00:25:52,906 --> 00:25:54,366
that I need to for popovers.


565
00:25:55,106 --> 00:25:58,896
Well, just on the aside, it's
okay to take an extension


566
00:25:58,896 --> 00:26:00,786
in Swift and use it
to add conformance


567
00:26:01,226 --> 00:26:02,626
to additional protocols.


568
00:26:02,756 --> 00:26:06,066
So I'll just add UI popover
presentation controller


569
00:26:06,066 --> 00:26:06,716
delegate there.


570
00:26:07,416 --> 00:26:11,166
That clears up that error,
but I still have the problem


571
00:26:11,896 --> 00:26:15,766
about trying to use an API
that doesn't exist on iOS 7.1,


572
00:26:16,196 --> 00:26:18,076
which is exactly
what I wanted --


573
00:26:18,076 --> 00:26:19,106
well, in the demonstration
anyway.


574
00:26:19,796 --> 00:26:21,916
So I have a couple
of ways to fix it.


575
00:26:23,126 --> 00:26:25,356
I have it pre-baked
for you here.


576
00:26:26,356 --> 00:26:30,686
To say if I am running on
-- in this case, iOS 8.3 --


577
00:26:31,016 --> 00:26:32,376
go ahead and display
as a popover.


578
00:26:32,376 --> 00:26:34,076
Otherwise, use navigation
controller.


579
00:26:34,686 --> 00:26:43,006
Now, if I run it and I tap
on the i -- let's see here.


580
00:26:44,056 --> 00:26:45,736
We get a popover.


581
00:26:46,916 --> 00:26:49,786
It's been 15 years and we
are still getting Carbon


582
00:26:50,346 --> 00:26:51,826
at WWDC [applause].


583
00:26:52,646 --> 00:26:52,836
Alright.


584
00:27:05,076 --> 00:27:06,586
For more information about
availability checking,


585
00:27:06,746 --> 00:27:08,536
please check out Thursday's
session called Swift


586
00:27:08,536 --> 00:27:09,146
in Practice.


587
00:27:09,146 --> 00:27:13,806
There's a whole big
talk about it.


588
00:27:14,076 --> 00:27:15,896
Next up, the previous
demonstrations were


589
00:27:15,896 --> 00:27:19,066
about improving and modernizing
the look of the application.


590
00:27:19,066 --> 00:27:21,566
You know, we changed the
drawing to get rid of the gloss.


591
00:27:21,566 --> 00:27:23,136
We now have a popover
and so forth.


592
00:27:23,136 --> 00:27:25,256
But let's actually add
some functionality to it.


593
00:27:25,486 --> 00:27:28,456
So we are going to
implement live searching.


594
00:27:28,826 --> 00:27:29,926
And to do that, we are
going to take a look


595
00:27:29,926 --> 00:27:32,366
at Swift's filter method,
which is now available


596
00:27:32,366 --> 00:27:34,876
on all collections,
including sets and arrays.


597
00:27:35,696 --> 00:27:39,056
Filtering can be used to
drive a live search function


598
00:27:39,056 --> 00:27:40,086
where only atomic elements


599
00:27:40,116 --> 00:27:43,136
that match the search string
are displayed in the table view.


600
00:27:43,466 --> 00:27:47,036
A standard setup for this would
be, well, something like this.


601
00:27:47,036 --> 00:27:47,856
We've got a TableView.


602
00:27:47,856 --> 00:27:50,206
The TableView is paired
with a view controller


603
00:27:50,206 --> 00:27:51,556
that acts as its data source.


604
00:27:51,986 --> 00:27:53,856
That view controller
has an array of content.


605
00:27:54,566 --> 00:27:59,216
And when I type something
into the search field,


606
00:27:59,286 --> 00:28:01,396
I have a delegate
method that's called,


607
00:28:01,736 --> 00:28:03,876
on the view controller called
searchbar:textDidChange.


608
00:28:03,876 --> 00:28:07,556
I figure out the string
that's been passed.


609
00:28:07,846 --> 00:28:08,566
It's just an argument.


610
00:28:09,026 --> 00:28:10,586
I filter the array of content.


611
00:28:10,666 --> 00:28:12,206
And then I tell the
TableView to update


612
00:28:12,206 --> 00:28:17,126
with this now filtered
array of content.


613
00:28:17,956 --> 00:28:21,136
Search bar:textDidChange
looks something like this.


614
00:28:22,206 --> 00:28:24,116
In actuality, it looks
exactly like this


615
00:28:24,116 --> 00:28:25,316
because that's the
code that I am using.


616
00:28:25,826 --> 00:28:26,986
Now I want to draw
your attention


617
00:28:27,526 --> 00:28:29,886
to the highlighted
section, which is a closure.


618
00:28:30,426 --> 00:28:32,646
So I am running a
filter, and in the filter,


619
00:28:32,956 --> 00:28:34,796
it's going to be applied
to every one of the items


620
00:28:34,796 --> 00:28:37,386
in the array, and that item in
the array, I have a placeholder,


621
00:28:37,386 --> 00:28:39,896
which the dollar sign zero,
I am getting its name,


622
00:28:39,896 --> 00:28:41,616
and then I'm asking
if it has the prefix,


623
00:28:41,616 --> 00:28:42,726
and whatever the
search string is.


624
00:28:43,236 --> 00:28:46,856
It kind of works like this.


625
00:28:46,916 --> 00:28:49,026
Here I have my original
array up at the top.


626
00:28:49,026 --> 00:28:51,106
And I have a closure for filter.


627
00:28:51,686 --> 00:28:52,616
And it just cycles through,


628
00:28:52,616 --> 00:28:55,636
passing in the element each
time, and if it has the name


629
00:28:55,856 --> 00:28:57,386
that begins with the
letter, in this case N,


630
00:28:57,836 --> 00:28:59,736
it's passed through to the
returning filtered array.


631
00:29:00,806 --> 00:29:02,476
And if not, it's not.


632
00:29:02,716 --> 00:29:03,776
Let me show you this in code.


633
00:29:04,346 --> 00:29:06,226
But just to speed things
along, I've already gone


634
00:29:06,926 --> 00:29:08,146
and put a search
bar up at the top.


635
00:29:08,886 --> 00:29:09,836
But I haven't rigged it up yet,


636
00:29:09,836 --> 00:29:11,246
so if I try to do
anything inside of it,


637
00:29:11,246 --> 00:29:14,216
it just doesn't work because I
haven't put the delegate method


638
00:29:14,216 --> 00:29:15,166
in yet.


639
00:29:16,296 --> 00:29:18,986
The delegate method is this.


640
00:29:22,756 --> 00:29:24,666
We are saying, if the
search text is empty,


641
00:29:24,696 --> 00:29:25,986
show all the atomic elements.


642
00:29:26,566 --> 00:29:27,116
That's here.


643
00:29:28,156 --> 00:29:30,476
If it's not empty, I
want to do a filter,


644
00:29:30,476 --> 00:29:31,876
and that part is
left to be done.


645
00:29:31,876 --> 00:29:32,596
Let's do it right now.


646
00:29:38,136 --> 00:29:39,206
So I am going to
bring up a filter.


647
00:29:39,286 --> 00:29:41,506
And if it's the first time
that you've seen closures,


648
00:29:41,946 --> 00:29:43,626
great, welcome to closures.


649
00:29:43,816 --> 00:29:44,896
Let me show you a
little bit about it.


650
00:29:44,896 --> 00:29:46,926
And if not, maybe it's
a bit of a review.


651
00:29:47,296 --> 00:29:49,966
When Xcode shows you these blue
kind of tokenized backgrounds


652
00:29:49,966 --> 00:29:52,086
that are all singular items,
you can double-click them,


653
00:29:52,086 --> 00:29:54,316
and they expand out, and
you just fill in the blanks.


654
00:29:54,696 --> 00:29:57,436
So I'll take this closure,
double-click it, it expands out.


655
00:29:57,436 --> 00:30:01,926
And I know that I have an
array of atomic elements.


656
00:30:01,926 --> 00:30:03,556
The data type is
called atomic element.


657
00:30:04,056 --> 00:30:07,286
So the parameter that's being
passed in is one atomic element.


658
00:30:07,286 --> 00:30:10,106
So I am just going to
specify that in this closure,


659
00:30:10,606 --> 00:30:11,786
the parameters that
are being passed


660
00:30:11,786 --> 00:30:14,356
in is one atomic element -- I am
going to give it a local name,


661
00:30:14,356 --> 00:30:17,366
so atomic element
is its local name,


662
00:30:17,366 --> 00:30:19,776
and its data type
is atomic element.


663
00:30:21,256 --> 00:30:23,836
Inside the closure, I need
to check to see if I want


664
00:30:23,836 --> 00:30:26,696
to include it in the
filtered results or not


665
00:30:27,046 --> 00:30:29,706
because I promised to give a
return value that's a Boolean.


666
00:30:30,876 --> 00:30:35,626
So I'll say my return value
is whether the atomic element,


667
00:30:36,246 --> 00:30:42,056
name, has prefix, and then
the search text that's passed


668
00:30:42,056 --> 00:30:42,816
in from the search bar.


669
00:30:43,406 --> 00:30:48,346
Like that.


670
00:30:49,476 --> 00:30:58,036
Now, when I run it, we'll
do a search for everything


671
00:30:58,036 --> 00:30:59,016
that begins with letter N.


672
00:30:59,416 --> 00:30:59,796
There we go.


673
00:30:59,796 --> 00:31:01,766
We get it filtered
using Swift's filter.


674
00:31:02,876 --> 00:31:04,706
But there's two things
I want to show you.


675
00:31:04,706 --> 00:31:06,766
One, there's really
two different ways


676
00:31:06,766 --> 00:31:07,846
to take a look at closures.


677
00:31:07,846 --> 00:31:09,996
There's this expanded syntax.


678
00:31:11,476 --> 00:31:13,316
There's also a condensed syntax.


679
00:31:13,546 --> 00:31:16,946
Let me show you the
condensed syntax.


680
00:31:16,946 --> 00:31:19,176
Swift has a very strong
type inference system.


681
00:31:19,176 --> 00:31:22,056
We can infer a lot of things
based on context and the kind


682
00:31:22,056 --> 00:31:23,056
of data types that
you are using.


683
00:31:23,536 --> 00:31:26,576
So for example, if you have
a single line in a closure,


684
00:31:26,576 --> 00:31:29,376
it's assumed that it's going to
return a value, so I don't have


685
00:31:29,376 --> 00:31:30,366
to put the return in there.


686
00:31:30,796 --> 00:31:35,196
And in fact, has prefix gives
a return type of Boolean


687
00:31:35,196 --> 00:31:36,966
so Swift can infer
that the return type


688
00:31:36,966 --> 00:31:39,076
for this closure is Boolean,
so I don't really need


689
00:31:39,076 --> 00:31:41,236
to have this here, which
means I don't have to have


690
00:31:41,236 --> 00:31:43,996
that there either, and since
atomic elements is an array


691
00:31:43,996 --> 00:31:46,656
of atomic elements, I
don't have to specify


692
00:31:46,656 --> 00:31:48,566
that an atomic element
is being passed in,


693
00:31:48,566 --> 00:31:49,476
so I can get rid of that.


694
00:31:49,476 --> 00:31:51,676
And since I don't have any
parameters, I don't have


695
00:31:51,676 --> 00:31:53,916
to separate the parameters from
the code, so I don't need the


696
00:31:53,916 --> 00:31:57,336
in keyword, which means I can
get rid of that and just tidy


697
00:31:57,336 --> 00:32:00,656
up the spacing a bit, and I end


698
00:32:00,656 --> 00:32:04,926
up getting something
that looks like this.


699
00:32:05,126 --> 00:32:10,726
And because the last argument to
the filter method is a closure


700
00:32:10,726 --> 00:32:13,496
in itself, we can make it
into a trailing closure


701
00:32:13,496 --> 00:32:14,806
and just get rid
of the parentheses,


702
00:32:15,666 --> 00:32:17,866
so we get that looking
more like this.


703
00:32:18,436 --> 00:32:19,676
Now the only trouble is


704
00:32:19,676 --> 00:32:22,006
that there's no symbol
declared called atomic element


705
00:32:22,546 --> 00:32:23,506
because I removed it.


706
00:32:24,246 --> 00:32:28,296
But I'm passing in one item into
this filter closure every time,


707
00:32:28,296 --> 00:32:32,056
and I can reference
that argument like that.


708
00:32:33,176 --> 00:32:34,176
That's exactly the same code.


709
00:32:34,176 --> 00:32:36,916
If you were missing Perl,
well, now we have this.


710
00:32:37,516 --> 00:32:43,946
[ Applause ]


711
00:32:44,446 --> 00:32:45,626
So now we can do a check.


712
00:32:45,626 --> 00:32:48,126
Let's just put in a
letter N, and great.


713
00:32:48,846 --> 00:32:50,726
Now I have the elements, but
they are not actually sorting


714
00:32:50,726 --> 00:32:51,456
in the right direction.


715
00:32:51,736 --> 00:32:53,096
Actually, they are
not sorting at all.


716
00:32:53,096 --> 00:32:55,326
So, let's just quickly
go ahead and add a sort.


717
00:32:55,326 --> 00:32:56,766
I am just going to
chain it to the end


718
00:32:56,766 --> 00:32:57,756
of this existing closure.


719
00:32:58,376 --> 00:33:01,716
Dot sort. Now, in this case,


720
00:33:01,716 --> 00:33:04,786
I could double-click this blue
token, have it expand out,


721
00:33:04,786 --> 00:33:08,076
and there's many ways we can
compare strings, like case


722
00:33:08,076 --> 00:33:10,316
and sensitive compare, localized
compare, so forth and so on.


723
00:33:10,856 --> 00:33:14,796
But because I know that in
a sort I am given one atomic


724
00:33:14,796 --> 00:33:16,956
element, and then I'm given
the other atomic element,


725
00:33:16,956 --> 00:33:20,156
and I only have to specify which
one comes before the other,


726
00:33:20,386 --> 00:33:23,006
or if the first one comes before
the other, I can just write


727
00:33:23,006 --> 00:33:26,056
out a closure myself, first of
all recognizing that I am going


728
00:33:26,056 --> 00:33:27,806
to have two atomic
elements passed in.


729
00:33:28,696 --> 00:33:31,816
So I have the first one, I
am going to check its name,


730
00:33:31,816 --> 00:33:32,836
and I have the second one.


731
00:33:32,836 --> 00:33:33,816
I am going to check its name.


732
00:33:34,426 --> 00:33:38,116
That in itself is
not a comparison.


733
00:33:38,966 --> 00:33:41,626
However, in Swift,
we've overloaded many


734
00:33:41,626 --> 00:33:43,826
of the standard operators, like
greater than and less than,


735
00:33:43,826 --> 00:33:45,906
so they actually work on types
that you might not expect them


736
00:33:45,906 --> 00:33:47,276
to work on, like strings.


737
00:33:47,826 --> 00:33:51,016
That's a string comparison.


738
00:33:51,656 --> 00:33:57,256
I'll run it again.


739
00:33:57,476 --> 00:34:01,296
Search on letter N, and now
it's being properly sorted.


740
00:34:01,296 --> 00:34:03,476
It's filtered and sorted
all in just one line.


741
00:34:03,476 --> 00:34:04,646
I can check again.


742
00:34:04,646 --> 00:34:05,986
Let's search on S.


743
00:34:06,656 --> 00:34:07,986
We have some really
important elements,


744
00:34:08,696 --> 00:34:09,426
like Swiftonium [laughter].


745
00:34:11,045 --> 00:34:11,926
Very important.


746
00:34:13,585 --> 00:34:17,616
Okay. Let's come back.


747
00:34:17,616 --> 00:34:20,126
So in this section, we
implemented filtering


748
00:34:20,746 --> 00:34:23,096
of our table view by using
Swift's filter method.


749
00:34:23,806 --> 00:34:27,166
And then we sorted
it using sort and got


750
00:34:27,166 --> 00:34:28,676
to see an overloaded operator,


751
00:34:28,676 --> 00:34:29,936
that being the less
than/greater than.


752
00:34:30,536 --> 00:34:33,116
The next feature and final
feature that I want to add


753
00:34:33,116 --> 00:34:36,466
to this app is simply one that
lets me select multiple rows


754
00:34:36,466 --> 00:34:39,076
and then it adds them up to give
me the sum of the atomic weights


755
00:34:39,076 --> 00:34:40,045
for the selected elements.


756
00:34:40,275 --> 00:34:41,286
It looks kinds of like this.


757
00:34:41,656 --> 00:34:44,036
We start off with
the table view.


758
00:34:44,735 --> 00:34:47,226
The nav bar at the top is
saying select two or more items.


759
00:34:48,166 --> 00:34:50,416
You select two or more
items, and then the nav bar


760
00:34:50,416 --> 00:34:52,366
at the top specifies the
sum of their weights.


761
00:34:52,936 --> 00:34:56,826
To do this, I start off
with my content array.


762
00:34:56,826 --> 00:34:58,556
That's all the atomic
elements that I have,


763
00:34:58,596 --> 00:35:00,456
those are all the ones that are
displayed in the table view.


764
00:35:00,876 --> 00:35:05,256
But what I want is just the
selected atomic elements.


765
00:35:06,286 --> 00:35:08,936
So to get that, I can't
go to the table view


766
00:35:08,936 --> 00:35:12,506
and ask the table view for
the array of selected items.


767
00:35:12,676 --> 00:35:16,486
I can only ask it for the
index paths for selected items.


768
00:35:16,726 --> 00:35:21,126
So the table view will give
me an array of the index paths


769
00:35:21,126 --> 00:35:22,116
for the selected items.


770
00:35:22,336 --> 00:35:24,166
I can query those index
paths to get the row.


771
00:35:24,166 --> 00:35:27,236
I can correlate that with the
backing array, the content.


772
00:35:27,606 --> 00:35:30,536
And from that, produce
the selected elements.


773
00:35:31,216 --> 00:35:32,346
Basically, it's this.


774
00:35:32,926 --> 00:35:33,986
We make a new array.


775
00:35:34,276 --> 00:35:35,926
We loop through the index paths.


776
00:35:36,116 --> 00:35:38,156
And then we go back
to content and we pull


777
00:35:38,156 --> 00:35:40,766
out the corresponding
atomic element


778
00:35:40,766 --> 00:35:42,946
for the current index
paths' row.


779
00:35:43,386 --> 00:35:45,676
If you've been accustomed
to writing code like this,


780
00:35:45,676 --> 00:35:48,306
you can do the same
thing in Swift with this.


781
00:35:49,256 --> 00:35:50,026
It's the map function.


782
00:35:50,986 --> 00:35:53,206
The important part is still
there, it's the part in orange.


783
00:35:53,506 --> 00:35:55,086
Just all the the extra
infrastructure that's


784
00:35:55,086 --> 00:35:56,346
around it has been removed.


785
00:35:56,716 --> 00:36:02,326
Next, once I have an array
of all the selected items,


786
00:36:02,726 --> 00:36:05,616
I want to add up
their atomic weights.


787
00:36:06,086 --> 00:36:09,716
So to do that, I might
traditionally use a foreign loop


788
00:36:09,906 --> 00:36:12,116
where I first declare a
variable that's set to zero,


789
00:36:12,116 --> 00:36:15,206
then I just iterate through the
selected objects and just add


790
00:36:15,206 --> 00:36:18,196
to that, in this
case, D, their weight.


791
00:36:18,726 --> 00:36:20,256
If you are accustomed to
doing this kind of thing


792
00:36:20,256 --> 00:36:22,496
with a for-in loop, you can
do the same thing in Swift,


793
00:36:23,136 --> 00:36:26,156
with a reduce, where we set
the initial value as zero,


794
00:36:26,156 --> 00:36:27,496
and then we just
patch in a closure


795
00:36:27,496 --> 00:36:30,376
that takes the initial value,
that's zero, and then appends


796
00:36:30,376 --> 00:36:32,946
to it the next item being
passed in, adds them all up.


797
00:36:33,856 --> 00:36:36,516
Let me just show you the code,
though I will give you a preview


798
00:36:36,956 --> 00:36:37,896
that we can do the whole thing


799
00:36:37,896 --> 00:36:39,636
with just a single
line of code like this.


800
00:36:40,826 --> 00:36:42,496
One of the graphic
designers was asking me


801
00:36:42,496 --> 00:36:43,376
when he saw the presentation,


802
00:36:43,376 --> 00:36:44,476
can you make that
fit on one line?


803
00:36:45,466 --> 00:36:46,576
It's like, not really, no,


804
00:36:46,656 --> 00:36:47,906
I don't think you
could see it then.


805
00:36:48,476 --> 00:36:52,786
Let's switch over to
the demo computer.


806
00:36:57,216 --> 00:37:04,956
Alright. So here's the
function that does all the work.


807
00:37:04,956 --> 00:37:07,776
I start off by ensuring
that I have more


808
00:37:07,776 --> 00:37:08,766
than two items selected.


809
00:37:09,126 --> 00:37:11,836
So you can see I am using a
where clause on an if to say


810
00:37:11,836 --> 00:37:13,946
that as long as the selected
items count as greater or equal


811
00:37:13,946 --> 00:37:15,796
to two, continue
executing this code.


812
00:37:17,116 --> 00:37:19,166
Then I use map so I can
actually get the objects


813
00:37:19,166 --> 00:37:21,756
that are selected by the table
view, not the index paths.


814
00:37:22,656 --> 00:37:24,976
And then use reduce
to add it all up.


815
00:37:24,976 --> 00:37:27,616
And then in the end just passed
it through a number formatter


816
00:37:27,616 --> 00:37:28,556
and stick it up in the title.


817
00:37:29,106 --> 00:37:30,816
If you wanted to see the
same thing on a single line,


818
00:37:30,816 --> 00:37:34,046
it would look like that.


819
00:37:34,266 --> 00:37:40,256
When I run the program,
it adds them all


820
00:37:40,256 --> 00:37:40,996
up and puts them up top.


821
00:37:42,086 --> 00:37:45,426
That's showing map and reduce
to make it easier to work


822
00:37:45,426 --> 00:37:56,136
with items that back
a table view.


823
00:37:56,376 --> 00:38:01,196
Alright. In summary, I'm hoping
you will see that there's a lot


824
00:38:01,196 --> 00:38:03,376
of advantages to
incorporating Swift,


825
00:38:03,376 --> 00:38:05,496
even with your existing
Objective-C projects.


826
00:38:05,976 --> 00:38:08,866
It's not hard to do, and
there's a lot of benefits to it.


827
00:38:08,866 --> 00:38:10,946
You don't have to throw
away any existing code,


828
00:38:11,046 --> 00:38:13,986
and you get to use these
modern and powerful techniques,


829
00:38:14,096 --> 00:38:17,226
like reducing and maps and these
powerful structs, so forth.


830
00:38:18,466 --> 00:38:20,206
For more information,
come see us in the labs,


831
00:38:20,296 --> 00:38:22,626
check out our documentation,
check out the Developer Forums,


832
00:38:22,936 --> 00:38:24,166
or send Stefan an email.


833
00:38:24,226 --> 00:38:25,136
He loves to get mail.


834
00:38:25,136 --> 00:38:26,526
You can just tell him the
conference is going well,


835
00:38:26,526 --> 00:38:27,086
that would be fine.


836
00:38:27,716 --> 00:38:28,856
And with that, I'd
like to thank you,


837
00:38:28,856 --> 00:38:29,756
and have a great conference.


838
00:38:31,516 --> 00:38:45,430
[ Applause ]

