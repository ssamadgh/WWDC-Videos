1
00:00:07,016 --> 00:00:15,500
[ Music ]


2
00:00:17,516 --> 00:00:20,546
[ Applause ]


3
00:00:21,046 --> 00:00:21,316
>> Good morning.


4
00:00:23,076 --> 00:00:24,566
My name is Josh Graessley, and I


5
00:00:24,566 --> 00:00:25,756
am really excited to be here


6
00:00:25,756 --> 00:00:27,206
this morning to tell you about


7
00:00:27,206 --> 00:00:27,936
Network.framework.


8
00:00:30,236 --> 00:00:32,086
Network.framework is a modern


9
00:00:32,086 --> 00:00:33,406
alternative to sockets.


10
00:00:34,016 --> 00:00:35,756
Today, we're going to talk about


11
00:00:35,756 --> 00:00:37,656
modernization transport APIs.


12
00:00:37,656 --> 00:00:38,506
This will help give you some


13
00:00:38,506 --> 00:00:40,176
context to understand what


14
00:00:40,176 --> 00:00:42,056
Network.framework is and how it


15
00:00:42,056 --> 00:00:43,786
fits into the system and whether


16
00:00:43,786 --> 00:00:44,736
or not it's the right thing for


17
00:00:44,736 --> 00:00:45,956
your application to be using.


18
00:00:47,286 --> 00:00:48,546
We'll introduce you to the API


19
00:00:48,916 --> 00:00:49,966
by walking you through making


20
00:00:49,966 --> 00:00:51,166
your first connections.


21
00:00:52,206 --> 00:00:53,626
We'll talk about how you can use


22
00:00:53,626 --> 00:00:55,876
this API to really optimize your


23
00:00:55,876 --> 00:00:57,826
data transfers and go way beyond


24
00:00:57,826 --> 00:00:59,016
the performance of anything you


25
00:00:59,016 --> 00:01:00,026
can do with sockets.


26
00:01:01,296 --> 00:01:02,496
We'll talk about how this API


27
00:01:02,496 --> 00:01:04,135
can help you handle some complex


28
00:01:04,135 --> 00:01:05,726
mobility challenges, and we'll


29
00:01:05,726 --> 00:01:07,146
wrap up with information on how


30
00:01:07,146 --> 00:01:08,356
you can get involved and start


31
00:01:08,356 --> 00:01:08,846
adopting.


32
00:01:10,116 --> 00:01:11,906
First, I'd like to spend a


33
00:01:11,906 --> 00:01:13,306
little bit of time talking about


34
00:01:13,306 --> 00:01:15,096
modernizing transport APIs.


35
00:01:15,716 --> 00:01:16,916
Now when I say transport API,


36
00:01:16,916 --> 00:01:19,136
I'm talking about any API that


37
00:01:19,266 --> 00:01:20,336
lets you send and receive


38
00:01:20,416 --> 00:01:21,996
arbitrary data between two


39
00:01:21,996 --> 00:01:23,266
endpoints on a network, and


40
00:01:23,796 --> 00:01:24,586
that's a pretty broad


41
00:01:24,586 --> 00:01:25,686
definition, and there are a lot


42
00:01:25,686 --> 00:01:27,366
of APIs that could fall under


43
00:01:27,366 --> 00:01:28,036
this category.


44
00:01:30,096 --> 00:01:32,046
Perhaps the most ubiquitous is


45
00:01:32,046 --> 00:01:32,706
sockets.


46
00:01:32,886 --> 00:01:34,006
Sockets has been within us for


47
00:01:34,046 --> 00:01:36,066
over 30 years, and I don't think


48
00:01:36,066 --> 00:01:37,306
it's an exaggeration to say that


49
00:01:37,306 --> 00:01:38,696
sockets has changed the world,


50
00:01:39,346 --> 00:01:40,606
but the world has kept changing.


51
00:01:41,166 --> 00:01:43,046
And as a consequence, using


52
00:01:43,046 --> 00:01:44,346
sockets to write apps for


53
00:01:44,346 --> 00:01:46,636
today's internet is really hard.


54
00:01:47,396 --> 00:01:49,446
There are three primary areas in


55
00:01:49,446 --> 00:01:50,816
which it's very difficult to use


56
00:01:50,816 --> 00:01:51,526
sockets well.


57
00:01:52,896 --> 00:01:54,496
The first one is Connection


58
00:01:54,496 --> 00:01:55,156
Establishment.


59
00:01:55,586 --> 00:01:57,296
There's a whole host of reasons


60
00:01:57,626 --> 00:01:58,916
that establishing connections


61
00:01:59,216 --> 00:02:00,266
can be really difficult with


62
00:02:00,266 --> 00:02:00,806
sockets.


63
00:02:01,356 --> 00:02:03,186
For starters, sockets connect to


64
00:02:03,186 --> 00:02:05,556
addresses, so you have to, most


65
00:02:05,556 --> 00:02:06,436
of the time you have a host


66
00:02:06,436 --> 00:02:07,606
name, so you're going to have to


67
00:02:07,606 --> 00:02:08,866
resolve that host name to an


68
00:02:08,866 --> 00:02:10,455
address.


69
00:02:10,616 --> 00:02:11,926
When you do that, you often end


70
00:02:11,926 --> 00:02:13,286
up with way more than one


71
00:02:13,286 --> 00:02:13,826
address.


72
00:02:13,826 --> 00:02:15,536
You'll have some IPv4 addresses,


73
00:02:15,816 --> 00:02:18,396
some IPv6 addresses, and now


74
00:02:18,396 --> 00:02:19,476
you've got this challenge, which


75
00:02:19,516 --> 00:02:20,376
address should you try and


76
00:02:20,376 --> 00:02:21,746
connect to, in what order?


77
00:02:22,076 --> 00:02:23,086
How long do you wait before you


78
00:02:23,086 --> 00:02:23,856
try the next one?


79
00:02:24,336 --> 00:02:25,776
You can spend years trying to


80
00:02:25,776 --> 00:02:26,426
perfect this.


81
00:02:26,806 --> 00:02:29,606
I know because we have.


82
00:02:30,266 --> 00:02:31,546
Once you get past the dual stack


83
00:02:31,806 --> 00:02:33,536
host problems, you run into a


84
00:02:33,536 --> 00:02:35,016
whole bunch of other issues.


85
00:02:35,466 --> 00:02:36,746
There are some networks that use


86
00:02:36,746 --> 00:02:38,146
something called Proxy Automatic


87
00:02:38,146 --> 00:02:39,296
Configuration or PAC.


88
00:02:40,116 --> 00:02:41,266
On these networks, there's a


89
00:02:41,266 --> 00:02:42,946
JavaScript that you get, and you


90
00:02:42,946 --> 00:02:44,256
have to pass a URL into the


91
00:02:44,256 --> 00:02:45,846
JavaScript, and the JavaScript


92
00:02:45,846 --> 00:02:47,376
runs and spits out an answer


93
00:02:47,706 --> 00:02:49,646
that says either you can go


94
00:02:49,646 --> 00:02:51,226
direct or you have to use this


95
00:02:51,226 --> 00:02:52,876
SOCKS proxy over here or that


96
00:02:52,876 --> 00:02:54,466
HTTP connect proxy over there.


97
00:02:54,946 --> 00:02:56,196
And now your app has to support


98
00:02:56,196 --> 00:02:58,176
SOCKS proxies and HTTP connect


99
00:02:58,306 --> 00:03:00,016
proxies, and this can be really


100
00:03:00,016 --> 00:03:01,046
difficult to do well.


101
00:03:01,876 --> 00:03:03,066
And the most difficult thing is


102
00:03:03,286 --> 00:03:04,256
that you may not have one of


103
00:03:04,256 --> 00:03:05,386
these networks to test on, so


104
00:03:05,766 --> 00:03:06,936
you may get a bug report from


105
00:03:07,066 --> 00:03:08,926
one of your customers, and they


106
00:03:09,146 --> 00:03:10,296
may complain that it's not


107
00:03:10,296 --> 00:03:11,066
working well on their


108
00:03:11,066 --> 00:03:11,656
environment.


109
00:03:12,096 --> 00:03:13,236
And you may want to add code to


110
00:03:13,236 --> 00:03:16,016
fix the problem, but that once


111
00:03:16,016 --> 00:03:17,036
you've got it in there, you


112
00:03:17,036 --> 00:03:17,896
really don't have a good way to


113
00:03:17,896 --> 00:03:18,336
test it.


114
00:03:18,336 --> 00:03:19,266
You have to end up building the


115
00:03:19,266 --> 00:03:20,706
whole environment to reproduce


116
00:03:20,706 --> 00:03:21,856
the same environment they have.


117
00:03:22,616 --> 00:03:23,726
It can be a real challenge.


118
00:03:24,716 --> 00:03:26,436
So connecting with sockets is


119
00:03:26,436 --> 00:03:26,926
really hard.


120
00:03:28,336 --> 00:03:30,056
The second thing that becomes


121
00:03:30,056 --> 00:03:31,486
challenges with sockets is data


122
00:03:31,486 --> 00:03:32,206
transfers.


123
00:03:33,056 --> 00:03:34,256
There's a lot of reasons that


124
00:03:34,256 --> 00:03:35,486
transferring data with sockets


125
00:03:35,486 --> 00:03:36,416
can be really difficult.


126
00:03:36,936 --> 00:03:39,896
The primary problem is the read


127
00:03:39,896 --> 00:03:42,736
and write model itself.


128
00:03:42,736 --> 00:03:43,626
If you're using blocking


129
00:03:43,626 --> 00:03:45,846
sockets, it pretty simple, but


130
00:03:45,846 --> 00:03:47,306
you're tying up a thread, and


131
00:03:47,306 --> 00:03:48,896
it's really not a great idea to


132
00:03:48,896 --> 00:03:49,976
be tying up a thread while


133
00:03:49,976 --> 00:03:50,946
you're waiting to read or write


134
00:03:50,976 --> 00:03:51,196
data.


135
00:03:52,206 --> 00:03:53,476
You can switch to nonblocking,


136
00:03:53,816 --> 00:03:54,706
but then you end up with a whole


137
00:03:54,706 --> 00:03:55,876
lot of other challenges that you


138
00:03:55,876 --> 00:03:56,366
run into.


139
00:03:57,456 --> 00:03:58,596
When you're using nonblocking,


140
00:03:58,736 --> 00:03:59,916
you may tell the kernel I'd like


141
00:03:59,916 --> 00:04:01,346
100 bytes, and the kernel will


142
00:04:01,346 --> 00:04:02,966
come back and say, I've got 10


143
00:04:02,966 --> 00:04:03,966
bytes for you, why don't you


144
00:04:03,966 --> 00:04:04,596
come back later.


145
00:04:04,996 --> 00:04:05,606
And now you have to build a


146
00:04:05,606 --> 00:04:06,696
state machine to keep track of


147
00:04:06,696 --> 00:04:07,916
how many bytes you read versus


148
00:04:07,916 --> 00:04:08,916
how many bytes you want to read.


149
00:04:09,306 --> 00:04:10,996
This can be a lot of work, and


150
00:04:10,996 --> 00:04:12,126
getting it to perform well can


151
00:04:12,126 --> 00:04:12,986
be a real challenge.


152
00:04:13,556 --> 00:04:15,986
On top of all of that, you


153
00:04:16,026 --> 00:04:16,906
really shouldn't be reading and


154
00:04:16,906 --> 00:04:18,016
writing to sockets directly


155
00:04:18,125 --> 00:04:18,896
because you should be using


156
00:04:18,896 --> 00:04:19,995
something like transport layer


157
00:04:19,995 --> 00:04:21,236
security or TLS.


158
00:04:24,226 --> 00:04:25,796
Sockets don't support TLS, so


159
00:04:26,006 --> 00:04:27,266
you're probably using some other


160
00:04:27,266 --> 00:04:30,836
library that is handling TLS for


161
00:04:30,836 --> 00:04:31,886
you and reading and writing to


162
00:04:31,886 --> 00:04:33,256
the sockets on your behalf, or


163
00:04:33,256 --> 00:04:34,186
you're writing the glue code


164
00:04:34,186 --> 00:04:35,386
between that library and


165
00:04:35,386 --> 00:04:36,746
sockets, and you have to figure


166
00:04:36,746 --> 00:04:37,756
out how to get all this to work


167
00:04:37,756 --> 00:04:38,766
with all the crazy connection


168
00:04:38,766 --> 00:04:39,796
logic that you put in ahead of


169
00:04:39,796 --> 00:04:40,056
time.


170
00:04:40,386 --> 00:04:42,496
There's a lot here that can be


171
00:04:42,496 --> 00:04:43,146
really difficult.


172
00:04:45,096 --> 00:04:47,106
Finally, mobility can be really


173
00:04:47,106 --> 00:04:48,656
challenges with sockets for a


174
00:04:48,656 --> 00:04:49,626
variety of reasons.


175
00:04:50,166 --> 00:04:53,286
I think a lot of this boils down


176
00:04:53,286 --> 00:04:54,626
to the fact that when sockets


177
00:04:54,626 --> 00:04:56,966
came out, a lot of the devices


178
00:04:56,966 --> 00:04:57,876
required more than a single


179
00:04:57,876 --> 00:04:58,876
person to move them, and they


180
00:04:58,876 --> 00:04:59,906
were connected with a single


181
00:04:59,906 --> 00:05:01,436
wire, and they had a static IP


182
00:05:01,516 --> 00:05:02,486
address, and everything was


183
00:05:02,486 --> 00:05:03,566
stable and simple.


184
00:05:04,376 --> 00:05:05,506
And today, we have these


185
00:05:05,506 --> 00:05:07,626
incredibly powerful devices in


186
00:05:07,626 --> 00:05:09,666
our pocket with multiple radios


187
00:05:09,986 --> 00:05:11,556
that may be on at the same time,


188
00:05:12,076 --> 00:05:13,476
and some of them are moving from


189
00:05:13,476 --> 00:05:14,876
network to network, and your


190
00:05:14,876 --> 00:05:16,356
application has to handle all


191
00:05:16,356 --> 00:05:17,566
these transitions well to


192
00:05:17,566 --> 00:05:18,846
provide a seamless experience to


193
00:05:18,846 --> 00:05:19,616
your customers.


194
00:05:21,176 --> 00:05:24,316
Sockets does nothing to help you


195
00:05:24,316 --> 00:05:24,826
with this.


196
00:05:25,116 --> 00:05:26,376
You can use routing sockets, but


197
00:05:26,376 --> 00:05:27,916
it's really, really difficult.


198
00:05:28,586 --> 00:05:30,016
We think a transport API should


199
00:05:30,016 --> 00:05:30,426
do better.


200
00:05:32,016 --> 00:05:34,196
Fortunately, on our platform as


201
00:05:34,196 --> 00:05:35,606
an application developer you


202
00:05:35,606 --> 00:05:37,966
have a great API in URLSession.


203
00:05:39,156 --> 00:05:41,406
URLSession handles all of these


204
00:05:41,446 --> 00:05:42,256
problems for you.


205
00:05:43,196 --> 00:05:45,016
It's really focused on HTTP, but


206
00:05:45,016 --> 00:05:46,756
it also has stream task that


207
00:05:46,756 --> 00:05:48,666
gives you raw access to TCP and


208
00:05:48,666 --> 00:05:49,766
TLS connections.


209
00:05:50,776 --> 00:05:52,076
Now you might be looking at


210
00:05:52,076 --> 00:05:53,316
this, and you may not have


211
00:05:53,496 --> 00:05:54,566
cheated by looking at the


212
00:05:54,666 --> 00:05:56,426
description in the WWDC app.


213
00:05:56,996 --> 00:05:58,366
You might think that URLSession


214
00:05:58,886 --> 00:06:00,626
is built on the same primitives


215
00:06:00,626 --> 00:06:01,826
that you would use yourself.


216
00:06:03,366 --> 00:06:04,476
But it turns out that's not the


217
00:06:04,476 --> 00:06:06,046
case.


218
00:06:06,046 --> 00:06:07,786
URLSession is built on top of


219
00:06:07,786 --> 00:06:08,396
something we call


220
00:06:08,396 --> 00:06:09,126
Network.framework.


221
00:06:10,116 --> 00:06:11,806
URLSession really focuses on all


222
00:06:11,806 --> 00:06:14,186
of the HTTP bits, and it


223
00:06:14,186 --> 00:06:15,766
offloads a lot of the transport


224
00:06:15,766 --> 00:06:16,646
functionality to


225
00:06:16,646 --> 00:06:17,356
Network.framework.


226
00:06:21,056 --> 00:06:22,156
Network.framework is something


227
00:06:22,156 --> 00:06:23,076
we've been working on for a


228
00:06:23,076 --> 00:06:24,496
number of years, and in


229
00:06:24,496 --> 00:06:25,886
supporting URLSession, we've


230
00:06:25,886 --> 00:06:27,716
learned a lot, and we've taken a


231
00:06:27,716 --> 00:06:28,826
lot of those lessons to the


232
00:06:28,826 --> 00:06:29,166
IETF.


233
00:06:29,166 --> 00:06:30,706
A number of our engineers


234
00:06:30,706 --> 00:06:32,536
regularly participate in the


235
00:06:32,536 --> 00:06:33,966
IETF and meet with engineers


236
00:06:33,966 --> 00:06:35,366
from other companies, and


237
00:06:35,366 --> 00:06:36,376
they've been discussing a lot of


238
00:06:36,376 --> 00:06:37,146
what we've learned in the


239
00:06:37,146 --> 00:06:38,366
transport services working


240
00:06:38,366 --> 00:06:38,576
group.


241
00:06:39,116 --> 00:06:40,196
And in those discussions, we've


242
00:06:40,196 --> 00:06:41,636
got some great feedback, and


243
00:06:41,636 --> 00:06:42,766
we've brought that back in and


244
00:06:42,766 --> 00:06:44,086
improved Network.framework based


245
00:06:44,086 --> 00:06:44,396
on that.


246
00:06:45,556 --> 00:06:46,636
We are really excited to


247
00:06:46,636 --> 00:06:48,376
announce this year that your


248
00:06:48,376 --> 00:06:50,266
applications can take advantage


249
00:06:50,336 --> 00:06:51,826
of this same library directly


250
00:06:51,826 --> 00:06:51,976
now.


251
00:06:52,516 --> 00:06:58,176
[ Applause ]


252
00:06:58,676 --> 00:06:59,446
Now we know that one of the


253
00:06:59,446 --> 00:07:01,256
things people love about sockets


254
00:07:01,256 --> 00:07:02,446
is that it gives them very


255
00:07:02,446 --> 00:07:03,976
fine-grain control over just


256
00:07:03,976 --> 00:07:05,456
about everything, and they're


257
00:07:05,456 --> 00:07:06,926
really loathe to give that up.


258
00:07:07,166 --> 00:07:08,156
So as we developed


259
00:07:08,156 --> 00:07:09,386
Network.framework, we wanted to


260
00:07:09,386 --> 00:07:10,866
make sure that it did the right


261
00:07:10,926 --> 00:07:12,536
thing by default in the way that


262
00:07:12,536 --> 00:07:14,296
sockets doesn't, but it gave you


263
00:07:14,296 --> 00:07:16,186
all the knobs that sockets does.


264
00:07:16,506 --> 00:07:17,236
And it's kind of got this


265
00:07:17,276 --> 00:07:19,936
gradient, so the more knobs you


266
00:07:19,936 --> 00:07:20,976
turn, the more complex it


267
00:07:21,016 --> 00:07:21,546
becomes.


268
00:07:22,016 --> 00:07:23,266
It gives you all the power you


269
00:07:23,266 --> 00:07:24,836
need, but you don't have to pay


270
00:07:24,866 --> 00:07:26,146
for the complexity unless you


271
00:07:26,146 --> 00:07:29,506
actually need some of it.


272
00:07:30,406 --> 00:07:32,426
Network.framework has incredibly


273
00:07:32,426 --> 00:07:34,016
smart connection establishment.


274
00:07:34,856 --> 00:07:36,936
It handles the dual stack cases.


275
00:07:36,936 --> 00:07:38,916
It handles IPv6 only networks.


276
00:07:38,916 --> 00:07:39,726
It handles PAC.


277
00:07:39,876 --> 00:07:40,976
It handles proxies.


278
00:07:41,676 --> 00:07:43,936
It will help you connect on


279
00:07:43,936 --> 00:07:45,386
networks that are otherwise very


280
00:07:45,386 --> 00:07:46,206
difficult to deal with.


281
00:07:47,116 --> 00:07:48,656
It has an incredibly optimized


282
00:07:48,656 --> 00:07:50,706
data transfer path that lets you


283
00:07:50,706 --> 00:07:52,146
go way beyond the performance of


284
00:07:52,146 --> 00:07:52,906
anything you can do with


285
00:07:52,906 --> 00:07:54,086
sockets, and Tommy will cover


286
00:07:54,086 --> 00:07:54,746
that in a little bit.


287
00:07:55,906 --> 00:07:57,326
It has support for built-in


288
00:07:57,326 --> 00:07:57,856
security.


289
00:07:58,326 --> 00:08:00,796
It supports TLS and DTLS by


290
00:08:00,796 --> 00:08:01,226
default.


291
00:08:01,476 --> 00:08:03,776
It's really simple to use.


292
00:08:04,256 --> 00:08:05,616
It has great support for


293
00:08:05,616 --> 00:08:06,136
mobility.


294
00:08:06,336 --> 00:08:07,926
It provides notifications about


295
00:08:07,926 --> 00:08:08,946
network changes that are


296
00:08:08,976 --> 00:08:10,386
relevant to the connections that


297
00:08:10,386 --> 00:08:11,216
your application is


298
00:08:11,216 --> 00:08:11,876
establishing.


299
00:08:12,476 --> 00:08:17,046
It's available on iOS, macOS,


300
00:08:17,146 --> 00:08:19,366
and tvOS as a CAPI with


301
00:08:19,366 --> 00:08:20,616
automatic reference counting, so


302
00:08:20,616 --> 00:08:21,836
it's easy to use from Objective


303
00:08:21,836 --> 00:08:23,646
C, and it has an incredible


304
00:08:23,646 --> 00:08:24,306
Swift API.


305
00:08:25,066 --> 00:08:28,166
With that, I'd like to turn it


306
00:08:28,166 --> 00:08:29,566
over to Tommy Pauly, to walk you


307
00:08:29,566 --> 00:08:30,406
through making your first


308
00:08:30,406 --> 00:08:30,856
connection.


309
00:08:31,416 --> 00:08:31,756
Thank you.


310
00:08:32,508 --> 00:08:34,508
[ Applause ]


311
00:08:38,496 --> 00:08:39,866
>> All right, hello everyone.


312
00:08:40,126 --> 00:08:41,556
My name is Tommy Pauly, and I'm


313
00:08:41,556 --> 00:08:43,306
on the networking team here at


314
00:08:43,306 --> 00:08:43,586
Apple.


315
00:08:44,686 --> 00:08:46,766
And so I'm sure a lot of you are


316
00:08:46,766 --> 00:08:48,156
really excited to start seeing


317
00:08:48,156 --> 00:08:50,226
how you can start adopting


318
00:08:50,366 --> 00:08:52,086
Network.framework in your apps.


319
00:08:53,366 --> 00:08:55,386
And the best place to start and


320
00:08:55,386 --> 00:08:56,836
just dive right in is by making


321
00:08:56,836 --> 00:08:57,726
your first connection.


322
00:08:57,726 --> 00:08:59,266
And you're going to be making


323
00:08:59,266 --> 00:09:00,266
your connection from your local


324
00:09:00,266 --> 00:09:03,246
device, to your server, or to


325
00:09:03,246 --> 00:09:04,586
some other peer device that's on


326
00:09:04,586 --> 00:09:05,966
your local network.


327
00:09:06,856 --> 00:09:09,296
But you may be wondering, what


328
00:09:09,296 --> 00:09:10,306
kind of connections are


329
00:09:10,306 --> 00:09:11,526
appropriate to use with


330
00:09:11,526 --> 00:09:12,246
Network.framework.


331
00:09:12,716 --> 00:09:13,826
What are the use cases?


332
00:09:14,596 --> 00:09:16,716
And so let's explore first some


333
00:09:16,716 --> 00:09:18,836
scenarios of apps that may be


334
00:09:18,836 --> 00:09:21,096
using sockets today and would


335
00:09:21,096 --> 00:09:22,826
really benefit a lot by taking


336
00:09:22,826 --> 00:09:23,976
advantage of Network.framework


337
00:09:24,126 --> 00:09:24,926
going forward.


338
00:09:25,526 --> 00:09:28,066
So the first one of these I want


339
00:09:28,066 --> 00:09:30,296
to highlight is gaming apps.


340
00:09:31,076 --> 00:09:33,316
Gaming apps often use UDP to


341
00:09:33,886 --> 00:09:35,456
send real-time data about the


342
00:09:35,456 --> 00:09:37,866
game state between one device


343
00:09:37,866 --> 00:09:38,386
and another.


344
00:09:39,246 --> 00:09:40,506
And they really care about


345
00:09:40,506 --> 00:09:42,496
optimizing for latency and


346
00:09:42,496 --> 00:09:43,866
making sure there's no lag or


347
00:09:43,866 --> 00:09:44,906
anything being dropped there.


348
00:09:46,056 --> 00:09:47,626
If you have an app like this,


349
00:09:48,396 --> 00:09:49,276
you're going to love how


350
00:09:49,276 --> 00:09:50,896
Network.framework allows you to


351
00:09:50,996 --> 00:09:52,736
really optimize your UDP,


352
00:09:52,996 --> 00:09:54,756
sending and receiving to be


353
00:09:55,246 --> 00:09:57,336
faster than ever before with the


354
00:09:57,336 --> 00:09:58,546
least latency possible.


355
00:09:58,946 --> 00:10:02,306
Another type of app that would


356
00:10:02,306 --> 00:10:03,586
take a lot of advantage from


357
00:10:03,586 --> 00:10:05,046
Network.framework is


358
00:10:05,046 --> 00:10:06,396
live-streaming apps.


359
00:10:06,746 --> 00:10:08,616
So live streaming often will use


360
00:10:08,906 --> 00:10:11,776
a combination of UDP and TCP in


361
00:10:11,896 --> 00:10:14,286
their apps, but the key point


362
00:10:14,286 --> 00:10:15,986
here is that it's generating


363
00:10:15,986 --> 00:10:17,276
data on the fly.


364
00:10:17,276 --> 00:10:19,606
If you have new video frames or


365
00:10:19,606 --> 00:10:21,426
audio frames, you need to make


366
00:10:21,426 --> 00:10:22,906
sure that those are paced well


367
00:10:22,906 --> 00:10:24,336
and you're not incurring a lot


368
00:10:24,336 --> 00:10:26,866
of buffering on the device or on


369
00:10:26,866 --> 00:10:27,366
the network.


370
00:10:28,486 --> 00:10:30,786
The asynchronous model for


371
00:10:30,786 --> 00:10:32,166
reading and writing in


372
00:10:32,166 --> 00:10:33,326
Network.framework is going to be


373
00:10:33,326 --> 00:10:34,936
perfect for making sure you


374
00:10:34,936 --> 00:10:35,956
reduce that buffering.


375
00:10:36,476 --> 00:10:39,246
And the last case I want to


376
00:10:39,246 --> 00:10:41,396
highlight are mail and messaging


377
00:10:41,396 --> 00:10:41,876
apps.


378
00:10:43,086 --> 00:10:44,336
So these are going to be using a


379
00:10:44,336 --> 00:10:46,006
lot more traditional protocols,


380
00:10:46,036 --> 00:10:48,026
just TLS over TCP.


381
00:10:49,016 --> 00:10:50,376
However, it's really critical


382
00:10:50,376 --> 00:10:51,676
for apps like this to handle


383
00:10:51,676 --> 00:10:52,846
network transitions really


384
00:10:52,846 --> 00:10:53,416
gracefully.


385
00:10:55,446 --> 00:10:56,436
Oftentimes if you have a


386
00:10:56,436 --> 00:10:57,906
messaging app, your user is


387
00:10:57,906 --> 00:10:59,306
going to be using your app as


388
00:10:59,306 --> 00:11:00,066
they're walking out of the


389
00:11:00,066 --> 00:11:01,416
building, texting their friend


390
00:11:01,696 --> 00:11:02,626
to let them know that they're on


391
00:11:02,626 --> 00:11:03,006
their way.


392
00:11:03,706 --> 00:11:04,766
And you want to make sure that


393
00:11:04,766 --> 00:11:06,216
you're handling that transition


394
00:11:06,446 --> 00:11:07,466
from the WiFi network in the


395
00:11:07,466 --> 00:11:08,626
building to the cell network


396
00:11:08,656 --> 00:11:10,466
that they're going onto and that


397
00:11:10,466 --> 00:11:11,986
you don't hand a long time for


398
00:11:11,986 --> 00:11:13,306
that message to actually get to


399
00:11:13,306 --> 00:11:13,766
their friend.


400
00:11:14,246 --> 00:11:16,606
And these are just three


401
00:11:16,606 --> 00:11:18,286
examples of the types of apps


402
00:11:18,286 --> 00:11:19,766
that may use low-level


403
00:11:19,766 --> 00:11:20,826
networking like this.


404
00:11:21,576 --> 00:11:22,816
There are many other types of


405
00:11:22,816 --> 00:11:24,356
apps that could take advantage


406
00:11:24,356 --> 00:11:25,596
of this, so if you have an app


407
00:11:25,596 --> 00:11:27,506
like one of these or some other


408
00:11:27,506 --> 00:11:28,756
use case that currently uses


409
00:11:28,756 --> 00:11:30,696
sockets, I invite you to follow


410
00:11:30,696 --> 00:11:33,046
along and see how your app can


411
00:11:33,046 --> 00:11:33,476
benefit.


412
00:11:33,476 --> 00:11:36,096
So to get started, I want to


413
00:11:36,096 --> 00:11:37,766
focus on that last case, the


414
00:11:37,766 --> 00:11:39,316
simplest case of mail and


415
00:11:39,316 --> 00:11:41,056
messaging apps and looking at


416
00:11:41,056 --> 00:11:42,586
how they establish connections.


417
00:11:43,286 --> 00:11:46,076
So when you want to establish


418
00:11:46,076 --> 00:11:47,126
your connection to a server,


419
00:11:47,306 --> 00:11:49,226
let's say it's for a mail


420
00:11:49,226 --> 00:11:51,716
connection, iMap with security,


421
00:11:51,826 --> 00:11:54,006
with TLS, you start with your


422
00:11:54,006 --> 00:11:56,426
hostname, mail.example.com.


423
00:11:57,326 --> 00:11:58,336
You have a port you want to


424
00:11:58,336 --> 00:12:00,956
connect to, port 993, and you


425
00:12:00,956 --> 00:12:04,306
want to be using TLS as well as


426
00:12:04,856 --> 00:12:04,946
TCP.


427
00:12:05,156 --> 00:12:06,336
So how would this look in


428
00:12:06,336 --> 00:12:07,426
sockets traditionally?


429
00:12:08,466 --> 00:12:09,576
Something like this to get


430
00:12:09,576 --> 00:12:09,926
started.


431
00:12:10,526 --> 00:12:11,516
You would take your host name.


432
00:12:12,126 --> 00:12:13,866
You would call some DNS API to


433
00:12:13,866 --> 00:12:14,796
resolve that host name.


434
00:12:15,156 --> 00:12:16,576
Let's say this is getaddrinfo.


435
00:12:17,346 --> 00:12:18,256
You'll get back one or more


436
00:12:18,256 --> 00:12:18,876
addresses.


437
00:12:19,206 --> 00:12:20,386
You'll have to decide which one


438
00:12:20,386 --> 00:12:21,526
you want to connect to first.


439
00:12:22,576 --> 00:12:24,116
You'll call socket with the


440
00:12:24,116 --> 00:12:25,316
appropriate address family.


441
00:12:26,446 --> 00:12:28,066
You will set a series of socket


442
00:12:28,066 --> 00:12:28,726
options.


443
00:12:29,116 --> 00:12:30,176
Let's say you want to make your


444
00:12:30,176 --> 00:12:32,126
socket nonblocking like Josh


445
00:12:32,126 --> 00:12:32,876
mentioned before.


446
00:12:34,356 --> 00:12:36,296
Then you call connect to start


447
00:12:36,296 --> 00:12:38,216
TCP, and then you wait for a


448
00:12:38,216 --> 00:12:38,856
writable event.


449
00:12:40,056 --> 00:12:41,426
And this is before you do


450
00:12:41,426 --> 00:12:42,876
anything with TLS, and that's a


451
00:12:42,876 --> 00:12:44,426
whole host of other problems.


452
00:12:44,966 --> 00:12:47,726
So how does this look in


453
00:12:47,726 --> 00:12:48,366
Network.framework?


454
00:12:48,756 --> 00:12:50,066
And we hope that it looks very


455
00:12:50,066 --> 00:12:52,536
familiar to you but a little bit


456
00:12:52,536 --> 00:12:52,956
simpler.


457
00:12:53,716 --> 00:12:54,856
So the first thing you do is you


458
00:12:54,856 --> 00:12:55,986
create a connect a connection


459
00:12:55,986 --> 00:12:56,206
object.


460
00:12:56,536 --> 00:12:57,936
And a connection object is based


461
00:12:57,936 --> 00:12:58,606
on two things.


462
00:12:59,116 --> 00:13:00,286
You have an endpoint, which


463
00:13:00,286 --> 00:13:01,676
defines the destination you want


464
00:13:01,676 --> 00:13:03,636
to get to, and this could be the


465
00:13:03,636 --> 00:13:05,186
address, the IP address that you


466
00:13:05,186 --> 00:13:07,566
had before, but usually, like in


467
00:13:07,566 --> 00:13:09,126
this example, we have a host


468
00:13:09,126 --> 00:13:10,846
name and a port, and so our end


469
00:13:10,876 --> 00:13:12,486
point can just be that host name


470
00:13:12,486 --> 00:13:12,916
and port.


471
00:13:13,506 --> 00:13:14,756
It could also be a bonjour


472
00:13:14,756 --> 00:13:15,856
service that I want to connect


473
00:13:15,856 --> 00:13:16,016
to.


474
00:13:17,486 --> 00:13:19,276
And then I also have parameters.


475
00:13:19,576 --> 00:13:21,286
Parameters define what protocols


476
00:13:21,286 --> 00:13:24,206
I want to use, TLS, DTLS, UDP,


477
00:13:24,206 --> 00:13:24,536
TCP.


478
00:13:24,536 --> 00:13:27,176
It defines the protocol options


479
00:13:27,176 --> 00:13:29,456
that I want as well as which


480
00:13:29,496 --> 00:13:31,016
paths I want to use to connect


481
00:13:31,016 --> 00:13:31,336
over.


482
00:13:31,726 --> 00:13:32,586
Do I want to just connect over


483
00:13:32,586 --> 00:13:34,606
anything, or do I only want to


484
00:13:35,276 --> 00:13:36,136
use WiFi?


485
00:13:36,316 --> 00:13:37,816
Once you've configured your


486
00:13:37,816 --> 00:13:39,616
connection, you simply call


487
00:13:39,616 --> 00:13:41,786
start to get things going, and


488
00:13:41,786 --> 00:13:42,876
then you wait for the connection


489
00:13:42,876 --> 00:13:44,196
to move into the ready state.


490
00:13:44,786 --> 00:13:45,956
And that's all you need to do to


491
00:13:45,956 --> 00:13:47,376
bring up a full TLS connection


492
00:13:47,376 --> 00:13:47,906
to your server.


493
00:13:48,936 --> 00:13:49,746
And I think you're going to love


494
00:13:49,746 --> 00:13:51,746
how this looks in Swift.


495
00:13:52,476 --> 00:13:53,536
So here's what you do.


496
00:13:53,876 --> 00:13:55,636
You first import the network


497
00:13:55,636 --> 00:13:56,126
module.


498
00:13:57,496 --> 00:13:59,956
Then, you create an NWConnection


499
00:13:59,956 --> 00:14:00,406
object.


500
00:14:00,756 --> 00:14:02,966
So an NWConnection in either


501
00:14:02,966 --> 00:14:05,596
Swift or in C is the fundamental


502
00:14:05,596 --> 00:14:06,876
object for reading and writing


503
00:14:06,876 --> 00:14:07,126
data.


504
00:14:08,516 --> 00:14:09,316
In this case, we have a


505
00:14:09,316 --> 00:14:10,886
convenience that initializes


506
00:14:10,886 --> 00:14:12,526
your endpoint with a host in the


507
00:14:12,526 --> 00:14:14,946
port, so I give it my hostname,


508
00:14:14,946 --> 00:14:17,526
male.example.com, and the port.


509
00:14:17,526 --> 00:14:18,606
And in this case, it's a


510
00:14:18,606 --> 00:14:19,726
well-known port.


511
00:14:20,146 --> 00:14:20,906
It's imaps.


512
00:14:21,086 --> 00:14:22,866
So I can just put that in Swift


513
00:14:23,156 --> 00:14:24,866
very easy, but I could also put


514
00:14:24,866 --> 00:14:27,026
any other numeric literal there.


515
00:14:27,496 --> 00:14:29,726
And then to define what


516
00:14:29,766 --> 00:14:31,346
protocols I want to use, I pass


517
00:14:31,386 --> 00:14:33,706
parameters, and since this is a


518
00:14:33,736 --> 00:14:35,176
client connection, I only want


519
00:14:35,306 --> 00:14:36,906
default, TLS, and TCP


520
00:14:36,906 --> 00:14:37,476
parameters.


521
00:14:38,176 --> 00:14:39,176
It can be as simple as just


522
00:14:39,176 --> 00:14:41,466
writing dot TLS, and now I have


523
00:14:41,466 --> 00:14:42,846
a fully-fledged TLS connection.


524
00:14:44,936 --> 00:14:46,336
The next thing I do is I said


525
00:14:46,426 --> 00:14:48,046
estate update handler to handle


526
00:14:48,046 --> 00:14:49,616
all the transitions that my


527
00:14:49,616 --> 00:14:50,586
connection might go through.


528
00:14:51,686 --> 00:14:52,696
The first state and the most


529
00:14:52,696 --> 00:14:53,586
important one that you want to


530
00:14:53,586 --> 00:14:55,236
handle is the ready state.


531
00:14:55,916 --> 00:14:57,736
Ready means that your app is


532
00:14:57,736 --> 00:14:59,346
ready to read and write data on


533
00:14:59,346 --> 00:15:00,616
this connection, it's totally


534
00:15:00,616 --> 00:15:03,026
established, and if you're using


535
00:15:03,386 --> 00:15:05,046
TCP and TLS, this means that the


536
00:15:05,046 --> 00:15:06,926
TLS handshake is finished.


537
00:15:08,096 --> 00:15:09,806
We also though let you know


538
00:15:09,806 --> 00:15:11,216
about the waiting state.


539
00:15:11,856 --> 00:15:14,526
So last year in URLSession, we


540
00:15:14,526 --> 00:15:15,636
introduced waits for


541
00:15:15,636 --> 00:15:17,306
connectivity, and the waiting


542
00:15:17,306 --> 00:15:19,056
state of an NWConnection is


543
00:15:19,056 --> 00:15:20,166
exactly the same thing.


544
00:15:20,446 --> 00:15:21,996
And this is on always by


545
00:15:21,996 --> 00:15:22,496
default.


546
00:15:22,866 --> 00:15:23,636
So when you create your


547
00:15:23,636 --> 00:15:24,746
connection and when you start


548
00:15:24,746 --> 00:15:25,896
it, if there is no network


549
00:15:25,896 --> 00:15:28,336
available, we won't fail, we'll


550
00:15:28,336 --> 00:15:29,816
just tell you we're waiting for


551
00:15:29,816 --> 00:15:30,726
a network to be available.


552
00:15:30,726 --> 00:15:32,396
We'll give you a helpful reason


553
00:15:32,396 --> 00:15:34,246
code, but you don't have to do


554
00:15:34,246 --> 00:15:35,736
anything more to watch network


555
00:15:35,736 --> 00:15:36,766
transitions yourself.


556
00:15:37,516 --> 00:15:38,846
Mobility is an essential,


557
00:15:38,886 --> 00:15:40,216
critical part of this API.


558
00:15:40,906 --> 00:15:43,286
And we'll also let you know if


559
00:15:43,286 --> 00:15:44,196
there's a fatal error.


560
00:15:44,196 --> 00:15:46,076
Let's say we had to reset from


561
00:15:46,076 --> 00:15:47,496
the server or TLS failed, and


562
00:15:47,496 --> 00:15:48,846
we'll give you that as a failed


563
00:15:49,386 --> 00:15:49,546
event.


564
00:15:50,276 --> 00:15:52,426
So once you've set this up, you


565
00:15:52,426 --> 00:15:54,386
simply call start and provide


566
00:15:54,386 --> 00:15:56,636
the dispatch queue upon which


567
00:15:56,816 --> 00:15:58,276
you want to receive callbacks.


568
00:15:58,336 --> 00:16:01,616
So I want to dig into what


569
00:16:01,616 --> 00:16:03,166
happens when you call start.


570
00:16:03,166 --> 00:16:04,216
What's actually going on?


571
00:16:04,976 --> 00:16:06,326
So here's a little state


572
00:16:06,326 --> 00:16:08,356
machine, the innards of the


573
00:16:08,356 --> 00:16:09,016
NWConnection.


574
00:16:09,016 --> 00:16:10,976
When we begin at the setup state


575
00:16:10,976 --> 00:16:13,686
and we call start, we move into


576
00:16:13,686 --> 00:16:15,146
the preparing state.


577
00:16:16,416 --> 00:16:19,116
So the preparing state does a


578
00:16:19,116 --> 00:16:20,566
lot more than just calling


579
00:16:20,776 --> 00:16:22,626
connect on a TCP socket.


580
00:16:23,696 --> 00:16:25,516
For TCP socket, that would just


581
00:16:25,516 --> 00:16:27,896
send out a SYN packet across to


582
00:16:27,896 --> 00:16:29,066
the server that you're trying to


583
00:16:29,066 --> 00:16:29,456
reach.


584
00:16:30,876 --> 00:16:32,356
But when you call start on an


585
00:16:32,356 --> 00:16:33,456
NWConnection, it actually


586
00:16:33,456 --> 00:16:34,766
handles all of the things that


587
00:16:34,766 --> 00:16:36,226
Josh was mentioning earlier.


588
00:16:37,206 --> 00:16:38,786
It evaluates the network you're


589
00:16:38,786 --> 00:16:41,106
on and tries to make the fastest


590
00:16:41,106 --> 00:16:42,296
connection possible for you.


591
00:16:42,296 --> 00:16:44,086
I want to dig into that a little


592
00:16:44,086 --> 00:16:44,446
bit more.


593
00:16:45,086 --> 00:16:46,896
So this is what we call Smart


594
00:16:47,146 --> 00:16:48,296
Connection Establishment.


595
00:16:48,826 --> 00:16:51,286
So the very first thing that we


596
00:16:51,286 --> 00:16:54,086
do when you call start is that


597
00:16:54,086 --> 00:16:56,056
we take your endpoint, and then


598
00:16:56,056 --> 00:16:57,396
we evaluate what are all the


599
00:16:57,396 --> 00:16:58,306
networks that are currently


600
00:16:58,306 --> 00:16:58,966
available to me.


601
00:16:59,876 --> 00:17:01,866
In this case, we have WiFi and


602
00:17:01,866 --> 00:17:02,336
cellular.


603
00:17:03,146 --> 00:17:04,866
And generally we prefer the WiFi


604
00:17:04,866 --> 00:17:06,685
network because it has less cost


605
00:17:06,685 --> 00:17:07,296
to the user.


606
00:17:08,165 --> 00:17:09,406
So we'll look at that one first.


607
00:17:10,776 --> 00:17:12,685
Then we check, are there any


608
00:17:12,746 --> 00:17:14,136
special configurations on this


609
00:17:14,136 --> 00:17:14,465
network.


610
00:17:14,816 --> 00:17:15,425
Is there a VPN?


611
00:17:15,425 --> 00:17:16,616
Is there a proxy?


612
00:17:16,616 --> 00:17:18,195
And we'll evaluate that for you.


613
00:17:19,435 --> 00:17:21,185
In this case, let's say that


614
00:17:21,185 --> 00:17:23,175
there is a proxy configured with


615
00:17:23,465 --> 00:17:25,185
an automatic configuration file


616
00:17:25,616 --> 00:17:28,296
that also lets you go direct if


617
00:17:28,296 --> 00:17:29,656
the proxy doesn't apply to your


618
00:17:29,656 --> 00:17:30,146
connection.


619
00:17:30,626 --> 00:17:32,096
So we'll evaluate both of those


620
00:17:32,096 --> 00:17:32,536
options.


621
00:17:33,676 --> 00:17:34,606
We'll check if we need to use


622
00:17:34,606 --> 00:17:36,566
the proxy, go ahead and connect


623
00:17:36,566 --> 00:17:38,516
to it, create a TCP connection


624
00:17:38,516 --> 00:17:38,716
there.


625
00:17:39,976 --> 00:17:41,456
But if we don't need it, we'll


626
00:17:41,456 --> 00:17:44,256
do DNS on your behalf going


627
00:17:44,256 --> 00:17:46,446
directly, get back all of the


628
00:17:46,446 --> 00:17:48,946
DNS IP address answers, and


629
00:17:48,946 --> 00:17:51,676
connect to them one after the


630
00:17:51,676 --> 00:17:52,976
other, leaving them going in


631
00:17:52,976 --> 00:17:53,436
parallel.


632
00:17:53,436 --> 00:17:54,966
We're racing them to get you the


633
00:17:54,966 --> 00:17:56,366
fastest connection possible.


634
00:17:59,136 --> 00:18:00,616
And then, if something goes


635
00:18:00,616 --> 00:18:01,926
wrong with WiFi, let's say the


636
00:18:01,926 --> 00:18:03,806
WiFi radio quality goes really


637
00:18:03,806 --> 00:18:05,006
bad because you're walking away


638
00:18:05,006 --> 00:18:07,546
from the building, we can


639
00:18:07,546 --> 00:18:09,136
actually take advantage of the


640
00:18:09,136 --> 00:18:11,156
feature called WiFi assist and


641
00:18:11,156 --> 00:18:13,156
fall back seamlessly to the


642
00:18:13,156 --> 00:18:15,366
cellular network, do DNS


643
00:18:15,366 --> 00:18:17,836
resolution there, and try the


644
00:18:17,836 --> 00:18:18,906
connections one after the other.


645
00:18:19,146 --> 00:18:22,146
So this way your connection


646
00:18:22,146 --> 00:18:24,396
establishment is very resilient,


647
00:18:24,636 --> 00:18:26,926
handles VPNs, handles proxies


648
00:18:26,926 --> 00:18:29,066
for you, and gets you the best


649
00:18:29,066 --> 00:18:29,816
connection possible.


650
00:18:29,816 --> 00:18:34,026
Now, of course, you may not want


651
00:18:34,116 --> 00:18:35,606
to try all of these options.


652
00:18:35,606 --> 00:18:37,216
You may want to restrict what


653
00:18:37,216 --> 00:18:38,176
the connection establishment


654
00:18:38,176 --> 00:18:40,646
does, and so we have many


655
00:18:40,746 --> 00:18:42,256
different knobs and controls to


656
00:18:42,256 --> 00:18:43,346
let you do that, and I want to


657
00:18:43,346 --> 00:18:44,756
highlight just three of them


658
00:18:45,296 --> 00:18:45,416
today.


659
00:18:46,616 --> 00:18:48,986
The first is you may not want to


660
00:18:48,986 --> 00:18:50,646
use expensive networks, like a


661
00:18:50,646 --> 00:18:52,376
cellular network, because this


662
00:18:52,376 --> 00:18:54,106
connection is only appropriate


663
00:18:54,106 --> 00:18:55,226
to use over WiFi.


664
00:18:56,086 --> 00:18:57,586
So within the parameters for


665
00:18:57,586 --> 00:18:59,396
your connection, there are


666
00:18:59,396 --> 00:19:00,896
options to control the


667
00:19:00,896 --> 00:19:02,626
interfaces that you use.


668
00:19:03,076 --> 00:19:03,996
So if you don't want to use


669
00:19:03,996 --> 00:19:06,176
cellular, simply add cellular to


670
00:19:06,266 --> 00:19:08,466
the list of prohibited interface


671
00:19:08,466 --> 00:19:08,956
types.


672
00:19:09,496 --> 00:19:12,316
It's even better, actually to


673
00:19:12,316 --> 00:19:14,436
also prohibit expensive networks


674
00:19:14,436 --> 00:19:16,076
in general because this will


675
00:19:16,076 --> 00:19:18,526
also block the usage of personal


676
00:19:18,526 --> 00:19:22,766
hotspots on a Mac let's say.


677
00:19:23,016 --> 00:19:23,736
Another way that you can


678
00:19:23,736 --> 00:19:25,066
restrict your connection


679
00:19:25,066 --> 00:19:26,926
establishment is by choosing


680
00:19:26,926 --> 00:19:28,406
specifically the IP address


681
00:19:28,406 --> 00:19:29,816
family that you want to use.


682
00:19:30,466 --> 00:19:31,596
So let's say that you really


683
00:19:31,596 --> 00:19:33,376
love IPv6 because it's faster


684
00:19:33,376 --> 00:19:34,146
and it's the future.


685
00:19:34,496 --> 00:19:35,646
You don't want to use IPv4 at


686
00:19:35,646 --> 00:19:36,676
all on your connection.


687
00:19:37,346 --> 00:19:39,016
And you can do this by going to


688
00:19:39,016 --> 00:19:40,796
your parameters, digging down


689
00:19:40,796 --> 00:19:42,466
into the IP-specific options,


690
00:19:42,896 --> 00:19:44,286
and here you'll have options


691
00:19:44,286 --> 00:19:45,806
that you'll find familiar from


692
00:19:45,806 --> 00:19:47,846
your socket options on a socket


693
00:19:47,846 --> 00:19:49,586
today, and you can also define


694
00:19:49,656 --> 00:19:51,316
specifically which IP version


695
00:19:51,316 --> 00:19:52,146
you want to use.


696
00:19:52,576 --> 00:19:53,876
And this will impact your


697
00:19:53,876 --> 00:19:55,466
connection as well as your DNS


698
00:19:55,466 --> 00:19:56,046
resolution.


699
00:19:56,566 --> 00:19:59,186
And lastly, you may not want to


700
00:19:59,186 --> 00:20:00,976
use a proxy on your given


701
00:20:00,976 --> 00:20:01,396
connection.


702
00:20:01,396 --> 00:20:02,596
Maybe it's not appropriate for


703
00:20:02,836 --> 00:20:04,266
your connection to go through a


704
00:20:04,266 --> 00:20:05,096
SOCKS proxy.


705
00:20:05,766 --> 00:20:07,206
In that case, you can simply


706
00:20:07,416 --> 00:20:08,856
prohibit the use of proxies as


707
00:20:08,886 --> 00:20:09,056
well.


708
00:20:09,646 --> 00:20:12,676
So that's what happens in the


709
00:20:12,676 --> 00:20:13,386
preparing state.


710
00:20:14,736 --> 00:20:16,256
I mentioned before that things


711
00:20:16,636 --> 00:20:17,546
can go wrong.


712
00:20:17,546 --> 00:20:18,956
You can have no network when you


713
00:20:18,956 --> 00:20:20,836
try to establish, and what we'll


714
00:20:20,836 --> 00:20:22,456
do after going to preparing is


715
00:20:22,456 --> 00:20:23,646
if we find there are no good


716
00:20:23,646 --> 00:20:25,776
options, DNS failed, there was


717
00:20:25,776 --> 00:20:27,086
no network, maybe you're in


718
00:20:27,086 --> 00:20:28,536
airplane mode, we'll move into


719
00:20:28,536 --> 00:20:29,596
the waiting state and let you


720
00:20:29,596 --> 00:20:30,516
know the reason for that.


721
00:20:31,476 --> 00:20:32,766
And we'll keep going back into


722
00:20:32,766 --> 00:20:34,976
preparing every time the network


723
00:20:34,976 --> 00:20:36,396
changes and the system thinks,


724
00:20:36,806 --> 00:20:38,206
yeah, there's a good chance that


725
00:20:38,266 --> 00:20:39,396
your connection will become


726
00:20:39,396 --> 00:20:40,816
established now, and we'll


727
00:20:40,816 --> 00:20:42,586
handle all that for you and let


728
00:20:42,586 --> 00:20:43,956
you know every time that we're


729
00:20:43,956 --> 00:20:44,526
reattempting.


730
00:20:46,236 --> 00:20:48,146
Eventually, hopefully your


731
00:20:48,146 --> 00:20:49,626
connection does get established.


732
00:20:49,966 --> 00:20:51,136
At this point, we'll move into


733
00:20:51,136 --> 00:20:51,826
the ready state.


734
00:20:52,296 --> 00:20:54,186
And the ready state, as I


735
00:20:54,186 --> 00:20:56,336
mentioned before, is when your


736
00:20:56,336 --> 00:20:57,776
connection is fully established.


737
00:20:57,956 --> 00:20:59,566
So this is all of the protocols


738
00:20:59,646 --> 00:21:02,086
in your stack up to TLS, for


739
00:21:02,086 --> 00:21:02,486
example.


740
00:21:03,476 --> 00:21:04,646
At this point, you can read and


741
00:21:04,646 --> 00:21:07,066
write, and this is also where we


742
00:21:07,066 --> 00:21:10,036
give you callbacks about the


743
00:21:10,036 --> 00:21:11,476
network transitions that you're


744
00:21:11,476 --> 00:21:12,016
going through.


745
00:21:12,536 --> 00:21:14,086
So if your connection is


746
00:21:14,086 --> 00:21:15,236
established and then you change


747
00:21:15,236 --> 00:21:17,196
networks, we'll give you updates


748
00:21:17,196 --> 00:21:18,426
about that so you can handle the


749
00:21:18,426 --> 00:21:20,416
mobility gracefully, and we'll


750
00:21:20,416 --> 00:21:21,716
be talking about this later on


751
00:21:21,716 --> 00:21:21,976
in the talk.


752
00:21:24,536 --> 00:21:25,606
If there's an error on the


753
00:21:25,606 --> 00:21:27,046
connection, either during the


754
00:21:27,046 --> 00:21:28,716
connection establishment or


755
00:21:28,716 --> 00:21:29,916
after you've already connected,


756
00:21:30,076 --> 00:21:31,136
we'll give you the failed state


757
00:21:31,136 --> 00:21:33,546
with an error, and then once


758
00:21:33,546 --> 00:21:34,336
you're totally done with the


759
00:21:34,336 --> 00:21:35,396
connection, let's say you


760
00:21:35,396 --> 00:21:36,506
already closed it or you


761
00:21:36,506 --> 00:21:37,696
received a close from the other


762
00:21:37,696 --> 00:21:39,606
side, and you want to just


763
00:21:39,606 --> 00:21:40,766
invalidate the connection, you


764
00:21:40,766 --> 00:21:42,716
call cancel, and we move into


765
00:21:42,716 --> 00:21:43,536
the cancelled state.


766
00:21:43,636 --> 00:21:45,376
And this is guaranteed to be the


767
00:21:45,376 --> 00:21:47,156
very last event that we will


768
00:21:47,156 --> 00:21:49,506
deliver to your object so you


769
00:21:49,506 --> 00:21:50,656
can clean up any memory that you


770
00:21:50,656 --> 00:21:52,506
have associated and move on.


771
00:21:53,656 --> 00:21:54,456
So that's it.


772
00:21:54,576 --> 00:21:56,046
That's an overview of the basic


773
00:21:56,046 --> 00:21:58,176
lifetime of a connection object


774
00:21:58,176 --> 00:21:59,786
in Network.framework, and to


775
00:21:59,786 --> 00:22:01,306
show you how you can use this to


776
00:22:01,306 --> 00:22:03,286
build a simple app, I'd like to


777
00:22:03,286 --> 00:22:04,776
invite Eric up to the stage.


778
00:22:05,516 --> 00:22:10,500
[ Applause ]


779
00:22:13,196 --> 00:22:14,066
>> Thanks Tommy.


780
00:22:14,676 --> 00:22:16,216
I'm Eric Kinnear, also from the


781
00:22:16,216 --> 00:22:17,386
networking team here at Apple,


782
00:22:17,716 --> 00:22:19,156
and I'm really excited to build


783
00:22:19,156 --> 00:22:20,636
with you an example application


784
00:22:20,926 --> 00:22:21,926
using Network.framework.


785
00:22:23,026 --> 00:22:24,076
We're going to use the live


786
00:22:24,076 --> 00:22:25,696
streaming example that Tommy


787
00:22:25,696 --> 00:22:27,516
mentioned earlier to build an


788
00:22:27,516 --> 00:22:29,106
application that can take the


789
00:22:29,106 --> 00:22:31,216
camera input on one device and


790
00:22:31,216 --> 00:22:32,976
send it over a network to be


791
00:22:32,976 --> 00:22:34,326
displayed on another device.


792
00:22:35,396 --> 00:22:36,196
Because we're going to be


793
00:22:36,196 --> 00:22:37,806
continuously generating live


794
00:22:37,806 --> 00:22:40,156
video frames, we're going to use


795
00:22:40,376 --> 00:22:41,736
UDP to send those packets across


796
00:22:41,736 --> 00:22:42,126
the network.


797
00:22:43,186 --> 00:22:46,036
So how do we do this?


798
00:22:46,266 --> 00:22:48,126
Well, first, we need a capture


799
00:22:48,126 --> 00:22:49,566
session with the camera so that


800
00:22:49,566 --> 00:22:51,026
we can receive the video frames


801
00:22:51,106 --> 00:22:51,996
from the image sensor.


802
00:22:53,046 --> 00:22:54,296
For the sake of this example,


803
00:22:54,666 --> 00:22:55,946
we're not going to use any video


804
00:22:55,946 --> 00:22:57,346
codecs or other compression.


805
00:22:57,846 --> 00:22:58,966
We're simply going to take the


806
00:22:58,966 --> 00:23:00,706
raw bytes from the camera, ship


807
00:23:00,706 --> 00:23:01,866
them across the network, and


808
00:23:01,866 --> 00:23:02,936
display them on the other side.


809
00:23:03,456 --> 00:23:05,966
In order to make this happen, we


810
00:23:05,966 --> 00:23:07,206
need to divvy those frames up


811
00:23:07,206 --> 00:23:09,006
into smaller chunks that we can


812
00:23:09,006 --> 00:23:10,416
send in UDP packets.


813
00:23:11,986 --> 00:23:13,236
Of course, to send those UDP


814
00:23:13,236 --> 00:23:14,876
packets on the network, we need


815
00:23:15,766 --> 00:23:16,926
a connection.


816
00:23:16,926 --> 00:23:17,846
Switching over to the other


817
00:23:17,846 --> 00:23:19,906
device, we need a listener that


818
00:23:19,906 --> 00:23:21,036
can receive that incoming


819
00:23:21,036 --> 00:23:23,196
connection and read the data


820
00:23:23,196 --> 00:23:24,366
packets off the network.


821
00:23:25,156 --> 00:23:26,326
From there, we simply reverse


822
00:23:26,326 --> 00:23:27,336
the earlier process,


823
00:23:27,796 --> 00:23:29,056
reassembling the video frames


824
00:23:29,366 --> 00:23:30,756
and sending them to the display


825
00:23:30,756 --> 00:23:31,666
so that we can see them on the


826
00:23:31,666 --> 00:23:31,966
screen.


827
00:23:32,556 --> 00:23:35,536
To keep things simple, we've


828
00:23:35,536 --> 00:23:36,766
already abstracted out the


829
00:23:36,766 --> 00:23:37,846
camera and the display


830
00:23:37,846 --> 00:23:39,346
functionalities so that we can


831
00:23:39,346 --> 00:23:41,156
focus just on the parts that use


832
00:23:41,156 --> 00:23:41,806
Network.framework.


833
00:23:43,296 --> 00:23:44,856
There's one piece we haven't yet


834
00:23:44,856 --> 00:23:46,086
covered here, and that's the


835
00:23:46,086 --> 00:23:46,496
listener.


836
00:23:46,836 --> 00:23:47,646
So we're going to take a minute


837
00:23:47,646 --> 00:23:50,076
to do that now.


838
00:23:50,326 --> 00:23:51,726
Listener functionality is


839
00:23:51,726 --> 00:23:53,116
provided by the NWListener


840
00:23:53,116 --> 00:23:54,976
class, which you can create


841
00:23:54,976 --> 00:23:56,026
using the same parameters


842
00:23:56,026 --> 00:23:57,386
objects that you used to


843
00:23:57,386 --> 00:23:58,206
configure connections.


844
00:23:59,836 --> 00:24:01,296
It's really easy to set up a


845
00:24:01,296 --> 00:24:03,296
listener to advertise a bonjour


846
00:24:03,296 --> 00:24:03,826
service.


847
00:24:04,146 --> 00:24:05,316
In this case, we'll use


848
00:24:05,316 --> 00:24:06,076
camera.udp.


849
00:24:06,076 --> 00:24:10,246
When a new connection is


850
00:24:10,246 --> 00:24:11,946
received by a listener, it will


851
00:24:11,946 --> 00:24:13,286
pass that connection to a block


852
00:24:13,286 --> 00:24:14,566
that you provide as the


853
00:24:14,566 --> 00:24:15,436
newConnectionHandler.


854
00:24:16,496 --> 00:24:17,606
This is your opportunity to


855
00:24:17,666 --> 00:24:19,096
perform any configuration that


856
00:24:19,096 --> 00:24:20,586
you choose on that connection,


857
00:24:21,036 --> 00:24:22,216
and then you need to call start


858
00:24:22,556 --> 00:24:24,006
to let that connection know that


859
00:24:24,006 --> 00:24:26,716
it's time to get going.


860
00:24:26,936 --> 00:24:28,226
Similarly, you need to call


861
00:24:28,226 --> 00:24:29,576
start on your listener, and


862
00:24:29,576 --> 00:24:30,566
again, just like with


863
00:24:30,566 --> 00:24:31,696
connections, you provide a


864
00:24:31,696 --> 00:24:33,016
dispatch queue where you want


865
00:24:33,016 --> 00:24:34,136
these callbacks to be scheduled.


866
00:24:34,666 --> 00:24:36,706
So that's listeners.


867
00:24:37,106 --> 00:24:38,516
If you think about it, we just


868
00:24:38,516 --> 00:24:39,916
implemented the equivalent of


869
00:24:39,916 --> 00:24:41,806
calling listen on a UDP socket.


870
00:24:42,926 --> 00:24:45,236
Except listen doesn't actually


871
00:24:45,236 --> 00:24:47,346
work on UDP sockets.


872
00:24:47,476 --> 00:24:48,906
Now we're ready to build our app


873
00:24:48,906 --> 00:24:49,376
in Xcode.


874
00:24:50,646 --> 00:24:51,476
So here we've got our


875
00:24:51,476 --> 00:24:53,026
application, and we've got a


876
00:24:53,026 --> 00:24:54,596
bunch of files over here that


877
00:24:54,596 --> 00:24:55,976
already handle the camera and


878
00:24:55,976 --> 00:24:57,876
the display functionality, so


879
00:24:57,876 --> 00:24:59,126
we're going to focus just on the


880
00:24:59,126 --> 00:25:01,316
UDPClient class and the


881
00:25:01,316 --> 00:25:02,076
UDPServer class.


882
00:25:03,156 --> 00:25:05,016
The UDPClient is going to be


883
00:25:05,016 --> 00:25:06,306
responsible for creating the


884
00:25:06,306 --> 00:25:07,966
connection to the other side and


885
00:25:07,966 --> 00:25:09,026
sending the frames across.


886
00:25:10,286 --> 00:25:11,776
Likewise, the server is


887
00:25:11,776 --> 00:25:12,816
responsible for creating the


888
00:25:12,816 --> 00:25:14,736
listener, accepting incoming


889
00:25:14,736 --> 00:25:16,446
connections, reading the data


890
00:25:16,446 --> 00:25:17,746
off those connections, and


891
00:25:17,746 --> 00:25:18,756
sending them up to the screen.


892
00:25:19,736 --> 00:25:22,416
Let's start with the client.


893
00:25:22,526 --> 00:25:23,656
My client class has an


894
00:25:23,656 --> 00:25:25,656
initializer that takes a name,


895
00:25:25,996 --> 00:25:28,056
which is a string describing the


896
00:25:28,056 --> 00:25:29,766
bonjour name that we want to


897
00:25:30,316 --> 00:25:31,436
connect to.


898
00:25:31,646 --> 00:25:33,836
I'll create my connection by


899
00:25:33,836 --> 00:25:35,986
simply calling NWConnection and


900
00:25:35,986 --> 00:25:37,296
passing in a service endpoint.


901
00:25:38,096 --> 00:25:39,116
Using the name that I was


902
00:25:39,116 --> 00:25:42,826
provided and camera.udp as the


903
00:25:43,456 --> 00:25:43,556
type.


904
00:25:43,776 --> 00:25:45,336
We also passed the default UDP


905
00:25:45,336 --> 00:25:45,876
parameters.


906
00:25:46,386 --> 00:25:49,596
As Tommy mentioned, we can use a


907
00:25:49,596 --> 00:25:52,826
state update handler to check


908
00:25:53,226 --> 00:25:54,546
for the ready and the failed


909
00:25:54,546 --> 00:25:55,016
states.


910
00:25:56,066 --> 00:25:57,546
Here, when our connection is


911
00:25:57,546 --> 00:25:58,776
ready, we'll call


912
00:25:58,776 --> 00:26:00,676
sendInitialFrame, which we'll


913
00:26:00,676 --> 00:26:02,616
implement in a minute.


914
00:26:02,726 --> 00:26:04,466
Because we're using UDP and


915
00:26:04,466 --> 00:26:05,526
there's no other handshake,


916
00:26:05,996 --> 00:26:07,216
we're going to take some data


917
00:26:07,566 --> 00:26:08,556
and send it across to the


918
00:26:08,556 --> 00:26:11,066
network to the other device and


919
00:26:11,066 --> 00:26:12,226
wait for it to be echoed back


920
00:26:12,586 --> 00:26:13,926
before we start generating lots


921
00:26:13,926 --> 00:26:15,266
of video frames and dumping them


922
00:26:15,266 --> 00:26:15,766
on the network.


923
00:26:19,176 --> 00:26:20,886
We need to remember to call


924
00:26:20,886 --> 00:26:22,576
start on our connection, and we


925
00:26:22,576 --> 00:26:23,466
provide the queue that we


926
00:26:23,466 --> 00:26:26,026
created up above.


927
00:26:26,236 --> 00:26:27,296
Let's implement send initial


928
00:26:27,296 --> 00:26:27,576
frame.


929
00:26:32,156 --> 00:26:33,346
Here we're going to take the


930
00:26:33,346 --> 00:26:35,876
literal bytes hello and create a


931
00:26:35,876 --> 00:26:38,156
data object using them.


932
00:26:38,156 --> 00:26:39,746
To send content on a connection,


933
00:26:40,206 --> 00:26:42,216
we can call connection.send and


934
00:26:42,216 --> 00:26:44,056
provide that data object as the


935
00:26:44,056 --> 00:26:44,496
content.


936
00:26:45,876 --> 00:26:47,396
We provide a completion handler


937
00:26:47,646 --> 00:26:48,886
in which we can check for any


938
00:26:48,886 --> 00:26:49,986
errors that may have been


939
00:26:49,986 --> 00:26:50,906
encountered while sending.


940
00:26:51,416 --> 00:26:54,396
Since we expect this content to


941
00:26:54,396 --> 00:26:56,066
be immediately echoed back, we


942
00:26:56,066 --> 00:26:57,316
turn right around and call


943
00:26:57,316 --> 00:26:59,056
connection.receive to read the


944
00:26:59,056 --> 00:27:00,126
incoming data off of the


945
00:27:00,126 --> 00:27:00,576
connection.


946
00:27:01,536 --> 00:27:03,006
In that completion handler, we


947
00:27:03,006 --> 00:27:04,106
validate that the content is


948
00:27:04,106 --> 00:27:06,216
present, and if so, we let the


949
00:27:06,216 --> 00:27:07,386
rest of the application know


950
00:27:07,386 --> 00:27:08,836
that we're connected, and it


951
00:27:08,836 --> 00:27:09,776
should bring up the camera


952
00:27:09,776 --> 00:27:11,156
hardware and start generating


953
00:27:11,156 --> 00:27:11,476
frames.


954
00:27:12,076 --> 00:27:15,186
When those frames are generated,


955
00:27:15,616 --> 00:27:16,566
the rest of the application


956
00:27:16,566 --> 00:27:18,266
knows to call send on our


957
00:27:18,266 --> 00:27:22,986
UDPClient class and pass it an


958
00:27:23,246 --> 00:27:24,676
array of data objects


959
00:27:24,796 --> 00:27:26,056
representing the video frames


960
00:27:26,186 --> 00:27:28,906
that we're trying to send.


961
00:27:29,096 --> 00:27:30,006
Because we're going to be doing


962
00:27:30,006 --> 00:27:31,406
a lot of send operations in very


963
00:27:31,406 --> 00:27:32,876
quick succession, we're going to


964
00:27:32,876 --> 00:27:34,516
do them within a block that we


965
00:27:34,516 --> 00:27:37,436
passed in connection.batch.


966
00:27:37,646 --> 00:27:39,126
Within this block we're going to


967
00:27:39,126 --> 00:27:41,026
go through every frame in that


968
00:27:41,026 --> 00:27:43,206
array of data objects and pass


969
00:27:43,206 --> 00:27:45,226
each one to connection.send.


970
00:27:45,926 --> 00:27:47,826
Similarly to above, we use the


971
00:27:47,826 --> 00:27:48,976
completion handler to check for


972
00:27:48,976 --> 00:27:50,466
any errors that were encountered


973
00:27:50,466 --> 00:27:50,916
while sending.


974
00:27:52,056 --> 00:27:52,526
And that's it.


975
00:27:53,216 --> 00:27:54,546
We've got our UDPClient class,


976
00:27:54,826 --> 00:27:55,556
and we're ready to go.


977
00:27:55,556 --> 00:27:58,566
Let's look at the server.


978
00:27:59,896 --> 00:28:01,416
On the server side, we need a


979
00:28:01,416 --> 00:28:02,856
listener that can accept the


980
00:28:02,856 --> 00:28:03,766
incoming connections.


981
00:28:04,246 --> 00:28:05,236
We need to respond to that


982
00:28:05,236 --> 00:28:06,516
handshake that we just sent from


983
00:28:06,516 --> 00:28:08,066
the client, and we need to read


984
00:28:08,066 --> 00:28:09,456
data off the network so that we


985
00:28:09,456 --> 00:28:10,436
can push it up to the display.


986
00:28:11,496 --> 00:28:13,066
Starting with the listener, we


987
00:28:15,976 --> 00:28:17,836
simply create an NWListener


988
00:28:18,156 --> 00:28:19,126
using the default UDP


989
00:28:19,126 --> 00:28:19,686
parameters.


990
00:28:20,236 --> 00:28:22,656
If I wanted to, this is also my


991
00:28:22,656 --> 00:28:23,736
opportunity to use those


992
00:28:23,736 --> 00:28:25,236
parameters to tell the listener


993
00:28:25,236 --> 00:28:26,596
to listen on a specific local


994
00:28:26,596 --> 00:28:26,886
port.


995
00:28:27,376 --> 00:28:28,406
But since we're using a bonjour


996
00:28:28,406 --> 00:28:29,566
service, we don't need to do


997
00:28:29,566 --> 00:28:30,366
that.


998
00:28:33,316 --> 00:28:35,236
To set up that service, I'm


999
00:28:35,236 --> 00:28:36,166
going to set the service


1000
00:28:36,166 --> 00:28:38,476
property on the listener to a


1001
00:28:38,476 --> 00:28:39,516
service object of type


1002
00:28:39,516 --> 00:28:40,426
camera.udp.


1003
00:28:41,216 --> 00:28:42,286
Notice that I don't pass the


1004
00:28:42,286 --> 00:28:43,826
name here because I want the


1005
00:28:43,826 --> 00:28:45,396
system to provide the default


1006
00:28:45,396 --> 00:28:46,236
device name for me.


1007
00:28:47,766 --> 00:28:49,666
I also provide a block to the


1008
00:28:49,666 --> 00:28:50,586
serviceRegistration


1009
00:28:50,586 --> 00:28:52,806
UpdateHandler, which is going to


1010
00:28:52,806 --> 00:28:54,466
be called anytime the set of


1011
00:28:54,466 --> 00:28:55,786
endpoints advertised by the


1012
00:28:55,786 --> 00:28:57,196
system changes.


1013
00:28:57,966 --> 00:28:59,366
Here, I'm interested in the case


1014
00:28:59,456 --> 00:29:01,206
where an endpoint is added, and


1015
00:29:01,206 --> 00:29:03,476
if it's of service type, I tell


1016
00:29:03,476 --> 00:29:05,006
the rest of the application the


1017
00:29:05,006 --> 00:29:06,446
name that is being advertised,


1018
00:29:06,586 --> 00:29:07,796
that default device name that I


1019
00:29:07,796 --> 00:29:08,956
ask the system to provide so


1020
00:29:08,956 --> 00:29:10,506
that I can display it in the UI


1021
00:29:10,506 --> 00:29:11,586
and have my users type it in


1022
00:29:11,586 --> 00:29:11,976
somewhere else.


1023
00:29:20,046 --> 00:29:20,916
I'm going to set a new


1024
00:29:20,916 --> 00:29:22,246
connection handler on the


1025
00:29:22,246 --> 00:29:23,766
listener, which will be called


1026
00:29:23,766 --> 00:29:25,046
every time the listener receives


1027
00:29:25,046 --> 00:29:26,046
a new incoming connection.


1028
00:29:26,116 --> 00:29:28,906
I could do some configuration on


1029
00:29:28,906 --> 00:29:29,986
these connections, but the


1030
00:29:29,986 --> 00:29:31,136
default settings are fine here,


1031
00:29:31,356 --> 00:29:31,996
so I simply call


1032
00:29:31,996 --> 00:29:34,536
connection.start and pass it to


1033
00:29:36,176 --> 00:29:36,286
queue.


1034
00:29:36,466 --> 00:29:38,216
Here, I notify the rest of the


1035
00:29:38,216 --> 00:29:39,746
application that I've received


1036
00:29:39,746 --> 00:29:41,076
an incoming connection, so it


1037
00:29:41,076 --> 00:29:42,336
can start warming up the display


1038
00:29:42,336 --> 00:29:43,766
pipeline and become ready to


1039
00:29:43,766 --> 00:29:45,106
display the video frames.


1040
00:29:46,336 --> 00:29:47,976
I'll also call receive on


1041
00:29:47,976 --> 00:29:49,406
myself, which we'll implement in


1042
00:29:49,406 --> 00:29:50,666
a minute, to start reading that


1043
00:29:50,666 --> 00:29:52,016
data off of the network and


1044
00:29:52,016 --> 00:29:52,966
shipping it up to the display


1045
00:29:52,966 --> 00:29:53,326
pipeline.


1046
00:29:53,326 --> 00:29:56,736
Just like with connections,


1047
00:29:57,056 --> 00:30:01,756
listeners have state update


1048
00:30:01,756 --> 00:30:03,086
handlers, which I'll use to


1049
00:30:03,086 --> 00:30:04,556
check for the ready and the


1050
00:30:04,556 --> 00:30:05,696
failed states.


1051
00:30:07,236 --> 00:30:08,896
I need to not forget to start my


1052
00:30:08,896 --> 00:30:10,856
listener, which I do by calling


1053
00:30:10,856 --> 00:30:12,496
listener.start and passing it


1054
00:30:12,496 --> 00:30:14,406
that queue we created up above.


1055
00:30:15,436 --> 00:30:17,036
So I've got my listener ready, I


1056
00:30:17,036 --> 00:30:18,506
just need to read data off the


1057
00:30:18,506 --> 00:30:19,976
network and implement this


1058
00:30:19,976 --> 00:30:20,636
receive function.


1059
00:30:24,656 --> 00:30:26,156
Here, we start by calling


1060
00:30:26,156 --> 00:30:28,036
connection.receive and passing


1061
00:30:28,036 --> 00:30:28,976
it into completion handler.


1062
00:30:29,646 --> 00:30:30,856
When data comes in off of that


1063
00:30:30,856 --> 00:30:32,376
connection, we'll see if we're


1064
00:30:32,376 --> 00:30:33,206
not yet connected.


1065
00:30:33,966 --> 00:30:35,586
If we weren't connected, this is


1066
00:30:35,586 --> 00:30:37,136
probably that handshake that the


1067
00:30:37,136 --> 00:30:40,166
client is starting by sending.


1068
00:30:40,306 --> 00:30:41,476
We'll simply turn right around


1069
00:30:41,476 --> 00:30:42,716
and call connection.send,


1070
00:30:43,246 --> 00:30:45,136
passing that same content back


1071
00:30:45,396 --> 00:30:46,476
so it will be echoed over to the


1072
00:30:46,476 --> 00:30:46,756
client.


1073
00:30:47,656 --> 00:30:48,516
We then remember that we're


1074
00:30:48,516 --> 00:30:50,516
connected, and on all subsequent


1075
00:30:50,516 --> 00:30:52,776
received callbacks, we will


1076
00:30:52,776 --> 00:30:53,916
simply tell the rest of the


1077
00:30:53,916 --> 00:30:55,516
application that we received


1078
00:30:55,836 --> 00:30:57,326
this frame, and it should send


1079
00:30:57,326 --> 00:30:58,966
it up to the display pipeline so


1080
00:30:58,966 --> 00:31:00,666
that we can see it on the


1081
00:31:01,596 --> 00:31:01,756
screen.


1082
00:31:01,926 --> 00:31:03,296
Finally, if there were no


1083
00:31:03,296 --> 00:31:05,456
errors, we call receive again so


1084
00:31:05,456 --> 00:31:06,496
that we receive subsequent


1085
00:31:06,496 --> 00:31:08,026
frames and send them up to the


1086
00:31:08,026 --> 00:31:09,826
display to book together a video


1087
00:31:09,826 --> 00:31:11,156
from each of these individual


1088
00:31:11,156 --> 00:31:11,526
images.


1089
00:31:12,086 --> 00:31:13,876
So that's it.


1090
00:31:13,966 --> 00:31:15,566
We've got our UDPClient, we've


1091
00:31:15,566 --> 00:31:17,476
got our UDPServer, let's try it


1092
00:31:17,476 --> 00:31:17,656
out.


1093
00:31:20,226 --> 00:31:22,316
I'm going to run the client on


1094
00:31:22,316 --> 00:31:24,046
my phone here, and I'm going to


1095
00:31:24,046 --> 00:31:25,786
run the server on my Mac so we


1096
00:31:25,786 --> 00:31:26,826
can see it on the big screen.


1097
00:31:27,366 --> 00:31:29,626
Here, the server just came up,


1098
00:31:30,386 --> 00:31:32,086
and we see that it's advertising


1099
00:31:32,086 --> 00:31:34,026
as Demo Mac, which is where I


1100
00:31:34,026 --> 00:31:36,166
told the rest of the system to


1101
00:31:36,166 --> 00:31:37,136
just give me the name.


1102
00:31:38,166 --> 00:31:39,206
That's on my phone.


1103
00:31:39,206 --> 00:31:41,676
If I tap connect, all of a


1104
00:31:41,676 --> 00:31:43,826
sudden, I can see video frames


1105
00:31:44,276 --> 00:31:45,206
being streamed across the


1106
00:31:45,206 --> 00:31:46,796
network over UDP Live.


1107
00:31:48,516 --> 00:31:53,500
[ Applause ]


1108
00:31:58,356 --> 00:32:00,276
So here we just saw how quickly


1109
00:32:00,276 --> 00:32:01,386
I was able to bring up a


1110
00:32:01,726 --> 00:32:03,806
UDPClient that could connect to


1111
00:32:03,806 --> 00:32:06,616
a bonjour service, it can send a


1112
00:32:06,616 --> 00:32:08,356
handshake, wait for that to be


1113
00:32:08,356 --> 00:32:10,726
processed, take the video frames


1114
00:32:10,726 --> 00:32:11,956
coming from the camera, and ship


1115
00:32:11,956 --> 00:32:12,806
them across the network.


1116
00:32:14,116 --> 00:32:16,716
The server side brought up a


1117
00:32:16,716 --> 00:32:18,606
bonjour listener.


1118
00:32:19,096 --> 00:32:20,866
It advertised a service, it


1119
00:32:20,866 --> 00:32:22,196
received incoming connections,


1120
00:32:22,436 --> 00:32:23,916
responded to the handshake, and


1121
00:32:23,916 --> 00:32:25,516
sent them all to the display so


1122
00:32:25,516 --> 00:32:26,106
that we could see them.


1123
00:32:27,176 --> 00:32:28,426
And now to take you through


1124
00:32:28,666 --> 00:32:29,846
optimizing that data transfer in


1125
00:32:29,846 --> 00:32:30,896
a little more detail, I'd like


1126
00:32:30,896 --> 00:32:32,126
to invite Tommy back up to the


1127
00:32:32,126 --> 00:32:32,506
stage.


1128
00:32:33,516 --> 00:32:38,416
[ Applause ]


1129
00:32:38,916 --> 00:32:39,726
>> Thank you, Eric.


1130
00:32:40,036 --> 00:32:42,116
It was a really cool demo.


1131
00:32:42,116 --> 00:32:43,386
It's super easy to get this


1132
00:32:43,386 --> 00:32:44,876
going, and so now we've covered


1133
00:32:44,876 --> 00:32:46,406
the basics, and we know how to


1134
00:32:46,736 --> 00:32:48,096
establish connections outbound,


1135
00:32:48,096 --> 00:32:49,106
how to receive connections


1136
00:32:49,106 --> 00:32:52,136
inbound, but the real key part


1137
00:32:52,136 --> 00:32:53,556
of Network.framework that's


1138
00:32:53,556 --> 00:32:54,526
going to be the killer feature


1139
00:32:54,526 --> 00:32:56,346
here is the way that it can


1140
00:32:56,346 --> 00:32:57,846
optimize your performance and


1141
00:32:57,846 --> 00:32:58,926
that we can go beyond what


1142
00:32:58,976 --> 00:33:00,126
sockets was able to do.


1143
00:33:00,676 --> 00:33:03,096
And I want to start with the way


1144
00:33:03,096 --> 00:33:04,886
that you in your application


1145
00:33:05,126 --> 00:33:06,496
interact with your networking


1146
00:33:06,496 --> 00:33:08,586
connections in the most basic


1147
00:33:08,586 --> 00:33:10,846
way, which is just sending and


1148
00:33:10,846 --> 00:33:11,506
receiving data.


1149
00:33:12,786 --> 00:33:14,686
And these calls are very simple,


1150
00:33:15,226 --> 00:33:17,146
but the nuances about how you


1151
00:33:17,146 --> 00:33:18,956
handle sending and receiving and


1152
00:33:18,956 --> 00:33:20,326
really make a huge difference


1153
00:33:20,796 --> 00:33:22,076
for the responsiveness of your


1154
00:33:22,076 --> 00:33:23,696
app and how much buffering there


1155
00:33:23,696 --> 00:33:25,816
is going on on the device and


1156
00:33:25,816 --> 00:33:26,266
the network.


1157
00:33:26,886 --> 00:33:29,016
So the first example I want to


1158
00:33:29,016 --> 00:33:30,516
walk through is when we're


1159
00:33:30,516 --> 00:33:32,786
sending data, in the application


1160
00:33:32,786 --> 00:33:34,236
very much like what Eric just


1161
00:33:34,236 --> 00:33:35,616
showed you, something that's


1162
00:33:35,616 --> 00:33:36,826
live streaming, something that


1163
00:33:36,826 --> 00:33:38,586
is generating data on the fly.


1164
00:33:39,166 --> 00:33:40,736
But in this case, let's talk


1165
00:33:40,736 --> 00:33:42,476
about when we're sending it over


1166
00:33:42,476 --> 00:33:44,776
a TCP stream, a TCP stream that


1167
00:33:44,776 --> 00:33:46,676
can back up on the network, that


1168
00:33:46,676 --> 00:33:47,926
has a certain window that it can


1169
00:33:47,976 --> 00:33:48,336
send.


1170
00:33:48,616 --> 00:33:50,486
So how do we handle this?


1171
00:33:51,356 --> 00:33:53,716
So here's a function to send a


1172
00:33:53,716 --> 00:33:54,446
single frame.


1173
00:33:54,446 --> 00:33:56,136
This is some frame of data that


1174
00:33:56,136 --> 00:33:57,796
your application has generated.


1175
00:33:58,376 --> 00:34:00,656
And the way that you send it on


1176
00:34:00,656 --> 00:34:01,706
the connection is you simply


1177
00:34:01,706 --> 00:34:03,886
call connection.send and pass


1178
00:34:04,196 --> 00:34:04,636
that data.


1179
00:34:05,556 --> 00:34:06,956
Now if you're used to using


1180
00:34:06,956 --> 00:34:09,496
sockets to send on your


1181
00:34:09,496 --> 00:34:11,775
connections, you either are


1182
00:34:11,775 --> 00:34:13,045
using a blocking socket, in


1183
00:34:13,126 --> 00:34:15,676
which case if you have a hundred


1184
00:34:15,676 --> 00:34:17,436
bytes of data to send, if


1185
00:34:17,436 --> 00:34:18,446
there's not room in the send


1186
00:34:18,446 --> 00:34:20,496
buffer, it'll actually block up


1187
00:34:20,496 --> 00:34:22,226
your thread and wait for the


1188
00:34:22,226 --> 00:34:24,815
network connection to drain out,


1189
00:34:25,166 --> 00:34:27,126
or if you're using a nonblocking


1190
00:34:27,126 --> 00:34:30,585
socket, that send may actually


1191
00:34:30,585 --> 00:34:31,846
not send your complete data.


1192
00:34:31,846 --> 00:34:33,196
It'll say, oh, I only sent 50


1193
00:34:33,196 --> 00:34:33,696
bytes of it.


1194
00:34:33,696 --> 00:34:34,696
Come back some other time to


1195
00:34:34,696 --> 00:34:35,846
send the next 50 bytes.


1196
00:34:36,536 --> 00:34:37,596
This requires you and your


1197
00:34:37,596 --> 00:34:38,795
application to handle a lot of


1198
00:34:38,795 --> 00:34:40,716
state about how much you have


1199
00:34:40,716 --> 00:34:42,565
actually done of sending your


1200
00:34:43,186 --> 00:34:43,315
data.


1201
00:34:44,235 --> 00:34:45,466
So the great thing about a


1202
00:34:45,466 --> 00:34:46,606
network connection is you can


1203
00:34:46,606 --> 00:34:48,056
simply send all of your data at


1204
00:34:48,106 --> 00:34:49,056
once, and you don't have to


1205
00:34:49,056 --> 00:34:51,126
worry about this, and it doesn't


1206
00:34:51,126 --> 00:34:51,826
block anything.


1207
00:34:53,106 --> 00:34:54,286
But then, of course, you have to


1208
00:34:54,286 --> 00:34:55,906
handle what happens if the


1209
00:34:55,906 --> 00:34:57,226
connection is backing up,


1210
00:34:57,226 --> 00:34:58,286
because we don't want to just


1211
00:34:58,456 --> 00:35:00,746
send a ton of data unnecessarily


1212
00:35:00,746 --> 00:35:02,456
into this connection if you want


1213
00:35:02,456 --> 00:35:04,616
a really responsive, live stream


1214
00:35:04,616 --> 00:35:04,966
of data.


1215
00:35:06,226 --> 00:35:08,176
And the key here is that


1216
00:35:08,176 --> 00:35:09,496
callback block that we give you.


1217
00:35:10,336 --> 00:35:12,116
It's called contentProcessed.


1218
00:35:12,766 --> 00:35:15,356
And we'll invoke it whenever the


1219
00:35:15,356 --> 00:35:17,006
network stack consumes your


1220
00:35:17,006 --> 00:35:17,246
data.


1221
00:35:17,666 --> 00:35:18,816
So this doesn't mean that the


1222
00:35:18,816 --> 00:35:20,046
data has necessarily been sent


1223
00:35:20,046 --> 00:35:21,306
out or acknowledged by the other


1224
00:35:21,306 --> 00:35:21,676
side.


1225
00:35:22,146 --> 00:35:23,996
It's exactly equivalent to the


1226
00:35:23,996 --> 00:35:25,696
time in which a blocking socket


1227
00:35:25,696 --> 00:35:27,506
call would return to you, or


1228
00:35:27,536 --> 00:35:29,256
when the nonblocking socket call


1229
00:35:29,256 --> 00:35:30,806
was able to consume all of the


1230
00:35:30,806 --> 00:35:31,656
bytes that you sent.


1231
00:35:32,246 --> 00:35:34,716
And in this completion handler,


1232
00:35:35,176 --> 00:35:36,076
there are two things you can


1233
00:35:36,076 --> 00:35:36,496
check for.


1234
00:35:37,566 --> 00:35:39,126
First, you can check for an


1235
00:35:39,126 --> 00:35:39,396
error.


1236
00:35:39,996 --> 00:35:41,176
If there is an error, that means


1237
00:35:41,176 --> 00:35:42,176
something went wrong while we


1238
00:35:42,176 --> 00:35:43,136
were trying to send your data,


1239
00:35:43,676 --> 00:35:45,536
generally it indicates a overall


1240
00:35:45,536 --> 00:35:46,316
connection failure.


1241
00:35:47,806 --> 00:35:49,746
Then, if there wasn't and error,


1242
00:35:49,986 --> 00:35:52,056
this is the perfect opportunity


1243
00:35:52,236 --> 00:35:53,896
to go and see if there's more


1244
00:35:53,896 --> 00:35:55,606
data from your application to


1245
00:35:55,606 --> 00:35:56,016
generate.


1246
00:35:56,016 --> 00:35:58,026
So if you're generating live


1247
00:35:58,026 --> 00:36:00,426
data frames, go and fetch


1248
00:36:00,426 --> 00:36:01,336
another frame from the video


1249
00:36:01,336 --> 00:36:02,546
stream, because now is the time


1250
00:36:02,546 --> 00:36:03,646
when you can actually enqueue


1251
00:36:03,646 --> 00:36:04,616
the next packets.


1252
00:36:05,046 --> 00:36:06,976
This allows you to pace all of


1253
00:36:06,976 --> 00:36:07,596
your data out.


1254
00:36:08,706 --> 00:36:10,116
And so as you see here, we


1255
00:36:10,116 --> 00:36:12,586
essentially form a loop of using


1256
00:36:12,586 --> 00:36:13,966
this asynchronous send callback


1257
00:36:14,366 --> 00:36:17,006
to continue to drain data out of


1258
00:36:17,006 --> 00:36:18,526
our connection and handle it


1259
00:36:18,676 --> 00:36:19,656
really elegantly.


1260
00:36:22,256 --> 00:36:23,816
The other thing I want to point


1261
00:36:23,816 --> 00:36:25,816
out about sending is the trick


1262
00:36:25,816 --> 00:36:27,156
that Eric showed earlier that's


1263
00:36:27,216 --> 00:36:29,406
great for UDP applications that


1264
00:36:29,406 --> 00:36:31,396
are sending multiple datagrams


1265
00:36:31,726 --> 00:36:32,546
all at one time.


1266
00:36:33,626 --> 00:36:35,116
So if you have a whole bunch of


1267
00:36:35,116 --> 00:36:36,396
little tiny pieces of data that


1268
00:36:36,396 --> 00:36:37,566
you need to send out or


1269
00:36:37,566 --> 00:36:39,036
essentially individual packets,


1270
00:36:40,206 --> 00:36:41,596
you can use something that we've


1271
00:36:41,596 --> 00:36:43,276
added called connection.batch.


1272
00:36:43,636 --> 00:36:46,046
So a UDP socket previously could


1273
00:36:46,046 --> 00:36:47,916
only send one packet at a time,


1274
00:36:48,606 --> 00:36:49,626
and this could be very


1275
00:36:49,626 --> 00:36:51,006
inefficient because if I have to


1276
00:36:51,006 --> 00:36:52,906
send a hundred UDP packets,


1277
00:36:53,196 --> 00:36:54,506
these are each a different


1278
00:36:54,506 --> 00:36:56,196
system call, a different copy,


1279
00:36:56,196 --> 00:36:57,446
and a context switch down into


1280
00:36:57,446 --> 00:36:57,886
the kernel.


1281
00:36:59,226 --> 00:37:01,206
But if you call batch within


1282
00:37:01,206 --> 00:37:03,706
that block, you can call send or


1283
00:37:03,706 --> 00:37:05,016
actually receive as many times


1284
00:37:05,016 --> 00:37:06,586
as you want, and the connection


1285
00:37:06,586 --> 00:37:08,406
will hold off processing any of


1286
00:37:08,406 --> 00:37:10,936
the data until you finish the


1287
00:37:10,936 --> 00:37:12,756
batch block and will try to send


1288
00:37:12,756 --> 00:37:14,656
all of those datagrams all as


1289
00:37:14,806 --> 00:37:16,876
one single batch down into the


1290
00:37:16,876 --> 00:37:19,026
system, ideally have just one


1291
00:37:19,026 --> 00:37:20,926
context switch down into the


1292
00:37:20,956 --> 00:37:22,026
kernel, and send out the


1293
00:37:22,026 --> 00:37:22,666
interface.


1294
00:37:23,126 --> 00:37:24,856
This allows you to be very, very


1295
00:37:24,856 --> 00:37:25,286
efficient.


1296
00:37:25,766 --> 00:37:28,196
So that's sending.


1297
00:37:28,846 --> 00:37:31,286
Receiving, like sending, is


1298
00:37:31,346 --> 00:37:32,586
asynchronous, and the


1299
00:37:32,586 --> 00:37:34,466
asynchronous nature gives you


1300
00:37:34,596 --> 00:37:35,606
the back pressure that allows


1301
00:37:35,606 --> 00:37:37,106
you to pace your app.


1302
00:37:38,276 --> 00:37:40,416
So in this case, I have a


1303
00:37:40,416 --> 00:37:43,116
TCP-based protocol, and it's


1304
00:37:43,116 --> 00:37:44,686
very common for apps when


1305
00:37:44,686 --> 00:37:46,386
they're reading to essentially


1306
00:37:46,386 --> 00:37:48,216
want to be reading some type of


1307
00:37:48,216 --> 00:37:49,066
record format.


1308
00:37:49,666 --> 00:37:52,286
Let's say that your protocol has


1309
00:37:52,286 --> 00:37:55,186
a header of 10 bytes that tells


1310
00:37:55,186 --> 00:37:56,316
you some information about what


1311
00:37:56,316 --> 00:37:57,606
you're about to receive, maybe


1312
00:37:57,606 --> 00:37:58,726
the length of the body that


1313
00:37:58,726 --> 00:37:59,406
you're about to receive.


1314
00:38:00,576 --> 00:38:01,486
And so you want to read that


1315
00:38:01,486 --> 00:38:03,036
header first and then read the


1316
00:38:03,036 --> 00:38:04,646
rest of your content, and maybe


1317
00:38:04,646 --> 00:38:05,686
your content's quite long.


1318
00:38:05,686 --> 00:38:07,506
It's a couple megabytes let's


1319
00:38:07,506 --> 00:38:07,726
say.


1320
00:38:09,066 --> 00:38:10,536
Traditionally with a socket, you


1321
00:38:10,536 --> 00:38:11,886
may try to read 10 bytes.


1322
00:38:12,706 --> 00:38:13,776
You may get 10 bytes, you may


1323
00:38:13,776 --> 00:38:14,336
get less.


1324
00:38:14,476 --> 00:38:15,426
You have to keep reading until


1325
00:38:15,426 --> 00:38:16,836
you get exactly 10 bytes to read


1326
00:38:16,836 --> 00:38:17,206
your header.


1327
00:38:18,096 --> 00:38:19,046
And then you have to read a


1328
00:38:19,206 --> 00:38:21,016
couple megabytes, and you'll


1329
00:38:21,016 --> 00:38:21,976
read some, and you'll get a


1330
00:38:21,976 --> 00:38:22,836
whole bunch of different read


1331
00:38:22,836 --> 00:38:24,076
calls and essentially go back


1332
00:38:24,076 --> 00:38:25,836
and forth between your app and


1333
00:38:25,836 --> 00:38:26,736
the stack.


1334
00:38:28,696 --> 00:38:30,686
With an NWConnection, when you


1335
00:38:30,686 --> 00:38:33,686
call receive, you provide the


1336
00:38:34,166 --> 00:38:35,316
minimum data that you want to


1337
00:38:35,316 --> 00:38:36,806
receive and the maximum data.


1338
00:38:37,676 --> 00:38:38,996
So you could actually specify if


1339
00:38:38,996 --> 00:38:40,426
you want to receive exactly 10


1340
00:38:40,426 --> 00:38:41,326
bytes because that's your


1341
00:38:41,326 --> 00:38:43,256
protocol, you can just say, I


1342
00:38:43,256 --> 00:38:44,646
want a minimum of 10 and a


1343
00:38:44,646 --> 00:38:45,406
maximum of 10.


1344
00:38:45,506 --> 00:38:46,736
Give me exactly 10 bytes.


1345
00:38:47,236 --> 00:38:48,646
And we will only call you back


1346
00:38:49,246 --> 00:38:50,686
when either there was an error


1347
00:38:50,946 --> 00:38:51,856
in reading on the connection


1348
00:38:51,856 --> 00:38:54,276
overall or we read exactly those


1349
00:38:54,276 --> 00:38:54,946
10 bytes.


1350
00:38:55,566 --> 00:38:57,806
Then you can easily just read


1351
00:38:57,806 --> 00:38:59,126
out whatever content you need


1352
00:38:59,126 --> 00:39:00,156
for your header, read out the


1353
00:39:00,156 --> 00:39:02,126
length, and then let's say you


1354
00:39:02,126 --> 00:39:04,526
want to read a couple megabytes,


1355
00:39:04,646 --> 00:39:05,906
and you essentially do the same


1356
00:39:05,906 --> 00:39:08,186
thing to read your body, and you


1357
00:39:08,186 --> 00:39:09,546
just pass, well I want to read


1358
00:39:09,546 --> 00:39:11,326
exactly this amount for my


1359
00:39:11,326 --> 00:39:12,486
connection, and this allows you


1360
00:39:12,486 --> 00:39:13,926
to not go back and forth between


1361
00:39:13,926 --> 00:39:15,576
the stack and your app but just


1362
00:39:15,576 --> 00:39:16,976
have a single callback of when


1363
00:39:17,056 --> 00:39:18,516
all of your data is ready to go.


1364
00:39:19,616 --> 00:39:21,216
So it's a really great way to


1365
00:39:21,256 --> 00:39:22,686
optimize the interactions.


1366
00:39:23,366 --> 00:39:25,856
Beyond sending and receiving,


1367
00:39:26,366 --> 00:39:27,776
there are a couple of advanced


1368
00:39:27,776 --> 00:39:28,696
options that I'd like to


1369
00:39:28,696 --> 00:39:30,916
highlight in your network


1370
00:39:30,916 --> 00:39:32,316
parameters that allow you to


1371
00:39:32,346 --> 00:39:34,216
configure your connection to get


1372
00:39:34,616 --> 00:39:37,056
very good startup time as well


1373
00:39:37,056 --> 00:39:38,876
as behavior on the network when


1374
00:39:38,876 --> 00:39:39,656
you're actually sending and


1375
00:39:39,656 --> 00:39:40,046
receiving.


1376
00:39:41,226 --> 00:39:42,746
So the first one is one that


1377
00:39:42,746 --> 00:39:43,986
we've talked about many times


1378
00:39:43,986 --> 00:39:46,236
here at WWDC, which is ECN.


1379
00:39:46,306 --> 00:39:48,136
This is explicit congestion


1380
00:39:48,136 --> 00:39:48,836
notification.


1381
00:39:50,086 --> 00:39:52,966
It gives you a way to smooth out


1382
00:39:52,966 --> 00:39:54,986
your connection by having the


1383
00:39:54,986 --> 00:39:57,856
network let the end host know


1384
00:39:58,176 --> 00:39:59,226
when there's congestion on the


1385
00:39:59,226 --> 00:40:00,796
network so we can pace things


1386
00:40:00,796 --> 00:40:01,406
out very well.


1387
00:40:02,676 --> 00:40:04,536
The great thing is that ECN is


1388
00:40:04,536 --> 00:40:06,076
enabled by default on all of


1389
00:40:06,076 --> 00:40:07,106
your TCP connections.


1390
00:40:07,516 --> 00:40:08,396
You don't have to do anything.


1391
00:40:09,446 --> 00:40:10,976
But it's been very difficult in


1392
00:40:10,976 --> 00:40:13,706
the past to use ECN with


1393
00:40:13,706 --> 00:40:14,946
UDP-based protocols.


1394
00:40:15,956 --> 00:40:16,946
And so I'd like to show you how


1395
00:40:16,946 --> 00:40:19,586
you can do that here.


1396
00:40:19,796 --> 00:40:20,816
The first thing you do is that


1397
00:40:20,816 --> 00:40:23,466
you create an ipMetadata object.


1398
00:40:23,746 --> 00:40:26,196
ECN is controlled by flags that


1399
00:40:26,196 --> 00:40:28,426
go in an IP packet, and so you


1400
00:40:28,426 --> 00:40:29,906
have this ipMmetadata object


1401
00:40:29,906 --> 00:40:31,396
that allows you to set various


1402
00:40:31,396 --> 00:40:34,456
flags on a per-packet basis, and


1403
00:40:34,456 --> 00:40:35,856
you can wrap this up into a


1404
00:40:35,856 --> 00:40:38,116
context object, which describes


1405
00:40:38,116 --> 00:40:39,236
all of the options for the


1406
00:40:39,236 --> 00:40:40,976
various protocols that you want


1407
00:40:40,976 --> 00:40:42,396
to associate with a single send


1408
00:40:43,066 --> 00:40:44,996
as well as the relative priority


1409
00:40:45,406 --> 00:40:46,856
of that particular message.


1410
00:40:48,196 --> 00:40:50,236
And then you use this context as


1411
00:40:50,236 --> 00:40:52,266
an extra parameter into the send


1412
00:40:52,266 --> 00:40:55,146
call besides just your content.


1413
00:40:55,996 --> 00:40:57,806
So now when you send this, any


1414
00:40:57,806 --> 00:40:58,636
packet that's going to be


1415
00:40:58,636 --> 00:41:00,656
generated by this content will


1416
00:41:00,656 --> 00:41:02,026
have all the flags that you


1417
00:41:02,026 --> 00:41:02,746
wanted marked.


1418
00:41:03,306 --> 00:41:04,126
So it's really easy.


1419
00:41:05,256 --> 00:41:07,146
And you can also get these same


1420
00:41:07,146 --> 00:41:08,526
flags whenever you're receiving


1421
00:41:08,956 --> 00:41:09,586
on a connection.


1422
00:41:09,586 --> 00:41:10,716
You'll have the same context


1423
00:41:10,716 --> 00:41:11,836
object associated with your


1424
00:41:11,836 --> 00:41:13,546
receives, and you'll be able to


1425
00:41:13,546 --> 00:41:15,426
read out the specific low-level


1426
00:41:15,496 --> 00:41:19,066
flags that you want to get out.


1427
00:41:19,346 --> 00:41:21,576
Similar, we have service class.


1428
00:41:22,426 --> 00:41:24,906
This is a property that is


1429
00:41:24,906 --> 00:41:26,956
available also in URLSession


1430
00:41:27,286 --> 00:41:28,476
that defines the relative


1431
00:41:28,526 --> 00:41:31,676
priority of your traffic, and


1432
00:41:31,676 --> 00:41:33,646
this affects the way that


1433
00:41:33,646 --> 00:41:34,956
traffic is queued on the local


1434
00:41:34,956 --> 00:41:36,886
interfaces when we're sending as


1435
00:41:36,886 --> 00:41:38,416
well as how the traffic works on


1436
00:41:38,416 --> 00:41:39,776
Cisco Fastlane networks.


1437
00:41:39,776 --> 00:41:43,216
So you can mark your service


1438
00:41:43,216 --> 00:41:44,916
class as a property on your


1439
00:41:44,916 --> 00:41:47,166
entire connection by using the


1440
00:41:47,166 --> 00:41:49,466
service class parameter in your


1441
00:41:49,466 --> 00:41:50,526
parameter's object.


1442
00:41:51,206 --> 00:41:53,516
In this case, we show how to use


1443
00:41:53,916 --> 00:41:55,256
the background service class,


1444
00:41:55,606 --> 00:41:57,196
and this is a great way to mark


1445
00:41:57,246 --> 00:41:58,936
that your connection is


1446
00:41:58,936 --> 00:41:59,976
relatively low priority.


1447
00:42:00,066 --> 00:42:01,336
We don't want it to get in the


1448
00:42:01,336 --> 00:42:03,456
way of user interactive data.


1449
00:42:04,066 --> 00:42:05,126
So we really encourage you if


1450
00:42:05,126 --> 00:42:06,506
you have background transfers,


1451
00:42:06,866 --> 00:42:08,256
mark them as a background


1452
00:42:08,256 --> 00:42:09,666
service class.


1453
00:42:10,476 --> 00:42:12,646
But you can also mark service


1454
00:42:12,646 --> 00:42:14,806
class on a per packet basis for


1455
00:42:14,806 --> 00:42:16,026
those UDP connections.


1456
00:42:16,996 --> 00:42:17,786
Let's say that you have a


1457
00:42:17,786 --> 00:42:19,886
connection in which you have


1458
00:42:20,006 --> 00:42:22,476
both voice and signaling data on


1459
00:42:22,476 --> 00:42:23,886
the same UDP flow.


1460
00:42:24,996 --> 00:42:26,526
In this case, you can create


1461
00:42:26,826 --> 00:42:28,666
that same IP metadata object


1462
00:42:28,666 --> 00:42:30,836
that we introduced before, mark


1463
00:42:30,836 --> 00:42:32,266
your service class now instead


1464
00:42:32,266 --> 00:42:34,846
of the ECN flags, attach it to a


1465
00:42:34,846 --> 00:42:36,206
context, and send it out.


1466
00:42:36,296 --> 00:42:37,476
And now you're marking the


1467
00:42:37,476 --> 00:42:39,526
priority on a per-packet basis.


1468
00:42:40,036 --> 00:42:43,866
The other way that you can


1469
00:42:43,866 --> 00:42:46,306
optimize your connections is to


1470
00:42:46,306 --> 00:42:47,746
reduce the number of round trips


1471
00:42:47,746 --> 00:42:49,226
that it takes to establish them.


1472
00:42:50,216 --> 00:42:51,396
So here I want to highlight two


1473
00:42:51,396 --> 00:42:52,316
approaches to do this.


1474
00:42:53,196 --> 00:42:55,376
One is enabling fast open on


1475
00:42:55,376 --> 00:42:56,046
your connections.


1476
00:42:56,756 --> 00:42:59,046
So TCP fast open allows you to


1477
00:42:59,166 --> 00:43:02,056
send initial data in the first


1478
00:43:02,196 --> 00:43:03,856
packet that TCP sends out, in


1479
00:43:03,856 --> 00:43:05,386
the SYN, so that you don't have


1480
00:43:05,386 --> 00:43:07,046
to wait for a whole handshake to


1481
00:43:07,046 --> 00:43:08,766
start sending your application


1482
00:43:09,406 --> 00:43:09,536
data.


1483
00:43:10,156 --> 00:43:11,976
Now in order to do this, you


1484
00:43:11,976 --> 00:43:13,546
need to enter into a contract


1485
00:43:13,546 --> 00:43:15,156
from your application with the


1486
00:43:15,156 --> 00:43:17,526
connection saying that you will


1487
00:43:17,526 --> 00:43:19,016
be providing this initial data


1488
00:43:19,016 --> 00:43:19,676
to send out.


1489
00:43:20,716 --> 00:43:22,076
So to enable this, you mark


1490
00:43:22,236 --> 00:43:23,576
allow fast open on your


1491
00:43:23,576 --> 00:43:24,286
parameters.


1492
00:43:24,996 --> 00:43:26,426
You then create your connection,


1493
00:43:27,436 --> 00:43:28,806
and then before you can call


1494
00:43:28,806 --> 00:43:30,796
start, you can actually call


1495
00:43:30,856 --> 00:43:32,806
send and get your initial data


1496
00:43:33,056 --> 00:43:33,676
sent out.


1497
00:43:33,856 --> 00:43:36,536
Now I want to point out here


1498
00:43:36,536 --> 00:43:38,116
that the completion handler here


1499
00:43:38,226 --> 00:43:39,816
is replaced by a marker that


1500
00:43:39,816 --> 00:43:41,886
this data is item potent, and


1501
00:43:41,886 --> 00:43:43,226
item potent means that the data


1502
00:43:43,226 --> 00:43:44,896
is safe to be replayed because


1503
00:43:44,896 --> 00:43:46,966
initial data may get resent over


1504
00:43:46,966 --> 00:43:48,256
the network, and so you don't


1505
00:43:48,256 --> 00:43:49,756
want it to have side effects if


1506
00:43:49,756 --> 00:43:51,086
it gets resent.


1507
00:43:52,776 --> 00:43:55,266
Then, you simply call start, and


1508
00:43:55,266 --> 00:43:56,656
as we're doing the connection


1509
00:43:56,656 --> 00:43:58,106
bring up, all the attempts that


1510
00:43:58,106 --> 00:43:59,916
we mentioned before, we will use


1511
00:43:59,916 --> 00:44:01,826
that initial data if we can to


1512
00:44:01,826 --> 00:44:04,226
send in TCP Fast Open.


1513
00:44:04,936 --> 00:44:06,696
There is one other way I want to


1514
00:44:06,696 --> 00:44:08,816
point out to use TCP Fast Open


1515
00:44:09,166 --> 00:44:10,636
that doesn't require your


1516
00:44:10,636 --> 00:44:12,146
application to send it's own


1517
00:44:12,926 --> 00:44:13,056
data.


1518
00:44:14,416 --> 00:44:16,666
If you're using TLS on top of


1519
00:44:16,696 --> 00:44:19,926
TCP, the first message from TLS,


1520
00:44:20,096 --> 00:44:21,716
the client hello, can actually


1521
00:44:21,716 --> 00:44:24,216
be used as the TCP Fast Open


1522
00:44:24,286 --> 00:44:24,926
initial data.


1523
00:44:25,946 --> 00:44:27,376
If you want to just enable this


1524
00:44:27,376 --> 00:44:29,316
and not provide your own Fast


1525
00:44:29,316 --> 00:44:32,226
Open data, simply go into the


1526
00:44:32,226 --> 00:44:34,846
TCP-specific options and mark


1527
00:44:34,846 --> 00:44:35,896
that you want to enable Fast


1528
00:44:35,896 --> 00:44:37,766
Open there, and it will


1529
00:44:37,866 --> 00:44:39,886
automatically grab the first


1530
00:44:39,886 --> 00:44:41,706
message from TLS to send out


1531
00:44:41,866 --> 00:44:43,086
during connection establishment.


1532
00:44:46,816 --> 00:44:47,896
There's another thing that you


1533
00:44:47,896 --> 00:44:49,456
can do to optimize your


1534
00:44:49,456 --> 00:44:50,586
connection establishment and


1535
00:44:50,586 --> 00:44:52,356
save a roundtrip, and this is


1536
00:44:52,356 --> 00:44:53,816
something that Stuart mentioned


1537
00:44:53,916 --> 00:44:55,876
in the previous session, which


1538
00:44:55,876 --> 00:44:57,626
we're calling Optimistic DNS.


1539
00:44:58,736 --> 00:45:00,256
This allows you to use


1540
00:45:00,626 --> 00:45:02,766
previously expired DNS answers


1541
00:45:02,996 --> 00:45:04,136
that may have had a very short


1542
00:45:04,136 --> 00:45:07,616
time to live, and try connecting


1543
00:45:07,616 --> 00:45:10,296
to them while we do a new DNS


1544
00:45:10,936 --> 00:45:12,506
query in parallel.


1545
00:45:13,716 --> 00:45:16,236
So if the addresses that you had


1546
00:45:16,236 --> 00:45:18,876
previously received that did


1547
00:45:18,876 --> 00:45:21,346
expire are still valid, and you


1548
00:45:21,346 --> 00:45:23,486
mark the expired DNS behavior to


1549
00:45:23,486 --> 00:45:24,196
be allow.


1550
00:45:24,696 --> 00:45:26,506
When you call start, we'll try


1551
00:45:26,506 --> 00:45:27,646
connecting to those addresses


1552
00:45:27,646 --> 00:45:29,626
first and not have to wait for


1553
00:45:29,626 --> 00:45:31,116
the new DNS query to finish.


1554
00:45:31,506 --> 00:45:33,006
This can shave off a lot of


1555
00:45:33,006 --> 00:45:34,456
set-up time from your


1556
00:45:34,456 --> 00:45:37,226
connection, but if your server


1557
00:45:37,226 --> 00:45:39,176
has indeed moved addresses,


1558
00:45:39,636 --> 00:45:40,896
because we're trying multiple


1559
00:45:40,896 --> 00:45:43,156
different connection options, if


1560
00:45:43,156 --> 00:45:44,736
that first one doesn't work, we


1561
00:45:44,736 --> 00:45:47,006
will gracefully wait for the new


1562
00:45:47,006 --> 00:45:48,986
DNS query to come back and try


1563
00:45:48,986 --> 00:45:50,456
those addresses as well.


1564
00:45:51,396 --> 00:45:52,746
So this is a very simple way


1565
00:45:53,006 --> 00:45:54,266
that if it's appropriate for


1566
00:45:54,266 --> 00:45:56,266
your server configuration, you


1567
00:45:56,266 --> 00:45:57,986
can get a much faster connection


1568
00:45:57,986 --> 00:45:58,556
establishment.


1569
00:46:01,756 --> 00:46:03,376
The next area I want to talk


1570
00:46:03,376 --> 00:46:04,516
about for performance is


1571
00:46:04,516 --> 00:46:05,486
something that you don't


1572
00:46:05,536 --> 00:46:06,896
actually need to do anything in


1573
00:46:06,896 --> 00:46:07,676
your app to get.


1574
00:46:08,206 --> 00:46:09,266
This is something that you get


1575
00:46:09,266 --> 00:46:11,176
totally for free whenever you


1576
00:46:11,656 --> 00:46:13,226
use URLSession or


1577
00:46:13,226 --> 00:46:14,486
Network.framework connections,


1578
00:46:14,846 --> 00:46:16,446
and this is user-space


1579
00:46:16,506 --> 00:46:17,006
networking.


1580
00:46:17,726 --> 00:46:18,626
So this is something that we


1581
00:46:18,626 --> 00:46:20,456
introduced last year here at


1582
00:46:20,456 --> 00:46:23,986
WWDC, and it's enabled on iOS


1583
00:46:23,986 --> 00:46:24,646
and tvOS.


1584
00:46:24,886 --> 00:46:27,446
This is where we're avoiding the


1585
00:46:27,446 --> 00:46:28,966
socket layer entirely, and we've


1586
00:46:28,966 --> 00:46:31,196
moved the transport stack into


1587
00:46:31,196 --> 00:46:32,396
your app.


1588
00:46:32,546 --> 00:46:33,656
So to give you an idea of what


1589
00:46:33,656 --> 00:46:35,646
this is doing, I want to start


1590
00:46:35,646 --> 00:46:37,136
with what the legacy model of


1591
00:46:37,136 --> 00:46:39,166
the stack generally is.


1592
00:46:39,876 --> 00:46:40,836
So let's say that you're


1593
00:46:40,836 --> 00:46:42,226
receiving a packet off the


1594
00:46:42,226 --> 00:46:42,546
network.


1595
00:46:42,896 --> 00:46:44,226
It's the WiFi interface.


1596
00:46:44,906 --> 00:46:45,896
That packet will come into the


1597
00:46:45,896 --> 00:46:48,806
driver, will be sent into the


1598
00:46:48,806 --> 00:46:50,926
TCP receive buffer within the


1599
00:46:50,926 --> 00:46:53,546
kernel, and then when your


1600
00:46:53,546 --> 00:46:55,476
application reads on a socket,


1601
00:46:56,206 --> 00:46:57,196
that's going to do a context


1602
00:46:57,196 --> 00:46:59,106
switch and copy the data up from


1603
00:46:59,106 --> 00:47:01,636
the kernel into your app, and


1604
00:47:01,636 --> 00:47:02,786
then generally if you're doing


1605
00:47:02,786 --> 00:47:04,476
TLS, it will have to get another


1606
00:47:04,476 --> 00:47:05,876
transformation to decrypt that


1607
00:47:05,906 --> 00:47:07,376
data before you can actually


1608
00:47:07,376 --> 00:47:08,776
send it up to the application.


1609
00:47:09,366 --> 00:47:12,286
So how does this look when we do


1610
00:47:12,376 --> 00:47:13,306
user space networking?


1611
00:47:13,926 --> 00:47:17,646
So as you can see, the main


1612
00:47:17,646 --> 00:47:19,186
change is that we've moved the


1613
00:47:19,186 --> 00:47:21,836
transport stack, TCP and UDP, up


1614
00:47:21,836 --> 00:47:22,466
into your app.


1615
00:47:23,026 --> 00:47:24,146
So what does this give us?


1616
00:47:25,056 --> 00:47:26,626
Now, when a packet comes in off


1617
00:47:26,626 --> 00:47:27,956
the network, comes into the


1618
00:47:27,956 --> 00:47:29,846
driver like before, but we move


1619
00:47:29,846 --> 00:47:31,736
it into a memory mapped region


1620
00:47:32,236 --> 00:47:33,726
that your application


1621
00:47:34,436 --> 00:47:36,196
automatically can scoop packets


1622
00:47:36,196 --> 00:47:38,096
out of without doing a copy,


1623
00:47:38,176 --> 00:47:39,416
without doing extra contexts


1624
00:47:39,416 --> 00:47:41,206
switch, and start processing the


1625
00:47:41,206 --> 00:47:42,296
packets automatically.


1626
00:47:42,816 --> 00:47:44,146
This way the only transformation


1627
00:47:44,146 --> 00:47:45,846
we're doing is the decryption


1628
00:47:45,846 --> 00:47:47,606
that we have to do anyway for


1629
00:47:48,346 --> 00:47:48,466
TLS.


1630
00:47:49,176 --> 00:47:50,886
This really can reduce the


1631
00:47:50,886 --> 00:47:53,046
amount of CPU time that it takes


1632
00:47:53,116 --> 00:47:54,506
to send and receive packets,


1633
00:47:55,096 --> 00:47:56,636
especially for protocols like


1634
00:47:56,636 --> 00:47:58,296
UDP in which you're going to be


1635
00:47:58,296 --> 00:47:59,586
sending a lot of packets back


1636
00:47:59,586 --> 00:48:01,046
and forth directly from your


1637
00:48:01,046 --> 00:48:01,666
application.


1638
00:48:02,286 --> 00:48:04,456
So to show how this works and


1639
00:48:04,456 --> 00:48:05,996
the effect it can have, I want


1640
00:48:05,996 --> 00:48:08,906
to show you a video that was


1641
00:48:08,906 --> 00:48:11,166
taken using the same app that


1642
00:48:11,166 --> 00:48:12,966
Eric showed you earlier to


1643
00:48:12,966 --> 00:48:14,816
demonstrate UDP performance with


1644
00:48:14,816 --> 00:48:15,816
user space networking.


1645
00:48:16,076 --> 00:48:18,876
So in this example, we're going


1646
00:48:18,876 --> 00:48:20,206
to have two videos running


1647
00:48:20,206 --> 00:48:21,126
simultaneously.


1648
00:48:21,676 --> 00:48:25,386
The device on the left is


1649
00:48:25,386 --> 00:48:28,866
receiving a video stream from an


1650
00:48:28,866 --> 00:48:30,066
application that was written


1651
00:48:30,066 --> 00:48:30,976
using sockets.


1652
00:48:32,186 --> 00:48:33,656
And the device on the right is


1653
00:48:33,656 --> 00:48:35,006
going to be receiving exactly


1654
00:48:35,006 --> 00:48:37,696
the same video stream from a


1655
00:48:37,696 --> 00:48:40,576
device that has an app written


1656
00:48:40,576 --> 00:48:42,176
using Network.framework so it


1657
00:48:42,176 --> 00:48:43,626
can take advantage of the user


1658
00:48:43,626 --> 00:48:44,906
space networking stack.


1659
00:48:45,456 --> 00:48:47,716
And in this case, we're


1660
00:48:47,716 --> 00:48:48,596
streaming the video.


1661
00:48:49,026 --> 00:48:50,756
It's just raw frames.


1662
00:48:50,756 --> 00:48:51,436
It's not compressed.


1663
00:48:51,496 --> 00:48:52,526
It's not great quality or


1664
00:48:52,526 --> 00:48:53,606
anything, but there's a lot of


1665
00:48:53,606 --> 00:48:54,536
packets going back and forth.


1666
00:48:55,746 --> 00:48:57,126
And we chose specifically for


1667
00:48:57,126 --> 00:49:00,596
this demonstration to not lower


1668
00:49:00,596 --> 00:49:01,546
the quality when we hit


1669
00:49:01,576 --> 00:49:03,106
contention or when we couldn't


1670
00:49:03,146 --> 00:49:04,786
send packets fast enough or to


1671
00:49:04,786 --> 00:49:06,526
not drop anything but just to


1672
00:49:06,526 --> 00:49:07,676
slow down if we had to.


1673
00:49:08,236 --> 00:49:09,116
Now this is probably not what


1674
00:49:09,116 --> 00:49:10,226
your app would do in real life,


1675
00:49:10,226 --> 00:49:11,906
but it highlights exactly the


1676
00:49:11,906 --> 00:49:13,916
difference in the performance


1677
00:49:13,916 --> 00:49:15,536
between these two stacks.


1678
00:49:16,156 --> 00:49:16,936
So let's see it right now.


1679
00:49:22,046 --> 00:49:23,176
So there's exactly the same


1680
00:49:23,176 --> 00:49:25,466
data, exactly the same frames


1681
00:49:25,466 --> 00:49:26,666
being sent over as fast as they


1682
00:49:26,666 --> 00:49:28,656
possibly can, across this


1683
00:49:28,656 --> 00:49:32,446
network, and we see the one on


1684
00:49:32,446 --> 00:49:33,836
the right is pretty easily


1685
00:49:33,836 --> 00:49:35,176
outstripping the one on the


1686
00:49:35,516 --> 00:49:35,646
left.


1687
00:49:36,766 --> 00:49:38,436
And in fact, if you look at the


1688
00:49:38,436 --> 00:49:40,306
difference, it's 30 percent less


1689
00:49:40,306 --> 00:49:41,776
overhead that we're viewing on


1690
00:49:41,776 --> 00:49:43,066
the receiver side only.


1691
00:49:44,236 --> 00:49:45,616
And this is due to the huge


1692
00:49:45,616 --> 00:49:47,806
difference that we see in the


1693
00:49:47,806 --> 00:49:50,016
CPU percentage that it takes to


1694
00:49:50,016 --> 00:49:51,746
send and receive UDP packets


1695
00:49:52,336 --> 00:49:53,536
when you compare sockets and


1696
00:49:53,536 --> 00:49:54,496
user space networking.


1697
00:49:55,186 --> 00:49:56,306
Now, of course this is just one


1698
00:49:56,306 --> 00:49:56,746
example.


1699
00:49:56,836 --> 00:49:58,396
This is not going to be what


1700
00:49:58,586 --> 00:49:59,666
every app is going to be like,


1701
00:49:59,666 --> 00:50:00,276
because you're going to be


1702
00:50:00,276 --> 00:50:01,606
compressing differently.


1703
00:50:01,606 --> 00:50:02,566
You're going to be already


1704
00:50:02,566 --> 00:50:03,576
trying to make your connections


1705
00:50:03,576 --> 00:50:04,236
more efficient.


1706
00:50:05,196 --> 00:50:06,966
But if you have an app that's


1707
00:50:06,966 --> 00:50:08,426
generating live data, especially


1708
00:50:08,426 --> 00:50:10,336
if you're using UDP to send and


1709
00:50:10,336 --> 00:50:11,896
receive a lot of packets, I


1710
00:50:11,956 --> 00:50:13,706
invite you to try using


1711
00:50:13,706 --> 00:50:15,026
Network.framework within your


1712
00:50:15,026 --> 00:50:16,466
app and run it through


1713
00:50:16,466 --> 00:50:17,086
instruments.


1714
00:50:17,636 --> 00:50:19,096
Measure the difference in CPU


1715
00:50:19,096 --> 00:50:21,026
usage that you have when you're


1716
00:50:21,026 --> 00:50:22,256
using Network.framework versus


1717
00:50:22,256 --> 00:50:23,746
sockets, and I think you'll be


1718
00:50:23,746 --> 00:50:24,796
really happy with what you see.


1719
00:50:30,336 --> 00:50:31,986
So the last topic we want to


1720
00:50:31,986 --> 00:50:34,156
talk about today is how we can


1721
00:50:34,226 --> 00:50:35,416
solve the problems around


1722
00:50:35,416 --> 00:50:37,256
network mobility, and this is a


1723
00:50:37,256 --> 00:50:38,606
key area that we're trying to


1724
00:50:38,606 --> 00:50:41,416
solve with Network.framework.


1725
00:50:42,166 --> 00:50:45,566
And the first step of this is


1726
00:50:45,566 --> 00:50:46,816
just making sure that we start


1727
00:50:46,816 --> 00:50:47,786
connections gracefully.


1728
00:50:48,816 --> 00:50:49,746
So we already mentioned this,


1729
00:50:49,746 --> 00:50:50,686
but I want to recap a little


1730
00:50:50,686 --> 00:50:50,906
bit.


1731
00:50:51,836 --> 00:50:54,146
The waiting state is the key


1732
00:50:54,206 --> 00:50:55,776
thing to handle network


1733
00:50:55,776 --> 00:50:58,326
transitions when your connection


1734
00:50:58,326 --> 00:50:59,126
is first coming up.


1735
00:50:59,726 --> 00:51:00,836
It will indicate that there's a


1736
00:51:00,836 --> 00:51:02,436
lack of connectivity or the


1737
00:51:02,476 --> 00:51:04,166
connectivity changed while you


1738
00:51:04,166 --> 00:51:05,486
were in the middle of doing DNS


1739
00:51:05,636 --> 00:51:06,096
or TCP.


1740
00:51:06,096 --> 00:51:08,996
We really encourage you please


1741
00:51:08,996 --> 00:51:11,106
avoid using APIs like


1742
00:51:11,206 --> 00:51:13,426
reachability to check the


1743
00:51:13,426 --> 00:51:14,496
network state before you


1744
00:51:14,496 --> 00:51:15,466
establish your connection.


1745
00:51:16,306 --> 00:51:17,306
That will lead to race


1746
00:51:17,376 --> 00:51:19,016
conditions and may not provide


1747
00:51:19,016 --> 00:51:20,126
an accurate picture of what's


1748
00:51:20,126 --> 00:51:21,566
actually happening in the


1749
00:51:21,566 --> 00:51:21,996
connection.


1750
00:51:22,536 --> 00:51:25,066
And if you need to make sure


1751
00:51:25,066 --> 00:51:26,396
that your connection does not


1752
00:51:26,396 --> 00:51:27,966
establish over a cellular


1753
00:51:27,966 --> 00:51:31,516
network, don't check up front is


1754
00:51:31,516 --> 00:51:32,516
the device currently on a


1755
00:51:32,516 --> 00:51:33,976
cellular network, because that


1756
00:51:33,976 --> 00:51:34,716
could change.


1757
00:51:35,486 --> 00:51:36,846
Simply restrict the interface


1758
00:51:36,846 --> 00:51:38,716
types that you want to use using


1759
00:51:38,716 --> 00:51:40,046
the NWParameters.


1760
00:51:41,266 --> 00:51:42,316
So once you've started your


1761
00:51:42,316 --> 00:51:44,006
connection and you're in the


1762
00:51:44,006 --> 00:51:45,506
ready state, there are a series


1763
00:51:45,506 --> 00:51:47,006
of events that we will give you


1764
00:51:47,476 --> 00:51:49,176
to let you know when the network


1765
00:51:49,176 --> 00:51:49,976
has changed.


1766
00:51:51,336 --> 00:51:53,006
The first one is called


1767
00:51:53,006 --> 00:51:54,236
connection viability.


1768
00:51:55,586 --> 00:51:58,186
So viability means that your


1769
00:51:58,186 --> 00:51:59,646
connection is able to send and


1770
00:51:59,646 --> 00:52:02,306
receive data out the interface


1771
00:52:02,306 --> 00:52:04,206
it has a valid route.


1772
00:52:04,996 --> 00:52:06,896
So to give a demonstration of


1773
00:52:06,896 --> 00:52:08,526
this, let's say that you started


1774
00:52:08,526 --> 00:52:10,266
your connection when the device


1775
00:52:10,406 --> 00:52:11,806
was associated with a WiFi


1776
00:52:11,806 --> 00:52:12,176
network.


1777
00:52:13,456 --> 00:52:16,266
Then, your user walks into the


1778
00:52:16,266 --> 00:52:17,796
elevator, they don't have a


1779
00:52:17,796 --> 00:52:18,506
signal anymore.


1780
00:52:19,216 --> 00:52:20,686
At this point, we will give you


1781
00:52:20,686 --> 00:52:23,176
an event, letting you know that


1782
00:52:23,176 --> 00:52:24,476
your connection is no longer


1783
00:52:24,476 --> 00:52:24,906
viable.


1784
00:52:25,826 --> 00:52:27,086
So what should you do at this


1785
00:52:27,086 --> 00:52:27,356
point?


1786
00:52:28,006 --> 00:52:29,666
Two things.


1787
00:52:30,466 --> 00:52:31,486
We recommend that if it's


1788
00:52:31,486 --> 00:52:32,876
appropriate for your app, you


1789
00:52:32,876 --> 00:52:34,246
can let the user know that they


1790
00:52:34,296 --> 00:52:35,736
currently have no connectivity.


1791
00:52:36,306 --> 00:52:37,436
If they're trying to send and


1792
00:52:37,436 --> 00:52:38,976
receive data, it's not going to


1793
00:52:38,976 --> 00:52:39,726
work right now.


1794
00:52:41,176 --> 00:52:43,156
But, don't necessarily tear down


1795
00:52:43,156 --> 00:52:43,776
your connection.


1796
00:52:44,706 --> 00:52:46,106
At this point, you don't have


1797
00:52:46,106 --> 00:52:47,176
any better interface that you


1798
00:52:47,176 --> 00:52:49,696
could use anyway, and that first


1799
00:52:49,696 --> 00:52:51,086
WiFi interface may come back.


1800
00:52:51,936 --> 00:52:53,466
Oftentimes, if you walk back out


1801
00:52:53,466 --> 00:52:54,616
of an elevator onto the same


1802
00:52:54,616 --> 00:52:56,206
WiFi network, your connection


1803
00:52:56,206 --> 00:52:57,596
can resume right where you left


1804
00:52:57,596 --> 00:52:57,796
off.


1805
00:52:58,466 --> 00:53:01,686
So the other event that we give


1806
00:53:01,686 --> 00:53:03,276
you is the better path


1807
00:53:03,556 --> 00:53:04,296
notification.


1808
00:53:05,596 --> 00:53:07,276
So let's take that same scenario


1809
00:53:07,626 --> 00:53:08,886
in which you connected over the


1810
00:53:08,886 --> 00:53:09,586
WiFi network.


1811
00:53:10,796 --> 00:53:12,296
You walk out of a building let's


1812
00:53:12,296 --> 00:53:14,106
say, and now you no longer have


1813
00:53:14,106 --> 00:53:15,286
WiFi, but you do have the


1814
00:53:15,286 --> 00:53:16,636
cellular network available to


1815
00:53:16,636 --> 00:53:16,776
you.


1816
00:53:17,526 --> 00:53:18,556
At this point, we'll let you


1817
00:53:18,556 --> 00:53:19,136
know two things.


1818
00:53:20,146 --> 00:53:21,606
First, that your connection is


1819
00:53:21,606 --> 00:53:23,456
not viable like before, but


1820
00:53:23,716 --> 00:53:25,136
we'll also let you know that


1821
00:53:25,136 --> 00:53:26,306
there is now a better path


1822
00:53:26,586 --> 00:53:27,126
available.


1823
00:53:27,526 --> 00:53:29,236
If you connected again, you


1824
00:53:29,236 --> 00:53:30,036
would be able to use the


1825
00:53:30,036 --> 00:53:30,896
cellular network.


1826
00:53:31,346 --> 00:53:35,616
And the advice here is to, if


1827
00:53:35,616 --> 00:53:36,496
it's appropriate for your


1828
00:53:36,496 --> 00:53:38,756
connection, attempt to migrate


1829
00:53:38,876 --> 00:53:40,156
to a new connection, if you can


1830
00:53:40,156 --> 00:53:42,036
resume the work that you were


1831
00:53:42,606 --> 00:53:43,956
doing before.


1832
00:53:44,126 --> 00:53:45,976
But only close the original


1833
00:53:45,976 --> 00:53:47,216
connection once that new


1834
00:53:47,216 --> 00:53:48,276
connection is fully ready.


1835
00:53:48,756 --> 00:53:50,386
Again, the WiFi network may come


1836
00:53:50,386 --> 00:53:52,886
back, or the connection over


1837
00:53:52,886 --> 00:53:54,146
cellular may fail.


1838
00:53:54,806 --> 00:53:57,386
And the last case I want to


1839
00:53:57,386 --> 00:53:59,736
highlight here is a case in


1840
00:53:59,736 --> 00:54:01,646
which you connect initially over


1841
00:54:01,646 --> 00:54:02,856
the cellular network, and then


1842
00:54:02,856 --> 00:54:04,496
the user walks into a building


1843
00:54:04,736 --> 00:54:06,246
and now they have WiFi access.


1844
00:54:07,126 --> 00:54:08,356
In this case, your connection,


1845
00:54:08,596 --> 00:54:09,706
the original one, is totally


1846
00:54:09,706 --> 00:54:10,076
fine.


1847
00:54:10,166 --> 00:54:12,106
You're still viable, but you now


1848
00:54:12,106 --> 00:54:13,256
also have a better path


1849
00:54:13,256 --> 00:54:13,736
available.


1850
00:54:14,296 --> 00:54:17,706
In this case, again, if you can


1851
00:54:17,706 --> 00:54:19,216
migrate your connection, this is


1852
00:54:19,216 --> 00:54:20,826
probably a good time to try to


1853
00:54:21,216 --> 00:54:23,046
establish a new connection and


1854
00:54:23,046 --> 00:54:23,906
move your data over.


1855
00:54:24,536 --> 00:54:26,326
That will save the user their


1856
00:54:26,926 --> 00:54:28,316
data bill.


1857
00:54:28,526 --> 00:54:30,386
But, continue to use the


1858
00:54:30,386 --> 00:54:31,876
original connection until you


1859
00:54:31,876 --> 00:54:32,636
have the new one fully


1860
00:54:32,636 --> 00:54:33,216
established.


1861
00:54:34,276 --> 00:54:35,496
Just to show how this looks in


1862
00:54:35,496 --> 00:54:37,896
code, we have the viability


1863
00:54:37,896 --> 00:54:39,286
update handler that you can set


1864
00:54:39,286 --> 00:54:40,366
in your connection, we'll give


1865
00:54:40,366 --> 00:54:41,426
you a boolean back to let you


1866
00:54:41,426 --> 00:54:42,776
know whenever you're viable or


1867
00:54:42,776 --> 00:54:45,866
not, and a better path update


1868
00:54:45,866 --> 00:54:47,006
handler to let you know when


1869
00:54:47,006 --> 00:54:48,796
there's a better path available


1870
00:54:49,176 --> 00:54:49,976
or is no longer available.


1871
00:54:53,236 --> 00:54:55,486
And now the better solution to


1872
00:54:55,546 --> 00:54:56,806
all of this to handle network


1873
00:54:56,836 --> 00:54:58,296
mobility is something that we've


1874
00:54:58,296 --> 00:54:59,816
talked about in previous years,


1875
00:55:00,256 --> 00:55:02,306
which is multipath connections,


1876
00:55:02,336 --> 00:55:03,386
Multipath TCP.


1877
00:55:04,236 --> 00:55:05,956
So if you were able to on your


1878
00:55:05,956 --> 00:55:07,636
server enable Multipath TCP and


1879
00:55:07,636 --> 00:55:10,446
you can enable it on the client


1880
00:55:10,446 --> 00:55:11,236
side with the


1881
00:55:11,236 --> 00:55:13,136
multipathServiceType in your


1882
00:55:13,136 --> 00:55:15,166
parameters, then your connection


1883
00:55:15,166 --> 00:55:16,686
will automatically migrate


1884
00:55:16,896 --> 00:55:18,226
between networks as they come


1885
00:55:18,226 --> 00:55:18,606
and go.


1886
00:55:19,096 --> 00:55:20,606
It's a great seamless experience


1887
00:55:20,606 --> 00:55:22,556
that doesn't require any work in


1888
00:55:22,556 --> 00:55:23,676
your application to handle.


1889
00:55:24,616 --> 00:55:26,106
And this is also the same


1890
00:55:26,106 --> 00:55:27,866
service type that's available in


1891
00:55:27,866 --> 00:55:28,676
URLSession.


1892
00:55:29,296 --> 00:55:31,716
A couple points I want to


1893
00:55:31,716 --> 00:55:33,926
highlight here, specific to


1894
00:55:33,926 --> 00:55:34,646
Network.framework.


1895
00:55:35,686 --> 00:55:37,196
If you restrict the interface


1896
00:55:37,196 --> 00:55:38,676
types that you allow to be used


1897
00:55:39,266 --> 00:55:41,296
with your NWParameters that will


1898
00:55:41,296 --> 00:55:43,766
apply to MPTCP, so you can still


1899
00:55:43,896 --> 00:55:45,696
not want to use the cellular


1900
00:55:45,696 --> 00:55:46,726
network with a multipath


1901
00:55:46,756 --> 00:55:48,776
connection, and instead we'll


1902
00:55:48,776 --> 00:55:50,356
just seamlessly migrate between


1903
00:55:50,356 --> 00:55:51,596
different WiFi networks as they


1904
00:55:51,596 --> 00:55:52,326
become available.


1905
00:55:54,496 --> 00:55:56,586
Also, the connection viability


1906
00:55:56,586 --> 00:55:57,986
handler that I mentioned before


1907
00:55:58,496 --> 00:55:59,346
is slightly different from


1908
00:55:59,346 --> 00:56:01,756
Multipath TCP because whenever


1909
00:56:01,756 --> 00:56:02,856
we change a network, we'll


1910
00:56:02,856 --> 00:56:05,136
automatically move for you, your


1911
00:56:05,196 --> 00:56:06,686
connection is only not viable


1912
00:56:06,686 --> 00:56:07,966
when you have no network


1913
00:56:07,966 --> 00:56:13,176
available to you at all.


1914
00:56:13,396 --> 00:56:15,856
So between waiting for


1915
00:56:15,856 --> 00:56:19,056
connectivity, viability, better


1916
00:56:19,566 --> 00:56:21,956
path, MPTCP, we really hope that


1917
00:56:22,026 --> 00:56:23,356
all of the use cases in your


1918
00:56:23,356 --> 00:56:25,996
apps for using tools like SC


1919
00:56:25,996 --> 00:56:27,836
Network Reachability to check


1920
00:56:28,196 --> 00:56:30,096
network changes manually have


1921
00:56:30,136 --> 00:56:30,886
been replaced.


1922
00:56:31,626 --> 00:56:33,606
However, we do recognize that


1923
00:56:33,606 --> 00:56:35,386
there are some scenarios in


1924
00:56:35,386 --> 00:56:36,656
which you still want to know


1925
00:56:37,156 --> 00:56:38,266
what's the available network,


1926
00:56:38,366 --> 00:56:39,406
when does it change.


1927
00:56:40,796 --> 00:56:42,146
For that Network.framework


1928
00:56:42,206 --> 00:56:44,766
offers a new API called the


1929
00:56:44,766 --> 00:56:46,346
NWPathMonitor.


1930
00:56:47,776 --> 00:56:50,136
So the Path Monitor instead of


1931
00:56:50,136 --> 00:56:51,676
watching the reachability and


1932
00:56:51,676 --> 00:56:52,396
trying to predict the


1933
00:56:52,396 --> 00:56:53,996
reachability of a given host


1934
00:56:54,506 --> 00:56:55,786
simply lets you know what is the


1935
00:56:55,786 --> 00:56:57,326
current state of the interfaces


1936
00:56:57,746 --> 00:56:59,226
on your device and when do they


1937
00:56:59,226 --> 00:56:59,766
change.


1938
00:57:01,156 --> 00:57:02,946
It allows you to iterate all of


1939
00:57:02,946 --> 00:57:04,886
the interfaces that you can


1940
00:57:04,886 --> 00:57:06,616
connect over in case you want to


1941
00:57:06,646 --> 00:57:07,926
make a connection over each one,


1942
00:57:08,846 --> 00:57:10,156
and it will let you know


1943
00:57:10,156 --> 00:57:11,766
whenever those networks do


1944
00:57:11,766 --> 00:57:12,196
change.


1945
00:57:13,196 --> 00:57:14,606
So this can be very useful if


1946
00:57:14,606 --> 00:57:16,226
you want to update your UI to


1947
00:57:16,226 --> 00:57:17,956
let the user know, are they


1948
00:57:17,956 --> 00:57:18,726
connected at all.


1949
00:57:18,726 --> 00:57:21,396
And as Stuart mentioned in the


1950
00:57:21,396 --> 00:57:22,976
previous session, there could be


1951
00:57:22,976 --> 00:57:25,676
scenarios in which the user has


1952
00:57:25,676 --> 00:57:27,026
a long form to fill out and they


1953
00:57:27,026 --> 00:57:28,756
don't necessarily want to go and


1954
00:57:28,816 --> 00:57:29,926
fill out something just to


1955
00:57:29,926 --> 00:57:30,676
realize that there's no


1956
00:57:30,676 --> 00:57:31,766
connectivity anyway.


1957
00:57:32,806 --> 00:57:34,696
So use Network Path Monitor in


1958
00:57:34,696 --> 00:57:36,886
any of these scenarios in which


1959
00:57:37,116 --> 00:57:38,506
just having a waiting connection


1960
00:57:38,566 --> 00:57:39,376
is not enough.


1961
00:57:39,986 --> 00:57:41,126
So between all of these things,


1962
00:57:41,126 --> 00:57:42,226
we'd really like to see people


1963
00:57:42,226 --> 00:57:44,956
move off of reachability and


1964
00:57:44,956 --> 00:57:46,936
handle network transitions more


1965
00:57:46,936 --> 00:57:48,316
gracefully than ever before.


1966
00:57:48,926 --> 00:57:52,036
So with that, I'd like to invite


1967
00:57:52,086 --> 00:57:53,546
Josh back up to the state to let


1968
00:57:53,546 --> 00:57:54,396
you know how you can get


1969
00:57:54,396 --> 00:57:56,116
involved and start adopting


1970
00:57:56,116 --> 00:57:56,736
Network.framework.


1971
00:57:57,516 --> 00:58:01,636
[ Applause ]


1972
00:58:02,136 --> 00:58:03,126
>> Thank you, Tommy.


1973
00:58:03,916 --> 00:58:05,416
So I've got a great new API for


1974
00:58:05,566 --> 00:58:06,996
you that we think you're going


1975
00:58:06,996 --> 00:58:07,316
to love.


1976
00:58:08,346 --> 00:58:09,156
We'd like to talk about the


1977
00:58:09,156 --> 00:58:10,416
things that you can do to start


1978
00:58:10,416 --> 00:58:12,206
using it today, but first I want


1979
00:58:12,206 --> 00:58:13,276
to talk about a few things that


1980
00:58:13,276 --> 00:58:14,886
we'd like you to stop doing so


1981
00:58:14,886 --> 00:58:16,166
we can really take advantage of


1982
00:58:16,166 --> 00:58:17,376
the new technologies like user


1983
00:58:17,376 --> 00:58:18,216
space networking.


1984
00:58:19,796 --> 00:58:21,206
If you're on macOS, and you have


1985
00:58:21,206 --> 00:58:22,446
a Network Kernel Extension, and


1986
00:58:22,446 --> 00:58:23,376
there's something you're doing


1987
00:58:23,376 --> 00:58:24,546
in that Network Kernel Extension


1988
00:58:24,546 --> 00:58:25,946
that you can't do any other way,


1989
00:58:26,106 --> 00:58:27,206
please get in touch with us


1990
00:58:27,296 --> 00:58:27,836
right away.


1991
00:58:28,106 --> 00:58:29,226
We need to provide you a better


1992
00:58:29,226 --> 00:58:30,636
alternative because Network


1993
00:58:30,636 --> 00:58:31,846
Kernel Extensions are not


1994
00:58:31,846 --> 00:58:33,176
compatible with User Space


1995
00:58:33,176 --> 00:58:33,686
Networking.


1996
00:58:34,656 --> 00:58:36,226
We wanted to give you a heads-up


1997
00:58:36,276 --> 00:58:39,286
that with URLSession, FTP and


1998
00:58:39,286 --> 00:58:40,696
file URLs are no longer going to


1999
00:58:40,696 --> 00:58:42,166
be supported for Proxy Automatic


2000
00:58:42,166 --> 00:58:42,936
Configuration.


2001
00:58:43,016 --> 00:58:44,076
Going forward, the only


2002
00:58:44,076 --> 00:58:46,006
supported URL schemes will be


2003
00:58:46,006 --> 00:58:47,226
HTTP and HTTPS.


2004
00:58:47,226 --> 00:58:50,826
There are a number of APIs at


2005
00:58:50,826 --> 00:58:52,626
the CoreFoundation layer that we


2006
00:58:52,626 --> 00:58:53,746
would like you to stop using.


2007
00:58:54,066 --> 00:58:54,966
They will be deprecated


2008
00:58:54,966 --> 00:58:55,456
eventually.


2009
00:58:55,606 --> 00:58:56,916
They are not yet marked as


2010
00:58:56,916 --> 00:58:57,466
deprecated.


2011
00:58:58,046 --> 00:58:58,806
These are


2012
00:58:59,126 --> 00:59:01,496
CFStreamCreatePairWith, anything


2013
00:59:01,496 --> 00:59:03,276
related to sockets as well as


2014
00:59:03,276 --> 00:59:03,796
CFSocket.


2015
00:59:04,606 --> 00:59:06,146
These cannot take advantage of a


2016
00:59:06,146 --> 00:59:07,296
lot of the connection


2017
00:59:07,296 --> 00:59:08,316
establishment that we've put in


2018
00:59:08,316 --> 00:59:09,486
there with the new


2019
00:59:09,486 --> 00:59:10,766
Network.framework, and they


2020
00:59:10,766 --> 00:59:11,776
can't take advantage of the new


2021
00:59:11,776 --> 00:59:12,886
User Space Networking.


2022
00:59:12,996 --> 00:59:14,006
So we really want you to move


2023
00:59:14,006 --> 00:59:15,266
off of these to take advantage


2024
00:59:15,546 --> 00:59:17,356
of the incredibly robust


2025
00:59:17,356 --> 00:59:18,556
connectivity improvements that


2026
00:59:18,556 --> 00:59:19,376
you'll get with


2027
00:59:19,376 --> 00:59:21,046
Network.framework and URLSession


2028
00:59:21,536 --> 00:59:22,776
and the improved performance.


2029
00:59:23,936 --> 00:59:25,656
There are some foundation APIs


2030
00:59:25,656 --> 00:59:26,566
as well that we'd like you to


2031
00:59:26,566 --> 00:59:27,246
move away from.


2032
00:59:27,526 --> 00:59:29,106
If you're using any of these


2033
00:59:29,196 --> 00:59:31,856
NSStream, NSNetService, or


2034
00:59:31,906 --> 00:59:34,076
NSSocket for APIs, please move


2035
00:59:34,076 --> 00:59:35,656
to Network.framework or


2036
00:59:35,886 --> 00:59:36,606
URLSession.


2037
00:59:37,576 --> 00:59:38,476
Finally, if you're using


2038
00:59:38,556 --> 00:59:40,906
SCNetworkReachability, we feel


2039
00:59:40,906 --> 00:59:41,996
that the Wait for Connectivity


2040
00:59:41,996 --> 00:59:43,836
model is a much better model, so


2041
00:59:43,836 --> 00:59:45,196
we'd really like you to move to


2042
00:59:45,196 --> 00:59:45,406
that.


2043
00:59:46,166 --> 00:59:47,166
And for those few cases where


2044
00:59:47,166 --> 00:59:48,526
Wait for Connectivity isn't the


2045
00:59:48,526 --> 00:59:50,576
right answer, NWPathMonitor is a


2046
00:59:50,576 --> 00:59:51,776
much better solution going


2047
00:59:51,776 --> 00:59:52,146
forward.


2048
00:59:52,956 --> 00:59:54,216
So now that we've talked about


2049
00:59:54,216 --> 00:59:55,016
some things we'd like you to


2050
00:59:55,016 --> 00:59:56,216
stop doing, I want to focus on


2051
00:59:56,216 --> 00:59:57,216
the things we really want to see


2052
00:59:57,216 --> 00:59:57,516
you do.


2053
00:59:58,736 --> 01:00:00,056
Going forward, the preferred


2054
01:00:00,056 --> 01:00:01,576
APIs on our platforms for


2055
01:00:01,576 --> 01:00:03,546
networking are URLSession and


2056
01:00:03,546 --> 01:00:04,346
Network.framework.


2057
01:00:04,816 --> 01:00:06,836
URLSession is really focused on


2058
01:00:06,836 --> 01:00:09,046
HTTP, but Stream Task provides


2059
01:00:09,636 --> 01:00:11,716
pretty simple access to TCP and


2060
01:00:11,716 --> 01:00:12,686
TLS connections.


2061
01:00:13,586 --> 01:00:14,856
If you need something more


2062
01:00:14,856 --> 01:00:16,516
advanced, Network.framework


2063
01:00:16,516 --> 01:00:18,376
gives you great support for TCP,


2064
01:00:18,726 --> 01:00:20,776
TLS, UDP, DTLS.


2065
01:00:21,166 --> 01:00:22,696
It handles listening for inbound


2066
01:00:22,696 --> 01:00:23,896
connections as well as outbound


2067
01:00:23,896 --> 01:00:25,606
connections, and we've got Path


2068
01:00:25,606 --> 01:00:26,876
Monitor to handle some of the


2069
01:00:26,876 --> 01:00:27,666
mobility stuff.


2070
01:00:28,006 --> 01:00:30,986
Next steps, we really want to


2071
01:00:30,986 --> 01:00:32,806
see you adopt these, adopt


2072
01:00:32,806 --> 01:00:33,756
Network.framework and


2073
01:00:33,756 --> 01:00:34,516
URLSession.


2074
01:00:35,116 --> 01:00:35,936
Your customers are going to


2075
01:00:35,936 --> 01:00:37,016
appreciate how much better your


2076
01:00:37,016 --> 01:00:38,676
connections, how much more


2077
01:00:38,676 --> 01:00:39,736
reliable your connections are


2078
01:00:39,736 --> 01:00:40,876
established, and they'll


2079
01:00:40,876 --> 01:00:42,006
appreciate the longer battery


2080
01:00:42,006 --> 01:00:42,606
life from the better


2081
01:00:42,606 --> 01:00:43,216
performance.


2082
01:00:45,156 --> 01:00:46,066
While you're working on these,


2083
01:00:46,146 --> 01:00:48,866
focus on how you're handling


2084
01:00:48,866 --> 01:00:50,166
your sending and receiving to


2085
01:00:50,166 --> 01:00:50,946
really optimize that


2086
01:00:50,946 --> 01:00:51,536
performance.


2087
01:00:52,146 --> 01:00:53,446
And take a lot of time to get


2088
01:00:53,446 --> 01:00:55,386
that support for the viability


2089
01:00:55,386 --> 01:00:57,186
and better route changes in


2090
01:00:57,186 --> 01:00:57,356
there.


2091
01:00:57,506 --> 01:00:59,136
It can make all the difference


2092
01:00:59,136 --> 01:01:00,016
for providing a seamless


2093
01:01:00,016 --> 01:01:01,006
networking experience.


2094
01:01:02,946 --> 01:01:03,346
Now we know that


2095
01:01:03,346 --> 01:01:04,176
Network.framework doesn't


2096
01:01:04,176 --> 01:01:06,336
support UDP Multicast yet, so if


2097
01:01:06,336 --> 01:01:07,666
you're doing UDP Multicast, we'd


2098
01:01:07,666 --> 01:01:08,706
really like to understand your


2099
01:01:08,706 --> 01:01:10,146
use cases so we can take those


2100
01:01:10,146 --> 01:01:11,206
into account going forward.


2101
01:01:12,386 --> 01:01:13,706
In addition, if you have any


2102
01:01:13,706 --> 01:01:14,876
other questions or enhancement


2103
01:01:14,876 --> 01:01:16,656
requests, we'd love to hear from


2104
01:01:16,656 --> 01:01:16,816
you.


2105
01:01:17,126 --> 01:01:18,846
Contact developer support or


2106
01:01:18,846 --> 01:01:20,416
better yet, meet us in one of


2107
01:01:20,416 --> 01:01:20,846
the labs.


2108
01:01:20,846 --> 01:01:22,166
We have a lab after lunch at 2


2109
01:01:22,166 --> 01:01:23,466
p.m. and another one tomorrow


2110
01:01:23,466 --> 01:01:26,176
morning at 9 a.m. For more


2111
01:01:26,176 --> 01:01:27,486
information, see this URL.


2112
01:01:29,046 --> 01:01:30,326
Don't forget the labs tomorrow


2113
01:01:30,326 --> 01:01:31,786
morning and after lunch.


2114
01:01:31,786 --> 01:01:33,066
Thank you so much and have a


2115
01:01:33,066 --> 01:01:33,876
great WWDC.


2116
01:01:34,508 --> 01:01:36,508
[ Applause ]

