1
00:00:09,766 --> 00:00:10,986
>> Good afternoon.


2
00:00:11,356 --> 00:00:12,946
This is Session 220.


3
00:00:13,446 --> 00:00:16,175
Advanced Text Layouts and
Effects with Text Kit.


4
00:00:16,516 --> 00:00:20,086
I'm Aki Inoue, a senior
text architect at Apple.


5
00:00:21,246 --> 00:00:26,426
Yesterday, Ian, Johannes and
Jordan introduced Text Kit,


6
00:00:26,716 --> 00:00:28,746
a new technology in iOS 7.


7
00:00:30,066 --> 00:00:33,316
Today in this session,
we're going to discover


8
00:00:33,316 --> 00:00:37,916
that you have broader and
finer controls over your text


9
00:00:38,546 --> 00:00:39,736
through this technology.


10
00:00:40,336 --> 00:00:42,256
Let's get started.


11
00:00:42,256 --> 00:00:44,316
These are the items
we're covering today.


12
00:00:44,316 --> 00:00:47,836
We're going to start
with text effects.


13
00:00:47,866 --> 00:00:50,856
As you've seen earlier
in this conference,


14
00:00:51,466 --> 00:00:55,676
iOS 7 supports gorgeous
letterpress text effects.


15
00:00:56,056 --> 00:00:56,946
You're going to learn how


16
00:00:56,946 --> 00:00:59,186
to integrate this effect
in the application.


17
00:00:59,956 --> 00:01:04,286
Next, we're going to cover the
three main Text Kit objects,


18
00:01:04,635 --> 00:01:10,106
NSLayoutManager, NSTextContainer
and NSTextStorage, the power,


19
00:01:10,106 --> 00:01:12,916
the typographic enhancements
in iOS 7.


20
00:01:13,266 --> 00:01:17,426
There are many advanced
text layout features


21
00:01:18,246 --> 00:01:23,656
such as multiple page
documents that are integral


22
00:01:23,656 --> 00:01:25,746
to the Text Kit architecture.


23
00:01:26,156 --> 00:01:30,126
Then we're going to dive
deeper into NSLayoutManager.


24
00:01:30,546 --> 00:01:32,066
You're going to learn
what you can do


25
00:01:32,066 --> 00:01:35,116
with some rich text layout
information available


26
00:01:35,116 --> 00:01:36,146
to your applications.


27
00:01:36,796 --> 00:01:39,446
And finally, I'm
going to cover a some


28
00:01:39,446 --> 00:01:42,726
of the customization point
provided for your applications.


29
00:01:43,046 --> 00:01:45,266
Of course, order of the material


30
00:01:46,216 --> 00:01:51,106
in this session brand
new to iOS 7.


31
00:01:51,146 --> 00:01:55,746
Now, I would like to bring
my colleague, Peter Hajas,


32
00:01:55,746 --> 00:02:02,896
who's going to tell you how
to spice up your application,


33
00:02:03,226 --> 00:02:04,856
what is the cool text effects.


34
00:02:05,246 --> 00:02:05,746
Peter.


35
00:02:06,236 --> 00:02:07,056
>> Good afternoon.


36
00:02:07,246 --> 00:02:08,545
My name is Peter Hajas.


37
00:02:08,856 --> 00:02:10,076
I'm a UIKit engineer.


38
00:02:10,496 --> 00:02:13,766
And today, I'd like to talk
to you about text effects.


39
00:02:14,006 --> 00:02:18,356
Text effects are a beautiful
new graphical effect we've added


40
00:02:18,676 --> 00:02:21,326
for your text in
your application.


41
00:02:21,846 --> 00:02:26,206
And in iOS 7, we're
introducing a beautiful,


42
00:02:26,446 --> 00:02:29,506
gorgeous letterpress effect.


43
00:02:30,896 --> 00:02:34,256
In case you're not familiar,
letterpress is a form


44
00:02:34,496 --> 00:02:37,326
of relief printing
by which texts


45
00:02:37,326 --> 00:02:40,016
and images are pressed
into the page.


46
00:02:40,096 --> 00:02:41,236
It's absolutely stunning.


47
00:02:42,456 --> 00:02:44,826
Now prior to iOS
7, if you wanted


48
00:02:44,826 --> 00:02:46,616
to create this effect
programmatically,


49
00:02:47,226 --> 00:02:49,196
it was extraordinarily
difficult for you


50
00:02:49,196 --> 00:02:54,136
to duplicate the shadows, the
embossing, this beautiful,


51
00:02:54,316 --> 00:02:55,876
beautiful effect for your text.


52
00:02:56,846 --> 00:03:00,496
But now, in iOS 7, we're
exposing this to you


53
00:03:00,496 --> 00:03:03,146
through one attributed
string key


54
00:03:03,376 --> 00:03:05,376
and a new attributed
string value.


55
00:03:06,626 --> 00:03:10,086
That key is
NSTextEffectAttributeName.


56
00:03:11,186 --> 00:03:15,226
And that value is
NSTextEffectLetterpressStyle.


57
00:03:16,426 --> 00:03:19,006
Now, if you've used
attributed strings before,


58
00:03:19,006 --> 00:03:21,156
and I hope you have, this works


59
00:03:21,156 --> 00:03:24,076
with all the standard NS
attributed string keys


60
00:03:24,076 --> 00:03:24,956
that you're familiar with,


61
00:03:25,226 --> 00:03:26,966
like
ForegroundColorAttributeName


62
00:03:27,196 --> 00:03:29,626
and others.


63
00:03:29,836 --> 00:03:32,586
Letterpress is a
complex graphical effect


64
00:03:33,216 --> 00:03:34,726
and you should use
it tastefully.


65
00:03:35,506 --> 00:03:38,666
If you look at our system
applications, like reminders


66
00:03:38,666 --> 00:03:42,916
and notes, you'll notice that
we use it in those applications


67
00:03:42,916 --> 00:03:45,216
for the title of
a reminder's list


68
00:03:46,026 --> 00:03:47,706
or the title of a
notes document.


69
00:03:49,956 --> 00:03:53,006
Now, I'd like to give
you a quick overview


70
00:03:53,616 --> 00:03:55,786
of the main Text Kit classes.


71
00:03:56,626 --> 00:03:58,846
This is a review of what
you saw at the Intro


72
00:03:58,846 --> 00:04:00,546
to Text Kit session yesterday.


73
00:04:02,376 --> 00:04:05,676
In Text Kit, there are
three classes that we use


74
00:04:06,176 --> 00:04:09,106
to represent the text in
your application and turn it


75
00:04:09,106 --> 00:04:11,616
into glyphs which users
will see on screen.


76
00:04:12,776 --> 00:04:16,176
Text Storage which
provides the backing store


77
00:04:16,346 --> 00:04:18,296
for the text in your
application.


78
00:04:19,926 --> 00:04:22,566
Layout Manager which
is in charge of how


79
00:04:22,566 --> 00:04:26,736
that text gets turned into
glyphs and has override points


80
00:04:26,736 --> 00:04:28,326
for you to customize it.


81
00:04:28,876 --> 00:04:32,986
And Text Container, which
describes the geometry


82
00:04:32,986 --> 00:04:34,236
about which we flow lines


83
00:04:34,476 --> 00:04:39,016
and line fragments
in your text view.


84
00:04:39,226 --> 00:04:40,676
Let's start with Text Storage.


85
00:04:41,656 --> 00:04:45,616
NSTextStorage is a mutable
attributed string subclass.


86
00:04:45,766 --> 00:04:48,246
So it supports all the
standard attributed string,


87
00:04:48,696 --> 00:04:50,316
keys and values that
you're customary


88
00:04:50,316 --> 00:04:51,676
with including letterpress.


89
00:04:52,716 --> 00:04:56,446
NSTextStorage is versatile
enough for a short document,


90
00:04:56,556 --> 00:05:00,936
like a brief note or message,
and a document as long as War


91
00:05:00,936 --> 00:05:04,396
and Peace, so it should be
totally perfect for your needs.


92
00:05:05,436 --> 00:05:09,286
If, however, you find the
need to subclass Text Storage,


93
00:05:09,956 --> 00:05:12,816
you'll need to override all
the primitive attributed string


94
00:05:13,546 --> 00:05:15,716
and mutable attributed
string API.


95
00:05:17,596 --> 00:05:20,736
Next, NSLayoutManager.


96
00:05:21,246 --> 00:05:25,646
If NSTextStorage is the thing
that controls the backing store


97
00:05:25,646 --> 00:05:28,246
for your text and all
your Unicode characters


98
00:05:28,246 --> 00:05:30,166
and attributes and
things like that,


99
00:05:30,956 --> 00:05:35,706
Layout Manager is the object
that translates that text


100
00:05:36,096 --> 00:05:37,526
into glyphs on screen.


101
00:05:38,776 --> 00:05:41,526
Now if you'd like to
override that layout process,


102
00:05:41,826 --> 00:05:43,396
you can do so through delegation


103
00:05:43,526 --> 00:05:45,816
and this is how you can
accomplish advanced layout


104
00:05:45,886 --> 00:05:50,136
techniques such as, for
example, folding lines


105
00:05:50,226 --> 00:05:51,896
or other advanced
text rendering.


106
00:05:52,376 --> 00:05:56,126
And finally, NSTextContainer.


107
00:05:57,486 --> 00:06:01,436
Text Container represents
one area on the display


108
00:06:01,696 --> 00:06:03,166
in which you'd like
to draw a text.


109
00:06:03,726 --> 00:06:06,266
It's not the object that
does the actual drawing,


110
00:06:06,356 --> 00:06:07,616
that's up to your text view.


111
00:06:08,366 --> 00:06:11,116
Instead Text Container
describes the geometry


112
00:06:11,116 --> 00:06:12,106
about which we draw.


113
00:06:13,246 --> 00:06:15,686
If you were in the
introduction session yesterday,


114
00:06:16,246 --> 00:06:19,206
you saw just how easy our
declarative exclusion path


115
00:06:19,206 --> 00:06:21,926
support is, and this is
built on Text Container.


116
00:06:23,026 --> 00:06:25,156
Now, as we'll see
in a little bit,


117
00:06:25,156 --> 00:06:30,106
Text Container represents one
area on which you draw a text.


118
00:06:30,606 --> 00:06:35,556
So if you'd like multiple pages
or multiple columns for each


119
00:06:35,556 --> 00:06:39,276
of those pages, columns or other
areas in which you flow text,


120
00:06:39,956 --> 00:06:41,936
you'll need an additional
Text Container.


121
00:06:42,456 --> 00:06:48,436
In their most basic
configuration, you'll have one


122
00:06:48,636 --> 00:06:49,896
of each of these objects.


123
00:06:50,866 --> 00:06:54,036
One Text Storage providing that
backing store for your document.


124
00:06:55,376 --> 00:06:58,516
One Layout Manager controlling
how that text gets turned


125
00:06:58,516 --> 00:06:59,606
into glyphs on screen.


126
00:07:00,126 --> 00:07:04,366
And one Text Container
describing the geometry


127
00:07:04,366 --> 00:07:05,526
of your lines.


128
00:07:06,396 --> 00:07:07,516
But let's say you want


129
00:07:07,516 --> 00:07:11,106
to do something a little more
intricate like a multi-columnar


130
00:07:11,156 --> 00:07:13,436
or multi-page layout,
that's fine.


131
00:07:13,506 --> 00:07:15,676
Text Kit supports this
right out of the box.


132
00:07:16,346 --> 00:07:18,196
Just use multiple
Text Containers,


133
00:07:18,536 --> 00:07:20,406
attached to the same
Layout Manager,


134
00:07:20,976 --> 00:07:23,036
backed by the same
Text Storage document.


135
00:07:23,786 --> 00:07:25,706
This is how you'd get
multi-page support


136
00:07:26,416 --> 00:07:28,076
and multi-columnar support.


137
00:07:29,276 --> 00:07:31,556
Now, let's say you want
to go really advanced


138
00:07:31,746 --> 00:07:35,116
and you want a different
layout for your text depending


139
00:07:35,116 --> 00:07:37,636
on if it's on the
device or if it's


140
00:07:37,636 --> 00:07:39,736
on the printed page, hard copy.


141
00:07:40,686 --> 00:07:43,796
In that case, you'd use
multiple Layout Managers,


142
00:07:44,156 --> 00:07:45,686
each with their own
Text Container,


143
00:07:46,236 --> 00:07:49,346
but they're still backed
by the same Text Storage.


144
00:07:49,876 --> 00:07:53,206
So now that I've showed
you just how easy it is


145
00:07:53,236 --> 00:07:57,216
to compose our Text Kit
classes in your applications,


146
00:07:57,986 --> 00:07:59,686
I'd like to give
you a quick demo


147
00:07:59,686 --> 00:08:02,896
of just how simple you
can implement a document


148
00:08:02,896 --> 00:08:05,406
of arbitrary length, a
multi-paged document.


149
00:08:05,896 --> 00:08:08,376
Here I've got some code and
I'm working on an application


150
00:08:08,846 --> 00:08:12,236
where I have a document sitting
in my applications bundle


151
00:08:12,896 --> 00:08:15,816
and I'd like to flow
this document on screen.


152
00:08:16,266 --> 00:08:18,776
In addition to flowing this
document on the screen,


153
00:08:19,296 --> 00:08:22,116
I want my user, when they're
scrolling through the pages


154
00:08:22,116 --> 00:08:24,726
of my document, to
fill like they would


155
00:08:24,726 --> 00:08:25,836
on the rest of the system.


156
00:08:25,836 --> 00:08:29,116
So I'm going to use
UIPageViewController.


157
00:08:30,126 --> 00:08:33,986
Now, the way PageViewController
works is it needs a view


158
00:08:33,986 --> 00:08:37,436
controller to represent every
page that you'd like to express.


159
00:08:38,035 --> 00:08:40,916
So first, we're going to
need a view controller


160
00:08:40,916 --> 00:08:42,666
to represent a particular page.


161
00:08:43,916 --> 00:08:46,696
Now, thankfully before you all
came in, I had this code sitting


162
00:08:46,696 --> 00:08:47,636
in the oven overnight.


163
00:08:48,146 --> 00:08:50,056
So, it should ready to go.


164
00:08:50,216 --> 00:08:53,336
I'm just going to
drag in a class


165
00:08:53,336 --> 00:08:57,066
that I wrote called
Text Container Instance


166
00:08:57,066 --> 00:08:57,806
View Controller.


167
00:08:58,526 --> 00:09:01,566
And this just encapsulates
a text view which is going


168
00:09:01,566 --> 00:09:04,696
to draw the text on
screen and the page number


169
00:09:04,696 --> 00:09:07,846
that we can reference when
the PageViewController asks us


170
00:09:07,846 --> 00:09:09,906
for a view controller after


171
00:09:09,906 --> 00:09:11,526
or before a particular
view controller.


172
00:09:12,006 --> 00:09:15,176
Next, in our main
view controller,


173
00:09:15,316 --> 00:09:19,396
we're going to add a method,
ViewControllerForPageNumber.


174
00:09:20,406 --> 00:09:24,776
Remember, a Text Container
represents one area


175
00:09:24,776 --> 00:09:26,516
on the screen in which
you'd like to draw.


176
00:09:27,116 --> 00:09:30,256
So for every page, we're going
to need a Text Container.


177
00:09:30,556 --> 00:09:31,556
But that's no big deal.


178
00:09:31,556 --> 00:09:32,786
Text Kit's pretty performant.


179
00:09:33,036 --> 00:09:36,476
We're going to create a new
page controller representing a


180
00:09:36,476 --> 00:09:41,186
particular page wired
up to our Layout Manager


181
00:09:41,186 --> 00:09:44,986
and add a text view into
the view controller.


182
00:09:48,436 --> 00:09:51,306
Next, we're going to
implement awakeFromNib.


183
00:09:52,376 --> 00:09:55,366
In awakeFromNib, we're going to
create a new PageViewController


184
00:09:55,556 --> 00:09:57,166
and set ourselves
as the delegate.


185
00:09:57,686 --> 00:10:00,186
Next, we're going to implement
the page view controller data


186
00:10:00,186 --> 00:10:01,126
source methods.


187
00:10:02,356 --> 00:10:05,266
As I said before, the way
PageViewController works is


188
00:10:05,266 --> 00:10:08,016
by referencing a view
controller before


189
00:10:08,286 --> 00:10:11,816
or after a particular view
controller and that's fine.


190
00:10:12,436 --> 00:10:15,276
Because our single
PageViewController has a page


191
00:10:15,276 --> 00:10:18,866
number instance variable, we
can just add or subtract one


192
00:10:19,416 --> 00:10:21,726
and return the view controller
representing that page.


193
00:10:22,186 --> 00:10:24,836
Finally, we're going to
implement viewWillAppear


194
00:10:24,836 --> 00:10:25,876
in our view controller.


195
00:10:26,446 --> 00:10:30,886
And we're going to loop
through each of our pages


196
00:10:31,236 --> 00:10:33,456
and create a Text
Container for each page.


197
00:10:33,706 --> 00:10:36,076
Because the Text Container
represents one area


198
00:10:36,076 --> 00:10:39,036
in which we need to draw,
we'll need one for every page.


199
00:10:39,586 --> 00:10:40,726
And that's it.


200
00:10:41,296 --> 00:10:42,416
I'm going to build and run.


201
00:10:45,296 --> 00:10:48,386
And this is the same demo
application that you saw


202
00:10:48,386 --> 00:10:51,526
in the Intro to Text Kit
session talk yesterday.


203
00:10:52,736 --> 00:10:54,906
So we're going to drop into
the Text Container demo.


204
00:10:56,106 --> 00:11:02,136
And as you can see our text is
flowed into this view perfectly.


205
00:11:02,746 --> 00:11:05,756
And as we scroll using the
paging behavior our users have


206
00:11:05,756 --> 00:11:10,446
come to expect, we'll be able
to go from page to page to page.


207
00:11:11,316 --> 00:11:13,616
And you'll notice we've even
got a little bit of spacing


208
00:11:13,696 --> 00:11:16,756
in between these pages.


209
00:11:16,916 --> 00:11:20,076
Now, if we had right to
left text from languages


210
00:11:20,076 --> 00:11:22,986
such as Hebrew, Text Kit
was built from the ground


211
00:11:22,986 --> 00:11:25,866
up to support text
in all directions.


212
00:11:25,936 --> 00:11:29,436
So that right to left text
would flow alongside this left


213
00:11:29,436 --> 00:11:30,206
to right text.


214
00:11:32,236 --> 00:11:35,096
And so, that's just
how easy it is


215
00:11:35,096 --> 00:11:39,556
to implement multi-page support
using the core Text Kit objects.


216
00:11:40,926 --> 00:11:44,276
Now, I'd like to hand it
back to my colleague Aki,


217
00:11:44,866 --> 00:11:48,176
our senior textpert, who's going
to go deeper into TextLayout.


218
00:11:48,396 --> 00:11:48,756
Thank you.


219
00:11:49,006 --> 00:11:49,616
>> Thank you, Peter.


220
00:11:50,776 --> 00:11:53,626
Now, let's get close
to NSLayoutManager.


221
00:11:54,056 --> 00:11:59,066
NSLayoutManager is not a
new API for old layout.


222
00:11:59,066 --> 00:12:04,066
It's a Text Kit controller
class that orchestrates


223
00:12:04,216 --> 00:12:08,906
between NSTextContainer
and NSTextStorage.


224
00:12:10,316 --> 00:12:14,846
And it manages and stores
the layout information.


225
00:12:15,546 --> 00:12:18,836
Using that information,
NSLayoutManager measures


226
00:12:19,086 --> 00:12:26,046
and renders text
as we pressed it.


227
00:12:26,046 --> 00:12:28,796
NSLayoutManager is
designed to be open.


228
00:12:29,176 --> 00:12:33,926
It's not just black box that
serve its sibling objects.


229
00:12:35,076 --> 00:12:42,236
So that all the information used
by Text Kit objects, the power,


230
00:12:42,236 --> 00:12:46,076
the magic is available
to your applications.


231
00:12:47,376 --> 00:12:52,786
Finally, its object-oriented
interface gives you excessive


232
00:12:52,786 --> 00:12:54,306
support for customization


233
00:12:55,766 --> 00:12:58,976
through the familiar
design patterns


234
00:12:58,976 --> 00:13:01,266
such as delegation
and subclassing.


235
00:13:04,176 --> 00:13:06,476
Before going any deeper,


236
00:13:07,116 --> 00:13:12,206
I'd like to recap
what a text layout is.


237
00:13:13,176 --> 00:13:18,786
Text layout is basically
glyphs and locations.


238
00:13:20,776 --> 00:13:28,326
Then I'd like to
look at the glyphs.


239
00:13:28,746 --> 00:13:31,926
Glyphs-- A glyph is a
graphical representation


240
00:13:31,926 --> 00:13:33,986
of one word characters.


241
00:13:34,506 --> 00:13:35,136
It's simple.


242
00:13:36,916 --> 00:13:43,486
These are three examples of
glyphs for a same character.


243
00:13:44,046 --> 00:13:48,026
As you can see, the graphical
informations you have


244
00:13:48,026 --> 00:13:53,536
in fonts are used to convert
character into glyphs,


245
00:13:53,916 --> 00:13:55,386
the graphical representation.


246
00:13:55,986 --> 00:14:03,246
And since glyphs are graphical
elements, they can be handled


247
00:14:03,246 --> 00:14:05,846
by the graphic subsystem
such as quotes.


248
00:14:06,826 --> 00:14:12,046
And on our platform, that glyph
information, glyph IDs to work


249
00:14:12,046 --> 00:14:15,046
in core graphics
data type, CGGlyph.


250
00:14:15,046 --> 00:14:21,386
Now that we covered the basics
of text layout information,


251
00:14:22,136 --> 00:14:26,356
I'd like to walk you though
some of the things you could do


252
00:14:26,536 --> 00:14:29,846
with the layout informations
to work in NSLayoutManager.


253
00:14:32,006 --> 00:14:36,276
In addition to, get the
size of the entire string,


254
00:14:37,496 --> 00:14:41,226
now you can get the
size of single line


255
00:14:42,256 --> 00:14:45,696
to a single glyph at will.


256
00:14:45,896 --> 00:14:48,946
As Ian mentioned yesterday
in his Introduction


257
00:14:48,946 --> 00:14:53,246
to Text Kit session, hit-testing
the character or a word


258
00:14:53,456 --> 00:14:55,926
under your touch
is very trivial.


259
00:14:59,156 --> 00:15:02,466
Also you can get the
precise location,


260
00:15:03,126 --> 00:15:06,616
fix your perfect location
of individual glyphs


261
00:15:07,326 --> 00:15:10,506
so that you can add your
custom rendering or animation


262
00:15:10,856 --> 00:15:16,376
at arbitrary range of
characters in your document.


263
00:15:16,906 --> 00:15:20,456
And with all text
layout information,


264
00:15:21,146 --> 00:15:26,066
glyphs plus locations,
you can transform


265
00:15:26,066 --> 00:15:32,316
and animate text using the power
of the core graphic system.


266
00:15:36,276 --> 00:15:39,256
OK. Let's look at the
glyph information stored


267
00:15:39,256 --> 00:15:40,346
in Layout Manager.


268
00:15:41,566 --> 00:15:44,386
You can access the glyph
information using this method,


269
00:15:45,286 --> 00:15:47,516
glyphAtIndex, simply enough.


270
00:15:48,666 --> 00:15:51,186
But notice that the index passed


271
00:15:51,276 --> 00:15:55,356
through this method
is a glyph index.


272
00:15:56,176 --> 00:15:58,986
It's not the character
index you use


273
00:15:58,986 --> 00:16:01,896
to access the contents
of NSTextStorage.


274
00:16:02,236 --> 00:16:05,556
So glyph index character
index, where are they?


275
00:16:06,776 --> 00:16:07,996
They are usually the same


276
00:16:08,036 --> 00:16:10,636
but they don't map one
to one all the time.


277
00:16:11,486 --> 00:16:19,786
It's because ligatures,
translation or hyphenation.


278
00:16:20,836 --> 00:16:25,996
There are many common situations
that make the glyphs to map


279
00:16:25,996 --> 00:16:29,366
to their original
character directory.


280
00:16:29,986 --> 00:16:34,996
So for that reason,
NSLayoutManager keeps track


281
00:16:35,856 --> 00:16:39,046
of the character index, the
original character index


282
00:16:39,426 --> 00:16:40,936
for each glyph for you.


283
00:16:42,176 --> 00:16:44,396
You can access the
character index using


284
00:16:44,476 --> 00:16:47,006
characterIndexForGlyphAtIndex
method.


285
00:16:47,006 --> 00:16:53,406
And also you can access
that index other way around.


286
00:16:54,416 --> 00:16:59,586
These are-- You could use these
two methods that maps glyph


287
00:16:59,586 --> 00:17:01,176
and characters in bulk.


288
00:17:01,616 --> 00:17:06,486
And remember, it's important
to remember that, in any case,


289
00:17:06,896 --> 00:17:10,526
you want to use one of these
methods to convert glyphs


290
00:17:10,705 --> 00:17:14,836
and character index when you're
working with NSLayoutManager.


291
00:17:17,665 --> 00:17:19,876
We look at the glyph
information,


292
00:17:20,705 --> 00:17:22,776
let's look at the allocations.


293
00:17:23,116 --> 00:17:30,836
Just like the glyph info itself,
NSLayoutManager keeps track


294
00:17:30,836 --> 00:17:34,726
of the text layout information,
the allocations for glyph.


295
00:17:35,976 --> 00:17:37,636
There are three elements--


296
00:17:38,256 --> 00:17:42,096
generally three elements in
text layout, Text Container,


297
00:17:43,086 --> 00:17:46,076
line and the glyph
location itself.


298
00:17:46,476 --> 00:17:49,466
As Peter described
earlier in this session,


299
00:17:50,306 --> 00:17:55,236
NSLayoutManager connects to
an array of Text Containers,


300
00:17:55,786 --> 00:18:00,076
glyphs are filled from the
beginning of the Text Container


301
00:18:00,076 --> 00:18:03,586
at index zero and
from so and so forth.


302
00:18:05,486 --> 00:18:08,446
You can access your Text
Container associated


303
00:18:08,446 --> 00:18:12,646
with a glyph using the
textContainerForGlyphAtIndex


304
00:18:12,696 --> 00:18:14,076
effectiveRange method.


305
00:18:15,076 --> 00:18:19,096
We now know that NSRange pointed


306
00:18:19,166 --> 00:18:23,896
by the second argument
will be filled


307
00:18:23,976 --> 00:18:25,556
with the glyph range
corresponding


308
00:18:25,556 --> 00:18:29,436
to the Text Container
returned from this method.


309
00:18:30,076 --> 00:18:33,406
So in a way, you can use
this method to animate


310
00:18:33,406 --> 00:18:35,076
through all the Text Containers


311
00:18:35,246 --> 00:18:37,126
and the corresponding
glyph range.


312
00:18:39,056 --> 00:18:44,956
Lines. Just as glyph
belong to Text Container,


313
00:18:46,076 --> 00:18:47,106
they are inside the line.


314
00:18:48,086 --> 00:18:52,026
And Text Containers are
filled with lines of text.


315
00:18:52,816 --> 00:18:57,796
But notice that a bigger
line could be divided


316
00:18:57,796 --> 00:19:01,226
into multiple pieces
like this due


317
00:19:01,226 --> 00:19:07,396
to NSTextContainer geometrical
shape defined by exclusion path.


318
00:19:08,386 --> 00:19:15,136
So for that reason, we call that
data element a line fragment.


319
00:19:15,616 --> 00:19:17,396
You can access the line fragment


320
00:19:17,816 --> 00:19:22,416
for a glyph using the
lineFragmentRectForGlyphAtIndex


321
00:19:22,416 --> 00:19:23,786
effectiveRange method.


322
00:19:24,946 --> 00:19:29,716
It returns the CGRect that
represent the rectangular area


323
00:19:30,276 --> 00:19:31,236
for the line fragment.


324
00:19:31,236 --> 00:19:37,846
And finally, the glyph
location itself, it's relative


325
00:19:37,846 --> 00:19:42,796
to the line fragmented rect
that the glyph is inside.


326
00:19:44,276 --> 00:19:45,846
You can access the
location using


327
00:19:45,846 --> 00:19:47,746
the locationForGlyphAtIndex.


328
00:19:48,286 --> 00:19:57,426
Now we covered APIs, I'd like to
explain the actual relationship


329
00:19:57,576 --> 00:20:02,086
among the three geometrical
elements inside the


330
00:20:02,086 --> 00:20:03,066
layout information.


331
00:20:04,286 --> 00:20:05,666
We have Text Container.


332
00:20:06,636 --> 00:20:13,296
It has its own system and it
starts at the upper left corner.


333
00:20:16,316 --> 00:20:21,446
The origin of the Text Container
could be actually anywhere


334
00:20:21,446 --> 00:20:25,146
inside a view coordinate
system of its parent view.


335
00:20:25,766 --> 00:20:29,696
So, it could be offsetted
like this.


336
00:20:35,596 --> 00:20:38,996
Now, look into the
line fragment itself.


337
00:20:39,716 --> 00:20:43,116
The line fragment is
represented by CGRect.


338
00:20:44,356 --> 00:20:49,656
And its frame origin is
relative to the line fragment.


339
00:20:49,656 --> 00:20:51,966
It's relative to the Text
Container coordinate system.


340
00:20:52,446 --> 00:20:58,486
Inside the line fragment, it has
its own coordinate system too


341
00:20:58,966 --> 00:21:00,616
that start with the
upper left corner.


342
00:21:02,176 --> 00:21:09,106
And the glyphs are located at
its baseline origin that starts


343
00:21:09,246 --> 00:21:16,336
from the upper left corner of
the line fragment rect itself.


344
00:21:16,546 --> 00:21:22,026
OK. We covered so many
concepts and APIs.


345
00:21:23,146 --> 00:21:25,556
Now make them used in practice.


346
00:21:25,996 --> 00:21:30,936
In this example, I'd like to
locate or find the location


347
00:21:30,936 --> 00:21:36,436
of the glyph associated with the
last character in your document.


348
00:21:36,736 --> 00:21:37,706
It's simple.


349
00:21:39,576 --> 00:21:43,596
First, we'll get the index of
the character in your doc--


350
00:21:43,826 --> 00:21:48,516
the last character in a
document just at the lengths


351
00:21:48,636 --> 00:21:51,236
of the document and
subtract one.


352
00:21:52,266 --> 00:21:57,876
Here we are assuming that
it's not an empty document.


353
00:21:58,316 --> 00:22:01,456
Then as we discussed earlier,


354
00:22:02,876 --> 00:22:06,006
we want to convert the
character index to glyph index.


355
00:22:06,526 --> 00:22:09,066
Here we're using the
glyphIndexForCharacterIndex


356
00:22:09,066 --> 00:22:09,336
method.


357
00:22:09,336 --> 00:22:13,036
Once you have the glyph index,


358
00:22:13,326 --> 00:22:16,626
it's easy to get the
other layout elements.


359
00:22:17,006 --> 00:22:19,186
Here we're getting
the line fragment rect


360
00:22:19,186 --> 00:22:23,866
for the glyph using the
lineFragmentRectForGlyphAtIndex.


361
00:22:25,236 --> 00:22:32,006
Then get the location of
the glyph at glyph itself.


362
00:22:32,146 --> 00:22:35,126
Now, we translate the location


363
00:22:35,496 --> 00:22:37,616
by adding the line
fragment origin


364
00:22:38,436 --> 00:22:40,766
so that the location
is now contained


365
00:22:40,846 --> 00:22:42,926
in Text Container
coordinate system.


366
00:22:44,316 --> 00:22:48,456
If you want, you can further
translate that location


367
00:22:48,456 --> 00:22:49,996
into the view coordinate system


368
00:22:50,266 --> 00:22:54,156
if the Text Container origin
is not at the view origin.


369
00:22:54,706 --> 00:22:55,586
Next example.


370
00:22:57,596 --> 00:23:00,896
In addition to the
primitive methods that acts


371
00:23:00,896 --> 00:23:03,506
as the layout information
we discussed so far,


372
00:23:03,506 --> 00:23:08,926
NSLayoutManager provides
many, many convenience methods


373
00:23:09,436 --> 00:23:10,936
to make your life easier.


374
00:23:11,596 --> 00:23:15,736
In this example we
are doing hit testing.


375
00:23:16,166 --> 00:23:21,466
We get the location of the touch
inside your text view using the


376
00:23:21,466 --> 00:23:22,646
locationInView method.


377
00:23:24,556 --> 00:23:27,826
Here we are assuming
the location.


378
00:23:28,636 --> 00:23:32,416
The view coordinate
system is equal


379
00:23:32,416 --> 00:23:35,216
to Text Container coordinate
system in this example.


380
00:23:36,946 --> 00:23:38,366
Now you have the location.


381
00:23:39,406 --> 00:23:45,766
Using the characterIndexForPoint
inTextContainer


382
00:23:46,886 --> 00:23:50,856
fractionOfDistance
BetweenInsertionPoints,


383
00:23:51,556 --> 00:23:54,966
you can get the character
index correspondent


384
00:23:54,966 --> 00:23:58,586
to the glyph closest to
the location you specify.


385
00:24:01,006 --> 00:24:05,336
Once you have the character
index, it's relatively simple


386
00:24:05,336 --> 00:24:10,736
to find out what range using
some of the NSString amenities


387
00:24:11,676 --> 00:24:15,086
such as
enumerateSubstringsInRange:


388
00:24:15,166 --> 00:24:16,806
options:usingBlock: method.


389
00:24:18,396 --> 00:24:20,966
So we are not going deep


390
00:24:20,966 --> 00:24:24,786
into the actual implementation
finding the word range,


391
00:24:25,046 --> 00:24:30,346
but you can do so
pretty trivially.


392
00:24:33,416 --> 00:24:40,856
Next. Usually, we recommend
sticking to UIKit objects


393
00:24:41,336 --> 00:24:45,436
such as UITextView and UILevel


394
00:24:45,436 --> 00:24:48,726
for all your text
rendering needs.


395
00:24:50,096 --> 00:24:52,836
Because with the
deeper integration


396
00:24:52,926 --> 00:24:54,426
with the attribute string,


397
00:24:55,186 --> 00:24:59,376
these objects now provide
sufficient functionalities


398
00:24:59,376 --> 00:25:04,146
and extensibilities for your
needs while you can enjoy Text


399
00:25:04,536 --> 00:25:10,566
Kit and amenities such as
old layout and accessibility.


400
00:25:10,956 --> 00:25:14,696
In some few cases,
though, you might want


401
00:25:14,696 --> 00:25:18,426
to consider rendering
NSLayoutManager


402
00:25:19,066 --> 00:25:20,396
into your custom view.


403
00:25:21,736 --> 00:25:29,506
For example, you have multiple
overlapping text image frames


404
00:25:29,906 --> 00:25:33,436
in your view, commonly
found in magazines


405
00:25:33,586 --> 00:25:36,556
or newspaper applications,


406
00:25:37,796 --> 00:25:42,386
or you want to have
custom pagination


407
00:25:43,196 --> 00:25:44,966
when you're printing
your documents.


408
00:25:46,226 --> 00:25:51,636
In this case, you could
actually directly access the


409
00:25:51,636 --> 00:25:55,606
NSLayoutManager and manually
render the contents yourself.


410
00:25:55,936 --> 00:26:01,876
Here, it's assumed this Layout
Manager variable contains


411
00:26:02,156 --> 00:26:04,336
preconfigured Layout Manager.


412
00:26:04,576 --> 00:26:09,476
And we have the rendering area.


413
00:26:09,816 --> 00:26:17,766
It's the area inside your view
you want to fill the glyph with.


414
00:26:17,766 --> 00:26:20,006
It's sort of, you know,
you'll get that rect


415
00:26:20,006 --> 00:26:22,136
from the direct method.


416
00:26:22,716 --> 00:26:27,896
And finally, we and-- we
have the container origin


417
00:26:28,906 --> 00:26:31,286
that contains the origin


418
00:26:31,646 --> 00:26:35,376
of the Text Container inside
your view coordinate system.


419
00:26:35,896 --> 00:26:41,166
First thing, you want to
convert the rendering area


420
00:26:41,616 --> 00:26:43,756
into the Text Container
coordinate system,


421
00:26:44,516 --> 00:26:46,256
just subtract the
container origin


422
00:26:47,756 --> 00:26:53,566
from the bounding rect frame.


423
00:26:53,766 --> 00:26:54,926
Then use


424
00:26:54,966 --> 00:26:58,066
that glyphRangeForBoundingRect
inTextContainer,


425
00:26:58,356 --> 00:26:59,756
another useful method.


426
00:27:00,386 --> 00:27:04,226
You can get the glyph
range that are filling


427
00:27:04,226 --> 00:27:06,246
that specify that bounding rect.


428
00:27:06,826 --> 00:27:12,736
Notice that that glyph range
might contain some extra glyphs


429
00:27:12,736 --> 00:27:14,876
outside of bounding
rect actually.


430
00:27:15,636 --> 00:27:20,796
It's because we're handling
the bidirectional language


431
00:27:20,796 --> 00:27:22,656
such as Arabic and Hebrew,


432
00:27:23,276 --> 00:27:25,956
the glyph location
could be out of order.


433
00:27:26,796 --> 00:27:29,866
So in order to contain
all the glyph range,


434
00:27:30,246 --> 00:27:34,146
some of the glyph might be lying
outside of the bounding rect.


435
00:27:35,296 --> 00:27:37,576
So in those cases, you
might consider clipping


436
00:27:38,346 --> 00:27:41,816
when you are rendering.


437
00:27:41,866 --> 00:27:45,556
Once you have the glyph
range, you can render.


438
00:27:46,976 --> 00:27:51,976
Here we are rendering
the background using


439
00:27:51,976 --> 00:27:54,666
that drawBackgroundForGlyphRange
atPoint.


440
00:27:55,926 --> 00:27:58,476
This method renders attributes


441
00:27:58,476 --> 00:28:01,656
such as
NSBackgroundColorAttributeName.


442
00:28:02,736 --> 00:28:08,016
But we recommend always using
this method whenever you are


443
00:28:08,016 --> 00:28:09,036
rendering glyphs.


444
00:28:09,616 --> 00:28:15,706
It's because in the future,
we might enhance this method


445
00:28:15,706 --> 00:28:17,506
to support some other
attributes.


446
00:28:18,256 --> 00:28:22,226
In that case, your application
automatically get the new


447
00:28:22,226 --> 00:28:25,346
functionalities out of it.


448
00:28:25,886 --> 00:28:27,426
Once you render the background,


449
00:28:28,096 --> 00:28:33,216
now render the glyphs using
the drawGlyphsForGlyohRange


450
00:28:33,216 --> 00:28:34,126
atPoint method.


451
00:28:35,166 --> 00:28:39,046
It renders a glyph in
the glyph range as well


452
00:28:39,046 --> 00:28:45,606
as other auxiliary graphical
items such as underlines,


453
00:28:45,856 --> 00:28:49,926
strikethrough, shadows
and attachments.


454
00:28:50,096 --> 00:28:54,556
You might have noticed that we
are passing container origin


455
00:28:54,556 --> 00:28:55,606
to these methods.


456
00:28:56,156 --> 00:28:59,786
So we are rendering an
arbitrary glyph range,


457
00:29:01,016 --> 00:29:06,706
but you are not passing
some location corresponding


458
00:29:06,706 --> 00:29:08,376
to the glyph range
to drawing method.


459
00:29:08,816 --> 00:29:11,286
Maybe that's not
what you are used to.


460
00:29:11,716 --> 00:29:14,836
Actually, it's quite
simple and straightforward.


461
00:29:15,316 --> 00:29:21,276
It's because Layout
Manager is designed


462
00:29:21,306 --> 00:29:23,646
to render Text Containers.


463
00:29:24,206 --> 00:29:28,826
So even though you are
passing the glyph range a part


464
00:29:28,826 --> 00:29:34,616
of the Text Container, you are
always rendering Text Container


465
00:29:34,616 --> 00:29:39,416
itself and rendering contents.


466
00:29:40,126 --> 00:29:43,106
So when you're passing
the location,


467
00:29:43,616 --> 00:29:46,786
it's always at the
Text Container origin.


468
00:29:46,786 --> 00:29:50,946
Now that doesn't necessary
mean you will start


469
00:29:50,946 --> 00:29:53,176
with your original
Text Container shape.


470
00:29:54,486 --> 00:29:58,336
You are free to translate
the location by yourself


471
00:29:58,336 --> 00:30:04,276
so that the location paths


472
00:30:05,736 --> 00:30:08,756
to the rendering
method can be arbitrary


473
00:30:09,236 --> 00:30:11,776
and your glyph range
can be moved


474
00:30:11,776 --> 00:30:13,916
to some other places
in the view.


475
00:30:14,476 --> 00:30:17,696
Here we have the glyph
range we want to render.


476
00:30:18,416 --> 00:30:20,616
That's some range inside
your Text Container.


477
00:30:21,246 --> 00:30:24,406
And we have the location.


478
00:30:24,856 --> 00:30:27,576
We want that glyph
range to appear


479
00:30:27,576 --> 00:30:29,696
at the location inside of view.


480
00:30:30,196 --> 00:30:30,636
First,


481
00:30:31,196 --> 00:30:34,056
using
lineFragmentRectForGlyphAtIndex


482
00:30:34,056 --> 00:30:40,256
method we saw earlier, we
get the line fragment origin


483
00:30:41,006 --> 00:30:42,646
for the glyph you
want to render.


484
00:30:43,126 --> 00:30:46,996
So in this case, you
get the line rect


485
00:30:46,996 --> 00:30:49,426
for the first glyph
in the glyph range.


486
00:30:50,866 --> 00:30:56,256
Once you get that, you
subtract the glyph origin


487
00:30:56,786 --> 00:30:58,236
from the location
you want to render.


488
00:31:00,116 --> 00:31:04,366
By doing that, the
location is now translated


489
00:31:05,896 --> 00:31:13,446
so that the Text Container
origin is moved far


490
00:31:13,446 --> 00:31:19,956
and the location coincide to the
glyph range you want to render.


491
00:31:20,116 --> 00:31:24,066
Now, you have the
location, just render it.


492
00:31:24,476 --> 00:31:31,026
Another common questions we
get at labs and mailing lists,


493
00:31:31,696 --> 00:31:36,496
it's like number of
lines in your document.


494
00:31:38,306 --> 00:31:39,496
It's really simple.


495
00:31:41,136 --> 00:31:44,346
But it was actually
difficult before Text Kit.


496
00:31:45,666 --> 00:31:49,576
With the Text Kits, since
NSLayoutManager keeps tracks


497
00:31:49,726 --> 00:31:55,396
of all the line fragment rect in
your documents, it's easy now.


498
00:31:56,356 --> 00:32:01,396
Remember, a visual
line could be divided


499
00:32:01,396 --> 00:32:05,696
into multiple line fragments
because of the exclusion path.


500
00:32:06,656 --> 00:32:12,756
You want to store the Y location
of the line fragment and using


501
00:32:12,756 --> 00:32:15,946
that cache value,
you want to compare


502
00:32:15,946 --> 00:32:19,346
to the current line fragment
rect before answering


503
00:32:19,346 --> 00:32:21,546
incremental number of lines.


504
00:32:23,976 --> 00:32:27,256
Here using the glyph
range for Text Container,


505
00:32:28,556 --> 00:32:33,456
you can get the glyph range
inside the Text Container and,


506
00:32:33,616 --> 00:32:37,206
you know, you should get
used to this method by now,


507
00:32:37,706 --> 00:32:41,156
lineFragmentRectForGlyphAtIndex
effectiveRange.


508
00:32:41,756 --> 00:32:49,206
And as I described it earlier,
you can pass a point out to--


509
00:32:49,366 --> 00:32:55,896
a point out to NSRange and
get back the glyph range


510
00:32:55,976 --> 00:32:58,146
corresponding to the
line fragment rect.


511
00:32:58,696 --> 00:33:04,316
And here we are enumerating all
the line fragment rect inside


512
00:33:04,606 --> 00:33:13,536
the fixed container by comparing
the stored last line fragment


513
00:33:13,536 --> 00:33:16,466
origin to the current
line fragment origin.


514
00:33:17,426 --> 00:33:22,176
If the new origin is larger,
that means you are moved


515
00:33:22,176 --> 00:33:26,156
to the new visual line so that
you can increment the number


516
00:33:26,216 --> 00:33:30,916
of lines like this.


517
00:33:31,706 --> 00:33:36,806
And at data stored
information was the new line


518
00:33:36,846 --> 00:33:37,636
fragment origin.


519
00:33:38,296 --> 00:33:39,256
It's that simple.


520
00:33:40,006 --> 00:33:44,136
We've seen glyphs and
layout informations stored


521
00:33:44,136 --> 00:33:48,716
in NSLayoutManager there
are endless possibilities


522
00:33:48,716 --> 00:33:55,646
that you can do with the broader
and finer controls you have


523
00:33:55,786 --> 00:34:00,426
in your text using
the information stored


524
00:34:00,426 --> 00:34:03,766
in NSLayoutManager and
you can freely access now.


525
00:34:04,466 --> 00:34:10,926
But the control over your
text doesn't end there.


526
00:34:11,146 --> 00:34:16,846
One of the main Text Kit
architecture strength is its


527
00:34:16,846 --> 00:34:19,485
vast support for customization.


528
00:34:19,815 --> 00:34:25,366
Let's look at how to customize
layout using Text Kit.


529
00:34:25,366 --> 00:34:30,726
NSLayoutManager provides a rich
set of delegation interface.


530
00:34:31,295 --> 00:34:36,585
You can-- With some of the
interface, you can get notified


531
00:34:38,016 --> 00:34:40,335
for step [phonetic]
change such as


532
00:34:40,956 --> 00:34:43,676
when your layout
cache is invited.


533
00:34:45,295 --> 00:34:50,386
Or, layout for the container was
finished, so on and so forth.


534
00:34:51,186 --> 00:34:53,936
With some other delegation
interface,


535
00:34:54,596 --> 00:34:58,226
you can override many aspects


536
00:34:58,226 --> 00:35:04,466
of layout process while
it's being laid out.


537
00:35:05,076 --> 00:35:10,066
For example, you can
override the line spacing.


538
00:35:10,196 --> 00:35:13,296
Your delegate object
gets consulted at the end


539
00:35:13,296 --> 00:35:16,146
of that every single
line fragment rect


540
00:35:17,076 --> 00:35:20,336
and you can provide
your own line spacing


541
00:35:20,586 --> 00:35:24,756
at that point overriding
their values stored


542
00:35:24,866 --> 00:35:27,636
in paragraph style
associated with that text.


543
00:35:29,096 --> 00:35:32,936
So for example, with that
paragraph style line spacing


544
00:35:32,936 --> 00:35:37,466
value, a single line
spacing value is used


545
00:35:37,466 --> 00:35:39,806
for the whole paragraph.


546
00:35:40,726 --> 00:35:45,856
But using this method,
you can have custom line


547
00:35:45,856 --> 00:35:47,056
spacing everywhere.


548
00:35:48,486 --> 00:35:53,416
And this is useful when
you want to make space


549
00:35:53,466 --> 00:36:01,036
for some other extra
rendering like this.


550
00:36:03,156 --> 00:36:08,196
[Inaudible] a lot annotation
when you want to have this kind


551
00:36:08,196 --> 00:36:13,616
of extra rendering right below
the text you want to make space


552
00:36:15,116 --> 00:36:19,386
and you don't know if you
want to make the space


553
00:36:20,376 --> 00:36:22,716
when you are creating
the text layout itself,


554
00:36:23,116 --> 00:36:25,006
so you have to determine
this kind


555
00:36:25,006 --> 00:36:30,906
of layout conditions dynamical
while you are laying out.


556
00:36:30,906 --> 00:36:37,786
Similar to the line
spacing, you can override


557
00:36:37,986 --> 00:36:44,786
with soft wrapping line--
soft wrapping lines at the end


558
00:36:44,786 --> 00:36:48,516
of every single soft
wrapping-- soft line breaking.


559
00:36:48,516 --> 00:36:52,186
So there it gets consulted.


560
00:37:00,556 --> 00:37:08,326
And by default, we are using
the line breaking logic provided


561
00:37:08,326 --> 00:37:11,716
by the Unicode standard,
so it should be sufficient


562
00:37:11,936 --> 00:37:17,636
for most cases, and it provides
a localized way of line breaking


563
00:37:17,696 --> 00:37:21,976
for every language
available on iOS.


564
00:37:22,606 --> 00:37:27,286
But in some few cases, you
want to enhance the ways


565
00:37:27,286 --> 00:37:30,946
of the line wrapping happens
for your typographic needs.


566
00:37:31,916 --> 00:37:35,666
In that case, you are
[inaudible] to override


567
00:37:36,146 --> 00:37:42,386
that line wrapping
phase like this.


568
00:37:42,586 --> 00:37:47,896
Another powerful feature
techniques you can use


569
00:37:47,946 --> 00:37:53,366
with delegation, by default,
NSLayoutManager uses the mapping


570
00:37:53,486 --> 00:37:57,896
between character and glyphs
stored inside the font itself.


571
00:37:57,896 --> 00:38:00,156
That's the default
glyph mapping.


572
00:38:01,906 --> 00:38:05,746
You can override this
glyph mapping all


573
00:38:05,746 --> 00:38:11,186
by yourself while it's
laying out of text.


574
00:38:11,996 --> 00:38:13,226
This is powerful.


575
00:38:13,226 --> 00:38:16,546
It's used by, for example,
bullet substitution


576
00:38:17,046 --> 00:38:22,376
in security mode or when you
want to hide some portion


577
00:38:22,376 --> 00:38:25,466
of text when you are
folding the line.


578
00:38:25,636 --> 00:38:31,646
And there are many,
many other ways


579
00:38:33,156 --> 00:38:36,586
to customize your text layout


580
00:38:37,216 --> 00:38:43,116
like a dynamic query
while it's being laid out.


581
00:38:43,406 --> 00:38:45,486
Today, I would like to look


582
00:38:45,486 --> 00:38:49,746
at the custom glyph
mapping a little farther.


583
00:38:50,046 --> 00:38:54,726
When you had text and
the text doesn't fit


584
00:38:54,726 --> 00:38:59,446
into the available space,
it's a common technique used


585
00:39:00,336 --> 00:39:03,856
to tail truncation like this.


586
00:39:04,056 --> 00:39:07,386
But with the simple
tail truncation logic,


587
00:39:08,056 --> 00:39:14,936
you might encounter, the actual
important information might be


588
00:39:15,016 --> 00:39:18,526
truncated out from
the user's view.


589
00:39:19,836 --> 00:39:21,386
You don't like that.


590
00:39:23,296 --> 00:39:26,546
So using the custom
glyph generation logic,


591
00:39:27,366 --> 00:39:33,776
you can override and add
additional truncation range


592
00:39:34,436 --> 00:39:39,776
to your string and make
sure your important range


593
00:39:39,776 --> 00:39:42,426
of text is visible to the user.


594
00:39:42,946 --> 00:39:45,506
Let's see how we
can accomplish that.


595
00:39:45,616 --> 00:39:51,646
First, with NSLayout method--
NSLayoutManager method,


596
00:39:52,746 --> 00:39:57,576
truncatedGlyphRangeInLine
FragmentForGlyphAtIndex method,


597
00:39:58,576 --> 00:40:02,946
you can get the range of the
glyphs that's being truncated


598
00:40:02,946 --> 00:40:07,716
out from the user's view.


599
00:40:09,376 --> 00:40:14,366
And you can compare this
range with your focus range,


600
00:40:14,756 --> 00:40:17,436
for example, when you
are searching some words,


601
00:40:17,976 --> 00:40:23,046
you want to keep the-- match the
words inside the user's view.


602
00:40:24,566 --> 00:40:26,656
When it matches this range,


603
00:40:27,176 --> 00:40:30,586
you want to truncate
additional location.


604
00:40:31,016 --> 00:40:36,116
In that case, we estimate the
additional truncation range


605
00:40:37,636 --> 00:40:42,606
probably using the
[inaudible] being truncated out.


606
00:40:43,986 --> 00:40:45,266
Now we layout.


607
00:40:45,966 --> 00:40:52,536
Inside the layout process, your
delegate method, layoutManager:


608
00:40:52,536 --> 00:40:57,306
shouldGenerateGlyphs:
properties:characterIndexes:


609
00:40:57,306 --> 00:41:01,036
font:forGlyphRange
method get being called.


610
00:41:01,696 --> 00:41:05,566
And inside this method, you
can override the default


611
00:41:05,566 --> 00:41:06,266
glyph mapping.


612
00:41:06,896 --> 00:41:10,356
So, you can do whatever
you want.


613
00:41:10,916 --> 00:41:19,506
In this case, we substitute
the default glyph mapping


614
00:41:19,996 --> 00:41:21,106
with [inaudible]
glyphs and truncate.


615
00:41:21,106 --> 00:41:24,906
It's that simple.


616
00:41:26,676 --> 00:41:31,426
And repeat itself until
you find the ideal range


617
00:41:31,936 --> 00:41:33,046
that fits everything.


618
00:41:33,396 --> 00:41:36,476
Well then let's take a look
at the delegate method itself.


619
00:41:36,896 --> 00:41:39,316
The delegate method is called


620
00:41:39,706 --> 00:41:44,606
for all the text ranges
inside your Text Storage


621
00:41:45,196 --> 00:41:49,276
when it gets mapped to glyphs.


622
00:41:49,276 --> 00:41:53,486
It receives glyph's
properties and character indexes


623
00:41:54,836 --> 00:41:56,096
for the chunk of text.


624
00:41:57,686 --> 00:41:59,506
And this is a default
information


625
00:41:59,796 --> 00:42:02,356
and you can override
any way you want


626
00:42:02,626 --> 00:42:06,276
until you have your delegate
object and your implementation


627
00:42:06,466 --> 00:42:09,156
of the delegate method.


628
00:42:09,316 --> 00:42:12,096
You will see a chunk of glyphs.


629
00:42:17,436 --> 00:42:22,596
Look through it and you
find a particular range


630
00:42:22,716 --> 00:42:28,176
of glyph matches your focus
range and you can check


631
00:42:28,356 --> 00:42:31,696
against using the
original character index.


632
00:42:32,286 --> 00:42:38,226
When that happens,
you override pass


633
00:42:38,476 --> 00:42:41,816
in glyphs information
with ellipsis glyph.


634
00:42:48,706 --> 00:42:54,316
And you might wonder what are
these things after ellipsis.


635
00:42:55,616 --> 00:42:58,886
In order to keep the character
and glyph index simple


636
00:42:58,986 --> 00:43:02,836
and be efficient,
NSLayoutManager often try


637
00:43:02,836 --> 00:43:07,666
to pad the glyph range that's
being hidden from the users.


638
00:43:08,366 --> 00:43:13,346
To do so, the glyph
property is working here.


639
00:43:13,346 --> 00:43:15,176
What is the glyph property?


640
00:43:16,656 --> 00:43:18,476
So it's like other
glyph information.


641
00:43:18,846 --> 00:43:23,566
Glyph NSLayoutManager keeps
track of glyph property


642
00:43:23,646 --> 00:43:29,436
for glyph and it stores semantic
behavior for each glyph.


643
00:43:29,746 --> 00:43:34,166
For example, you can identify
a glyph as a control character


644
00:43:34,296 --> 00:43:37,196
like a tab or a new
line, so on and so forth.


645
00:43:38,246 --> 00:43:44,416
Or, a glyph could be white space
that can be treated as elastic


646
00:43:44,416 --> 00:43:47,626
at the end of the line break.


647
00:43:48,546 --> 00:43:52,806
In our example, we are
using this property,


648
00:43:53,226 --> 00:43:56,906
NSGlyphPropertyNull, by
displaying this property,


649
00:43:57,456 --> 00:44:02,806
the glyph will be treated
as the glyph will be ignored


650
00:44:02,806 --> 00:44:05,366
from both layout and rendering.


651
00:44:06,466 --> 00:44:08,176
So, you can hide a part


652
00:44:08,176 --> 00:44:10,476
of the glyph range
from the user's view.


653
00:44:10,886 --> 00:44:17,966
Now, I'd like to point
our Text Kit demo maester,


654
00:44:18,976 --> 00:44:24,486
Jordan Breeding to show that
multiple truncations demo.


655
00:44:25,436 --> 00:44:25,876
Jordan.


656
00:44:25,876 --> 00:44:30,516
>> So, what I'm going to
show you right now is a view


657
00:44:30,516 --> 00:44:32,776
controller inside of our
demo shell that we used


658
00:44:32,776 --> 00:44:34,196
in the Intro session as well.


659
00:44:35,666 --> 00:44:38,046
In this case, instead
of using a UITextView,


660
00:44:38,046 --> 00:44:43,156
we're actually using a new
class, a text rendering view.


661
00:44:44,206 --> 00:44:47,116
This is a UIView subclass
in which we are going


662
00:44:47,116 --> 00:44:50,086
to render the glyphs ourselves
to achieve multiple truncation.


663
00:44:51,336 --> 00:44:53,616
First, I'll show
you at running live


664
00:44:53,696 --> 00:44:57,986
and then we'll explain
what some of the code does.


665
00:44:58,186 --> 00:45:02,526
Now we're building and running.


666
00:45:02,656 --> 00:45:05,306
And when we run the
demo, you'll notice


667
00:45:05,306 --> 00:45:06,936
that we have highlighted
the range


668
00:45:06,936 --> 00:45:10,226
so that we are concerned
about not truncating.


669
00:45:10,776 --> 00:45:18,306
And as we get closer and
closer to that, you'll notice


670
00:45:19,166 --> 00:45:21,656
that it automatically starts
to truncate to the left


671
00:45:22,626 --> 00:45:26,656
so that we keep it intact.


672
00:45:26,936 --> 00:45:28,236
So, how do we do that?


673
00:45:28,826 --> 00:45:30,856
Well, in the text
rendering view,


674
00:45:31,166 --> 00:45:33,196
we actually made a new
class called a focus


675
00:45:33,196 --> 00:45:34,266
truncation renderer.


676
00:45:34,876 --> 00:45:36,646
We setup an instance
variable for that.


677
00:45:36,646 --> 00:45:40,506
And then awakeFromNib,
we actually setup some


678
00:45:40,506 --> 00:45:43,026
of our data including
the focus range


679
00:45:43,026 --> 00:45:45,426
that we are concerned
with keeping intact.


680
00:45:46,866 --> 00:45:50,446
Then in our draw rect, we
setup some basic information


681
00:45:50,446 --> 00:45:52,226
and then we also
tell our renderer


682
00:45:52,726 --> 00:45:57,636
to use each drawing rect
to draw in the same place.


683
00:45:57,796 --> 00:46:00,536
So if we go over to our
focus truncation renderer,


684
00:46:01,646 --> 00:46:03,526
you'll notice that when
we setup the contents


685
00:46:03,576 --> 00:46:07,326
for the Text Storage,
we also set ourselves


686
00:46:07,326 --> 00:46:09,636
as the Layout Manager's
delegate right here.


687
00:46:11,976 --> 00:46:18,526
The reason that we do that
is then in our draw and rect,


688
00:46:19,166 --> 00:46:23,986
when we actually draw
all of our characters


689
00:46:24,956 --> 00:46:27,696
and we know whether we need
to force tail truncation


690
00:46:28,136 --> 00:46:32,016
and truncate ahead of time
or not, all of this calls


691
00:46:32,016 --> 00:46:35,616
to Layout Manager will actually
consult us for glyph generation.


692
00:46:39,216 --> 00:46:43,736
So, all these calls
end up calling


693
00:46:43,736 --> 00:46:44,956
down into our delegate method.


694
00:46:45,536 --> 00:46:48,386
In this case, layoutManager:
shouldGenerateGlyphs:


695
00:46:48,576 --> 00:46:51,426
properties:characterIndexes:
font:forGlyphRange.


696
00:46:51,666 --> 00:46:53,026
This is the method Aki pointed


697
00:46:53,026 --> 00:46:55,226
out for laying out
custom glyphs.


698
00:46:56,076 --> 00:46:58,256
So, what are we actually
doing here?


699
00:46:58,976 --> 00:47:00,066
Well, first, we're finding


700
00:47:00,066 --> 00:47:01,916
out if we have an
intersection range.


701
00:47:03,526 --> 00:47:07,066
And then in our actual code,


702
00:47:07,066 --> 00:47:11,006
we're checking the character
indexes that we've been passed


703
00:47:11,066 --> 00:47:12,216
by the Layout Manager.


704
00:47:12,896 --> 00:47:16,776
And if they're inside the target
range, we know that we need


705
00:47:16,776 --> 00:47:18,206
to use the ellipsis glyph.


706
00:47:19,466 --> 00:47:21,666
So, we get the character
for the ellipsis glyph


707
00:47:21,726 --> 00:47:24,376
and then we get the
glyph for the characters


708
00:47:24,376 --> 00:47:26,156
and then we actually
do the replacement.


709
00:47:27,296 --> 00:47:28,886
Then, just like Aki said,


710
00:47:29,386 --> 00:47:32,966
we actually change the other
glyph character properties


711
00:47:33,026 --> 00:47:37,356
to be the control character
and the null character


712
00:47:37,356 --> 00:47:39,586
so that everything just
lays out automatically


713
00:47:39,656 --> 00:47:41,886
for us in our draw rect.


714
00:47:42,586 --> 00:47:45,216
It's actually just
as simple as that.


715
00:47:45,316 --> 00:47:47,086
It was a lot harder
before, right?


716
00:47:48,226 --> 00:47:51,506
Next, I'd like to have
Aki come back up and close


717
00:47:51,506 --> 00:47:52,556
out our session for us.


718
00:47:53,126 --> 00:47:56,746
>> We saw you can use
the gorgeous text layouts


719
00:47:56,746 --> 00:47:58,376
in your applications.


720
00:47:58,876 --> 00:48:05,996
And you learned how to
achieve multiple page,


721
00:48:05,996 --> 00:48:09,046
multiple document
configuration easy--


722
00:48:09,776 --> 00:48:14,376
easily with the application.


723
00:48:14,376 --> 00:48:21,546
And we covered the rich in text
layout information provided


724
00:48:22,306 --> 00:48:26,676
through the NSLayoutManager API.


725
00:48:27,046 --> 00:48:36,926
And finally, we saw some aspect
of the Text Kit customizability


726
00:48:37,846 --> 00:48:40,436
that was previously
not possible.


727
00:48:42,536 --> 00:48:51,436
So, Text Kit is not just another
text API you need to learn.


728
00:48:51,986 --> 00:48:55,946
With the deep integration
with UIKit,


729
00:48:57,246 --> 00:49:01,316
comprehensive functionalities
and broad customizability,


730
00:49:02,696 --> 00:49:08,036
we believe it will be the last


731
00:49:08,036 --> 00:49:12,296
and only text API even be
working for years to come.


732
00:49:13,066 --> 00:49:16,386
If you want to know more,


733
00:49:16,386 --> 00:49:19,556
you can contact our
evangelist, Jake Behrens.


734
00:49:20,346 --> 00:49:24,086
And we have two related
sessions,


735
00:49:24,476 --> 00:49:28,606
one already happened
yesterday and another coming


736
00:49:28,666 --> 00:49:31,726
up tomorrow morning
at 9:00 at Presidio.


737
00:49:33,076 --> 00:49:35,126
And that's going to talk


738
00:49:35,126 --> 00:49:39,096
about the technology
behind the dynamic type.


739
00:49:39,436 --> 00:49:42,046
And if you want to know how


740
00:49:42,046 --> 00:49:46,306
to utilize all the cool
technologies such as UIFont


741
00:49:46,306 --> 00:49:49,166
and UIFont Descriptor,
you want to be there.


742
00:49:49,346 --> 00:49:53,836
So, thank you and enjoy
the rest of the conference.


743
00:49:54,516 --> 00:49:58,480
[ Applause ]

