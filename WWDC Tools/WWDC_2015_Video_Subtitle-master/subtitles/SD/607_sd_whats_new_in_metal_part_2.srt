1
00:00:22,516 --> 00:00:28,026
[ Applause ]


2
00:00:28,526 --> 00:00:30,126
>> DAN OMACHI: Good morning,
welcome to the second part


3
00:00:30,126 --> 00:00:31,816
of our What's New in
Metal presentation.


4
00:00:32,036 --> 00:00:33,436
My name is Dan Omachi.


5
00:00:33,866 --> 00:00:36,616
I'm an engineer in Apple's
GPU software frameworks team.


6
00:00:37,206 --> 00:00:40,226
Today my colleague Anna
Tikhonova and I will talk


7
00:00:40,226 --> 00:00:42,756
about technologies
that build upon Metal,


8
00:00:43,166 --> 00:00:46,266
helping you deliver great
rendering experiences


9
00:00:46,376 --> 00:00:49,136
on both iOS and OS X.


10
00:00:50,416 --> 00:00:53,506
So this is the second
of three sessions


11
00:00:53,606 --> 00:00:56,586
at this years WWDC
talking about Metal.


12
00:00:57,546 --> 00:01:01,386
In the first session, Rob
Duraf talked about developments


13
00:01:01,386 --> 00:01:03,266
in Metal that have
happened in the past year.


14
00:01:04,025 --> 00:01:06,206
He also described some
of the new features


15
00:01:06,206 --> 00:01:08,096
in Metal we just released.


16
00:01:09,476 --> 00:01:12,686
He also described how app
thinning is a great match


17
00:01:12,816 --> 00:01:14,316
for your Metal applications.


18
00:01:14,856 --> 00:01:19,496
In this session, I will be
up here first to talk to you


19
00:01:19,496 --> 00:01:23,886
about MetalKit, convenience
APIs allowing you bring


20
00:01:23,886 --> 00:01:26,556
up Metal applications
much more quickly.


21
00:01:27,486 --> 00:01:30,026
Then Anna will come up to talk


22
00:01:30,026 --> 00:01:32,356
about Metal performance
shaders framework,


23
00:01:32,956 --> 00:01:36,086
which offers great shaders


24
00:01:36,806 --> 00:01:40,276
for common data parallel
operations available


25
00:01:40,276 --> 00:01:42,666
on iOS devices with
an A8 processor.


26
00:01:43,186 --> 00:01:46,636
And tomorrow, you
will get a chance


27
00:01:47,036 --> 00:01:50,416
to catch the Metal Performance
Optimization Techniques session,


28
00:01:50,886 --> 00:01:54,346
where they will introduce
the Metal System Trace Tool


29
00:01:54,926 --> 00:01:57,396
and provide you with
some best practices


30
00:01:57,796 --> 00:02:00,356
for shipping an efficient
Metal application.


31
00:02:00,356 --> 00:02:04,966
So let's get started
with Metal kit.


32
00:02:05,226 --> 00:02:08,186
Utility functionality
for your Metal apps.


33
00:02:09,616 --> 00:02:13,586
So because Metal is a low
level API, there are a number


34
00:02:13,586 --> 00:02:17,616
of things you need to do
to get up and running.


35
00:02:17,766 --> 00:02:20,346
MetalKit hopes to help with this


36
00:02:20,346 --> 00:02:22,596
by providing efficient
implementation


37
00:02:22,856 --> 00:02:24,956
for commonly used scenarios.


38
00:02:25,466 --> 00:02:28,576
This requires less effort
on your part to get up


39
00:02:28,576 --> 00:02:31,936
and rendering and we offer
increased performance


40
00:02:32,056 --> 00:02:35,676
and stability over the
standard boilerplate code


41
00:02:35,866 --> 00:02:37,416
that you might implement
yourself.


42
00:02:38,156 --> 00:02:41,246
There is less maintenance
for you as the burden


43
00:02:41,246 --> 00:02:45,786
of that maintenance has
been shifted from you to us.


44
00:02:46,046 --> 00:02:49,966
So MetalKit consists of
three main components.


45
00:02:50,926 --> 00:02:53,236
First is the MetalKit view.


46
00:02:53,506 --> 00:02:57,656
A unified view class
between iOS and OS X


47
00:02:58,206 --> 00:02:59,596
for rendering your Metal scenes.


48
00:03:01,126 --> 00:03:05,666
Second is the texture loader
which creates texture objects


49
00:03:06,016 --> 00:03:08,576
from image files on disk.


50
00:03:09,966 --> 00:03:14,556
And finally, Metal kit's model
I/O integration which loads


51
00:03:14,676 --> 00:03:17,176
and manages mesh data
from Metal rendering.


52
00:03:20,506 --> 00:03:23,366
MetalKit view is
the simplest way


53
00:03:23,486 --> 00:03:25,556
to get Metal rendering
on screen.


54
00:03:26,136 --> 00:03:31,746
It's a unified class
on both iOS and OS X.


55
00:03:32,006 --> 00:03:34,146
It offers pretty much
the same interface


56
00:03:34,406 --> 00:03:37,546
on both Operating Systems,
but naturally it's a subclass


57
00:03:37,546 --> 00:03:42,956
of UI view for iOS and a
subclass of NS view on OS X.


58
00:03:43,456 --> 00:03:48,126
Its main job is to manage
displayable render targets


59
00:03:48,126 --> 00:03:51,276
for you, and it creates
render path descriptors


60
00:03:51,326 --> 00:03:53,536
for these render
targets automatically.


61
00:03:53,536 --> 00:03:58,906
Now, it's super flexible
in terms of the ways


62
00:03:59,276 --> 00:04:02,206
that it can execute
your draw code.


63
00:04:03,436 --> 00:04:05,676
You can use a timer-based mode


64
00:04:06,206 --> 00:04:09,056
where it will execute your
draw code at a regular interval


65
00:04:09,456 --> 00:04:11,416
in synchronization
with a display,


66
00:04:12,806 --> 00:04:14,366
or you can use an
event-based mode


67
00:04:14,366 --> 00:04:16,776
which will trigger your
draw code whenever a touch


68
00:04:16,826 --> 00:04:19,836
or UI event has occurred, so
you can respond to that event.


69
00:04:21,055 --> 00:04:23,836
Finally, you can explicitly
drive your draw code,


70
00:04:24,156 --> 00:04:27,066
perhaps in an open loop
on a secondary thread


71
00:04:27,686 --> 00:04:29,096
at your own frame rate.


72
00:04:29,726 --> 00:04:35,676
So there are two approaches
to using the MetalKit view.


73
00:04:37,146 --> 00:04:39,586
The simplest approach is
to implement a delegate


74
00:04:39,716 --> 00:04:42,556
to handle your draw
and resize operations.


75
00:04:43,336 --> 00:04:45,756
In this case, you would
implement the draw


76
00:04:45,756 --> 00:04:50,386
in view method to handle your
per-frame updates including


77
00:04:50,726 --> 00:04:52,456
encoding any rendering commands.


78
00:04:53,846 --> 00:04:56,006
You would also implement
the view will layout


79
00:04:56,126 --> 00:05:00,836
with size method to handle
size changes to your view.


80
00:05:01,466 --> 00:05:04,696
This is where you might
update your projection matrix


81
00:05:05,016 --> 00:05:06,966
or change any texture sizes


82
00:05:06,996 --> 00:05:09,366
to better fit your
displayable area.


83
00:05:10,836 --> 00:05:14,566
Now, if you have any other
pieces of the view that you need


84
00:05:14,566 --> 00:05:18,536
to override, you can
subclass the MetalKit view.


85
00:05:18,926 --> 00:05:20,896
And in this case on iOS,


86
00:05:21,666 --> 00:05:23,566
you would override
the draw Rect method


87
00:05:25,126 --> 00:05:26,466
to handle your per-frame updates


88
00:05:27,336 --> 00:05:30,346
and the layout subviews
method to handle resizes.


89
00:05:31,156 --> 00:05:33,706
Likewise on OS X
you would handle,


90
00:05:34,106 --> 00:05:36,516
you would override these
two methods, the draw Rect


91
00:05:36,516 --> 00:05:38,606
and set frame size method.


92
00:05:39,316 --> 00:05:49,756
So here is an example of
setting up a view controller


93
00:05:49,946 --> 00:05:53,166
that also serves as the
delegate to our view.


94
00:05:54,446 --> 00:05:58,896
In the view did load method,
after we received a reference


95
00:05:59,106 --> 00:06:02,976
to the view, we will assign
ourself as the delegate,


96
00:06:04,306 --> 00:06:11,516
and particularly important on OS
X is that we will need to choose


97
00:06:11,516 --> 00:06:13,376
and set a Metal device.


98
00:06:13,976 --> 00:06:18,136
Once we are done with
that, we can configure some


99
00:06:18,136 --> 00:06:21,186
of the view's properties
including choosing our own


100
00:06:21,186 --> 00:06:23,576
custom pixel formats
for the color


101
00:06:23,576 --> 00:06:24,836
and depth and stencil buffers.


102
00:06:25,516 --> 00:06:28,496
We can use multisampling


103
00:06:28,706 --> 00:06:32,336
by increasing the sample count
property to a value above 1,


104
00:06:32,336 --> 00:06:41,036
or we can set our
custom clear color.


105
00:06:41,196 --> 00:06:45,626
Now, here is a very basic
usage of the MetalKit view


106
00:06:45,796 --> 00:06:48,566
in the implementation
of the per frame update.


107
00:06:49,506 --> 00:06:53,336
In our drawing view method,
we call the views render,


108
00:06:53,336 --> 00:06:55,466
I'm sorry, current
render past descriptor.


109
00:06:55,966 --> 00:06:59,666
Now, the first time you access
this property each frame,


110
00:07:00,086 --> 00:07:02,516
the view will call
into core animation


111
00:07:02,816 --> 00:07:04,646
and get a drawable back,


112
00:07:05,256 --> 00:07:07,406
which you can encode
your rendering commands


113
00:07:07,406 --> 00:07:08,076
and render to.


114
00:07:08,686 --> 00:07:12,956
So we will render our
final render pass,


115
00:07:13,466 --> 00:07:15,196
which will show up
in this drawable.


116
00:07:15,726 --> 00:07:18,996
And then we will present the
drawable, which is stored


117
00:07:18,996 --> 00:07:20,736
in the view's current
drawable property


118
00:07:21,796 --> 00:07:24,866
and we will commit
our command buffer.


119
00:07:25,036 --> 00:07:26,776
Now, because of its importance


120
00:07:27,296 --> 00:07:30,396
in structuring your per-frame
updates, let me take a minute


121
00:07:30,656 --> 00:07:32,896
to talk about managing
these drawables.


122
00:07:33,586 --> 00:07:36,906
So there are a limited
pool of drawables


123
00:07:37,436 --> 00:07:40,026
in this system all
managed by core animation.


124
00:07:41,556 --> 00:07:44,246
There are only a few of them
mostly because of their size,


125
00:07:44,246 --> 00:07:45,456
they take up some space.


126
00:07:46,556 --> 00:07:49,346
Now, these drawables
are concurrently used


127
00:07:49,346 --> 00:07:52,456
through many stages of
the display pipeline.


128
00:07:53,916 --> 00:07:55,206
Here is roughly how it works.


129
00:07:55,656 --> 00:07:57,706
First, your application
encodes commands


130
00:07:57,706 --> 00:07:58,926
to be rendered onto
the drawable.


131
00:08:00,016 --> 00:08:02,216
It sends that drawable
down to the GPU


132
00:08:02,596 --> 00:08:05,656
as your application encodes
commands for the next frame


133
00:08:05,876 --> 00:08:09,766
and the GPU renders to that
drawable, and core animation


134
00:08:09,766 --> 00:08:11,666
at this stage may do compositing


135
00:08:11,666 --> 00:08:15,026
with other layers
into that drawable.


136
00:08:15,636 --> 00:08:19,726
And finally, the display
can take the drawable


137
00:08:19,726 --> 00:08:21,016
and slap it up onto the screen.


138
00:08:21,966 --> 00:08:24,086
Now, the display can't
replace it with anything


139
00:08:24,086 --> 00:08:25,806
until another drawable
is available.


140
00:08:26,106 --> 00:08:29,106
So if any of these previous
stages are taking a lot of time,


141
00:08:29,416 --> 00:08:31,166
it just has to sit
there for awhile.


142
00:08:31,606 --> 00:08:36,876
Additionally, the display can't
recycle that drawable back


143
00:08:36,876 --> 00:08:39,015
up to your frame until it
has something available.


144
00:08:39,015 --> 00:08:44,986
So let's take a look at
your application frame


145
00:08:45,436 --> 00:08:47,456
with respect to these drawables.


146
00:08:48,936 --> 00:08:51,796
First, you call the MetalKit
views current render past


147
00:08:51,796 --> 00:08:54,166
descriptor which
reserves a drawable.


148
00:08:54,166 --> 00:08:59,176
Then you will encode rendering
commands that you want


149
00:08:59,176 --> 00:09:02,136
into that drawable, and
finally you will present


150
00:09:02,236 --> 00:09:03,196
and commit the drawable


151
00:09:03,396 --> 00:09:06,366
which will release it
back to core animation.


152
00:09:06,926 --> 00:09:11,266
Now, this is fine if all we
are doing is rendering a single


153
00:09:11,266 --> 00:09:13,156
render pass, however,


154
00:09:13,156 --> 00:09:16,246
it's likely we will
do other operations


155
00:09:16,856 --> 00:09:24,216
such as some app logic, encoding
in offscreen render pass


156
00:09:24,456 --> 00:09:28,076
where we don't actually
need the drawable,


157
00:09:28,076 --> 00:09:31,166
or running some compute
kernels for physics or whatnot.


158
00:09:31,716 --> 00:09:36,426
In this case we are
essentially hogging the drawable


159
00:09:36,426 --> 00:09:39,216
from our future self because
in a subsequent frame,


160
00:09:39,216 --> 00:09:41,816
we will call this current
render pass descriptor


161
00:09:42,256 --> 00:09:44,996
and it will sit there
waiting for a drawable


162
00:09:44,996 --> 00:09:47,176
to become available,
which may not be the case


163
00:09:47,176 --> 00:09:50,936
because we are doing these other
operations and reserving it


164
00:09:50,936 --> 00:09:52,186
for much longer than we need to.


165
00:09:52,606 --> 00:09:54,086
So to solve this problem,


166
00:09:54,876 --> 00:09:58,136
let's put these operations
before our access


167
00:09:58,246 --> 00:09:59,906
to the current render
pass descriptor.


168
00:10:00,436 --> 00:10:04,306
Now, let me just note that
this isn't a problem specific


169
00:10:04,396 --> 00:10:05,536
to the MetalKit view.


170
00:10:05,896 --> 00:10:08,816
You need to be aware of this
issue if you roll your own view


171
00:10:09,066 --> 00:10:11,056
in access core animation
directly.


172
00:10:12,126 --> 00:10:17,656
So this is information that's
quite useful in any case.


173
00:10:18,526 --> 00:10:20,846
Now, here is a more
complete example


174
00:10:20,846 --> 00:10:22,806
of our per-frame
rendering update.


175
00:10:23,816 --> 00:10:27,316
First, as I described we want to
update our app's render state,


176
00:10:28,046 --> 00:10:29,866
encode any offscreen passes,


177
00:10:30,166 --> 00:10:31,986
do anything where we
don't need the drawable.


178
00:10:32,576 --> 00:10:36,266
And then we can continue
as we did previously,


179
00:10:36,266 --> 00:10:39,256
get the current render pass
descriptor, encode our commands


180
00:10:39,256 --> 00:10:41,996
for that final pass, and present
and commit our command buffer.


181
00:10:42,996 --> 00:10:46,166
The key point is that
these two stages should be


182
00:10:46,166 --> 00:10:48,236
as close together as possible.


183
00:10:49,016 --> 00:10:52,166
It's a critical section where
we are holding onto a resource


184
00:10:52,736 --> 00:10:57,386
and we don't want to hold onto
it any longer than we need to.


185
00:10:57,626 --> 00:10:58,476
That's it for the view.


186
00:11:00,216 --> 00:11:01,886
Let's move on to
the texture loader.


187
00:11:02,476 --> 00:11:06,036
It's textural loading
made simple.


188
00:11:07,096 --> 00:11:11,336
You give a reference and
you get back a fully formed


189
00:11:11,666 --> 00:11:12,446
Metal Texture.


190
00:11:13,006 --> 00:11:18,586
Not only is it simple, it's
fast and fully featured.


191
00:11:19,656 --> 00:11:22,226
It asynchronously decodes files


192
00:11:22,976 --> 00:11:26,486
and creates textures
on a separate thread.


193
00:11:27,936 --> 00:11:31,376
It has support for many common
image file formats including


194
00:11:31,376 --> 00:11:36,076
JPG, TIF and PNG and
also supports the PVR


195
00:11:36,336 --> 00:11:38,646
and KTX texture file formats.


196
00:11:38,996 --> 00:11:43,026
What's interesting about these
formats is that they store data


197
00:11:43,296 --> 00:11:47,166
in a raw form that can be
uploaded to your Metal Texture


198
00:11:47,166 --> 00:11:48,516
without any conversion.


199
00:11:49,516 --> 00:11:54,996
Additionally, you can encode
data for MIT maps for any


200
00:11:55,146 --> 00:11:58,896
of the other types of
textures including 3D textures,


201
00:11:59,336 --> 00:12:01,886
cube maps, and texture arrays.


202
00:12:05,716 --> 00:12:07,206
Its usage is really simple.


203
00:12:08,716 --> 00:12:10,976
First, we create a
texture loader object


204
00:12:11,416 --> 00:12:13,386
by supplying a device.


205
00:12:14,916 --> 00:12:17,586
Then, once we have that
texture loader object,


206
00:12:17,586 --> 00:12:20,356
we can create many
textures with it.


207
00:12:21,196 --> 00:12:26,116
First, we will give a URL
location of our image file,


208
00:12:26,786 --> 00:12:29,996
and we can supply a number of
options including how we want


209
00:12:29,996 --> 00:12:33,886
to treat the sRGB information
in the file or whether


210
00:12:33,886 --> 00:12:36,136
or not we want to allocate
memory for MIT maps


211
00:12:36,546 --> 00:12:37,866
when we create this texture,


212
00:12:38,496 --> 00:12:42,426
and finally we will supply
a completion handler block.


213
00:12:42,936 --> 00:12:45,526
Now, this block will
get executed as soon


214
00:12:45,526 --> 00:12:48,206
as the texture loader has
finished loading the texture


215
00:12:48,276 --> 00:12:49,086
and created it.


216
00:12:49,166 --> 00:12:51,056
It will pass the texture
handler back to you


217
00:12:51,096 --> 00:12:54,086
which you can stash away
for later and render


218
00:12:54,086 --> 00:12:57,166
with when you need to.


219
00:12:57,356 --> 00:12:59,396
That's very simple,
the texture loader.


220
00:12:59,506 --> 00:13:02,686
Let's move on to model I/O.


221
00:13:04,496 --> 00:13:07,236
So model I/0 is a new
framework introduced


222
00:13:07,236 --> 00:13:09,396
with iOS 9 and OS X El Capitan.


223
00:13:11,236 --> 00:13:13,246
And one of its key features is


224
00:13:13,246 --> 00:13:17,696
that it can load many
model file formats for you.


225
00:13:19,006 --> 00:13:22,336
You can create your own
importers and exporters


226
00:13:22,366 --> 00:13:25,056
for proprietary formats
if you need to.


227
00:13:25,056 --> 00:13:28,776
Some of the cooler
features here are


228
00:13:28,776 --> 00:13:32,806
that you can do offline
baking operations.


229
00:13:32,806 --> 00:13:36,286
You can create static
ambient occlusion maps,


230
00:13:36,826 --> 00:13:40,856
light map generations, it
also includes the Voxelization


231
00:13:40,956 --> 00:13:41,656
of your meshes.


232
00:13:42,256 --> 00:13:48,536
It provides you a way to
focus on your rendering code


233
00:13:48,536 --> 00:13:49,636
and write your shaders.


234
00:13:49,706 --> 00:13:52,346
You don't have to deal
with creating some parchers


235
00:13:52,346 --> 00:13:53,766
to get some stuff off disk.


236
00:13:53,766 --> 00:13:57,106
You have to deal less
with serialization,


237
00:13:57,776 --> 00:14:00,606
you just load a model
file with Model I/O,


238
00:14:01,636 --> 00:14:03,566
put it into some form
you can render it with,


239
00:14:04,246 --> 00:14:06,596
and start writing your shaders.


240
00:14:06,596 --> 00:14:12,216
So what does MetalKit
provide in this context?


241
00:14:12,216 --> 00:14:15,456
It's utilities to efficiently
use model I/O with Metal.


242
00:14:16,796 --> 00:14:19,636
It offers optimized
loading of model I/O meshes


243
00:14:19,636 --> 00:14:23,786
into Metal buffers, the
encapsulation of mesh data


244
00:14:24,206 --> 00:14:28,606
within MetalKit objects, and
there are a number of functions


245
00:14:28,606 --> 00:14:31,676
to prepare mesh data
for Metal pipelines.


246
00:14:32,326 --> 00:14:40,356
Let me walk you through the
process of loading a model file


247
00:14:41,426 --> 00:14:46,026
with model I/O and getting it
rendering on screen with Metal.


248
00:14:46,596 --> 00:14:53,626
And here are the
steps we will take.


249
00:14:53,846 --> 00:14:58,986
So first, we will create a
Metal render state pipeline


250
00:14:58,986 --> 00:15:01,866
that we'll use to create our
mesh, to render our mesh.


251
00:15:02,406 --> 00:15:06,256
Then we will actually
load the model file


252
00:15:06,336 --> 00:15:09,426
by initializing the
model I/O asset.


253
00:15:10,456 --> 00:15:14,506
And with that asset, we
will create MetalKit mesh


254
00:15:14,506 --> 00:15:16,076
and sub mesh objects.


255
00:15:17,496 --> 00:15:20,416
Finally, we will render
those objects with Metal.


256
00:15:22,216 --> 00:15:26,146
So let's focus on creating a
Metal Render State Pipeline


257
00:15:27,316 --> 00:15:29,436
and we will pay particular
attention


258
00:15:29,756 --> 00:15:33,356
to creating a vertex descriptor
that will describe the layout


259
00:15:33,356 --> 00:15:36,326
of vertices that we'll
need our mesh to be


260
00:15:36,326 --> 00:15:40,086
in to feed our pipeline.


261
00:15:40,086 --> 00:15:43,226
Here is the bare bones
of a vertex shader.


262
00:15:45,046 --> 00:15:48,306
It uses the stage in
qualifier which basically says


263
00:15:48,306 --> 00:15:51,776
that our per vertex
inputs, the layout for them,


264
00:15:52,306 --> 00:15:54,426
will be described
outside of the shader


265
00:15:54,426 --> 00:15:58,156
in our objective-C code
using a vertex descriptor.


266
00:15:59,626 --> 00:16:02,386
It uses this vertex
input structure


267
00:16:03,556 --> 00:16:04,706
which is defined up here.


268
00:16:06,096 --> 00:16:09,406
And the key part of this vertex
input structure are these


269
00:16:09,506 --> 00:16:13,026
attributes, the indices here
which we will use to connect


270
00:16:13,026 --> 00:16:16,306
up outside inside of
our Objective-C code.


271
00:16:17,136 --> 00:16:22,136
Note that these floating-point
vector types define how the data


272
00:16:22,136 --> 00:16:27,456
looks within the shader, not
actually how the data looks


273
00:16:27,456 --> 00:16:29,366
as it's being fed
into the shader


274
00:16:29,416 --> 00:16:30,686
from our Objective-C code.


275
00:16:33,036 --> 00:16:41,226
For that, we need to
create a vertex descriptor.


276
00:16:41,796 --> 00:16:46,296
Now, I'm going to put this
vertex input structure


277
00:16:46,296 --> 00:16:49,826
up here just for reference,
but let me just remind you


278
00:16:49,826 --> 00:16:53,136
that it does not define
the layout of the data


279
00:16:53,456 --> 00:16:54,796
as it's being fed
into the shader.


280
00:16:54,796 --> 00:16:57,256
We are actually creating
the Metal Vertex Descriptor


281
00:16:57,756 --> 00:17:01,146
that is down below.


282
00:17:01,826 --> 00:17:06,256
And for that, what we will
do is for attribute zero,


283
00:17:07,156 --> 00:17:12,796
the position will define as
using three floating points,


284
00:17:13,215 --> 00:17:14,876
three floating point values.


285
00:17:15,986 --> 00:17:23,756
For attribute one, the color
will specify that it's going


286
00:17:23,756 --> 00:17:26,736
to be composed of four
unsigned characters,


287
00:17:26,965 --> 00:17:29,666
not the four floats above,
four unsigned characters


288
00:17:29,906 --> 00:17:31,396
and it will have an offset


289
00:17:32,506 --> 00:17:40,906
of 12 bytes immediately
following the position data.


290
00:17:41,086 --> 00:17:46,636
Now, for the texture coordinates
in attribute 2, we will define


291
00:17:46,636 --> 00:17:49,026
that it uses two half floats.


292
00:17:49,586 --> 00:17:55,756
And that it immediately follows
the position and color data


293
00:17:55,836 --> 00:17:57,556
with an offset of 16 bytes.


294
00:17:58,056 --> 00:18:02,576
And finally, we will
specify that the size


295
00:18:02,576 --> 00:18:05,656
of each vertex is 20 bytes
by setting the stride


296
00:18:05,896 --> 00:18:07,646
to 20 for that buffer.


297
00:18:11,736 --> 00:18:15,676
Now, this defines the
layout of each vertex


298
00:18:15,786 --> 00:18:17,776
within our array of vertices.


299
00:18:17,776 --> 00:18:23,386
So now that we have got our
Metal Vertex Descriptor,


300
00:18:23,986 --> 00:18:26,046
we can assign it to our
render state pipeline,


301
00:18:27,636 --> 00:18:28,426
and with that render --


302
00:18:28,526 --> 00:18:31,016
excuse me, with the
render pipeline descriptor,


303
00:18:31,306 --> 00:18:34,256
we can create a Metal
Render State Pipeline.


304
00:18:35,776 --> 00:18:40,246
So let's move on to
actually loading our asset


305
00:18:41,056 --> 00:18:45,646
and using model I/O
for that task.


306
00:18:46,326 --> 00:18:49,086
And we will actually use the
vertex descriptor we just


307
00:18:49,086 --> 00:18:50,366
created in the previous step,


308
00:18:51,336 --> 00:18:55,056
along with a MetalKit
mesh buffer object,


309
00:18:55,516 --> 00:18:58,066
a mesh buffer allocator object.


310
00:18:58,876 --> 00:19:00,636
I will describe a
little bit more


311
00:19:00,636 --> 00:19:06,456
about its importance
as we continue.


312
00:19:06,556 --> 00:19:11,426
So the model I/O
vertex descriptor


313
00:19:11,686 --> 00:19:14,506
and Metal Vertex
Descriptor are very similar,


314
00:19:15,586 --> 00:19:18,726
but while the model I/O vertex
descriptor describes the layouts


315
00:19:18,726 --> 00:19:20,796
of vertex attributes
within a mesh,


316
00:19:22,336 --> 00:19:25,076
the Metal Vertex Descriptor
describes the layout


317
00:19:25,076 --> 00:19:27,156
of vertex attributes
as their input


318
00:19:27,666 --> 00:19:29,166
to a render state pipeline.


319
00:19:30,536 --> 00:19:33,696
Now, they are intentionally
designed to look similar


320
00:19:34,456 --> 00:19:38,386
as they contain attribute
and buffer layout objects,


321
00:19:39,376 --> 00:19:43,396
and the reason for this is
it simplifies the translation


322
00:19:43,396 --> 00:19:44,906
of one object to another.


323
00:19:47,366 --> 00:19:52,276
Now, each attribute in a model
I/O vertex descriptor has an


324
00:19:52,276 --> 00:19:53,866
identifying string base name.


325
00:19:54,836 --> 00:19:59,456
Model I/O assigns a default
name if one does not exist


326
00:19:59,486 --> 00:20:02,626
in the model file or that
model file does not support


327
00:20:02,626 --> 00:20:03,366
these names.


328
00:20:04,046 --> 00:20:07,046
These names include position,
normal, texture, coordinate,


329
00:20:07,046 --> 00:20:11,046
color, et cetera, and
model I/0 defines these


330
00:20:11,046 --> 00:20:14,746
with the string based
MDLVertex attribute constants.


331
00:20:15,856 --> 00:20:19,796
There are a number of files
including the Alembic file


332
00:20:19,796 --> 00:20:23,136
format where you can
customize those names.


333
00:20:23,796 --> 00:20:27,646
Be aware if you are changing
the names you will need


334
00:20:27,646 --> 00:20:31,806
to access these attributes
with those customized names.


335
00:20:32,406 --> 00:20:39,146
So we recommend that you create
a custom model I/O vertex


336
00:20:39,146 --> 00:20:42,366
descriptor, because by default
model I/O loads vertices


337
00:20:42,586 --> 00:20:43,816
as high-precision


338
00:20:44,066 --> 00:20:48,526
yet memory-hungry
floating-point types.


339
00:20:48,526 --> 00:20:52,446
This is one of the
advantages of using model I/0.


340
00:20:52,916 --> 00:20:58,976
You can actually load a model
format and have the vertex data


341
00:20:58,976 --> 00:21:03,486
in any form that you would like
and use model I/0 to massage


342
00:21:03,536 --> 00:21:06,596
that data into a format
you can actually use.


343
00:21:07,306 --> 00:21:09,766
In this case, we want
to feed the pipelines


344
00:21:10,126 --> 00:21:11,206
with the smallest type


345
00:21:11,596 --> 00:21:13,796
that meets your precision
requirements.


346
00:21:14,186 --> 00:21:17,686
This would improve your
vertex bandwidth efficiency;


347
00:21:18,036 --> 00:21:20,716
as you are feeding each
vertex to the pipeline,


348
00:21:21,066 --> 00:21:23,086
you don't really want
a bloated vertex.


349
00:21:23,626 --> 00:21:28,756
So here is the layout
we defined previously


350
00:21:28,756 --> 00:21:30,906
when creating our Metal
Vertex Descriptor.


351
00:21:31,456 --> 00:21:37,186
Now, we will create our
model I/O vertex descriptor


352
00:21:37,606 --> 00:21:42,406
by calling this MTK model
I/O vertex format from Metal


353
00:21:42,486 --> 00:21:45,426
and we will supply our
Metal Vertex Descriptor.


354
00:21:45,716 --> 00:21:51,546
This builds the majority of this
model I/O vertex descriptor,


355
00:21:52,376 --> 00:21:55,786
yet we still need to tag
each attribute with a name,


356
00:21:55,786 --> 00:21:59,136
so model I/O knows what
we are talking about.


357
00:22:00,066 --> 00:22:03,646
So for attribute
0, we will tag it


358
00:22:03,646 --> 00:22:06,216
with the vertex attribute
position name.


359
00:22:07,446 --> 00:22:10,846
And similarly for attribute
1 and 2, we will tag them


360
00:22:10,846 --> 00:22:13,696
with a color and texture
coordinate attributes.


361
00:22:17,036 --> 00:22:20,096
The other thing we will do here
is we will create a MetalKit


362
00:22:20,356 --> 00:22:24,466
mesh buffer allocator and we
will supply a Metal device.


363
00:22:24,996 --> 00:22:29,376
Now, what this object does
is it allows model I/0


364
00:22:29,906 --> 00:22:35,116
to load vertex data directly
into GPU backed memory.


365
00:22:35,936 --> 00:22:39,056
Now, you don't have to use a
MetalKit mesh buffer allocator,


366
00:22:39,856 --> 00:22:44,206
but what that will do is it
will allocate system memory


367
00:22:44,676 --> 00:22:49,876
for these vertex and index
buffers inside of the mesh.


368
00:22:50,136 --> 00:22:53,596
And when you want to actually
render it, we will need to copy


369
00:22:53,626 --> 00:22:56,816
from that system memory down
into the GPU backed memory.


370
00:22:56,816 --> 00:23:01,926
So for efficiency, it's
really desirable to use one


371
00:23:01,926 --> 00:23:05,026
of these mesh buffer allocators,
and here is how you use it.


372
00:23:06,106 --> 00:23:09,856
Now, we are going to
load our asset file.


373
00:23:10,086 --> 00:23:16,806
We will supply the URL location,
the model I/0 vertex descriptor


374
00:23:16,806 --> 00:23:19,996
which will tell model I/0
how to lay out each vertex


375
00:23:21,366 --> 00:23:24,406
and we will also supply
this mesh buffer allocator


376
00:23:24,996 --> 00:23:28,006
so that model I/0 can
load this data directly


377
00:23:28,006 --> 00:23:29,656
into GPU backed memory.


378
00:23:30,916 --> 00:23:35,336
So now that we have
got our asset,


379
00:23:35,556 --> 00:23:37,986
let's actually create
some MetalKit mesh


380
00:23:37,986 --> 00:23:39,146
and some mesh objects.


381
00:23:39,146 --> 00:23:43,636
So here's an example of an asset


382
00:23:43,636 --> 00:23:47,686
that might be created
by model I/0.


383
00:23:47,866 --> 00:23:51,606
Inside of an asset, we
might have camera objects,


384
00:23:53,236 --> 00:23:57,616
light objects, and
particularly important


385
00:23:57,616 --> 00:23:59,966
to us right now are
the mesh objects.


386
00:24:00,346 --> 00:24:03,266
Now, MetalKit is
primarily concerned


387
00:24:03,266 --> 00:24:04,166
with these mesh objects.


388
00:24:04,166 --> 00:24:07,226
It doesn't really deal
directly with the light


389
00:24:07,336 --> 00:24:10,876
and camera objects because that
sort of data is very specific


390
00:24:11,166 --> 00:24:13,886
to your custom shaders
and your engines.


391
00:24:14,676 --> 00:24:18,246
You can actually
introspect into this object


392
00:24:18,246 --> 00:24:20,876
or go look inside this object
and grab out that camera


393
00:24:20,876 --> 00:24:23,806
and light information to
plug it into your shaders,


394
00:24:24,086 --> 00:24:27,106
but MetalKit isn't directly
involved in that process.


395
00:24:28,116 --> 00:24:38,066
So what we can do is pass
in this asset directly


396
00:24:38,066 --> 00:24:42,386
to this mesh, meshes
from asset class function


397
00:24:42,756 --> 00:24:46,246
which will create an
array of MetalKit meshes.


398
00:24:50,636 --> 00:24:54,006
Let's take a look at what's
inside this mesh object.


399
00:24:55,276 --> 00:24:57,476
So first are these
vertex buffers


400
00:24:57,476 --> 00:25:00,106
which includes the
position attributes,


401
00:25:00,366 --> 00:25:04,006
the normal attributes,
textural attributes, et cetera.


402
00:25:04,406 --> 00:25:07,496
In our example, we
only needed one array


403
00:25:07,696 --> 00:25:09,366
because we interleaved
all of our data.


404
00:25:09,946 --> 00:25:13,696
However, you can define the
layout to use multiple arrays,


405
00:25:13,696 --> 00:25:17,216
and therefore you would have
multiple vertex buffers.


406
00:25:17,376 --> 00:25:21,326
You could define that
attribute 0 would be inside


407
00:25:21,426 --> 00:25:23,966
of a single array, so you would
have an array of positions


408
00:25:24,476 --> 00:25:28,156
in one array, an array of
texture coordinates in the next,


409
00:25:28,636 --> 00:25:32,056
another array with
colors, and so on.


410
00:25:35,276 --> 00:25:37,696
The mesh also includes
a vertex descriptor


411
00:25:37,696 --> 00:25:39,336
which defines this layout


412
00:25:39,436 --> 00:25:41,896
and it's the same object
we just created and passed


413
00:25:41,896 --> 00:25:45,266
in when we initialized
our asset.


414
00:25:46,026 --> 00:25:49,716
And finally, the mesh contains
a number of sub mesh objects.


415
00:25:50,086 --> 00:25:53,666
Now, the key part of each
sub mesh object is this index


416
00:25:53,696 --> 00:25:57,506
buffer, which references
vertices inside the


417
00:25:57,506 --> 00:25:59,846
vertex buffer.


418
00:26:00,016 --> 00:26:03,076
Additionally, there are a number
of properties which you can use


419
00:26:03,566 --> 00:26:08,556
to make a draw call with Metal.


420
00:26:08,696 --> 00:26:12,696
So now that we have
got our Metal kit mesh


421
00:26:12,696 --> 00:26:21,086
and sub mesh objects, let's
go ahead and render them.


422
00:26:21,586 --> 00:26:26,046
So first we will iterate
through each vertex buffer.


423
00:26:27,426 --> 00:26:29,796
Now, we may have a sparse
array, so we need to make sure


424
00:26:29,796 --> 00:26:32,136
that there is actually
something in each buffer,


425
00:26:32,136 --> 00:26:35,956
but once we are sure of
that, we can continue on


426
00:26:35,956 --> 00:26:39,716
and set the vertex buffer
in our render encoder.


427
00:26:40,696 --> 00:26:43,346
Now, the vertex buffer
actually has two properties,


428
00:26:43,556 --> 00:26:47,126
the buffer itself, and an
offset within the buffer


429
00:26:47,616 --> 00:26:50,026
where your vertex data resides.


430
00:26:50,026 --> 00:26:57,046
We also need to supply a buffer
index telling the pipeline


431
00:26:57,546 --> 00:26:59,316
exactly where the data is.


432
00:26:59,946 --> 00:27:03,826
Now, we will actually
render our mesh.


433
00:27:04,756 --> 00:27:06,466
We will iterate through
every sub mesh,


434
00:27:07,906 --> 00:27:10,156
and make our draw
index primitives call.


435
00:27:11,126 --> 00:27:15,506
Note here that the sub mesh
has all of the parameters


436
00:27:15,506 --> 00:27:18,496
for this draw index parameter.


437
00:27:20,416 --> 00:27:25,486
So today we posted this
MetalKit essentials sample


438
00:27:25,486 --> 00:27:28,696
on the WWDC 2015 site.


439
00:27:29,396 --> 00:27:31,356
I encourage you to download it.


440
00:27:31,356 --> 00:27:34,116
It describes a number of
the techniques I described.


441
00:27:34,506 --> 00:27:38,936
It uses model I/0 to load this
little airplane object that's


442
00:27:38,996 --> 00:27:44,666
stuffed in an OBJ file and
creates a MetalKit mesh


443
00:27:45,126 --> 00:27:47,226
and renders it on screen.


444
00:27:47,526 --> 00:27:51,186
So you can get an idea of
exactly how this is all done.


445
00:27:51,686 --> 00:27:55,966
So I encourage you
to check that out.


446
00:27:56,226 --> 00:27:58,356
So that's it for me,
my name is Dan Omachi,


447
00:27:58,616 --> 00:28:02,076
I will be at the Metal Lab
tomorrow if you have questions


448
00:28:02,076 --> 00:28:03,516
about topics I have discussed.


449
00:28:03,516 --> 00:28:07,366
I would like to welcome my
colleague, Anna Tikhonova


450
00:28:07,366 --> 00:28:12,336
on stage to talk about the Metal
performance shaders frameworks.


451
00:28:12,636 --> 00:28:12,976
Thank you.


452
00:28:13,516 --> 00:28:18,546
[ Applause ]


453
00:28:19,046 --> 00:28:19,386
>> ANNA TIKHONOVA: Good morning.


454
00:28:20,276 --> 00:28:22,676
Thank you, Dan, for the
introduction, my name is Anna


455
00:28:23,206 --> 00:28:26,086
and I will be talking to you
about Metal performance shaders.


456
00:28:26,266 --> 00:28:26,996
Let's get started.


457
00:28:27,946 --> 00:28:29,926
So first of all, what is it?


458
00:28:30,406 --> 00:28:34,276
It's a framework of optimized
high performance data parallel


459
00:28:34,276 --> 00:28:35,926
algorithms for the GPU in Metal.


460
00:28:37,066 --> 00:28:38,156
When and why would you use it?


461
00:28:39,136 --> 00:28:41,466
If you are writing
C code and you want


462
00:28:41,466 --> 00:28:42,996
to add a common sorting
algorithm


463
00:28:42,996 --> 00:28:46,486
to your CPU application, you are
very unlikely to implement one


464
00:28:46,486 --> 00:28:49,346
from scratch unless it
was out of self-interest.


465
00:28:49,976 --> 00:28:52,736
You are a lot more likely to
use the implementation provided


466
00:28:52,736 --> 00:28:56,746
to you by the library because
it's already been debugged


467
00:28:56,986 --> 00:28:58,096
and optimized for you.


468
00:28:59,006 --> 00:29:02,036
Likewise, if you wanted to add
an image processing operation


469
00:29:02,036 --> 00:29:05,496
to your CPU application,
on our platform,


470
00:29:05,496 --> 00:29:07,086
you would use the
accelerate framework


471
00:29:07,466 --> 00:29:08,716
because it uses vImage.


472
00:29:09,596 --> 00:29:10,796
It's a powerful,


473
00:29:10,796 --> 00:29:14,976
high-performance tuned image
processing framework for --


474
00:29:16,256 --> 00:29:19,136
that utilizes the CPU's
vector processing.


475
00:29:19,656 --> 00:29:21,536
These are just a few examples.


476
00:29:22,516 --> 00:29:25,636
The point is that there is
a rich environment available


477
00:29:25,636 --> 00:29:26,836
for your CPU applications.


478
00:29:27,496 --> 00:29:30,096
On the GPU the story
is a bit different,


479
00:29:30,866 --> 00:29:33,366
you simply have fewer
options but we would


480
00:29:33,366 --> 00:29:34,466
like to change the story.


481
00:29:34,546 --> 00:29:38,136
Our goal is to enrich your
Metal programming environment.


482
00:29:38,776 --> 00:29:42,536
We have selected a
collection of common filters


483
00:29:42,756 --> 00:29:45,746
that we see often used in
graphic processing pipelines


484
00:29:46,066 --> 00:29:47,956
in your image processing
applications and games.


485
00:29:49,736 --> 00:29:53,656
These algorithms are
optimized for iOS and available


486
00:29:53,906 --> 00:29:55,966
in iOS 9 for the A8 processor.


487
00:29:56,996 --> 00:30:00,306
The Metal performance shaders
framework has two goals,


488
00:30:00,786 --> 00:30:02,956
performance and ease of use.


489
00:30:03,336 --> 00:30:05,416
It's designed to
integrate easily


490
00:30:05,496 --> 00:30:06,726
into your Metal applications.


491
00:30:07,476 --> 00:30:10,136
It operates on Metal
resources directly.


492
00:30:10,596 --> 00:30:13,356
They are the input
and the output.


493
00:30:13,356 --> 00:30:14,936
We are not only giving
you collection


494
00:30:15,206 --> 00:30:18,086
of these high performance
optimized awesome kernels --


495
00:30:18,386 --> 00:30:22,156
we are giving you that, but
we are also taking care of all


496
00:30:22,156 --> 00:30:24,996
of the host code necessary
to launch these kernels.


497
00:30:25,716 --> 00:30:28,756
We take care of the
decision-making process of how


498
00:30:28,756 --> 00:30:30,996
to split up the work for
parallel computation.


499
00:30:31,556 --> 00:30:35,556
The work you have to do to take
advantage of this framework


500
00:30:35,556 --> 00:30:37,656
in your applications
usually amounts


501
00:30:37,656 --> 00:30:40,266
to only a few lines of code.


502
00:30:40,436 --> 00:30:42,636
It's as simple as calling
a library function.


503
00:30:44,226 --> 00:30:46,186
So now that I have introduced
the framework to you,


504
00:30:46,366 --> 00:30:48,306
let's take a look at the
available operations.


505
00:30:49,296 --> 00:30:52,396
Here is a full list and let's
start from the beginning.


506
00:30:52,666 --> 00:30:54,296
I will cover just a
few of these actually


507
00:30:54,476 --> 00:30:55,586
and I will show you examples.


508
00:30:56,756 --> 00:30:59,806
So first, the framework
supports the histogram filter


509
00:30:59,806 --> 00:31:02,726
and the histogram equalization
and specification filters.


510
00:31:03,846 --> 00:31:06,116
The equalization and
specification filters,


511
00:31:06,566 --> 00:31:10,596
they allow you to
change the distribution


512
00:31:10,596 --> 00:31:12,216
of color intensities
in your image.


513
00:31:12,446 --> 00:31:15,076
The equalization filter
is a special case.


514
00:31:15,536 --> 00:31:16,946
It changes the distribution


515
00:31:17,396 --> 00:31:20,016
from the current
distribution to the uniform one.


516
00:31:20,736 --> 00:31:23,046
And the specification
filter enables you


517
00:31:23,046 --> 00:31:24,866
to set any distribution
of your choice.


518
00:31:25,216 --> 00:31:27,606
You specify the histogram that
will be used in the filter.


519
00:31:30,576 --> 00:31:34,386
This is an example of
the equalization filter.


520
00:31:34,936 --> 00:31:40,186
It increases the global
contrast in the image.


521
00:31:40,366 --> 00:31:43,216
Here it brings out the rainbow
in the sky quite beautifully.


522
00:31:43,956 --> 00:31:45,446
One thing I'd like to mention


523
00:31:45,846 --> 00:31:48,606
about these filters is they
are not an end in themselves.


524
00:31:49,496 --> 00:31:51,606
They can be used as
an intermediate step


525
00:31:52,026 --> 00:31:53,476
in a more complex algorithm.


526
00:31:53,826 --> 00:31:57,336
The histogram filter can be
used as an intermediate step


527
00:31:57,336 --> 00:31:58,636
in implementing tune mapping,


528
00:31:58,966 --> 00:32:01,646
which is a technique commonly
used by graphics developers


529
00:32:02,096 --> 00:32:05,076
to approximate the appearance
of high dynamic range.


530
00:32:05,676 --> 00:32:09,756
So moving on, we also
support Lancos resampling.


531
00:32:10,226 --> 00:32:13,456
It's a high-quality resampling
algorithm that can used


532
00:32:13,576 --> 00:32:16,476
to downscale, upscale,
squeeze, and stretch images.


533
00:32:16,476 --> 00:32:21,906
In this example, I
stretched the image vertically


534
00:32:22,086 --> 00:32:24,566
and squeezed it horizontally
while preserving all


535
00:32:24,566 --> 00:32:25,506
of the image content.


536
00:32:27,396 --> 00:32:29,566
You also support the
thresholding filter.


537
00:32:30,156 --> 00:32:31,956
It can be used to
find image edges


538
00:32:32,076 --> 00:32:33,486
if chained with a Sobel filter.


539
00:32:34,746 --> 00:32:36,296
Let's take a look at an example.


540
00:32:36,776 --> 00:32:39,776
This is the output of
the thresholding filter,


541
00:32:39,776 --> 00:32:44,926
and now it's fed into the Sobel
filter to give you image edges.


542
00:32:46,626 --> 00:32:49,666
And finally we support
a whole range


543
00:32:49,666 --> 00:32:52,616
of convolution kernels
including general convolution,


544
00:32:52,616 --> 00:32:55,296
where you can specify your
own convolution matrix.


545
00:32:55,356 --> 00:32:57,716
And we also support
Gaussian blur,


546
00:32:57,936 --> 00:32:59,696
box tent, and Sobel filters.


547
00:33:00,196 --> 00:33:03,136
My final example will
be of a Gaussian blur.


548
00:33:03,766 --> 00:33:05,326
You should all be
very familiar with it;


549
00:33:05,706 --> 00:33:07,076
we like to use it in our UI.


550
00:33:07,806 --> 00:33:09,936
What if you wanted to
use a Gaussian blur


551
00:33:09,936 --> 00:33:11,426
in your own application,


552
00:33:12,366 --> 00:33:15,396
the Metal performance shaders
framework makes it very easy.


553
00:33:16,736 --> 00:33:17,616
How easy, you ask?


554
00:33:18,716 --> 00:33:20,186
I'm building some
anticipation here.


555
00:33:20,666 --> 00:33:23,206
It's just two lines of code.


556
00:33:23,536 --> 00:33:28,466
You first have to create a blur
filter object, and then you have


557
00:33:28,466 --> 00:33:33,356
to encode the filter
to the command buffer.


558
00:33:33,986 --> 00:33:35,796
And that's it [applause].


559
00:33:37,466 --> 00:33:38,226
Thank you, guys.


560
00:33:40,906 --> 00:33:43,716
And one thing I just wanted to
point out again and just note is


561
00:33:43,716 --> 00:33:47,536
that this API takes your common
Metal resources as input.


562
00:33:48,146 --> 00:33:50,036
Your device, your command
buffer, your textures.


563
00:33:51,096 --> 00:33:53,496
These are the Metal resources


564
00:33:53,496 --> 00:33:55,176
that you already create
in your application.


565
00:33:55,736 --> 00:33:59,116
And now that I have shown
you these two lines of code,


566
00:33:59,536 --> 00:34:01,816
let's take a look
at where they plug


567
00:34:01,816 --> 00:34:03,926
in into your current
Metal work flow.


568
00:34:04,436 --> 00:34:06,336
So this is a graphical
representation


569
00:34:06,336 --> 00:34:07,086
of your command buffer.


570
00:34:08,436 --> 00:34:10,686
It contains all of the
commands you are going


571
00:34:10,686 --> 00:34:11,866
to be submitting to the device.


572
00:34:12,716 --> 00:34:14,755
You do your work as
you usually would.


573
00:34:15,056 --> 00:34:17,025
You render your scene
by issuing draw calls


574
00:34:18,326 --> 00:34:21,206
and you do your post processing
effect by dispatching kernels.


575
00:34:21,545 --> 00:34:23,536
Now you have decided that one


576
00:34:23,536 --> 00:34:26,136
of your post processing effects
is going to be a blur filter.


577
00:34:26,976 --> 00:34:29,576
So this is exactly
where it goes.


578
00:34:30,346 --> 00:34:34,315
And don't forget that you still
have to submit your commands


579
00:34:34,315 --> 00:34:36,396
to the device as
you normally would.


580
00:34:36,396 --> 00:34:37,356
Nothing changes here.


581
00:34:38,106 --> 00:34:41,446
And now, if you would like
to look at the sample code


582
00:34:41,446 --> 00:34:43,466
for the example I was
just going through,


583
00:34:43,466 --> 00:34:44,485
you could do so right now.


584
00:34:44,485 --> 00:34:46,295
You can go to
developer.Apple.com


585
00:34:46,585 --> 00:34:49,275
and download the example called
Metal performance shaders


586
00:34:49,356 --> 00:34:49,926
hello world.


587
00:34:51,315 --> 00:34:54,626
I've mentioned before that
the Metal performance shaders


588
00:34:54,626 --> 00:34:57,566
framework has two goals,
performance and ease of use.


589
00:34:57,666 --> 00:35:00,206
I just showed you how
easy it is to use.


590
00:35:01,116 --> 00:35:03,056
Let's take a quick
look behind the scenes


591
00:35:03,556 --> 00:35:05,416
at what's giving you
this performance.


592
00:35:07,676 --> 00:35:10,606
For every one of these filters
including the Gaussian blur


593
00:35:10,606 --> 00:35:13,656
filter, we had to choose
the right algorithm.


594
00:35:14,106 --> 00:35:18,676
The right here means correct
and it has to be the fastest.


595
00:35:19,346 --> 00:35:24,606
The fastest for a particular
combination of input data,


596
00:35:24,836 --> 00:35:27,366
input parameters,
and device GPU.


597
00:35:28,276 --> 00:35:30,286
What do I mean by this?


598
00:35:30,366 --> 00:35:32,686
There are multiple ways to
implement Gaussian blur.


599
00:35:32,686 --> 00:35:36,346
There are constant
cost, log 2, linear,


600
00:35:36,346 --> 00:35:37,736
and brute force algorithms.


601
00:35:39,276 --> 00:35:40,906
All of these approaches
have different start


602
00:35:40,906 --> 00:35:42,296
up costs and overheads.


603
00:35:42,666 --> 00:35:45,636
One approach may work really
well for a small kernel radius


604
00:35:45,976 --> 00:35:48,806
but perform very poorly
on a large kernel radius.


605
00:35:49,976 --> 00:35:54,326
The point is we had to implement
each one of these approaches


606
00:35:54,406 --> 00:35:57,126
and find out experimentally
which one is going


607
00:35:57,126 --> 00:35:59,536
to be the fastest for a
particular combination


608
00:35:59,536 --> 00:36:03,956
of input problem, input
parameters, and device GPU.


609
00:36:03,956 --> 00:36:09,076
And after this process, all
of the kernels had to be tuned


610
00:36:09,076 --> 00:36:11,266
for such parameters
as your kernel radius,


611
00:36:12,436 --> 00:36:13,456
your pixel format,


612
00:36:14,416 --> 00:36:16,936
your underlying hardware
architecture's memory hierarchy,


613
00:36:17,326 --> 00:36:19,776
and such parameters as
number of pixels per thread


614
00:36:19,776 --> 00:36:20,846
and thread group dimensions.


615
00:36:21,206 --> 00:36:23,636
This is what determines how to
split up your work in parallel.


616
00:36:23,636 --> 00:36:26,476
And finally, I would
like to mention


617
00:36:27,196 --> 00:36:30,626
that the framework also performs
CPU optimizations for you.


618
00:36:31,176 --> 00:36:35,016
It optimizes program
loading speed.


619
00:36:36,266 --> 00:36:40,546
It also reuses intermediate
textures,


620
00:36:41,206 --> 00:36:45,096
and finally it does some compute
encoder optimization for you.


621
00:36:45,146 --> 00:36:47,256
Specifically, it can defect


622
00:36:47,646 --> 00:36:51,106
if you are using multiple
computing coders in a row and if


623
00:36:51,106 --> 00:36:52,416
so it will coalesce them.


624
00:36:53,116 --> 00:36:58,896
And after we have done all
of these steps for you,


625
00:36:58,896 --> 00:37:01,076
that's cool, but what would
this actually look like in terms


626
00:37:01,076 --> 00:37:03,776
of code, for example, for an
optimized Gaussian blur shader


627
00:37:03,776 --> 00:37:04,736
that I just showed you?


628
00:37:07,436 --> 00:37:08,656
Well, are you ready for it?


629
00:37:09,686 --> 00:37:11,926
Here is the code.


630
00:37:12,436 --> 00:37:13,606
So now all of you know how


631
00:37:13,606 --> 00:37:15,726
to implement your own
optimized Gaussian blur, right?


632
00:37:16,196 --> 00:37:17,396
I bet you didn't
know you were going


633
00:37:17,396 --> 00:37:19,046
to learn this in this session.


634
00:37:19,826 --> 00:37:23,016
Basically all joking aside,
this is 49 Metal kernels,


635
00:37:23,066 --> 00:37:25,066
2,000 lines of kernel code


636
00:37:25,296 --> 00:37:29,756
and 821 different Metal
Gaussian blur implementations


637
00:37:30,576 --> 00:37:33,706
where each implementation
is some combination


638
00:37:33,706 --> 00:37:37,426
of these 49 Metal kernels, so it
looks like a lot of work we did


639
00:37:37,686 --> 00:37:39,566
and now you don't have to.


640
00:37:39,566 --> 00:37:40,946
Now, let's take a look


641
00:37:40,946 --> 00:37:50,216
at the Metal performance
shaders framework in action.


642
00:37:50,316 --> 00:37:53,286
So first, I will
demonstrate the performance


643
00:37:53,366 --> 00:37:58,556
of a simple textbook separable
Gaussian blur implementation


644
00:37:59,466 --> 00:38:01,486
that took only minutes
to write in Metal.


645
00:38:01,656 --> 00:38:04,026
This is probably something you
would start with if you had


646
00:38:04,026 --> 00:38:05,646
to implement your own blur


647
00:38:05,646 --> 00:38:07,806
and you didn't have Metal
performance shaders available


648
00:38:07,806 --> 00:38:08,086
to you.


649
00:38:08,456 --> 00:38:11,336
So now we are happily running
at 60 frames per second


650
00:38:11,336 --> 00:38:12,996
but we are not actually
doing any work yet.


651
00:38:13,996 --> 00:38:15,186
The sigma value is 0.


652
00:38:15,606 --> 00:38:19,466
Let's change the sigma value
to 6 and we are down to


653
00:38:19,466 --> 00:38:21,146
about 8 frames per second.


654
00:38:21,956 --> 00:38:23,046
Dare we go any further?


655
00:38:23,376 --> 00:38:24,736
Let's try a sigma of 20.


656
00:38:25,396 --> 00:38:30,896
Okay. And we are down
to 3 frames per second


657
00:38:30,896 --> 00:38:32,176
so that's not going to work.


658
00:38:33,006 --> 00:38:34,806
Let's switch to the
Metal performance


659
00:38:34,806 --> 00:38:35,956
shaders implementation.


660
00:38:36,566 --> 00:38:39,946
So now we are back to
60 frames per second,


661
00:38:39,946 --> 00:38:42,626
not doing any work, sigma of 6.


662
00:38:43,416 --> 00:38:44,846
Still 60 frames per second.


663
00:38:45,576 --> 00:38:46,556
Sigma of 20.


664
00:38:47,136 --> 00:38:48,586
Still 60 frames per second.


665
00:38:49,876 --> 00:38:53,366
And, of course, we had to go
further and really blur it,


666
00:38:53,706 --> 00:38:55,226
still at 60 frames per second.


667
00:38:55,226 --> 00:38:56,486
So this looks like a winner.


668
00:39:02,516 --> 00:39:12,026
[ Applause ]


669
00:39:12,526 --> 00:39:12,656
Okay.


670
00:39:13,046 --> 00:39:15,336
So your screen refresh
rate is 60 hertz.


671
00:39:17,096 --> 00:39:21,056
This means that we are running
at 60 frames we are second,


672
00:39:21,056 --> 00:39:24,956
so the performance of this
optimized Gaussian blur shader


673
00:39:24,956 --> 00:39:28,326
you have seen in the demo is
capped at 60 frames per second.


674
00:39:28,966 --> 00:39:33,786
This means that you have 16.6
milliseconds to draw your frame,


675
00:39:33,786 --> 00:39:36,566
and this also includes
any compositing work


676
00:39:36,596 --> 00:39:39,306
that your system
might need to do.


677
00:39:39,806 --> 00:39:43,066
This chart shows you
the execution time


678
00:39:43,646 --> 00:39:46,616
of this optimized Gaussian blur
filter for different values


679
00:39:46,616 --> 00:39:51,096
of sigma and as you can see,
the execution time is a lot less


680
00:39:51,246 --> 00:39:52,756
than 16.6 milliseconds.


681
00:39:53,436 --> 00:39:56,416
So this means that you
still have some extra time


682
00:39:56,416 --> 00:39:57,976
to do additional GPU work,


683
00:39:59,496 --> 00:40:02,766
and still hit the desired
60 frames per second.


684
00:40:03,416 --> 00:40:07,036
And now there are just a
few more details I would


685
00:40:07,036 --> 00:40:07,596
like to cover.


686
00:40:08,966 --> 00:40:12,266
Sometimes you will need to
work on very large images


687
00:40:12,266 --> 00:40:13,376
and you will need to tile them.


688
00:40:14,546 --> 00:40:16,036
And sometimes you
will just need to work


689
00:40:16,036 --> 00:40:17,186
on a portion of your image.


690
00:40:17,186 --> 00:40:18,976
So there is a mechanism
for that.


691
00:40:19,486 --> 00:40:22,616
It's called source offset
and destination clip Rect.


692
00:40:23,106 --> 00:40:25,616
Clip rect has an
origin and size.


693
00:40:26,206 --> 00:40:28,866
It determines the region
of the destination texture,


694
00:40:28,866 --> 00:40:32,416
which is going to be
updated by a filter.


695
00:40:32,416 --> 00:40:34,346
The source offset
only has an origin.


696
00:40:35,136 --> 00:40:37,356
The size is implicit, it's
determined by the clip rect,


697
00:40:37,356 --> 00:40:40,066
and it is just an offset
from the upper left corner


698
00:40:40,066 --> 00:40:41,436
of your source texture.


699
00:40:42,316 --> 00:40:45,366
They work together to
give you the final image.


700
00:40:45,916 --> 00:40:50,716
In the Metal performance
shaders framework your source


701
00:40:50,716 --> 00:40:53,646
and destination can be
one in the same texture.


702
00:40:54,096 --> 00:40:56,066
In this case, the clip rect


703
00:40:56,896 --> 00:40:59,546
and source offset work
exactly the same way.


704
00:41:00,126 --> 00:41:06,246
When the source and destination
are the same texture,


705
00:41:06,406 --> 00:41:08,246
we call it an in
place operation.


706
00:41:08,836 --> 00:41:09,846
Use it to save memory.


707
00:41:09,846 --> 00:41:12,386
How could you do you
actually encode one


708
00:41:12,386 --> 00:41:13,466
of these filters in place?


709
00:41:14,836 --> 00:41:17,936
You have to use the encode to
command buffer method that takes


710
00:41:17,936 --> 00:41:20,606
in place texture and a fall
by back copy allocator.


711
00:41:22,376 --> 00:41:25,346
One thing to keep in mind
here, it's not always possible


712
00:41:25,346 --> 00:41:26,716
for the shaders to run in place.


713
00:41:27,076 --> 00:41:28,596
It depends on your filter,


714
00:41:28,996 --> 00:41:30,506
on the filter parameters
and properties.


715
00:41:31,106 --> 00:41:32,806
If you want this operation


716
00:41:32,806 --> 00:41:35,486
to always succeed,
use a copy allocator.


717
00:41:35,726 --> 00:41:40,086
It will be called automatically,
only in the situation where the


718
00:41:40,086 --> 00:41:41,646
in place operation
is not possible.


719
00:41:42,046 --> 00:41:44,866
And we will create a new
destination texture for you


720
00:41:46,216 --> 00:41:47,736
so that the operation
can proceed


721
00:41:47,736 --> 00:41:49,286
out of place if necessary.


722
00:41:50,206 --> 00:41:54,206
And here is an example of a
simple fall back copy allocator.


723
00:41:55,826 --> 00:41:58,946
This one simply creates
a new destination texture


724
00:41:59,726 --> 00:42:02,886
with the same pixel
format and dimensions


725
00:42:02,886 --> 00:42:04,626
as the source texture,
very simple.


726
00:42:05,326 --> 00:42:08,016
So now I have shown you
an example before of an


727
00:42:08,016 --> 00:42:10,796
in place operation where
you only modified a portion


728
00:42:10,796 --> 00:42:13,976
of your destination texture
and everything outside


729
00:42:13,976 --> 00:42:15,866
of the clip rect
remained unchanged.


730
00:42:16,226 --> 00:42:18,366
You can also do this
in the copy allocator.


731
00:42:19,346 --> 00:42:22,596
Just initialize your destination
texture with the contexts


732
00:42:22,596 --> 00:42:23,536
of your source texture.


733
00:42:24,136 --> 00:42:28,696
And I would also like
to mention that all


734
00:42:28,696 --> 00:42:31,176
of the usual Metal
resources such as your device


735
00:42:31,176 --> 00:42:33,316
and your command buffer
are available to you


736
00:42:33,316 --> 00:42:34,286
in the copy allocator.


737
00:42:34,796 --> 00:42:36,916
Now that I have covered
these details,


738
00:42:37,166 --> 00:42:38,286
let's jump into the summary.


739
00:42:38,846 --> 00:42:43,296
I would like to say please use
the Metal support frameworks,


740
00:42:43,416 --> 00:42:46,416
MetalKit and Metal performance
shaders, they are robust,


741
00:42:46,606 --> 00:42:49,716
they are optimized, and as I
have shown you, they're easy


742
00:42:49,716 --> 00:42:51,486
to integrate into your
Metal applications.


743
00:42:52,026 --> 00:42:54,586
They will allow for faster bring
up time of your applications.


744
00:42:54,906 --> 00:42:56,216
Now, you can spend the time


745
00:42:56,216 --> 00:42:58,316
on making application
unique instead


746
00:42:58,316 --> 00:43:00,626
of implementing common tasks.


747
00:43:00,626 --> 00:43:03,566
And, of course, as an added
benefit, there is less code


748
00:43:03,566 --> 00:43:04,956
for you to write and maintain.


749
00:43:05,736 --> 00:43:07,746
And come to our labs,
give us feedback.


750
00:43:07,856 --> 00:43:10,366
Let us know how to get
started or give us questions.


751
00:43:10,836 --> 00:43:14,106
Let us know if there are new
utilities or shaders you would


752
00:43:14,106 --> 00:43:15,856
like to see added to
the support frameworks.


753
00:43:16,466 --> 00:43:19,686
You can always find
more information online.


754
00:43:19,786 --> 00:43:22,886
We have documentation videos
available, and take advantage


755
00:43:22,886 --> 00:43:25,216
of the Apple Developer
Forums and technical support.


756
00:43:25,496 --> 00:43:28,416
For general inquiries,
contact our gaming technologies


757
00:43:28,416 --> 00:43:29,706
evangelist Allan Schaffer.


758
00:43:31,926 --> 00:43:35,726
You can watch the past sessions
online, but if you would


759
00:43:35,726 --> 00:43:38,236
like to learn new Metal
performance optimization


760
00:43:38,236 --> 00:43:40,576
techniques, come to
our talk tomorrow


761
00:43:40,576 --> 00:43:42,956
at 11:00 a.m. Thank you.


762
00:43:44,516 --> 00:43:58,360
[ Applause ]

