1
00:00:11,066 --> 00:00:13,466
>> Good afternoon and welcome
to fixing memory issues.


2
00:00:14,036 --> 00:00:16,106
My name is Kate Stone
[phonetic], and I'm responsible,


3
00:00:16,106 --> 00:00:17,716
among other things,
for managing the team


4
00:00:17,716 --> 00:00:19,316
that develops the
Instruments product


5
00:00:19,316 --> 00:00:21,946
that hopefully you all know and
love and will learn a lot more


6
00:00:21,946 --> 00:00:22,996
about in this session.


7
00:00:23,046 --> 00:00:27,326
But, of course, the focus of
our session is not Instruments,


8
00:00:27,856 --> 00:00:29,056
it's on your application.


9
00:00:29,596 --> 00:00:33,086
So glad to see so many of you
here today because our goal is


10
00:00:33,086 --> 00:00:35,996
to make your application the
best that it can possibly be.


11
00:00:36,506 --> 00:00:39,396
We want applications that
are robust, that are fast,


12
00:00:40,076 --> 00:00:42,926
that don't hog too many system
resources and work really well


13
00:00:42,926 --> 00:00:44,576
with other applications
on the system.


14
00:00:45,496 --> 00:00:47,316
So with that in mind
let's start thinking


15
00:00:47,316 --> 00:00:51,656
about what could
possibly go wrong.


16
00:00:51,886 --> 00:00:54,376
Your application, of
course it occupies memory.


17
00:00:54,376 --> 00:00:56,766
From the very beginning
an application that's up


18
00:00:56,766 --> 00:00:58,396
and running, it's
loaded into memory,


19
00:00:58,396 --> 00:01:00,526
it starts executing,
starts loading data.


20
00:01:00,646 --> 00:01:04,025
It starts loading more
and more and more data.


21
00:01:04,775 --> 00:01:07,376
And there are a couple of
potential side effects of this.


22
00:01:07,986 --> 00:01:10,766
If you get too much you start
seeing a poor user experience.


23
00:01:11,006 --> 00:01:12,286
It could mean long load times.


24
00:01:12,506 --> 00:01:14,236
It could mean you're
trying to get too much up


25
00:01:14,236 --> 00:01:16,346
and running before the user
sees something meaningful.


26
00:01:17,046 --> 00:01:19,386
It could mean you're using
so many system resources


27
00:01:19,616 --> 00:01:22,296
that you wind up
swapping on an OS X system


28
00:01:22,376 --> 00:01:23,666
and slowing the system down.


29
00:01:24,586 --> 00:01:26,276
It could mean that when
users try to switch


30
00:01:26,276 --> 00:01:27,786
to their other applications
that they find


31
00:01:27,786 --> 00:01:30,436
that they've been forced out
of memory by your application.


32
00:01:31,106 --> 00:01:32,946
So there are a lot of
potential down sides,


33
00:01:32,946 --> 00:01:35,576
and it really behooves us to
keep things under control.


34
00:01:35,576 --> 00:01:38,426
Of course, the situation
could get worse.


35
00:01:38,926 --> 00:01:42,046
It could be the situation that
you're using so much memory,


36
00:01:42,166 --> 00:01:43,606
so many resources on the system,


37
00:01:43,826 --> 00:01:45,446
that you were forcibly
terminated.


38
00:01:46,636 --> 00:01:48,106
This can happen in
a variety of ways.


39
00:01:48,106 --> 00:01:49,586
We'll discuss all of them.


40
00:01:49,586 --> 00:01:51,186
But in particular you
should keep in mind


41
00:01:51,186 --> 00:01:53,836
that your application being
terminated aggressively while


42
00:01:53,836 --> 00:01:56,736
the user is watching is only
the worst possible outcome.


43
00:01:57,406 --> 00:01:59,246
It's also possible that
the user switches away


44
00:01:59,246 --> 00:02:00,196
from your application,


45
00:02:00,496 --> 00:02:03,526
and because you're using too
much memory the system needs


46
00:02:03,526 --> 00:02:06,396
to clean that up, it discards
your application, and it's slow


47
00:02:06,396 --> 00:02:08,126
to come back to your
app the next time.


48
00:02:08,316 --> 00:02:10,586
And that's another form
of poor user experience.


49
00:02:11,316 --> 00:02:13,486
So, again, memory is really
critical in this sense.


50
00:02:14,116 --> 00:02:15,826
But it's critical in
another sense as well.


51
00:02:16,396 --> 00:02:19,246
Poor management of memory
can lead to bugs that result


52
00:02:19,246 --> 00:02:21,916
in the immediate crash of your
application even though your


53
00:02:21,916 --> 00:02:23,786
resources may not be excessive.


54
00:02:24,736 --> 00:02:26,076
So we're going to focus on all


55
00:02:26,076 --> 00:02:27,866
of these problems
throughout this session.


56
00:02:28,606 --> 00:02:30,866
Specifically, if you
look at our agenda,


57
00:02:31,086 --> 00:02:33,616
we're going to talk a little
bit about app memory in general.


58
00:02:33,616 --> 00:02:34,896
What does it look like?


59
00:02:34,896 --> 00:02:38,016
How can you think about it, and
what kinds of tools do we have


60
00:02:38,016 --> 00:02:39,676
to help you understand
what's going on?


61
00:02:40,776 --> 00:02:42,186
We're going to talk
about the Heap,


62
00:02:42,336 --> 00:02:45,776
because every memory discussion
discusses the Heap and, in fact,


63
00:02:45,776 --> 00:02:49,206
that's an area where not only do
you have a lot of resource uses,


64
00:02:49,656 --> 00:02:52,186
you have keys to
finding other areas


65
00:02:52,336 --> 00:02:53,826
where there's memory
being occupied.


66
00:02:53,826 --> 00:02:55,336
And we'll talk about
how that works.


67
00:02:56,086 --> 00:02:58,266
I'll hand it over to one of
my engineers, and we'll move


68
00:02:58,266 --> 00:03:00,206
on to talking about Objective-C,


69
00:03:00,436 --> 00:03:03,216
challenges on that front
including retained releases


70
00:03:03,216 --> 00:03:03,616
a pattern.


71
00:03:04,136 --> 00:03:07,226
And, lastly, how to be a really
good citizen in the environment.


72
00:03:08,606 --> 00:03:11,286
So an overview of
application memory.


73
00:03:12,896 --> 00:03:14,446
Thankfully this release,


74
00:03:14,446 --> 00:03:16,446
and doubtless you've seen
this numerous times before,


75
00:03:16,826 --> 00:03:19,606
we now have the debug
gauges in Xcode.


76
00:03:19,866 --> 00:03:22,136
The debug gauges give you
access, among other things,


77
00:03:22,176 --> 00:03:23,556
to memory at a glance.


78
00:03:24,106 --> 00:03:27,596
So there's a gauge that
you can move to, click on,


79
00:03:27,966 --> 00:03:29,516
and you'll get an
additional report


80
00:03:29,516 --> 00:03:31,586
that shows you more detail
about your application.


81
00:03:31,866 --> 00:03:34,706
We've tried to break this down
to one number that's most likely


82
00:03:34,706 --> 00:03:35,636
to be meaningful to you.


83
00:03:35,996 --> 00:03:36,986
In this case you can think of it


84
00:03:36,986 --> 00:03:38,986
as the footprint of
your application.


85
00:03:39,826 --> 00:03:41,776
That one number gives
you a good indication


86
00:03:41,776 --> 00:03:43,876
as you're running your app
because it's always present


87
00:03:43,876 --> 00:03:45,966
in the debugger of
just what you're doing.


88
00:03:45,966 --> 00:03:48,216
If you're starting to consume
more resources over time,


89
00:03:48,656 --> 00:03:51,166
if something catastrophic
does occur just what point


90
00:03:51,166 --> 00:03:51,856
that occurred at.


91
00:03:51,856 --> 00:03:54,596
So you've got a good
indicator when you might need


92
00:03:54,596 --> 00:03:55,796
to go and use Instruments.


93
00:03:56,186 --> 00:03:58,136
And, indeed, there's a
handy button right there


94
00:03:58,396 --> 00:04:00,906
that if you see a trend you
don't like we can go directly


95
00:04:00,906 --> 00:04:03,156
to Instruments from
the debug gauge.


96
00:04:05,796 --> 00:04:09,946
You need to understand that
this memory number is just one


97
00:04:09,946 --> 00:04:12,976
number, and there are all
kinds of ways to measure memory


98
00:04:12,976 --> 00:04:14,376
as we'll discuss again in a bit.


99
00:04:14,806 --> 00:04:18,716
But Instruments is typically
traditionally focused


100
00:04:18,716 --> 00:04:19,406
on the Heap.


101
00:04:19,406 --> 00:04:21,016
And you may have seen situations


102
00:04:21,016 --> 00:04:23,476
where your application was
summarily killed despite the


103
00:04:23,476 --> 00:04:25,156
fact that your Heap
was relatively small.


104
00:04:26,186 --> 00:04:28,246
It's important to know
that there's really a lot


105
00:04:28,246 --> 00:04:30,976
of other memory involved
in your application


106
00:04:30,976 --> 00:04:33,086
that you may not have thought
about, may not have had to worry


107
00:04:33,086 --> 00:04:36,376
about or may not have had the
tools to understand before


108
00:04:36,776 --> 00:04:40,016
that can take the form of code,
it could be images, media.


109
00:04:40,236 --> 00:04:41,886
It could be a lot
of different things


110
00:04:41,886 --> 00:04:43,676
that you haven't been
able to see before.


111
00:04:44,076 --> 00:04:46,166
So the big question
is how do you get


112
00:04:46,166 --> 00:04:47,756
to all of this information?


113
00:04:50,696 --> 00:04:53,176
Lastly, again, this point


114
00:04:53,176 --> 00:04:56,296
that your measurement will tell
you different numbers depending


115
00:04:56,296 --> 00:04:59,206
on the tool you use, the
strategy that the tool uses


116
00:04:59,206 --> 00:05:02,126
to find that information and
really what you're looking for.


117
00:05:02,436 --> 00:05:05,596
So if you're looking for one
number that sums up everything


118
00:05:05,596 --> 00:05:08,086
about your application, in
some sense you're trying


119
00:05:08,086 --> 00:05:10,686
to oversimplify what's
really a fairly complex set


120
00:05:10,686 --> 00:05:11,866
of subsystems operating.


121
00:05:12,146 --> 00:05:15,346
So you will see that the gauge
provides you one set of numbers.


122
00:05:15,586 --> 00:05:18,326
Again, it's what we think is
the most meaningful number.


123
00:05:18,756 --> 00:05:21,256
But there are other numbers that
we can explore, and as we go


124
00:05:21,256 --> 00:05:23,166
through Instruments you'll
see some of those as well.


125
00:05:23,906 --> 00:05:26,036
So it sounds like the
right time to dive on in


126
00:05:26,306 --> 00:05:27,866
and have a look at
this workflow.


127
00:05:27,926 --> 00:05:32,946
I'm just going to bring
up a project here.


128
00:05:32,946 --> 00:05:37,676
And this project is one that
you're probably familiar


129
00:05:37,676 --> 00:05:39,276
with if not in source code


130
00:05:39,276 --> 00:05:40,506
because we don't
make it available,


131
00:05:40,746 --> 00:05:42,876
then because you've used it
every day at this conference.


132
00:05:42,876 --> 00:05:45,446
It's the WWDC app that
you have on your devices.


133
00:05:47,306 --> 00:05:50,446
Or at least it's an early
version of it with a few issues,


134
00:05:50,596 --> 00:05:53,176
maybe some of them having been
introduced by us for purposes


135
00:05:53,426 --> 00:05:54,906
that will become
clear on the stage.


136
00:05:55,406 --> 00:05:58,426
So let's go ahead and
run that application.


137
00:05:58,466 --> 00:05:59,786
So it's been deployed
to my device.


138
00:06:00,426 --> 00:06:01,156
It's up and running.


139
00:06:04,596 --> 00:06:07,756
And we'll see that the gauges
are providing me feedback here


140
00:06:07,756 --> 00:06:09,586
about how much CPU
time I'm using,


141
00:06:09,586 --> 00:06:10,626
how much memory I'm using.


142
00:06:10,786 --> 00:06:12,926
And so as I exercise the
app I'm going to drill


143
00:06:12,926 --> 00:06:14,346
into a particular session.


144
00:06:14,686 --> 00:06:17,776
I'm going to go ahead and look
at maps, look at news, videos.


145
00:06:17,776 --> 00:06:19,386
You can't see any
of this but, again,


146
00:06:19,386 --> 00:06:20,916
the workflow should
be familiar to you.


147
00:06:21,376 --> 00:06:23,496
And so I've come back to
the initial state I was in,


148
00:06:23,496 --> 00:06:26,606
and I've seen rather a lot
of growth over that time.


149
00:06:27,156 --> 00:06:29,876
So maybe I want to have a
look at that memory curve.


150
00:06:29,876 --> 00:06:32,176
And it doesn't look spectacular.


151
00:06:32,176 --> 00:06:33,696
It's kind of going the
wrong direction here.


152
00:06:34,036 --> 00:06:35,496
There's enough information
here to know


153
00:06:35,496 --> 00:06:37,266
that there's something
I should investigate,


154
00:06:37,646 --> 00:06:38,696
but not enough information


155
00:06:38,696 --> 00:06:40,196
to tell me what exactly
I should do.


156
00:06:40,546 --> 00:06:43,516
That's the time that we might
go to profile in Instruments.


157
00:06:43,966 --> 00:06:46,836
And so by simply clicking
here I get a prompt,


158
00:06:46,836 --> 00:06:48,336
and I have two options
at this point.


159
00:06:48,746 --> 00:06:52,156
I can choose to stop
my debug session


160
00:06:52,316 --> 00:06:55,086
and hand this existing
running application off


161
00:06:55,086 --> 00:06:56,496
to Instruments to investigate.


162
00:06:57,426 --> 00:06:59,286
I will have missed
the opportunity then


163
00:06:59,286 --> 00:07:01,756
to measure a lot of
important information


164
00:07:01,756 --> 00:07:03,836
about the allocations that
have already occurred.


165
00:07:04,226 --> 00:07:07,236
So when you're looking at memory
that's rarely the right option.


166
00:07:07,776 --> 00:07:09,186
It's possible there
may be things


167
00:07:09,186 --> 00:07:10,736
that you could learn
using that technique,


168
00:07:11,046 --> 00:07:12,306
but for our purposes no.


169
00:07:12,466 --> 00:07:15,836
We're going to ask to stop the
debug session, launch a new copy


170
00:07:15,836 --> 00:07:18,636
of the application
inside Instruments.


171
00:07:19,266 --> 00:07:22,926
And we may see here what you may
very well have run into already


172
00:07:22,926 --> 00:07:24,486
if you've been experimenting
with the seed,


173
00:07:24,966 --> 00:07:28,106
that in the initial seed the
handoff is not always graceful.


174
00:07:28,686 --> 00:07:31,326
If you run into problems
you can stop the application


175
00:07:31,886 --> 00:07:34,956
and simply start
re-recording in Instruments.


176
00:07:34,956 --> 00:07:36,336
Obviously this will
be corrected.


177
00:07:37,646 --> 00:07:40,086
So we've got our application up
and running under Instruments.


178
00:07:40,086 --> 00:07:42,296
We're getting recordings
here of what's going


179
00:07:42,296 --> 00:07:44,116
on in terms of memory
allocation.


180
00:07:44,456 --> 00:07:46,306
And we're seeing a
nice allocations curve.


181
00:07:46,896 --> 00:07:50,646
I mentioned before that
typically Instruments is shown


182
00:07:50,646 --> 00:07:52,466
as Heap information
in allocations.


183
00:07:52,866 --> 00:07:53,616
Well, if we look at some


184
00:07:53,616 --> 00:07:56,226
of these numbers we would
expect then maybe to see numbers


185
00:07:56,226 --> 00:07:57,826
that are smaller
than the numbers


186
00:07:57,826 --> 00:07:59,146
that are being reported
by the gauge.


187
00:07:59,666 --> 00:08:00,866
That's no longer the case.


188
00:08:01,456 --> 00:08:04,256
My total live bytes being
reported here, 57 meg,


189
00:08:04,256 --> 00:08:07,266
is actually even more than
the number reported in gauges.


190
00:08:07,266 --> 00:08:09,156
And that's because
allocations has been enhanced


191
00:08:09,526 --> 00:08:10,896
to show a lot more information


192
00:08:10,966 --> 00:08:12,356
than we've been able
to see in the past.


193
00:08:12,676 --> 00:08:15,006
In particular it's not
just Heap allocations


194
00:08:15,326 --> 00:08:18,126
but all virtual memory regions
that have been allocated,


195
00:08:18,646 --> 00:08:21,016
mapped into memory while
your application was running.


196
00:08:22,426 --> 00:08:26,166
So if you look here specifically
we actually have a filter


197
00:08:26,166 --> 00:08:28,966
that allows us to
see a blended view


198
00:08:28,966 --> 00:08:32,716
of both Heap allocations
and VM allocations.


199
00:08:32,926 --> 00:08:34,696
Or we can focus on just the heap


200
00:08:35,116 --> 00:08:37,806
which is really just
3.6 meg in this case.


201
00:08:38,366 --> 00:08:41,506
Or just the VM regions which
accounts for rather a lot


202
00:08:41,506 --> 00:08:42,655
of memory in my application,


203
00:08:43,006 --> 00:08:45,346
memory that you haven't been
able to see in the past.


204
00:08:45,906 --> 00:08:46,886
Well, that's interesting,


205
00:08:46,886 --> 00:08:48,106
what kinds of things
have we got here?


206
00:08:48,516 --> 00:08:52,096
Well, if we sort by
live bytes we'll see


207
00:08:52,096 --> 00:08:56,396
that we have mapped files, and I
can dive in and see specifically


208
00:08:56,516 --> 00:09:00,476
which files, zoom back out,
which files have been mapped


209
00:09:00,476 --> 00:09:02,616
into my application,
when they were mapped in


210
00:09:02,616 --> 00:09:03,876
and get additional information.


211
00:09:03,876 --> 00:09:06,406
In fact, I can find a
particular file of interest


212
00:09:06,646 --> 00:09:09,186
and find the call stack
that was responsible.


213
00:09:09,186 --> 00:09:12,126
What was it in my code that
caused this to be mapped in?


214
00:09:12,746 --> 00:09:13,286
Interesting.


215
00:09:14,556 --> 00:09:17,596
But in this particular case
what caught my eye wasn't the


216
00:09:17,596 --> 00:09:18,366
mapped files.


217
00:09:19,886 --> 00:09:21,986
It was all of this image IO.


218
00:09:22,866 --> 00:09:24,746
So I've got image IO going on,


219
00:09:24,956 --> 00:09:27,886
and as I exercise the
application in the same fashion


220
00:09:27,886 --> 00:09:31,496
that I exercised it a moment
ago, we'll see that, in fact,


221
00:09:31,496 --> 00:09:34,146
image IO turns out to be
a pretty substantial chunk


222
00:09:34,986 --> 00:09:36,456
of what my application is doing.


223
00:09:36,456 --> 00:09:39,036
In fact, it's dwarfing the
Heap memory at this point.


224
00:09:39,396 --> 00:09:41,916
So optimizing for my Heap is
maybe not the most important


225
00:09:41,916 --> 00:09:42,836
thing for me to consider.


226
00:09:43,346 --> 00:09:45,206
Maybe I need to understand
this a little better.


227
00:09:45,796 --> 00:09:46,906
And a lot of the tools


228
00:09:46,906 --> 00:09:49,146
that we've used before
help me understand this.


229
00:09:49,506 --> 00:09:51,886
So if I were to go into
my call trees view,


230
00:09:52,206 --> 00:09:54,106
the call trees view
will show me, again,


231
00:09:54,106 --> 00:09:56,976
down which paths the
allocations are occurring.


232
00:09:57,986 --> 00:09:59,976
If I search for


233
00:10:01,276 --> 00:10:02,776
image IO work here I can see


234
00:10:02,776 --> 00:10:05,486
that there's core
animation-related things


235
00:10:05,486 --> 00:10:09,206
happening that are resulting
in memory mapped operations.


236
00:10:09,206 --> 00:10:10,526
And so I can actually drill down


237
00:10:10,876 --> 00:10:12,876
and see the call path
that led to this.


238
00:10:13,486 --> 00:10:16,746
It's interesting because I will
see there are actually also


239
00:10:17,236 --> 00:10:20,776
malloc operations operating on
the Heap in the same vicinity.


240
00:10:21,276 --> 00:10:23,046
In fact, if I look at this line,


241
00:10:23,716 --> 00:10:28,486
we'll go up even one more level
here, 7.83 meg is being called


242
00:10:28,526 --> 00:10:30,856
down this path somewhere
in code.


243
00:10:31,906 --> 00:10:36,026
7.82 meg of that looks
like it's mapped memory,


244
00:10:36,336 --> 00:10:38,406
memory that would
show up as VM regions


245
00:10:38,406 --> 00:10:39,706
that I couldn't see before.


246
00:10:39,706 --> 00:10:42,176
So I'd have this
tiny amount of memory


247
00:10:42,176 --> 00:10:44,956
on the Heap that's
allocated down this same path


248
00:10:44,956 --> 00:10:47,646
and represents the same
work that's allocating all


249
00:10:47,646 --> 00:10:48,406
of these images.


250
00:10:48,636 --> 00:10:50,536
That's what we'd like to
be able to queue in on


251
00:10:50,536 --> 00:10:52,486
and understand a
lot better in order


252
00:10:52,486 --> 00:10:54,456
to control the behavior
of our application.


253
00:10:55,116 --> 00:10:57,786
So these are some interesting
new tools that we have.


254
00:10:57,786 --> 00:10:59,766
Of course we have some
familiar tools as well.


255
00:10:59,766 --> 00:11:02,696
I'm going to dig into
the library and bring


256
00:11:02,696 --> 00:11:05,886
out one other familiar
favorite, VM Tracker,


257
00:11:06,416 --> 00:11:10,826
and record a little bit
about the current state


258
00:11:10,826 --> 00:11:12,836
of my application
from VM Tracker.


259
00:11:13,606 --> 00:11:16,006
The reason I bring this up
we'll dive into in a moment,


260
00:11:16,006 --> 00:11:19,546
but virtual memory is an
interesting slippery beast.


261
00:11:19,546 --> 00:11:22,496
A region can represent
a lot of memory space


262
00:11:22,896 --> 00:11:25,846
but have only portions of that
memory actually in active use


263
00:11:25,846 --> 00:11:27,416
in physical RAM on your device.


264
00:11:27,876 --> 00:11:30,026
And the VM Tracker is
one way that you can dig


265
00:11:30,026 --> 00:11:30,916
in and understand this.


266
00:11:31,096 --> 00:11:35,156
So the VM Tracker in this case
is showing me information like,


267
00:11:35,496 --> 00:11:37,886
okay, there's this image
IO that's going on.


268
00:11:38,456 --> 00:11:42,936
Of that image IO how
much of it is virtual,


269
00:11:42,936 --> 00:11:45,456
how much of it is dirty and
how much of it is resident?


270
00:11:46,006 --> 00:11:49,726
These are incredibly important
queues that we really need


271
00:11:49,726 --> 00:11:54,636
to understand a little better
in order to see the full picture


272
00:11:54,636 --> 00:11:56,526
of what's going on in
my applications memory.


273
00:11:57,116 --> 00:12:01,946
I'd also like to point out that
if you've used the Instruments


274
00:12:01,976 --> 00:12:04,206
from sort of a casual
perspective, you go in


275
00:12:04,206 --> 00:12:06,246
and you look at the
default presentations,


276
00:12:06,246 --> 00:12:09,066
you haven't really tried tuning
the way you look at things,


277
00:12:09,336 --> 00:12:11,466
you might want to try
clicking on the left side


278
00:12:11,466 --> 00:12:12,766
of the navigation bar here.


279
00:12:13,286 --> 00:12:15,176
Because this isn't
just about navigation


280
00:12:15,176 --> 00:12:16,116
in the bread crumb trail,


281
00:12:16,376 --> 00:12:18,736
it's about fundamentally
different views


282
00:12:18,886 --> 00:12:20,096
for the instruments
that we have.


283
00:12:20,096 --> 00:12:22,206
And so for the VM Tracker one


284
00:12:22,206 --> 00:12:26,136
of those handy views is the
region's map that allows me


285
00:12:26,136 --> 00:12:28,806
to see where things
are laid out in memory.


286
00:12:28,806 --> 00:12:32,386
So I could actually understand
my virtual memory address range,


287
00:12:32,566 --> 00:12:34,506
which things are adjacent
to which other things


288
00:12:34,506 --> 00:12:37,326
in case I'm overriding the
end of some buffer, et cetera.


289
00:12:37,526 --> 00:12:39,336
There's a lot of good
information in here.


290
00:12:39,616 --> 00:12:42,446
We won't cover it all in this
session sadly, but we are going


291
00:12:42,446 --> 00:12:44,006
to focus on some of the things


292
00:12:44,006 --> 00:12:46,466
that are particularly
new this time around.


293
00:12:47,516 --> 00:12:50,546
[ Pause ]


294
00:12:51,046 --> 00:12:52,336
So let's switch back to slides.


295
00:12:57,056 --> 00:12:58,306
We talked about the fact


296
00:12:58,306 --> 00:13:01,446
that virtual memory is
now more fully represented


297
00:13:01,656 --> 00:13:02,546
in allocations.


298
00:13:02,736 --> 00:13:04,676
And we have a lot
of familiar tools


299
00:13:04,676 --> 00:13:06,146
and techniques that
we can apply.


300
00:13:07,026 --> 00:13:10,106
There's one that may not be
quite so obvious, though,


301
00:13:10,306 --> 00:13:12,316
this notion that there's
an efficient alternative


302
00:13:12,396 --> 00:13:15,106
to running allocations on
your application as is.


303
00:13:15,106 --> 00:13:16,866
If you've ever tried
using Allocations


304
00:13:16,866 --> 00:13:19,126
on a particularly
large app you'll note


305
00:13:19,126 --> 00:13:21,396
that it's tracking a
lot of information,


306
00:13:21,776 --> 00:13:24,726
millions upon millions of
allocations and deallocations,


307
00:13:24,726 --> 00:13:27,326
and bookkeeping for that
winds up actually taking a lot


308
00:13:27,326 --> 00:13:28,736
of memory and a lot of time.


309
00:13:28,856 --> 00:13:31,076
So if you've got an application
that you've never been able


310
00:13:31,076 --> 00:13:34,036
to use Allocations on
before there's a new


311
00:13:34,036 --> 00:13:35,076
interesting technique.


312
00:13:35,076 --> 00:13:39,806
If you open the configuration
panel for Allocations and move


313
00:13:39,806 --> 00:13:44,876
to only VM Allocation tracking,
you will lose your ability


314
00:13:44,876 --> 00:13:46,806
to see the fine grained
information on the Heap,


315
00:13:47,286 --> 00:13:49,946
but you can still see the
big picture in terms of VM,


316
00:13:49,946 --> 00:13:53,016
and that could be a powerful
tool for applications


317
00:13:53,016 --> 00:13:55,846
that previously there was no
way to get any insight into.


318
00:13:57,756 --> 00:13:59,936
Because this does
give us insight


319
00:14:00,086 --> 00:14:01,526
into some very interesting
things.


320
00:14:01,526 --> 00:14:04,236
It gives us an idea of who
mapped files into memory,


321
00:14:04,496 --> 00:14:07,616
who is responsible for
contributing to my footprint


322
00:14:07,616 --> 00:14:09,956
in a way that the
Heap never could.


323
00:14:10,786 --> 00:14:13,206
And, again, for page
level statistics,


324
00:14:13,436 --> 00:14:15,756
so beyond the VM region
to an individual page,


325
00:14:15,756 --> 00:14:18,696
a concept we'll talk about in a
moment, there's the VM Tracker


326
00:14:18,696 --> 00:14:20,646
which can give me more depth.


327
00:14:23,216 --> 00:14:28,046
So, sorry, built.


328
00:14:29,556 --> 00:14:30,466
Virtual memory.


329
00:14:30,646 --> 00:14:32,196
We've talked a lot
about virtual memory.


330
00:14:32,196 --> 00:14:35,866
I pointed out concepts like
dirty memory, resident memory,


331
00:14:36,336 --> 00:14:38,686
these are things that may
or may not be familiar


332
00:14:38,686 --> 00:14:40,326
so let's go through
them briefly.


333
00:14:40,946 --> 00:14:43,586
The notion of virtual memory
versus resident memory.


334
00:14:44,096 --> 00:14:46,546
My virtual memory isn't
a logical address space


335
00:14:46,616 --> 00:14:49,516
from address 0 to the
top of logical memory,


336
00:14:49,716 --> 00:14:53,006
and every single process has
its own virtual memory region.


337
00:14:53,386 --> 00:14:56,356
Process A may be thinking
it has memory at address 0


338
00:14:56,356 --> 00:14:57,906
and process B thinks
the same thing.


339
00:14:57,906 --> 00:15:00,766
And obviously they have
distinct chunks of memory.


340
00:15:01,186 --> 00:15:03,356
So this is a nice
logical concept


341
00:15:03,356 --> 00:15:04,996
from an application
developer's point of view.


342
00:15:04,996 --> 00:15:06,996
You can pretend that
you own all of RAM,


343
00:15:07,456 --> 00:15:11,876
but the reality is a little
bit more complicated than that.


344
00:15:11,876 --> 00:15:15,106
All memory regions that
are reserved are allocated


345
00:15:15,106 --> 00:15:19,646
on 4K page boundaries and
occupy a fixed number of pages


346
00:15:19,936 --> 00:15:21,336
so you'll never share a page


347
00:15:21,336 --> 00:15:22,796
with another virtual
memory region.


348
00:15:23,456 --> 00:15:26,676
So the example we have up here
you'll see that we have a region


349
00:15:26,676 --> 00:15:30,076
that consists of 2 pages, 8K,
another region that consists


350
00:15:30,076 --> 00:15:34,766
of 3 pages, 12K, and that's
representing my virtual address


351
00:15:34,766 --> 00:15:35,256
space here.


352
00:15:35,696 --> 00:15:37,316
But nothing's actually
in RAM yet.


353
00:15:37,826 --> 00:15:39,776
This is all just from
my application's point


354
00:15:39,776 --> 00:15:42,286
of view a simplistic way
of looking at the world.


355
00:15:43,656 --> 00:15:47,466
What happens is that on the
first use, whether I read


356
00:15:47,466 --> 00:15:50,776
from a chunk of memory or write
to a piece of memory it winds


357
00:15:50,776 --> 00:15:52,196
up being mapped into
physical memory.


358
00:15:52,196 --> 00:15:55,656
We find a page that's not used
in physical memory it's unlikely


359
00:15:55,656 --> 00:15:57,916
to be the first page, there's
probably an operating system up


360
00:15:57,916 --> 00:16:00,706
and running at this point, but
it finds a page that's unused


361
00:16:00,706 --> 00:16:03,386
and it maps it to a page
of your application.


362
00:16:04,356 --> 00:16:05,786
Same thing happens again.


363
00:16:05,786 --> 00:16:07,406
I find some other
page that I touch,


364
00:16:07,406 --> 00:16:09,796
and these can be completely
disjoint, and these result


365
00:16:09,796 --> 00:16:11,496
in physical memory coming in.


366
00:16:12,046 --> 00:16:15,726
What happens is we describe
these as having become resident.


367
00:16:16,026 --> 00:16:18,346
So it's still virtual
memory, we still talk about it


368
00:16:18,346 --> 00:16:20,106
as virtual memory,
but only a portion


369
00:16:20,106 --> 00:16:23,596
of it is actually resident in
physical RAM at any given time.


370
00:16:25,336 --> 00:16:27,316
Part of the reason that I
like to draw the distinction


371
00:16:27,316 --> 00:16:30,216
between these two is because
while physical memory is more


372
00:16:30,216 --> 00:16:32,766
likely to be your constraint,
we've tried to illustrate this


373
00:16:32,766 --> 00:16:35,706
with the shorter bar,
it's not always the case.


374
00:16:35,706 --> 00:16:38,616
It's possible in an application
that you will try to map


375
00:16:38,616 --> 00:16:41,606
in too many media resources
in case you ever need them.


376
00:16:41,606 --> 00:16:43,846
And so despite the fact that
you've never read a single one


377
00:16:43,846 --> 00:16:46,536
of them, you've exhausted
the amount of virtual memory


378
00:16:46,576 --> 00:16:49,026
that the operating system
is going to allow you.


379
00:16:49,296 --> 00:16:51,526
In particular on
iOS you may find


380
00:16:51,526 --> 00:16:52,776
that you don't have much loaded,


381
00:16:53,056 --> 00:16:55,966
but if you exhaust the virtual
memory space that we allow


382
00:16:55,966 --> 00:16:58,996
for you we will simply kill
your application outright.


383
00:16:59,536 --> 00:17:01,496
So it's possible to
run into that limit.


384
00:17:01,736 --> 00:17:04,746
It is much more likely instead
that I'll run into limits


385
00:17:04,746 --> 00:17:06,496
in terms of physical RAM.


386
00:17:07,656 --> 00:17:10,256
The notion of clean
versus dirty comes up next.


387
00:17:10,256 --> 00:17:11,856
What's dirty memory represent?


388
00:17:12,506 --> 00:17:13,915
Well, clean pages are pages


389
00:17:13,915 --> 00:17:16,685
that we can discard
at will and recreate.


390
00:17:17,816 --> 00:17:19,185
What kinds of pages
can we do that with?


391
00:17:19,185 --> 00:17:21,526
Well, if we've loaded
some code from Flash


392
00:17:21,626 --> 00:17:26,246
or from a physical disk
drive we've loaded that in,


393
00:17:26,246 --> 00:17:27,376
we know where it came from.


394
00:17:27,376 --> 00:17:29,486
If we need that memory
back we can throw it away.


395
00:17:29,486 --> 00:17:31,086
We can always reload
it from disk.


396
00:17:31,476 --> 00:17:32,986
That memory is still
considered clean


397
00:17:33,206 --> 00:17:34,456
because it can be discarded.


398
00:17:34,716 --> 00:17:36,886
And this is true
of OS X and iOS.


399
00:17:38,036 --> 00:17:40,646
On the other hand as
soon as I touch a page


400
00:17:40,646 --> 00:17:42,236
and actually modify its contents


401
00:17:42,456 --> 00:17:44,636
so that there's no longer
essentially a backup copy


402
00:17:44,636 --> 00:17:47,146
that we can readily get we
consider that memory dirty.


403
00:17:47,536 --> 00:17:50,736
And so basically everything
on your Heap, your Stacks,


404
00:17:50,736 --> 00:17:53,216
global variables, all
of this is dirty RAM.


405
00:17:53,406 --> 00:17:55,636
It's RAM that we have
to keep in memory --


406
00:17:56,236 --> 00:18:00,076
sorry, information that we
have to keep in memory in order


407
00:18:00,076 --> 00:18:01,686
for you to be able to
continue executing.


408
00:18:02,086 --> 00:18:05,396
That's absolutely
critical for your sanity.


409
00:18:06,646 --> 00:18:08,996
So what happens when
we start running low


410
00:18:08,996 --> 00:18:12,746
on memory is we'll start
discarding pages that are clean.


411
00:18:14,226 --> 00:18:16,986
On OS X then we will also worry


412
00:18:16,986 --> 00:18:19,486
about what we can do
to swap things out.


413
00:18:19,486 --> 00:18:21,626
We'll take dirty pages
and write them to disk


414
00:18:21,626 --> 00:18:24,156
so we do have a backup copy
and we can reuse that memory.


415
00:18:24,376 --> 00:18:26,656
At this point your system
will start to slow as it needs


416
00:18:26,656 --> 00:18:28,186
to page memory in and out.


417
00:18:28,946 --> 00:18:31,396
But on iOS the situation
is much more drastic.


418
00:18:32,066 --> 00:18:35,236
If there's dirty memory and we
haven't got anywhere to put it


419
00:18:35,236 --> 00:18:38,566
because we don't write it
to Flash, too expensive


420
00:18:38,566 --> 00:18:39,926
for a variety of reasons,


421
00:18:39,926 --> 00:18:41,786
we will simply terminate
your application.


422
00:18:42,406 --> 00:18:44,816
So you absolutely need
to keep your dirty memory


423
00:18:45,016 --> 00:18:47,156
under control especially on iOS.


424
00:18:47,846 --> 00:18:52,466
So this process of swapping
gives us potential but, again,


425
00:18:52,466 --> 00:18:55,006
for the vast majority of
you it's not available.


426
00:18:55,726 --> 00:18:57,666
The last concept is the notion


427
00:18:57,666 --> 00:19:00,226
of private memory
versus shared memory.


428
00:19:01,326 --> 00:19:03,566
When I create a memory
region I can give it a name,


429
00:19:03,566 --> 00:19:06,726
and by giving it a name another
process can actually use the


430
00:19:06,726 --> 00:19:09,906
same physical memory and map it
into its virtual address space.


431
00:19:11,156 --> 00:19:13,816
Well, as it turns out in a
lot of cases you will wind


432
00:19:13,816 --> 00:19:16,916
up instead with memory that
is automatically shared,


433
00:19:16,916 --> 00:19:20,116
implicitly given a name
because it's mapped to a file.


434
00:19:20,116 --> 00:19:21,516
And so as soon as I map a file


435
00:19:21,516 --> 00:19:24,586
if somebody maps the same file
we're now sharing that memory.


436
00:19:25,146 --> 00:19:27,826
So consider an example where
I write an application.


437
00:19:27,826 --> 00:19:29,396
The first thing that
happens is a piece


438
00:19:29,396 --> 00:19:31,266
of code gets paged in, okay?


439
00:19:31,296 --> 00:19:33,846
We hit the code off
disk, it's now mapped


440
00:19:33,846 --> 00:19:34,946
into my address space.


441
00:19:35,446 --> 00:19:38,386
I then go and allocate
something on the Heap,


442
00:19:38,386 --> 00:19:40,626
and so I need a page that
backs some of the Heap.


443
00:19:40,626 --> 00:19:42,966
And now we've got one
process up and running.


444
00:19:42,966 --> 00:19:46,796
But now I launch another
instance of the same process.


445
00:19:48,426 --> 00:19:50,586
It's got its own address space.


446
00:19:51,176 --> 00:19:54,706
So it has a completely separate
address space that they happen


447
00:19:54,706 --> 00:19:56,846
to potentially align
here, they may not.


448
00:19:57,826 --> 00:19:59,406
And now it needs to load code.


449
00:19:59,616 --> 00:19:59,956
Well,


450
00:20:00,046 --> 00:20:03,086
because the code is coming
from a file it's actually able


451
00:20:03,086 --> 00:20:05,636
to map the same chunk
of physical memory


452
00:20:05,816 --> 00:20:07,336
into its virtual address space.


453
00:20:08,146 --> 00:20:09,776
But then it goes to put
something on the Heap,


454
00:20:09,776 --> 00:20:13,306
and because this is logically
a separate instance its data is


455
00:20:13,306 --> 00:20:16,206
kept independently,
and this is separate.


456
00:20:16,206 --> 00:20:18,006
This is what we call
private memory.


457
00:20:18,646 --> 00:20:21,896
So often you will see a
focus on your private memory,


458
00:20:22,266 --> 00:20:24,626
memory that is not potentially
shared with anyone else


459
00:20:24,626 --> 00:20:26,056
because all the frameworks
are shared.


460
00:20:26,056 --> 00:20:28,736
It's generally not considered
reasonable to account


461
00:20:28,736 --> 00:20:31,656
against your process what you're
using from the frameworks.


462
00:20:32,626 --> 00:20:35,286
And instead we want to focus
on the private dirty memory,


463
00:20:35,286 --> 00:20:38,246
and that's largely what we
show you with the Xcode gauges.


464
00:20:38,716 --> 00:20:41,796
So we're going to talk
about Heap memory.


465
00:20:42,646 --> 00:20:44,686
What is the Heap?


466
00:20:44,896 --> 00:20:47,886
Probably a familiar concept for
most of you, but if it's not,


467
00:20:48,606 --> 00:20:52,466
any time you call malloc you are
allocating a chunk of memory,


468
00:20:52,466 --> 00:20:54,316
and it's potentially
quite small.


469
00:20:54,316 --> 00:20:56,436
This is often used for
fine grained things,


470
00:20:56,436 --> 00:20:58,346
a dozen bytes or more.


471
00:20:58,886 --> 00:21:00,836
But it can also be used
for fairly large things,


472
00:21:00,936 --> 00:21:02,566
and it's in this managed area.


473
00:21:04,126 --> 00:21:07,176
You may not have called malloc,
but if you've called alloc


474
00:21:07,176 --> 00:21:09,086
or new on an Objective-C object


475
00:21:09,086 --> 00:21:10,666
under the covers
that's what it's doing.


476
00:21:10,836 --> 00:21:12,356
Or if you use the new operator


477
00:21:12,356 --> 00:21:14,616
on a C++ object that's
what it's been doing.


478
00:21:14,616 --> 00:21:17,276
And so you wind up with
these malloc zones.


479
00:21:17,836 --> 00:21:21,336
The malloc memory is actually
backed by virtual memory,


480
00:21:21,536 --> 00:21:23,066
so there's a virtual memory zone


481
00:21:23,066 --> 00:21:25,026
that the malloc subsystem
has created for you,


482
00:21:25,316 --> 00:21:26,926
and it's doing all
the bookkeeping to try


483
00:21:26,926 --> 00:21:29,456
to reuse space and
use space efficiently


484
00:21:29,696 --> 00:21:30,916
within that malloc region.


485
00:21:31,866 --> 00:21:33,976
So if you actually
look you will see


486
00:21:33,976 --> 00:21:36,196
that there is this VM
malloc region lying


487
00:21:36,196 --> 00:21:38,826
around that represents the
backing store for all of this.


488
00:21:39,266 --> 00:21:40,906
And typically things
that you keep


489
00:21:40,906 --> 00:21:43,156
on the heap you will often
have reference counted


490
00:21:43,236 --> 00:21:45,856
so that you can do fairly
sophisticated memory management.


491
00:21:45,856 --> 00:21:48,996
It takes care of a lot of
interesting bookkeeping for you.


492
00:21:50,006 --> 00:21:52,866
You may also wind up seeing it,
of course, allocated implicitly


493
00:21:52,866 --> 00:21:54,756
by other code on your behalf.


494
00:21:56,126 --> 00:21:58,926
So when I'm looking at the heap
things that I might want to keep


495
00:21:58,926 --> 00:22:00,576
in mind are that
there are some types


496
00:22:00,636 --> 00:22:02,766
that are more expensive
than others.


497
00:22:03,486 --> 00:22:04,456
VM is about bytes.


498
00:22:04,456 --> 00:22:07,026
I can look at a VM region
and say this is a couple


499
00:22:07,026 --> 00:22:09,046
of megabytes, that's
actually relatively large,


500
00:22:09,566 --> 00:22:11,936
but in the Heap typically,
again, things are going


501
00:22:11,936 --> 00:22:16,446
to be 16 bytes, 30 bytes, it's
going to be some small amount


502
00:22:16,446 --> 00:22:17,746
of memory that's reserved.


503
00:22:18,096 --> 00:22:21,266
And so it's the aggregation of
a large number of these things


504
00:22:21,266 --> 00:22:22,186
that gets interesting.


505
00:22:22,666 --> 00:22:23,726
Why is that important?


506
00:22:23,806 --> 00:22:27,856
It's important because in
practice a small object can have


507
00:22:27,856 --> 00:22:31,006
a large graph of other
objects that it references.


508
00:22:31,436 --> 00:22:33,506
So let's say we have,
for example here,


509
00:22:35,036 --> 00:22:37,906
in our world a view
of some kind.


510
00:22:39,616 --> 00:22:41,976
It actually contains
that small chunk


511
00:22:41,976 --> 00:22:44,766
of memory that's actually
allocated for us here,


512
00:22:45,016 --> 00:22:46,506
96 bytes in this case.


513
00:22:46,506 --> 00:22:51,156
It has a layer pointer, has view
delegate pointers, has pointers


514
00:22:51,156 --> 00:22:52,666
to all kinds of other objects.


515
00:22:52,926 --> 00:22:55,326
And these objects
themselves occupy space.


516
00:22:56,106 --> 00:22:58,716
The layer object in this
case another 32 bytes.


517
00:22:58,716 --> 00:23:00,336
And this may not seem
like it's going to add


518
00:23:00,336 --> 00:23:02,296
up in a hurry except that some


519
00:23:02,296 --> 00:23:07,486
of those objects manage whole
VM regions behind the scenes.


520
00:23:07,796 --> 00:23:10,706
So a CA layer needs to keep
its bitmap data somewhere,


521
00:23:10,826 --> 00:23:14,066
and as it turns out that data
isn't always on the Heap.


522
00:23:14,316 --> 00:23:17,016
In this case we've got a VM
region that could be megabytes


523
00:23:17,016 --> 00:23:18,316
and megabytes of pixel data.


524
00:23:18,676 --> 00:23:21,016
And so it behooves you
to understand that, yes,


525
00:23:21,156 --> 00:23:24,126
what I'm looking for are these
objects that keep large graphs


526
00:23:24,436 --> 00:23:26,266
of other objects
behind the scenes.


527
00:23:27,186 --> 00:23:28,276
There are the obvious ones.


528
00:23:28,276 --> 00:23:31,056
If I look for an NS set or
an NS dictionary I'll see


529
00:23:31,056 --> 00:23:32,436
that there's a relatively
small amount


530
00:23:32,436 --> 00:23:34,836
of memory attributed
to it by allocations.


531
00:23:35,356 --> 00:23:38,246
But really it's holding onto
we know potentially a large


532
00:23:38,246 --> 00:23:39,736
collection of objects.


533
00:23:39,736 --> 00:23:42,196
And then there's the less
obvious containers, again,


534
00:23:42,196 --> 00:23:44,836
UI view, view controllers
or NS image


535
00:23:45,176 --> 00:23:47,126
that represent a
lot of information.


536
00:23:47,396 --> 00:23:49,146
So as I showed you
earlier in the call graph


537
00:23:49,146 --> 00:23:52,786
where I found one place
that creates both an object


538
00:23:53,116 --> 00:23:55,726
and a VM region this is
what happens typically.


539
00:23:55,886 --> 00:23:58,616
And it's when you finally
de- reference the object


540
00:23:58,616 --> 00:24:02,436
that the VM region is
deallocated on your behalf.


541
00:24:02,836 --> 00:24:04,516
So what can I do to investigate?


542
00:24:05,296 --> 00:24:07,956
Well, as it turns out
there are a couple


543
00:24:07,956 --> 00:24:09,336
of ways to think about this.


544
00:24:09,406 --> 00:24:10,426
There are my classes.


545
00:24:11,296 --> 00:24:13,016
My classes is a subset.


546
00:24:13,016 --> 00:24:16,526
They're probably things
that hold onto large graphs.


547
00:24:17,046 --> 00:24:19,476
And so if you want to just see
just your classes you should


548
00:24:19,476 --> 00:24:21,076
probably prefix them
consistently.


549
00:24:21,666 --> 00:24:24,166
So in this app we have
everything prefixed with WWDC.


550
00:24:24,166 --> 00:24:26,216
And that means that I can
go ahead and just bring


551
00:24:26,216 --> 00:24:30,726
up the allocations UI, go
ahead and click in the filter


552
00:24:30,726 --> 00:24:33,196
in the upper right
corner and type my prefix.


553
00:24:35,436 --> 00:24:38,066
So once we've got that
prefix typed in you'll see


554
00:24:38,066 --> 00:24:42,036
that we're filtering down to
just the object whose category


555
00:24:42,036 --> 00:24:43,606
here uses that prefix.


556
00:24:43,606 --> 00:24:47,176
And category is the way we
divide all of the allocations


557
00:24:47,176 --> 00:24:51,716
into some reasonably
observable group of objects.


558
00:24:51,716 --> 00:24:54,816
And in this case it's based
on the class of the object.


559
00:24:54,816 --> 00:24:57,126
So if I've used a
consistent prefix it's easy.


560
00:24:57,126 --> 00:24:59,706
But we categorize
objects by things other


561
00:24:59,706 --> 00:25:01,736
than just Objective-C classes.


562
00:25:01,956 --> 00:25:03,586
Specifically we're much,


563
00:25:03,866 --> 00:25:07,286
much better in this
release at C++ objects.


564
00:25:07,286 --> 00:25:10,276
If you have a virtual
C++ class you'll find


565
00:25:10,276 --> 00:25:12,286
that we categorize
those by name as well.


566
00:25:12,886 --> 00:25:15,186
We also find other
things that have V tables.


567
00:25:15,546 --> 00:25:17,396
We can find dispatch queues.


568
00:25:17,396 --> 00:25:19,716
We can find XPC-related types.


569
00:25:19,926 --> 00:25:21,926
Just try searching
for dispatch or XPC.


570
00:25:22,056 --> 00:25:25,446
We can also find blocks
that have escaped the scope


571
00:25:25,446 --> 00:25:26,626
and been allocated on the Heap.


572
00:25:26,906 --> 00:25:28,976
Look for NS malloc
block to find those.


573
00:25:29,516 --> 00:25:34,566
[ Pause ]


574
00:25:35,066 --> 00:25:36,656
So when we look at Heap growth


575
00:25:36,656 --> 00:25:38,976
and it's going the wrong
direction and we could sit down


576
00:25:38,976 --> 00:25:42,206
and look at objects all day
long, there are a few kinds


577
00:25:42,206 --> 00:25:43,616
of problems to keep in mind.


578
00:25:43,906 --> 00:25:45,566
One of them is the
potential for leaked memory.


579
00:25:46,156 --> 00:25:48,746
It's possible that you
have allocated an object,


580
00:25:48,876 --> 00:25:49,876
you've finished using it,


581
00:25:49,986 --> 00:25:52,206
you in fact no longer
have any references to it.


582
00:25:52,206 --> 00:25:55,426
And this is much easier to do
without ARC than it is with ARC.


583
00:25:55,766 --> 00:25:56,646
It's still possible.


584
00:25:58,006 --> 00:25:59,856
If you literally
cannot get to it anymore


585
00:25:59,856 --> 00:26:02,646
because there is no longer a
pointer from any active object


586
00:26:02,646 --> 00:26:04,956
that you reference we
consider this memory leaked.


587
00:26:05,066 --> 00:26:06,526
And Daniel will show
you a little bit later


588
00:26:06,796 --> 00:26:09,046
about how exactly you
can go about tracking


589
00:26:09,046 --> 00:26:10,026
down this leaked memory.


590
00:26:10,476 --> 00:26:12,126
But there's some
other categories


591
00:26:12,126 --> 00:26:14,266
that are much trickier
to understand.


592
00:26:15,356 --> 00:26:17,476
Abandoned memory,
memory I've allocated,


593
00:26:18,206 --> 00:26:21,466
I have a legitimate path to
get to it, but as it turns


594
00:26:21,466 --> 00:26:23,396
out there's never going to
be a single line of code


595
00:26:23,396 --> 00:26:26,006
that actually follows
that path again.


596
00:26:26,356 --> 00:26:28,346
I stuck it in the global
variable during startup,


597
00:26:28,346 --> 00:26:30,186
and that startup
code is the only code


598
00:26:30,186 --> 00:26:31,076
that ever references it.


599
00:26:31,076 --> 00:26:32,326
That memory has been abandoned.


600
00:26:32,696 --> 00:26:35,376
No leak detection tool on the
planet will find it for you,


601
00:26:35,736 --> 00:26:37,886
but it's still important
that you understand


602
00:26:37,886 --> 00:26:40,026
that that memory
exists and is cluttering


603
00:26:40,026 --> 00:26:41,226
up your user's environment.


604
00:26:42,616 --> 00:26:44,576
There's also cached memory.


605
00:26:45,176 --> 00:26:47,536
If you have a cache that you
stick things in you may find


606
00:26:47,576 --> 00:26:49,896
that you open a document,
put the document reference


607
00:26:49,896 --> 00:26:51,446
in the cache, close
the document,


608
00:26:51,666 --> 00:26:52,876
and it sticks around forever.


609
00:26:53,006 --> 00:26:55,586
It's really efficient to go
and reopen that document now,


610
00:26:56,186 --> 00:26:58,326
but it's a shame if the user
really intends to do a lot


611
00:26:58,326 --> 00:27:00,226
of other things and it's
cluttering up the world.


612
00:27:00,486 --> 00:27:02,766
And in this place
maybe the right thing


613
00:27:02,766 --> 00:27:05,636
to do is consider using NS
Cache to manage your chaches


614
00:27:05,636 --> 00:27:07,356
so that it can handle
memory for you.


615
00:27:07,356 --> 00:27:09,596
But we're going to talk
about tracking some of this


616
00:27:09,626 --> 00:27:12,686
down using a technique
called generational analysis.


617
00:27:13,406 --> 00:27:14,426
You may have seen this before.


618
00:27:14,426 --> 00:27:16,366
Previously we referred
to it as a Heap shot.


619
00:27:16,726 --> 00:27:18,386
But given that we cover more


620
00:27:18,386 --> 00:27:20,556
than Heap now we've
renamed the facility.


621
00:27:22,016 --> 00:27:25,886
It's about following these
steps to find our problems.


622
00:27:25,886 --> 00:27:26,886
We reach a steady state.


623
00:27:26,886 --> 00:27:28,066
We launch our application.


624
00:27:29,216 --> 00:27:30,696
We then do something
that allocates memory,


625
00:27:30,696 --> 00:27:33,786
open a document and then get
back to that steady state,


626
00:27:33,786 --> 00:27:37,066
close the document and
repeat that series of steps.


627
00:27:37,756 --> 00:27:40,206
And along the way we may
find something interesting.


628
00:27:40,536 --> 00:27:44,146
Specifically if I repeat this
process over and over again


629
00:27:44,146 --> 00:27:47,196
and every time memory
winds up accruing,


630
00:27:47,466 --> 00:27:50,406
then I've got some form of
abandoned or over cached


631
00:27:50,406 --> 00:27:52,126
or leaked memory going on.


632
00:27:52,566 --> 00:27:56,426
So visually steady state, some
sort of intermediate state


633
00:27:56,426 --> 00:27:58,746
with the document open,
back to the original state.


634
00:27:58,936 --> 00:28:02,426
Now, you may find that
there's some warmup cost here.


635
00:28:02,556 --> 00:28:04,756
We're loading code that
hasn't been used before.


636
00:28:04,756 --> 00:28:06,856
There's some basic data
structures being set up.


637
00:28:07,226 --> 00:28:09,616
Some level of warmup
cost is to be expected.


638
00:28:10,056 --> 00:28:12,326
But it's on the repeated
use of this


639
00:28:12,996 --> 00:28:13,976
that we wind up finding waste.


640
00:28:14,516 --> 00:28:19,546
[ Pause ]


641
00:28:20,046 --> 00:28:23,196
If you find that you are going
through this repeated cycle


642
00:28:23,196 --> 00:28:26,006
and you're not seeing any
waste, you're getting a net 0,


643
00:28:26,336 --> 00:28:30,096
you may find that you have free
memory from a heap perspective


644
00:28:30,426 --> 00:28:33,556
that isn't actually free from
a virtual memory perspective.


645
00:28:34,096 --> 00:28:34,796
How does that happen?


646
00:28:34,796 --> 00:28:37,166
Well, it's something we refer
to as Heap fragmentation.


647
00:28:38,006 --> 00:28:41,576
Specifically I have a situation
where I have a variety of pages,


648
00:28:41,576 --> 00:28:43,686
and every page has
exactly one object


649
00:28:43,686 --> 00:28:44,886
that I keep referencing on it.


650
00:28:45,456 --> 00:28:47,646
Those pages, therefore,
are still kept in,


651
00:28:47,646 --> 00:28:48,786
they're in physical memory.


652
00:28:49,226 --> 00:28:52,266
And I'm now using 32
bytes of some sort


653
00:28:52,266 --> 00:28:55,116
of legitimate data
occupying 4K of memory.


654
00:28:55,906 --> 00:28:57,616
So what do I do about this?


655
00:28:57,616 --> 00:28:59,736
How do I understand
this situation,


656
00:28:59,736 --> 00:29:01,376
and how did I get there
in the first place?


657
00:29:02,296 --> 00:29:03,156
Well, here's how it happens.


658
00:29:04,126 --> 00:29:06,106
You go ahead and get
a malloc VM region.


659
00:29:06,306 --> 00:29:09,226
This is created for you by
the malloc subsystem in order


660
00:29:09,226 --> 00:29:10,246
to allocate an object.


661
00:29:10,246 --> 00:29:12,066
I then allocate a
bunch of objects


662
00:29:12,836 --> 00:29:13,896
and I've filled this page.


663
00:29:15,366 --> 00:29:19,036
Repeat. So we allocate
a bunch more VM regions.


664
00:29:19,036 --> 00:29:21,396
We fill them with a bunch
more objects, and now we're


665
00:29:21,396 --> 00:29:22,726
in a perfectly reasonable
situation


666
00:29:22,726 --> 00:29:24,366
where we're utilizing
all that memory.


667
00:29:25,826 --> 00:29:29,056
Now we go and we free
most of those objects.


668
00:29:29,386 --> 00:29:32,246
And unfortunately what happens
is we're left with objects


669
00:29:32,246 --> 00:29:34,196
in the locations where
they were allocated,


670
00:29:34,196 --> 00:29:35,826
pinned there occupying memory.


671
00:29:36,406 --> 00:29:38,966
So if you've got a process
that allocates a lot of memory


672
00:29:38,966 --> 00:29:41,746
and then releases most of it
you may be fragmenting memory.


673
00:29:41,986 --> 00:29:43,466
You may not see the
memory coming back


674
00:29:43,466 --> 00:29:47,556
that you would expect
from looking at the Heap.


675
00:29:47,706 --> 00:29:50,866
The biggest thing you can do
about this is avoid a situation


676
00:29:50,866 --> 00:29:53,556
where you have these
extreme peaks and valleys.


677
00:29:54,426 --> 00:29:55,576
So go into Allocations.


678
00:29:55,936 --> 00:29:58,786
This is the place where
the Heap Allocation tool,


679
00:29:58,786 --> 00:29:59,976
if you're just filtering
for Heap


680
00:30:00,056 --> 00:30:01,676
only and graphing the Heap,


681
00:30:01,966 --> 00:30:05,016
can show you precisely how
much Heap you're using.


682
00:30:05,496 --> 00:30:07,836
So we're seeing this graph
with peaks and valleys.


683
00:30:08,166 --> 00:30:10,796
And that is indicative
of a potential problem.


684
00:30:11,646 --> 00:30:16,556
You may never get back
the virtual memory region


685
00:30:16,556 --> 00:30:19,236
that is resident from
that high water mark.


686
00:30:19,566 --> 00:30:21,636
Most of the time you'll get
back a significant amount.


687
00:30:21,966 --> 00:30:24,066
But be careful.


688
00:30:24,556 --> 00:30:27,106
Your ideal graph looks
a lot more like this,


689
00:30:27,576 --> 00:30:30,236
relatively small increases
and decreases over time


690
00:30:30,236 --> 00:30:32,266
to the extent that
you can manage it.


691
00:30:32,976 --> 00:30:35,926
Of course your friend
in this is auto release.


692
00:30:36,546 --> 00:30:38,366
Keep in mind that
auto release is sort


693
00:30:38,366 --> 00:30:40,446
of the best tool you
can possibly use here.


694
00:30:40,696 --> 00:30:42,416
And what you need
to do is make sure


695
00:30:42,416 --> 00:30:45,366
that you give the auto
release pool a chance to drain.


696
00:30:45,706 --> 00:30:47,986
You either drain it
yourself in the course


697
00:30:47,986 --> 00:30:50,446
of a long loop that's
doing a lot of operations,


698
00:30:50,876 --> 00:30:52,146
or if you're doing something


699
00:30:52,146 --> 00:30:55,076
on a dispatch queue you may
find it's valuable to drain it.


700
00:30:55,566 --> 00:30:57,186
You need to be careful,
as always,


701
00:30:57,436 --> 00:30:59,386
that auto released
objects aren't something


702
00:30:59,386 --> 00:31:00,416
that you're going to reference


703
00:31:00,416 --> 00:31:02,166
after the auto release
pool has been drained.


704
00:31:02,546 --> 00:31:07,096
And with that I'm going to
turn it over to my engineer,


705
00:31:07,096 --> 00:31:09,996
Daniel Delwood, who is going to
dive into more of the mysteries


706
00:31:10,036 --> 00:31:13,226
of Objective-C, retain
release and other goodness.


707
00:31:13,546 --> 00:31:13,976
Thank you, Daniel.


708
00:31:14,516 --> 00:31:19,956
[ Applause ]


709
00:31:20,456 --> 00:31:21,286
>> Thank you, Kate.


710
00:31:21,286 --> 00:31:23,886
So Kate went over virtual
memory from a high level


711
00:31:24,276 --> 00:31:26,396
and then zoomed into
Heap memory.


712
00:31:26,396 --> 00:31:28,376
And now we're going to zoom
in even further and talk


713
00:31:28,376 --> 00:31:30,276
about Objective-C, your objects


714
00:31:30,276 --> 00:31:33,576
and the management schemes
that you can employ.


715
00:31:33,966 --> 00:31:35,156
So first of all let's start


716
00:31:35,156 --> 00:31:36,806
with a brief review
of retain release.


717
00:31:38,026 --> 00:31:40,016
Objective-C uses as a reference
counting ownership model.


718
00:31:40,696 --> 00:31:43,706
And this means that when you
create an object the object


719
00:31:43,706 --> 00:31:44,946
starts out with a
reference count of 1.


720
00:31:45,756 --> 00:31:50,056
So there's two main primitives,
retain which says I want


721
00:31:50,056 --> 00:31:52,346
to express ownership over
this, it bumps the retain count


722
00:31:52,786 --> 00:31:56,396
and release which
releases that ownership


723
00:31:56,776 --> 00:31:58,726
and decrements are
a retain count by 1.


724
00:31:59,386 --> 00:32:02,136
Whenever the account drops
to 0 the object is freed back


725
00:32:02,136 --> 00:32:03,056
to the malloc subsystem.


726
00:32:03,956 --> 00:32:06,716
Now, the third primitive
there is auto release,


727
00:32:06,756 --> 00:32:08,026
and it's important to remember


728
00:32:08,026 --> 00:32:11,176
that this is just a delayed
release, and it's very useful


729
00:32:11,176 --> 00:32:16,006
for things like returning
objects from functions.


730
00:32:16,006 --> 00:32:18,916
Just remember, though, that
the auto release will issue


731
00:32:18,916 --> 00:32:21,196
that delayed release whenever
the current auto release ends.


732
00:32:22,306 --> 00:32:24,396
The rules are established,
they're easy to learn,


733
00:32:24,396 --> 00:32:26,086
and here's actually a
good reference document,


734
00:32:26,086 --> 00:32:27,986
the advanced memory
management guide.


735
00:32:28,466 --> 00:32:30,436
I'd recommend book marking it.


736
00:32:30,436 --> 00:32:33,006
It's a great place to go back
to when you're debugging issues.


737
00:32:33,676 --> 00:32:35,556
The thing to remember here,


738
00:32:35,556 --> 00:32:38,056
though about Objective-C's
ownership model is


739
00:32:38,336 --> 00:32:41,366
that it's deterministic
and simple to learn.


740
00:32:41,876 --> 00:32:46,246
Most importantly,
though, it's fast.


741
00:32:46,246 --> 00:32:48,466
So what can go wrong
with this, right?


742
00:32:48,466 --> 00:32:50,026
We're talking about
fixing memory issues.


743
00:32:50,706 --> 00:32:52,426
Well, it's tedious.


744
00:32:53,006 --> 00:32:56,236
Writing retain and
release is very error prone


745
00:32:56,236 --> 00:32:57,676
when you're writing
all of this code,


746
00:32:57,676 --> 00:32:59,306
and more code really
is more bugs.


747
00:32:59,926 --> 00:33:02,316
And so if you write too
many retains you're going


748
00:33:02,316 --> 00:33:05,196
to get objects that may not
be referenced by anything else


749
00:33:05,196 --> 00:33:07,346
in your code but still
have non 0 retain counts.


750
00:33:07,946 --> 00:33:10,196
Now, if you release something
too many times it will quickly


751
00:33:10,196 --> 00:33:10,846
lead to crashes.


752
00:33:11,376 --> 00:33:15,526
Now, the third problem
that's common


753
00:33:15,526 --> 00:33:16,976
with this is retain cycles.


754
00:33:16,976 --> 00:33:18,846
And this is more of
a structural problem,


755
00:33:18,846 --> 00:33:20,216
more of a behavioral problem.


756
00:33:20,706 --> 00:33:23,296
And it's because you
could have objects


757
00:33:23,296 --> 00:33:25,296
that reference each
other, retain each other,


758
00:33:25,586 --> 00:33:27,096
and if they're not
referenced by anything else


759
00:33:27,096 --> 00:33:30,056
in your application
they're still going to leak,


760
00:33:30,436 --> 00:33:33,216
and you need to find some
way of breaking that cycle.


761
00:33:34,186 --> 00:33:37,156
Well, luckily for the
tedium it's gone now.


762
00:33:37,836 --> 00:33:39,226
We have automatic
reference counting.


763
00:33:39,656 --> 00:33:41,076
And the compiler is really great


764
00:33:41,076 --> 00:33:43,586
about doing those retains
and releases for us.


765
00:33:44,336 --> 00:33:47,106
So it's compiler assisted
convention enforcement.


766
00:33:47,466 --> 00:33:50,106
It knows that whole document
I just told you about.


767
00:33:50,106 --> 00:33:52,426
It knows how to do the
retain and release perfectly.


768
00:33:52,426 --> 00:33:55,406
But it's still important
that you know how


769
00:33:55,806 --> 00:33:57,516
that convention works
under the covers.


770
00:33:57,556 --> 00:33:59,316
Because whether you're
running ARC or not,


771
00:33:59,726 --> 00:34:01,556
when you're debugging
issues you need to be able


772
00:34:01,556 --> 00:34:05,056
to understand all of the
data, understand what retain


773
00:34:05,056 --> 00:34:08,386
and release means in
your object history.


774
00:34:09,516 --> 00:34:13,426
Now, automatic reference
counting doesn't solve retain


775
00:34:13,426 --> 00:34:16,426
cycles on its own because
that's not a mechanics issue,


776
00:34:16,426 --> 00:34:18,525
that's a design and
behavior issue.


777
00:34:19,085 --> 00:34:21,696
Luckily, though, it does
provide some very useful tools


778
00:34:21,696 --> 00:34:24,795
and keywords to help fix
these including things


779
00:34:24,795 --> 00:34:27,426
like zeroing weak references
where you can mark one


780
00:34:27,426 --> 00:34:31,596
of the references weak and
the whole cycle will go away.


781
00:34:31,775 --> 00:34:36,176
So let's talk about then
what the common problems are


782
00:34:36,436 --> 00:34:39,896
under ARC and focus on
those more behavioral


783
00:34:39,896 --> 00:34:40,846
structural issues.


784
00:34:41,585 --> 00:34:43,686
Well, the first one
is memory growth.


785
00:34:44,666 --> 00:34:48,396
And memory growth can really
come in two different forms.


786
00:34:48,716 --> 00:34:50,666
The first like I talked
about is retain cycles.


787
00:34:51,585 --> 00:34:55,275
And the second is
abandoned objects.


788
00:34:55,916 --> 00:34:59,576
So for retain cycles the leaks
instrument actually provides a


789
00:34:59,576 --> 00:35:02,266
very nice graphical
display of the cycle


790
00:35:02,406 --> 00:35:05,426
so you can easily understand
what the cause is and go in


791
00:35:05,426 --> 00:35:09,026
and find out where you need to
use the weak keyword and fix it.


792
00:35:09,586 --> 00:35:12,056
As for abandoned objects,
what Kate was talking


793
00:35:12,056 --> 00:35:14,366
about with the generational
analysis is definitely the best


794
00:35:14,366 --> 00:35:14,736
way to go.


795
00:35:15,986 --> 00:35:19,026
The second thing that can happen


796
00:35:19,026 --> 00:35:21,386
in ARC is messaging the
deallocated objects.


797
00:35:21,916 --> 00:35:23,456
Now, you might say
how is this happening


798
00:35:23,456 --> 00:35:25,676
if I'm not issuing
too many releases?


799
00:35:26,026 --> 00:35:27,636
Well, I'll get to
that in a little bit.


800
00:35:27,636 --> 00:35:31,286
But the problem with messaging
these objects is it's very


801
00:35:31,286 --> 00:35:33,136
undefined and nondeterministic
behavior.


802
00:35:33,136 --> 00:35:35,486
You might way, well, it
always crashes for me,


803
00:35:35,956 --> 00:35:38,386
but it really depends
on what happens


804
00:35:38,426 --> 00:35:41,136
to that object once you free it.


805
00:35:41,136 --> 00:35:44,516
If you return the memory to the
malloc system it doesn't have


806
00:35:44,516 --> 00:35:46,086
to clear it, it doesn't
have to reuse it.


807
00:35:46,436 --> 00:35:49,936
And it may still appear to be
an object, it may still respond


808
00:35:49,936 --> 00:35:52,246
to messages and you won't
get a crash some of the time.


809
00:35:52,246 --> 00:35:53,906
When you do get crashes, though,


810
00:35:54,126 --> 00:35:57,006
things like Objective-C
message send, store strong


811
00:35:57,296 --> 00:35:59,746
or it does not respond to
selector are good indicators


812
00:35:59,746 --> 00:36:01,496
that this is the sort of
problem that you have.


813
00:36:02,866 --> 00:36:05,526
So how do we fix that?


814
00:36:05,526 --> 00:36:06,486
What tools do we have?


815
00:36:06,996 --> 00:36:09,736
Well, the Zombies template
is a great way to do this,


816
00:36:09,736 --> 00:36:13,466
and it uses a very age old
debugging environment variable


817
00:36:13,846 --> 00:36:15,066
exposed by foundation.


818
00:36:15,476 --> 00:36:17,036
And that's Zombie
enabled equals 1.


819
00:36:17,406 --> 00:36:20,396
And what this does is instead
of objects being deallocated


820
00:36:20,586 --> 00:36:23,886
when they're freed or when
their retain counts goes to 0,


821
00:36:24,166 --> 00:36:25,676
they're changed into
Zombie objects.


822
00:36:26,386 --> 00:36:29,216
So that whenever you reference
them later and use them


823
00:36:29,306 --> 00:36:31,436
and send them a message
they crash.


824
00:36:32,256 --> 00:36:34,536
Very deterministic behavior,
and this is what we want


825
00:36:34,536 --> 00:36:35,506
when we're debugging issues.


826
00:36:36,756 --> 00:36:39,616
So, again, it's deterministic


827
00:36:39,616 --> 00:36:42,596
because the memory isn't
unchanged or reused.


828
00:36:43,386 --> 00:36:48,206
And I want to also point
out that every Zombie object


829
00:36:48,336 --> 00:36:51,506
that you leave in your process
is technically also a leak.


830
00:36:51,506 --> 00:36:53,986
So you really don't want to
use this sort of debugging


831
00:36:54,196 --> 00:36:56,186
at the same time that you're
looking for leaks in your code.


832
00:36:56,186 --> 00:36:58,736
An important note, though,


833
00:36:58,936 --> 00:37:00,186
previously this was
only available


834
00:37:00,186 --> 00:37:02,386
for iOS on the iOS Simulator.


835
00:37:03,166 --> 00:37:04,976
It's now available
for iOS 7 devices.


836
00:37:05,516 --> 00:37:11,546
[ Applause ]


837
00:37:12,046 --> 00:37:13,606
So with that I want to
show you a quick demo.


838
00:37:14,316 --> 00:37:16,476
So I have here the
same WWDC app,


839
00:37:16,476 --> 00:37:20,086
and I was noticing
an intermittent crash


840
00:37:20,556 --> 00:37:22,996
when I was dealing with
bad network conditions.


841
00:37:23,376 --> 00:37:25,896
Well, I can actually reproduce
this a lot easier just


842
00:37:25,896 --> 00:37:28,876
by messing up a URL, and you'll
see what it turns out to do.


843
00:37:29,186 --> 00:37:32,336
So I'm going to go ahead
and run this on my phone.


844
00:37:33,516 --> 00:37:39,916
[ Pause ]


845
00:37:40,416 --> 00:37:44,976
So the app comes up.


846
00:37:45,066 --> 00:37:49,466
You'll have to trust me it's
looking very nice on iOS 7.


847
00:37:50,246 --> 00:37:52,876
And immediately we see
this sort of thing.


848
00:37:52,876 --> 00:37:58,156
Exec bad access, crash, and
if we zoom in here right


849
00:37:58,156 --> 00:38:00,276
in the debugger ObjC
underscore release.


850
00:38:00,446 --> 00:38:03,916
So it looks like we've
got probably a memory


851
00:38:03,916 --> 00:38:04,536
management issue.


852
00:38:04,626 --> 00:38:08,376
So I'm just going to
use the profile action


853
00:38:08,376 --> 00:38:14,256
from the run menu,
and goes ahead builds,


854
00:38:15,956 --> 00:38:18,626
pops open instruments,
and I can go ahead


855
00:38:18,626 --> 00:38:20,606
and select the Zombies
template for my device.


856
00:38:22,096 --> 00:38:25,116
So, again, it launches,
and we get this graph


857
00:38:25,846 --> 00:38:28,366
of allocations as we'd expect.


858
00:38:29,676 --> 00:38:33,086
Alright, so instruments has
detected that I have message


859
00:38:33,086 --> 00:38:36,586
to Zombie, and I can get
some more information just


860
00:38:36,586 --> 00:38:37,216
by hitting the arrow.


861
00:38:38,826 --> 00:38:40,366
So the first thing
you'll notice here is


862
00:38:40,366 --> 00:38:43,006
that my retain release
history looks a lot different


863
00:38:43,076 --> 00:38:44,596
than it did in Xcode 4.


864
00:38:44,596 --> 00:38:49,106
And that's because what
Instruments is doing is showing


865
00:38:49,106 --> 00:38:51,656
me a pairing view of
retains and releases.


866
00:38:51,896 --> 00:38:55,666
And if I turn this down you'll
see that we have malloc events,


867
00:38:55,666 --> 00:39:00,336
auto release, retain release all
grouped together into one chunk.


868
00:39:01,006 --> 00:39:03,526
Now the scope bar here
allows me to change my view


869
00:39:03,756 --> 00:39:06,936
so I can see it by time which is
what I'm used to seeing before.


870
00:39:07,696 --> 00:39:09,026
Or, I can see it again grouped


871
00:39:09,156 --> 00:39:11,916
by that pairing or
bad back trace.


872
00:39:12,496 --> 00:39:15,666
So the interesting part here
is that I can select each one


873
00:39:15,666 --> 00:39:22,026
of these events and take a look
at the stack trace on the right.


874
00:39:22,026 --> 00:39:24,246
And look through and see,
okay, what's going on here.


875
00:39:24,536 --> 00:39:25,906
But Instruments has
already told me


876
00:39:25,996 --> 00:39:28,996
that these are very
likely already paired.


877
00:39:28,996 --> 00:39:30,946
They're already matching up.


878
00:39:30,946 --> 00:39:34,136
There's probably not too many
retains, too many releases.


879
00:39:34,526 --> 00:39:40,256
So the question is why is this a
message to a deallocated objects


880
00:39:40,256 --> 00:39:41,436
and Objective-C store strong?


881
00:39:42,606 --> 00:39:44,256
So we can just jump
right to the code.


882
00:39:44,566 --> 00:39:50,556
And I'm going to open it in
Xcode so you can see it better.


883
00:39:51,066 --> 00:39:53,356
And what happens,
let's see here --


884
00:39:54,516 --> 00:40:00,676
[ Pause ]


885
00:40:01,176 --> 00:40:02,726
What we've got --


886
00:40:03,516 --> 00:40:08,006
[ Pause ]


887
00:40:08,506 --> 00:40:13,196
-- is an error parameter
being returned by reference


888
00:40:13,316 --> 00:40:15,496
from this process
raw data function.


889
00:40:16,456 --> 00:40:19,936
So it seems like a
very standard function


890
00:40:19,936 --> 00:40:21,886
for parsing a JSON response.


891
00:40:21,886 --> 00:40:23,156
We've got an auto
release pool around it


892
00:40:23,156 --> 00:40:25,136
because it's doing a lot
of string manipulation


893
00:40:25,136 --> 00:40:27,636
and we don't want to
cause memory spikes,


894
00:40:27,636 --> 00:40:29,416
and then we're passing
our error back.


895
00:40:29,416 --> 00:40:32,596
So the question is why is
this crashing when we get back


896
00:40:32,596 --> 00:40:35,426
to our caller of process
raw data right here.


897
00:40:36,016 --> 00:40:37,686
We get the error back,
and then we're trying


898
00:40:37,686 --> 00:40:41,106
to store a response
process error below.


899
00:40:42,666 --> 00:40:44,716
Well, just by taking
a look at the retain


900
00:40:44,716 --> 00:40:46,076
and release history we'll see


901
00:40:46,076 --> 00:40:48,386
that there was auto
release going on so


902
00:40:48,386 --> 00:40:50,606
that we can pass objects
back to our callers.


903
00:40:51,066 --> 00:40:54,286
But then those auto release
pools actually popped somewhere


904
00:40:54,286 --> 00:40:54,776
in between.


905
00:40:55,786 --> 00:40:57,036
In looking at that function


906
00:40:57,036 --> 00:40:59,046
that we saw there was an auto
release pool written there.


907
00:40:59,446 --> 00:41:00,746
So I'll talk about this
a little bit later,


908
00:41:00,746 --> 00:41:04,526
but what we really needed to
do is was use a local NS error


909
00:41:04,526 --> 00:41:08,336
and get that assignment
done outside


910
00:41:08,336 --> 00:41:10,706
of the auto release pool.


911
00:41:10,886 --> 00:41:13,986
So, the other thing I want


912
00:41:13,986 --> 00:41:17,776
to show you here is using
the leaks instrument.


913
00:41:18,636 --> 00:41:20,826
I'll just go ahead
and fix that typo.


914
00:41:21,376 --> 00:41:24,956
And so I could just go ahead and
profile again in instruments.


915
00:41:25,516 --> 00:41:30,726
[ Pause ]


916
00:41:31,226 --> 00:41:35,646
I actually want to use
the leaks template.


917
00:41:36,516 --> 00:41:42,046
[ Pause ]


918
00:41:42,546 --> 00:41:44,986
And Instrument starts up
with both the template


919
00:41:44,986 --> 00:41:50,706
with both allocation and
leaks and starts recording.


920
00:41:53,256 --> 00:41:56,506
So quickly you'll notice that
we have some leaks detected


921
00:41:56,506 --> 00:41:57,156
in the background.


922
00:41:57,496 --> 00:42:00,106
And I can just go ahead and use
the app a little bit and sort


923
00:42:00,106 --> 00:42:02,206
of get some activity going on.


924
00:42:02,686 --> 00:42:04,766
And as I scroll around it
actually is interesting to type


925
00:42:04,766 --> 00:42:09,646
in that WWDC prefix and
take a look at the view here


926
00:42:09,646 --> 00:42:12,786
to see anything interesting
going on in our Heap.


927
00:42:13,236 --> 00:42:15,846
If we zoom in we'll even notice
that like our table cells,


928
00:42:16,066 --> 00:42:17,406
there's a lot of
transient cells.


929
00:42:17,786 --> 00:42:19,296
It's very likely we've
done something wrong


930
00:42:19,296 --> 00:42:20,806
with cell reuse use
just by looking


931
00:42:20,806 --> 00:42:22,296
at these high level statistics.


932
00:42:23,656 --> 00:42:26,566
And another interesting
thing here


933
00:42:26,566 --> 00:42:28,756
with the retain release
view is if I select one


934
00:42:28,756 --> 00:42:31,286
of these WWDC news
objects you'll notice


935
00:42:31,286 --> 00:42:34,636
that Instruments was able to
quickly pair up a whole ton


936
00:42:34,636 --> 00:42:38,196
of retains and releases even
pairing together retains auto


937
00:42:38,196 --> 00:42:38,976
releases and releases together.


938
00:42:42,476 --> 00:42:44,716
So let's take a look
at the leaks,


939
00:42:45,086 --> 00:42:46,206
and I'll remove my filter.


940
00:42:46,206 --> 00:42:49,296
And I'm actually interested in
a certain reachability leak.


941
00:42:50,416 --> 00:42:53,146
You'll notice that
we have a bunch


942
00:42:53,146 --> 00:42:54,946
of different objects
types, NS datas,


943
00:42:55,076 --> 00:42:57,166
NS arrays, network reachability.


944
00:42:58,016 --> 00:43:01,836
And they're all coming from
the system configuration


945
00:43:01,836 --> 00:43:03,236
system library.


946
00:43:03,826 --> 00:43:05,476
So are these really
our fault or not?


947
00:43:06,296 --> 00:43:09,626
Well, to see if they're
related I can go to the cycles


948
00:43:09,626 --> 00:43:12,286
and roots page and
see that, yes,


949
00:43:12,286 --> 00:43:14,906
the SC network reachability
is a root leak,


950
00:43:15,306 --> 00:43:21,386
and that this actually leaks
an NS array which leaks a list.


951
00:43:21,956 --> 00:43:24,466
So that's kind of nice.


952
00:43:24,506 --> 00:43:26,876
I can focus all my efforts
in that one location.


953
00:43:27,356 --> 00:43:31,966
So if I click on the network
reachability object and pull


954
00:43:31,966 --> 00:43:34,886
in the extended detail view, I
notice I allocate it right here


955
00:43:34,886 --> 00:43:37,976
at reachability with host name.


956
00:43:38,446 --> 00:43:44,376
And in Xcode this shows up as me
using an SC network reachability


957
00:43:44,376 --> 00:43:47,696
with host name, and then
I create a wrapper for it


958
00:43:47,696 --> 00:43:48,456
and then I release it.


959
00:43:48,456 --> 00:43:50,756
So it looks like I'm
using it fine, right?


960
00:43:51,666 --> 00:43:53,306
No problem at the
allocation point.


961
00:43:54,196 --> 00:43:57,936
Well, if I dive right in I again
get that retain release view,


962
00:43:59,356 --> 00:44:01,246
and not many retains
and releases.


963
00:44:01,966 --> 00:44:04,766
Well, I'd like to pair these up
and know which one is at fault.


964
00:44:04,766 --> 00:44:07,366
So we have a nice
pairing assistant


965
00:44:07,366 --> 00:44:08,966
in the bottom left
that I can bring up.


966
00:44:09,946 --> 00:44:12,296
And if I select different
CF retains


967
00:44:12,296 --> 00:44:15,046
and CF releases it
will suggest ones


968
00:44:15,046 --> 00:44:16,376
that could be possibly
be paired to it.


969
00:44:16,376 --> 00:44:20,196
So in this case I have a
CF retain and a CF release,


970
00:44:20,236 --> 00:44:21,906
and these look like
they're pretty paired.


971
00:44:22,506 --> 00:44:26,426
And here's my malloc that I just
looked at and that CF release


972
00:44:26,826 --> 00:44:29,506
that I just saw as well
so I can pair these up.


973
00:44:30,256 --> 00:44:32,766
And now I very quickly
dropped everything


974
00:44:32,766 --> 00:44:36,216
out of this table except
for the CF retain that's


975
00:44:36,216 --> 00:44:37,156
probably unmatched.


976
00:44:37,746 --> 00:44:43,996
Double click, go to source, and
here we have the INIT [phonetic]


977
00:44:43,996 --> 00:44:45,326
with reachability ref.


978
00:44:45,696 --> 00:44:49,066
And so we're doing a CF retain
into the reachability ref.


979
00:44:49,146 --> 00:44:51,656
And well, oops, I forgot
to write into the alloc


980
00:44:51,706 --> 00:44:55,726
so that's pretty easy to go fix.


981
00:44:56,016 --> 00:44:59,496
So, alright, that is showing
you the Zombies template


982
00:44:59,496 --> 00:45:02,866
on an iOS device and taking
a look at a couple leaks.


983
00:45:04,516 --> 00:45:12,806
[ Applause ]


984
00:45:13,306 --> 00:45:15,446
So first steps in applying this


985
00:45:15,446 --> 00:45:17,796
to your app I'd very
much recommend


986
00:45:17,796 --> 00:45:18,636
that you switch to ARC.


987
00:45:18,636 --> 00:45:22,096
It gets rid of a lot of that
code that the compiler can do


988
00:45:22,096 --> 00:45:23,956
for you and do very, very well,


989
00:45:24,456 --> 00:45:25,886
and also run the
static analyzer.


990
00:45:25,886 --> 00:45:28,846
You may have noticed there
actually are some analyzer


991
00:45:28,846 --> 00:45:29,896
warnings, and had I looked


992
00:45:29,896 --> 00:45:31,806
at the analyzer I may have
fixed some of those bugs


993
00:45:31,806 --> 00:45:33,356
without having to do
any run time debugging.


994
00:45:33,706 --> 00:45:36,466
And that's always a lot
better if you can save time.


995
00:45:37,516 --> 00:45:40,146
Another thing if
you have crashes,


996
00:45:40,206 --> 00:45:41,816
the Zombies template is
a great first resort.


997
00:45:41,816 --> 00:45:44,386
If it doesn't catch anything,
great, continue debugging.


998
00:45:44,386 --> 00:45:46,566
But if it does then you just
saved yourself a lot of time.


999
00:45:47,976 --> 00:45:51,266
For leaks the back trace of
that allocation doesn't tell the


1000
00:45:51,266 --> 00:45:54,746
whole story, so you can't just
stop at that top level view.


1001
00:45:54,746 --> 00:45:56,236
You really do need to dive down,


1002
00:45:56,536 --> 00:45:59,306
look at the retain
release history even


1003
00:45:59,306 --> 00:46:02,586
when it's an object
that's managed by ARC.


1004
00:46:02,586 --> 00:46:06,146
And, finally, you
could save time now


1005
00:46:06,286 --> 00:46:09,046
by pairing those retains and
releases with the new UI.


1006
00:46:10,246 --> 00:46:12,976
So there's two ways to
do it as I've showed,


1007
00:46:12,976 --> 00:46:15,476
the manual pairing
assistant as well


1008
00:46:15,476 --> 00:46:18,826
as the heuristic-based
automatic pairing.


1009
00:46:19,246 --> 00:46:21,506
And you can see in this
screen shot that most


1010
00:46:21,506 --> 00:46:23,686
of them were automatically
paired, and I've got


1011
00:46:23,686 --> 00:46:26,026
that assistant up
giving me suggestions.


1012
00:46:26,616 --> 00:46:28,706
Now, I should note that
this is actually better


1013
00:46:28,946 --> 00:46:33,316
if you're using ARC and if
you're using no optimization.


1014
00:46:33,316 --> 00:46:36,816
And so why do I mention
that specifically?


1015
00:46:37,666 --> 00:46:40,996
Well, because by default the
profile action that I was using


1016
00:46:40,996 --> 00:46:44,436
from the run menu it defaults
to the release configuration.


1017
00:46:44,436 --> 00:46:46,836
And release is really great
if you're doing things


1018
00:46:46,836 --> 00:46:48,896
like performance work
and trying to find


1019
00:46:48,896 --> 00:46:51,646
out how your app is
spending its time.


1020
00:46:51,916 --> 00:46:55,976
You really want it to behave
as much as you can the same way


1021
00:46:55,976 --> 00:46:56,886
as you're going to ship it.


1022
00:46:57,706 --> 00:46:59,576
For memory tools
and memory analysis


1023
00:46:59,676 --> 00:47:02,266
that additional debugging
info is actually very useful.


1024
00:47:02,266 --> 00:47:10,456
And so you can set it by just
using the scheme editor and so


1025
00:47:10,456 --> 00:47:13,046
that that profile action
translates directly


1026
00:47:13,046 --> 00:47:16,376
to the profile action in
the scheme and just set it


1027
00:47:16,376 --> 00:47:19,226
to release, or set it
to debug, I'm sorry.


1028
00:47:20,736 --> 00:47:23,236
So with that I want
to talk about a couple


1029
00:47:23,236 --> 00:47:27,686
of common Objective-C issues
that you can face even under ARC


1030
00:47:28,046 --> 00:47:30,536
because these are the
issues that are behavioral,


1031
00:47:30,806 --> 00:47:31,866
structural in your code.


1032
00:47:32,306 --> 00:47:34,256
And there's a lot of
really powerful keywords


1033
00:47:34,716 --> 00:47:38,186
that the run time provides
to solve some issues.


1034
00:47:38,576 --> 00:47:39,856
They're both powerful, and some


1035
00:47:39,856 --> 00:47:40,946
of them are a little
bit dangerous.


1036
00:47:41,036 --> 00:47:43,486
And so I want to go through
a couple of these so that


1037
00:47:43,486 --> 00:47:45,496
when you see them in your
code you hopefully won't be


1038
00:47:45,566 --> 00:47:48,956
surprised, and you'll be able to
more quickly get to a solution.


1039
00:47:49,586 --> 00:47:53,116
So the first thing
is block captures.


1040
00:47:53,116 --> 00:47:54,616
Now, blocks are really,
really powerful,


1041
00:47:55,056 --> 00:47:59,056
and you can use Objective-C
objectives, dispatch objects,


1042
00:47:59,056 --> 00:48:00,296
many things inside them.


1043
00:48:01,396 --> 00:48:03,916
And when they're copied
to the Heap for things


1044
00:48:03,916 --> 00:48:05,136
like dispatch A sync


1045
00:48:05,136 --> 00:48:08,576
or as registrations they capture
those reference objects strongly


1046
00:48:08,576 --> 00:48:09,146
by default.


1047
00:48:09,686 --> 00:48:12,086
So if you use self
it will retain self,


1048
00:48:12,086 --> 00:48:14,506
and when the block is
destroyed it will release self.


1049
00:48:15,236 --> 00:48:18,696
But instance variables are
also implicitly reference self.


1050
00:48:18,696 --> 00:48:20,106
So this means if you have an


1051
00:48:20,146 --> 00:48:23,096
under bar fu [phonetic]
it's going to reference self


1052
00:48:23,096 --> 00:48:24,486
and use it in that way.


1053
00:48:24,576 --> 00:48:26,616
So let me show you
an example here.


1054
00:48:27,016 --> 00:48:28,886
I'm using NS Notification
Center API.


1055
00:48:29,576 --> 00:48:33,286
And I'm storing the observer
token in an instance variable.


1056
00:48:33,906 --> 00:48:36,106
Great. So self is
retaining observer token,


1057
00:48:36,106 --> 00:48:38,136
and then I'm sending in a block,


1058
00:48:38,406 --> 00:48:41,396
and that block is
roundabout retained


1059
00:48:41,396 --> 00:48:43,216
by the observer token as well.


1060
00:48:44,456 --> 00:48:46,876
But self is retained
by that block,


1061
00:48:46,876 --> 00:48:49,146
and so you can really quickly
see here that this leads


1062
00:48:49,146 --> 00:48:51,316
to retain cycle and it's
going to cause problems.


1063
00:48:51,866 --> 00:48:54,626
So the solution is just
to use a weak keyword


1064
00:48:54,626 --> 00:48:55,626
to break these cycles.


1065
00:48:55,626 --> 00:49:01,156
In this case we can just
define a weakly notified self


1066
00:49:01,246 --> 00:49:03,176
and use it inside the block.


1067
00:49:04,216 --> 00:49:07,766
Now, just as a note, when you
are running non-ARC you may have


1068
00:49:07,766 --> 00:49:09,876
to use the under
under block keyword


1069
00:49:09,876 --> 00:49:11,686
to also indicate don't retain.


1070
00:49:11,686 --> 00:49:15,176
It means that the variable can
be modified inside the block,


1071
00:49:15,176 --> 00:49:17,746
but it has that additional
effect under non-ARC.


1072
00:49:19,136 --> 00:49:21,946
So when do you need to look for
these retain cycles in blocks?


1073
00:49:22,016 --> 00:49:24,066
So is it all the time
or is it just sometimes?


1074
00:49:24,306 --> 00:49:26,876
Well, it's mostly just
persistent relationships,


1075
00:49:26,916 --> 00:49:29,286
so things like I showed
you, NS notifications


1076
00:49:29,336 --> 00:49:33,936
or error call backs or
things that recur over time.


1077
00:49:34,016 --> 00:49:37,706
So things like timers,
dispatch source handlers,


1078
00:49:38,146 --> 00:49:39,766
and that's where you
should definitely look


1079
00:49:39,766 --> 00:49:41,366
to using the weak keyword.


1080
00:49:41,836 --> 00:49:43,916
For things like one
time executions,


1081
00:49:44,186 --> 00:49:47,226
enumeration of an array, of
a dictionary you don't need


1082
00:49:47,226 --> 00:49:49,286
to use the weak keyword.


1083
00:49:50,796 --> 00:49:53,656
So let's talk about
weak just a little bit.


1084
00:49:54,026 --> 00:49:56,896
What does weak do and what
does that mean to you?


1085
00:49:57,556 --> 00:49:59,976
Well, weak validates
the reference


1086
00:50:00,116 --> 00:50:01,586
whenever it's used.


1087
00:50:01,776 --> 00:50:05,466
So it checks that the object
it refers to is still alive


1088
00:50:05,466 --> 00:50:07,506
and hasn't entered it's
dealloc on another thread.


1089
00:50:08,176 --> 00:50:13,476
So if the object isn't alive you
get back nil whenever you use a


1090
00:50:13,476 --> 00:50:13,946
weak variable.


1091
00:50:14,456 --> 00:50:16,326
This means you should avoid
consecutive uses, right?


1092
00:50:16,326 --> 00:50:17,366
If you begin transaction


1093
00:50:17,366 --> 00:50:20,426
on a weak variable then
you end transaction, well,


1094
00:50:20,426 --> 00:50:22,746
maybe only the begin
transaction went


1095
00:50:22,746 --> 00:50:26,846
through because your weak
reference may return nil


1096
00:50:26,846 --> 00:50:27,586
on the second use.


1097
00:50:28,646 --> 00:50:31,776
Finally, never do an arrow
to reference with weak.


1098
00:50:32,496 --> 00:50:35,426
And just to show you an example
of this, I can even check


1099
00:50:35,566 --> 00:50:39,066
if weak object then
I'll do an access


1100
00:50:39,066 --> 00:50:41,176
of the weak object's delegate
by an arrow reference.


1101
00:50:42,286 --> 00:50:45,386
If you get back nil then you've
referenced no and crashed.


1102
00:50:45,676 --> 00:50:49,566
So better would be to use
the dot syntax in this case


1103
00:50:49,846 --> 00:50:53,866
to access a delegate,
because sending a message


1104
00:50:53,866 --> 00:50:56,286
to nil is just fine.


1105
00:50:56,736 --> 00:50:58,216
Or, you can be very explicit,


1106
00:50:58,266 --> 00:51:00,116
and this is actually
probably the best way to go.


1107
00:51:00,116 --> 00:51:05,256
Just create a strong object,
promote your weak reference


1108
00:51:05,656 --> 00:51:08,826
and then use the strong
object in any way you see fit.


1109
00:51:10,196 --> 00:51:12,016
So one final note about weak.


1110
00:51:12,016 --> 00:51:14,086
Since it has to validate
the reference,


1111
00:51:14,216 --> 00:51:15,456
it's not a free thing.


1112
00:51:15,456 --> 00:51:18,256
So if this is in a really,
really hot loop you may want


1113
00:51:18,346 --> 00:51:21,276
to think about promoting
it to strong and using that


1114
00:51:21,676 --> 00:51:28,176
or not using weak in
that specific instance.


1115
00:51:28,176 --> 00:51:29,706
Which brings us to
unsafe unretained.


1116
00:51:30,296 --> 00:51:34,776
This is, as the name
suggests, an unsafe keyword.


1117
00:51:35,376 --> 00:51:37,416
But there's some risk
and there's some reward.


1118
00:51:37,986 --> 00:51:41,276
What it says is ARC please don't
manage this variable at all.


1119
00:51:41,646 --> 00:51:43,796
There's no retain when something
is stored to the variable,


1120
00:51:43,856 --> 00:51:46,036
no release when nil is
stored to the variable.


1121
00:51:47,536 --> 00:51:49,976
Important to note, though,
is if you've got legacy code


1122
00:51:49,976 --> 00:51:52,786
that you've sort of by
hand migrated to ARC,


1123
00:51:53,256 --> 00:51:56,276
if you're using property
assign this actually means


1124
00:51:56,276 --> 00:51:57,846
under the covers
unsafe unretained.


1125
00:51:57,846 --> 00:52:00,856
And so you can very
easily get crashes


1126
00:52:00,856 --> 00:52:02,506
because these are
dangling references


1127
00:52:02,556 --> 00:52:04,096
to whatever the object is.


1128
00:52:05,676 --> 00:52:08,066
Also keep in mind that many


1129
00:52:08,066 --> 00:52:11,296
of the frameworks will have
these sort of unsafe references


1130
00:52:11,406 --> 00:52:13,826
to your code such as
delegates or data sources.


1131
00:52:14,276 --> 00:52:18,106
And if you're getting a
crash where it's trying


1132
00:52:18,106 --> 00:52:20,916
to send a data source
message to your object


1133
00:52:21,006 --> 00:52:22,346
and your object is
already deallocated,


1134
00:52:22,606 --> 00:52:24,946
you may have just needed to
go into your dealloc and mill


1135
00:52:24,946 --> 00:52:27,176
out that data source
before your object went way.


1136
00:52:28,656 --> 00:52:32,526
So in general I would
sort of recommend this


1137
00:52:32,526 --> 00:52:35,076
as last resort keyword if
you have performance issues


1138
00:52:35,316 --> 00:52:37,026
or you need to use it
for some other reason.


1139
00:52:38,496 --> 00:52:42,676
So one of the key words to talk
about here is auto releasing.


1140
00:52:42,676 --> 00:52:45,146
And this one actually came
up with that demo example.


1141
00:52:45,266 --> 00:52:48,026
So for an auto releasing
variable the object has sent a


1142
00:52:48,026 --> 00:52:51,796
retain and then auto release
whenever assignment happens


1143
00:52:51,796 --> 00:52:52,056
to it.


1144
00:52:52,666 --> 00:52:55,076
So out parameters are
actually auto releasing


1145
00:52:55,076 --> 00:52:56,926
by default like NS errors.


1146
00:52:57,476 --> 00:53:02,096
And this means that if there's
an auto release pool wrapping


1147
00:53:02,096 --> 00:53:04,536
the assignment you can get
some interesting behavior,


1148
00:53:04,886 --> 00:53:05,916
namely crashes.


1149
00:53:06,546 --> 00:53:13,326
So in this case here we have an
auto release pool wrapping our


1150
00:53:13,826 --> 00:53:15,056
JSON use just like that.


1151
00:53:15,326 --> 00:53:20,516
We take that out error and we do
the assignment inside the kit.


1152
00:53:20,516 --> 00:53:23,876
So the assignment to that auto
releasing variable happens


1153
00:53:24,146 --> 00:53:25,216
inside our auto release pool.


1154
00:53:25,646 --> 00:53:28,746
The instant we leave our
auto release pool, well,


1155
00:53:28,746 --> 00:53:31,626
now that delayed release
happens immediately,


1156
00:53:32,536 --> 00:53:35,416
and now what we've done is we've
returned our deallocated NS


1157
00:53:35,416 --> 00:53:37,986
error to our caller
causing problems.


1158
00:53:38,186 --> 00:53:39,486
So the fix is simple.


1159
00:53:39,806 --> 00:53:42,126
If you write an auto
release pool write a local.


1160
00:53:42,866 --> 00:53:44,996
So in this case we just
need to write a local error,


1161
00:53:45,986 --> 00:53:47,506
send the local error
into the API,


1162
00:53:47,506 --> 00:53:50,956
and then do the auto
releasing assignment outside


1163
00:53:51,386 --> 00:53:52,936
of the auto release
pool that we wrote.


1164
00:53:53,446 --> 00:54:00,026
The final keyword I want to
talk about is bridge gaps.


1165
00:54:00,026 --> 00:54:03,386
Now, ARC is great for
managing life cycles


1166
00:54:03,386 --> 00:54:08,646
at the Objective-C level, but in
most of our code we still have


1167
00:54:08,646 --> 00:54:11,936
to use C-based APIs like core
foundation, core graphics,


1168
00:54:11,936 --> 00:54:15,106
things that take
void star context.


1169
00:54:15,106 --> 00:54:17,496
And for dealing with
there are bridge gaps.


1170
00:54:17,596 --> 00:54:19,006
There's three conversion
primitives,


1171
00:54:19,516 --> 00:54:22,796
bridge with just this type
casting, bridge transfer


1172
00:54:22,946 --> 00:54:25,656
which does the release,
and if you like the syntax


1173
00:54:25,656 --> 00:54:28,296
of CF bridging release
better you can use that,


1174
00:54:28,296 --> 00:54:29,926
or bridge retain which
does a retain as well.


1175
00:54:31,116 --> 00:54:34,046
Although I should note here
that incorrect bridging


1176
00:54:34,046 --> 00:54:38,146
because it's very explicit
can lead to a crash or a leak.


1177
00:54:39,096 --> 00:54:40,856
So how do you use
them correctly?


1178
00:54:40,856 --> 00:54:43,836
Well, this is the standard
way of using these.


1179
00:54:43,836 --> 00:54:47,466
If you're going from CF+ 1
you use a bridge transfer,


1180
00:54:47,656 --> 00:54:50,836
and you really should think
about your references in terms


1181
00:54:50,836 --> 00:54:53,026
of where the ARC
managed object is.


1182
00:54:53,776 --> 00:54:56,216
But I specifically want
to call out the third cast


1183
00:54:56,216 --> 00:54:57,426
because this is the
most dangerous.


1184
00:54:57,606 --> 00:55:02,656
If you're casting from an ARC
managed reference to a void star


1185
00:55:02,656 --> 00:55:03,546
or a CF reference,


1186
00:55:04,196 --> 00:55:07,316
this effectively creates an
unsafe unretained CF reference.


1187
00:55:07,646 --> 00:55:09,086
So what do I mean?


1188
00:55:09,596 --> 00:55:11,696
Well, if I have this
in a string it's


1189
00:55:11,696 --> 00:55:15,196
in an ARC managed reference,
I use the bridge cast,


1190
00:55:15,596 --> 00:55:17,146
put it in a CF reference.


1191
00:55:17,766 --> 00:55:21,206
Well, now anywhere in between
here if, say, the log info goes


1192
00:55:21,206 --> 00:55:24,176
out of scope, I never use it
again, the compiler is free


1193
00:55:24,176 --> 00:55:25,436
to release that variable.


1194
00:55:25,736 --> 00:55:29,256
And now when I go to use it
in CFURL create, boom, right?


1195
00:55:29,256 --> 00:55:33,696
And now it's kind of a very
strange crash inside the kit.


1196
00:55:33,976 --> 00:55:36,666
So for that just switch
to the fourth one.


1197
00:55:36,666 --> 00:55:40,406
Use bridge retained, and just
remember to CF release it later.


1198
00:55:41,366 --> 00:55:44,216
So I want to briefly talk
about being a good citizen


1199
00:55:44,666 --> 00:55:48,846
on the platform and what sort
of testing you can do for this.


1200
00:55:49,256 --> 00:55:51,356
So test some real
world scenarios.


1201
00:55:51,566 --> 00:55:53,846
Definitely test on
constrained devices.


1202
00:55:53,846 --> 00:55:57,466
If you're on a MAC, low memory
systems, maybe low CPUs.


1203
00:55:57,466 --> 00:56:00,976
If you're on an iPhone this
is just older hardware.


1204
00:56:01,786 --> 00:56:04,556
Test your first install
and first launch.


1205
00:56:05,086 --> 00:56:05,746
If you're having to build


1206
00:56:05,746 --> 00:56:08,386
up a database you may have
memory spikes in that case,


1207
00:56:08,466 --> 00:56:10,316
and these are really
good test cases.


1208
00:56:11,006 --> 00:56:12,146
As well as large data sets.


1209
00:56:12,316 --> 00:56:15,976
Everyone wants to have really
devoted and awesome users


1210
00:56:16,046 --> 00:56:20,306
who use your app for years,
and it's worth testing for them


1211
00:56:20,636 --> 00:56:22,706
that you can handle
these big things.


1212
00:56:23,586 --> 00:56:26,676
Also, test background
launch on iOS 7.


1213
00:56:27,056 --> 00:56:30,626
And to do that you can just use
the option in the launch options


1214
00:56:31,366 --> 00:56:35,496
to simulate a background
fetch and off you go.


1215
00:56:35,556 --> 00:56:37,106
And, finally, make
sure that you test


1216
00:56:37,106 --> 00:56:38,596
for leaks and abandoned memory.


1217
00:56:39,396 --> 00:56:43,676
So under system memory pressure
we've talked about this briefly,


1218
00:56:43,676 --> 00:56:45,066
and I'm not going to
touch on it very much.


1219
00:56:45,096 --> 00:56:46,406
But when pages have


1220
00:56:46,446 --> 00:56:49,636
to be evicted it really is
your dirty memory that matters.


1221
00:56:49,746 --> 00:56:54,726
And in this case on OS X these
are compressed or saved to disk.


1222
00:56:55,026 --> 00:56:55,986
See this talk right here


1223
00:56:55,986 --> 00:56:58,016
for more information,
it's really great.


1224
00:56:58,766 --> 00:57:01,356
And for iOS memory
warnings are issued


1225
00:57:01,356 --> 00:57:02,836
and processes have terminated.


1226
00:57:03,656 --> 00:57:05,276
So when it comes
to memory warnings


1227
00:57:05,616 --> 00:57:07,436
and how you can avoid
termination,


1228
00:57:08,046 --> 00:57:09,376
well, don't be the biggest.


1229
00:57:09,606 --> 00:57:11,356
Dirty memory really
is what counts.


1230
00:57:11,396 --> 00:57:13,656
You can use the VM Tracker to
find out how much you're using.


1231
00:57:14,316 --> 00:57:16,276
And make sure you get
a chance to respond.


1232
00:57:16,616 --> 00:57:20,246
You're not guaranteed a memory
warning, but if you get one,


1233
00:57:20,816 --> 00:57:23,326
and hopefully you will, it
will arrive on the main thread.


1234
00:57:23,776 --> 00:57:25,956
So make sure your main thread
isn't blocked for many reasons,


1235
00:57:26,076 --> 00:57:27,176
also user responsiveness.


1236
00:57:27,626 --> 00:57:29,676
And, of course, avoid
large and rapid allocations


1237
00:57:29,676 --> 00:57:31,726
so the system doesn't
have to act quickly.


1238
00:57:32,936 --> 00:57:35,836
So these are the three best ways


1239
00:57:35,836 --> 00:57:37,966
to respond using
the notifications


1240
00:57:37,966 --> 00:57:40,736
or the APIs that get called.


1241
00:57:41,566 --> 00:57:43,276
And you should consider freeing


1242
00:57:43,276 --> 00:57:44,916
up some memory before
you enter the background.


1243
00:57:46,556 --> 00:57:48,636
So there's the [inaudible]
for that.


1244
00:57:48,636 --> 00:57:52,266
So to summarize we really want


1245
00:57:52,266 --> 00:57:53,446
to encourage you
to be proactive.


1246
00:57:53,446 --> 00:57:55,926
Start with the gauges,
use Instruments,


1247
00:57:55,966 --> 00:57:57,506
monitor, test and investigate.


1248
00:57:57,826 --> 00:57:59,706
Definitely avoid memory spikes.


1249
00:57:59,706 --> 00:58:01,996
This will lead to fragmentation
of your application,


1250
00:58:02,336 --> 00:58:03,926
and avoidance is
the best policy.


1251
00:58:04,446 --> 00:58:07,836
And definitely don't allow
unbounded memory growth,


1252
00:58:07,836 --> 00:58:09,636
you set generational analysis.


1253
00:58:10,276 --> 00:58:12,476
There are some great
language tools for you to use.


1254
00:58:12,506 --> 00:58:15,346
And I hope that you make
great effective use of them.


1255
00:58:15,556 --> 00:58:19,006
For more information contact
our developer tools evangelist,


1256
00:58:19,006 --> 00:58:19,566
Dave DeLong.


1257
00:58:20,216 --> 00:58:22,266
And the Apple developer
forums are great.


1258
00:58:23,356 --> 00:58:24,476
Here's some related sessions.


1259
00:58:24,476 --> 00:58:26,096
I just want to specifically call


1260
00:58:26,486 --> 00:58:28,406
out the Building
Efficient OS X apps


1261
00:58:28,406 --> 00:58:31,626
so you can get a deeper
understanding of virtual memory


1262
00:58:31,626 --> 00:58:32,856
and how that works
on the system.


1263
00:58:33,426 --> 00:58:35,196
So come see us.


1264
00:58:35,316 --> 00:58:36,416
We'd love to help you.


1265
00:58:36,446 --> 00:58:37,956
And thank you very
much for coming today.


1266
00:58:38,016 --> 00:58:40,000
[ Applause ]

