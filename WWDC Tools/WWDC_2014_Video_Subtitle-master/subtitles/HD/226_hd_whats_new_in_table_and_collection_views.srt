1
00:00:00,506 --> 00:00:11,536
[ Silence ]


2
00:00:12,036 --> 00:00:15,286
>> Thanks so much for coming
to "What's New in Table


3
00:00:15,286 --> 00:00:16,236
and Collection Views".


4
00:00:16,976 --> 00:00:20,566
This is a topic of special
dearness to my heart


5
00:00:20,896 --> 00:00:22,126
as we give it every year.


6
00:00:22,306 --> 00:00:24,336
Well, not exactly at this
session but something


7
00:00:24,336 --> 00:00:27,406
on collection and table views
we usually to get to talk about.


8
00:00:27,406 --> 00:00:30,026
And that's really
because table views


9
00:00:30,026 --> 00:00:33,096
and collection views
are a tool that get used


10
00:00:33,096 --> 00:00:37,186
in nearly every single
application and we recognized


11
00:00:37,246 --> 00:00:40,346
that as we went through to add
a lot of improvements to iOS 8.


12
00:00:40,696 --> 00:00:42,326
We really wanted to do things


13
00:00:42,836 --> 00:00:47,286
that made your life
easier doing awesome things


14
00:00:47,286 --> 00:00:50,466
with the tools that, as I said,
just about everybody uses.


15
00:00:51,356 --> 00:00:53,056
So, what we're going to talk


16
00:00:53,056 --> 00:00:55,536
about today is a few
fundamental improvements


17
00:00:56,016 --> 00:00:57,966
to both table view
and collection view.


18
00:00:58,486 --> 00:01:00,376
And we'll be beginning
with table view.


19
00:01:01,306 --> 00:01:04,036
In particular, the big thing
that we're going to be talking


20
00:01:04,036 --> 00:01:07,896
about today is how to
do Dynamic Type adoption


21
00:01:07,896 --> 00:01:08,826
in your table views.


22
00:01:09,716 --> 00:01:13,876
We're going to be asking that
all applications that deal


23
00:01:13,876 --> 00:01:18,196
with text in iOS 8 adopt Dynamic
Type and you'll see in fact


24
00:01:18,316 --> 00:01:20,856
that all of our system apps
have already done this.


25
00:01:21,276 --> 00:01:23,826
So users are going to expect
that your application do this.


26
00:01:23,826 --> 00:01:26,926
And I'm going to show you that
it's really quite simple to do


27
00:01:27,156 --> 00:01:29,056
and I think you'll have
a lot of fun with it.


28
00:01:29,226 --> 00:01:31,216
The mechanism that
we're giving you


29
00:01:31,706 --> 00:01:35,636
for adopting Dynamic Type
is self-sizing cells.


30
00:01:36,856 --> 00:01:39,466
We think this strategy-thank
you.


31
00:01:40,516 --> 00:01:44,106
[ Applause ]


32
00:01:44,606 --> 00:01:48,316
This strategy is really
going to improve the way


33
00:01:48,316 --> 00:01:51,166
that we architect our
table views, number one,


34
00:01:51,556 --> 00:01:53,986
because you can encapsulate
logic right in the cells,


35
00:01:54,596 --> 00:01:57,206
and two, the fact that you
can do that will make it


36
00:01:57,256 --> 00:02:01,526
so much easier to have cells
that are not a hardcoded,


37
00:02:01,526 --> 00:02:03,236
compile-time, known height


38
00:02:03,606 --> 00:02:07,836
which means you can easily
adopt the dynamic font changes.


39
00:02:08,795 --> 00:02:11,506
So, additionally, we've got some
new things in collection view.


40
00:02:11,826 --> 00:02:15,086
And number one, really great is
we're bringing self-sizing cells


41
00:02:15,086 --> 00:02:16,606
to collection view also.


42
00:02:17,516 --> 00:02:21,396
[ Applause ]


43
00:02:21,896 --> 00:02:25,796
And for all of you custom layout
authors, I know there's a lot


44
00:02:25,796 --> 00:02:29,986
of you out there because, every
week at least, I see a new app


45
00:02:30,236 --> 00:02:33,336
that has a really great layout
that really impresses me.


46
00:02:34,026 --> 00:02:36,396
We have something
we want to talk


47
00:02:36,396 --> 00:02:39,276
about which is smart
invalidation,


48
00:02:39,596 --> 00:02:42,236
which will allow you
to write great layouts


49
00:02:42,236 --> 00:02:44,756
that are also super performant.


50
00:02:45,516 --> 00:02:49,516
[ Applause ]


51
00:02:50,016 --> 00:02:52,516
So, we begin by talking
about table view


52
00:02:52,826 --> 00:02:54,186
and Dynamic Type adoption.


53
00:02:55,036 --> 00:02:58,726
If you've never seen
this screen from iOS 7,


54
00:02:58,726 --> 00:03:00,266
it's when we introduced
Dynamic Type.


55
00:03:00,666 --> 00:03:02,236
This is a screen in Settings


56
00:03:02,236 --> 00:03:06,976
where you can change
the text size


57
00:03:07,076 --> 00:03:09,456
to fit what feels
appropriate for you.


58
00:03:10,036 --> 00:03:12,456
And if you're somebody who
likes text a little bit bigger


59
00:03:12,976 --> 00:03:15,886
so that you can see things
easier, then you can slide


60
00:03:15,886 --> 00:03:20,056
that over and magically the
text changes in the interface


61
00:03:20,406 --> 00:03:23,876
and in fact, in iOS 8, all
internal apps will adapt


62
00:03:24,326 --> 00:03:26,236
and change their text size based


63
00:03:26,236 --> 00:03:29,786
on this slider value
that you've set.


64
00:03:29,986 --> 00:03:33,516
So that's great because it
makes your phone truly feel


65
00:03:33,516 --> 00:03:36,036
like your phone, and then
adopts to your needs.


66
00:03:36,466 --> 00:03:39,496
And since all of the internal
apps are doing this adaption,


67
00:03:40,016 --> 00:03:43,966
we will expect third party
apps to do that as well.


68
00:03:44,786 --> 00:03:48,256
So, let's talk briefly about
what it takes to get there.


69
00:03:48,746 --> 00:03:53,116
Well, we can do it by
using built-in labels.


70
00:03:53,226 --> 00:03:57,776
Built-in labels in table
view cells have dynamic fonts


71
00:03:57,776 --> 00:03:59,876
on them automatically in iOS 8.


72
00:04:00,246 --> 00:04:04,246
So, if you're using the text
label, the detail text label,


73
00:04:04,516 --> 00:04:06,856
they have already dynamic fonts


74
00:04:06,856 --> 00:04:08,856
and as the user changes
the text size,


75
00:04:09,176 --> 00:04:10,636
those labels are
going to change size.


76
00:04:11,616 --> 00:04:14,936
If you have your own custom
labels, it's really as simple


77
00:04:14,936 --> 00:04:19,226
as adding a preferred
font to that label.


78
00:04:19,495 --> 00:04:23,406
This is another API that existed
in iOS 7 so it's not new.


79
00:04:23,776 --> 00:04:26,456
We're just expecting
everyone to use it now.


80
00:04:26,456 --> 00:04:29,736
So, simply changing
your font from something


81
00:04:29,736 --> 00:04:31,786
that may have been, you
know, setting a font


82
00:04:31,786 --> 00:04:35,386
of a particular size to
instead using a preferred font,


83
00:04:36,226 --> 00:04:38,396
you now have Dynamic
Type in your label.


84
00:04:39,246 --> 00:04:42,366
But that brings in
a wrinkle to things


85
00:04:42,836 --> 00:04:48,536
and that wrinkle is now things
are dynamic and it's dynamic


86
00:04:48,616 --> 00:04:51,696
because of the size of the
text that can change based


87
00:04:51,696 --> 00:04:52,696
on what the user has set.


88
00:04:53,276 --> 00:04:57,726
So, if we think of simple
table views like Settings


89
00:04:58,106 --> 00:05:03,996
or like Messages-I guess that
Notes actually-Messages and Mail


90
00:05:04,176 --> 00:05:08,166
or Contacts, these are
all simple table views


91
00:05:08,166 --> 00:05:12,866
that in iOS 7, the row height
was known at build time.


92
00:05:12,866 --> 00:05:14,976
You could say, hey,
that's a 44-point high row


93
00:05:14,976 --> 00:05:16,456
and that's always true.


94
00:05:17,196 --> 00:05:19,636
But on iOS 8, that's not true.


95
00:05:19,766 --> 00:05:24,026
A user changes their text size,
all of those row heights change.


96
00:05:24,466 --> 00:05:29,856
So, even the simplest of table
views from iOS 7 now need


97
00:05:29,906 --> 00:05:33,216
to think about being
dynamic in iOS 8.


98
00:05:34,196 --> 00:05:37,416
So we have a few strategies
to achieve dynamism.


99
00:05:37,466 --> 00:05:41,976
One is the simplest case.


100
00:05:42,276 --> 00:05:45,696
If you're like one of those very
simple table views that we saw


101
00:05:46,016 --> 00:05:50,616
on the previous page, then you
can use the already existing


102
00:05:50,616 --> 00:05:52,266
property rowHeight.


103
00:05:53,166 --> 00:05:56,346
And even though you're dynamic,
you can still use that property


104
00:05:56,636 --> 00:05:58,966
because when the
text size changes,


105
00:05:58,966 --> 00:06:02,056
when you get a new height,
you can change the value


106
00:06:02,056 --> 00:06:04,696
of that property to
something different.


107
00:06:05,116 --> 00:06:11,626
And in fact, this strategy has
an advantage if you truly are,


108
00:06:11,716 --> 00:06:16,056
you know, a known height that
will be the same for each cell


109
00:06:16,546 --> 00:06:18,776
because if you can
set this property


110
00:06:18,776 --> 00:06:20,896
for all same size cells,


111
00:06:21,256 --> 00:06:23,946
then you'll get the best
scrolling performance possible


112
00:06:24,156 --> 00:06:26,346
because no calculations
need to be done


113
00:06:26,786 --> 00:06:28,796
on the fly while scrolling.


114
00:06:30,156 --> 00:06:32,856
The next strategy is something
you're probably all familiar


115
00:06:32,856 --> 00:06:35,886
with for using dynamic-sized
cells


116
00:06:36,356 --> 00:06:38,296
and that's implementing
the delegate method,


117
00:06:38,636 --> 00:06:40,436
tableView:height
ForRowAtIndexPath.


118
00:06:41,216 --> 00:06:45,216
That strategy is still valid and
something you can use in iOS 8


119
00:06:45,216 --> 00:06:49,656
if you'd like to size
your cells one at a time,


120
00:06:49,656 --> 00:06:51,156
give a height for each row.


121
00:06:52,106 --> 00:06:53,826
You can still do that.


122
00:06:54,336 --> 00:06:56,986
Of course, the disadvantage
to this


123
00:06:57,246 --> 00:07:01,726
and why we wanted something
new is that if you implement


124
00:07:01,726 --> 00:07:04,646
that delegate method, all of
your row heights are asked


125
00:07:04,926 --> 00:07:07,546
for upfront when
the table is loaded.


126
00:07:07,816 --> 00:07:11,926
Even if you have 20,000
rows, we're going to ask


127
00:07:11,926 --> 00:07:14,966
for the height of all of those
rows when we load the table.


128
00:07:14,966 --> 00:07:17,926
And of course, no cells
have yet been created


129
00:07:17,926 --> 00:07:20,116
so your delegate
needs to understand,


130
00:07:20,236 --> 00:07:25,096
without creating cells, what
height to make those cells based


131
00:07:25,096 --> 00:07:27,556
on your content, and that's been
the challenge up to this point.


132
00:07:28,626 --> 00:07:31,026
So that's why we have
the third strategy,


133
00:07:31,306 --> 00:07:32,856
which is self-sizing cells.


134
00:07:33,516 --> 00:07:38,166
[ Applause ]


135
00:07:38,666 --> 00:07:41,886
So, let's talk a little bit
about, you know, why this is


136
00:07:41,976 --> 00:07:44,176
and why, you know,
this is a big deal?


137
00:07:44,356 --> 00:07:48,426
If we take a simple table cell
like that in Mail, there's a lot


138
00:07:48,426 --> 00:07:51,886
of parameters around
sizing the cell.


139
00:07:52,776 --> 00:07:54,896
We, you know, we
look at this and OK,


140
00:07:54,896 --> 00:07:56,286
there's actually a
lot going on here.


141
00:07:56,546 --> 00:07:58,136
There are three different fonts.


142
00:07:58,646 --> 00:08:01,606
And in order to size the cell
correctly, we need to know


143
00:08:01,606 --> 00:08:04,226
about the size of all of those
fonts and how big they draw.


144
00:08:05,006 --> 00:08:09,906
Additionally, there are
margins between the texts.


145
00:08:10,366 --> 00:08:12,046
We need to know how
big those margins are


146
00:08:12,046 --> 00:08:13,166
and there are several of them.


147
00:08:13,456 --> 00:08:14,986
So we have to know
these fonts and we have


148
00:08:14,986 --> 00:08:15,846
to know these margins.


149
00:08:16,526 --> 00:08:18,336
That's a lot of knowledge
if we were


150
00:08:18,336 --> 00:08:20,666
to do dynamic sizing
in the delegate.


151
00:08:21,566 --> 00:08:25,426
So, in 8, I'll show you how
things work and I'll get


152
00:08:25,426 --> 00:08:28,346
out of the way so you
can really see this.


153
00:08:28,976 --> 00:08:31,186
Imagine that we've got
a few rows onscreen,


154
00:08:32,086 --> 00:08:35,586
and then we've got a fourth
row that's not yet on screen.


155
00:08:36,566 --> 00:08:39,885
In iOS 8, if you're using
self-sizing cells, and in fact,


156
00:08:40,336 --> 00:08:43,186
part of this is going to
be using the iOS 7 API


157
00:08:43,826 --> 00:08:46,846
which is giving an
estimated height for a row,


158
00:08:46,846 --> 00:08:48,226
something we introduced
last year.


159
00:08:48,656 --> 00:08:51,096
So that fourth row is going


160
00:08:51,096 --> 00:08:53,606
to be sized using an estimated
height that you provide,


161
00:08:53,796 --> 00:08:56,686
either via the property
estimatedHeight


162
00:08:57,186 --> 00:08:59,086
or there's a delegate
method for that, too.


163
00:09:00,086 --> 00:09:04,196
Now, when you scroll or when
you use the scrolls rather,


164
00:09:05,036 --> 00:09:10,346
at that time, we need to
bring on screen row four,


165
00:09:10,566 --> 00:09:12,866
which up to this point only
has an estimated height.


166
00:09:13,196 --> 00:09:17,156
So at that time, we
will create the cell.


167
00:09:17,356 --> 00:09:21,386
After creating it, we will ask
the cell how big it should be.


168
00:09:22,656 --> 00:09:25,396
Then, we use that
size if it's different


169
00:09:25,396 --> 00:09:26,686
from the estimated size


170
00:09:27,286 --> 00:09:30,626
to adjust the content
size of the table view.


171
00:09:31,706 --> 00:09:34,846
And only then after we've
adjusted the content size


172
00:09:34,846 --> 00:09:36,146
and taken the size
from the cell,


173
00:09:36,576 --> 00:09:39,896
do we actually put
that cell on screen.


174
00:09:40,436 --> 00:09:44,366
And so, what you
probably all want


175
00:09:44,366 --> 00:09:47,496
to know is what happens
in step two?


176
00:09:47,746 --> 00:09:48,986
How do we actually
size the cell?


177
00:09:48,986 --> 00:09:50,736
So, we're going to
talk about that now.


178
00:09:51,106 --> 00:09:54,086
And there are two ways that
you can communicate information


179
00:09:54,086 --> 00:09:57,816
about how big your cell is from
the cell back to the table view


180
00:09:58,026 --> 00:10:00,486
so that we can get
you the right thing.


181
00:10:00,846 --> 00:10:03,826
And number one is you
can use Autolayout.


182
00:10:04,516 --> 00:10:08,886
[ Applause ]


183
00:10:09,386 --> 00:10:12,096
If you're already using
Autolayout, and I know that many


184
00:10:12,096 --> 00:10:15,116
of you are, you may essentially
have to do nothing here.


185
00:10:15,376 --> 00:10:19,626
Your constraints, if they
already determined unambiguously


186
00:10:19,946 --> 00:10:23,846
the size of the cell, then we
will just use those constraints.


187
00:10:24,736 --> 00:10:28,756
In fact, the way that we've
implemented this in iOS 8 is


188
00:10:28,756 --> 00:10:32,276
that table view calls
systemLayoutSizeFittingSize


189
00:10:33,136 --> 00:10:33,856
on your cell.


190
00:10:34,526 --> 00:10:37,786
And systemLayoutSizeFittingSize
is smart enough to understand


191
00:10:38,246 --> 00:10:41,356
if you've implemented
constraints in your cell


192
00:10:41,766 --> 00:10:45,036
and if so, the Autolayout
engine delivers the size.


193
00:10:45,886 --> 00:10:48,656
And if you haven't implemented
Autolayout constraints,


194
00:10:49,166 --> 00:10:53,226
systemLayoutSizeFittingSize
calls sizeThatFits.


195
00:10:53,226 --> 00:10:57,826
And then, you can simply
return a size manually based


196
00:10:57,826 --> 00:10:59,326
on your own logic.


197
00:11:00,246 --> 00:11:03,456
So by adding sizeThatFits,
you don't have


198
00:11:03,516 --> 00:11:05,406
to use Autolayout if
you don't want to.


199
00:11:05,646 --> 00:11:07,906
If you are using Autolayout
as it notes up there,


200
00:11:08,166 --> 00:11:11,476
you want to add your constraints
to the content view of the cell.


201
00:11:12,656 --> 00:11:15,596
You always think about
whatever content you have goes


202
00:11:15,596 --> 00:11:16,756
in the cells content view.


203
00:11:17,266 --> 00:11:20,546
And this plays into
what the API contract is


204
00:11:20,886 --> 00:11:24,746
when we are sizing your
cell because there's sort


205
00:11:24,746 --> 00:11:27,586
of a-there's an in
and out situation.


206
00:11:28,116 --> 00:11:30,516
The in to your cell is a width


207
00:11:31,266 --> 00:11:33,756
and that width is the
width of the content view.


208
00:11:34,756 --> 00:11:39,196
What your cell returns is the
height of the content view.


209
00:11:39,846 --> 00:11:43,636
So, when you're implementing
sizeThatFits, for example,


210
00:11:43,886 --> 00:11:47,036
the size that we send you
will have the resolved width,


211
00:11:47,036 --> 00:11:48,996
what the width of the
content view is going to be.


212
00:11:49,246 --> 00:11:52,696
And then, the value that you
return has a resolved height.


213
00:11:53,016 --> 00:11:55,426
And even still with your
constraints, you should think


214
00:11:55,426 --> 00:11:58,636
about how you build your
constraints as assuming


215
00:11:58,636 --> 00:12:01,796
that you've got a width,
the content view has a width


216
00:12:01,796 --> 00:12:04,476
and that was predetermined
by the table view based


217
00:12:04,476 --> 00:12:06,696
on how wide the table
view is, you know,


218
00:12:06,696 --> 00:12:08,466
whether you have an image
view or accessory views


219
00:12:08,496 --> 00:12:10,396
that will make us
shrink the content view.


220
00:12:11,056 --> 00:12:12,556
And then from that width,


221
00:12:12,816 --> 00:12:15,076
your constraints
define a height based


222
00:12:15,076 --> 00:12:17,266
on the content that you have.


223
00:12:17,756 --> 00:12:20,266
So I'd like to spend the
rest of the time, well,


224
00:12:20,266 --> 00:12:23,656
actually the table view time,
telling you or showing you


225
00:12:23,656 --> 00:12:26,376
in code how to actually do this.


226
00:12:26,916 --> 00:12:30,916
We're going to see that this
is quite simple at its base,


227
00:12:31,546 --> 00:12:36,076
but I also kind of want
to run through gotchas


228
00:12:36,566 --> 00:12:40,376
that you might run into,
that other people have run


229
00:12:40,376 --> 00:12:45,076
into in the past so that you
can kind of keep the idea


230
00:12:45,076 --> 00:12:47,966
in your head that, "Hey, this
is simple," but if I go back


231
00:12:48,036 --> 00:12:50,266
to my hotel or if I
go back to my company


232
00:12:50,316 --> 00:12:52,556
and I start implementing
this and it just doesn't seem


233
00:12:52,556 --> 00:12:55,376
to work, come back
and watch this video


234
00:12:55,776 --> 00:12:59,056
because there's a good chance
I will have covered what is


235
00:12:59,056 --> 00:13:02,976
causing your code to not do
what you think it's going to do.


236
00:13:03,886 --> 00:13:10,946
So let's start off
by going to Settings


237
00:13:11,246 --> 00:13:13,256
and looking at our Text Size.


238
00:13:13,256 --> 00:13:16,766
Right now, I've got it set
to be the smallest thing.


239
00:13:17,326 --> 00:13:19,956
I'll just put it to regular.


240
00:13:21,526 --> 00:13:25,456
And this application I've got
right now just has a very simple


241
00:13:25,456 --> 00:13:29,406
table view and it
doesn't do a whole lot.


242
00:13:29,406 --> 00:13:34,746
It just has a one-line
text label in cells


243
00:13:34,746 --> 00:13:38,926
that are all predetermined
to be 44 points tall.


244
00:13:40,026 --> 00:13:45,736
So, one thing about this that
is interesting, if I'm on iOS 8,


245
00:13:45,736 --> 00:13:50,866
is you take a look at that
and if I change my text size


246
00:13:51,806 --> 00:14:00,866
and I bring it all the way
up, then run the app again.


247
00:14:01,076 --> 00:14:03,356
You see nothing changes
and that's the problem.


248
00:14:03,536 --> 00:14:05,646
We want something
to change on iOS 8.


249
00:14:05,906 --> 00:14:09,046
We want our app to be adaptive
to what the user wants.


250
00:14:10,086 --> 00:14:13,936
So, since in this case
I'm using a custom label


251
00:14:14,396 --> 00:14:16,196
that I've called
-headlineLabel here.


252
00:14:16,356 --> 00:14:19,076
I created it right in
my cell's initializer.


253
00:14:19,626 --> 00:14:23,916
The problem is that I have
set the headline label's font


254
00:14:24,176 --> 00:14:25,666
to be a specific size.


255
00:14:26,536 --> 00:14:31,236
And actually what I want is
to use a Dynamic Type font.


256
00:14:31,646 --> 00:14:33,006
And so I'll just change this


257
00:14:33,866 --> 00:14:38,936
to preferredFontForText
Style:UIFontTextStyleHeadline.


258
00:14:40,046 --> 00:14:41,576
It's perfect.


259
00:14:41,646 --> 00:14:45,846
And if I run that now, we'll see


260
00:14:45,846 --> 00:14:48,506
that the text did get
bigger and that's great.


261
00:14:48,506 --> 00:14:50,556
It adapted to what
the user wanted.


262
00:14:50,866 --> 00:14:53,926
But this looks a
little weird now


263
00:14:54,126 --> 00:14:57,946
because the cells are the same
size that they were before


264
00:14:57,946 --> 00:15:01,686
and I want the cells to
grow along with the text


265
00:15:02,466 --> 00:15:06,756
because if I have giant texts,
small cells, things are weird.


266
00:15:08,226 --> 00:15:18,086
So, what I'm going to do is
use constraints via Autolayout


267
00:15:18,276 --> 00:15:19,596
and I've got a whole
bunch of them here,


268
00:15:19,596 --> 00:15:20,856
I'm going to walk through them.


269
00:15:21,586 --> 00:15:25,906
We could do this in Interface
Builder as well but I thought


270
00:15:26,226 --> 00:15:27,796
if we walk through this in code,


271
00:15:27,796 --> 00:15:31,586
it will cause a little
bit more understanding


272
00:15:31,586 --> 00:15:33,336
about what we're actually doing.


273
00:15:33,666 --> 00:15:37,326
So, I have four sets of
constraint logic here.


274
00:15:37,786 --> 00:15:42,536
What I'm doing with this first
one is setting what happens


275
00:15:42,766 --> 00:15:43,636
at the top.


276
00:15:43,636 --> 00:15:46,436
I'm setting some spacing
at the top of my label.


277
00:15:46,756 --> 00:15:52,956
So I'm saying that the first
baseline is equal to the top


278
00:15:52,956 --> 00:15:57,476
of the content view plus a
constant and a multiplier.


279
00:15:58,056 --> 00:15:59,556
And the reason that I, you know,


280
00:15:59,556 --> 00:16:01,806
I've picked these values
somewhat arbitrarily,


281
00:16:02,156 --> 00:16:05,296
but the reason that there's a
multiplier is I want the space


282
00:16:05,346 --> 00:16:11,016
between the first baseline and
the top to grow not simply equal


283
00:16:11,016 --> 00:16:15,466
to the growth of the
font but I want it


284
00:16:15,516 --> 00:16:20,096
to grow a little bit more so
that we get even more space


285
00:16:20,226 --> 00:16:24,156
between the top of the text
in the top as the font grows.


286
00:16:24,686 --> 00:16:28,116
So then I do something
very similar,


287
00:16:29,016 --> 00:16:31,876
setting a padding at the bottom.


288
00:16:31,986 --> 00:16:35,256
So that's just setting
an AttributeBottom


289
00:16:35,426 --> 00:16:40,236
for my content view to be
based off of the last baseline


290
00:16:40,596 --> 00:16:45,896
of the label, again, with sort
of a constant that I just picked


291
00:16:46,516 --> 00:16:50,436
and a multiplier for the same
reason I have a multiplier


292
00:16:50,826 --> 00:16:51,646
up here again.


293
00:16:51,916 --> 00:16:53,686
These values are
not magic values.


294
00:16:53,686 --> 00:16:56,366
They're largely values that
I picked out of thin air.


295
00:16:56,796 --> 00:17:00,186
So that gives me
padding at the top


296
00:17:00,426 --> 00:17:02,276
and the bottom of my content.


297
00:17:02,336 --> 00:17:05,276
And as the content grows, then
I will still have that padding


298
00:17:05,276 --> 00:17:08,826
and the cell will
actually grow with it.


299
00:17:09,556 --> 00:17:12,955
The last thing I did
here for height is,


300
00:17:12,955 --> 00:17:14,685
I wanted to have a minimum.


301
00:17:14,866 --> 00:17:16,695
The human interface
guideline says,


302
00:17:16,695 --> 00:17:18,766
"We want to have touchable
things, like table views,


303
00:17:18,766 --> 00:17:20,746
be at least 44-point tall."


304
00:17:21,386 --> 00:17:23,415
So, I've set a constraint
that says,


305
00:17:23,415 --> 00:17:26,965
"I want my content view's height
to be greater than or equal


306
00:17:26,965 --> 00:17:29,996
to 44," simple as that.


307
00:17:29,996 --> 00:17:32,746
So even if the text
size gets very small,


308
00:17:32,916 --> 00:17:34,546
I actually still want
to keep the cell to be


309
00:17:34,546 --> 00:17:38,246
at least 44 points tall to meet
the human interface guideline.


310
00:17:39,376 --> 00:17:42,166
For the horizontal axis,


311
00:17:42,696 --> 00:17:47,086
I've just used a simple
visual format language to say


312
00:17:47,366 --> 00:17:51,646
that I want 15-point margins
around my headlineLabel


313
00:17:52,146 --> 00:17:53,696
and I'm just adding
those to the array.


314
00:17:53,816 --> 00:17:56,556
I had all those constraints
in my content view.


315
00:17:56,556 --> 00:17:59,846
And now that I've done that,


316
00:17:59,846 --> 00:18:04,836
let's run it and
see what happens.


317
00:18:05,486 --> 00:18:09,096
Well, it actually
looks the same.


318
00:18:09,316 --> 00:18:12,136
And, I have something
really scary here.


319
00:18:12,676 --> 00:18:16,806
I have a bunch of Autolayout
constraints failing messages.


320
00:18:17,516 --> 00:18:24,926
[ Applause ]


321
00:18:25,426 --> 00:18:27,686
Thankfully, there is a solution.


322
00:18:29,306 --> 00:18:33,006
So, I mentioned this
earlier but part


323
00:18:33,006 --> 00:18:38,416
of being dynamic-or
self-sizing cell-aware and using


324
00:18:38,416 --> 00:18:40,146
that in your application is


325
00:18:40,146 --> 00:18:44,016
that you use row
height estimation rather


326
00:18:44,016 --> 00:18:46,946
than literal row heights
in your table view.


327
00:18:47,446 --> 00:18:50,626
So if we look at my
ViewController, in viewDidLoad,


328
00:18:51,006 --> 00:18:53,516
previously I was setting
the row height to 44.


329
00:18:54,166 --> 00:18:56,906
Well, if we do that and
we have self-sizing cells,


330
00:18:57,726 --> 00:18:59,106
the self-sizing doesn't kick


331
00:18:59,266 --> 00:19:02,376
in because I've said row
height is 44 and that's sort


332
00:19:02,376 --> 00:19:03,796
of the end-all be-all
for table view.


333
00:19:05,046 --> 00:19:07,606
What I really want
now in iOS 8 is


334
00:19:08,386 --> 00:19:11,056
to set the estimated row height.


335
00:19:12,266 --> 00:19:14,696
So, when you run
into this problem,


336
00:19:14,696 --> 00:19:17,996
try to remember Luke said
use estimatedRowHeight,


337
00:19:18,216 --> 00:19:20,116
not rowHeight on iOS 8.


338
00:19:20,616 --> 00:19:24,796
And then when you
run this-oh God,


339
00:19:26,396 --> 00:19:27,966
Luke's solution didn't
even work.


340
00:19:30,846 --> 00:19:33,186
Well, so here's one
other gotcha here,


341
00:19:33,666 --> 00:19:37,766
which actually will be
fixed in the next seed,


342
00:19:38,016 --> 00:19:39,556
but I wanted to show you-


343
00:19:40,516 --> 00:19:43,636
[ Applause ]


344
00:19:44,136 --> 00:19:49,266
I wanted to show you so
you don't think I'm a liar


345
00:19:49,306 --> 00:19:52,696
when we go back to your rooms.


346
00:19:52,696 --> 00:19:56,296
So, if your cell or if
your table view is coming


347
00:19:56,296 --> 00:19:58,106
out of a NIB or a storyboard,


348
00:19:59,206 --> 00:20:04,076
then its-row height property
will be set when it comes


349
00:20:04,076 --> 00:20:05,366
out of that storyboard.


350
00:20:07,006 --> 00:20:08,946
We want it to be the default.


351
00:20:08,946 --> 00:20:11,176
This is actually the new
default for rowHeight


352
00:20:11,906 --> 00:20:18,126
in iOS 8 is
UITableViewAutomaticDimension.


353
00:20:18,986 --> 00:20:21,226
That means, hey, I
don't have a row height,


354
00:20:21,556 --> 00:20:24,566
figure it out based
on other information.


355
00:20:24,936 --> 00:20:27,466
And this is already the default


356
00:20:27,576 --> 00:20:30,916
for programmatically created
table views and, as of seed two,


357
00:20:31,086 --> 00:20:34,346
will be the default for
table views that come


358
00:20:34,346 --> 00:20:36,356
out of storyboards
and NIBs as well.


359
00:20:36,756 --> 00:20:40,396
It's interesting actually
to know this in general


360
00:20:40,516 --> 00:20:43,006
that this default has-this
default value has changed


361
00:20:43,036 --> 00:20:46,736
because it used to be 44 and
now it's AutomaticDimension.


362
00:20:47,256 --> 00:20:51,266
Because if you were doing
math based on the value


363
00:20:51,266 --> 00:20:55,596
of tableViewrowHeight and just
expecting the default value


364
00:20:55,596 --> 00:20:59,766
to be something that is
reasonable to do math on,


365
00:21:00,066 --> 00:21:03,126
that's not true unless
you have actually set the


366
00:21:03,126 --> 00:21:04,046
rowHeight value.


367
00:21:04,746 --> 00:21:06,636
So, if you run into
weird things,


368
00:21:06,636 --> 00:21:11,206
like all of your table cells
suddenly shrunk to no width,


369
00:21:11,466 --> 00:21:15,086
or no height rather, look
and see if you're doing math


370
00:21:15,526 --> 00:21:16,666
with the rowHeight property.


371
00:21:17,126 --> 00:21:23,106
So, now that I've done
that-oh, thank God,


372
00:21:23,596 --> 00:21:26,126
no more weird layout
constraint messages.


373
00:21:26,126 --> 00:21:29,656
And actually, my cells
have grown a bit.


374
00:21:29,656 --> 00:21:33,216
They look more natural
for this text size.


375
00:21:34,236 --> 00:21:38,566
So now that that is true,
there's something else


376
00:21:38,566 --> 00:21:46,246
that I can do here, and that is
go back to my cell and I want


377
00:21:46,816 --> 00:21:51,516
to make those labels which
are all clipping off the end


378
00:21:51,516 --> 00:21:54,656
of the screen not
do that anymore.


379
00:21:56,136 --> 00:22:03,116
So, let me take
-headlineLabel.numberOfLines,


380
00:22:03,686 --> 00:22:10,306
make it 0 so it should grow the
height of the label according


381
00:22:10,306 --> 00:22:12,026
to the content that's in it.


382
00:22:12,936 --> 00:22:18,586
If I run that now, now my cells
all become the right size based


383
00:22:18,586 --> 00:22:21,986
on this content that's in them.


384
00:22:23,191 --> 00:22:25,191
[ Applause ]


385
00:22:25,366 --> 00:22:26,956
And that's it.


386
00:22:26,956 --> 00:22:29,566
I don't have any
delegate methods at all.


387
00:22:29,566 --> 00:22:31,166
I'll prove it to you, nothing.


388
00:22:32,486 --> 00:22:34,406
Except for
cellForRowAtIndexPath, I mean,


389
00:22:34,496 --> 00:22:36,156
got to have that, right?


390
00:22:36,546 --> 00:22:37,596
So that's it.


391
00:22:38,696 --> 00:22:43,286
That's all you need to
know to migrate your table


392
00:22:44,886 --> 00:22:49,946
from an iOS 7 style table
to an iOS 8 style table.


393
00:22:50,416 --> 00:22:53,256
And I encourage you to go do
this right away because you want


394
00:22:53,256 --> 00:22:55,576
to be ready by the
time we shift iOS 8


395
00:22:55,576 --> 00:22:59,526
to have your fully adaptive apps
that respond to Dynamic Type


396
00:22:59,846 --> 00:23:01,746
and are just fabulous for users.


397
00:23:02,086 --> 00:23:05,486
So that's table view in
iOS 8 and we're going


398
00:23:05,486 --> 00:23:07,576
to spend the rest
of this talk talking


399
00:23:07,576 --> 00:23:10,496
about collection view features
that I mentioned earlier.


400
00:23:10,786 --> 00:23:16,116
And Olivier Gutknecht will come
up to enlighten us as it were.


401
00:23:17,516 --> 00:23:21,336
[ Applause ]


402
00:23:21,836 --> 00:23:23,096
>> Thank you.


403
00:23:23,366 --> 00:23:27,086
Hi, my name is Olivier Gutknecht
and I love collection views.


404
00:23:27,726 --> 00:23:33,736
So today, we have
two new features


405
00:23:34,356 --> 00:23:35,466
in collection view for you.


406
00:23:36,686 --> 00:23:39,976
So first one, of course,
is self-sizing cells.


407
00:23:41,296 --> 00:23:44,436
We added that to table
view and, of course,


408
00:23:44,436 --> 00:23:47,976
we had to enhance
collection view


409
00:23:47,976 --> 00:23:50,126
to support self-sizing cells.


410
00:23:50,766 --> 00:23:58,376
But collection view is quite a
generic class and a key thing


411
00:23:58,376 --> 00:24:03,216
in collection view is you can
actually build your own layout.


412
00:24:04,496 --> 00:24:07,896
And when we implemented
the self-sizing cells,


413
00:24:08,886 --> 00:24:12,046
we added a new infrastructure
to do that.


414
00:24:13,056 --> 00:24:15,696
And what we wanted to
do is to actually open


415
00:24:15,696 --> 00:24:18,016
that for your custom layouts.


416
00:24:18,996 --> 00:24:21,066
So if you have a custom layout,


417
00:24:21,566 --> 00:24:25,246
you can actually implement
the same self-sizing cells


418
00:24:25,316 --> 00:24:29,266
techniques we have in
all different layout.


419
00:24:31,096 --> 00:24:37,116
So, self-sizing cells, we
think it's a major new feature


420
00:24:37,536 --> 00:24:40,616
in collection view because,
with self-sizing cells,


421
00:24:40,676 --> 00:24:43,846
you can support easily
Dynamic Type.


422
00:24:44,616 --> 00:24:48,836
We're making that available
in UICollectionViewFlowLayout


423
00:24:49,506 --> 00:24:55,176
which is our default
layout we provide in UIKit.


424
00:24:56,456 --> 00:25:01,126
And it's really for
your own custom layouts.


425
00:25:02,316 --> 00:25:09,756
But first, I'd like to do a very
quick demo of self-sizing cell


426
00:25:10,266 --> 00:25:12,316
in UICollectionViewFlowLayout.


427
00:25:12,316 --> 00:25:18,916
So, this is a very
simple collection view.


428
00:25:20,336 --> 00:25:23,496
I actually tried to make
that simpler but I couldn't.


429
00:25:23,496 --> 00:25:30,026
So, it's a flow layout and
we just set the item size


430
00:25:30,686 --> 00:25:35,016
of all elements of the
screen to be the same CGSize.


431
00:25:35,626 --> 00:25:38,706
So we don't even
have a delegate.


432
00:25:39,746 --> 00:25:43,036
We just used the
itemSize property


433
00:25:43,556 --> 00:25:45,196
on UICollectionViewFlowLayout


434
00:25:46,216 --> 00:25:52,476
and UICollectionViewCells
here are extremely simple.


435
00:25:52,476 --> 00:25:55,276
It's basically just a label


436
00:25:55,276 --> 00:25:57,586
and everything is
sized the same way.


437
00:25:58,526 --> 00:26:01,766
So, of course, it's not great.


438
00:26:02,806 --> 00:26:08,586
And when you want to actually
adjust your item size based


439
00:26:08,586 --> 00:26:12,886
on the content of that cell, you
can actually do that right now.


440
00:26:13,626 --> 00:26:15,496
You have to implement a delegate


441
00:26:16,046 --> 00:26:17,596
on the
UICollectionViewFlowLayout


442
00:26:17,596 --> 00:26:22,196
to compute the correct
size for a given item


443
00:26:23,116 --> 00:26:26,376
and then the cell
is going to be sized


444
00:26:26,966 --> 00:26:29,576
with what the layout returns.


445
00:26:29,976 --> 00:26:32,666
But it's a bit inconvenient.


446
00:26:33,596 --> 00:26:37,876
Because basically in your
data source, in your delegate,


447
00:26:38,526 --> 00:26:41,966
you have to compute a size based


448
00:26:41,966 --> 00:26:44,876
on the font you're going
to use in this label.


449
00:26:45,726 --> 00:26:50,366
And then, your cell is
implemented with the label.


450
00:26:50,366 --> 00:26:55,506
So, you're basically duplicating
code and that's not great.


451
00:26:55,556 --> 00:27:00,536
So, what I'm going to
do now is I'm going


452
00:27:00,536 --> 00:27:02,386
to use the exact
same collection view,


453
00:27:02,546 --> 00:27:05,506
the same flow layout,
the same cell class.


454
00:27:06,206 --> 00:27:09,626
I'm not going to change
to a different layout.


455
00:27:10,486 --> 00:27:14,086
I'm just going to
enable self-sizing cells


456
00:27:14,846 --> 00:27:16,556
on UICollectionViewFlowLayout.


457
00:27:17,146 --> 00:27:20,126
And that's what we have.


458
00:27:20,986 --> 00:27:22,846
It's dynamically sized.


459
00:27:24,306 --> 00:27:28,156
The flow layout still
works the same usual way


460
00:27:28,406 --> 00:27:34,116
by dynamically flowing,
adding cells line by line


461
00:27:35,166 --> 00:27:38,126
and it's a new feature in
UICollectionViewFlowLayout.


462
00:27:38,446 --> 00:27:40,936
The only thing you have to do is


463
00:27:40,936 --> 00:27:45,106
to have your cell class
implemented with Autolayout


464
00:27:45,836 --> 00:27:47,416
or using sizeThatFits.


465
00:27:52,516 --> 00:27:57,196
[ Applause ]


466
00:27:57,696 --> 00:28:03,306
So, how do you size cells
with UICollectionView?


467
00:28:05,096 --> 00:28:09,226
The usual way, the classic
way to size items on screen


468
00:28:10,496 --> 00:28:11,756
with the collection view is


469
00:28:11,756 --> 00:28:15,986
to actually have the
layout compute items,


470
00:28:16,556 --> 00:28:18,226
size and position onscreen.


471
00:28:18,896 --> 00:28:24,066
So in that case-and that was
what was happening with iOS 6


472
00:28:24,116 --> 00:28:31,226
and iOS 7, the collection view
layout decides everything.


473
00:28:32,366 --> 00:28:36,896
The cell is just-We are just
enforcing a size for this cell.


474
00:28:38,256 --> 00:28:44,146
So, in iOS 8, we're adding
these self-sizing cells' mode,


475
00:28:44,836 --> 00:28:48,546
which mean that just
like with table view,


476
00:28:49,206 --> 00:28:53,326
you can actually use constraints
on your cell content view.


477
00:28:54,086 --> 00:28:57,856
Or, if you are using
manual layout, you just have


478
00:28:57,886 --> 00:28:59,826
to override sizeThatFits.


479
00:29:01,856 --> 00:29:07,386
But when setting cells
onscreen with a collection view,


480
00:29:08,466 --> 00:29:12,006
a layout basically computes
a set of attributes.


481
00:29:12,616 --> 00:29:17,106
And in these attributes,
we have position, size,


482
00:29:17,416 --> 00:29:20,896
but all the things like
alpha or even transform.


483
00:29:22,186 --> 00:29:27,616
And we are actually opening
that also at the cell level.


484
00:29:28,516 --> 00:29:32,976
It means that if you override
preferredLayoutAttributes


485
00:29:34,096 --> 00:29:39,146
FittingAttributes in your cell
class, you can actually tweak


486
00:29:40,236 --> 00:29:42,966
for the layout itself
to compute.


487
00:29:43,746 --> 00:29:45,036
It's extremely powerful.


488
00:29:45,246 --> 00:29:50,846
So, to summarize, the first
mode, the classic mode,


489
00:29:50,896 --> 00:29:54,856
the layout, the size,
computes attributes


490
00:29:54,906 --> 00:29:56,926
and the collection view
is going to create a cell


491
00:29:57,436 --> 00:29:59,726
and enforce that size.


492
00:30:00,936 --> 00:30:03,986
The second mode is
the layout is going


493
00:30:03,986 --> 00:30:08,766
to compute an approximation,
provide attributes.


494
00:30:09,766 --> 00:30:12,776
The collection view is
going to do the usual thing


495
00:30:12,776 --> 00:30:18,006
if you create cell and
then the cell is going


496
00:30:18,006 --> 00:30:21,186
to adjust, if needed, that size.


497
00:30:21,796 --> 00:30:29,446
And the third mode, the layout
again estimate the attributes


498
00:30:30,376 --> 00:30:34,646
but then the cell can
actually tweak any property


499
00:30:35,476 --> 00:30:38,016
on the layout attributes
including transform.


500
00:30:39,516 --> 00:30:44,976
[ Applause ]


501
00:30:45,476 --> 00:30:48,866
So, we are making that
available as a new feature


502
00:30:48,866 --> 00:30:51,466
of UICollectionViewFlowLayout.


503
00:30:52,146 --> 00:30:56,426
How can you use that?


504
00:30:57,046 --> 00:30:59,136
It's actually easy.


505
00:31:00,406 --> 00:31:03,136
Step one, we have
a new property.


506
00:31:04,326 --> 00:31:06,566
It's estimatedItemSize.


507
00:31:07,846 --> 00:31:13,096
Because on collection view
we're really talking about width


508
00:31:13,096 --> 00:31:15,566
and height, it's a CGSize.


509
00:31:16,596 --> 00:31:18,186
But apart from that,


510
00:31:18,186 --> 00:31:23,396
it's basically the same model
Luke described for table views.


511
00:31:23,956 --> 00:31:26,566
How do you enable that?


512
00:31:27,576 --> 00:31:32,066
You just set this property
to a non-zero CGSize.


513
00:31:32,776 --> 00:31:33,716
That was step one.


514
00:31:34,216 --> 00:31:36,416
Step two is...


515
00:31:36,946 --> 00:31:38,496
there is no step two.


516
00:31:39,696 --> 00:31:42,706
If you want to use
self-sizing cells


517
00:31:43,976 --> 00:31:47,046
in UICollectionViewFlowLayout,
it's one line.


518
00:31:48,256 --> 00:31:49,266
That was my demo.


519
00:31:49,386 --> 00:31:55,096
I replaced ItemSize with
estimatedItemSize and that's it.


520
00:31:56,316 --> 00:31:56,946
That's pretty cool.


521
00:31:57,516 --> 00:32:02,666
[ Applause ]


522
00:32:03,166 --> 00:32:09,276
Now, I'd like to talk about
how that works and how


523
00:32:09,276 --> 00:32:13,176
that changed things in
the collection view model.


524
00:32:14,136 --> 00:32:17,446
Self-sizing is really
a collaboration


525
00:32:17,446 --> 00:32:20,766
between three things,
the layout,


526
00:32:21,636 --> 00:32:26,456
the collection view
and the cell.


527
00:32:26,676 --> 00:32:30,886
The first thing a flow
layout is going to do is


528
00:32:31,336 --> 00:32:33,816
to compute a first pass,


529
00:32:34,476 --> 00:32:37,286
the first approximation
of your layout.


530
00:32:38,806 --> 00:32:40,556
And based on this
information, what's going


531
00:32:40,556 --> 00:32:45,216
to happen is the
collection view is going


532
00:32:45,216 --> 00:32:49,296
to the queue, create
these cells.


533
00:32:49,806 --> 00:32:57,386
We're going to self-size these
items again using Autolayout


534
00:32:57,466 --> 00:33:00,736
or sizeThatFits or
preferred layout attributes


535
00:33:00,736 --> 00:33:03,596
for fitting attributes.


536
00:33:04,196 --> 00:33:08,866
And then, we are
actually sending back


537
00:33:10,076 --> 00:33:14,066
that updated information
to the layout.


538
00:33:15,136 --> 00:33:21,706
The layout can now decide
if it wants to react to that


539
00:33:21,916 --> 00:33:27,486
and actually send the final
layout attributes we need


540
00:33:27,486 --> 00:33:30,386
to actually display
cells onscreen.


541
00:33:31,486 --> 00:33:33,956
So, a very important thing


542
00:33:34,736 --> 00:33:39,136
about this model is it's
actually the same model we're


543
00:33:39,136 --> 00:33:40,946
using with collection view.


544
00:33:41,366 --> 00:33:46,156
So, layout is in charge
and is always in charge.


545
00:33:47,106 --> 00:33:54,526
But the catch is now we have
a way to actually communicate


546
00:33:54,986 --> 00:34:00,026
to the layout that maybe we
should actually adjust things


547
00:34:01,106 --> 00:34:03,216
because the cell size
might be slightly different


548
00:34:04,286 --> 00:34:08,076
from this first approximation
we computed before.


549
00:34:09,516 --> 00:34:14,286
That's a very generic and
extremely powerful mechanism.


550
00:34:16,076 --> 00:34:21,646
So, now, I'd like to
talk about custom layouts


551
00:34:22,376 --> 00:34:23,406
and smart invalidation.


552
00:34:24,136 --> 00:34:29,406
But first I'm going
to refresh your memory


553
00:34:29,406 --> 00:34:34,426
about how collection view
layout and validation works.


554
00:34:34,886 --> 00:34:41,646
So, if you have a custom layout,
if you got a custom layout,


555
00:34:42,286 --> 00:34:46,856
you know that the first
time we try to present cells


556
00:34:47,045 --> 00:34:50,505
or supplementary views or
decoration views onscreen,


557
00:34:52,025 --> 00:34:54,656
the first method we are coding


558
00:34:54,656 --> 00:34:57,766
on your custom layout
is prepareLayout.


559
00:34:59,756 --> 00:35:05,166
Usually, that's when you can
actually pre-compute things


560
00:35:06,306 --> 00:35:11,786
or cache some attributes,
have a generic idea


561
00:35:11,786 --> 00:35:14,486
about what your layout
is going to be.


562
00:35:14,956 --> 00:35:19,706
Because the next
thing we're going


563
00:35:19,706 --> 00:35:27,156
to ask you is the overall
size of your custom layout.


564
00:35:27,736 --> 00:35:32,746
And based on that, and
based on what section


565
00:35:33,726 --> 00:35:40,756
of this layout we want to show
onscreen, then to ask the layout


566
00:35:42,006 --> 00:35:49,686
to provide a list of attributes
for items in a given rect.


567
00:35:50,716 --> 00:35:53,806
For instance, usually
the visible bounds


568
00:35:54,406 --> 00:35:59,776
of the collection view.


569
00:35:59,776 --> 00:36:01,316
Based on these attributes,


570
00:36:01,806 --> 00:36:05,676
the next thing is the
collection view is going


571
00:36:05,676 --> 00:36:11,846
to do the usual work of
dequeuing, creating cells,


572
00:36:12,606 --> 00:36:16,716
possibly coding sizeThatFits or
applying Autolayout constraints.


573
00:36:16,716 --> 00:36:22,916
So, in that case,
you would return 6


574
00:36:23,476 --> 00:36:31,146
and 6 plus the supplementary
view attributes describing what


575
00:36:31,146 --> 00:36:35,486
is in this rect.


576
00:36:36,266 --> 00:36:40,866
Now, you might actually
later invalidate this layout,


577
00:36:42,076 --> 00:36:46,216
for instance, because you want
to apply some special effect


578
00:36:46,626 --> 00:36:51,946
when you scroll, like a
cover flow-like effect.


579
00:36:53,046 --> 00:36:55,946
In that case, you have
to call invalidateLayout,


580
00:36:55,946 --> 00:37:00,816
which is basically a way to tell
the collection view that OK,


581
00:37:01,216 --> 00:37:02,316
we are starting again.


582
00:37:02,986 --> 00:37:06,636
What's going to happen
is we begin


583
00:37:06,636 --> 00:37:08,116
to call prepareLayout again.


584
00:37:09,036 --> 00:37:12,606
And that full cycle
starts again.


585
00:37:14,056 --> 00:37:19,946
So, obviously, there is
a small problem here.


586
00:37:20,836 --> 00:37:26,156
If each time we call or
you call invalidateLayout,


587
00:37:26,716 --> 00:37:29,786
you have to re-compute
all these attributes.


588
00:37:30,046 --> 00:37:33,926
Not the best way to have
a high-performance layout.


589
00:37:33,956 --> 00:37:40,856
So, we actually have
a great solution


590
00:37:40,856 --> 00:37:42,396
for you for this problem.


591
00:37:43,416 --> 00:37:47,626
Be lazy or smart
or lazy and smart


592
00:37:48,766 --> 00:37:52,286
which basically means
re-compute only what you need.


593
00:37:53,836 --> 00:37:58,796
And that's a strategy you
can use right now in iOS 7


594
00:37:59,736 --> 00:38:02,856
with something we call
invalidation contexts,


595
00:38:03,916 --> 00:38:07,696
because that's a class that
we introduced in iOS 7.


596
00:38:08,856 --> 00:38:14,856
And this class is basically
a tool for your custom layout


597
00:38:15,846 --> 00:38:20,036
to indicate what changed,
because it's your layout


598
00:38:20,926 --> 00:38:23,036
so you know what to do.


599
00:38:23,036 --> 00:38:27,276
So, invalidation contexts in
iOS 7 were basically a way


600
00:38:27,276 --> 00:38:32,356
to provide fine-grain
information to your layout


601
00:38:33,076 --> 00:38:34,766
when things are invalidated.


602
00:38:35,456 --> 00:38:41,156
We were actually using this
invalidation context class


603
00:38:41,266 --> 00:38:46,806
already for things like rotation
in UICollectionViewFlowLayout.


604
00:38:47,396 --> 00:38:52,046
And now, we are using that
for self-sizing cells.


605
00:38:52,046 --> 00:38:59,146
So, in iOS 7, when using
an invalidation context,


606
00:38:59,836 --> 00:39:00,706
it's actually easy.


607
00:39:01,306 --> 00:39:05,336
You have to define a collection
view invalidation context


608
00:39:05,336 --> 00:39:10,096
subclass exposed at
your layout level.


609
00:39:11,106 --> 00:39:14,886
And instead of coding
invalidateLayout,


610
00:39:14,946 --> 00:39:16,846
which is the very generic,


611
00:39:17,576 --> 00:39:20,686
remove everything
invalidation method,


612
00:39:21,276 --> 00:39:25,266
we can actually call
invalidateLayoutWithContext


613
00:39:26,166 --> 00:39:29,126
and pass an instance
of your class


614
00:39:29,606 --> 00:39:32,576
where you're probably
adding some information


615
00:39:32,576 --> 00:39:36,746
about what you should do in a
given invalidation situation.


616
00:39:39,436 --> 00:39:44,386
We also provided an override
point for bounds change,


617
00:39:44,676 --> 00:39:48,216
which is a common
thing you want to do.


618
00:39:48,216 --> 00:39:52,046
So if your layout is
continuously invalidating


619
00:39:52,046 --> 00:39:56,686
on scrolling on bounds
change or rotation,


620
00:39:56,686 --> 00:39:59,146
you can actually
just override that


621
00:39:59,426 --> 00:40:02,046
and return your invalidation
context


622
00:40:02,156 --> 00:40:03,956
with information
you can use then


623
00:40:03,956 --> 00:40:06,386
in your layout implementation.


624
00:40:09,336 --> 00:40:12,266
We actually added in iOS 7


625
00:40:12,266 --> 00:40:15,896
in this invalidation context
two additional information.


626
00:40:16,906 --> 00:40:19,716
Sometimes when we invalidate,


627
00:40:20,736 --> 00:40:23,416
it's because the
data source changed.


628
00:40:24,496 --> 00:40:30,826
You have items coming in
on or out or we just have


629
00:40:30,826 --> 00:40:33,156
to invalidate everything
in some situations.


630
00:40:33,806 --> 00:40:35,436
These were two properties.


631
00:40:36,326 --> 00:40:39,936
The collection view was setting
up for you and you could use


632
00:40:39,936 --> 00:40:41,916
in your layout implementation.


633
00:40:42,026 --> 00:40:48,116
So, iOS 7 invalidation
contexts were really a class


634
00:40:48,476 --> 00:40:49,736
for your own use basically.


635
00:40:51,126 --> 00:40:53,706
So what's changing in iOS 8?


636
00:40:54,836 --> 00:41:00,336
In iOS 8, invalidation
contexts are really a way


637
00:41:00,336 --> 00:41:04,566
to establish a communication
between your layout


638
00:41:05,596 --> 00:41:06,416
and the collection view.


639
00:41:07,886 --> 00:41:10,816
You can tell the
collection view that,


640
00:41:12,446 --> 00:41:15,886
"Here is my invalidation
situation.


641
00:41:15,886 --> 00:41:17,966
Maybe you can actually
help me with that."


642
00:41:19,156 --> 00:41:21,786
And the information you can pass


643
00:41:21,906 --> 00:41:24,856
to the collection view
can be useful for things


644
00:41:24,856 --> 00:41:29,036
like high-performance floating
headers, sticky headers,


645
00:41:29,036 --> 00:41:31,416
like in table view
when you scroll


646
00:41:31,776 --> 00:41:37,606
and you have this
section header on top.


647
00:41:37,806 --> 00:41:43,376
Another use case is
self-sizing cells.


648
00:41:48,216 --> 00:41:52,196
Oops. Because when cells can
actually change their size,


649
00:41:53,086 --> 00:41:56,226
it might actually change
the overall collection view


650
00:41:56,226 --> 00:41:57,056
content size.


651
00:41:57,436 --> 00:41:58,726
It might change the offset


652
00:41:59,696 --> 00:42:02,696
and invalidation
context are a great way


653
00:42:02,696 --> 00:42:07,596
to tell the collection view
that your layout is adapting


654
00:42:08,276 --> 00:42:09,646
to a self-sizing change.


655
00:42:10,226 --> 00:42:16,366
So, first, fine-grain
invalidation.


656
00:42:16,366 --> 00:42:24,626
We added three new methods on
invalidation context in iOS 8,


657
00:42:25,616 --> 00:42:28,226
invalidateItemsAtIndexPaths,


658
00:42:29,236 --> 00:42:33,386
invalidateSupplementary
ElementsOfKind atIndexPaths


659
00:42:33,776 --> 00:42:39,626
and invalidateDecoration
ElementsOfKind atIndexPaths


660
00:42:39,766 --> 00:42:44,036
and you can access this later.


661
00:42:44,756 --> 00:42:45,846
What's great about that?


662
00:42:47,526 --> 00:42:52,106
First, you can actually call
these methods several times.


663
00:42:52,606 --> 00:42:55,016
You're going to aggregate
that information.


664
00:42:55,586 --> 00:42:59,366
What does that mean
for your layout?


665
00:43:00,086 --> 00:43:03,436
Let's take a very simple,


666
00:43:04,476 --> 00:43:08,426
grid-like layout
with section headers.


667
00:43:09,466 --> 00:43:15,866
And you want to implement
a sticky header on top.


668
00:43:18,596 --> 00:43:25,366
In iOS 7, you basically had
to invalidate the entire rect.


669
00:43:26,596 --> 00:43:31,926
In iOS 8, the only thing
that is actually moving is


670
00:43:31,926 --> 00:43:33,796
that supplementary view.


671
00:43:34,456 --> 00:43:36,776
So what you really
want to use is,


672
00:43:37,226 --> 00:43:43,416
on your invalidation context,
tell us that I'm invalidating


673
00:43:43,956 --> 00:43:48,286
that supplementaryView
atIndexPath throughout.


674
00:43:48,896 --> 00:43:55,376
In that case, we know that only
one thing is actually changing.


675
00:43:55,376 --> 00:43:58,766
So, we're going to
ask your layout, "OK,


676
00:43:58,766 --> 00:44:04,156
give me an updated version
of that supplementary view."


677
00:44:04,426 --> 00:44:07,836
So we are directly going to
call this fine-grain method


678
00:44:07,946 --> 00:44:12,266
on your layout which
is already here,


679
00:44:13,116 --> 00:44:16,256
layoutAttributesFor
SupplementaryViewOfKind,


680
00:44:17,316 --> 00:44:19,556
section header atIndexPath.


681
00:44:20,976 --> 00:44:22,866
And one thing we are not going


682
00:44:23,756 --> 00:44:26,726
to do is calling
layoutAttributes


683
00:44:26,726 --> 00:44:27,656
ForElementsInRect.


684
00:44:27,656 --> 00:44:34,906
So instead of asking
you for 14 attributes


685
00:44:35,986 --> 00:44:38,306
in that invalidation situation,


686
00:44:38,826 --> 00:44:40,676
we are just going
to ask you for one.


687
00:44:42,026 --> 00:44:45,516
It's amazing for
high-performance layouts.


688
00:44:46,516 --> 00:44:52,156
[ Applause ]


689
00:44:52,656 --> 00:44:54,106
Here's a situation
where you want


690
00:44:54,106 --> 00:44:58,606
to use an invalidation context
is for self-sizing cells.


691
00:44:58,956 --> 00:45:02,036
If you want to implement
self-sizing cell


692
00:45:02,036 --> 00:45:05,206
in your own custom layout, well,


693
00:45:05,676 --> 00:45:08,386
you can actually tell
the collection view


694
00:45:08,386 --> 00:45:11,336
that the content-size
is going to change


695
00:45:11,826 --> 00:45:17,086
because that cell was bigger
than expected so you have


696
00:45:17,176 --> 00:45:20,416
to enlarge the overall
content-size.


697
00:45:21,776 --> 00:45:26,416
And you can do that with
a very simple property


698
00:45:27,106 --> 00:45:30,446
on the validation context which
is a contentSizeAdjustment.


699
00:45:30,446 --> 00:45:33,746
So you can give us the delta,


700
00:45:34,736 --> 00:45:37,086
the change between what
was computed before


701
00:45:37,086 --> 00:45:38,946
and the new size.


702
00:45:39,466 --> 00:45:45,766
But, of course, because a cell
might not be what you expected,


703
00:45:47,036 --> 00:45:49,596
it means that the
offset where you are


704
00:45:50,866 --> 00:45:52,166
in the collection
view can change


705
00:45:52,566 --> 00:45:54,166
and you can tell that too.


706
00:45:55,266 --> 00:45:58,096
You can set to
contentOffsetAdjustment


707
00:45:59,106 --> 00:46:00,496
in the invalidation context


708
00:46:01,226 --> 00:46:04,056
and then the collection view
is going to do the right thing


709
00:46:05,036 --> 00:46:10,006
and adjust the position so
you don't see and they jump


710
00:46:10,006 --> 00:46:12,426
from one position
to another just


711
00:46:12,426 --> 00:46:15,626
because your layout
updated itself.


712
00:46:18,676 --> 00:46:23,836
The other feature we're
adding to help you


713
00:46:23,836 --> 00:46:28,596
with self-sizing cells in
your custom layout is a way


714
00:46:28,596 --> 00:46:32,506
to invalidate for
specific attributes.


715
00:46:33,046 --> 00:46:37,146
And that's a new method
on UICollectionViewLayout.


716
00:46:37,836 --> 00:46:42,926
If a cell returns a
different size, for instance,


717
00:46:42,926 --> 00:46:46,106
or different layout attributes,
we're going to ask you


718
00:46:46,106 --> 00:46:49,056
if we should invalidate
the layout.


719
00:46:50,586 --> 00:46:54,296
And because we want
fine-grain invalidation,


720
00:46:54,956 --> 00:46:57,496
we have an override point,


721
00:46:58,656 --> 00:47:03,436
invalidationContext
ForPreferredAttributes based


722
00:47:03,436 --> 00:47:06,156
on the original attributes.


723
00:47:07,656 --> 00:47:10,186
So again, first step,


724
00:47:10,766 --> 00:47:14,266
your layout computes
the first approximation.


725
00:47:16,016 --> 00:47:20,336
We self-size the cells which
might change its attribute


726
00:47:20,756 --> 00:47:25,066
and we pass you these
attributes in your layout.


727
00:47:25,066 --> 00:47:29,886
And again, the layout is
still the final decisionmaker


728
00:47:29,886 --> 00:47:32,226
on what should be on screen.


729
00:47:35,056 --> 00:47:37,986
So, we just like to summarize


730
00:47:38,286 --> 00:47:40,156
that technique for
a custom layout.


731
00:47:40,156 --> 00:47:45,826
It's a very simple,
line-based custom layout,


732
00:47:46,996 --> 00:47:47,766
something like that.


733
00:47:47,766 --> 00:47:51,846
So that's my overall
collection view layout.


734
00:47:51,876 --> 00:47:56,546
I have five cells and
I'm going to compute


735
00:47:57,626 --> 00:47:58,856
that first approximation


736
00:47:58,856 --> 00:48:02,306
by using the usual
layoutAttributes


737
00:48:02,356 --> 00:48:03,636
ForElementsInRect.


738
00:48:03,676 --> 00:48:08,866
So I'm going to assume that
all my cells are exactly the


739
00:48:08,866 --> 00:48:09,606
same size.


740
00:48:10,126 --> 00:48:15,976
But then, collection
view is going


741
00:48:15,976 --> 00:48:18,976
to create these cells
and self-size.


742
00:48:20,006 --> 00:48:26,116
In the first cell, let's say,
adjust to this size based


743
00:48:26,116 --> 00:48:29,626
on sizeThatFits or
through layout


744
00:48:29,626 --> 00:48:31,866
or preferredLayoutAttributes.


745
00:48:32,416 --> 00:48:36,006
And obviously because
of that size change,


746
00:48:37,006 --> 00:48:40,146
my layout is no longer
what I want.


747
00:48:40,146 --> 00:48:47,366
So I will have to update the
position for these other cells.


748
00:48:48,746 --> 00:48:53,876
So, in my layout
implementation, I can decide


749
00:48:53,876 --> 00:48:57,936
if a cell has different
attributes


750
00:48:57,936 --> 00:48:59,766
from what I computed before


751
00:49:00,346 --> 00:49:05,316
that I should actually update
these other cells' attributes.


752
00:49:05,886 --> 00:49:08,906
Of course, there is
one last problem.


753
00:49:10,126 --> 00:49:14,606
My collection view content
size is no longer correct.


754
00:49:14,646 --> 00:49:17,016
So, I want to make
that consistent.


755
00:49:17,016 --> 00:49:19,746
So, in my invalidation context,


756
00:49:23,816 --> 00:49:25,756
I'm going to tell
the collection view


757
00:49:25,756 --> 00:49:30,696
that we should adjust the
collection view content size.


758
00:49:31,226 --> 00:49:37,746
And actually it's not the
only thing I need to do


759
00:49:38,186 --> 00:49:42,096
because my previous
state was three cells


760
00:49:42,676 --> 00:49:43,936
in these visible bounds.


761
00:49:44,776 --> 00:49:46,756
A little bit of the first
cell, the second cell


762
00:49:47,196 --> 00:49:48,686
and part of the third cell.


763
00:49:48,686 --> 00:49:55,216
But the next thing is telling
the collection view that based


764
00:49:55,216 --> 00:49:58,616
on this new cell
information we need


765
00:49:58,616 --> 00:50:03,566
to actually adjust the
offset, so visually we are


766
00:50:03,566 --> 00:50:05,596
in the exact same state.


767
00:50:06,516 --> 00:50:10,876
[ Applause ]


768
00:50:11,376 --> 00:50:13,696
It's, of course,
completely layout-specific.


769
00:50:14,436 --> 00:50:18,546
You can imagine using this
technique for circle layouts,


770
00:50:19,046 --> 00:50:22,906
line layouts, grid
layouts, baseboard layouts.


771
00:50:23,236 --> 00:50:29,566
It's an amazing way to implement
extremely high-performance


772
00:50:30,076 --> 00:50:33,866
layout and add new
features like Dynamic Type.


773
00:50:35,196 --> 00:50:39,386
And to conclude, I'd
like to bring back Luke.


774
00:50:40,516 --> 00:50:46,446
[ Applause ]


775
00:50:46,946 --> 00:50:48,056
>> Thanks so much, Olivier.


776
00:50:48,176 --> 00:50:53,556
Well, you probably
got a theme here


777
00:50:54,326 --> 00:50:57,636
that is we've brought
self-sizing cells to table view,


778
00:50:58,146 --> 00:51:01,146
we've brought self-sizing cells
to collection view in the form


779
00:51:01,146 --> 00:51:04,566
of flow layout and we've also
brought self-sizing cells


780
00:51:04,926 --> 00:51:07,456
to your custom layouts
if you choose


781
00:51:07,456 --> 00:51:09,516
to adopt that methodology.


782
00:51:10,546 --> 00:51:13,506
So, what I want you
to go home with is,


783
00:51:13,506 --> 00:51:17,036
remember that every app should
be adopting Dynamic Type,


784
00:51:17,136 --> 00:51:19,036
if you've got text
in your app that is,


785
00:51:19,036 --> 00:51:20,886
which I imagine is
every single one of you.


786
00:51:21,766 --> 00:51:25,806
When you're doing
this, you might think


787
00:51:25,806 --> 00:51:27,436
about using self-sizing cells.


788
00:51:27,436 --> 00:51:29,456
It will probably
help your cause.


789
00:51:30,476 --> 00:51:34,156
And if you're using
collection view, specifically,


790
00:51:34,426 --> 00:51:38,126
if you are the author of a
custom collection view layout,


791
00:51:38,496 --> 00:51:43,066
this I can't stress enough,
use invalidation contexts.


792
00:51:43,356 --> 00:51:45,456
This is like the
key to the world


793
00:51:45,856 --> 00:51:49,406
for writing high performance
layouts in collection view.


794
00:51:49,586 --> 00:51:53,496
In fact, since we're going to
have a lab right after this,


795
00:51:54,156 --> 00:51:56,986
and I know some people
are going to come


796
00:51:56,986 --> 00:52:01,806
with performance questions,
I'm going to tell you


797
00:52:02,436 --> 00:52:04,586
that my first question
for you will be,


798
00:52:04,586 --> 00:52:06,546
"Are you using invalidation
context?"


799
00:52:07,076 --> 00:52:10,426
And so, if you're not,
learn how to use them.


800
00:52:10,426 --> 00:52:11,246
They're spectacular.


801
00:52:12,036 --> 00:52:14,496
There's another great talk


802
00:52:14,496 --> 00:52:18,146
on collection view later today
particularly for those of you


803
00:52:18,396 --> 00:52:20,066
who are writing custom layouts.


804
00:52:20,626 --> 00:52:22,776
This is "Advanced
User Interfaces


805
00:52:22,776 --> 00:52:26,136
with Collection Views" and
there are some really great tips


806
00:52:26,136 --> 00:52:31,016
in here for how to accomplish
non-standard things, you know,


807
00:52:31,016 --> 00:52:33,856
things that aren't built into
the flow layout that we shipped


808
00:52:34,136 --> 00:52:37,626
and get truly great interfaces
that use collection view.


809
00:52:38,076 --> 00:52:40,496
For more information,
always feel free


810
00:52:40,496 --> 00:52:43,036
to contact our Frameworks
evangelist, Jake Behrens,


811
00:52:43,036 --> 00:52:44,356
and check out the documentation.


812
00:52:44,356 --> 00:52:44,916
Thanks for coming.


813
00:52:45,516 --> 00:52:49,500
[ Applause ]

