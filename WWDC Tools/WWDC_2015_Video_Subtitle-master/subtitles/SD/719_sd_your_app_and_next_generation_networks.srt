1
00:00:23,516 --> 00:00:29,486
[Applause]


2
00:00:29,986 --> 00:00:31,616
>> PRABHAKAR LAKHERA:
Thank you and good morning.


3
00:00:32,656 --> 00:00:36,046
Welcome to Your App and Next
Generation Network session.


4
00:00:36,996 --> 00:00:40,306
I am Prabhakar Lakhera and
with me I have my colleague


5
00:00:40,406 --> 00:00:41,036
Stuart Cheshire.


6
00:00:42,746 --> 00:00:44,896
And this session
is in two parts.


7
00:00:44,896 --> 00:00:49,936
For the first topic I
will talk about IPv6,


8
00:00:50,436 --> 00:00:53,556
and for the second topic
Stuart will talk about how


9
00:00:53,556 --> 00:00:55,866
to make your applications
run faster.


10
00:00:57,476 --> 00:01:02,586
We will start off
with IPv6 first.


11
00:01:02,776 --> 00:01:04,426
Now, what's new in IPv6?


12
00:01:05,796 --> 00:01:09,826
IPv6 RFC was published
almost 17 years back.


13
00:01:11,086 --> 00:01:15,836
So you must be wondering, why
are we talking about IPv6 now?


14
00:01:17,596 --> 00:01:23,236
We are seeing more and more of
IPv6 deployment in enterprise


15
00:01:23,366 --> 00:01:25,196
and cellular networks.


16
00:01:26,056 --> 00:01:27,806
And you want to make sure


17
00:01:27,866 --> 00:01:30,986
that your applications
work in those networks.


18
00:01:31,286 --> 00:01:36,776
That is the reason we will also
be mandating your applications


19
00:01:36,776 --> 00:01:38,206
to be IPv6 compliant.


20
00:01:38,876 --> 00:01:41,896
Now, we will talk more about
that and what it means to you


21
00:01:41,896 --> 00:01:44,376
as developers, but
before we do that,


22
00:01:44,966 --> 00:01:46,936
let's begin with
a bit of history.


23
00:01:47,436 --> 00:01:53,386
Now, a long, long time ago,
client devices had real


24
00:01:53,446 --> 00:01:57,946
and unique IPv4 addresses;
these were the good olden days


25
00:01:57,946 --> 00:02:00,226
and you had end-to-end
network connectivity.


26
00:02:01,536 --> 00:02:04,056
However, we soon realized
that we were running


27
00:02:04,056 --> 00:02:06,406
out of IPv4 addresses
way too fast.


28
00:02:07,276 --> 00:02:09,496
So we added a NAT in the middle.


29
00:02:10,946 --> 00:02:15,226
Now, this works, but the
larger scale NAT device is both


30
00:02:15,226 --> 00:02:17,146
expensive and fragile.


31
00:02:18,606 --> 00:02:21,796
So carriers are now deploying
IPv6 in their network.


32
00:02:21,796 --> 00:02:29,266
Now, with this, they again have
end-to-end network connectivity


33
00:02:29,326 --> 00:02:33,236
and there's no translation
needed in the data path.


34
00:02:33,406 --> 00:02:35,976
I will now show you how
IPv6 deployment looks


35
00:02:36,276 --> 00:02:39,236
for three major cellular
carriers in the USA.


36
00:02:39,636 --> 00:02:43,546
Now, two things are
obvious here.


37
00:02:44,266 --> 00:02:47,826
One, all the lines are going up.


38
00:02:48,436 --> 00:02:51,296
And second, more than half


39
00:02:51,296 --> 00:02:53,246
of the subscribers
are now connecting


40
00:02:53,246 --> 00:02:55,756
to cellular data
networks over IPv6.


41
00:02:57,116 --> 00:02:58,376
So that's great, right?


42
00:02:59,316 --> 00:03:01,206
Turns out it's actually worse


43
00:03:01,206 --> 00:03:03,336
for cellular carriers
than it was before.


44
00:03:04,286 --> 00:03:09,636
And the reason is now they are
having to support both IPv4


45
00:03:10,036 --> 00:03:12,156
as well as IPv6 in
their network.


46
00:03:13,416 --> 00:03:16,816
So what they really want
to do is to drop IPv4


47
00:03:17,116 --> 00:03:18,286
from their access network.


48
00:03:19,246 --> 00:03:21,726
Now, when you do that,
you lose connectivity


49
00:03:21,726 --> 00:03:23,896
to the IPv4-only
part of the Internet,


50
00:03:24,376 --> 00:03:25,616
which is still in majority.


51
00:03:27,676 --> 00:03:31,806
So now they have deployed DNS64
and NAT64 in their network,


52
00:03:32,306 --> 00:03:35,246
and the way it works
is when the application


53
00:03:35,246 --> 00:03:37,906
on the client device
makes a hostname query


54
00:03:38,206 --> 00:03:41,836
to get the IPv6 address
for an IPv4-only server,


55
00:03:42,616 --> 00:03:47,186
DNS64 and the network
synthesizes an IPv6 address


56
00:03:47,186 --> 00:03:48,826
and gives it back to
the client device.


57
00:03:49,106 --> 00:03:53,956
Now that the client device has
this IPv6 address to work with,


58
00:03:54,236 --> 00:03:56,316
it can start writing
traffic to the network.


59
00:03:57,636 --> 00:03:59,986
The network itself is
configured in a way


60
00:04:00,046 --> 00:04:03,696
that search packets get
shorted to the NAT64 engine,


61
00:04:04,226 --> 00:04:08,376
which then translates
IPv6 traffic to IPv4


62
00:04:08,646 --> 00:04:09,906
and vice versa on the way back.


63
00:04:10,436 --> 00:04:14,366
Now, the important
thing to note here is


64
00:04:14,366 --> 00:04:17,676
that to the applications
running on the client device,


65
00:04:18,546 --> 00:04:23,716
your IPv4-only server looks
like an IPv6-only server.


66
00:04:24,556 --> 00:04:27,396
And this is important
because till now,


67
00:04:27,396 --> 00:04:29,076
some of you in the room
may have been thinking


68
00:04:29,076 --> 00:04:32,466
that my server is only
configured for IPv4,


69
00:04:32,786 --> 00:04:34,336
so I do not need to test


70
00:04:34,336 --> 00:04:37,596
for a client accessing
it over an IPv6 network.


71
00:04:39,046 --> 00:04:40,746
Your assumption just got broken.


72
00:04:41,246 --> 00:04:43,626
Now the transition to this type


73
00:04:43,626 --> 00:04:46,756
of network will happen very
soon, and when it happens,


74
00:04:47,756 --> 00:04:50,606
we want it to be an
absolutely seamless experience


75
00:04:50,606 --> 00:04:51,336
for our consumers.


76
00:04:52,286 --> 00:04:58,896
And that is the reason your
app has to be IPv6 compliant,


77
00:05:00,206 --> 00:05:02,686
and this will be an app
submission requirement.


78
00:05:04,176 --> 00:05:06,506
So great, we have a new app
submission requirement, right?


79
00:05:06,506 --> 00:05:09,686
And you must be wondering
how do I test my application


80
00:05:09,686 --> 00:05:10,356
for this network?


81
00:05:11,016 --> 00:05:13,296
Where will I find this
NAT64 type of network?


82
00:05:14,336 --> 00:05:16,686
I have a great news
for all of you.


83
00:05:18,776 --> 00:05:22,736
Starting today, with just
your Mac devices on top


84
00:05:22,736 --> 00:05:27,066
of IPv4 connectivity, you can
create your very own NAT64


85
00:05:27,066 --> 00:05:29,576
networks and start
testing your applications.


86
00:05:29,786 --> 00:05:33,566
Now, this feature is meant
to be used by the developers,


87
00:05:33,776 --> 00:05:37,396
so it's somewhat hidden, and to
make it visible, all you have


88
00:05:37,396 --> 00:05:44,366
to do is to Option-click on
Sharing, then Option-click


89
00:05:44,366 --> 00:05:48,006
on Internet Sharing, and now you
will see everything looks just


90
00:05:48,006 --> 00:05:48,536
the same.


91
00:05:49,446 --> 00:05:51,436
But there's a new
checkbox here that says


92
00:05:51,846 --> 00:05:53,616
"Create NAT64 Network."


93
00:05:53,616 --> 00:05:58,206
So you check that, you
choose your interfaces


94
00:05:58,206 --> 00:06:02,146
for Internet sharing, and now
you can host this NAT64 network


95
00:06:03,236 --> 00:06:04,886
and start testing
your applications.


96
00:06:05,776 --> 00:06:09,936
Now, for the example here,
I have my IPv4 connectivity


97
00:06:10,066 --> 00:06:12,436
on the Internet and
I'm sharing this


98
00:06:12,436 --> 00:06:17,566
as an IPv6-only access
network with NAT64/DNS64


99
00:06:17,676 --> 00:06:18,766
on my Wi-Fi interface.


100
00:06:19,826 --> 00:06:25,286
So when I start it, I see that
the Wi-Fi icon has grayed out


101
00:06:25,286 --> 00:06:27,806
and it has an arrow pointing up.


102
00:06:29,056 --> 00:06:31,796
That means now the
Wi-Fi interface is


103
00:06:31,796 --> 00:06:33,836
in access point mode.


104
00:06:34,536 --> 00:06:37,916
What that really means is now
it's hosting a Wi-Fi hotspot,


105
00:06:37,916 --> 00:06:40,056
and you can connect your
other client devices


106
00:06:40,206 --> 00:06:41,606
and start testing
your applications.


107
00:06:42,486 --> 00:06:46,456
Now, a typical test bed
will look like this.


108
00:06:46,676 --> 00:06:49,856
Now, here I have my IPv4
Internet connectivity


109
00:06:50,066 --> 00:06:54,136
on the WAN side, my iMac has
the DNS64/NAT64 engine running


110
00:06:54,136 --> 00:06:58,836
on it, and it is hosting an IPv6
network on the Wi-Fi interface.


111
00:07:00,096 --> 00:07:03,246
Now the application that you
want to test is either installed


112
00:07:03,246 --> 00:07:04,666
in one of the client machines,


113
00:07:05,196 --> 00:07:07,076
or you could very
well be testing it


114
00:07:07,076 --> 00:07:08,726
on a simulator that's running


115
00:07:08,726 --> 00:07:11,236
on another Mac device
that's a client


116
00:07:11,236 --> 00:07:12,776
of this Internet
sharing environment.


117
00:07:13,196 --> 00:07:18,516
So now that we have made testing
easy for you, for this type


118
00:07:18,516 --> 00:07:21,816
of network, what we
really want you to do is


119
00:07:21,856 --> 00:07:25,356
to make sure it is part of
your development process.


120
00:07:26,166 --> 00:07:28,826
That is, any time you are
writing a new application,


121
00:07:29,126 --> 00:07:31,396
or you are writing an
update for your application,


122
00:07:31,786 --> 00:07:33,126
make sure you are testing


123
00:07:33,126 --> 00:07:36,906
for NAT64 network
environment before you submit


124
00:07:36,906 --> 00:07:37,686
your applications.


125
00:07:37,976 --> 00:07:44,036
Now, the good news is for
almost 70% of you, you will see


126
00:07:44,036 --> 00:07:46,496
that your applications
are working just fine.


127
00:07:46,776 --> 00:07:47,956
And that's great, right?


128
00:07:48,736 --> 00:07:50,436
Just keep testing
your applications,


129
00:07:50,726 --> 00:07:54,066
release after release and make
sure there's no regression.


130
00:07:54,616 --> 00:07:58,576
But for almost a third
of you, you will see


131
00:07:58,576 --> 00:08:01,846
that either your application
is severely limited


132
00:08:01,846 --> 00:08:05,746
in a NAT64 network environment
or it does not work at all.


133
00:08:07,206 --> 00:08:09,966
Now, fortunately, most of
the issues are simple to fix,


134
00:08:10,716 --> 00:08:18,746
and here's a sample list.


135
00:08:18,926 --> 00:08:23,346
Now, if you are using only
IPv4-only data structures


136
00:08:23,346 --> 00:08:28,196
or IPv4-only APIs, or
you are using an API


137
00:08:28,196 --> 00:08:30,706
that supports both
IPv4 and IPv6,


138
00:08:31,346 --> 00:08:34,416
but maybe you're passing
an argument that says


139
00:08:34,885 --> 00:08:38,586
that only get me
results for IPv4,


140
00:08:38,586 --> 00:08:43,655
all of these things will make
your application IPv4 only.


141
00:08:44,216 --> 00:08:46,486
And what that means
is it will not work


142
00:08:46,486 --> 00:08:48,906
in an IPv6-only access
network environment.


143
00:08:49,426 --> 00:08:53,496
Now, there's another interesting
thing that we have seen


144
00:08:53,496 --> 00:08:56,256
with some of these
applications that do not work,


145
00:08:57,786 --> 00:09:00,216
that sometimes there's a
preflight check that checks


146
00:09:00,216 --> 00:09:03,886
for IPv4 connectivity even
before attempting a connection.


147
00:09:05,046 --> 00:09:09,566
And that is the reason sometimes
you get errors like this.


148
00:09:10,516 --> 00:09:14,716
So in this case, my iPhone
was actually connected


149
00:09:14,716 --> 00:09:17,736
to the NAT64 network I had
just created on my Mac device,


150
00:09:18,476 --> 00:09:20,726
and I could browse
Internet with Safari,


151
00:09:20,726 --> 00:09:22,856
I could stream videos, music...


152
00:09:23,666 --> 00:09:25,226
I had my Internet connectivity,


153
00:09:25,666 --> 00:09:29,156
but for some reason this
application thinks I have no


154
00:09:29,156 --> 00:09:30,576
Internet connectivity
whatsoever.


155
00:09:31,296 --> 00:09:34,366
And if you read the
error message it says


156
00:09:34,366 --> 00:09:37,886
that my device is in
airplane mode, but if you look


157
00:09:37,886 --> 00:09:40,636
at the top bar, that's
not the case, right?


158
00:09:42,066 --> 00:09:43,956
So what's going on here?


159
00:09:44,416 --> 00:09:47,346
It's precisely the application
making a preflight check


160
00:09:47,376 --> 00:09:50,816
to check for IPv4 connectivity,
and if you remember,


161
00:09:51,276 --> 00:09:54,426
in IPv6-only access
network like NAT64 network,


162
00:09:55,066 --> 00:09:57,596
you do not have IPv4
connectivity;


163
00:09:57,656 --> 00:10:01,156
the entire world looks like
an IPv6-only world to you.


164
00:10:01,546 --> 00:10:05,286
Even the IPv4-only server
looks like an IPv6-only server.


165
00:10:05,666 --> 00:10:07,446
So if you do this
check, it will fail.


166
00:10:08,386 --> 00:10:11,056
Now, in this case,
application is saying retry.


167
00:10:11,056 --> 00:10:14,006
So I retried and it gave
me the same error message,


168
00:10:14,366 --> 00:10:16,606
and then I retried again,
and the same error message.


169
00:10:17,236 --> 00:10:19,406
And it never went off,
and I was just stuck


170
00:10:19,406 --> 00:10:20,296
with this application.


171
00:10:21,226 --> 00:10:22,836
So, what are the
recommendations?


172
00:10:23,226 --> 00:10:26,596
Well, just attempt a connection.


173
00:10:27,966 --> 00:10:30,156
Right? If it connects,
that's great.


174
00:10:30,156 --> 00:10:33,416
If it does not, then
handle that case gracefully.


175
00:10:34,656 --> 00:10:36,606
The second recommendation
would be


176
00:10:36,606 --> 00:10:40,466
to use higher networking
frameworks like NSURLSession


177
00:10:41,036 --> 00:10:47,076
or CFNetwork API, and
the reason is networking


178
00:10:48,016 --> 00:10:50,456
with multihome devices
like iPhone


179
00:10:51,346 --> 00:10:54,456
and Mac devices can
be somewhat complex.


180
00:10:54,956 --> 00:10:57,836
Like for iPhone, you
have Wi-Fi interface


181
00:10:57,836 --> 00:10:59,396
and you have cellular interface.


182
00:10:59,586 --> 00:11:02,176
And with Mac devices, you
may have multiple Ethernet


183
00:11:02,176 --> 00:11:04,726
interfaces, and you have
a Wi-Fi interface also,


184
00:11:05,186 --> 00:11:07,466
and at a given time, you
may have different kinds


185
00:11:07,466 --> 00:11:09,886
of connectivity to
all these interfaces.


186
00:11:11,366 --> 00:11:16,126
Now, which interface you use
and how to connect which type


187
00:11:16,126 --> 00:11:18,326
of connectivity do you use
for a given destination,


188
00:11:18,886 --> 00:11:22,096
writing that code yourself
can be a lot tedious.


189
00:11:22,726 --> 00:11:25,566
So please use higher
networking frameworks.


190
00:11:25,896 --> 00:11:29,276
It will make your application
code a lot cleaner and simpler.


191
00:11:29,276 --> 00:11:34,426
Now if for some reason you
cannot use a higher networking


192
00:11:34,426 --> 00:11:37,186
framework and if you are
having to work with sockets,


193
00:11:37,346 --> 00:11:42,786
we will definitely recommend you
to read RFC 4038, and it talks


194
00:11:42,786 --> 00:11:45,776
about in great length how
to write your applications


195
00:11:46,026 --> 00:11:47,916
in a way that's address-family
agnostic.


196
00:11:50,296 --> 00:11:54,366
Now, our final recommendation
would be to use hostnames


197
00:11:54,366 --> 00:11:57,106
when possible and not to
use IP address literals,


198
00:11:57,286 --> 00:11:58,676
whether IPv4 or IPv6.


199
00:11:58,676 --> 00:12:02,266
When you are writing
your very own protocol,


200
00:12:02,266 --> 00:12:04,506
a proprietary protocol, or
when you are writing your


201
00:12:04,506 --> 00:12:08,156
application, make sure you are
not using IP address literals


202
00:12:08,556 --> 00:12:09,746
but preferring hostnames.


203
00:12:10,216 --> 00:12:11,626
And the reason is, remember,


204
00:12:11,986 --> 00:12:14,376
in a NAT64/DNS64
network environment,


205
00:12:15,466 --> 00:12:18,106
the client device first has
to make a DNS query, right?


206
00:12:18,406 --> 00:12:20,526
To get the IPv6 address
for the IPv4 server.


207
00:12:20,656 --> 00:12:22,936
So you have to work
with the hostname.


208
00:12:23,246 --> 00:12:25,526
If you are working with
an IPv4 address literal,


209
00:12:26,116 --> 00:12:28,426
the client device will
not make that DNS query,


210
00:12:28,726 --> 00:12:32,546
and the DNS64 network will not
synthesize the IPv6 address


211
00:12:32,546 --> 00:12:32,856
for you.


212
00:12:33,416 --> 00:12:39,266
So, given that, we do understand
that sometimes there's no way


213
00:12:39,266 --> 00:12:44,416
to avoid working with an
IPv4 address, and an example


214
00:12:44,416 --> 00:12:45,506
of that would be Safari.


215
00:12:46,096 --> 00:12:48,676
So you go to a web page,
it loads up just fine.


216
00:12:49,266 --> 00:12:52,356
But within the web page,
there may be some other links,


217
00:12:52,906 --> 00:12:57,326
and some of those links may
have IPv4 addresses embedded.


218
00:12:59,166 --> 00:13:02,276
Now, before today, on
Safari if you clicked on one


219
00:13:02,276 --> 00:13:04,726
such link, it would not load up.


220
00:13:05,696 --> 00:13:13,236
Starting iOS 9 and OS X 10.11,
not only Safari but any user


221
00:13:13,236 --> 00:13:18,956
of NSURLSession or CFNetwork
API will be able to work even


222
00:13:18,956 --> 00:13:23,266
with IPv4 address literals
in a NAT64/DNS64 network.


223
00:13:24,596 --> 00:13:26,746
The way it works is when
you are using hostnames,


224
00:13:27,536 --> 00:13:30,816
the DNS64 in the network is
synthesizing IPv6 addresses


225
00:13:30,816 --> 00:13:31,396
for you.


226
00:13:32,546 --> 00:13:35,866
But when you are working
with an IPv4 address literal


227
00:13:35,866 --> 00:13:38,126
and using one of the
higher networking API,


228
00:13:39,016 --> 00:13:42,826
the OS is discovering what
the network would have done


229
00:13:42,896 --> 00:13:45,526
and how it would have
synthesized an IPv6 address


230
00:13:45,526 --> 00:13:47,696
for you, and it will
do that locally.


231
00:13:48,276 --> 00:13:51,586
So this is another reason
why you should be working


232
00:13:51,586 --> 00:13:53,016
with higher network frameworks.


233
00:13:53,016 --> 00:13:56,446
So please do that.


234
00:13:56,656 --> 00:14:00,936
Now, with these data points
and with the new tool,


235
00:14:01,276 --> 00:14:04,396
we really hope that you will
be able to find and fix issues


236
00:14:04,396 --> 00:14:05,496
with your applications.


237
00:14:07,406 --> 00:14:12,036
Now, what we want you to do
is after this session is over,


238
00:14:12,426 --> 00:14:14,826
install the seed build
on your Mac devices


239
00:14:15,226 --> 00:14:17,916
and start creating your
very own NAT64 networks,


240
00:14:18,156 --> 00:14:20,306
and then use them to
test your applications.


241
00:14:21,496 --> 00:14:24,786
Now, remember this will be an
app submission requirement.


242
00:14:25,716 --> 00:14:29,246
So please take this message to
other developers who are not


243
00:14:29,246 --> 00:14:31,676
in this session and also
take this message back


244
00:14:31,676 --> 00:14:34,696
to your company and make sure
you are doing NAT64 testing


245
00:14:35,016 --> 00:14:35,896
for your applications.


246
00:14:36,336 --> 00:14:43,036
Now, with that, I now invite
Stuart Cheshire to talk


247
00:14:43,036 --> 00:14:45,346
about other networking
features we have for you


248
00:14:45,746 --> 00:14:48,106
that make your applications
faster


249
00:14:48,446 --> 00:14:50,486
and be more responsive
to the users.


250
00:14:51,256 --> 00:14:51,856
Stuart?


251
00:14:52,516 --> 00:14:58,636
[Applause]


252
00:14:59,136 --> 00:14:59,916
>> STUART CHESHIRE:
Thank you, Prabhakar.


253
00:15:02,546 --> 00:15:06,406
What I want to talk about now
is making your applications


254
00:15:06,406 --> 00:15:07,076
run faster.


255
00:15:09,116 --> 00:15:10,536
In the last couple of decades,


256
00:15:10,606 --> 00:15:14,076
we have seen a phenomenal
increase in network throughput.


257
00:15:15,036 --> 00:15:19,056
I remember a time when the
56-kilobit modem was the latest


258
00:15:19,056 --> 00:15:21,366
technology; now we
live in a world


259
00:15:21,366 --> 00:15:24,676
where 50 megabits per
second is quite commonplace.


260
00:15:25,596 --> 00:15:27,776
But things don't feel a
thousand times faster.


261
00:15:28,616 --> 00:15:31,056
We still spend a lot
of time sitting waiting


262
00:15:31,056 --> 00:15:32,136
for a web page to load.


263
00:15:32,426 --> 00:15:33,146
And why is that?


264
00:15:34,716 --> 00:15:38,296
It's because our industry
has put a huge focus


265
00:15:38,396 --> 00:15:39,956
on increasing throughput


266
00:15:41,166 --> 00:15:44,986
and it has sorely neglected
the other sources of delay.


267
00:15:46,156 --> 00:15:48,016
The speed of light
hasn't gotten any faster


268
00:15:48,916 --> 00:15:52,006
and we can't do anything about
that, but there are other areas


269
00:15:52,006 --> 00:15:54,286
of delay that we can
fix and it's time


270
00:15:54,286 --> 00:15:55,346
for us to start doing that.


271
00:15:56,176 --> 00:15:58,486
So that's what I'm going
to talk about today.


272
00:15:59,316 --> 00:16:03,286
I'm going to talk about
four sources of delay


273
00:16:03,906 --> 00:16:05,806
when users are using
your applications.


274
00:16:06,976 --> 00:16:09,776
The first one is the
delay that happens


275
00:16:10,056 --> 00:16:12,936
when you have weak
Wi-Fi connectivity,


276
00:16:13,306 --> 00:16:14,986
and connection attempts
are not succeeding.


277
00:16:15,976 --> 00:16:19,896
The second area is a technique
called Explicit Congestion


278
00:16:19,896 --> 00:16:21,936
Notification, which along


279
00:16:21,936 --> 00:16:25,916
with smart queuing reduces
delays in the network.


280
00:16:27,036 --> 00:16:32,096
The TCP NOTSENT Low-Water
Mark option reduces delays


281
00:16:32,516 --> 00:16:35,556
in the sending machine, and
then we are going to finish


282
00:16:35,556 --> 00:16:36,976
up with a sneak peek


283
00:16:37,096 --> 00:16:39,916
of an exciting new technology
called TCP Fast Open.


284
00:16:40,746 --> 00:16:44,226
So let's start off with
reliable network fallback.


285
00:16:45,406 --> 00:16:48,706
I'm sure everybody in this
room has had the experience


286
00:16:48,986 --> 00:16:52,276
at the end of the
day: They leave work.


287
00:16:52,576 --> 00:16:53,976
They go out to their car.


288
00:16:54,096 --> 00:16:55,046
They pull out their phone.


289
00:16:55,736 --> 00:17:01,856
You want to check maps, weather
forecast, email, whatever,


290
00:17:02,046 --> 00:17:04,496
and you are staring at the
phone and it's not loading


291
00:17:04,576 --> 00:17:06,695
and it's not loading and
you are walking to your car,


292
00:17:06,695 --> 00:17:08,786
and it's still not loading
and you get frustrated,


293
00:17:08,786 --> 00:17:11,356
you go into Settings,
you turn Wi-Fi off.


294
00:17:11,556 --> 00:17:12,756
Now you're on LTE and bam!


295
00:17:12,756 --> 00:17:13,846
The page loads.


296
00:17:15,076 --> 00:17:17,165
And then you forget
to turn Wi-Fi back on,


297
00:17:17,165 --> 00:17:19,536
and a week later you've got
a huge cellular data bill


298
00:17:19,536 --> 00:17:20,205
that you didn't want.


299
00:17:20,386 --> 00:17:22,715
Well, that's not a
good user experience.


300
00:17:23,366 --> 00:17:28,156
What we are doing now is we
have some intelligent logic


301
00:17:28,465 --> 00:17:30,166
about doing parallel
connections.


302
00:17:31,016 --> 00:17:33,346
So if your iPhone
thinks it's on Wi-Fi,


303
00:17:34,806 --> 00:17:38,326
but the TCP connection setup
attempt is not succeeding,


304
00:17:38,906 --> 00:17:44,636
then very rapidly, it will
initiate a second parallel


305
00:17:44,666 --> 00:17:47,356
connection over cellular data.


306
00:17:47,426 --> 00:17:49,996
Now, it won't kill
the Wi-Fi connection.


307
00:17:49,996 --> 00:17:50,976
It won't give up on it.


308
00:17:50,976 --> 00:17:54,186
It will let that one continue
to run in parallel and if


309
00:17:54,186 --> 00:17:56,496
that one completes
first, that's great.


310
00:17:56,706 --> 00:17:58,126
You have a connection
over Wi-Fi.


311
00:17:58,126 --> 00:18:02,396
But if it doesn't, and the
cellular connection completes


312
00:18:02,396 --> 00:18:05,536
first, then that's the
connection your application will


313
00:18:05,536 --> 00:18:10,186
get with a delay so short, the
user won't notice anything odd.


314
00:18:10,186 --> 00:18:13,636
Of course, we only
use this for apps


315
00:18:13,676 --> 00:18:15,456
that are allowed to
use cellular data.


316
00:18:15,966 --> 00:18:17,676
If the user has gone
into the settings


317
00:18:17,676 --> 00:18:19,796
and turned off mobile
data for that app,


318
00:18:19,846 --> 00:18:20,886
we won't do the fallback.


319
00:18:22,056 --> 00:18:25,166
And if we do fall back, then
we hide the Wi-Fi indicator,


320
00:18:25,606 --> 00:18:28,506
so now the user knows they
are not on Wi-Fi anymore.


321
00:18:29,026 --> 00:18:32,936
This is something
that you get for free,


322
00:18:33,346 --> 00:18:36,636
as long as you are using
the higher layer APIs,


323
00:18:37,306 --> 00:18:40,966
and you should see no difference
in your applications apart


324
00:18:40,966 --> 00:18:42,646
from a better user experience.


325
00:18:44,016 --> 00:18:45,896
There's one additional
thing you can do,


326
00:18:46,816 --> 00:18:50,616
and that is when you are
running over cellular,


327
00:18:52,106 --> 00:18:54,686
whether you started on cellular
or whether you fell back


328
00:18:54,686 --> 00:18:56,356
to cellular, doesn't matter.


329
00:18:56,356 --> 00:19:01,056
The user can walk back in range
of Wi-Fi and at that point,


330
00:19:01,286 --> 00:19:04,046
if you pay attention to the
Better Route notification,


331
00:19:04,626 --> 00:19:06,676
you can then decide
what to do about that.


332
00:19:07,356 --> 00:19:09,976
You may want to tear down
the connections you have


333
00:19:09,976 --> 00:19:15,066
and reconnect over Wi-Fi,
or if you are 99% of the way


334
00:19:15,116 --> 00:19:17,436
through sending an email,
you may want to just let


335
00:19:17,436 --> 00:19:19,636
that complete, but
by paying attention


336
00:19:19,636 --> 00:19:21,176
to the Better Route
notification,


337
00:19:21,466 --> 00:19:23,116
you can make an intelligent
decision


338
00:19:23,426 --> 00:19:26,336
that minimizes the
user's cellular data bill.


339
00:19:27,316 --> 00:19:33,476
My next topic is
delays in the network.


340
00:19:35,006 --> 00:19:39,646
And this is something that came
out of work I did on Apple TV.


341
00:19:39,646 --> 00:19:43,376
We are working on trying to
make Apple TV more responsive


342
00:19:43,726 --> 00:19:45,676
and understanding where
the delays came from.


343
00:19:46,406 --> 00:19:49,196
And I expect everybody
in this room has heard


344
00:19:49,196 --> 00:19:50,226
about bufferbloat.


345
00:19:51,376 --> 00:19:54,756
I did some experiments, and
I want to share the results


346
00:19:54,756 --> 00:19:56,116
of those experiments with you


347
00:19:56,406 --> 00:20:00,366
so you can understand too how
critically important it is


348
00:20:00,366 --> 00:20:02,316
for all of our applications
and products


349
00:20:02,626 --> 00:20:04,356
that we fix bufferbloat
in the network.


350
00:20:05,696 --> 00:20:09,206
I tested a simulated
network environment


351
00:20:09,676 --> 00:20:14,516
with a 10-megabit downstream
connection, which is plenty


352
00:20:14,516 --> 00:20:18,506
for watching streaming
video, and first I'm going


353
00:20:18,506 --> 00:20:24,656
to show you the results using
a representative network setup,


354
00:20:25,186 --> 00:20:28,046
a simpleminded first-in,
first-out queue


355
00:20:28,416 --> 00:20:30,586
where packets are buffered
until the queue is full


356
00:20:30,586 --> 00:20:34,236
and can't hold anymore, and then
the new arrivals get dropped.


357
00:20:35,016 --> 00:20:38,416
This is very typical of
consumer home gateways today.


358
00:20:38,446 --> 00:20:42,326
And then I will show you a
comparison using smarter queuing


359
00:20:42,326 --> 00:20:42,866
and ECN.


360
00:20:44,536 --> 00:20:48,086
I'm going to show you some
plots generated using tcptrace.


361
00:20:49,026 --> 00:20:52,486
I expect many people in this
room have used tcptrace,


362
00:20:52,826 --> 00:20:56,346
but if you haven't, I
strongly urge you to go


363
00:20:56,346 --> 00:20:58,896
to TCPtrace.org and download it.


364
00:20:59,786 --> 00:21:02,846
If you are working
on networking code,


365
00:21:03,366 --> 00:21:06,226
and you are not using tcptrace
to look at your packets,


366
00:21:06,566 --> 00:21:10,676
then you have no way to
really know what is going on


367
00:21:10,916 --> 00:21:13,116
or understand the
performance characteristics


368
00:21:13,326 --> 00:21:15,376
of your app and your protocol.


369
00:21:16,086 --> 00:21:19,766
When we write apps, we pay
attention to the memory usage.


370
00:21:20,496 --> 00:21:24,196
We profile the code to find
out what's taking the CPU


371
00:21:24,616 --> 00:21:26,586
and then we optimize
the code that needs it


372
00:21:26,726 --> 00:21:29,746
to improve CPU efficiency
and improve battery life.


373
00:21:31,176 --> 00:21:36,246
To do those things, to care
that much about CPU and memory,


374
00:21:36,756 --> 00:21:39,756
but neglect the networking
part doesn't make any sense.


375
00:21:39,886 --> 00:21:43,596
And tcptrace is the tool
that lets you do similar kind


376
00:21:43,596 --> 00:21:45,936
of profiling and analysis
of your network traffic.


377
00:21:45,936 --> 00:21:51,836
Here's a TCP trace of
the first 10 seconds


378
00:21:52,126 --> 00:21:53,496
of some streaming video.


379
00:21:53,956 --> 00:21:56,246
For those of you who haven't
looked at tcptrace before,


380
00:21:56,246 --> 00:21:58,256
I will give a quick overview.


381
00:21:58,966 --> 00:22:01,766
The little white lines
represent data packets.


382
00:22:02,816 --> 00:22:07,396
The horizontal position of that
white line tells you the moment


383
00:22:07,396 --> 00:22:08,926
in time where the
packet was captured.


384
00:22:10,016 --> 00:22:15,076
The height of the white line
tells you how many bytes


385
00:22:15,076 --> 00:22:18,346
of payload are in the packets,
and the vertical position


386
00:22:18,346 --> 00:22:21,816
of where that line appears
tells you where those bytes fall


387
00:22:22,186 --> 00:22:25,936
within the overall logical
TCP sequence number space.


388
00:22:26,996 --> 00:22:30,256
So here we can see a stream of
packets being sent out in order,


389
00:22:30,966 --> 00:22:33,276
spaced a few microseconds apart.


390
00:22:34,656 --> 00:22:37,426
One round trip later, we
get the acknowledgment back


391
00:22:37,426 --> 00:22:39,166
from the receiver
saying it was received.


392
00:22:40,346 --> 00:22:44,036
And that green line is the
cumulative acknowledgment line.


393
00:22:44,496 --> 00:22:47,516
Everything up to and including
the green line has been


394
00:22:47,516 --> 00:22:48,806
acknowledged by the receiver.


395
00:22:49,626 --> 00:22:53,786
So we should never see any white
packets below the green line.


396
00:22:54,416 --> 00:22:55,556
That would indicate a bug,


397
00:22:56,356 --> 00:22:59,106
and we don't see any white
packets below the line,


398
00:22:59,106 --> 00:22:59,696
so that's good.


399
00:22:59,736 --> 00:23:04,596
The yellow line indicates
the receive window.


400
00:23:05,286 --> 00:23:06,906
When you open up
a TCP connection,


401
00:23:06,906 --> 00:23:10,406
the receiver indicates how
much RAM it has put aside


402
00:23:11,586 --> 00:23:16,526
for your data, and you should
not exceed the amount of RAM


403
00:23:16,526 --> 00:23:17,886
that you have been allocated.


404
00:23:18,546 --> 00:23:22,036
If we see any white packets
above the yellow line,


405
00:23:22,346 --> 00:23:24,156
then that would be
a bug, and we don't.


406
00:23:24,376 --> 00:23:27,046
So that's good.


407
00:23:27,716 --> 00:23:30,906
This looks look a
relatively nice,


408
00:23:30,986 --> 00:23:33,486
straight line data transfer.


409
00:23:33,486 --> 00:23:37,086
The slope of that curve is
exactly 10 megabits per second,


410
00:23:37,816 --> 00:23:41,996
which is what we expect,
but every few seconds,


411
00:23:42,086 --> 00:23:43,706
we see something
like this going on.


412
00:23:44,236 --> 00:23:48,576
So let's zoom in and
take a closer look


413
00:23:48,806 --> 00:23:51,016
at what's going on down there.


414
00:23:52,616 --> 00:23:56,216
There is so much information
on these TCP trace plots,


415
00:23:56,736 --> 00:23:59,636
I could spend an hour just
talking about this one slide.


416
00:23:59,986 --> 00:24:01,686
But we don't have time for that,


417
00:24:02,056 --> 00:24:06,216
so I will just cover some
highlights that jump out just


418
00:24:06,216 --> 00:24:07,786
with a glance at this plot.


419
00:24:09,296 --> 00:24:14,426
One is the white packet
line is kind of pulling away


420
00:24:15,246 --> 00:24:16,986
from the green ack line.


421
00:24:17,726 --> 00:24:20,906
What that means is the rate
that we are injecting data


422
00:24:20,906 --> 00:24:25,696
into the network is faster
than the rate data is coming


423
00:24:25,786 --> 00:24:27,606
out of the other side
and being acknowledged.


424
00:24:28,066 --> 00:24:30,836
Well, if we are putting
it in faster


425
00:24:30,836 --> 00:24:33,976
than we are pulling it
out, something has got


426
00:24:33,976 --> 00:24:34,866
to be going somewhere.


427
00:24:35,396 --> 00:24:40,526
It's sitting in buffers and
we can see that the amount


428
00:24:40,686 --> 00:24:44,606
of stale data sitting in buffers
in the network is growing.


429
00:24:45,246 --> 00:24:47,426
And because the amount
of buffering is growing,


430
00:24:47,856 --> 00:24:51,676
that means the round trip delay
between when a packet is sent


431
00:24:51,756 --> 00:24:54,456
and when it's acknowledged
is getting longer.


432
00:24:55,226 --> 00:24:58,296
When we have so much buffered


433
00:24:58,336 --> 00:25:01,096
that the gateway
can't buffer anymore,


434
00:25:01,316 --> 00:25:02,666
we start losing packets.


435
00:25:03,236 --> 00:25:08,126
And then this mess happens, and
it really is quite a big mess,


436
00:25:08,436 --> 00:25:13,176
because packets are coming into
the tail of the queue faster


437
00:25:13,256 --> 00:25:18,206
than the queue is draining, and
we get a packet, we lose it,


438
00:25:18,726 --> 00:25:20,116
we get another one, we lose it.


439
00:25:20,396 --> 00:25:22,936
The queue drains a bit, we
get a packet, we accept it.


440
00:25:23,486 --> 00:25:27,286
So, at the tail end of
the queue, it's carnage.


441
00:25:27,346 --> 00:25:29,066
It's get a packet,
lose one, lose one,


442
00:25:29,066 --> 00:25:30,676
lose one, get one, lose one.


443
00:25:31,846 --> 00:25:33,226
But over at the front
of the queue,


444
00:25:33,716 --> 00:25:38,046
we've got 200 packets queued up,
in order, they are neatly going


445
00:25:38,046 --> 00:25:40,206
out over that 10-megabit
bottleneck link,


446
00:25:40,326 --> 00:25:42,776
in order, no gaps, no problem.


447
00:25:43,176 --> 00:25:45,936
It's only after that
entire queue has drained


448
00:25:46,396 --> 00:25:48,396
that we actually
witness the results


449
00:25:48,396 --> 00:25:50,876
of that packet loss
carnage at the receiver;


450
00:25:51,796 --> 00:25:54,986
that gets reflected back to the
sender in the selective acks


451
00:25:55,336 --> 00:25:56,616
and the recovery starts.


452
00:25:57,066 --> 00:25:59,766
So this is a big mess.


453
00:26:01,496 --> 00:26:04,246
Because of the way
networking APIs work,


454
00:26:04,856 --> 00:26:06,256
data has to be delivered
in order.


455
00:26:07,626 --> 00:26:10,766
If you lose one packet, then
all the packets that arrive


456
00:26:10,766 --> 00:26:12,786
after it get delayed
in the kernel


457
00:26:13,026 --> 00:26:14,616
until the gap has
been filled in.


458
00:26:15,076 --> 00:26:17,926
Now, there are good
reasons for this.


459
00:26:18,146 --> 00:26:21,126
People have talked many times
about out-of-order delivery,


460
00:26:21,516 --> 00:26:24,346
but it turns out with almost
all applications it's hard


461
00:26:24,346 --> 00:26:25,626
to use data out of order.


462
00:26:25,916 --> 00:26:29,946
If you are trying to decode
H.264 video, having frames


463
00:26:29,946 --> 00:26:33,186
that depend on an I-frame you
don't have is not helpful.


464
00:26:33,546 --> 00:26:37,706
So it turns out that in-order
delivery really is the model


465
00:26:37,736 --> 00:26:38,856
that applications want.


466
00:26:39,416 --> 00:26:42,346
Because of that in-order
delivery,


467
00:26:42,806 --> 00:26:45,396
we get these long plateaus
where no data is delivered.


468
00:26:46,186 --> 00:26:49,536
And for the Apple TV,
video playback process,


469
00:26:50,046 --> 00:26:52,846
that equals a period
of starvation


470
00:26:53,016 --> 00:26:54,166
where it's getting no data.


471
00:26:54,816 --> 00:26:58,096
And because we don't
want the video to freeze,


472
00:26:58,826 --> 00:27:01,586
that's why all streaming
video applications need a


473
00:27:01,586 --> 00:27:02,426
playback buffer.


474
00:27:03,456 --> 00:27:06,626
And having a big
playback buffer is why


475
00:27:06,726 --> 00:27:08,266
when you watch a
streaming video,


476
00:27:08,596 --> 00:27:10,976
you see that spinning wheel
saying buffering, buffering,


477
00:27:10,976 --> 00:27:14,316
buffering, because it has to
fill up the playback buffer


478
00:27:14,416 --> 00:27:18,226
so that it can weather the
storms when no data arrives


479
00:27:18,226 --> 00:27:19,226
for a long period of time.


480
00:27:20,236 --> 00:27:23,286
When the missing packet
arrives, we then fill in the gap


481
00:27:23,486 --> 00:27:24,756
and deliver it all at once.


482
00:27:26,596 --> 00:27:30,886
That puts an excessive burden
on the network receiving thread


483
00:27:31,516 --> 00:27:36,086
which takes away CPU time from
the video playback threads,


484
00:27:36,676 --> 00:27:38,496
and that results
in the stuttering


485
00:27:38,816 --> 00:27:40,436
of the smooth video playback.


486
00:27:40,436 --> 00:27:43,526
So that's bad.


487
00:27:43,736 --> 00:27:48,736
So this uneven delivery in the
network has bad consequences


488
00:27:48,846 --> 00:27:51,026
for a device like Apple
TV; when we are trying


489
00:27:51,026 --> 00:27:54,726
to make a very affordable,
cost-effective device,


490
00:27:55,546 --> 00:27:59,126
these long plateaus
of starvation equate


491
00:27:59,356 --> 00:28:02,556
to needing more RAM in the
device for more buffering


492
00:28:03,206 --> 00:28:07,406
and slower video start-up
and a poor user experience.


493
00:28:08,786 --> 00:28:13,056
And these spikes in delivery
result in needing a faster CPU


494
00:28:13,056 --> 00:28:15,556
in the device than we
otherwise might have needed,


495
00:28:15,816 --> 00:28:16,936
which pushes the price up.


496
00:28:17,416 --> 00:28:24,306
So this uneven delivery is very
damaging for streaming video.


497
00:28:25,666 --> 00:28:27,736
One interesting thing
to note, though:


498
00:28:28,166 --> 00:28:33,966
If you visually track the
slope of the yellow ack line --


499
00:28:34,376 --> 00:28:37,116
the yellow window line
and the green ack line,


500
00:28:37,646 --> 00:28:40,986
you'll see that at the end of
the trace, they pretty much end


501
00:28:40,986 --> 00:28:44,266
up back where they should have
been, if no loss had happened


502
00:28:44,766 --> 00:28:47,546
because TCP does do an
awesome job of filling


503
00:28:47,546 --> 00:28:51,166
in exactly what needs to be
retransmitted, exactly once,


504
00:28:51,706 --> 00:28:53,176
and not retransmitting anything


505
00:28:53,176 --> 00:28:54,726
that didn't need to
be retransmitted.


506
00:28:55,186 --> 00:28:56,926
So it gets back to where
it should have been.


507
00:28:57,916 --> 00:29:00,746
If you measure this
network using Iperf and look


508
00:29:00,746 --> 00:29:01,866
at the number that comes out,


509
00:29:01,866 --> 00:29:04,196
it will tell you 10
megabits per second,


510
00:29:04,556 --> 00:29:07,336
and you will say thumbs up, my
network is working perfectly.


511
00:29:08,416 --> 00:29:11,036
But distilling all
of this information


512
00:29:11,036 --> 00:29:15,406
down to a single figure
loses all the subtlety


513
00:29:15,636 --> 00:29:22,156
of what's really going
on on the network.


514
00:29:22,156 --> 00:29:25,976
So now that I understood
what was going on


515
00:29:25,976 --> 00:29:27,936
and causing the sluggish
performance,


516
00:29:28,666 --> 00:29:30,996
I decided to experiment
with a smarter network.


517
00:29:31,586 --> 00:29:35,136
For this experiment, I used a
smart cueing algorithm called


518
00:29:35,136 --> 00:29:38,056
CoDel, which is short
for Controlled Delay.


519
00:29:39,316 --> 00:29:42,006
The way it works is
instead of filling the queue


520
00:29:42,006 --> 00:29:45,796
until it overflows and loses
data, it monitors the state


521
00:29:45,796 --> 00:29:51,986
of the queue and as soon
as a standing queue starts


522
00:29:51,986 --> 00:29:56,866
to build up, then it considers
that to be a sign of congestion.


523
00:29:57,766 --> 00:30:01,766
And when I say congestion, a
lot of people think I'm talking


524
00:30:01,766 --> 00:30:03,416
about something that
happens rarely


525
00:30:03,416 --> 00:30:05,656
at peak times, and it's not.


526
00:30:05,656 --> 00:30:09,116
It's important to
understand that in networking,


527
00:30:09,626 --> 00:30:12,316
congestion is what
happens all the time.


528
00:30:12,856 --> 00:30:14,516
It's the steady state
of the network.


529
00:30:14,576 --> 00:30:17,336
It's the job of any
transport protocol like TCP


530
00:30:18,096 --> 00:30:20,836
to maximize its use
of the network,


531
00:30:21,306 --> 00:30:23,856
to find out how much
the network can carry


532
00:30:24,336 --> 00:30:26,596
and make the best use of that.


533
00:30:26,596 --> 00:30:28,346
And the way a transport
protocol does


534
00:30:28,346 --> 00:30:33,006
that is it sends data faster
and faster and faster.


535
00:30:33,006 --> 00:30:35,496
It keeps probing and it
keeps trying a bit more,


536
00:30:35,986 --> 00:30:38,006
until it loses a
packet, and then it knows


537
00:30:38,006 --> 00:30:39,586
that was too much
and it backs off.


538
00:30:40,026 --> 00:30:43,346
So it's constantly doing
this hunting to track


539
00:30:43,346 --> 00:30:45,166
to find the right rate and what


540
00:30:45,166 --> 00:30:47,456
that means is it's
always pushing the network


541
00:30:47,456 --> 00:30:49,636
into congestion, and
then backing off,


542
00:30:49,636 --> 00:30:51,606
and then congestion
and backing off.


543
00:30:52,456 --> 00:30:55,996
What CoDel does is not wait
until things have gotten really,


544
00:30:55,996 --> 00:30:58,626
really bad before it
signals congestion.


545
00:30:59,336 --> 00:31:01,976
As soon as the first
sign of it starts


546
00:31:01,976 --> 00:31:05,156
to happen, it tells the sender.


547
00:31:06,156 --> 00:31:09,436
The other thing that I did for
this experiment was instead


548
00:31:09,436 --> 00:31:12,106
of indicating congestion
by losing packets,


549
00:31:12,176 --> 00:31:13,686
which requires a retransmission,


550
00:31:14,266 --> 00:31:16,636
we used a new technology
called Explicit Congestion


551
00:31:16,636 --> 00:31:19,916
Notification, and that way
the smart queuing algorithm,


552
00:31:19,916 --> 00:31:22,496
instead of dropping the
packet, it sets a bit


553
00:31:22,866 --> 00:31:26,206
in the IP header saying
congestion experienced.


554
00:31:26,856 --> 00:31:30,026
That is echoed back to
the sender and it responds


555
00:31:30,026 --> 00:31:33,046
by slowing down without
the destructive effects


556
00:31:33,046 --> 00:31:33,886
of a packet loss.


557
00:31:34,466 --> 00:31:41,926
So this is our graph of the
same data transfer, using CoDel


558
00:31:42,076 --> 00:31:46,176
and ECN, and if I zoom in to
the same part we were looking


559
00:31:46,176 --> 00:31:49,426
at before, you can
see an absolutely


560
00:31:49,516 --> 00:31:50,506
phenomenal difference.


561
00:31:50,956 --> 00:31:52,646
When I was doing
these experiments,


562
00:31:52,946 --> 00:31:56,206
I had planned a week to do
the work and gather the data,


563
00:31:56,916 --> 00:31:59,416
and I was finished
after two hours.


564
00:31:59,746 --> 00:32:02,286
I did one plot with the
standard configuration


565
00:32:02,286 --> 00:32:03,576
and one plot with CoDel.


566
00:32:03,796 --> 00:32:06,766
This is my first experimental
run that I'm showing you.


567
00:32:06,766 --> 00:32:10,076
I was expecting to have to
tweak parameters and retry


568
00:32:10,076 --> 00:32:11,506
and rerun the experiment.


569
00:32:12,156 --> 00:32:16,446
No. This is -- the
difference is that obvious,


570
00:32:16,586 --> 00:32:18,216
that one trial was all it took.


571
00:32:18,976 --> 00:32:19,726
I'm hearing applause.


572
00:32:19,726 --> 00:32:19,976
Thank you.


573
00:32:20,516 --> 00:32:25,866
[Applause]


574
00:32:26,366 --> 00:32:28,946
We have no plateaus
of starvation.


575
00:32:28,986 --> 00:32:31,396
We have no spikes
of peak delivery.


576
00:32:32,056 --> 00:32:35,396
Every time the slightest
hint of a queue builds up,


577
00:32:35,956 --> 00:32:38,086
we get these little
polite nudges


578
00:32:38,086 --> 00:32:40,326
from the CoDel algorithm
saying slow down.


579
00:32:40,806 --> 00:32:44,606
The CWR on that plot is
Congestion Window Reduced.


580
00:32:44,606 --> 00:32:47,026
That's TCP's acknowledgment
saying message received


581
00:32:47,026 --> 00:32:48,836
and understood; I
have slowed down.


582
00:32:49,646 --> 00:32:50,706
Absolutely wonderful!


583
00:32:52,366 --> 00:32:56,136
So, simple summary, CoDel


584
00:32:56,136 --> 00:32:58,516
and other smart cueing
algorithms are great.


585
00:32:58,846 --> 00:32:59,846
ECN are great.


586
00:33:00,626 --> 00:33:02,446
Put them together,
it's totally awesome.


587
00:33:05,506 --> 00:33:07,606
So if it's so great,
where is it?


588
00:33:08,226 --> 00:33:11,826
Well, historically, packet loss


589
00:33:11,826 --> 00:33:14,736
and retransmission has
not caused big problems


590
00:33:14,786 --> 00:33:17,416
for the traditional
networking applications


591
00:33:17,416 --> 00:33:19,166
like file transfer
and sending email.


592
00:33:21,636 --> 00:33:24,896
When you transfer a
file, the transport layer


593
00:33:24,896 --> 00:33:28,336
in principle could send
the first packet last


594
00:33:28,336 --> 00:33:31,156
and the last packet first and
all the ones in the middle


595
00:33:31,156 --> 00:33:33,676
in a random order; as
long as they all get there


596
00:33:33,676 --> 00:33:34,486
and they are reassembled


597
00:33:34,486 --> 00:33:36,176
in the correct order
you have your file,


598
00:33:36,176 --> 00:33:37,306
and that's all you care about.


599
00:33:38,076 --> 00:33:41,966
But when you are watching
streaming video, you don't want


600
00:33:41,966 --> 00:33:45,796
to see the end first,
and the start last.


601
00:33:46,306 --> 00:33:47,506
You want it in order.


602
00:33:47,956 --> 00:33:51,566
So in order delivery has become
a much more pressing problem,


603
00:33:51,566 --> 00:33:54,286
now that we are using the
Internet for streaming video.


604
00:33:57,196 --> 00:33:59,866
One way I characterize
this is that we used


605
00:33:59,866 --> 00:34:03,096
to have applications like
clicking send on an email,


606
00:34:03,726 --> 00:34:06,236
where you have a
predetermined amount of data


607
00:34:07,106 --> 00:34:09,306
and how long it takes
to send it is variable.


608
00:34:10,266 --> 00:34:13,436
Basically, the time you'd
like the network to take


609
00:34:13,436 --> 00:34:16,386
to send your email is
as little as possible.


610
00:34:17,025 --> 00:34:19,176
There's really no such thing
as sending an email too fast.


611
00:34:20,076 --> 00:34:22,106
So the time is variable.


612
00:34:22,106 --> 00:34:23,146
You would like it to be fast.


613
00:34:23,466 --> 00:34:25,196
Now we have applications


614
00:34:25,196 --> 00:34:29,126
where you are watching
a two-hour movie,


615
00:34:29,416 --> 00:34:30,886
streaming over the Internet.


616
00:34:32,186 --> 00:34:35,556
It doesn't help to watch it in
half an hour or in eight hours.


617
00:34:35,755 --> 00:34:37,196
It has to take two hours.


618
00:34:38,045 --> 00:34:40,056
So now we have adaptive
applications


619
00:34:40,056 --> 00:34:42,696
where the time is fixed
but the amount of data


620
00:34:42,696 --> 00:34:45,116
that could be sent in
that time has to adjust


621
00:34:45,226 --> 00:34:47,025
to accommodate the
network conditions.


622
00:34:50,295 --> 00:34:51,386
Where are we now?


623
00:34:52,116 --> 00:34:55,246
Well, amazingly, because
it is in Linux and turned


624
00:34:55,246 --> 00:34:59,556
on by default, more than half
of the top million web servers


625
00:34:59,556 --> 00:35:01,516
in the world already
support ECN,


626
00:35:02,176 --> 00:35:04,546
which is phenomenal adoption


627
00:35:04,546 --> 00:35:05,976
for a technology
that no one is using.


628
00:35:06,516 --> 00:35:09,546
[Laughter]


629
00:35:10,046 --> 00:35:14,786
Clients. Well, the clients are
not asking for ECN connections.


630
00:35:14,786 --> 00:35:18,286
They are not requesting ECN
because pretty much none


631
00:35:18,286 --> 00:35:20,706
of the Internet supports
ECN marking.


632
00:35:21,006 --> 00:35:24,746
So if you turn on that option,
there might be some risk


633
00:35:24,746 --> 00:35:27,646
of exposing bugs and
there's no immediate benefit.


634
00:35:29,626 --> 00:35:30,666
What are the routers doing?


635
00:35:30,776 --> 00:35:33,626
Well, none of the routers are
doing marking because none


636
00:35:33,626 --> 00:35:36,646
of the clients are asking for
it, so why put engineering


637
00:35:36,646 --> 00:35:39,086
into something that might have
risk that no one is asking for?


638
00:35:39,346 --> 00:35:41,736
Well, I'm happy to
announce today


639
00:35:41,736 --> 00:35:43,306
that Apple is taking
the initiative


640
00:35:43,596 --> 00:35:44,746
to break this log jam.


641
00:35:45,226 --> 00:35:50,236
In the seeds that you all have,
ECN is now turned on by default


642
00:35:50,606 --> 00:35:54,976
for all TCP connections
for all applications.


643
00:35:55,516 --> 00:36:01,406
[Applause]


644
00:36:01,906 --> 00:36:05,436
We're not expecting to see
any problems; in our testing,


645
00:36:05,926 --> 00:36:07,226
everything has gone smoothly.


646
00:36:07,696 --> 00:36:10,536
I have been running it on my
own laptop for a long time;


647
00:36:11,676 --> 00:36:14,806
of course, we want to
hear your experience.


648
00:36:14,976 --> 00:36:19,396
Please take the seed builds, run
them on your networks at home,


649
00:36:20,056 --> 00:36:24,506
at work, in your hotel, at
the airport, and as usual,


650
00:36:24,506 --> 00:36:26,636
if you find any bugs,
please report them to Apple.


651
00:36:27,426 --> 00:36:30,346
If we are successful, in a few
months' time we could have a


652
00:36:30,436 --> 00:36:35,156
billion devices running ECN, and
that should be enough incentive


653
00:36:35,156 --> 00:36:37,236
for the ISPs to start
offering that service.


654
00:36:37,806 --> 00:36:43,026
Now we are going to move
on from network delays


655
00:36:43,326 --> 00:36:45,326
to end system delays.


656
00:36:46,316 --> 00:36:50,506
Like many advances in
technology, this was borne


657
00:36:50,506 --> 00:36:53,446
out of a personal
pain point for me.


658
00:36:54,676 --> 00:36:59,336
I use screen sharing to
connect to my Mac at home,


659
00:36:59,916 --> 00:37:01,236
and it's absolutely wonderful.


660
00:37:01,856 --> 00:37:03,526
Being able to control
it remotely,


661
00:37:03,526 --> 00:37:05,346
being able to access data on it,


662
00:37:06,036 --> 00:37:11,556
being able to start a long video
transcode going that I want


663
00:37:11,556 --> 00:37:13,086
to have finished
when I get back home:


664
00:37:13,746 --> 00:37:14,946
these are all wonderful things.


665
00:37:15,996 --> 00:37:18,406
And at the time I was
doing these experiments,


666
00:37:19,896 --> 00:37:23,136
I had a fairly slow DSL line.


667
00:37:24,006 --> 00:37:27,236
And, of course, DSL
is asymmetric.


668
00:37:27,656 --> 00:37:30,596
It's typically ten times faster
in the downstream direction


669
00:37:30,596 --> 00:37:31,906
than the upstream direction,


670
00:37:32,766 --> 00:37:34,766
and when you are doing screen
sharing, the data is coming


671
00:37:35,186 --> 00:37:37,396
in the wrong direction
in that sense.


672
00:37:37,546 --> 00:37:41,716
So it's kind of to be
expected it will be a bit slow.


673
00:37:42,546 --> 00:37:45,066
It's like the famous joke
about the dancing bear:


674
00:37:45,386 --> 00:37:47,346
when you see a dancing
bear, you are not supposed


675
00:37:47,346 --> 00:37:49,196
to be impressed that
it dances well.


676
00:37:49,316 --> 00:37:51,396
You are supposed to be
impressed that it dances at all.


677
00:37:52,186 --> 00:37:58,216
So for many years, like many
of us, I kind of suffered


678
00:37:58,216 --> 00:38:04,626
with this painful, barely usable
experience, and I would find


679
00:38:04,676 --> 00:38:08,306
that when I clicked on a menu,
it took three or four seconds


680
00:38:08,306 --> 00:38:10,786
for the menu to appear,
and after a few minutes


681
00:38:10,786 --> 00:38:14,386
of using the computer this way,
it's really, really frustrating.


682
00:38:14,466 --> 00:38:16,466
There were times it felt
like it would be quicker


683
00:38:16,466 --> 00:38:19,596
to drive home and do it.


684
00:38:19,816 --> 00:38:22,636
And I had been working
on bufferbloat


685
00:38:23,256 --> 00:38:25,596
and excessive queuing
in the network.


686
00:38:25,986 --> 00:38:28,626
So naturally, that was
the first thing I blamed,


687
00:38:29,096 --> 00:38:30,656
and I started digging in.


688
00:38:30,896 --> 00:38:32,396
I started investigating.


689
00:38:32,726 --> 00:38:35,366
I was all ready to be
thoroughly indignant


690
00:38:35,366 --> 00:38:37,896
about this stupid DSL
modem that had all


691
00:38:37,896 --> 00:38:39,526
of this excessive
bufferbloat in it.


692
00:38:40,156 --> 00:38:41,446
And I pinged the machine,


693
00:38:42,176 --> 00:38:44,406
and the ping time
was 35 milliseconds,


694
00:38:45,276 --> 00:38:46,666
but when I click the mouse,


695
00:38:46,666 --> 00:38:48,736
it takes 3 seconds
for a menu to appear.


696
00:38:49,796 --> 00:38:52,986
So now I'm realizing this is
not as obvious as I thought.


697
00:38:53,686 --> 00:38:55,176
Where is the delay coming from?


698
00:38:56,016 --> 00:38:59,136
Well, I did some investigation.


699
00:39:00,626 --> 00:39:04,206
The default socket send buffer
at that time was 120 kilobytes,


700
00:39:04,636 --> 00:39:08,236
my throughput was about
50 kilobytes a second,


701
00:39:08,236 --> 00:39:10,246
so that's about 2.5 seconds,


702
00:39:10,466 --> 00:39:12,106
which was about the
delay I was seeing.


703
00:39:14,046 --> 00:39:17,246
Now, the socket send buffer
serves a very important purpose.


704
00:39:18,496 --> 00:39:21,486
When we use a transport
protocol like TCP,


705
00:39:21,486 --> 00:39:25,706
if it just sent one packet and
waited for the acknowledgment


706
00:39:25,706 --> 00:39:27,816
and one packet and waited
for the acknowledgment,


707
00:39:27,816 --> 00:39:29,516
we would get terrible
performance.


708
00:39:29,906 --> 00:39:32,996
We need multiple packets in
flight; we need enough packets


709
00:39:32,996 --> 00:39:37,106
in flight to fill the bandwidth
delay product of that path


710
00:39:37,766 --> 00:39:40,906
to the destination and
back, and those packets have


711
00:39:40,906 --> 00:39:43,336
to be buffered so
that if they are lost,


712
00:39:43,406 --> 00:39:44,596
they can be retransmitted.


713
00:39:45,076 --> 00:39:47,256
That's all good and
useful and necessary


714
00:39:47,586 --> 00:39:50,296
to maximize the throughput
of that connection.


715
00:39:51,096 --> 00:39:53,486
But any excess buffering


716
00:39:53,486 --> 00:39:57,876
above that requirement just
adds delay for no benefit.


717
00:39:58,056 --> 00:39:59,356
It doesn't help the throughput.


718
00:39:59,856 --> 00:40:00,776
It just adds delay.


719
00:40:01,626 --> 00:40:04,386
And we end up with something
that looks like this.


720
00:40:05,206 --> 00:40:08,756
We have a little bit of data
in flight, which is buffered,


721
00:40:08,976 --> 00:40:10,556
in case it needs to
be retransmitted,


722
00:40:11,206 --> 00:40:15,196
and we have a whole lot, just
sitting in the kernel waiting


723
00:40:15,196 --> 00:40:19,006
for its turn to go out.


724
00:40:19,936 --> 00:40:22,986
Well, this was an
eye-opening revelation for me.


725
00:40:23,536 --> 00:40:25,536
There aren't just
delays in the network.


726
00:40:25,536 --> 00:40:27,766
There are big delays in
the hosts themselves.


727
00:40:29,786 --> 00:40:33,076
Screen sharing would grab a
frame, put it in the buffer,


728
00:40:33,276 --> 00:40:35,416
grab a frame, put it in
the buffer, grab a frame,


729
00:40:35,536 --> 00:40:38,586
put it in the buffer, and then
the kernel would let those


730
00:40:38,586 --> 00:40:42,196
frames mature like a fine
wine before it was time


731
00:40:42,196 --> 00:40:43,406
to put them out on the network.


732
00:40:44,031 --> 00:40:46,031
[Laughter]


733
00:40:46,046 --> 00:40:51,596
Because of that, we came up with
the TCP NOTSENT low-water mark


734
00:40:51,596 --> 00:40:52,296
socket option.


735
00:40:53,116 --> 00:40:54,486
When you send that option,


736
00:40:55,606 --> 00:40:58,636
the socket send buffer
remains unchanged.


737
00:40:59,496 --> 00:41:02,706
The difference is that kevent


738
00:41:03,316 --> 00:41:07,756
or your run loop will not report
the socket as being writable


739
00:41:08,126 --> 00:41:10,646
until the unsent
data has drained


740
00:41:10,646 --> 00:41:13,106
to some fairly low
threshold, typically 8


741
00:41:13,106 --> 00:41:14,806
or 16 kilobytes works well.


742
00:41:15,816 --> 00:41:17,486
When the socket becomes
writable,


743
00:41:18,046 --> 00:41:23,206
you then write a single useful
atomic chunk into the buffer.


744
00:41:23,946 --> 00:41:27,656
You don't loop, cramming as
much data into the kernel


745
00:41:27,656 --> 00:41:29,696
as it can take, because
RAM is cheap these days,


746
00:41:29,696 --> 00:41:30,476
it can take a lot.


747
00:41:31,526 --> 00:41:33,366
You just write a sensible unit.


748
00:41:33,636 --> 00:41:36,356
And in the case of screen
sharing, that's one frame.


749
00:41:37,226 --> 00:41:38,926
And now the picture
looks like this.


750
00:41:40,026 --> 00:41:42,106
We have data in flight,
that's buffered.


751
00:41:42,436 --> 00:41:44,686
We have a little bit waiting
for its turn to go out.


752
00:41:45,726 --> 00:41:48,206
As that drains and
reaches the threshold,


753
00:41:49,136 --> 00:41:50,456
the socket becomes writable.


754
00:41:51,166 --> 00:41:53,176
We write a single chunk and let


755
00:41:53,176 --> 00:41:54,766
that drain before
we write some more.


756
00:41:55,496 --> 00:41:57,436
So with that, I would
like to show you a demo


757
00:41:57,436 --> 00:41:57,976
of this in action.


758
00:42:07,086 --> 00:42:08,506
Here I'm using screen sharing


759
00:42:08,876 --> 00:42:11,496
from this machine,
connecting to this.


760
00:42:12,436 --> 00:42:15,726
I'm using a gateway running
sarawert [assumed spelling]


761
00:42:15,886 --> 00:42:18,376
to simulate a DSL
performance connection.


762
00:42:20,296 --> 00:42:24,976
And let's bring up
a Terminal window.


763
00:42:32,266 --> 00:42:33,086
Okay, there we go.


764
00:42:34,976 --> 00:42:36,656
I'm going to move this window.


765
00:42:37,806 --> 00:42:40,706
You can see the mouse
pointer move


766
00:42:40,946 --> 00:42:42,416
because it's generated locally.


767
00:42:42,826 --> 00:42:45,766
The actual graphical updates are
generated by the remote machine.


768
00:42:46,216 --> 00:42:48,466
So let's move this
window over here.


769
00:42:48,466 --> 00:42:50,316
No, not over here.


770
00:42:50,316 --> 00:42:53,316
So let's move it -- actually,
no I like it back where it is.


771
00:42:53,316 --> 00:42:54,306
Hands off the keyboard.


772
00:42:55,516 --> 00:43:01,696
[Laughter]


773
00:43:02,196 --> 00:43:04,436
Let's pull down some
menus: Shell.


774
00:43:06,686 --> 00:43:09,416
There we go.


775
00:43:09,646 --> 00:43:11,186
Let's look at Edit.


776
00:43:11,416 --> 00:43:12,666
No, maybe View.


777
00:43:18,576 --> 00:43:21,556
If this feels like a demo
that's going painfully badly,


778
00:43:21,796 --> 00:43:23,446
this is what my life
was like trying


779
00:43:23,446 --> 00:43:24,896
to use my computer remotely.


780
00:43:25,426 --> 00:43:28,836
It takes the patience of a
saint to put up with this.


781
00:43:31,066 --> 00:43:37,056
Well, now I have a new option.


782
00:43:37,056 --> 00:43:41,176
Let's turn on the not
sent low-water mark,


783
00:43:42,726 --> 00:43:50,076
and once we reconnect,


784
00:43:50,076 --> 00:43:53,086
now I will try dragging
this window around.


785
00:43:54,516 --> 00:44:04,966
[Applause]


786
00:44:05,466 --> 00:44:05,816
Thank you.


787
00:44:06,436 --> 00:44:13,416
And that was years of suffering
unusable screen-sharing


788
00:44:13,416 --> 00:44:16,706
connections just for the
sake of a silly oversight


789
00:44:16,916 --> 00:44:18,946
in the BSD networking stack.


790
00:44:19,776 --> 00:44:26,276
The great news is that
we have fixed this.


791
00:44:27,226 --> 00:44:36,196
It is available in -- it's now
being used by screen sharing


792
00:44:36,326 --> 00:44:39,786
in the last software update
in 10.10.3, so if you noticed


793
00:44:39,786 --> 00:44:42,116
that screen sharing seemed
to get a lot more snappy,


794
00:44:42,646 --> 00:44:44,366
then this is the reason why.


795
00:44:44,996 --> 00:44:49,586
It's used by AirPlay, and
it's available in Linux too


796
00:44:50,146 --> 00:44:52,386
because this option
applies at the source


797
00:44:52,386 --> 00:44:54,166
of the data on the sending side.


798
00:44:54,636 --> 00:44:57,356
So for those of you who
are running Linux servers,


799
00:44:57,696 --> 00:45:02,866
this option is available
for your servers too.


800
00:45:03,176 --> 00:45:06,716
The benefit of this delay
reduction is really obvious


801
00:45:06,826 --> 00:45:08,226
for real-time applications.


802
00:45:09,856 --> 00:45:13,896
And we started making
slides for this presentation


803
00:45:14,006 --> 00:45:15,136
where we had two columns.


804
00:45:15,136 --> 00:45:18,356
We had the apps that should
use the low-water mark option


805
00:45:18,416 --> 00:45:19,506
and the apps that shouldn't.


806
00:45:20,276 --> 00:45:23,606
And we couldn't think of any
to go in the shouldn't column.


807
00:45:24,386 --> 00:45:26,606
Every time we thought
of a traditional app


808
00:45:26,606 --> 00:45:28,586
like file transfer, well,
that doesn't need it.


809
00:45:29,126 --> 00:45:31,976
We realized you've
had that experience


810
00:45:31,976 --> 00:45:33,786
where you change your
mind about a file transfer


811
00:45:33,786 --> 00:45:35,576
and you press Control-C
and it seems to take


812
00:45:35,576 --> 00:45:37,106
about 30 seconds to cancel.


813
00:45:37,976 --> 00:45:40,526
It's because it had
over-committed all of this data


814
00:45:40,526 --> 00:45:42,606
into the kernel and it had
to wait for it to drain


815
00:45:43,006 --> 00:45:44,506
because there's no way
to change your mind.


816
00:45:45,016 --> 00:45:48,176
So, yeah, actually, file
transfer does not benefit


817
00:45:48,176 --> 00:45:51,946
from over-committing data,
and we couldn't think


818
00:45:51,946 --> 00:45:53,856
of any application
that does benefit


819
00:45:53,856 --> 00:45:55,626
from over-stuffing the kernel.


820
00:45:55,946 --> 00:46:00,836
So once we had that
realization, we decided starting


821
00:46:00,836 --> 00:46:04,686
in the next seed, this option
will be turned on automatically


822
00:46:05,566 --> 00:46:09,766
for all connections using
the higher layer NSURLSession


823
00:46:09,766 --> 00:46:11,546
and CFNetwork APIs.


824
00:46:12,696 --> 00:46:15,776
All you have to do to
make best use of this is


825
00:46:15,776 --> 00:46:20,606
when your socket becomes
writable, don't loop writing


826
00:46:20,606 --> 00:46:23,086
as much data as you can
until you get an EWOULDBLOCK.


827
00:46:23,446 --> 00:46:26,856
Just write a sensible-sized
unit, and then wait


828
00:46:27,126 --> 00:46:28,426
to be told it's time for more.


829
00:46:28,836 --> 00:46:31,606
And that way if the user
has changed their mind


830
00:46:31,606 --> 00:46:33,686
or something else has
changed about the environment,


831
00:46:33,686 --> 00:46:36,946
next time you find your
socket is writable,


832
00:46:37,256 --> 00:46:39,466
you can make an intelligent
decision.


833
00:46:40,456 --> 00:46:42,886
You can do just-in-time
data generation


834
00:46:43,196 --> 00:46:47,116
where you generate the data
so it is as fresh as possible


835
00:46:47,116 --> 00:46:48,656
and based on the
current information,


836
00:46:49,046 --> 00:46:51,906
not based on the information
from five or ten seconds ago.


837
00:46:52,486 --> 00:46:58,426
And that brings me to our
final part of the presentation,


838
00:46:59,336 --> 00:47:01,416
and that is a sneak peek


839
00:47:02,096 --> 00:47:06,416
of a brand-new technology
called TCP Fast Open.


840
00:47:07,236 --> 00:47:14,516
The way TCP traditionally works
is this: we do one round trip


841
00:47:15,076 --> 00:47:16,506
to set up the TCP connection.


842
00:47:17,356 --> 00:47:18,746
And then we do a
second round trip


843
00:47:19,396 --> 00:47:21,666
to send the request
and get the response.


844
00:47:22,766 --> 00:47:27,056
TCP Fast Open combines
the connection setup


845
00:47:27,056 --> 00:47:30,036
and the data exchange
into one packet exchange.


846
00:47:31,216 --> 00:47:34,466
This is not turned on by
default for all applications


847
00:47:34,566 --> 00:47:37,406
and there's a reason for that.


848
00:47:37,636 --> 00:47:39,606
There is a caveat you
need to be aware of,


849
00:47:40,026 --> 00:47:43,486
and that is that this is only
safe for idempotent data.


850
00:47:43,796 --> 00:47:47,736
I'll explain what that means.


851
00:47:47,906 --> 00:47:52,426
When you use a TFO
operation, the handshake


852
00:47:52,426 --> 00:47:55,556
and data are combined, the
server gets the message,


853
00:47:55,556 --> 00:47:57,946
the server acts on that,
sends you the response,


854
00:47:58,336 --> 00:47:59,586
and then you close
the connection.


855
00:48:00,686 --> 00:48:05,566
But the service model of the
Internet doesn't guarantee


856
00:48:05,916 --> 00:48:08,536
that packets can't
be duplicated.


857
00:48:09,366 --> 00:48:12,916
The success of the
Internet has been due


858
00:48:12,916 --> 00:48:14,306
to a very simple service model,


859
00:48:14,736 --> 00:48:18,446
which is deliver the
packets fast and cheap.


860
00:48:19,146 --> 00:48:21,136
And don't worry about
them being in order.


861
00:48:21,926 --> 00:48:24,296
Don't worry if some get
corrupted, some get lost,


862
00:48:24,346 --> 00:48:26,916
some get duplicated,
just be fast and cheap.


863
00:48:27,776 --> 00:48:30,816
And the end systems are
smart enough to deal


864
00:48:30,816 --> 00:48:31,886
with that network model.


865
00:48:33,456 --> 00:48:35,566
Packets can be duplicated
for many reasons.


866
00:48:35,566 --> 00:48:37,446
It could just be
a bug in a router,


867
00:48:37,996 --> 00:48:40,736
it could be Wi-Fi link
layer retransmission


868
00:48:41,636 --> 00:48:43,876
that accidentally
sends the packet twice.


869
00:48:44,276 --> 00:48:46,706
It could be end-system
retransmission:


870
00:48:46,706 --> 00:48:50,396
If you send a packet and
don't get an acknowledgment


871
00:48:50,966 --> 00:48:52,896
because the acknowledgment
was lost, perhaps,


872
00:48:53,316 --> 00:48:54,786
you will then retransmit
the packet


873
00:48:55,296 --> 00:48:56,946
and then immediately
you've got two copies


874
00:48:56,946 --> 00:48:58,276
of the same packet
in the network.


875
00:48:58,786 --> 00:49:02,956
Well, if one of those copies is
delayed and shows up much later,


876
00:49:03,716 --> 00:49:06,496
then to the server that looks


877
00:49:06,496 --> 00:49:09,766
like a perfectly
valid TFO request,


878
00:49:10,156 --> 00:49:12,776
and whatever the operation
was, it will do it again.


879
00:49:13,646 --> 00:49:16,996
If that operation was
sending you a JPEG image,


880
00:49:17,336 --> 00:49:19,076
doing it twice may
be no big deal.


881
00:49:20,046 --> 00:49:23,726
If that operation was sending
you a pair of shoes from Zappos,


882
00:49:24,176 --> 00:49:26,006
then doing it twice might
not be what you want.


883
00:49:26,456 --> 00:49:31,196
So this is something where you
have to intelligently decide


884
00:49:31,316 --> 00:49:32,756
when it's appropriate and safe


885
00:49:33,076 --> 00:49:35,396
and when it's not
for your application.


886
00:49:36,626 --> 00:49:41,426
You use this through the
connectx system call.


887
00:49:42,346 --> 00:49:48,086
This is a sneak peek technology
preview for the early adopters.


888
00:49:49,136 --> 00:49:51,986
Later, we will look
at how to expose this


889
00:49:51,986 --> 00:49:52,846
through the higher level APIs


890
00:49:52,846 --> 00:49:55,616
but now it's only
available through connectx.


891
00:49:56,456 --> 00:49:59,776
The server you are talking to
has to support TFO as well,


892
00:49:59,776 --> 00:50:03,536
and the application
has to opt in.


893
00:50:03,536 --> 00:50:06,546
For those of you running Linux
servers, if you have the very,


894
00:50:06,546 --> 00:50:09,686
very latest Linux kernel as
of a couple of weeks ago,


895
00:50:10,096 --> 00:50:15,836
that now supports the
standard ITF, TFO,


896
00:50:16,116 --> 00:50:18,676
TCP option code,
the same as OS X.


897
00:50:19,236 --> 00:50:24,196
So to wrap up what we
would like you to remember


898
00:50:24,196 --> 00:50:28,586
from today's session,
wherever you can,


899
00:50:29,256 --> 00:50:32,356
use the highest layer
network API as possible


900
00:50:32,886 --> 00:50:36,286
and that way you get the
full benefit of all the work


901
00:50:36,286 --> 00:50:38,016
that those APIs can do for you.


902
00:50:39,576 --> 00:50:42,956
You absolutely must be
testing on a NAT64 network


903
00:50:43,076 --> 00:50:44,586
for your applications,


904
00:50:45,206 --> 00:50:48,666
and thankfully we have made
it really, really easy for you


905
00:50:48,666 --> 00:50:52,396
to do that with just
an Option click.


906
00:50:52,596 --> 00:50:57,256
Reliable network fallback will
give your customers a better


907
00:50:57,256 --> 00:50:59,286
user experience with
your applications.


908
00:51:00,526 --> 00:51:04,246
What you can do is pay attention
to the Better Route notification


909
00:51:04,506 --> 00:51:07,056
so that you migrate back to
Wi-Fi when it's available.


910
00:51:08,856 --> 00:51:13,096
Explicit Congestion Notification
is a new feature for the seed.


911
00:51:14,476 --> 00:51:17,646
It will enable the
Internet to move


912
00:51:17,646 --> 00:51:21,476
to this much more
responsive mode of operation


913
00:51:21,796 --> 00:51:24,756
with lower queuing
and lower packet loss.


914
00:51:25,406 --> 00:51:28,116
So we would like you to test
that and report any problems.


915
00:51:29,486 --> 00:51:32,836
The TCP NOTSENT Low-Water mark
is something that you can set


916
00:51:32,836 --> 00:51:36,636
for yourself as a socket
option or get for free starting


917
00:51:36,636 --> 00:51:39,506
in the next seed, and that
will reduce the amount


918
00:51:39,506 --> 00:51:41,726
of stagnant data buffered
in the sending machine.


919
00:51:42,706 --> 00:51:46,856
And then finally, for the people
excited about TCP Fast Open,


920
00:51:46,856 --> 00:51:48,076
we've made that available too.


921
00:51:49,896 --> 00:51:51,286
There's a bunch of sources


922
00:51:51,286 --> 00:51:53,006
of good documentation
that you can look at.


923
00:51:53,626 --> 00:51:55,906
I'm not expecting anybody
to write down these URLs;


924
00:51:55,906 --> 00:51:57,806
you can click those
in the PDF version.


925
00:51:59,066 --> 00:52:03,066
There are some good forums
where you can ask questions


926
00:52:03,066 --> 00:52:04,176
and have discussions


927
00:52:04,666 --> 00:52:06,596
with questions you
have about networking.


928
00:52:09,586 --> 00:52:11,586
I encourage you to
watch the videos


929
00:52:11,586 --> 00:52:14,976
of the NSURLSession presentation


930
00:52:15,196 --> 00:52:19,626
and the Network Extensions
presentation and, of course,


931
00:52:20,326 --> 00:52:23,626
come and join us in person after
lunch in the networking lab


932
00:52:23,766 --> 00:52:25,276
and we can answer all
of your questions there.


933
00:52:25,746 --> 00:52:25,936
Thank you.


934
00:52:26,516 --> 00:52:32,500
[Applause]

