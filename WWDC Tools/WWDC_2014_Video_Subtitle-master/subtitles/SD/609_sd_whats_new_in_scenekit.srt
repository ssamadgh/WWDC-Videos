1
00:00:11,516 --> 00:00:17,146
[ Applause ]


2
00:00:17,646 --> 00:00:18,096
>> Thank you.


3
00:00:18,396 --> 00:00:21,336
So, good morning,
everyone, and welcome to the


4
00:00:21,336 --> 00:00:23,156
"What's New in SceneKit"
session.


5
00:00:24,476 --> 00:00:28,686
So, SceneKit is a
framework to help you load


6
00:00:28,686 --> 00:00:31,966
and integrate 3D objects or
3D scenes in your application.


7
00:00:32,976 --> 00:00:36,706
It can be used for
different purposes, like UI,


8
00:00:36,846 --> 00:00:39,866
data visualization, or
presentations, like here,


9
00:00:39,866 --> 00:00:44,836
and now with this release
also to build casual 3D games.


10
00:00:45,296 --> 00:00:49,166
It was first introduced
on the Mac on 10.8,


11
00:00:49,496 --> 00:00:51,526
and it is now available on iOS.


12
00:00:53,426 --> 00:00:54,116
Yeah, thank you.


13
00:00:55,516 --> 00:00:58,386
[ Applause ]


14
00:00:58,886 --> 00:01:02,646
Regarding the layering, SceneKit
is a high-level Objective-C API.


15
00:01:03,476 --> 00:01:06,366
It's built on top of
OpenGL and OpenGL ES,


16
00:01:06,786 --> 00:01:10,126
and it can collaborate well with
those aerographic technologies,


17
00:01:10,266 --> 00:01:13,136
like Core Image and Core
Animation, and also,


18
00:01:13,136 --> 00:01:15,636
especially now, with
SpriteKit, and I will detail


19
00:01:15,636 --> 00:01:16,986
that in the next slide.


20
00:01:17,506 --> 00:01:22,416
In addition of being available
in iOS, which is really great,


21
00:01:23,146 --> 00:01:26,356
we also have a set of cool new
features ready for this release,


22
00:01:27,006 --> 00:01:29,256
like physics, particles
in physics fields.


23
00:01:29,826 --> 00:01:32,336
I will present them
in the next slides.


24
00:01:33,666 --> 00:01:36,146
Before that, some
related sessions.


25
00:01:37,396 --> 00:01:39,406
So, I invite you
first to have a look


26
00:01:39,406 --> 00:01:40,896
at last year's presentation,


27
00:01:41,526 --> 00:01:44,136
since even if SceneKit
was OS X only,


28
00:01:44,656 --> 00:01:48,146
everything represented last
year is applicable now on iOS.


29
00:01:49,426 --> 00:01:52,236
Then this session is about
"What's New in SceneKit."


30
00:01:52,236 --> 00:01:56,126
We also have a more hands-on
session at 11:30, same room,


31
00:01:56,796 --> 00:01:58,986
where we will show
how we build a little


32
00:01:58,986 --> 00:02:01,766
but fully functional game, and
we'll explain how we did that.


33
00:02:03,076 --> 00:02:04,536
Also, in case you missed it,


34
00:02:04,976 --> 00:02:06,836
have a look at the
SpriteKit session


35
00:02:06,836 --> 00:02:10,506
that was earlier this
week, since SceneKit


36
00:02:10,506 --> 00:02:12,306
and SpriteKit can
really work well together


37
00:02:12,306 --> 00:02:13,926
to achieve great results.


38
00:02:14,456 --> 00:02:19,536
Okay, for this presentation,
I will start


39
00:02:19,536 --> 00:02:23,726
with a very brief overview of
the SceneKit main principles.


40
00:02:24,766 --> 00:02:26,086
It will be very quick.


41
00:02:26,086 --> 00:02:27,876
If you want more
details, please refer


42
00:02:27,876 --> 00:02:29,286
to last year's presentation.


43
00:02:29,586 --> 00:02:33,576
And then I will present the
steps to create an application


44
00:02:33,576 --> 00:02:36,826
that uses SceneKit, and I
will present the new features


45
00:02:37,006 --> 00:02:37,746
as I go along.


46
00:02:39,516 --> 00:02:40,506
So, the overview.


47
00:02:41,876 --> 00:02:44,056
So, a scene in SceneKit
is represented


48
00:02:44,056 --> 00:02:45,686
by the SCNScene class.


49
00:02:46,056 --> 00:02:47,846
If you are already
familiar with SpriteKit,


50
00:02:48,266 --> 00:02:50,816
that's the equivalent
of SKScene.


51
00:02:51,756 --> 00:02:54,506
So that's [inaudible] object,
and the scene has a root node


52
00:02:54,726 --> 00:02:58,866
of the SCNNode class, and a
node represents a location


53
00:02:58,866 --> 00:02:59,676
in 3D space.


54
00:03:00,316 --> 00:03:02,596
A node may have some child
nodes that are related


55
00:03:02,646 --> 00:03:04,196
to their parent node, just


56
00:03:04,196 --> 00:03:06,706
like SKNode are related
to their parent node.


57
00:03:07,256 --> 00:03:11,216
And then, a node by
itself doesn't render


58
00:03:11,216 --> 00:03:12,126
anything onscreen.


59
00:03:12,296 --> 00:03:14,076
It's just a location
in 3D space.


60
00:03:14,656 --> 00:03:17,276
And unlike SpriteKit,
where you use subclasses


61
00:03:17,276 --> 00:03:20,226
to render things onscreen,
here with SceneKit,


62
00:03:20,226 --> 00:03:21,966
you attach attributes
to your nodes.


63
00:03:22,696 --> 00:03:24,976
So attributes you can
attach as the following:


64
00:03:24,976 --> 00:03:28,306
You can attach a light
or a camera or geometry.


65
00:03:29,046 --> 00:03:32,346
And attaching a geometry to
a node means that you want


66
00:03:32,346 --> 00:03:34,886
to render that geometry
at the node location.


67
00:03:35,676 --> 00:03:37,636
So, if you want to
render the same geometry


68
00:03:37,636 --> 00:03:40,736
in multiple places, you simply
share the same geometry instance


69
00:03:41,036 --> 00:03:41,886
to multiple nodes.


70
00:03:42,656 --> 00:03:44,916
So, let's go quickly
over these attributes.


71
00:03:45,306 --> 00:03:49,986
So, the first one
is SCNGeometry.


72
00:03:50,446 --> 00:03:54,976
It represents a geometry, so
a set of triangles, vertices,


73
00:03:54,976 --> 00:03:56,406
no more than textural
coordinates,


74
00:03:57,026 --> 00:03:58,626
and it has also a
[inaudible] of materials


75
00:03:58,626 --> 00:04:00,666
that controls the
appearance of the surface.


76
00:04:02,336 --> 00:04:04,426
Then, the second
attribute is SCNLight.


77
00:04:04,556 --> 00:04:06,676
It represents a light source.


78
00:04:07,056 --> 00:04:11,006
We support four types of lights:
to illuminate from a point,


79
00:04:11,356 --> 00:04:14,536
in a direction, as a spot
[inaudible] directions,


80
00:04:15,146 --> 00:04:16,805
and with the ambient light.


81
00:04:17,476 --> 00:04:20,286
Then, next attribute, SCNCamera.


82
00:04:21,736 --> 00:04:24,796
A node with a camera attached
can be used as a point of view


83
00:04:24,796 --> 00:04:26,996
to render your scene,
so it's simple


84
00:04:26,996 --> 00:04:29,266
as setting the pointOfView
property of your view


85
00:04:29,606 --> 00:04:31,826
to one node that has
a camera attached.


86
00:04:32,256 --> 00:04:34,686
For example, here is a point
of view to render the scene,


87
00:04:35,686 --> 00:04:36,916
and here is another
point of view.


88
00:04:38,276 --> 00:04:41,526
So, to sum up, when you
create a scene with SceneKit,


89
00:04:41,526 --> 00:04:43,086
you first start by
creating nodes


90
00:04:43,086 --> 00:04:45,096
and placing them in 3D space.


91
00:04:46,436 --> 00:04:47,876
Then you can add a child node


92
00:04:48,036 --> 00:04:50,306
that are relative to
their parent node.


93
00:04:51,476 --> 00:04:54,416
Then you attach geometries
to these nodes


94
00:04:54,416 --> 00:04:55,826
to render surfaces onscreen.


95
00:04:56,656 --> 00:04:58,096
Then you configure the materials


96
00:04:58,236 --> 00:04:59,806
to change their colors
and textures.


97
00:04:59,886 --> 00:05:03,666
And finally, you can also attach
a light to one node if you want


98
00:05:03,666 --> 00:05:05,666
to illuminate your scene.


99
00:05:06,216 --> 00:05:08,896
So that's our very
brief introduction.


100
00:05:08,986 --> 00:05:11,556
Now let's see how
to get started.


101
00:05:12,766 --> 00:05:18,386
So, in Xcode 6, there is
now a new game template


102
00:05:18,386 --> 00:05:23,236
from which you can choose to
create a SceneKit base game,


103
00:05:24,166 --> 00:05:25,696
and this will create
a new application


104
00:05:25,696 --> 00:05:27,616
with the SCNView
already set up for you.


105
00:05:28,246 --> 00:05:30,116
If you already have
an application,


106
00:05:30,116 --> 00:05:32,136
you can also use the
Interface Builder and drag


107
00:05:32,136 --> 00:05:34,726
and drop SCNView from the
Interface Builder Library


108
00:05:34,856 --> 00:05:35,926
into your application.


109
00:05:36,336 --> 00:05:39,926
Note that SceneKit gives you
a view if you want to render


110
00:05:39,926 --> 00:05:42,766
into a view, but there
is also SCNLayer on OS X,


111
00:05:42,766 --> 00:05:47,556
and SCNRenderer if you
want to render off-screen


112
00:05:47,556 --> 00:05:49,336
into an arbitrary
OpenGL context.


113
00:05:49,966 --> 00:05:53,286
Now you know how
to render a scene;


114
00:05:53,286 --> 00:05:54,596
let's see how to create one.


115
00:05:55,416 --> 00:05:58,006
So, to create a scene, you
have basically two options:


116
00:05:58,006 --> 00:06:00,016
You can user-create
everything programmatically,


117
00:06:00,596 --> 00:06:01,956
or you can load a
scene from a file.


118
00:06:03,116 --> 00:06:04,716
To create a scene
programmatically,


119
00:06:05,626 --> 00:06:08,726
you can use one of our
built-in parametric geometries,


120
00:06:09,076 --> 00:06:12,636
like a box, a plane, a
torus, a cylinder, etcetera.


121
00:06:13,446 --> 00:06:17,146
You can configure the
parameters, like width, length,


122
00:06:17,686 --> 00:06:20,076
height, [inaudible],
segment count, etcetera.


123
00:06:21,086 --> 00:06:25,406
You also have SCNText to
create 3D text with extrusion


124
00:06:25,406 --> 00:06:28,336
and chamfer and multiple
materials,


125
00:06:28,766 --> 00:06:31,236
and it supports basically
all the fonts


126
00:06:31,236 --> 00:06:33,176
and layouts supported
by Core Text.


127
00:06:34,006 --> 00:06:38,286
You can also use SCNShape
to create a 3D object


128
00:06:38,716 --> 00:06:42,946
from a 2D Bezier pass by
extruding it and chamfering it.


129
00:06:42,946 --> 00:06:45,096
So, for example, here
is a 2D Bezier pass,


130
00:06:45,166 --> 00:06:49,866
and I can extrude it to create
a 3D object from it very easily.


131
00:06:50,426 --> 00:06:53,306
And also, if you need, you can
also create your fully custom


132
00:06:53,306 --> 00:06:56,526
geometry by placing
your custom vertices,


133
00:06:56,526 --> 00:06:58,136
normal and texture coordinates.


134
00:06:58,136 --> 00:06:59,336
So here you have
the full control


135
00:06:59,336 --> 00:07:03,546
and with SCNGeometry API.


136
00:07:03,546 --> 00:07:05,246
And also new in this release,


137
00:07:05,666 --> 00:07:08,766
you can also now
subdivide your geometry


138
00:07:08,946 --> 00:07:12,076
with the subdivisionLevel
property of SCNGeometry.


139
00:07:12,776 --> 00:07:17,006
This uses Pixar OpenSubdiv
technology to achieve this.


140
00:07:17,326 --> 00:07:18,326
So, for example, here


141
00:07:18,996 --> 00:07:22,076
on the left you have the
model not subdivided yet,


142
00:07:22,236 --> 00:07:25,266
and on the right with one
iteration of subdivision.


143
00:07:25,756 --> 00:07:30,626
Okay, so that to create
scenes programmatically.


144
00:07:30,626 --> 00:07:32,796
Now, you can also load
a scene from a file.


145
00:07:33,526 --> 00:07:37,026
And loading a scene from a file
lets you load a scene fully


146
00:07:37,026 --> 00:07:41,466
configured by your artist that
will include all the geometries,


147
00:07:41,466 --> 00:07:44,106
all the nodal hierarchies,
the lightings, the textures,


148
00:07:44,556 --> 00:07:45,856
the position of your cameras,


149
00:07:46,146 --> 00:07:48,156
all the skin information,
etcetera.


150
00:07:49,066 --> 00:07:51,566
SceneKit supports
COLLADA documents


151
00:07:52,446 --> 00:07:54,586
with the extension .dae.


152
00:07:55,016 --> 00:07:56,916
It's an XML-based file format.


153
00:07:58,736 --> 00:08:02,236
We now also support
the Alembic file format


154
00:08:02,686 --> 00:08:05,106
with the extension .abc.


155
00:08:05,906 --> 00:08:09,946
So, Alembic is quite popular in
the video industry, for example.


156
00:08:10,736 --> 00:08:12,696
And with Alembic you
can load geometries


157
00:08:12,696 --> 00:08:14,096
and animations exclusively.


158
00:08:15,426 --> 00:08:18,606
So, once you get your 3D
file from your artist,


159
00:08:19,316 --> 00:08:23,346
you can have a preview of it in
Preview, or directly in Finder


160
00:08:23,346 --> 00:08:27,196
with QuickLook, and you can
open it and have a preview


161
00:08:27,196 --> 00:08:28,386
and do more with Xcode.


162
00:08:29,896 --> 00:08:32,826
Xcode has a built-in
COLLADA editor


163
00:08:33,096 --> 00:08:36,285
that will let you
inspect your 3D files.


164
00:08:37,506 --> 00:08:39,726
To be clear, it's
not a modeling tool;


165
00:08:40,056 --> 00:08:42,796
this is not where you
will create your models


166
00:08:42,796 --> 00:08:43,846
and create your scene.


167
00:08:43,846 --> 00:08:47,696
This is more a tool to
inspect the hierarchy of nodes,


168
00:08:47,696 --> 00:08:51,196
their names, you can change the
materials, adjust the lighting,


169
00:08:51,196 --> 00:08:53,286
and do the scan of
things, typically.


170
00:08:53,506 --> 00:08:56,676
You can tune your scene for
your application with Xcode.


171
00:08:59,996 --> 00:09:01,806
Once you have your
scene ready to load it


172
00:09:01,806 --> 00:09:03,546
at one time, it's easy.


173
00:09:03,546 --> 00:09:06,736
You first add your COLLADA
file to your resource


174
00:09:06,736 --> 00:09:10,496
as a normal resource,
and then, at runtime,


175
00:09:10,496 --> 00:09:17,706
you use SCNScene sceneNamed
to load it, or Scene with URL.


176
00:09:18,116 --> 00:09:21,586
New in this release, we also
provide an alternative way


177
00:09:21,586 --> 00:09:22,656
to manage your assets,


178
00:09:23,176 --> 00:09:26,786
and we call that
SceneKit Assets Catalogs.


179
00:09:27,826 --> 00:09:30,076
An Asset Catalog
is simply a folder


180
00:09:30,316 --> 00:09:35,446
with a .scnassets extension,
and what it does is that,


181
00:09:35,706 --> 00:09:39,116
if you put your assets in it,
Xcode will copy this folder


182
00:09:39,116 --> 00:09:42,496
at build time by preserving
your folder hierarchy.


183
00:09:43,716 --> 00:09:44,786
So, the first advantage is


184
00:09:44,916 --> 00:09:48,456
that it lets you organize your
assets the way you want --


185
00:09:48,616 --> 00:09:50,726
for example by having
your models in one folder,


186
00:09:50,726 --> 00:09:54,256
your textures in another
one, your particles in


187
00:09:54,256 --> 00:09:57,226
yet another one -- or
organize your assets by level


188
00:09:57,226 --> 00:09:58,236
if you are building a game.


189
00:09:59,356 --> 00:10:00,956
The second advantage is


190
00:10:00,956 --> 00:10:03,516
that Assets Catalogs will
give you some options


191
00:10:03,676 --> 00:10:08,016
because the Assets Catalogs
are processed at build time,


192
00:10:08,446 --> 00:10:11,676
and so you have options
to optimize your assets


193
00:10:12,116 --> 00:10:16,766
at build time by, for example,
interleaving the geometry data


194
00:10:16,996 --> 00:10:22,496
to be more efficient on iOS, or
by converting the orientations


195
00:10:22,496 --> 00:10:24,826
of your models, too, so
that they are all consistent


196
00:10:24,996 --> 00:10:26,126
across your game.


197
00:10:30,186 --> 00:10:33,736
Okay, once you have your scene
loaded to display it, it's easy.


198
00:10:33,736 --> 00:10:36,596
Simply assign your scene to your
view with the scene property.


199
00:10:37,196 --> 00:10:40,186
The view will automatically
display the scene, and also,


200
00:10:40,516 --> 00:10:42,066
if you modify your scene graph,


201
00:10:42,066 --> 00:10:44,276
the view will automatically
reflect your changes.


202
00:10:44,666 --> 00:10:47,346
There is no need to call
[inaudible] display,


203
00:10:47,956 --> 00:10:49,906
for example.


204
00:10:50,606 --> 00:10:53,106
Okay, so now we have seen how
to load and display your scene;


205
00:10:53,106 --> 00:10:55,026
let's see how to give
life to those scenes.


206
00:10:56,296 --> 00:10:59,596
To animate your objects,
you have several options.


207
00:11:00,126 --> 00:11:02,486
You can update the position


208
00:11:02,486 --> 00:11:04,916
of your objects programmatically
at every frame.


209
00:11:05,886 --> 00:11:07,546
You can configure animations


210
00:11:07,546 --> 00:11:11,286
for a given duration
and let it play.


211
00:11:11,986 --> 00:11:12,706
New in this release,


212
00:11:12,706 --> 00:11:14,626
we introduce the
concept of actions.


213
00:11:14,786 --> 00:11:16,676
I will present that.


214
00:11:16,816 --> 00:11:19,146
You can also set
up some constraints


215
00:11:19,146 --> 00:11:20,476
between your 3D objects.


216
00:11:20,746 --> 00:11:23,656
And last I will present how
you can animate your scenes


217
00:11:23,656 --> 00:11:24,446
using physics.


218
00:11:25,146 --> 00:11:28,826
So first, the per-frame update.


219
00:11:28,826 --> 00:11:32,216
If you need to update your
objects on a per-frame basis,


220
00:11:33,466 --> 00:11:37,626
it is recommended to use one
of the delegate methods here.


221
00:11:37,986 --> 00:11:40,376
So here is how the game
loops look like; so,


222
00:11:40,376 --> 00:11:43,366
this is what is done at every
frame when your game runs.


223
00:11:44,286 --> 00:11:48,396
So it's the combination of
delegate method that we call,


224
00:11:48,396 --> 00:11:51,646
and you implement, and some
SceneKit internal processes,


225
00:11:51,746 --> 00:11:52,996
like our rendering typically.


226
00:11:53,886 --> 00:11:56,806
So basically, you will
implement the update method


227
00:11:57,266 --> 00:11:58,766
to implement your game logic,


228
00:11:58,876 --> 00:12:01,636
and you can here move your
objects programmatically.


229
00:12:02,046 --> 00:12:07,826
It is recommended to use
these callbacks essentially


230
00:12:07,826 --> 00:12:11,876
for performance reasons, because
when these callbacks are called,


231
00:12:12,116 --> 00:12:15,016
the scene is already
loaded for you to modify it.


232
00:12:15,896 --> 00:12:19,986
If you do it in your own thread,
your changes will be committed


233
00:12:20,086 --> 00:12:21,386
on the next transaction


234
00:12:21,566 --> 00:12:23,866
and it won't be necessarily
synchronized


235
00:12:23,966 --> 00:12:24,846
with the current frame.


236
00:12:25,426 --> 00:12:29,336
Note that you are also have
some callbacks to be notified


237
00:12:29,336 --> 00:12:30,636
when the animations did apply


238
00:12:30,636 --> 00:12:32,086
and when the physics
did simulate,


239
00:12:32,526 --> 00:12:36,356
if you need to do whatever
actions after these operations.


240
00:12:37,456 --> 00:12:39,296
So, that's for per-frame
updates.


241
00:12:40,046 --> 00:12:44,256
Now, another way is to configure
actions - animation, sorry.


242
00:12:45,366 --> 00:12:49,096
So, for animations, SceneKit
uses the same programming model


243
00:12:49,096 --> 00:12:51,976
as Core Animation,
which supports implicit


244
00:12:51,976 --> 00:12:56,456
and explicit animations, and
almost all the properties


245
00:12:56,456 --> 00:12:58,436
of the scene graph
are animatable.


246
00:12:59,786 --> 00:13:03,546
So, for implicit animations, it
works just like Core Animations:


247
00:13:03,546 --> 00:13:07,756
You first start a transaction
with a given duration,


248
00:13:08,836 --> 00:13:10,846
then you modify whatever
property you want


249
00:13:10,846 --> 00:13:11,666
on the scene graph.


250
00:13:12,426 --> 00:13:13,846
And last, you commit
your changes


251
00:13:13,996 --> 00:13:15,396
and it animates implicitly.


252
00:13:15,886 --> 00:13:22,516
For explicit animations,
here we use directly the APIs


253
00:13:22,516 --> 00:13:23,426
of Core Animation.


254
00:13:23,586 --> 00:13:25,666
We support CABasicAnimation,


255
00:13:25,756 --> 00:13:28,396
CAKeyFrameAnimation,
and CAAnimationGroup.


256
00:13:28,816 --> 00:13:33,216
For example, here I set up
a simple basic animation


257
00:13:33,216 --> 00:13:34,886
that targets the
rotation of my node,


258
00:13:35,606 --> 00:13:38,696
then I configure its duration,
its destination value,


259
00:13:38,696 --> 00:13:39,986
and set it to repeat forever.


260
00:13:40,366 --> 00:13:43,596
And finally, I add my animation
with addAnimation forKey - so,


261
00:13:43,596 --> 00:13:45,626
just like Core Animation.


262
00:13:46,006 --> 00:13:48,536
And it makes my nodes to
rotate forever like this.


263
00:13:53,616 --> 00:13:54,896
Okay, don't worry.


264
00:13:55,616 --> 00:14:00,736
So, note that we also have
some extensions, some additions


265
00:14:00,836 --> 00:14:02,566
in Core Animation animations.


266
00:14:02,826 --> 00:14:05,166
The first one is
animation events.


267
00:14:05,636 --> 00:14:09,996
Animation events lets you
trigger a custom block of code


268
00:14:09,996 --> 00:14:13,326
at some specific
progress of you animation.


269
00:14:14,336 --> 00:14:17,416
A typical example, for
example, is to play a sound


270
00:14:17,516 --> 00:14:19,266
at some progress
in the animation.


271
00:14:19,626 --> 00:14:23,666
For example, here, I'm
playing a sound at 60 percent


272
00:14:24,206 --> 00:14:26,406
of my animation,
so if I press Next,


273
00:14:26,836 --> 00:14:31,116
you can see it calls my block at
60 percent and plays that sound.


274
00:14:31,986 --> 00:14:33,566
So that's the first addition,


275
00:14:33,566 --> 00:14:36,026
and the second addition
is smooth transitions.


276
00:14:37,466 --> 00:14:42,116
So this is useful to blend
one animation onto another.


277
00:14:42,556 --> 00:14:43,716
So, for example, here,


278
00:14:43,986 --> 00:14:46,496
the monster is playing
an idle animation.


279
00:14:47,986 --> 00:14:51,656
If I press Next, I will start an
attack animation on top of it.


280
00:14:51,966 --> 00:14:53,706
By default, without any fade-in


281
00:14:53,706 --> 00:14:56,976
and fade-out duration,
it looks like this.


282
00:14:57,446 --> 00:14:59,936
Okay, I will do it one more
time; look carefully at the end


283
00:14:59,936 --> 00:15:01,186
of the attack animation.


284
00:15:03,556 --> 00:15:06,246
Okay, so this is not super
smooth, not really great.


285
00:15:07,376 --> 00:15:10,726
And if I simply configure
the fadeInDuration


286
00:15:10,726 --> 00:15:12,936
and fadeOutDuration of
the attack animation,


287
00:15:13,576 --> 00:15:16,146
it will make the effect
of the attack animation


288
00:15:16,616 --> 00:15:18,746
to smoothly increase
at the beginning


289
00:15:18,826 --> 00:15:20,816
and smoothly decrease
at the end.


290
00:15:21,076 --> 00:15:23,526
So, now look at the same thing.


291
00:15:24,206 --> 00:15:27,226
Okay, one more time.


292
00:15:27,396 --> 00:15:29,536
So now it's smooth,
so it's much better.


293
00:15:29,716 --> 00:15:30,736
Yeah, thank you.


294
00:15:31,516 --> 00:15:35,426
[ Applause ]


295
00:15:35,926 --> 00:15:38,696
So that's much better, and also
that's super easy to configure.


296
00:15:39,606 --> 00:15:41,076
So that's for animations.


297
00:15:41,886 --> 00:15:42,606
Now, actions.


298
00:15:44,236 --> 00:15:46,206
So, if you're already
familiar with SpriteKit,


299
00:15:46,206 --> 00:15:47,576
you already know SKAction.


300
00:15:47,886 --> 00:15:50,346
Here, SCNAnimations
just works the same.


301
00:15:50,856 --> 00:15:53,566
And the main advantage
over animations is


302
00:15:53,566 --> 00:15:56,806
that it makes really
easy to sequence group


303
00:15:56,806 --> 00:15:58,706
and repeat simple actions.


304
00:16:00,446 --> 00:16:04,466
However, it's limited to a
set of predefined actions


305
00:16:04,636 --> 00:16:06,416
that works on SCNNode.


306
00:16:06,516 --> 00:16:10,536
With animations, you can
really target whatever property


307
00:16:10,536 --> 00:16:11,266
of the scene graph.


308
00:16:11,926 --> 00:16:17,316
So to give you an example of how
easy it is to write an action,


309
00:16:17,426 --> 00:16:20,976
here is an action that makes
my node to rotate forever.


310
00:16:21,726 --> 00:16:23,786
So with just one line of
code, it's the equivalent


311
00:16:23,786 --> 00:16:25,716
of the previous slide
with Core Animation


312
00:16:25,716 --> 00:16:26,906
with six lines of code.


313
00:16:27,486 --> 00:16:28,466
So that's much simpler.


314
00:16:30,306 --> 00:16:32,736
Here are some of the
predefined actions.


315
00:16:32,736 --> 00:16:36,556
You can move your objects,
rotate, make them fade in,


316
00:16:36,556 --> 00:16:38,356
fade out, remove
from the scene graph.


317
00:16:38,696 --> 00:16:41,506
And note that you can also
implement your custom actions


318
00:16:41,686 --> 00:16:46,106
by providing your
custom block if you want.


319
00:16:46,436 --> 00:16:50,386
One difference between
animations and actions is


320
00:16:50,386 --> 00:16:53,456
that actions directly target
the presentation tree.


321
00:16:54,266 --> 00:16:55,896
If you are familiar
with Core Animation,


322
00:16:55,896 --> 00:16:58,326
you know already the
concept of the model tree


323
00:16:58,326 --> 00:16:59,756
versus the presentation tree.


324
00:17:00,386 --> 00:17:02,606
So, model tree contains
the value you set


325
00:17:02,606 --> 00:17:03,816
and get programmatically,


326
00:17:04,256 --> 00:17:07,536
and the presentation tree
contains the in-flight value


327
00:17:07,536 --> 00:17:09,146
of any running animation.


328
00:17:09,846 --> 00:17:14,346
So, the red dot here
represents node.position.


329
00:17:14,866 --> 00:17:19,076
You can see that, with actions,
node.position corresponds


330
00:17:19,076 --> 00:17:21,215
to the position of the
cube on the screen.


331
00:17:22,445 --> 00:17:26,955
With animations, node.position
corresponds to the position


332
00:17:26,955 --> 00:17:29,096
of the cube at the
end of the animation.


333
00:17:30,196 --> 00:17:32,756
If you want to know the
position of the cube onscreen


334
00:17:32,756 --> 00:17:36,616
with animations, you have to do
node.presentationNode.position,


335
00:17:36,836 --> 00:17:37,966
just like Core Animation.


336
00:17:41,496 --> 00:17:43,586
Okay, so that's about actions.


337
00:17:43,656 --> 00:17:44,276
Now, physics.


338
00:17:45,636 --> 00:17:48,546
SceneKit now has a
built-in physics engine,


339
00:17:48,816 --> 00:17:50,126
zeroprode [phonetic].


340
00:17:50,276 --> 00:17:55,976
So, the API is very
similar to SpriteKit.


341
00:17:56,206 --> 00:18:00,696
To make a node physicalize, you
set the physics body property


342
00:18:00,696 --> 00:18:03,786
of your node to a
SCNPhysicsBody instance.


343
00:18:04,826 --> 00:18:08,656
For example, here I have a cube
that is not physicalized yet,


344
00:18:09,326 --> 00:18:12,456
and by setting the physicsBody
property to a dynamic body,


345
00:18:12,806 --> 00:18:16,096
it will automatically animate
with the physics simulation.


346
00:18:16,696 --> 00:18:21,366
Now, dynamic bodies
automatically bounce


347
00:18:21,496 --> 00:18:23,126
and collide together based


348
00:18:23,126 --> 00:18:26,846
on their physicsBody
properties, it's automatic.


349
00:18:28,246 --> 00:18:31,036
And then if you want to
manipulate those objects,


350
00:18:31,706 --> 00:18:35,096
you should not set the position
programmatically directly.


351
00:18:35,376 --> 00:18:38,506
Instead, you have to use forces
to manipulate those objects.


352
00:18:38,506 --> 00:18:43,096
SCNPhysicsBody has some
methods for you to apply forces


353
00:18:43,096 --> 00:18:45,086
and angular forces
to your objects.


354
00:18:45,286 --> 00:18:48,526
So for example here, if I
apply a force from the center


355
00:18:48,526 --> 00:18:51,326
of the scene to all these
cubes, I will make them go away.


356
00:18:51,846 --> 00:18:51,946
Okay.


357
00:18:55,126 --> 00:18:57,126
So, that's dynamic bodies.


358
00:18:57,526 --> 00:18:59,156
We also have static bodies.


359
00:18:59,506 --> 00:19:02,986
Static bodies participate
to the physics simulation,


360
00:19:03,096 --> 00:19:04,696
but they never move;
they are static.


361
00:19:05,756 --> 00:19:09,466
So for example here, these boxes
here are set to a static body,


362
00:19:10,166 --> 00:19:12,206
and if I have some
dynamic spheres,


363
00:19:12,206 --> 00:19:13,826
you can see that
they collide together


364
00:19:14,196 --> 00:19:17,556
but that the static
objects don't move.


365
00:19:19,016 --> 00:19:21,016
[ Blows Sharply ]


366
00:19:21,016 --> 00:19:27,000
[ Laughter & Applause ]


367
00:19:27,916 --> 00:19:28,846
My son loves that, too.


368
00:19:30,716 --> 00:19:33,776
One last kind of physics
body: kinematics body.


369
00:19:34,166 --> 00:19:37,346
Kinematics bodies participate
to the physics simulation.


370
00:19:38,026 --> 00:19:39,966
They don't move in
response to collision.


371
00:19:40,426 --> 00:19:41,726
However, the difference here is


372
00:19:41,726 --> 00:19:45,216
that you can move kinematics
bodies programmatically


373
00:19:45,486 --> 00:19:47,556
by setting their
position or rotation.


374
00:19:47,556 --> 00:19:51,706
For example here, I
have a rotating box


375
00:19:51,986 --> 00:19:53,656
that is set as a kinematic body.


376
00:19:53,796 --> 00:19:56,506
I can make it to rotate
with an action, for example.


377
00:19:56,996 --> 00:19:58,976
And you can see that it
automatically collides


378
00:19:58,976 --> 00:20:02,616
with dynamic spheres here
and makes them bounce.


379
00:20:05,546 --> 00:20:07,586
Okay, so that's for
physics bodies.


380
00:20:08,366 --> 00:20:10,406
Now, one note about
PhysicsShape.


381
00:20:10,956 --> 00:20:14,086
The PhysicsShape is a
geometry that is used


382
00:20:14,086 --> 00:20:17,796
by the physics engine to
perform the physics simulation.


383
00:20:18,296 --> 00:20:22,406
By default, SceneKit will
automatically create a shape


384
00:20:22,406 --> 00:20:22,786
for you.


385
00:20:23,306 --> 00:20:25,886
So for example, if I had
some teapots, let's say,


386
00:20:26,576 --> 00:20:30,286
SceneKit will automatically
build a shape for these teapots


387
00:20:30,286 --> 00:20:31,966
by building the convex
hull [phonetic] for you.


388
00:20:33,096 --> 00:20:37,146
That said, you can still
customize the physics shape


389
00:20:37,236 --> 00:20:37,876
if you want.


390
00:20:38,086 --> 00:20:39,986
The main reason can
be for performance.


391
00:20:40,776 --> 00:20:44,286
If you use a built-in
primitive for the shape,


392
00:20:44,286 --> 00:20:47,156
it will be more efficient
than the convex hull.


393
00:20:47,156 --> 00:20:49,936
And the second reason can
be for better correctness.


394
00:20:50,706 --> 00:20:54,126
Let's say you want to have an
object that rolls on the floor.


395
00:20:54,576 --> 00:20:58,486
You will have better correctness
if you use a sphere or cylinder


396
00:20:58,746 --> 00:21:00,826
than using a discretized
geometry.


397
00:21:01,896 --> 00:21:05,566
So, here are the primitives
that are natively supported


398
00:21:05,566 --> 00:21:06,576
by the physics engine.


399
00:21:07,266 --> 00:21:10,126
So spheres as usual,
spheres and boxes, etcetera.


400
00:21:10,936 --> 00:21:12,936
Okay, next.


401
00:21:13,996 --> 00:21:16,256
And, okay, next,
PhysicsBehavior.


402
00:21:16,536 --> 00:21:18,866
The PhysicsBehavior
lets you customize the


403
00:21:18,866 --> 00:21:19,956
physics simulation.


404
00:21:20,276 --> 00:21:24,046
For example, we have a set of
joints available in the APIs


405
00:21:24,796 --> 00:21:27,956
for you to connect objects
together, for example.


406
00:21:28,606 --> 00:21:34,176
For instance here, these boxes
are connected by hinge joints.


407
00:21:34,946 --> 00:21:38,446
To add a joint, simply use
addBehavior on the physicsWorld


408
00:21:38,446 --> 00:21:42,176
of your scene, and the joint
will reference the two nodes it


409
00:21:42,176 --> 00:21:43,046
has to connect.


410
00:21:43,906 --> 00:21:46,686
To remove the behavior,
simply use removeBehavior,


411
00:21:46,846 --> 00:21:50,116
and it will remove the joints.


412
00:21:52,756 --> 00:21:56,206
Okay, so there are definitely
much more things I didn't cover


413
00:21:56,206 --> 00:21:59,496
about physics, like
PhysicsFields for example,


414
00:21:59,496 --> 00:22:01,626
but definitely a lot of
cool things to play with.


415
00:22:02,666 --> 00:22:09,686
Now I will just show you a
quick demo, still about physics.


416
00:22:10,496 --> 00:22:13,636
So, here is a little
sample code available


417
00:22:13,636 --> 00:22:16,756
on the developer website that
is to illustrate the physics


418
00:22:16,756 --> 00:22:19,536
in general and vehicles
in particular.


419
00:22:19,536 --> 00:22:21,086
Vehicles have a specific
behavior.


420
00:22:21,886 --> 00:22:25,326
When I touch the screen, I will
apply a force on the wheels,


421
00:22:26,026 --> 00:22:27,576
and so we'll be able
to start to drive.


422
00:22:30,086 --> 00:22:32,756
Then I can control the
steering of my vehicle


423
00:22:32,966 --> 00:22:35,886
with the accelerometer and
also with the game controller.


424
00:22:36,546 --> 00:22:39,516
And the first thing
you can see, well,


425
00:22:39,516 --> 00:22:41,216
the first thing you can see
is that I'm not a good driver,


426
00:22:41,866 --> 00:22:43,926
but the second thing
you can see is


427
00:22:44,016 --> 00:22:46,596
that vehicles automatically
collide


428
00:22:47,476 --> 00:22:50,606
with dynamic bodies
and make them bounce.


429
00:22:51,446 --> 00:22:53,336
Second thing, it also
works with static bodies.


430
00:22:53,336 --> 00:22:55,906
So, for example, if I hit the
wall, the walls are static, ah,


431
00:22:55,906 --> 00:22:58,956
oops, missed, woo, like that.


432
00:23:00,486 --> 00:23:05,726
And - okay, then you can also
notice the train here is made


433
00:23:05,726 --> 00:23:08,726
of several objects that
are connected with joints,


434
00:23:08,896 --> 00:23:10,446
so if I hit the train
you can see


435
00:23:10,446 --> 00:23:12,346
that the objects move like that.


436
00:23:13,966 --> 00:23:16,676
Also notice the smoke effect,
and we explain how we do


437
00:23:16,676 --> 00:23:18,236
that later in the slides.


438
00:23:19,416 --> 00:23:20,856
Now, we'll try to do one gentle.


439
00:23:20,856 --> 00:23:23,886
Let me restart the game
like that and try to jump.


440
00:23:24,806 --> 00:23:26,626
Woo! Okay, quite good.


441
00:23:26,706 --> 00:23:27,446
Thank you, thank you.


442
00:23:28,516 --> 00:23:32,366
[ Applause ]


443
00:23:32,866 --> 00:23:36,906
Okay, and also note that this
game has some little overlays


444
00:23:36,906 --> 00:23:37,496
on top of it.


445
00:23:38,036 --> 00:23:39,356
They are made with SpriteKit;


446
00:23:39,566 --> 00:23:41,306
we will explain how
we do that later.


447
00:23:42,326 --> 00:23:45,016
So I'm talking about the
speed gauge on the right


448
00:23:45,016 --> 00:23:46,896
and the camera button
on the left.


449
00:23:47,156 --> 00:23:48,816
And so they are rendered
by SpriteKit,


450
00:23:48,816 --> 00:23:50,106
but they are also
fully functional.


451
00:23:50,106 --> 00:23:52,506
So, for example, if I click
the camera button here,


452
00:23:52,826 --> 00:23:54,586
it is clickable, and
I can change the point


453
00:23:54,586 --> 00:23:56,136
of view now to drive like that.


454
00:23:56,506 --> 00:24:00,836
Ah! Okay, and you can
see that the transition


455
00:24:00,966 --> 00:24:03,736
between the two points of view
is smooth because it's just done


456
00:24:03,736 --> 00:24:06,896
between using an
implicit transaction,


457
00:24:07,506 --> 00:24:08,856
and so that's really
super easy to do.


458
00:24:08,856 --> 00:24:10,856
So this sample code
is available.


459
00:24:10,856 --> 00:24:14,786
It is very small - sorry
- it's about 600 lines


460
00:24:14,786 --> 00:24:16,776
of code, so very easy to do.


461
00:24:17,726 --> 00:24:18,296
Thank you.


462
00:24:19,516 --> 00:24:22,456
[ Applause ]


463
00:24:22,956 --> 00:24:26,096
Okay, so still related to
animations and interactivity


464
00:24:26,096 --> 00:24:27,666
in general, now constraints.


465
00:24:28,866 --> 00:24:31,866
You can set an array of
constraints to a node.


466
00:24:32,026 --> 00:24:34,276
These constraints will
be applied sequentially,


467
00:24:34,506 --> 00:24:37,556
and they will be
applied at render time.


468
00:24:37,656 --> 00:24:40,506
So, that means that the
constraints will never modify


469
00:24:40,506 --> 00:24:43,136
your model tree, so
models that you set


470
00:24:43,136 --> 00:24:44,096
and get programmatically.


471
00:24:45,136 --> 00:24:47,696
It will be applied at the very
last moment of the rendering.


472
00:24:48,546 --> 00:24:52,106
We support custom constraints
where you can program your block


473
00:24:52,106 --> 00:24:57,266
and apply whatever transform you
want on the node's transform.


474
00:24:58,686 --> 00:25:02,476
We also support some
predefined constraints,


475
00:25:02,476 --> 00:25:03,606
like the LookAtConstraint.


476
00:25:04,476 --> 00:25:08,986
So, LookAtConstraint forces a
node to look at another node.


477
00:25:09,156 --> 00:25:12,386
For example here, if
I set LookAtConstraint


478
00:25:12,506 --> 00:25:15,526
to these arrows, it will
make my arrows to look


479
00:25:15,576 --> 00:25:17,916
into the direction
of the sphere here,


480
00:25:18,436 --> 00:25:21,536
and note that I'm doing it
inside an implicit transaction


481
00:25:21,586 --> 00:25:22,846
to make a smooth transition.


482
00:25:23,066 --> 00:25:28,106
And since it is done at render
time, I can just move my sphere


483
00:25:28,106 --> 00:25:29,656
and you can see that
the constraints


484
00:25:29,656 --> 00:25:30,916
automatically update.


485
00:25:32,406 --> 00:25:34,766
Then a typical use case
is to use this constraint


486
00:25:34,766 --> 00:25:36,416
on the node that
owns the camera.


487
00:25:36,416 --> 00:25:39,966
For example, now to have my
camera to follow that node.


488
00:25:40,516 --> 00:25:43,116
And since everything
are nodes in SceneKit,


489
00:25:43,256 --> 00:25:45,836
you can also set this
constraint on the node


490
00:25:45,836 --> 00:25:47,966
that owns the spotlight,
and now you can see


491
00:25:47,966 --> 00:25:50,776
that I have my spotlight that
can follow this node as well.


492
00:25:53,396 --> 00:25:54,486
Thank you.


493
00:25:55,516 --> 00:25:58,916
[ Applause ]


494
00:25:59,416 --> 00:26:01,666
New in this release, we are
adding one more constraint


495
00:26:01,916 --> 00:26:04,046
that we named SCNIKConstraint.


496
00:26:04,526 --> 00:26:06,566
IK stands for inverse
kinematics.


497
00:26:08,386 --> 00:26:13,896
And this one is hard to explain
by a French guy, but I'll try.


498
00:26:13,896 --> 00:26:17,066
IK constraints apply
on a node chain.


499
00:26:17,666 --> 00:26:21,226
The node chain is specified as
a base node and a root node,


500
00:26:21,226 --> 00:26:24,156
and the two nodes must
be in the same hierarchy.


501
00:26:25,676 --> 00:26:28,516
The IK constraints
will force your node


502
00:26:28,706 --> 00:26:32,256
to keep the same
original related distance


503
00:26:32,406 --> 00:26:33,276
between each other.


504
00:26:34,616 --> 00:26:38,516
So to give an example
here, I have a character


505
00:26:38,766 --> 00:26:40,626
that is playing an
idle animation,


506
00:26:41,586 --> 00:26:45,066
and when I press Next, it does
an attack animation like this.


507
00:26:45,816 --> 00:26:51,376
So IK are often used to control
articulated things like the arm


508
00:26:51,376 --> 00:26:53,056
of robots or characters.


509
00:26:54,236 --> 00:26:57,076
Now, let's say I want to do
the same attack animation,


510
00:26:57,076 --> 00:26:58,956
but this time I want
to hit this target.


511
00:26:59,916 --> 00:27:03,226
By default, it will
just miss the target.


512
00:27:03,786 --> 00:27:10,376
Now, I can use an
IKConstraint to move the lift


513
00:27:10,376 --> 00:27:12,696
of my node chain in the
direction of that target,


514
00:27:12,876 --> 00:27:15,306
and the IKConstraint will
automatically make sure


515
00:27:15,306 --> 00:27:19,416
that the hand and the elbow and
the shoulder stay consistent.


516
00:27:19,946 --> 00:27:25,836
And I can also modulate the
effect of the IKConstraints


517
00:27:25,836 --> 00:27:29,406
over time by modifying
the influence factor


518
00:27:29,406 --> 00:27:34,076
of the IKConstraint to make
its effect increase during


519
00:27:34,076 --> 00:27:34,666
the animation.


520
00:27:34,666 --> 00:27:37,386
So for example here, by
combining the attack animation


521
00:27:37,386 --> 00:27:40,166
and the IKConstraint, I
can do something like this.


522
00:27:40,166 --> 00:27:41,406
Hit the target.


523
00:27:42,196 --> 00:27:46,046
Note that here I'm also using
a LookAtConstraint for the head


524
00:27:46,046 --> 00:27:47,996
of the character
to make it to look


525
00:27:48,226 --> 00:27:49,506
in the direction of the target.


526
00:27:50,366 --> 00:27:52,616
So, if I move the target down,
you can see that the head


527
00:27:52,616 --> 00:27:54,106
of the character
follows the target.


528
00:27:54,466 --> 00:27:56,586
I can still use the
IKConstraints


529
00:27:56,586 --> 00:27:58,866
to hit the target like this.


530
00:27:59,306 --> 00:28:01,946
I will do it one last
time because it's fun.


531
00:28:03,756 --> 00:28:05,976
And beam! Okay.


532
00:28:06,516 --> 00:28:12,906
[ Applause ]


533
00:28:13,406 --> 00:28:15,706
Okay, now one note
about scriptability.


534
00:28:16,236 --> 00:28:18,976
Note that in this release,
now SceneKit is fully bridged


535
00:28:18,976 --> 00:28:21,736
with JavaScript using
JavaScript call APIs.


536
00:28:22,486 --> 00:28:26,276
It's simple to set up: just
call SCNExportJavaScriptModule


537
00:28:26,666 --> 00:28:29,026
and pass a JavaScript
Core Context.


538
00:28:29,636 --> 00:28:31,786
This will set up the
JavaScript Core Context


539
00:28:31,786 --> 00:28:34,286
with all the SceneKit
symbols and classes,


540
00:28:34,466 --> 00:28:38,246
and once this is done you
can reference your 3D objects


541
00:28:38,246 --> 00:28:41,376
from JavaScript and even write
whatever script you want.


542
00:28:42,216 --> 00:28:44,406
To give you an idea
of how SceneKit looks


543
00:28:44,406 --> 00:28:47,236
like in JavaScript,
you can do everything:


544
00:28:47,236 --> 00:28:50,276
You can allocate objects, modify
whatever properties of course.


545
00:28:50,926 --> 00:28:53,006
You can modify the
scene graph if you want,


546
00:28:53,006 --> 00:28:56,266
and you can even start
implicit transaction


547
00:28:56,266 --> 00:28:59,046
to do implicit animations with
JavaScript, and this is cool.


548
00:28:59,776 --> 00:29:05,096
And JavaScript is very handy
for tools and debugging.


549
00:29:05,426 --> 00:29:09,056
For example, if you want to
have at any time to be able


550
00:29:09,056 --> 00:29:11,316
to write a script in a
consult to debug your game


551
00:29:11,666 --> 00:29:14,626
or to have it consult
in your own tools,


552
00:29:15,106 --> 00:29:16,376
this is very convenient.


553
00:29:18,366 --> 00:29:20,986
Okay? So that's all
for animations,


554
00:29:22,436 --> 00:29:24,266
and so there are
definitely a lot


555
00:29:24,266 --> 00:29:26,616
of things I did not cover
yet, like the skinning,


556
00:29:26,616 --> 00:29:28,196
for example, the
morphing as well.


557
00:29:28,546 --> 00:29:31,076
For this, please refer to
last year's presentation.


558
00:29:31,806 --> 00:29:34,496
Now, I hand it over to Aymeric


559
00:29:34,676 --> 00:29:36,096
for the rest of the
presentation.


560
00:29:36,136 --> 00:29:36,526
Thank you.


561
00:29:37,516 --> 00:29:43,536
[ Applause ]


562
00:29:44,036 --> 00:29:44,746
>> Thanks, Thomas.


563
00:29:45,686 --> 00:29:46,496
Good morning, everyone.


564
00:29:46,726 --> 00:29:49,646
My name is Aymeric, and I'm
going to talk about rendering.


565
00:29:50,916 --> 00:29:53,526
Thomas already showed
you how to load a scene


566
00:29:53,766 --> 00:29:55,216
or create it from scratch.


567
00:29:56,446 --> 00:30:03,636
We now see how you can make it
visually nice using material.


568
00:30:04,206 --> 00:30:06,276
While geometry defines
the shape of a node,


569
00:30:06,596 --> 00:30:09,026
material defines its appearance.


570
00:30:09,376 --> 00:30:14,296
That means its color, its
transparency, and interactions


571
00:30:14,296 --> 00:30:17,466
with light like diffuse
and specular reflections.


572
00:30:18,786 --> 00:30:22,956
SceneKit uses the SCNMaterial
class to represent material.


573
00:30:24,126 --> 00:30:26,726
You can imagine it
as a toolbox full


574
00:30:26,726 --> 00:30:31,606
of properties controlling an
underlying optimized shadow.


575
00:30:32,416 --> 00:30:36,976
Here is an example of a
nicely configured material.


576
00:30:37,866 --> 00:30:39,406
A satellite image is used


577
00:30:39,406 --> 00:30:42,596
as a diffuse map while
the oceans are masked


578
00:30:42,876 --> 00:30:44,776
as the only specular areas.


579
00:30:45,896 --> 00:30:48,006
A normal map is used
to simulate a mountain,


580
00:30:48,746 --> 00:30:52,536
while an emission map displays
the city lights shining even


581
00:30:52,536 --> 00:30:53,046
in the dark.


582
00:30:54,426 --> 00:30:59,206
Finally, a cloud layer has been
added using a transparent map


583
00:30:59,396 --> 00:31:00,756
on a separate object.


584
00:31:02,456 --> 00:31:04,256
All these properties
uses [inaudible]


585
00:31:04,396 --> 00:31:07,186
of SCNMaterialsProperty class.


586
00:31:08,236 --> 00:31:12,816
Let's see how we can
fill our contents.


587
00:31:12,816 --> 00:31:18,306
First, we can set a plain color
using an NSColor or CGColorRef.


588
00:31:20,656 --> 00:31:22,386
Then, of course, we
can set an image.


589
00:31:22,896 --> 00:31:27,396
The easiest way to set an
image is using an image pass,


590
00:31:27,636 --> 00:31:29,966
either using an NS
string or an NS URL.


591
00:31:31,076 --> 00:31:33,226
This is the most optimized way.


592
00:31:33,876 --> 00:31:37,566
Simply save an extra copy of
the image in the system memory.


593
00:31:37,566 --> 00:31:43,196
Of course, you can set image
using NSImage or UIImage,


594
00:31:44,016 --> 00:31:46,966
but new in this release
we also support SKTexture.


595
00:31:48,006 --> 00:31:51,486
This will allow you to use the
cool features of SpriteKit,


596
00:31:52,166 --> 00:31:55,286
like atlases, procedural
node generation,


597
00:31:55,456 --> 00:31:59,296
and automatic normal
map generation.


598
00:32:00,916 --> 00:32:06,706
For dynamic contents, we
still support CALayer and,


599
00:32:06,706 --> 00:32:09,016
new in this release,
SpriteKit Scene.


600
00:32:10,236 --> 00:32:13,506
This video is played
using a SKVideo node.


601
00:32:17,356 --> 00:32:20,696
For the reflective property,
we [inaudible] cube maps.


602
00:32:21,496 --> 00:32:22,426
Cube maps are useful


603
00:32:22,426 --> 00:32:24,806
to represent a complete
environment.


604
00:32:25,956 --> 00:32:29,936
To set a cube map on the
property, simply set an array


605
00:32:29,936 --> 00:32:31,696
of six separate images.


606
00:32:37,596 --> 00:32:40,906
If you want to customize the
standard materials of SceneKit,


607
00:32:41,526 --> 00:32:43,186
you may want to use
shader modifiers.


608
00:32:44,216 --> 00:32:47,016
Modifiers are little
snippets of GLSL code


609
00:32:47,176 --> 00:32:49,976
that can be injected
at specific stages.


610
00:32:50,846 --> 00:32:53,696
You can apply modifiers directly


611
00:32:54,086 --> 00:32:57,586
into materials or
onto a geometry.


612
00:32:58,426 --> 00:33:00,456
In this case, every
material used


613
00:33:00,456 --> 00:33:02,056
by the geometry will
be modified.


614
00:33:04,896 --> 00:33:07,516
Here are some examples
of shader modifiers.


615
00:33:08,446 --> 00:33:11,456
The first, Ripple Effect, is
working at the geometry stage.


616
00:33:12,456 --> 00:33:15,076
The Liquid Noise Effect's
working at the surface stage,


617
00:33:15,756 --> 00:33:20,276
while the Rim Lighting Effect is
obviously at the lighting stage.


618
00:33:20,746 --> 00:33:25,446
Finally, we fake a [inaudible]
mode using a fragment modifier.


619
00:33:26,616 --> 00:33:30,856
For more information, for more
details about shader modifiers,


620
00:33:31,006 --> 00:33:32,786
please refer to last
year's session.


621
00:33:32,786 --> 00:33:39,116
If you want to completely
replace a specific material,


622
00:33:39,786 --> 00:33:42,736
you can do so by
using SCNProgram.


623
00:33:43,466 --> 00:33:48,146
These are GLSL programs like
Vertex and Fragment shaders,


624
00:33:48,236 --> 00:33:53,316
and new this year, but
only on OS X, geometry


625
00:33:53,316 --> 00:33:56,736
and [inaudible] shaders
are supported too.


626
00:33:57,066 --> 00:33:59,826
This will allow you to take the
full control of the rendering.


627
00:34:00,506 --> 00:34:03,456
SceneKit only provides
you geometry attributes


628
00:34:03,456 --> 00:34:05,796
like position, normal,
and texture coordinates,


629
00:34:06,216 --> 00:34:09,216
and transform uniforms
like model view


630
00:34:09,216 --> 00:34:10,416
and projection matrices.


631
00:34:12,896 --> 00:34:18,246
For even more control, you can
inject OpenGL code directly


632
00:34:18,246 --> 00:34:20,366
before or after the
scene rendering.


633
00:34:21,686 --> 00:34:25,315
This allows effects
like this vortex tunnel


634
00:34:25,315 --> 00:34:27,386
that was done using
a full screen quad


635
00:34:27,485 --> 00:34:29,116
on a custom fragment program.


636
00:34:30,016 --> 00:34:35,476
You can also inject OpenGL
code on a specific node basis,


637
00:34:35,906 --> 00:34:40,826
allowing you to inject code
during scene rendering among


638
00:34:40,826 --> 00:34:41,646
those objects.


639
00:34:44,835 --> 00:34:47,255
So, new in this release also,


640
00:34:47,295 --> 00:34:50,936
we support overlaying a
SpriteKit scene directly


641
00:34:50,936 --> 00:34:52,735
onto the SceneKit scene.


642
00:34:53,186 --> 00:34:54,896
This is how we did
the speedometer


643
00:34:54,966 --> 00:34:57,996
in the toy car demo
Thomas showed you earlier.


644
00:34:59,036 --> 00:35:03,156
This is the preferred
way to all your UI needs,


645
00:35:04,076 --> 00:35:07,076
because you only will have
to write once your event


646
00:35:07,076 --> 00:35:10,316
and link code in SpriteKit, and
it will work on iOS, on OS X,


647
00:35:10,316 --> 00:35:12,446
and it also quite performant


648
00:35:12,666 --> 00:35:16,656
because SpriteKit nodes are
directly rendered in our buffer,


649
00:35:16,776 --> 00:35:18,156
saving on extra compositing.


650
00:35:20,076 --> 00:35:23,636
So, that's all for rendering
and rendering customization.


651
00:35:24,706 --> 00:35:29,756
Let's now browse the effects
available in SceneKit to dress


652
00:35:29,756 --> 00:35:34,136
up your scenes, starting
with particles.


653
00:35:35,676 --> 00:35:39,126
Particle systems are commonly
used in movies and video games


654
00:35:39,896 --> 00:35:42,926
to simulate a large class
of effects, like fire,


655
00:35:43,146 --> 00:35:44,826
rain, smoke and explosions.


656
00:35:45,656 --> 00:35:49,546
In this release, we introduce
a new SCNParticleSystem class


657
00:35:49,696 --> 00:35:53,166
that will allow you all
of these effects and more.


658
00:35:53,916 --> 00:35:56,476
Because particles have a
large number of properties,


659
00:35:57,096 --> 00:35:59,676
we also provide you with
this new release of Xcode,


660
00:36:00,026 --> 00:36:03,186
a new 3D particle editor
that will allow you


661
00:36:03,186 --> 00:36:06,006
to tweak almost all
properties of ParticleSystem.


662
00:36:07,136 --> 00:36:10,926
So, let's see what kind of
effect we can achieve with it.


663
00:36:12,856 --> 00:36:15,956
Here is a hot fire
effect that is done


664
00:36:15,956 --> 00:36:18,396
with a flame texture
set as a particle image.


665
00:36:19,526 --> 00:36:22,006
We animate the color
and the size


666
00:36:22,006 --> 00:36:23,806
of the particle over
the lifespan.


667
00:36:24,936 --> 00:36:26,966
We also use an additive
blending,


668
00:36:27,416 --> 00:36:31,276
but we could also have used
a screen blending among other


669
00:36:31,276 --> 00:36:32,146
blend modes.


670
00:36:35,296 --> 00:36:38,746
ParticleSystem can be
local, like the one


671
00:36:38,746 --> 00:36:43,486
in the background moving
as a [inaudible] or global


672
00:36:43,486 --> 00:36:45,546
like the one in the front,


673
00:36:46,006 --> 00:36:48,836
where particles are directly
emitted in workspace.


674
00:36:50,796 --> 00:36:53,346
Particles can be
affected by gravity.


675
00:36:55,896 --> 00:37:00,316
They can also collide
with nodes of any shapes.


676
00:37:01,076 --> 00:37:03,356
Just beware of your
[inaudible], though.


677
00:37:07,206 --> 00:37:11,446
Particles can be affected
by physics fields,


678
00:37:11,986 --> 00:37:15,446
like this turbulence field
or this vortex field.


679
00:37:21,176 --> 00:37:25,316
ParticleSystem can also generate
subsystems on specific events,


680
00:37:25,746 --> 00:37:28,506
like particle bursts,
deaths or collision.


681
00:37:29,276 --> 00:37:33,536
Here, each raindrop
generates a subsplash system


682
00:37:33,826 --> 00:37:34,946
when hitting the floor.


683
00:37:35,456 --> 00:37:41,816
You can even apply custom
block on this particle event


684
00:37:42,036 --> 00:37:43,896
or on each simulation step.


685
00:37:44,696 --> 00:37:47,436
Here, the confetti are
laid down and stand still


686
00:37:47,846 --> 00:37:48,926
when they touch the floor.


687
00:37:53,626 --> 00:37:56,416
ParticleSystem can be
emitted from inside


688
00:37:56,416 --> 00:37:58,296
or from the surface
of any shape.


689
00:37:59,246 --> 00:38:01,976
This shape I represented
using standard geometries.


690
00:38:02,896 --> 00:38:04,766
Please note that we recommend


691
00:38:04,766 --> 00:38:06,296
that you use parametric
geometries


692
00:38:06,726 --> 00:38:08,546
as they will provide
the best performances


693
00:38:08,896 --> 00:38:10,876
and a better spatial
distribution.


694
00:38:16,126 --> 00:38:17,966
Here are some kinds of
parametric geometries.


695
00:38:19,406 --> 00:38:23,396
As I've said earlier, it
is the recommended way


696
00:38:23,636 --> 00:38:25,376
to create ParticleSystem is


697
00:38:25,376 --> 00:38:27,926
through the 3D Particle
Editor built into Xcode.


698
00:38:28,716 --> 00:38:32,206
Starting from the provided
templates, you will be able


699
00:38:32,206 --> 00:38:34,726
to tweak and customize
your system.


700
00:38:35,376 --> 00:38:41,586
Then, you will save them as
.scnp files that you'll be able


701
00:38:43,156 --> 00:38:45,806
to later load in your app.


702
00:38:47,296 --> 00:38:51,146
One of the most important
visual cues regarding depths


703
00:38:51,146 --> 00:38:52,896
and contact is shadows,


704
00:38:53,346 --> 00:38:56,426
and SceneKit provides
several ways to do shadows.


705
00:38:57,796 --> 00:39:03,436
The first way is to
directly bake your shadow map


706
00:39:03,436 --> 00:39:05,016
into your altering tool.


707
00:39:05,866 --> 00:39:08,866
Then, you will use them
on the Multiply properties


708
00:39:09,096 --> 00:39:11,466
of your receiving materials.


709
00:39:12,406 --> 00:39:15,136
While this provides the
best-looking shadows,


710
00:39:16,446 --> 00:39:20,966
and they are quite efficient
as well, the effect will break


711
00:39:21,306 --> 00:39:25,606
if you try to move your shadow
casters or even the light.


712
00:39:28,116 --> 00:39:30,776
But SceneKit also
supports dynamic shadows.


713
00:39:32,246 --> 00:39:35,526
All you have to do is enable
castsShadow on the spotlight or,


714
00:39:35,526 --> 00:39:38,746
new this release, a
directional light.


715
00:39:39,376 --> 00:39:43,996
Then your receivers, caster,
and even the light will be able


716
00:39:43,996 --> 00:39:47,046
to move as the shadow map
will be generated each frame.


717
00:39:47,596 --> 00:39:52,116
If you want to move
your shadow casters


718
00:39:52,756 --> 00:39:55,516
but have a limited GPU budget,


719
00:39:56,206 --> 00:39:58,046
you can also use
projected shadows,


720
00:39:58,646 --> 00:40:03,626
where a simple texture will fake
soft shadow when set on a gobo


721
00:40:03,626 --> 00:40:05,216
with a ShadowModeModulated.


722
00:40:05,766 --> 00:40:08,946
The next session will
cover this in more detail.


723
00:40:12,196 --> 00:40:16,576
New in this release, we also
added a global fog on the scene.


724
00:40:17,076 --> 00:40:20,956
Just set a fog color,
the range you want it


725
00:40:21,006 --> 00:40:22,826
to operate, and you're done.


726
00:40:24,006 --> 00:40:27,806
You can even control or
animate the density of the fog.


727
00:40:31,436 --> 00:40:32,896
Another commonly used effect


728
00:40:32,896 --> 00:40:34,986
in games is the use
of depth of field.


729
00:40:35,996 --> 00:40:38,786
Here again, with SceneKit,
it's really easy to do.


730
00:40:39,196 --> 00:40:42,236
All you have to do is tweak
a few focal properties


731
00:40:42,236 --> 00:40:46,106
on the camera, and you can
achieve effects like out


732
00:40:46,106 --> 00:40:50,866
of focus in the background
or in the foreground.


733
00:40:51,196 --> 00:40:51,976
It's that simple.


734
00:40:52,516 --> 00:40:59,096
[ Applause ]


735
00:40:59,596 --> 00:41:02,566
The integration of Core
Image also allows you


736
00:41:02,566 --> 00:41:06,946
to use several screen-space
fancy effects.


737
00:41:07,936 --> 00:41:11,876
Applying on a single node or
hierarchy, you can do effects


738
00:41:11,876 --> 00:41:15,006
like Gaussian blurs, distortion
like this Pixelate Effect,


739
00:41:15,396 --> 00:41:17,246
or any kind of color
processing you want.


740
00:41:20,656 --> 00:41:24,626
The last big new thing in this
release that I wanted to talk


741
00:41:24,626 --> 00:41:29,276
about is the addition
of multipass technique.


742
00:41:29,556 --> 00:41:32,106
Shadows, Core Image
filter, depth of field -


743
00:41:32,376 --> 00:41:35,326
all of these are internally
built using techniques.


744
00:41:35,686 --> 00:41:39,756
And now, with this release, we
offer you to create your own.


745
00:41:40,156 --> 00:41:41,486
So, what is a technique?


746
00:41:42,136 --> 00:41:44,746
A technique is a
sequence of passes.


747
00:41:45,356 --> 00:41:48,896
Each pass can render the
scene, a specific object


748
00:41:49,296 --> 00:41:52,006
or full-screen quad,
using custom vertex


749
00:41:52,006 --> 00:41:53,106
and fragment programs.


750
00:41:54,096 --> 00:41:58,116
Techniques have outputs, like
a color or depth render target.


751
00:41:58,476 --> 00:42:02,506
They usually have inputs
that can be constant textures


752
00:42:02,666 --> 00:42:04,346
or other passes render target.


753
00:42:05,716 --> 00:42:08,716
They can also modify
states like blend states.


754
00:42:09,816 --> 00:42:12,276
So, this passes from a graph


755
00:42:13,046 --> 00:42:16,036
where render targets are
produced and consumed.


756
00:42:18,036 --> 00:42:20,806
Techniques were designed
to be data-driven.


757
00:42:21,736 --> 00:42:23,536
They can be entirely configured


758
00:42:23,536 --> 00:42:26,466
through a property list
referencing external vertex


759
00:42:26,466 --> 00:42:27,276
and fragment shader.


760
00:42:28,096 --> 00:42:30,216
This setup allows
you quick iterations


761
00:42:30,986 --> 00:42:32,706
and tweaking your effects


762
00:42:32,766 --> 00:42:34,776
without rebuilding
your application.


763
00:42:35,356 --> 00:42:39,366
Let's see how to
create a technique.


764
00:42:40,116 --> 00:42:43,006
The easiest way is to
load it from a dictionary,


765
00:42:43,126 --> 00:42:44,676
usually coming from
a property list,


766
00:42:45,346 --> 00:42:46,626
but you can also
create technique


767
00:42:46,626 --> 00:42:48,926
by chaining several
techniques together.


768
00:42:49,846 --> 00:42:51,736
When you have a technique,
simply set it


769
00:42:51,736 --> 00:42:53,716
to a view, and you're done.


770
00:42:55,516 --> 00:42:57,506
Here's an example
of a simple depth


771
00:42:57,506 --> 00:42:59,326
of field done using techniques.


772
00:43:00,356 --> 00:43:03,726
The first pass here
renders the scene normally,


773
00:43:03,836 --> 00:43:06,446
writing into a color
on a depth buffer.


774
00:43:06,686 --> 00:43:10,656
Then a second pass takes the
color buffer from the first one


775
00:43:10,656 --> 00:43:13,046
and generates a blow-up
version of it.


776
00:43:13,316 --> 00:43:17,206
Finally, the third pass
combines the normal color buffer


777
00:43:17,206 --> 00:43:21,566
and the blowed one
using the depth buffer


778
00:43:21,566 --> 00:43:22,586
as a blending factor.


779
00:43:25,636 --> 00:43:28,466
So, that's all for techniques.


780
00:43:28,936 --> 00:43:31,836
So let's sum up what you should
take away from this session.


781
00:43:33,186 --> 00:43:35,876
SceneKit now is available
on iOS.


782
00:43:36,446 --> 00:43:40,436
It is ready for casual
games thanks to physics,


783
00:43:40,636 --> 00:43:41,986
actions and animations.


784
00:43:42,566 --> 00:43:43,496
It's also [inaudible]


785
00:43:43,576 --> 00:43:48,076
of rendering possibilities using
standard materials and effects


786
00:43:48,076 --> 00:43:52,026
like particles, and it has
a lot of control for you


787
00:43:52,626 --> 00:43:54,956
to customize its
rendering with things


788
00:43:54,956 --> 00:43:56,806
like shader modifiers
and techniques.


789
00:43:58,236 --> 00:44:00,156
One last thing is, as
you may have guessed,


790
00:44:00,386 --> 00:44:02,986
this session was created
entirely in SceneKit,


791
00:44:03,306 --> 00:44:05,736
and we are happy to give
it to you as a sample code.


792
00:44:06,516 --> 00:44:14,426
[ Applause ]


793
00:44:14,926 --> 00:44:18,476
So, I strongly encourage you to
download it and give it a try.


794
00:44:18,666 --> 00:44:20,366
It's almost as fun as Swift.


795
00:44:21,516 --> 00:44:26,546
[ Laughter & Applause ]


796
00:44:27,046 --> 00:44:28,636
For more information,


797
00:44:28,636 --> 00:44:31,156
please contact our
Evangelists Allan and Filip.


798
00:44:31,666 --> 00:44:34,616
We have a brand new
documentation for you


799
00:44:34,846 --> 00:44:39,196
in the developer website
and also a dedicated forum.


800
00:44:40,066 --> 00:44:40,576
Thanks.


801
00:44:41,016 --> 00:44:43,000
[ Applause ]

