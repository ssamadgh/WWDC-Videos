1
00:00:12,356 --> 00:00:13,336
>> Good morning!


2
00:00:13,616 --> 00:00:13,796
Welcome!


3
00:00:14,516 --> 00:00:17,136
[ Applause ]


4
00:00:17,636 --> 00:00:20,886
Glad to see a number of folks
out now, bright and early,


5
00:00:20,886 --> 00:00:23,906
to talk about all the
heart-pounding excitement


6
00:00:23,906 --> 00:00:25,276
in the world of compilers.


7
00:00:26,026 --> 00:00:31,396
And I'm Jim Grosbach, and I'm
really happy to be here today


8
00:00:31,396 --> 00:00:35,746
to share with you all of the
new things that we have in LLVM.


9
00:00:37,106 --> 00:00:42,226
When we normally talk about LLVM
and what first comes to mind


10
00:00:42,226 --> 00:00:46,296
when we think about it is the
Apple LLVM Compiler itself.


11
00:00:46,646 --> 00:00:51,146
This is what we all use to
build our apps and that's


12
00:00:51,146 --> 00:00:53,276
where we really first
encounter LLVM,


13
00:00:53,966 --> 00:00:57,136
but it's much more than that.


14
00:00:57,886 --> 00:01:03,266
LLVM is used in a wide
variety of products and tools


15
00:01:03,766 --> 00:01:09,436
that we all use every day, both
as developers and as end users.


16
00:01:10,866 --> 00:01:16,326
Over the years LLVM has grown to
be a really key technology here


17
00:01:16,326 --> 00:01:19,566
at Apple for building
tools, for performance,


18
00:01:20,146 --> 00:01:25,996
and for modernization, and that
has been no exception this year


19
00:01:26,496 --> 00:01:28,276
as we have moved swiftly along


20
00:01:29,226 --> 00:01:32,106
with a wide variety
of new improvements.


21
00:01:33,666 --> 00:01:38,806
To start with, back in September
we introduced the Apple A7


22
00:01:38,806 --> 00:01:43,086
processor which has been
just absolutely magnificent


23
00:01:43,206 --> 00:01:44,516
in what it's allowed us to do,


24
00:01:44,826 --> 00:01:47,366
bringing truly desktop-class
performance


25
00:01:48,076 --> 00:01:53,166
to your mobile devices and
LLVM plays a key role in this.


26
00:01:54,226 --> 00:01:59,546
And now we're encouraging more
of you to use this technology


27
00:01:59,546 --> 00:02:03,396
in your apps, so
building for 64-bit


28
00:02:03,676 --> 00:02:05,546
in iOS is now the default.


29
00:02:05,626 --> 00:02:09,515
As of Xcode 5.1 carrying
on into Xcode 6,


30
00:02:10,235 --> 00:02:11,546
when you rebuild your app,


31
00:02:12,486 --> 00:02:14,146
if you're using standard
architectures,


32
00:02:14,616 --> 00:02:16,676
ARM64 will be included.


33
00:02:17,406 --> 00:02:19,926
This does not impact
your deployment story.


34
00:02:19,926 --> 00:02:23,466
You can continue to
deploy back to iOS 4.3.


35
00:02:23,466 --> 00:02:26,786
We still build for
arm V7 for 32 bit.


36
00:02:27,626 --> 00:02:30,546
All of the development work
flows that you're familiar


37
00:02:30,546 --> 00:02:34,346
with for the simulator,
the debugger, profiling,


38
00:02:34,916 --> 00:02:38,066
all of these things continue
to work transparently,


39
00:02:38,526 --> 00:02:41,636
just as you're familiar with
in a 64-bit environment.


40
00:02:42,506 --> 00:02:44,926
Now, one thing to be aware of is


41
00:02:44,926 --> 00:02:49,166
that because ARM64 is an
entirely new architecture,


42
00:02:49,856 --> 00:02:52,786
your entire application
must be built 64 bit,


43
00:02:53,256 --> 00:02:54,826
not just a few libraries here,


44
00:02:54,826 --> 00:02:57,526
or a few files there,
but the whole app.


45
00:02:57,746 --> 00:03:00,586
So, if you're relying on
third-party libraries,


46
00:03:01,286 --> 00:03:05,416
and those libraries have
not yet adopted 64 bit,


47
00:03:06,036 --> 00:03:10,506
please work with your vendors
and encourage them to update


48
00:03:10,746 --> 00:03:12,796
and support 64 bit development


49
00:03:13,146 --> 00:03:16,276
so that your app
can then migrate


50
00:03:16,276 --> 00:03:18,116
as well and get the benefits.


51
00:03:18,666 --> 00:03:22,526
Now, during migration there
are a few things that we'd


52
00:03:22,526 --> 00:03:26,426
like to bring to your
attention that might come up,


53
00:03:26,426 --> 00:03:29,586
a few advancements we've
made, and a few things


54
00:03:29,586 --> 00:03:31,676
that we've tightened
up in the specification


55
00:03:31,806 --> 00:03:35,406
and what the possible impact
of that to your app is.


56
00:03:35,956 --> 00:03:42,556
To start with, in 64-bit iOS all
functions must have a prototype.


57
00:03:43,096 --> 00:03:47,116
This has been good style
since time immemorial


58
00:03:47,596 --> 00:03:51,496
and it's been required
for C++ since the start.


59
00:03:51,886 --> 00:03:55,156
It's been highly suggested in C,


60
00:03:55,276 --> 00:03:58,636
for any modern version not
using a prototype is deprecated


61
00:03:59,306 --> 00:04:01,976
and has been for a
very long time now.


62
00:04:03,206 --> 00:04:06,546
So, we've taken advantage
of this in ARM64


63
00:04:06,986 --> 00:04:10,156
to generate more efficient
calling convention code,


64
00:04:10,396 --> 00:04:12,866
in particular for variatic
functions like printf,


65
00:04:12,866 --> 00:04:14,866
that the number of arguments


66
00:04:15,166 --> 00:04:17,476
to the function varies
by call site.


67
00:04:18,995 --> 00:04:21,805
So, when you have older
code that you're using


68
00:04:21,805 --> 00:04:23,356
that may not use prototypes,


69
00:04:24,176 --> 00:04:27,496
what is normally a warning has
now been promoted to an error,


70
00:04:27,496 --> 00:04:31,646
so the compiler will highlight
to you in your code exactly


71
00:04:31,736 --> 00:04:35,766
where this is happening so
that you know which prototypes


72
00:04:35,766 --> 00:04:38,156
to go add to your
header files to move on.


73
00:04:39,796 --> 00:04:42,786
One place that this
does sometimes come


74
00:04:42,786 --> 00:04:46,556
up in a little bit more
of a subtle way is when C


75
00:04:46,556 --> 00:04:50,116
and Objective-C interworking
code with direct indications


76
00:04:50,116 --> 00:04:51,816
of Objective-C message send.


77
00:04:52,466 --> 00:04:54,946
To help find this, we
have a new Xcode setting


78
00:04:55,536 --> 00:04:58,896
to enable strict
checking of objc-msgSend.


79
00:05:00,366 --> 00:05:01,706
This is a recommended setting


80
00:05:02,796 --> 00:05:05,236
and when you first
upgrade your project


81
00:05:05,236 --> 00:05:07,396
to [inaudible] code
6 we'll encourage you


82
00:05:07,506 --> 00:05:08,546
to adopt this setting.


83
00:05:08,546 --> 00:05:12,926
And what's tricky is
that every indication


84
00:05:12,926 --> 00:05:16,636
of objc-msgSend effectively
has a different type.


85
00:05:17,466 --> 00:05:22,196
It has the type of what the
final receiving method is going


86
00:05:22,196 --> 00:05:22,646
to be.


87
00:05:23,696 --> 00:05:26,566
For example here,
a trivial piece


88
00:05:26,566 --> 00:05:29,906
of code that's invoking
method foo,


89
00:05:31,046 --> 00:05:36,446
with strict checking enabled,
the compiler will now tell us


90
00:05:36,576 --> 00:05:40,236
that we need to tell it
what the final type is.


91
00:05:41,136 --> 00:05:42,466
This is straightforward to do.


92
00:05:42,466 --> 00:05:44,956
It's a little bit verbose,
but very straightforward.


93
00:05:44,956 --> 00:05:47,736
We simply add the type of
the final receiving method.


94
00:05:48,146 --> 00:05:49,406
Done it here with a typedef.


95
00:05:49,446 --> 00:05:52,856
This could be done with a direct
type test on all on one line,


96
00:05:52,856 --> 00:05:54,866
if you prefer, just to make sure


97
00:05:54,866 --> 00:05:57,646
that the compiler knows what
the final receiving type


98
00:05:57,646 --> 00:06:01,046
of the method is so that it
can generate the right code


99
00:06:01,296 --> 00:06:02,926
to get the final result correct.


100
00:06:05,016 --> 00:06:08,296
Another place that we've
tightened things up


101
00:06:08,296 --> 00:06:09,916
and taken advantage
of our new ABI


102
00:06:09,916 --> 00:06:13,856
and ARM64 is the
Objective-C Boolean type.


103
00:06:14,276 --> 00:06:17,776
If any of you were at Stump
the Experts last night,


104
00:06:17,776 --> 00:06:19,916
this topic actually
came up as a question.


105
00:06:20,396 --> 00:06:23,306
It was rather amusing like,
"I have a slide on that!


106
00:06:23,456 --> 00:06:25,116
That'll be great!"


107
00:06:25,116 --> 00:06:27,596
So, BOOL is basically
now a BOOL type.


108
00:06:28,716 --> 00:06:31,666
Previously, it's been
a signed character.


109
00:06:32,156 --> 00:06:36,726
And, sometimes our code -- our
code as well, not just in yours,


110
00:06:37,326 --> 00:06:39,756
would put values
into the Boolean type


111
00:06:39,786 --> 00:06:41,876
that weren't strictly Boolean.


112
00:06:42,946 --> 00:06:46,606
Now, the compiler is going to
be taking advantage of this type


113
00:06:46,606 --> 00:06:48,796
or definition, so
what can happen is


114
00:06:48,796 --> 00:06:52,346
that if your code does that,
the results between 32-bit iOS


115
00:06:52,696 --> 00:06:55,106
and 64-bit iOS may differ.


116
00:06:56,046 --> 00:06:59,066
So, if you start seeing some
odd behaviors with Booleans,


117
00:06:59,366 --> 00:07:03,326
this is something
to look out for.


118
00:07:04,946 --> 00:07:06,296
We also have pointers.


119
00:07:07,516 --> 00:07:10,196
As we're now 64-bit
architecture, this is kind


120
00:07:10,196 --> 00:07:12,666
of the core of what this
is all about, that pointers


121
00:07:12,666 --> 00:07:14,266
and longs are now 64 bits.


122
00:07:15,226 --> 00:07:19,146
So, old code would
often do horrible things


123
00:07:19,146 --> 00:07:21,916
like casting integers to
pointers, and back-and-forth.


124
00:07:22,866 --> 00:07:25,286
And hopefully, we don't write
code that does that anymore,


125
00:07:25,286 --> 00:07:28,026
but we all have this legacy
code that we have to live with,


126
00:07:29,076 --> 00:07:32,176
and now this can bite
us if we're not careful.


127
00:07:32,486 --> 00:07:34,736
This is very similar
to what we've all dealt


128
00:07:34,736 --> 00:07:38,876
with on the 32-bit to
64-bit Intel transition,


129
00:07:38,876 --> 00:07:39,816
if we went through that.


130
00:07:40,616 --> 00:07:41,496
That's still a problem;


131
00:07:41,496 --> 00:07:43,826
we haven't magically just
solved that in the compiler.


132
00:07:44,886 --> 00:07:48,946
So for example here, we're
casting an integer which came


133
00:07:48,946 --> 00:07:50,106
from a pointer somewhere else.


134
00:07:50,106 --> 00:07:52,156
We're casting that
to a void (star).


135
00:07:52,156 --> 00:07:55,186
But now the compiler
can help a little bit.


136
00:07:55,186 --> 00:08:00,196
It can at least inform us
that the problem is coming up


137
00:08:00,196 --> 00:08:03,636
and tell us that, "Oh, we have a
problem here that we need to go


138
00:08:03,636 --> 00:08:04,606
and look at and make sure


139
00:08:04,606 --> 00:08:06,796
that this is really
what's happening."


140
00:08:07,596 --> 00:08:09,176
Now, if we ignore this warning,


141
00:08:09,796 --> 00:08:12,656
the runtime in the
kernel is going


142
00:08:12,656 --> 00:08:15,036
to be a little bit more
forceful about this.


143
00:08:15,606 --> 00:08:19,116
If we dereference that pointer,
we're going to get a hard fault


144
00:08:19,916 --> 00:08:22,936
because the page zero is
mapped to always give a fault,


145
00:08:22,936 --> 00:08:26,236
so if we miss any of these
through other warnings,


146
00:08:26,806 --> 00:08:27,916
we'll still get an error.


147
00:08:28,406 --> 00:08:29,696
Paying attention
to the compiler,


148
00:08:29,696 --> 00:08:32,106
it's going to be a lot
friendlier because it'll be nice


149
00:08:32,106 --> 00:08:34,515
and friendly and tell you the
line number and the source file


150
00:08:34,576 --> 00:08:35,496
for where the problem is.


151
00:08:35,716 --> 00:08:37,756
The kernel's just going to
tell you you did something bad.


152
00:08:39,246 --> 00:08:43,666
To address this, we use
the C language typedefs


153
00:08:44,456 --> 00:08:46,776
that are 64 and 32-bit cleaned.


154
00:08:46,776 --> 00:08:49,596
We say we want a signed
integer, an unsigned integer,


155
00:08:49,816 --> 00:08:53,086
that is an appropriate type
for saving a pointer value


156
00:08:53,386 --> 00:08:55,306
or for indexing into an array


157
00:08:55,746 --> 00:08:58,466
for comparing the differences
between two pointers.


158
00:08:59,446 --> 00:09:02,026
For example, if we would
modify our previous code


159
00:09:02,026 --> 00:09:05,566
to simply use the intptr type,
which when we're compiling


160
00:09:05,566 --> 00:09:08,726
for 32-bit iOS, will we
get 32-bit signed integer,


161
00:09:09,126 --> 00:09:13,726
and for 64-bit iOS will be
a 64-bit signed integer.


162
00:09:14,456 --> 00:09:18,686
Slightly more subtly, this can
come up in structure layouts.


163
00:09:19,496 --> 00:09:23,266
When we use a long or pointer
these now grow, which change


164
00:09:23,636 --> 00:09:26,236
but the size and
sometimes the alignment,


165
00:09:26,236 --> 00:09:28,836
the offsets of other
fields in our structures.


166
00:09:29,486 --> 00:09:30,576
And, we have to be careful


167
00:09:30,576 --> 00:09:32,646
that this is done in
a way that's safe.


168
00:09:33,876 --> 00:09:36,586
Now, most of time this is
going to work transparently,


169
00:09:36,586 --> 00:09:38,856
because these structures
are used entirely


170
00:09:38,856 --> 00:09:40,236
within our application


171
00:09:40,236 --> 00:09:42,926
and everything gets the new
definition and works fine.


172
00:09:44,146 --> 00:09:46,806
But, if we're doing something
like a representation


173
00:09:46,806 --> 00:09:50,556
of an on-disk file format
communicating across a network


174
00:09:50,556 --> 00:09:54,436
to another process that is going
to rely on the exact layout


175
00:09:54,436 --> 00:09:58,056
of a structure, that
can go badly.


176
00:09:58,056 --> 00:10:01,086
So again, on any of those
data structures we want


177
00:10:01,086 --> 00:10:07,496
to use the C fixed type,
fixed size types to make sure


178
00:10:07,496 --> 00:10:09,316
that we get what we want,
whether we're building


179
00:10:09,316 --> 00:10:12,876
for 64-bit iOS or
for 32-bit iOS.


180
00:10:14,756 --> 00:10:18,166
So in summary, building
for 64-bit iOS is easy,


181
00:10:18,636 --> 00:10:23,596
it's a default, and the
compiler will help find


182
00:10:23,596 --> 00:10:25,136
and resolve any issues.


183
00:10:26,116 --> 00:10:29,736
But, this isn't the only
thing that we've been up to.


184
00:10:29,816 --> 00:10:33,056
We've also been making
advances in Objective-C


185
00:10:34,086 --> 00:10:36,596
and the compiler
can help here, too.


186
00:10:37,996 --> 00:10:39,906
The language has
continued to move forward.


187
00:10:40,386 --> 00:10:43,166
Some of this really helps with
the interoperability with SWF


188
00:10:43,286 --> 00:10:46,006
as well, as you may be
seeing in that talk.


189
00:10:46,006 --> 00:10:47,656
I highly encourage
you to check it out.


190
00:10:47,656 --> 00:10:50,116
It's happening at the same time
as this one, so go and look


191
00:10:50,116 --> 00:10:53,516
on the video when that
comes on the WWDC app.


192
00:10:53,566 --> 00:10:59,776
And, whenever we write new
code, we've been using all


193
00:10:59,776 --> 00:11:02,046
of these advancements
in the language


194
00:11:02,626 --> 00:11:05,436
to get the modern best
practices, more expressive code,


195
00:11:05,436 --> 00:11:10,386
but then we have all of this
older legacy code that we'd


196
00:11:10,386 --> 00:11:12,776
like to adopt all of these
features in, as well.


197
00:11:13,026 --> 00:11:15,436
But, that's a lot of
code to go read through


198
00:11:15,436 --> 00:11:19,216
and manually find all of these
things, so we have a tool


199
00:11:19,216 --> 00:11:22,196
that will help us
identify the opportunities


200
00:11:22,746 --> 00:11:24,686
where we can use
these new features.


201
00:11:24,926 --> 00:11:28,496
And, I think the best
way to talk about that is


202
00:11:28,496 --> 00:11:32,066
to show you with the demo.


203
00:11:32,686 --> 00:11:37,576
Now, rather than use some
contrived example code here,


204
00:11:37,576 --> 00:11:39,376
I thought we'd maybe
look at something


205
00:11:39,376 --> 00:11:40,966
that we all are familiar with,


206
00:11:40,966 --> 00:11:44,326
at least as users,
and our WWDC app.


207
00:11:45,236 --> 00:11:47,246
That code has been
with us for a while.


208
00:11:47,246 --> 00:11:48,696
We update it every year.


209
00:11:49,126 --> 00:11:53,326
And, with the modernizer we
wanted to use that to look at it


210
00:11:53,326 --> 00:11:55,986
and find out if there
are perhaps some places


211
00:11:55,986 --> 00:11:58,486
in the codebase that we
missed for opportunities


212
00:11:59,496 --> 00:12:01,516
to use new Objective-C features.


213
00:12:02,396 --> 00:12:04,786
So, let's look and
see what a few


214
00:12:04,786 --> 00:12:06,396
of those things that
we found are.


215
00:12:06,876 --> 00:12:11,246
If we go under Edit to refactor,
we can convert our project


216
00:12:11,356 --> 00:12:13,246
to modern Objective-C syntax.


217
00:12:14,136 --> 00:12:16,796
We get a dialog box telling
us what we've just selected,


218
00:12:16,896 --> 00:12:18,676
so make sure that we've
got the right thing.


219
00:12:20,476 --> 00:12:21,486
We can select whether --


220
00:12:21,566 --> 00:12:23,886
which targets in our
project to modernize.


221
00:12:23,886 --> 00:12:26,876
In this case, we're looking
at the WWDC app, itself.


222
00:12:27,476 --> 00:12:32,406
In the previous versions of
Xcode, the modernizer would go


223
00:12:32,466 --> 00:12:33,716
through and just look


224
00:12:33,806 --> 00:12:36,246
for Objective-C literals
and subscripting.


225
00:12:36,246 --> 00:12:38,596
But now, we have more options.


226
00:12:39,606 --> 00:12:42,476
Now personally, I prefer not
to do all of these at once.


227
00:12:42,476 --> 00:12:45,566
That tends to be a little too
much to swap back-and-forth,


228
00:12:45,596 --> 00:12:48,156
so I tend to want to
select a few things.


229
00:12:48,446 --> 00:12:51,616
I'm going to look for
instance type here


230
00:12:51,616 --> 00:12:53,866
that we can get our
initialization methods more


231
00:12:53,866 --> 00:12:54,616
strongly typed.


232
00:12:54,616 --> 00:12:58,596
I'm going to try and find if we
missed any read/write properties


233
00:12:58,596 --> 00:13:01,726
where we convert explicit
getter/setter methods.


234
00:13:02,316 --> 00:13:05,116
And, we're going to
look to use NS ENUM


235
00:13:05,496 --> 00:13:08,766
for our enumeration values
so the compiler can cooperate


236
00:13:08,766 --> 00:13:11,156
with the runtime to
give better results.


237
00:13:12,246 --> 00:13:16,736
Click Next, and the compiler
will run over our code


238
00:13:16,986 --> 00:13:20,216
and it turns out we do, indeed,
have a few more suggestions


239
00:13:20,216 --> 00:13:21,506
for what we can look at.


240
00:13:22,176 --> 00:13:25,016
Now, do keep in mind that
these are just suggestions,


241
00:13:25,866 --> 00:13:27,406
that we need to go
through and look


242
00:13:27,406 --> 00:13:30,656
at the side-by-side diff here,
where we have the new code


243
00:13:30,656 --> 00:13:35,026
on the left, the old code on the
right, and we look through here.


244
00:13:35,026 --> 00:13:36,226
This looks fine.


245
00:13:36,926 --> 00:13:38,196
Everything looks good here.


246
00:13:38,196 --> 00:13:39,556
We're converting to ENUMS.


247
00:13:40,066 --> 00:13:42,096
Let's look at our next one.


248
00:13:42,936 --> 00:13:46,036
This looks a little
bit different,


249
00:13:46,036 --> 00:13:50,686
because we still have this NS
integer over here that looks


250
00:13:50,686 --> 00:13:52,196
like it'd be straightforward
to clean up,


251
00:13:52,196 --> 00:13:54,116
but I'd rather come
back to this later.


252
00:13:54,116 --> 00:13:55,076
I just want to deal
with the things


253
00:13:55,076 --> 00:13:56,756
that we can do automatically
right now.


254
00:13:57,416 --> 00:14:00,546
So, I tell the modernizer
to discard that change.


255
00:14:00,996 --> 00:14:03,396
It wants to make sure
that I'm doing that.


256
00:14:03,396 --> 00:14:04,966
Yes, I am absolutely sure.


257
00:14:04,966 --> 00:14:07,396
I can do the same here.


258
00:14:08,876 --> 00:14:11,646
We could also tell it to ignore
all of the changes in this file


259
00:14:11,646 --> 00:14:12,846
with this Check button here.


260
00:14:13,406 --> 00:14:16,366
And now, it's also found a place


261
00:14:17,026 --> 00:14:18,396
where we can use
an instance type.


262
00:14:18,696 --> 00:14:23,296
And, that all looks good
so we tell it to save.


263
00:14:24,236 --> 00:14:26,086
And, Xcode will now
tell us that, "Oh!


264
00:14:26,086 --> 00:14:29,926
We can update our project as
well, and take snapshots."


265
00:14:30,376 --> 00:14:31,416
That sounds great.


266
00:14:31,416 --> 00:14:33,216
Let's let it do that
because backups are good.


267
00:14:33,216 --> 00:14:36,476
And now, our project is
saved, it's been rebuilt,


268
00:14:37,286 --> 00:14:42,416
and the Objective-C modernizer
works to update our code


269
00:14:42,416 --> 00:14:45,026
and help us find places
where we can take advantage


270
00:14:45,326 --> 00:14:46,216
of new features.


271
00:14:46,846 --> 00:14:51,046
But, this isn't the only
place that we've made advances


272
00:14:51,616 --> 00:14:55,086
for Objective-C and
for interoperability.


273
00:14:55,136 --> 00:14:58,886
And, to tell you more about that
I'd like to invite my friend


274
00:14:58,886 --> 00:15:00,036
and coworker, Bob Wilson.


275
00:15:00,246 --> 00:15:01,066
Thank you, Bob.


276
00:15:02,516 --> 00:15:07,576
[ Applause ]


277
00:15:08,076 --> 00:15:08,516
>> Thank you, Jim.


278
00:15:10,186 --> 00:15:12,006
So, modules are another way


279
00:15:12,096 --> 00:15:14,476
that LLVM can help
modernize your code.


280
00:15:14,726 --> 00:15:18,066
We introduced modules just last
year, but in cases you missed


281
00:15:18,066 --> 00:15:19,786
that let's start
with some background.


282
00:15:22,056 --> 00:15:24,896
So, before modules we
had precompiled headers,


283
00:15:25,136 --> 00:15:28,556
which are often an effective
way to speed up the compilation


284
00:15:28,556 --> 00:15:31,286
of your code, but they
do have some limitations.


285
00:15:32,196 --> 00:15:35,606
You can only have one
precompiled header at a time,


286
00:15:36,516 --> 00:15:39,536
and more importantly,
the whole approach


287
00:15:39,536 --> 00:15:43,156
of using a textual inclusion
of a header file as a way


288
00:15:43,156 --> 00:15:45,846
of importing a framework
is just fragile.


289
00:15:46,916 --> 00:15:48,396
We have a deal with the issue


290
00:15:48,396 --> 00:15:51,266
where a header file gets
included more than once


291
00:15:51,266 --> 00:15:52,406
in a single compilation.


292
00:15:53,606 --> 00:15:55,986
We have also a problem
of headers being fragile.


293
00:15:56,526 --> 00:15:59,346
And, what I mean by
that is that the meaning


294
00:15:59,346 --> 00:16:01,956
of the header can change
depending on the environment


295
00:16:02,236 --> 00:16:05,246
where it's imported, and let me
show you that with an example.


296
00:16:06,706 --> 00:16:09,936
So here, I've defined a macro
count to the value of 100,


297
00:16:10,266 --> 00:16:12,266
and then I import the
foundation framework.


298
00:16:13,256 --> 00:16:17,056
Now, inside the foundation
header there's an include


299
00:16:17,096 --> 00:16:18,586
for the NSArray definition.


300
00:16:19,346 --> 00:16:21,786
An NSArray has an
ivar, the count.


301
00:16:22,726 --> 00:16:26,896
So, the macro of count gets
substituted as literal text


302
00:16:27,356 --> 00:16:30,296
in that place and we end up
with completely broken code


303
00:16:30,296 --> 00:16:32,936
where instead of the ivar
name, we have a value of 100.


304
00:16:33,856 --> 00:16:35,876
This is what I mean by
headers being fragile.


305
00:16:37,296 --> 00:16:40,696
Modules solve this problem
by replacing the model


306
00:16:40,696 --> 00:16:43,996
of textual inclusion
with a semantic import.


307
00:16:44,326 --> 00:16:48,426
And, there's a lot more detail
about modules in the Advances


308
00:16:48,426 --> 00:16:50,956
in Objective-C presentation
from last year's WWDC


309
00:16:50,956 --> 00:16:52,556
and I encourage you to watch


310
00:16:52,556 --> 00:16:54,146
that if you're not
familiar with modules.


311
00:16:55,816 --> 00:16:58,466
Until now, modules have
only been available


312
00:16:58,516 --> 00:16:59,776
for the system frameworks.


313
00:17:01,106 --> 00:17:04,286
New in Xcode 6, you
can now define modules


314
00:17:04,476 --> 00:17:07,906
for your own frameworks as
well for C and Objective-C.


315
00:17:09,156 --> 00:17:11,866
Besides fixing the
problems we just looked at,


316
00:17:11,986 --> 00:17:13,356
this also gives you a way


317
00:17:13,356 --> 00:17:16,886
of importing your own
framework into your SWF code.


318
00:17:17,586 --> 00:17:19,286
And as Jim mentioned,
there's another session


319
00:17:19,286 --> 00:17:22,336
on integrating SWF with
Objective-C that I encourage you


320
00:17:22,336 --> 00:17:24,425
to watch the video to
learn more about that.


321
00:17:25,675 --> 00:17:27,556
So if you want to do this, how?


322
00:17:28,806 --> 00:17:29,986
It's really very easy.


323
00:17:30,946 --> 00:17:32,926
For most frameworks
it's possible


324
00:17:32,926 --> 00:17:35,656
to define a single
umbrella header


325
00:17:35,916 --> 00:17:38,126
that imports all of
the framework API.


326
00:17:38,606 --> 00:17:40,866
And, this is what we
recommend that you do


327
00:17:41,276 --> 00:17:43,976
as it is the easiest
way to adopt a module.


328
00:17:45,046 --> 00:17:48,046
Once you've done that, simply
go to the Xcode BUILD settings


329
00:17:48,256 --> 00:17:52,756
for your framework and in the
packaging section set Defines


330
00:17:52,756 --> 00:17:55,616
Module to Yes, and that's it.


331
00:17:55,616 --> 00:17:57,176
It really is very easy.


332
00:17:57,796 --> 00:17:59,896
Now, if you have a more
complicated framework


333
00:18:00,116 --> 00:18:03,516
where that single umbrella
header is not sufficient,


334
00:18:03,516 --> 00:18:05,146
you can use a custom module map.


335
00:18:05,946 --> 00:18:08,236
And, there's more
information to describe how


336
00:18:08,236 --> 00:18:09,846
that works on the LLVM website.


337
00:18:12,036 --> 00:18:14,506
After you've created a
module you'll want to use it.


338
00:18:15,396 --> 00:18:16,036
How do you do that?


339
00:18:17,226 --> 00:18:21,516
There's an @import keyword
followed by the module name


340
00:18:21,856 --> 00:18:24,076
that tells the compiler, "I
want to import this module."


341
00:18:24,726 --> 00:18:27,636
If you haven't had a
chance to update your code


342
00:18:27,636 --> 00:18:28,716
and you're still --


343
00:18:28,716 --> 00:18:31,726
have a #import to include
the umbrella header,


344
00:18:31,726 --> 00:18:33,986
the compiler's smart
enough to know


345
00:18:34,206 --> 00:18:37,416
that this is now a modular
framework and it will go ahead


346
00:18:37,416 --> 00:18:40,426
and treat that as an implicit
modular import anyway.


347
00:18:41,966 --> 00:18:45,516
So just as a guideline though,
we do recommend you use @import


348
00:18:46,396 --> 00:18:49,536
when you're importing your
framework into a separate target


349
00:18:49,536 --> 00:18:53,036
within your project just because
it makes it clear in the source


350
00:18:53,116 --> 00:18:56,326
that you really intend for
this to be a modular import.


351
00:18:57,646 --> 00:19:00,466
One exception to that is
within the implementation


352
00:19:00,466 --> 00:19:01,776
of your framework, itself.


353
00:19:02,476 --> 00:19:05,746
It doesn't make any sense to
import a framework into itself


354
00:19:05,746 --> 00:19:09,006
and so, in that case, you
really need to use #import


355
00:19:09,006 --> 00:19:11,096
to textually include
the framework headers,


356
00:19:11,276 --> 00:19:13,286
just within the implementation
of the framework.


357
00:19:14,846 --> 00:19:17,616
And, besides those guidelines,
we have a few other rules


358
00:19:17,616 --> 00:19:19,876
about modules that you
should be aware of.


359
00:19:20,286 --> 00:19:23,916
First, don't expose
any non-modular headers


360
00:19:23,916 --> 00:19:24,966
in your framework API.


361
00:19:26,186 --> 00:19:28,786
It's fine to import
another module, like Cocoa,


362
00:19:29,296 --> 00:19:32,266
but if I have an import of
something like Postgres.h,


363
00:19:32,266 --> 00:19:34,226
which presumably
is not a module,


364
00:19:34,986 --> 00:19:37,156
you can put that down
inside the implementation


365
00:19:37,156 --> 00:19:40,366
of your framework, but
don't expose it in the API.


366
00:19:42,596 --> 00:19:46,436
One other issue is that
modules can change the semantics


367
00:19:46,526 --> 00:19:47,146
of your code.


368
00:19:47,636 --> 00:19:50,386
We saw earlier the
problem of a fragile header


369
00:19:50,496 --> 00:19:53,676
where a macro definition
inadvertently broke the code.


370
00:19:54,206 --> 00:19:56,256
Sometimes you might want
to do this on purpose,


371
00:19:56,286 --> 00:19:59,236
and I'm showing here an example
where I've defined a macro,


372
00:19:59,336 --> 00:20:03,226
DEBUG, as a flag to enable
additional debugging APIs


373
00:20:03,896 --> 00:20:04,726
in my framework.


374
00:20:06,386 --> 00:20:08,806
By switching that
framework to be a module,


375
00:20:08,806 --> 00:20:10,846
the DEBUG macro defined


376
00:20:10,846 --> 00:20:13,066
in my source code no
longer has any effect,


377
00:20:13,196 --> 00:20:14,426
which is not what I wanted.


378
00:20:15,296 --> 00:20:17,726
Now, that limitation
only applies to macros


379
00:20:17,726 --> 00:20:19,716
that are defined
in the source code.


380
00:20:19,966 --> 00:20:22,066
So, if you really want to
do something like this,


381
00:20:22,546 --> 00:20:26,146
one alternative is to define
the macro on the command line


382
00:20:26,276 --> 00:20:27,726
or in the Xcode build settings.


383
00:20:30,086 --> 00:20:31,716
So, that is user-defined
modules.


384
00:20:31,906 --> 00:20:33,466
It's really pretty
straightforward


385
00:20:33,466 --> 00:20:36,096
in the common case, and it
gives you fast compilation,


386
00:20:36,436 --> 00:20:40,076
clear semantics, and a way of
interoperating with SWF code.


387
00:20:42,396 --> 00:20:44,826
So far, we've been
talking a lot about ways


388
00:20:44,826 --> 00:20:47,016
that LLVM helps you
modernize your code


389
00:20:47,016 --> 00:20:52,106
and adopt modern Objective-C
modules, but let's turn now


390
00:20:52,106 --> 00:20:53,346
and look at performance,


391
00:20:53,446 --> 00:20:55,566
which is the other theme
of this presentation.


392
00:20:56,846 --> 00:21:02,766
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6


393
00:21:03,316 --> 00:21:04,606
and it gives you a way


394
00:21:04,606 --> 00:21:07,206
of getting even more
performance out of your code.


395
00:21:08,436 --> 00:21:11,836
Let me give you an overall
high-level understanding


396
00:21:11,836 --> 00:21:13,396
of what this is about.


397
00:21:14,506 --> 00:21:17,426
One of the inherent
challenges for the compiler is


398
00:21:17,426 --> 00:21:19,656
that it has no way of
knowing what the input


399
00:21:19,656 --> 00:21:20,946
to your program is going to be.


400
00:21:21,356 --> 00:21:24,006
The only input to the
compiler is your source code.


401
00:21:25,176 --> 00:21:27,106
So, the compiler has to assume


402
00:21:27,366 --> 00:21:29,346
that all inputs are
equally likely.


403
00:21:30,506 --> 00:21:32,096
There are some cases
where it can guess


404
00:21:32,536 --> 00:21:35,116
that certain code paths will
be more common than others.


405
00:21:35,856 --> 00:21:39,346
For example, it can assume that
going through a loop is going


406
00:21:39,346 --> 00:21:41,516
to happen more often than
code outside of that loop.


407
00:21:42,246 --> 00:21:44,246
But, those are just guesses
and there are a lot of things


408
00:21:44,246 --> 00:21:45,496
that it simply can't know.


409
00:21:47,286 --> 00:21:50,616
If we provide a profile
as an additional input


410
00:21:50,616 --> 00:21:55,486
to the compiler it can now try
to optimize for the common case


411
00:21:55,816 --> 00:21:58,736
and do a better job
of optimization.


412
00:21:59,216 --> 00:22:01,036
And, what I mean
by a profile, here,


413
00:22:01,226 --> 00:22:03,876
is simply a count how
many times each statement


414
00:22:03,876 --> 00:22:08,366
in your app executes in a
typical run of your app.


415
00:22:09,086 --> 00:22:12,086
You may be wondering, "How do
I get a profile like that?"


416
00:22:12,466 --> 00:22:14,166
Again, we could use
the compiler here


417
00:22:14,826 --> 00:22:17,616
to generate a special
instrumented app


418
00:22:17,676 --> 00:22:19,316
that as it runs is going


419
00:22:19,316 --> 00:22:22,276
to count how many times
each statement executes.


420
00:22:22,606 --> 00:22:24,146
And then, when your app finishes


421
00:22:24,146 --> 00:22:26,676
with this special instrumented
version, it will write


422
00:22:26,676 --> 00:22:29,706
out that profile which
we can then use for PGO.


423
00:22:31,896 --> 00:22:34,936
So, how does the compiler
use that profile information?


424
00:22:35,736 --> 00:22:37,106
There are an awful lot of ways.


425
00:22:37,236 --> 00:22:39,636
So many optimizations
can benefit from this,


426
00:22:40,326 --> 00:22:41,916
but I'm highlighting
just three here


427
00:22:41,916 --> 00:22:43,316
that are particularly valuable.


428
00:22:43,946 --> 00:22:45,046
One is to the inliner.


429
00:22:46,066 --> 00:22:48,166
If we know that a
function is really hot,


430
00:22:48,166 --> 00:22:50,706
and by that I mean it's
run a lot, over and over.


431
00:22:51,256 --> 00:22:54,936
The inliner can be much more
aggressive about inlining that.


432
00:22:55,226 --> 00:22:57,016
When we're generating
the code we can try


433
00:22:57,016 --> 00:22:59,696
to layout the common
paths through your code


434
00:23:00,126 --> 00:23:02,246
so that they're contiguous,
which makes it easy


435
00:23:02,246 --> 00:23:04,156
for the processor
to run them fast.


436
00:23:04,986 --> 00:23:08,006
And the register allocator
can also try to keep values


437
00:23:08,066 --> 00:23:12,466
in registers throughout
those most common paths.


438
00:23:12,766 --> 00:23:14,006
Let's look at an example just


439
00:23:14,006 --> 00:23:16,306
to give you a better
understanding of this.


440
00:23:16,836 --> 00:23:20,286
This is some C++ code that's
going to iterate over a set


441
00:23:20,286 --> 00:23:22,306
of colored objects and
for each one it's going


442
00:23:22,306 --> 00:23:24,146
to update the position
of the object.


443
00:23:24,596 --> 00:23:27,646
So, at the top I've got
a loop over the objects,


444
00:23:28,206 --> 00:23:29,016
and for each one I'm going


445
00:23:29,016 --> 00:23:30,956
to call my Update
Position function.


446
00:23:32,066 --> 00:23:33,906
And, Update Position is
going to look and see


447
00:23:34,166 --> 00:23:38,206
if the object is red it moves in
a very simple horizontal line,


448
00:23:38,206 --> 00:23:39,456
so the code is really simple.


449
00:23:40,146 --> 00:23:42,266
But, if the object
is blue, let's assume


450
00:23:42,516 --> 00:23:44,696
that the movement is
much more complicated,


451
00:23:44,696 --> 00:23:46,796
I've got a very large
block of code here.


452
00:23:48,126 --> 00:23:51,416
Now, the compiler has no way
of knowing whether red objects


453
00:23:51,416 --> 00:23:53,216
or blue objects are more likely,


454
00:23:53,256 --> 00:23:56,196
so it just assumes they're
both equally likely.


455
00:23:56,196 --> 00:23:59,856
But, with PGO I might
be able to know


456
00:23:59,856 --> 00:24:02,796
that red objects
are far more common.


457
00:24:03,326 --> 00:24:05,906
And so, I'm highlighting
in red here the hot code,


458
00:24:06,346 --> 00:24:09,116
which is the code to iterate
over the set of objects and then


459
00:24:09,116 --> 00:24:10,546
to handle the red objects.


460
00:24:11,536 --> 00:24:14,986
I'm going to color-code
the cold code in blue,


461
00:24:15,016 --> 00:24:16,736
which is blue objects
which are rare


462
00:24:16,736 --> 00:24:18,346
for some reason in
this application.


463
00:24:19,216 --> 00:24:22,056
And then, let's look at how the
compiler would handle this code.


464
00:24:24,016 --> 00:24:27,786
Here's kind of the default code
layout that matches, roughly,


465
00:24:27,786 --> 00:24:29,286
the original source order.


466
00:24:29,606 --> 00:24:31,416
We've got the hot loop outside,


467
00:24:31,416 --> 00:24:34,346
and then the Update
Position function down below,


468
00:24:34,556 --> 00:24:37,536
with a little bit
of hot code in it.


469
00:24:38,486 --> 00:24:41,606
Inlining is one of the most
important optimizations


470
00:24:42,346 --> 00:24:45,826
and we'd really like to inline
that Update Position function.


471
00:24:46,226 --> 00:24:48,686
But, the compiler
can't inline everything


472
00:24:49,266 --> 00:24:52,586
or the code would bloat beyond a
point where it would be useful.


473
00:24:53,796 --> 00:24:57,006
But in this case, the Update
Position function is big


474
00:24:57,046 --> 00:24:59,916
because of all that cold code
for handling the blue objects


475
00:25:00,876 --> 00:25:02,646
and so it wouldn't
normally be inlined.


476
00:25:02,956 --> 00:25:05,866
But, because PGO tells us
there's some really hot code


477
00:25:05,866 --> 00:25:09,896
here, the inliner can be much
more aggressive about that


478
00:25:09,896 --> 00:25:11,216
in this particular case.


479
00:25:11,936 --> 00:25:16,046
So, we take the loop iterating
over the objects and split


480
00:25:16,046 --> 00:25:20,546
that in half and move the Update
Position code right inline.


481
00:25:21,416 --> 00:25:22,706
So, this is much better now.


482
00:25:22,706 --> 00:25:25,406
We've got a lot of the
hot code right together,


483
00:25:25,406 --> 00:25:29,966
but we've still got a big chunk
of this code for blue objects,


484
00:25:29,966 --> 00:25:31,816
the cold code, right in
the middle of our loop.


485
00:25:32,696 --> 00:25:36,596
And, PGO can help this, as well,
by changing the code layout.


486
00:25:36,926 --> 00:25:40,456
It knows that that code is cold
and can move it down below,


487
00:25:40,456 --> 00:25:43,436
out of the way, and we end
up with a nice tight loop


488
00:25:43,746 --> 00:25:45,016
that can run really fast.


489
00:25:45,536 --> 00:25:48,906
And, it also typically
enables other optimizations


490
00:25:48,906 --> 00:25:49,906
on that hot code.


491
00:25:51,146 --> 00:25:53,416
So obviously, this is
a simplified example,


492
00:25:53,416 --> 00:25:56,216
but hopefully gives you a
feel of the power of PGO


493
00:25:56,216 --> 00:25:58,486
and just how much it
can help the optimizer.


494
00:26:00,056 --> 00:26:01,606
So, you may want to use it.


495
00:26:02,406 --> 00:26:03,496
When does it make sense?


496
00:26:04,406 --> 00:26:07,746
The compiler does a really
good job optimizing by default.


497
00:26:08,916 --> 00:26:11,636
With PGO, if you do just
a little bit of extra work


498
00:26:11,856 --> 00:26:15,146
to gather the profile,
you can do even better.


499
00:26:15,826 --> 00:26:17,666
So obviously, if you're happy


500
00:26:17,666 --> 00:26:19,616
with the performance
you're already getting,


501
00:26:20,126 --> 00:26:21,806
you're probably not
motivated to do that --


502
00:26:22,036 --> 00:26:23,506
even that little
bit of extra work.


503
00:26:23,936 --> 00:26:25,966
But, if you need
more performance,


504
00:26:26,486 --> 00:26:28,486
by all means, give it a try.


505
00:26:29,136 --> 00:26:31,066
And, let me show
you some examples


506
00:26:31,066 --> 00:26:32,436
of just how much it can help.


507
00:26:33,676 --> 00:26:36,886
This is a graph showing
the speedup.


508
00:26:36,886 --> 00:26:38,876
Compare it with PGO
compared to a case


509
00:26:38,876 --> 00:26:40,636
of just a normal optimize build.


510
00:26:41,446 --> 00:26:44,206
And, I'm looking at four
different applications here;


511
00:26:44,206 --> 00:26:47,516
the Apple LLVM compiler
itself, applying PGO


512
00:26:47,606 --> 00:26:50,766
to the compiler itself,
the SQLite database,


513
00:26:51,246 --> 00:26:53,596
the PERL interpreter, and
gzip file compression.


514
00:26:54,676 --> 00:26:56,736
And, PGO gives us
speedups ranging


515
00:26:56,736 --> 00:26:59,456
from about 4% all
the way up to 18%.


516
00:27:00,786 --> 00:27:02,806
So, not all apps will
benefit this much.


517
00:27:03,026 --> 00:27:04,646
It really varies,
depending on the app,


518
00:27:05,116 --> 00:27:07,426
but clearly there's a
lot of potential here.


519
00:27:09,676 --> 00:27:12,606
So, if you want to try it,
how do you go about that?


520
00:27:13,166 --> 00:27:15,016
PGO is really easy to use.


521
00:27:15,616 --> 00:27:17,476
The first step is to
collect a profile.


522
00:27:17,476 --> 00:27:20,186
I'm going to come back and talk
about that in just a minute.


523
00:27:21,286 --> 00:27:24,146
Once you've done that, simply
go in the Xcode Build settings


524
00:27:24,146 --> 00:27:27,676
for your project and find
the Use Optimization Profile


525
00:27:27,676 --> 00:27:30,096
setting, and set it
to Yes, typically just


526
00:27:30,096 --> 00:27:31,446
for the release configuration.


527
00:27:32,216 --> 00:27:32,886
And that's it!


528
00:27:32,886 --> 00:27:34,576
You've enabled PGO.


529
00:27:35,696 --> 00:27:36,576
Once you've done that,


530
00:27:36,576 --> 00:27:39,326
as you continue developing
your app you may change it


531
00:27:39,326 --> 00:27:41,176
as you fix bugs, you
add new features,


532
00:27:41,876 --> 00:27:44,336
the code becomes
gradually out of sync


533
00:27:44,336 --> 00:27:46,136
with the profile you've
collected earlier.


534
00:27:47,096 --> 00:27:50,996
And, when that happens, the
compiler will simply fail to use


535
00:27:50,996 --> 00:27:52,486
that profile information.


536
00:27:52,486 --> 00:27:53,636
It won't break anything,


537
00:27:53,636 --> 00:27:56,666
you just gradually lose
the optimization benefit.


538
00:27:56,666 --> 00:27:58,986
And when that happens, it
will give you a warning.


539
00:27:59,966 --> 00:28:01,636
So, if you see warnings
like this,


540
00:28:01,636 --> 00:28:04,866
saying that your profile may
be out of date, as you see more


541
00:28:04,866 --> 00:28:06,866
and more of them, it's a good
indication to you that's time


542
00:28:06,866 --> 00:28:09,376
to go back and update
your profile.


543
00:28:10,726 --> 00:28:13,876
So, let's turn now and look at,
how do you generate the profile?


544
00:28:15,166 --> 00:28:19,406
Xcode 6 has a new command,
Generate Optimization Profile.


545
00:28:20,096 --> 00:28:21,176
When you run this command,


546
00:28:21,376 --> 00:28:24,316
Xcode will build the special
instrumented version of your app


547
00:28:24,316 --> 00:28:27,096
and then run it, and
you can then interact


548
00:28:27,096 --> 00:28:29,506
with the running app to
generate the profile.


549
00:28:29,506 --> 00:28:31,616
When it finishes running, it
will write out the profile


550
00:28:31,616 --> 00:28:32,956
and add it to your project.


551
00:28:34,316 --> 00:28:37,156
As you're running your app,
keep in mind it's important


552
00:28:37,156 --> 00:28:40,056
to exercise all of the
code that's important


553
00:28:40,056 --> 00:28:41,076
for your performance.


554
00:28:41,626 --> 00:28:43,906
If I have a game with
three different levels


555
00:28:44,416 --> 00:28:47,966
and I only play the first level
of my game, the compiler's going


556
00:28:47,966 --> 00:28:49,856
to assume that that's the
only thing that really matters


557
00:28:49,856 --> 00:28:52,096
and not work as hard
on the other levels.


558
00:28:54,356 --> 00:28:57,166
Now, you may be wondering, "If
I've written a really hard game,


559
00:28:57,936 --> 00:29:00,746
it may take a while to play
the whole thing to completion."


560
00:29:01,396 --> 00:29:03,476
That could be a problem, right?


561
00:29:03,546 --> 00:29:05,966
So, Xcode has another option,


562
00:29:07,116 --> 00:29:10,076
which is to use your
performance tests as inputs


563
00:29:10,076 --> 00:29:11,286
to drive the profiling.


564
00:29:12,496 --> 00:29:15,296
Performance tests are a
new feature in Xcode 6.


565
00:29:15,796 --> 00:29:17,246
If you'd like to
learn more about them,


566
00:29:17,376 --> 00:29:19,096
there's a session right
here tomorrow morning


567
00:29:19,096 --> 00:29:20,756
on testing in Xcode 6.


568
00:29:21,586 --> 00:29:25,436
And, if you care about
performance you want to set


569
00:29:25,436 --> 00:29:28,406
up these performance tests
anyway, to catch regressions


570
00:29:28,406 --> 00:29:30,406
in your code, just to keep
track of how you're doing.


571
00:29:31,296 --> 00:29:34,276
And once you've gone to
that trouble to set them up,


572
00:29:34,776 --> 00:29:36,906
in most cases they're
pretty good inputs


573
00:29:36,906 --> 00:29:38,176
for driving this profile.


574
00:29:40,106 --> 00:29:42,396
Again though, keep in
mind it's important


575
00:29:42,596 --> 00:29:45,116
that your tests cover
the code in a way


576
00:29:45,116 --> 00:29:47,566
that reflects the
typical usage of your app.


577
00:29:47,946 --> 00:29:51,066
Going back to my three-level
game, if I write lots of tests


578
00:29:51,066 --> 00:29:53,356
for the first level and
only a few for the second


579
00:29:53,356 --> 00:29:56,006
and third level, again,
the compiler's going to end


580
00:29:56,006 --> 00:29:59,216
up optimizing more heavily
for that first level.


581
00:30:00,656 --> 00:30:03,416
Another benefit of using tests
is it gives you a great way


582
00:30:03,746 --> 00:30:06,306
of evaluating, how
much does PGO help me?


583
00:30:06,306 --> 00:30:07,726
You can just run your tests.


584
00:30:08,086 --> 00:30:10,286
Now, let me show you
that with a demo now.


585
00:30:12,376 --> 00:30:14,556
So, with the release
of the SWF language,


586
00:30:15,286 --> 00:30:18,026
we thought it would be
fun to make a demo app


587
00:30:18,026 --> 00:30:19,016
that would celebrate that.


588
00:30:19,986 --> 00:30:21,566
And so, rather than
the SWF language,


589
00:30:21,566 --> 00:30:25,056
we thought of the SWF birds
and we made an application


590
00:30:25,196 --> 00:30:28,326
that uses the Boids
Artificial Life Simulation


591
00:30:29,326 --> 00:30:30,816
to simulate a flock of SWFs.


592
00:30:33,146 --> 00:30:35,206
And, I can create a
whole bunch of them here


593
00:30:35,206 --> 00:30:36,436
and let them fly around.


594
00:30:36,516 --> 00:30:40,686
And, the way this Boids
application works is


595
00:30:40,686 --> 00:30:44,986
that each bird, or Boid,
compares its position to all


596
00:30:44,986 --> 00:30:48,346
of the other ones on the screen
and it calculates the distance


597
00:30:48,346 --> 00:30:52,066
between them to find the flock
of the birds nearest to it.


598
00:30:53,016 --> 00:30:57,136
And then, each Boid
has competing urges.


599
00:30:57,136 --> 00:30:59,446
On the one hand, it
wants to move closer


600
00:30:59,446 --> 00:31:00,696
to the center of the flock.


601
00:31:00,696 --> 00:31:03,886
At the same time, it doesn't
want to get too close.


602
00:31:04,676 --> 00:31:08,986
And so, if it gets too close to
another one it will move apart.


603
00:31:10,066 --> 00:31:12,946
And the performance of that,
as we add more and more


604
00:31:12,946 --> 00:31:15,666
of these Boids, could
become a problem.


605
00:31:16,466 --> 00:31:20,086
So, we set up a performance
test to track that,


606
00:31:20,936 --> 00:31:24,216
and this is a really
simple performance test.


607
00:31:25,576 --> 00:31:29,296
We set up a scene with 200 Boids
and measured the time it takes


608
00:31:29,296 --> 00:31:31,686
to update their positions
100 times,


609
00:31:31,686 --> 00:31:32,816
and that's our performance test.


610
00:31:32,816 --> 00:31:33,716
So, let's run that.


611
00:31:34,476 --> 00:31:36,376
Because I care about
performance,


612
00:31:36,816 --> 00:31:39,806
I'm going to edit my
current scheme to make sure


613
00:31:39,806 --> 00:31:41,656
that my test step is going


614
00:31:41,656 --> 00:31:44,186
to use the release-built
configuration


615
00:31:44,586 --> 00:31:46,436
so that we get optimized
results.


616
00:31:47,616 --> 00:31:49,726
And, I'll go to the
Product Test menu


617
00:31:51,376 --> 00:31:53,096
and run my performance
test here.


618
00:31:57,526 --> 00:31:57,936
All right.


619
00:31:58,086 --> 00:32:00,486
And now, because I haven't run
the test before I don't have a


620
00:32:00,536 --> 00:32:02,086
baseline, so let's go ahead


621
00:32:02,086 --> 00:32:06,536
and set the baseline
based on that first run.


622
00:32:07,666 --> 00:32:10,366
And now, let's try adding PGO.


623
00:32:11,256 --> 00:32:13,636
Under the Product
menu, Perform Action,


624
00:32:14,246 --> 00:32:16,636
down at the bottom here is this
new command I told you about,


625
00:32:16,636 --> 00:32:18,496
Generate Optimization Profile.


626
00:32:19,136 --> 00:32:22,516
I get two choices; I can
either run the application


627
00:32:23,616 --> 00:32:25,446
or I can use my performance
test.


628
00:32:25,446 --> 00:32:28,016
And, I'd like to show you how it
works with the performance test.


629
00:32:29,026 --> 00:32:33,256
I just click Build and Run,
and Xcode, very helpfully,


630
00:32:33,396 --> 00:32:35,906
warns me that I haven't
yet enabled PGO


631
00:32:35,906 --> 00:32:38,616
in the Build settings
and it offers to do that.


632
00:32:38,616 --> 00:32:41,196
So, let's go ahead and
let it enable that.


633
00:32:41,486 --> 00:32:44,236
It's now building a special
instrumented version of our app


634
00:32:44,236 --> 00:32:48,736
and running it using
the performance test.


635
00:32:49,136 --> 00:32:50,406
And when those tests finish --


636
00:32:52,516 --> 00:32:55,436
ah, I got a warning
here, an error.


637
00:32:55,436 --> 00:32:57,586
Let me just explain
what's happened here is


638
00:32:57,616 --> 00:33:00,016
that because we've
run the app with a lot


639
00:33:00,016 --> 00:33:02,966
of the instrumentation
code, it runs more slowly.


640
00:33:03,246 --> 00:33:05,616
But, this is just being
used to generate the profile


641
00:33:05,616 --> 00:33:06,656
so that's not a problem.


642
00:33:07,026 --> 00:33:10,016
I'm going to go back to the
Project Navigator a minute


643
00:33:10,616 --> 00:33:13,666
and show you that Xcode has
added this new Optimization


644
00:33:13,666 --> 00:33:14,836
Profiles folder.


645
00:33:15,446 --> 00:33:18,806
And inside of that, if you can
see it, there's my profile data.


646
00:33:20,066 --> 00:33:20,826
So, that's great!


647
00:33:21,416 --> 00:33:23,776
PGO is enabled, we
have a profile.


648
00:33:23,776 --> 00:33:25,676
Let's rerun those
performance tests.


649
00:33:26,276 --> 00:33:27,786
We'll go back to
run Product Test,


650
00:33:28,946 --> 00:33:30,156
and see how much does it help?


651
00:33:30,156 --> 00:33:34,956
And the tests are running now.


652
00:33:36,376 --> 00:33:39,036
And, wow, we got a 21%
improvement just like that.


653
00:33:39,386 --> 00:33:41,696
We didn't have to change the
code or do anything else.


654
00:33:42,516 --> 00:33:49,286
[ Applause ]


655
00:33:49,786 --> 00:33:51,276
So, that is PGO.


656
00:33:51,626 --> 00:33:54,836
It's a great new feature to help
you get even more performance,


657
00:33:54,946 --> 00:33:57,346
when you care about
getting every last drop


658
00:33:57,346 --> 00:33:58,006
out of your code.


659
00:33:59,136 --> 00:34:01,186
Continuing on this
theme of performance,


660
00:34:01,266 --> 00:34:04,736
I'd like to turn the stage over
to Nadav Rotem, my colleague,


661
00:34:04,736 --> 00:34:08,936
to talk about advances
in vectorization.


662
00:34:09,536 --> 00:34:09,966
>> Thank you, Bob.


663
00:34:10,565 --> 00:34:10,735
Hi.


664
00:34:11,516 --> 00:34:16,476
[ Applause ]


665
00:34:16,976 --> 00:34:21,896
So, Last year with Xcode 5 we've
introduced a new optimization


666
00:34:22,186 --> 00:34:23,856
called loop vectorization.


667
00:34:24,156 --> 00:34:28,485
And, I would like to remind
you what loop vectorization is.


668
00:34:29,085 --> 00:34:33,186
So, modern processors
have vector instructions.


669
00:34:33,616 --> 00:34:37,025
These instructions can process
multiple scalars at once.


670
00:34:37,505 --> 00:34:40,406
And loop vectorization is
the compiler optimization


671
00:34:40,766 --> 00:34:43,866
that accelerates loops using
these vector instructions.


672
00:34:44,866 --> 00:34:45,735
And let's see how it's done.


673
00:34:46,295 --> 00:34:48,266
If you can see the code
on the screen here,


674
00:34:48,266 --> 00:34:49,656
you'll see that it's
a simple program


675
00:34:50,266 --> 00:34:52,716
that accumulates all
the numbers in the array


676
00:34:53,025 --> 00:34:54,436
into one variable, into sum.


677
00:34:54,496 --> 00:34:59,016
And, the natural way of
executing this code is


678
00:34:59,016 --> 00:35:02,366
to load one number at a time and
save it into the variable sum.


679
00:35:02,426 --> 00:35:04,586
And then, load another
number and save it into sum.


680
00:35:05,236 --> 00:35:07,736
But, there's the better
way of executing this code.


681
00:35:09,076 --> 00:35:11,856
What the loop vector does
for you automatically,


682
00:35:12,186 --> 00:35:15,596
is that it introduces a new
temporary variable, temp4.


683
00:35:15,596 --> 00:35:19,436
Now, this is a vector register,
a vector temporary variable.


684
00:35:20,576 --> 00:35:23,586
And, this allows us to
load four numbers at a time


685
00:35:23,856 --> 00:35:25,246
and add four numbers at a time,


686
00:35:25,556 --> 00:35:26,766
and we do it for
the entire array.


687
00:35:27,206 --> 00:35:29,136
So, this is obviously
much faster


688
00:35:29,136 --> 00:35:32,236
because we're processing
four numbers at once instead


689
00:35:32,236 --> 00:35:34,896
of processing one
number at a time.


690
00:35:35,036 --> 00:35:37,416
And, when you finish
scanning the array we need


691
00:35:37,416 --> 00:35:40,186
to take the four numbers
from that temporary register


692
00:35:40,186 --> 00:35:42,076
and add them together,
but it doesn't matter


693
00:35:42,076 --> 00:35:43,826
because usually an
array is pretty big.


694
00:35:44,836 --> 00:35:48,716
So, this is how loop
vectorization accelerates loops


695
00:35:48,716 --> 00:35:49,846
and makes your code run faster


696
00:35:49,956 --> 00:35:51,466
so that you don't have
to change your code.


697
00:35:52,696 --> 00:35:56,956
So, in Xcode 6 we've improved
loop vectorization in a number


698
00:35:56,956 --> 00:35:58,726
of ways, where first of all,


699
00:35:59,006 --> 00:36:01,126
we've improved the analysis
of complicated loops.


700
00:36:01,716 --> 00:36:03,976
This means that the
LLVM will be able


701
00:36:03,976 --> 00:36:07,906
to analyze more complicated
loops and vectorize more loops


702
00:36:07,906 --> 00:36:09,326
in your code, which is great.


703
00:36:09,696 --> 00:36:12,696
We've also integrated the
Loop Vectorizer with PGO,


704
00:36:12,696 --> 00:36:14,146
that Bob just mentioned.


705
00:36:14,596 --> 00:36:18,166
So, this means that when PGO is
available the Loop Vectorizer


706
00:36:18,236 --> 00:36:19,896
will be able to make
better decisions


707
00:36:20,406 --> 00:36:21,436
when vectorizing your code.


708
00:36:22,436 --> 00:36:27,016
We've also improved the X86
and ARM64 in coding support.


709
00:36:27,096 --> 00:36:28,066
Now this means two things.


710
00:36:28,766 --> 00:36:31,616
First of all, the Loop
Vectorizer has a better


711
00:36:31,616 --> 00:36:35,096
understanding of the processor
so it can predict better


712
00:36:35,376 --> 00:36:37,806
when it is profitable
to vectorize your codes.


713
00:36:38,226 --> 00:36:40,266
And the second thing
that it means is


714
00:36:40,266 --> 00:36:44,096
that when it vectorize your
code it'll generate better,


715
00:36:44,096 --> 00:36:46,216
more optimized code sequences,


716
00:36:46,286 --> 00:36:47,756
so that your code
would run faster.


717
00:36:49,926 --> 00:36:51,576
And, the last feature
that I want to talk to you


718
00:36:51,576 --> 00:36:54,156
about is specialization
of loop variables.


719
00:36:56,896 --> 00:37:02,946
So, most variables in your
code are only known at runtime.


720
00:37:03,796 --> 00:37:09,396
These variables can be arguments
or computed expressions,


721
00:37:09,396 --> 00:37:12,356
and compiler doesn't know
the values of these variables


722
00:37:12,656 --> 00:37:15,076
at compile time,
only at runtime.


723
00:37:16,186 --> 00:37:17,776
And in many times,


724
00:37:18,176 --> 00:37:21,556
the Vectorizer cannot vectorize
your code unless the value


725
00:37:21,556 --> 00:37:23,536
of these variables is
known to be constant.


726
00:37:24,146 --> 00:37:25,416
So, let's take a
look at the example


727
00:37:25,416 --> 00:37:26,266
that I showed you earlier.


728
00:37:26,496 --> 00:37:30,026
So, this is a simple loop and
I modified it a little bit


729
00:37:30,026 --> 00:37:32,066
and I introduced
the Step variable.


730
00:37:32,356 --> 00:37:36,196
So now, instead of consecutively
scanning all of the elements


731
00:37:36,196 --> 00:37:38,796
in the array, we jump
and skip some elements,


732
00:37:38,796 --> 00:37:41,216
and we go in step
of variable Step.


733
00:37:42,826 --> 00:37:44,366
Now, we can't vectorize
this code


734
00:37:44,366 --> 00:37:48,056
because these elements are
not consecutive in memory.


735
00:37:48,056 --> 00:37:51,466
We can't use these vector
registers to load a few elements


736
00:37:51,466 --> 00:37:52,766
and then add them together.


737
00:37:52,766 --> 00:37:56,266
It's won't work unless
Step is equal to one.


738
00:37:56,586 --> 00:37:59,236
Well, in many cases
Step is equal to one.


739
00:38:00,236 --> 00:38:01,046
So, what do we do?


740
00:38:01,726 --> 00:38:04,776
Well, we've introduced a
new optimization that's


741
00:38:04,776 --> 00:38:05,976
called Specialization.


742
00:38:06,706 --> 00:38:09,546
What we do is we create
multiple versions of the loop.


743
00:38:10,206 --> 00:38:13,036
In one version of the loop
we assume that step is equal


744
00:38:13,036 --> 00:38:15,176
to one, and then we
vectorize the code


745
00:38:15,896 --> 00:38:17,046
and make the code run faster.


746
00:38:17,946 --> 00:38:20,706
But, in another version of the
loop we don't assume anything


747
00:38:20,756 --> 00:38:24,316
and the code runs
as-is -- scalar.


748
00:38:25,396 --> 00:38:29,106
And then, we add code
for selecting at runtime


749
00:38:29,636 --> 00:38:31,586
which version of
the loop to run.


750
00:38:31,926 --> 00:38:35,056
If Step happened to
be one, then we go


751
00:38:35,056 --> 00:38:36,956
and execute the vectorized
version.


752
00:38:37,136 --> 00:38:38,286
But, if Step is not equal


753
00:38:38,286 --> 00:38:40,956
to one then we execute
the regular version.


754
00:38:41,236 --> 00:38:43,206
And this compiler,
this new feature,


755
00:38:43,206 --> 00:38:45,666
allows the Loop Vectorizer


756
00:38:45,736 --> 00:38:50,146
to vectorize a lot more
loops, and it's great.


757
00:38:50,146 --> 00:38:52,106
Okay. So, this was
loop vectorization.


758
00:38:52,626 --> 00:38:56,606
But, in Xcode 6 we've also added
a new kind of vectorization.


759
00:38:56,816 --> 00:38:59,916
This is -- this new vectorizer
is not a loop vectorizer.


760
00:39:00,206 --> 00:39:03,156
It's called SLP Vectorizer,
which stands


761
00:39:03,156 --> 00:39:05,386
for Superword Level Parallelism,


762
00:39:05,686 --> 00:39:08,646
and it extracts parallelism
beyond loops.


763
00:39:09,116 --> 00:39:11,726
What this SLP Vectorizer
does is that it looks


764
00:39:11,726 --> 00:39:15,426
for multiple scalars in your
code and it glues them together


765
00:39:15,426 --> 00:39:16,686
into vector instructions.


766
00:39:18,136 --> 00:39:20,496
Let's see how it's done.


767
00:39:21,696 --> 00:39:23,596
So, on the screen you
see a very simple struct.


768
00:39:24,476 --> 00:39:26,936
This struct has two
members, x and y.


769
00:39:27,596 --> 00:39:28,816
They're consecutive in memory.


770
00:39:29,766 --> 00:39:32,246
And, we have a simple
function that converts units


771
00:39:32,946 --> 00:39:34,326
from feet to centimeters.


772
00:39:34,496 --> 00:39:36,086
Now, this is a very
simple conversion.


773
00:39:36,136 --> 00:39:39,486
All we have to do is
load the x member,


774
00:39:39,486 --> 00:39:41,206
multiply it by a
constant, and do it again.


775
00:39:41,206 --> 00:39:42,246
And, we do the same thing for y.


776
00:39:42,576 --> 00:39:46,606
And of course, the natural
way of executing this code is


777
00:39:46,636 --> 00:39:49,746
to do it consecutively;
load variable x,


778
00:39:49,836 --> 00:39:51,646
multiply it, save it back.


779
00:39:52,736 --> 00:39:56,396
Load variable y, multiply
it, and save it back.


780
00:39:57,076 --> 00:39:59,556
But again, there's a
better way of doing it,


781
00:39:59,866 --> 00:40:01,956
and this is what the
SLP Vectorizer does.


782
00:40:02,486 --> 00:40:05,316
We can load x and y together
because they're consecutive


783
00:40:05,316 --> 00:40:09,026
in memory, multiply
them together again,


784
00:40:09,026 --> 00:40:10,316
and save them back to memory.


785
00:40:10,316 --> 00:40:13,366
And, this is SLP vectorization.


786
00:40:15,996 --> 00:40:20,766
SLP vectorization is very
beneficial for some kinds


787
00:40:20,766 --> 00:40:23,296
of applications, mainly
numeric applications,


788
00:40:23,296 --> 00:40:24,906
and we see great speedups.


789
00:40:25,186 --> 00:40:27,386
It may not speed
up all programs,


790
00:40:27,996 --> 00:40:30,096
but it definitely
speeds up a lot


791
00:40:30,166 --> 00:40:32,546
of numerically complex
applications.


792
00:40:33,816 --> 00:40:40,236
So to summarize, we've improved
loop vectorization in Xcode 6


793
00:40:40,526 --> 00:40:42,056
and we've introduced a new kind


794
00:40:42,056 --> 00:40:44,896
of vectorization called
SLP vectorization.


795
00:40:46,866 --> 00:40:49,676
Now in Xcode 5, when we
introduced the Loop Vectorizer,


796
00:40:49,916 --> 00:40:52,646
we did not enable it by default
and you had to go into one


797
00:40:52,646 --> 00:40:54,816
of the settings and
select Loop Vectorization


798
00:40:54,816 --> 00:40:56,186
and then Loop Vectorization
worked.


799
00:40:56,596 --> 00:40:59,426
Well, in Xcode 6 you
don't have to do anything


800
00:40:59,426 --> 00:41:02,136
because both the
new SLP Vectorizer


801
00:41:02,536 --> 00:41:05,776
and the improved Loop Vectorizer
are enabled by default


802
00:41:05,916 --> 00:41:08,036
when you build your
application in a release mode.


803
00:41:08,306 --> 00:41:09,746
This means that you don't
need to do anything.


804
00:41:09,746 --> 00:41:11,846
Just compile your
application in release mode


805
00:41:12,346 --> 00:41:15,016
and the improved LLVM will
make your code run faster.


806
00:41:18,916 --> 00:41:20,856
Okay. So, we talked
about a number


807
00:41:20,856 --> 00:41:23,036
of performance features in LLVM.


808
00:41:23,276 --> 00:41:25,486
We talked about PGO, we
talked about vectorization,


809
00:41:26,656 --> 00:41:29,696
but both of these
features are features


810
00:41:29,696 --> 00:41:32,806
of a static C and C++ compiler.


811
00:41:33,316 --> 00:41:36,346
But, LLVM is essential
technology here at Apple,


812
00:41:36,346 --> 00:41:38,156
that's used by many projects.


813
00:41:38,506 --> 00:41:40,126
And, one of the projects
that I want to talk to you


814
00:41:40,126 --> 00:41:43,266
about today is accelerating
JavaScript code.


815
00:41:47,356 --> 00:41:52,126
Well, WebKit is another
important technology.


816
00:41:52,126 --> 00:41:54,406
It's the heart of the
Safari Web Browser.


817
00:41:55,166 --> 00:41:57,646
And, WebKit needs to
execute JavaScript code


818
00:41:58,046 --> 00:42:00,326
because JavaScript is
everywhere in every web page.


819
00:42:01,806 --> 00:42:03,236
And, WebKit has an interpreter,


820
00:42:03,536 --> 00:42:05,826
so when you load your Facebook
page, or any other page,


821
00:42:06,156 --> 00:42:09,966
WebKit starts executing your
code with the interpreter.


822
00:42:11,356 --> 00:42:13,906
But, WebKit also has
two JIT compilers


823
00:42:14,276 --> 00:42:15,926
to accelerate your code.


824
00:42:17,156 --> 00:42:19,466
When WebKit sees that you
execute the same function,


825
00:42:19,466 --> 00:42:21,816
the same JavaScript
functions over


826
00:42:21,816 --> 00:42:23,396
and over again, it says, "Huh.


827
00:42:23,716 --> 00:42:27,106
Let's take a little bit of time
to compile it really quickly


828
00:42:27,106 --> 00:42:29,396
so that it will run a little bit
faster than the interpreter."


829
00:42:29,876 --> 00:42:30,956
So, this is the fast JIT.


830
00:42:32,366 --> 00:42:36,236
And, when WebKit sees that you
execute a function many times,


831
00:42:36,806 --> 00:42:39,726
then it says, "All right,
let's also take the time


832
00:42:39,936 --> 00:42:41,596
and optimize this
function real quick,


833
00:42:41,836 --> 00:42:44,256
so that it will run a
little bit more faster,


834
00:42:44,256 --> 00:42:45,286
a little bit faster."


835
00:42:45,676 --> 00:42:49,736
So, we have the interpreter,
we have the fast JIT,


836
00:42:50,126 --> 00:42:54,176
and we have the optimizing
JIT, and there are tradeoffs


837
00:42:54,176 --> 00:42:56,836
between compile time and
the quality of the code.


838
00:42:57,186 --> 00:43:00,256
And this works really great,


839
00:43:01,136 --> 00:43:03,096
except that JavaScript
is evolving.


840
00:43:04,146 --> 00:43:05,986
People start writing large,


841
00:43:06,106 --> 00:43:08,696
compute intensive
applications in JavaScript.


842
00:43:09,346 --> 00:43:13,356
People then compile C++
programs into JavaScript


843
00:43:13,776 --> 00:43:15,326
and run them in the browser.


844
00:43:15,586 --> 00:43:18,256
You can even compile
a Quake3 and run it


845
00:43:18,256 --> 00:43:20,446
in your browser today,
which is --


846
00:43:20,486 --> 00:43:22,266
some people like it [laughter].


847
00:43:23,586 --> 00:43:25,716
Yeah, it's great.


848
00:43:26,436 --> 00:43:30,956
But, it's a new-use case
and we need a new compiler


849
00:43:31,306 --> 00:43:32,356
to support this use-case,


850
00:43:32,926 --> 00:43:35,476
and this is where LLVM
comes into the picture.


851
00:43:36,986 --> 00:43:41,446
So, we're adding LLVM as a
fourth tier compiler to WebKit.


852
00:43:43,896 --> 00:43:45,796
Functions that run many, many,


853
00:43:45,796 --> 00:43:48,906
many times are now
compiled with LLVM.


854
00:43:49,096 --> 00:43:52,716
And, LLVM is tuned for making
the most out of your code,


855
00:43:52,716 --> 00:43:55,736
for really trying hard
to optimize your code


856
00:43:55,966 --> 00:43:59,366
and to generate excellent
code quality.


857
00:43:59,746 --> 00:44:03,106
And again, there's a
tradeoff between compiled time


858
00:44:03,386 --> 00:44:06,286
and the quality of the code,
so WebKit really waits for you


859
00:44:06,286 --> 00:44:09,426
to execute that function
many, many times as you do


860
00:44:09,426 --> 00:44:10,976
in computing intensive
applications


861
00:44:11,016 --> 00:44:11,856
that you run in the browser.


862
00:44:11,856 --> 00:44:17,746
But, compiling JavaScript
with LLVM is very different


863
00:44:17,746 --> 00:44:21,126
from compiling C or Objective-C
because JavaScript --


864
00:44:21,786 --> 00:44:24,446
it's a great language,
it's a dynamic language,


865
00:44:24,446 --> 00:44:26,226
and if you look at the code
on the screen you'll see


866
00:44:26,226 --> 00:44:27,726
that there are no types.


867
00:44:28,356 --> 00:44:33,086
There's this n argument
here, but what is n?


868
00:44:33,086 --> 00:44:34,246
Is it an integer?


869
00:44:34,326 --> 00:44:35,346
Is it double?


870
00:44:35,626 --> 00:44:36,436
Is it a class?


871
00:44:37,306 --> 00:44:38,506
It can be a lot of
different things.


872
00:44:39,706 --> 00:44:41,316
So, how do we compile it?


873
00:44:41,906 --> 00:44:48,616
Well luckily, WebKit executed
this function many, many, many,


874
00:44:48,616 --> 00:44:50,376
many times before
with the interpreter,


875
00:44:50,526 --> 00:44:56,636
so it knows that in the last
1000 times n was an integer.


876
00:44:57,006 --> 00:45:00,016
So now, we can compile this code
assuming that n is an integer,


877
00:45:00,996 --> 00:45:03,406
except that someone made decide


878
00:45:03,406 --> 00:45:06,466
to pass an n that's
not an integer.


879
00:45:06,466 --> 00:45:09,206
Someone may decide to
pass a double or a class


880
00:45:09,736 --> 00:45:12,266
and then everything will
break and we can't allow that.


881
00:45:12,786 --> 00:45:13,866
So, what do we do?


882
00:45:14,216 --> 00:45:15,606
We use a technique
that's very similar


883
00:45:15,606 --> 00:45:16,936
to what we did with
the vectorizer.


884
00:45:17,596 --> 00:45:18,336
We add checks.


885
00:45:18,336 --> 00:45:19,896
We make assumptions
and we add checks.


886
00:45:20,306 --> 00:45:21,946
We assume that n is an integer.


887
00:45:22,806 --> 00:45:24,976
We assume that n
does not overflow.


888
00:45:24,976 --> 00:45:28,476
And then, we verify our
assumptions at runtime.


889
00:45:29,526 --> 00:45:30,486
Okay, that's great.


890
00:45:30,966 --> 00:45:32,016
But, what is the fallback?


891
00:45:32,016 --> 00:45:32,506
What do we do?


892
00:45:33,276 --> 00:45:35,656
When our assumptions
fail we have to go back


893
00:45:35,656 --> 00:45:38,676
to the interpreter because only
the interpreter can handle all


894
00:45:38,676 --> 00:45:40,736
these cases, all
these extreme cases.


895
00:45:42,426 --> 00:45:45,616
But, moving back to the
interpreter is not simple


896
00:45:46,106 --> 00:45:47,826
because we started
executing it in a code


897
00:45:47,826 --> 00:45:48,976
and the function made changes.


898
00:45:48,976 --> 00:45:50,976
We can't just start executing
it from the beginning.


899
00:45:51,736 --> 00:45:54,536
So, we developed a technology
that's called On-Stack


900
00:45:54,536 --> 00:45:57,406
Replacement, which is
techniques that is used


901
00:45:57,856 --> 00:46:01,856
to migrate the state of the
program from the JITed code


902
00:46:01,856 --> 00:46:03,886
in LLVM back to WebKit.


903
00:46:04,156 --> 00:46:07,486
And, LLVM needs to track all of
the variables in your program


904
00:46:07,486 --> 00:46:09,966
and some of them may be in the
register, some of them may be


905
00:46:09,966 --> 00:46:13,406
in the stack, and now we're
able to migrate them from LLVM


906
00:46:13,406 --> 00:46:17,666
to WebKit and continue
the execution in WebKit.


907
00:46:17,906 --> 00:46:22,726
Now, this doesn't happen all the
time, it's a very extreme case.


908
00:46:22,726 --> 00:46:24,806
But when it happens, we
have to handle these cases.


909
00:46:26,996 --> 00:46:32,086
Okay, now compiling code
with LLVM is very beneficial,


910
00:46:32,086 --> 00:46:35,956
especially for compute intensive
applications and especially


911
00:46:36,226 --> 00:46:39,106
for these C++ applications
compiled


912
00:46:39,106 --> 00:46:40,976
into JavaScript,
run in the browser.


913
00:46:43,986 --> 00:46:45,596
And, we're really excited
about this technology.


914
00:46:45,886 --> 00:46:46,216
It's great.


915
00:46:47,176 --> 00:46:49,966
So now, we use LLVM.


916
00:46:50,386 --> 00:46:53,566
So to summarize, we use LLVM
as a fourth tier compiler


917
00:46:53,966 --> 00:47:00,006
in Safari, both for X86
and ARM64 on iOS and OS X,


918
00:47:00,006 --> 00:47:02,306
and we get excellent
performance speedups.


919
00:47:03,336 --> 00:47:05,276
To summarize this
talk, today we talked


920
00:47:05,276 --> 00:47:08,286
about modernizing Objective-C
code and we also talked


921
00:47:08,286 --> 00:47:09,946
about a number of
performance features.


922
00:47:10,716 --> 00:47:12,326
If you have any more questions,


923
00:47:12,326 --> 00:47:15,966
you can contact our Developer
Tools Evangelist, Dave DeLong,


924
00:47:16,156 --> 00:47:19,276
or you can go to the Apple
website or to the LLVM website.


925
00:47:19,476 --> 00:47:24,046
There are a few related
sessions, and I encourage you


926
00:47:24,046 --> 00:47:26,496
to attend these sessions
or to watch them online.


927
00:47:28,506 --> 00:47:31,756
Thank you, very much,
and have a good week.


928
00:47:32,436 --> 00:47:32,896
Bye-bye.


929
00:47:33,016 --> 00:47:35,000
[ Applause ]

