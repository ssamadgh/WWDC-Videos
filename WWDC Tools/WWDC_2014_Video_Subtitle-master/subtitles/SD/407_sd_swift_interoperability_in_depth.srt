1
00:00:00,506 --> 00:00:11,516
[ Silence ]


2
00:00:12,016 --> 00:00:16,000
[ Applause ]


3
00:00:16,516 --> 00:00:16,986
>> Welcome.


4
00:00:18,216 --> 00:00:19,176
So I'm Doug Gregor.


5
00:00:19,416 --> 00:00:22,656
I'm an engineer on the Swift
Compiler Team, and we're here


6
00:00:22,656 --> 00:00:24,976
to talk about Swift
Interoperabiity.


7
00:00:28,626 --> 00:00:30,416
We're going to talk about a
couple of different things here.


8
00:00:31,166 --> 00:00:33,986
So, of course, Swift is
a new language for Cocoa


9
00:00:33,986 --> 00:00:35,526
and Cocoa Touch development.


10
00:00:36,856 --> 00:00:38,746
Now, Cocoa's not
written in Swift.


11
00:00:38,746 --> 00:00:41,286
It's written in Objective-C,
a language you've been using


12
00:00:41,286 --> 00:00:43,526
for years and that all of
your apps are written in.


13
00:00:44,276 --> 00:00:47,036
So, interoperability between
these two very different


14
00:00:47,036 --> 00:00:49,626
programming languages
is absolutely critical.


15
00:00:50,106 --> 00:00:52,636
So we're going to talk about
how that interoperating works


16
00:00:53,076 --> 00:00:54,576
at the language level.


17
00:00:55,116 --> 00:00:58,786
We're going to hit a number
of different topics today.


18
00:00:59,426 --> 00:01:01,336
We're going to talk
about working with Cocoa,


19
00:01:01,436 --> 00:01:06,816
seeing how the Cocoa APIs or
Objective-C APIs look and feel


20
00:01:06,816 --> 00:01:09,916
in Swift and how to work
with them, as well as working


21
00:01:09,916 --> 00:01:13,786
with some more Swift concepts
like dealing with AnyObject


22
00:01:13,786 --> 00:01:17,046
and doing dynamic
checks on your types.


23
00:01:18,106 --> 00:01:20,206
Then we're going to
talk about bridging


24
00:01:20,526 --> 00:01:24,216
of the core Cocoa datatypes
and NSArray, NSDictionary,


25
00:01:24,366 --> 00:01:27,386
NSString into their
Swift-native equivalents.


26
00:01:28,616 --> 00:01:30,796
Then we'll move on
to subclassing,


27
00:01:30,946 --> 00:01:33,946
so writing Swift classes that
subclass from Objective-C


28
00:01:34,186 --> 00:01:36,576
and how they're mapped
back into Objective-C


29
00:01:36,856 --> 00:01:38,926
so that you can use these
two languages together.


30
00:01:40,156 --> 00:01:42,526
And, finally, we're going to
talk about Core Foundation


31
00:01:42,526 --> 00:01:44,316
and Core Graphics, and
this general notion


32
00:01:44,316 --> 00:01:48,276
of CF Interoperability within
the Swift programming language.


33
00:01:48,806 --> 00:01:53,366
Let's get started talking
about working with Cocoa.


34
00:01:55,466 --> 00:01:59,616
So Swift provides seamless
access to Objective-C APIs


35
00:01:59,916 --> 00:02:03,166
through the Objective-C Module
System we introduced last year.


36
00:02:03,796 --> 00:02:06,986
So you can pull your Objective-C
APIs whether they be from Cocoa


37
00:02:06,986 --> 00:02:09,826
or your own into
Swift and use them.


38
00:02:10,556 --> 00:02:13,206
And then Swift maps
those Objective-C APIs


39
00:02:13,306 --> 00:02:15,126
into the Swift syntax.


40
00:02:15,836 --> 00:02:19,186
This covers both the objective
parts of Objective-C -


41
00:02:19,306 --> 00:02:21,656
the classes, protocols,
methods, and so on,


42
00:02:22,116 --> 00:02:24,856
as well as the lower level
C things like functions,


43
00:02:24,856 --> 00:02:26,956
enumerations, structs, pointers.


44
00:02:27,456 --> 00:02:29,966
So you have access to all
of your Objective-C APIs.


45
00:02:31,456 --> 00:02:33,926
Now when you look at one of
these Objective-C APIs in Swift,


46
00:02:34,486 --> 00:02:36,366
it's going to be
different from Objective-C.


47
00:02:37,316 --> 00:02:39,286
There are inherent
syntactic differences


48
00:02:39,336 --> 00:02:41,346
between these two
language, of course.


49
00:02:42,426 --> 00:02:46,506
Swift also has some
modern features that we use


50
00:02:46,506 --> 00:02:49,266
when expressing those
Objective-C APIs in Swift


51
00:02:49,266 --> 00:02:51,196
that will make it look
a little bit different,


52
00:02:51,516 --> 00:02:54,066
as well as the bridging
of core Cocoa types


53
00:02:54,316 --> 00:02:55,306
that I mentioned earlier.


54
00:02:55,926 --> 00:02:59,486
Now, despite all of these
differences that you see


55
00:02:59,486 --> 00:03:02,396
when looking at the
APIs, it's still Cocoa,


56
00:03:02,586 --> 00:03:04,006
it's still Cocoa Touch.


57
00:03:04,236 --> 00:03:07,366
And the same conventions
and idioms still apply,


58
00:03:07,766 --> 00:03:10,166
so what you know of
Cocoa works in Swift.


59
00:03:10,206 --> 00:03:11,676
It's just a different
programming language


60
00:03:11,766 --> 00:03:14,646
for the same great platform,
the same great frameworks.


61
00:03:16,136 --> 00:03:19,356
So we're going to walk through
part of something we know


62
00:03:19,356 --> 00:03:22,336
and love, and that's
the UIDocument class.


63
00:03:23,736 --> 00:03:26,456
Here's a tiny slice
of it in Objective-C.


64
00:03:26,846 --> 00:03:30,706
We're going to walk through how
and why that maps into Swift.


65
00:03:31,546 --> 00:03:35,656
First thing, something simple, a
property: fileModificationDate.


66
00:03:35,656 --> 00:03:36,596
It is an NSDate!.


67
00:03:37,826 --> 00:03:40,756
This comes into Swift
as a property.


68
00:03:40,986 --> 00:03:41,956
It's the var keyword.


69
00:03:42,536 --> 00:03:45,536
The NSDate class, of course
just comes into Swift.


70
00:03:45,536 --> 00:03:47,346
Nothing interesting there except


71
00:03:47,346 --> 00:03:50,396
for this little exclamation
point that you may have noticed.


72
00:03:50,896 --> 00:03:55,966
Now that exclamation point is an
Implicitly Unwrapped Optional.


73
00:03:56,486 --> 00:03:58,846
What does that mean?


74
00:03:59,156 --> 00:04:01,456
Well, let's look at
Swift in Objective-C.


75
00:04:01,456 --> 00:04:03,946
They're different languages with
some different ideas in them.


76
00:04:04,456 --> 00:04:06,616
So in Swift, when
you have a value


77
00:04:06,616 --> 00:04:09,366
of class type, so
I have an NSDate!


78
00:04:09,866 --> 00:04:11,746
That can never be nil.


79
00:04:12,466 --> 00:04:13,826
So a very strong constraint.


80
00:04:14,566 --> 00:04:16,616
And it makes life a bit
simpler when you know


81
00:04:16,616 --> 00:04:17,565
that thing is not nil.


82
00:04:19,036 --> 00:04:21,646
Now, when you want to deal
with nil, you have an NSDate!


83
00:04:21,646 --> 00:04:25,056
that could be nil, you
use an optional type,


84
00:04:25,236 --> 00:04:27,526
and optional types are
covered extensively in the


85
00:04:27,526 --> 00:04:29,506
"Intermediate Swift" talk.


86
00:04:30,046 --> 00:04:31,526
We're going to cover them
a little bit more now.


87
00:04:32,976 --> 00:04:34,546
That's the Swift side of things.


88
00:04:34,986 --> 00:04:36,226
What about Objective-C?


89
00:04:36,656 --> 00:04:39,756
Well, it does not have
the notion of a never


90
00:04:39,756 --> 00:04:42,816
"never-nil" pointer
like we have in Swift.


91
00:04:43,356 --> 00:04:45,876
And so we have a little
impedance mismatch here.


92
00:04:45,876 --> 00:04:50,256
The Objective-C APIs don't have
the notion of this is not nil,


93
00:04:50,256 --> 00:04:52,146
but we need to bring
them into Swift.


94
00:04:52,796 --> 00:04:56,066
And so, we have the
implicitly unwrapped optional


95
00:04:56,146 --> 00:04:57,486
with the exclamation point here.


96
00:04:57,486 --> 00:04:59,916
And this gives us
a nice balance.


97
00:04:59,916 --> 00:05:02,336
It means that we can
express the notion of nil


98
00:05:03,006 --> 00:05:05,686
and you can test it against
nil to do those checks.


99
00:05:06,426 --> 00:05:09,656
However, you can also just
directly access properties


100
00:05:09,656 --> 00:05:12,346
or directly call a method
on it, or you can convert it


101
00:05:12,346 --> 00:05:14,786
down to NSNil, and we'll unwrap


102
00:05:14,936 --> 00:05:17,116
that optional object
automatically


103
00:05:17,116 --> 00:05:17,976
for you doing the checking.


104
00:05:18,046 --> 00:05:21,976
So it's a fairly syntactically
lightweight way of dealing


105
00:05:21,976 --> 00:05:26,786
with nil in a language where nil
is a much more explicit entity


106
00:05:27,376 --> 00:05:28,006
like in Swift.


107
00:05:29,406 --> 00:05:32,976
Let's look at another property.


108
00:05:33,096 --> 00:05:35,396
So here we have the fileType
property that's in NSString.


109
00:05:36,676 --> 00:05:42,456
This is going to come into
Swift as a native Swift string.


110
00:05:43,196 --> 00:05:45,636
Now, again, we have the
implicitly unwrapped optional


111
00:05:45,636 --> 00:05:47,876
here so that nil can be passed


112
00:05:47,876 --> 00:05:50,866
through since NSString doesn't
have a notion of nil inside it.


113
00:05:52,446 --> 00:05:55,106
And there's a number
of Objective-C types


114
00:05:55,286 --> 00:05:58,056
that get mapped slightly
differently into Swift.


115
00:05:58,776 --> 00:06:01,846
So there's some very, very
fundamental types like BOOL


116
00:06:01,896 --> 00:06:07,036
and NSInteger that map into the
Bool and Int types within Swift.


117
00:06:07,256 --> 00:06:08,846
So we're working with
all the Swift types.


118
00:06:09,636 --> 00:06:11,606
There's id and Class,


119
00:06:11,606 --> 00:06:14,396
which we're very familiar
with in Objective-C.


120
00:06:14,676 --> 00:06:16,496
These map over to AnyObject!


121
00:06:16,496 --> 00:06:18,396
and AnyClass!, something
we're going to talk


122
00:06:18,396 --> 00:06:19,346
about in a couple of minutes.


123
00:06:20,366 --> 00:06:22,746
And we also have the core
Cocoa types that are bridged,


124
00:06:22,746 --> 00:06:24,066
like NSString and NSArray,


125
00:06:24,326 --> 00:06:26,586
mapping to their
Swift-native equivalents.


126
00:06:26,776 --> 00:06:28,616
Again, we'll talk about
that later in this talk.


127
00:06:29,956 --> 00:06:31,106
Let's take a look at methods.


128
00:06:32,346 --> 00:06:34,706
There's an Objective-C method
fileNameExtensionForType,


129
00:06:34,776 --> 00:06:35,796
saveOperation.


130
00:06:36,356 --> 00:06:39,796
It comes into Swift here
as, again, a method.


131
00:06:40,906 --> 00:06:43,946
Now, one important thing
to know here is that all


132
00:06:43,946 --> 00:06:47,596
of the selector pieces from
the Objective-C method are here


133
00:06:47,666 --> 00:06:49,926
in the method's signature
in Swift.


134
00:06:50,556 --> 00:06:53,236
The first selector piece has
become the so-called base name


135
00:06:53,236 --> 00:06:53,846
of the method.


136
00:06:54,436 --> 00:06:56,816
The second selector
piece, SaveOperation,


137
00:06:57,226 --> 00:07:00,576
has become a label on
the second argument.


138
00:07:01,966 --> 00:07:05,046
A really important thing
here is that these labels


139
00:07:05,306 --> 00:07:08,846
and their order are
enforced at the call site.


140
00:07:09,656 --> 00:07:13,026
So, you must call it as
fileNameExtensionForType,


141
00:07:13,266 --> 00:07:15,746
saveOperation, just
like you do in Cocoa


142
00:07:16,036 --> 00:07:18,236
with the exact same
ordering, so to preserve


143
00:07:18,506 --> 00:07:21,416
that nice readability from
Cocoa that we all know and love.


144
00:07:23,466 --> 00:07:26,516
Now the other thing to note
here is the consistency here


145
00:07:26,516 --> 00:07:27,296
on the Swift side.


146
00:07:28,496 --> 00:07:31,106
All of the names and the
colons and the parentheses


147
00:07:31,106 --> 00:07:33,586
and the commas are in
exactly the same places


148
00:07:34,166 --> 00:07:37,206
in the declaration of
the method in the middle


149
00:07:37,676 --> 00:07:39,946
and in the call site of
the method at the bottom.


150
00:07:39,946 --> 00:07:41,846
So the kind of consistency
we like out


151
00:07:41,846 --> 00:07:43,196
of building a new language.


152
00:07:43,196 --> 00:07:47,296
Let's look at a little bit
more complicated method here


153
00:07:47,296 --> 00:07:48,646
where we have some
blocks going on,


154
00:07:48,646 --> 00:07:51,506
some more interesting things,
and map that into Swift.


155
00:07:52,326 --> 00:07:54,556
And here there are two different
things I want to talk about.


156
00:07:54,596 --> 00:07:58,496
The first thing I want to
talk about is the naming


157
00:07:58,586 --> 00:08:02,096
of these argument labels and
the internal parameter names.


158
00:08:02,676 --> 00:08:05,816
So here in Objective-C you
always have a selector piece,


159
00:08:06,556 --> 00:08:07,586
goes before the colon.


160
00:08:07,976 --> 00:08:10,666
And then you have the name of
the - at the internal parameter


161
00:08:10,956 --> 00:08:13,016
that you use when you're
defining the method


162
00:08:13,016 --> 00:08:14,196
in your .m file.


163
00:08:14,406 --> 00:08:17,416
In Objective-C you always
have to write both of these,


164
00:08:17,416 --> 00:08:19,536
of course, and many
times they're the same.


165
00:08:19,536 --> 00:08:20,696
So you have some redundancy.


166
00:08:21,316 --> 00:08:24,566
We do a little bit of syntax
optimization here in Swift,


167
00:08:24,566 --> 00:08:25,866
so you just write the name once.


168
00:08:26,236 --> 00:08:28,996
It serves both as the label
and the internal name.


169
00:08:29,906 --> 00:08:32,525
If you want those names
to be different, fine,


170
00:08:32,525 --> 00:08:33,576
we can handle that, too.


171
00:08:33,706 --> 00:08:35,416
You just write the two
names next to each other.


172
00:08:35,626 --> 00:08:37,816
The first one is the label
because that's what's important


173
00:08:37,816 --> 00:08:38,996
for the caller to use.


174
00:08:39,616 --> 00:08:42,376
And then the second one is the
internal name that you're going


175
00:08:42,376 --> 00:08:44,896
to use within the
implementation of your method.


176
00:08:46,366 --> 00:08:50,106
The next thing I want to
point out here is the Block.


177
00:08:51,436 --> 00:08:54,596
So here we have a method
that takes a Block,


178
00:08:55,126 --> 00:08:59,716
and Blocks in Objective-C get
mapped into Closures in Swift.


179
00:09:00,566 --> 00:09:03,316
You see, again, this is an
implicitly unwrapped optional


180
00:09:03,536 --> 00:09:05,936
so that you can pass
a nil Block in here.


181
00:09:07,486 --> 00:09:08,806
Now the really great thing


182
00:09:09,076 --> 00:09:13,036
about getting Objective-C Blocks
mapped into Swift Closures is


183
00:09:13,036 --> 00:09:16,316
that we get all of the great
closure syntax that is provided


184
00:09:16,316 --> 00:09:18,766
by Swift, including
trailing closures


185
00:09:18,986 --> 00:09:20,826
when your block is
the last parameter.


186
00:09:21,356 --> 00:09:23,816
So all of your block-based
APIs that you've written,


187
00:09:23,886 --> 00:09:26,526
all the ones from Cocoa, when
they're following the convention


188
00:09:26,526 --> 00:09:30,736
of putting the block last get
this nice trailing closure


189
00:09:30,736 --> 00:09:31,736
syntax in Swift.


190
00:09:32,166 --> 00:09:37,026
Let's talk a little
bit about Initializers.


191
00:09:38,626 --> 00:09:41,796
So in Objective-C
we have init methods


192
00:09:42,576 --> 00:09:46,506
and init methods have a lot of
conventions built around them.


193
00:09:47,036 --> 00:09:48,376
They start with the word "init."


194
00:09:49,046 --> 00:09:51,016
They should be returning
instance type,


195
00:09:51,546 --> 00:09:52,966
although that's a
fairly new invention.


196
00:09:52,966 --> 00:09:54,746
So sometimes they're
still returning ID.


197
00:09:56,206 --> 00:09:58,036
And when you're implementing
these things,


198
00:09:58,036 --> 00:09:59,356
you have a lot of requirements.


199
00:09:59,356 --> 00:09:59,966
You need to call "super init."


200
00:10:00,046 --> 00:10:01,896
You need to reassign "self."


201
00:10:01,896 --> 00:10:03,996
You need to check "self,"
you need to return "self."


202
00:10:05,926 --> 00:10:09,666
So all of this screams, we
need something formalized


203
00:10:09,696 --> 00:10:10,506
in the language.


204
00:10:10,536 --> 00:10:13,476
And so Swift has this
notion of Initializers.


205
00:10:13,906 --> 00:10:18,236
And we import Objective-C init
methods as Swift Initializers.


206
00:10:19,206 --> 00:10:21,696
How do we get from the
top Objective-C code


207
00:10:21,696 --> 00:10:23,016
to the Swift code in the bottom?


208
00:10:23,526 --> 00:10:27,436
Well, we find the init,
so we match the init name


209
00:10:27,436 --> 00:10:28,916
and the camel-case string here.


210
00:10:28,916 --> 00:10:31,586
We actually look forward
a little bit to see


211
00:10:31,586 --> 00:10:34,546
if it's really initWith
because that's extremely common.


212
00:10:34,986 --> 00:10:37,756
And then we take the
rest of that Selector,


213
00:10:37,846 --> 00:10:39,826
and lowercase the
first character in it,


214
00:10:40,146 --> 00:10:43,666
and turn that into an argument
label for the Swift Initializer.


215
00:10:44,976 --> 00:10:45,866
Now, why do we do this?


216
00:10:45,866 --> 00:10:47,736
Well, let's look at
how we build objects


217
00:10:47,736 --> 00:10:49,996
in Objective-C versus in Swift.


218
00:10:50,566 --> 00:10:54,196
So in Objective-C you do
an alloc on your class


219
00:10:54,386 --> 00:10:58,256
and then you immediately
send it an init message


220
00:10:58,386 --> 00:10:59,556
to initialize the Object.


221
00:10:59,846 --> 00:11:02,246
These two steps are
almost never separated.


222
00:11:02,866 --> 00:11:07,376
Now in Swift we have
our Initializers


223
00:11:07,856 --> 00:11:11,116
and we use this Unified
Object Construction syntax


224
00:11:11,386 --> 00:11:13,176
where we write the
name of the Class


225
00:11:13,536 --> 00:11:16,346
and then we pass arguments
directly to the Initializer.


226
00:11:16,916 --> 00:11:20,626
And notice here, we're using the
argument label of fileURL to say


227
00:11:20,626 --> 00:11:22,786
which Initializer
we're actually using


228
00:11:23,146 --> 00:11:24,316
and then give it the argument.


229
00:11:25,046 --> 00:11:27,556
And, of course, we folded the
alloc and the init together


230
00:11:27,556 --> 00:11:29,906
in this one nice syntax
that also happens to work


231
00:11:29,906 --> 00:11:32,216
for all other types of in
Swift whether they be structs


232
00:11:32,216 --> 00:11:32,786
or enums.


233
00:11:33,336 --> 00:11:38,186
Okay. So let's talk
about factory methods


234
00:11:38,226 --> 00:11:40,026
because this is the other way


235
00:11:40,176 --> 00:11:42,376
that we build Objects
in Objective-C.


236
00:11:42,816 --> 00:11:44,746
So here we have something
from UIColor.


237
00:11:44,746 --> 00:11:46,106
I've stepped away
from UIDocument.


238
00:11:46,106 --> 00:11:48,316
And they have colorWithRed
blue green alpha.


239
00:11:48,726 --> 00:11:50,366
And, of course, we
can go and construct


240
00:11:50,366 --> 00:11:55,366
that by calling UIColor
colorWithRed green blue alpha.


241
00:11:55,616 --> 00:11:58,206
All of this can be
directly imported in Swift.


242
00:11:58,646 --> 00:12:01,496
It would just be a class
method, colorwithRed,


243
00:12:01,496 --> 00:12:04,406
and green blue alpha
as argument labels,


244
00:12:04,846 --> 00:12:07,456
and we could just
call it on the class.


245
00:12:08,396 --> 00:12:09,286
This would be fine.


246
00:12:09,286 --> 00:12:10,876
However, we don't really love


247
00:12:10,876 --> 00:12:12,626
that they're two
completely different kinds


248
00:12:12,626 --> 00:12:13,626
of initialization.


249
00:12:14,916 --> 00:12:19,496
So we recognize the
common patterns


250
00:12:19,496 --> 00:12:22,066
in how factory methods are
described in Objective-C,


251
00:12:22,236 --> 00:12:24,786
and bring them in as
Swift Initializers.


252
00:12:25,976 --> 00:12:27,906
And the really great
thing here is we get


253
00:12:27,906 --> 00:12:31,416
that common Initialization
syntax for all


254
00:12:31,416 --> 00:12:32,816
of these Objective-C APIs.


255
00:12:33,266 --> 00:12:35,396
You don't have to think, "Is
there an init method for this?


256
00:12:35,396 --> 00:12:38,156
Or is there a class
method for this?"


257
00:12:39,046 --> 00:12:40,486
It's there as an Initializer.


258
00:12:43,176 --> 00:12:43,956
Do you like that?


259
00:12:44,516 --> 00:12:49,026
[ Applause ]


260
00:12:49,526 --> 00:12:51,166
Let's go a little
bit down the stack


261
00:12:51,586 --> 00:12:52,856
and let's talk about Enums.


262
00:12:54,006 --> 00:12:56,826
So here's the
UIDocumentSaveOperation enum


263
00:12:57,186 --> 00:12:58,556
as defined in Objective-C.


264
00:12:59,646 --> 00:13:02,666
And if we look at this we see
a whole lot of redundancy.


265
00:13:03,416 --> 00:13:06,646
This UIDocumentSave
prefix is used for the enum


266
00:13:06,916 --> 00:13:09,136
and for both of its enum values.


267
00:13:10,066 --> 00:13:10,986
Why is this?


268
00:13:10,986 --> 00:13:12,436
Well, this is C.


269
00:13:13,236 --> 00:13:16,896
The enum values in C are
in a global namespace.


270
00:13:17,276 --> 00:13:20,386
We can't call these enum
values just ForCreating


271
00:13:20,386 --> 00:13:22,456
and ForOverwriting because
that's going to stomp


272
00:13:22,456 --> 00:13:25,016
on some other completely
different enumeration somewhere


273
00:13:25,016 --> 00:13:27,546
else in the system
and cause havoc.


274
00:13:28,396 --> 00:13:31,456
So we do this common
prefix by convention.


275
00:13:31,496 --> 00:13:33,506
It helps code completion
find the right thing.


276
00:13:33,506 --> 00:13:37,196
But when we're talking about
Swift, it's also a great cue


277
00:13:37,196 --> 00:13:38,776
for us that we can do better.


278
00:13:39,376 --> 00:13:42,036
And so we can import
this NS-ENUM


279
00:13:42,506 --> 00:13:46,876
as a Swift enum chopping off
all of those common prefixes


280
00:13:47,116 --> 00:13:49,396
to get us nice short
names for the cases.


281
00:13:50,886 --> 00:13:54,126
Now the reason we can do this
is because the enum cases


282
00:13:54,126 --> 00:13:57,446
in Swift are scoped within
the enum type itself.


283
00:13:58,016 --> 00:14:02,026
How does this play
out in actual code?


284
00:14:02,596 --> 00:14:04,656
Well, okay, if we call
fileNameExtensionForType


285
00:14:04,656 --> 00:14:08,606
saveOperation, we can
refer to, say ForCreating,


286
00:14:09,306 --> 00:14:12,216
with its fully dotted
name - class name.enum,


287
00:14:12,216 --> 00:14:13,996
the same dotted syntax we use


288
00:14:14,146 --> 00:14:16,686
for a number of anything
in Swift.


289
00:14:17,896 --> 00:14:19,626
But Swift has type inference.


290
00:14:20,496 --> 00:14:23,426
We know that this method takes
the UIDocumentSaveOperation,


291
00:14:23,536 --> 00:14:25,446
so there's absolutely
no reason to write that.


292
00:14:25,756 --> 00:14:27,626
You can just pass .ForCreating


293
00:14:27,626 --> 00:14:30,546
and we will infer the
enum type from that.


294
00:14:36,046 --> 00:14:38,426
I'd also like to
talk about NSError.


295
00:14:39,276 --> 00:14:43,086
So this is our pattern in
Cocoa for dealing with errors.


296
00:14:43,676 --> 00:14:45,846
And so there are many
methods throughout Cocoa


297
00:14:45,846 --> 00:14:48,896
and throughout your own
apps that take an NSError ,


298
00:14:49,106 --> 00:14:53,266
and that's a C pointer
to an NSError object.


299
00:14:53,896 --> 00:14:57,076
We bring this in with a
special type in Swift.


300
00:14:57,166 --> 00:14:58,216
In fact, if you type alias


301
00:14:58,216 --> 00:15:01,896
for a much longer type
name call NSErrorPointer.


302
00:15:03,026 --> 00:15:03,356
We're going


303
00:15:03,356 --> 00:15:05,976
to see NSErrorPointer
twice in this talk.


304
00:15:06,826 --> 00:15:08,846
For now we're going to
talk about how to use it


305
00:15:09,356 --> 00:15:11,326
when we're calling into the API.


306
00:15:13,036 --> 00:15:15,646
And it's not actually all that
much different from Objective-C.


307
00:15:16,506 --> 00:15:20,506
So, if we bring this up, we
declare a local variable.


308
00:15:20,936 --> 00:15:22,026
It's called error.


309
00:15:22,096 --> 00:15:24,036
It's a type NSError optional.


310
00:15:24,996 --> 00:15:27,566
And we pass its address
in when we're calling


311
00:15:27,566 --> 00:15:28,766
contentsForType error.


312
00:15:30,076 --> 00:15:32,816
And so in this code we check
whether we're getting back some


313
00:15:32,816 --> 00:15:33,826
contents from this.


314
00:15:34,726 --> 00:15:36,106
Then we can deal
with those contents.


315
00:15:36,736 --> 00:15:39,446
If we fail to find any contents
well, we probably have an error.


316
00:15:39,446 --> 00:15:42,056
So we can go unwrap
that optional error


317
00:15:42,356 --> 00:15:43,726
and present it to the user.


318
00:15:44,126 --> 00:15:46,626
And if we fall through the
else here, now we're in trouble


319
00:15:46,626 --> 00:15:49,256
because something failed and we
have nothing we can do about it.


320
00:15:49,906 --> 00:15:52,476
We hope that doesn't happen.


321
00:15:52,686 --> 00:15:55,456
But this is the pattern
you'll be using when dealing


322
00:15:55,456 --> 00:15:57,026
with NSError in Swift.


323
00:15:57,296 --> 00:15:59,036
If you truly don't
care about the error,


324
00:15:59,176 --> 00:16:00,176
you can also pass nil.


325
00:16:01,656 --> 00:16:04,916
So we've walked through
a lot of little pieces


326
00:16:05,356 --> 00:16:08,446
of the Objective-C
mapping into Swift.


327
00:16:08,446 --> 00:16:11,306
And there are a lot of
rules that we've talked


328
00:16:11,306 --> 00:16:13,016
about that you're certainly
not going to remember.


329
00:16:14,166 --> 00:16:15,196
That's perfectly fine.


330
00:16:15,366 --> 00:16:16,506
Xcode has your back here.


331
00:16:17,226 --> 00:16:18,466
Use the tools to help you.


332
00:16:19,026 --> 00:16:21,346
So if you're in Xcode,
you're in some Swift Code,


333
00:16:21,346 --> 00:16:23,636
you can Command+Click
on a class name.


334
00:16:23,886 --> 00:16:25,956
And we'll show you
the Swift projection


335
00:16:26,276 --> 00:16:28,096
of the underlying
Objective-C class.


336
00:16:28,896 --> 00:16:31,046
So take your favorite
Cocoa class and look


337
00:16:31,046 --> 00:16:33,176
at how it maps into Swift.


338
00:16:33,566 --> 00:16:35,616
Get a feel for the
language, an intuitive feel


339
00:16:35,616 --> 00:16:38,806
for how these languages
work together and you'll get


340
00:16:38,806 --> 00:16:40,336
into Swift really fast.


341
00:16:41,126 --> 00:16:43,956
And the great thing
is, all of these tools,


342
00:16:44,166 --> 00:16:47,016
all the rules I've talked
about, apply equally


343
00:16:47,016 --> 00:16:50,976
to any Objective-C API
when it comes into Swift.


344
00:16:51,416 --> 00:16:52,636
It doesn't matter if it's Cocoa.


345
00:16:52,636 --> 00:16:53,776
It doesn't matter if
it's your own API.


346
00:16:54,256 --> 00:16:58,876
The same rules apply, and you
can view your own Objective-C


347
00:16:58,956 --> 00:17:01,186
APIs in Swift to get
to know them better.


348
00:17:02,246 --> 00:17:05,146
Now this works best
when you're following


349
00:17:05,175 --> 00:17:07,136
"modern" Objective-C practices.


350
00:17:07,705 --> 00:17:11,935
So these are using features
like Properties, instancetype,


351
00:17:12,726 --> 00:17:15,915
marking your enumerations
with NS-ENUM or NS-OPTIONS


352
00:17:15,965 --> 00:17:17,866
to describe more
semantic information


353
00:17:17,866 --> 00:17:20,366
about what these enums
actually mean in C.


354
00:17:21,616 --> 00:17:24,306
We've also introduced
NS-DESIGNATED-INITIALIZER this


355
00:17:24,306 --> 00:17:27,086
year to mark your
designated Initializers


356
00:17:27,606 --> 00:17:29,546
and formalize a Designated
Initializer pattern,


357
00:17:29,546 --> 00:17:31,676
both in Objective-C
through additional warnings,


358
00:17:32,306 --> 00:17:35,486
and as the initialization
model for Swift.


359
00:17:36,736 --> 00:17:39,176
So, of course, we want
you to follow all of these


360
00:17:39,176 --> 00:17:42,496
"modern" Objective-C
practices but we don't want you


361
00:17:42,496 --> 00:17:43,296
to have to go it alone.


362
00:17:44,046 --> 00:17:47,316
And so this year we introduced
the Objective-C Modernizer


363
00:17:47,776 --> 00:17:50,296
that helps find these
cases in your code


364
00:17:50,596 --> 00:17:53,376
where we could possibly
modernize them to work


365
00:17:53,376 --> 00:17:55,496
with all these "modern"
Objective-C features


366
00:17:55,786 --> 00:17:57,876
and give you a better
projection into Swift.


367
00:17:58,426 --> 00:18:00,696
And that Modernizer is
discussed in the "What's New


368
00:18:00,696 --> 00:18:02,666
in LLVM" talk earlier today.


369
00:18:03,296 --> 00:18:05,686
Highly recommend you catch
it on video if you missed it.


370
00:18:08,096 --> 00:18:12,056
With that, let's talk about id.


371
00:18:13,766 --> 00:18:15,176
What is id in Objective-C?


372
00:18:15,736 --> 00:18:19,576
It's kind of a placeholder
in some sense.


373
00:18:19,766 --> 00:18:21,596
It means, I have a value.


374
00:18:22,016 --> 00:18:25,066
I know it's an object
but I don't know


375
00:18:25,066 --> 00:18:28,686
or I don't care what the
static type of that object is.


376
00:18:29,096 --> 00:18:30,996
It's going to vary at
runtime most likely.


377
00:18:31,766 --> 00:18:34,026
And there's a couple
of core operations


378
00:18:34,026 --> 00:18:35,316
that you can perform on id.


379
00:18:35,316 --> 00:18:38,216
You can do upcasting on it.


380
00:18:38,296 --> 00:18:41,996
So, if I have this
variable object of type id,


381
00:18:42,366 --> 00:18:44,416
I can put an NSURL into it.


382
00:18:45,406 --> 00:18:48,326
Later I can go reassign it
and I can put a UIView on it.


383
00:18:48,736 --> 00:18:49,646
That's perfectly fine.


384
00:18:49,806 --> 00:18:52,626
They can both be upcasted
essentially to id.


385
00:18:52,806 --> 00:18:53,596
They're both objects.


386
00:18:54,536 --> 00:18:57,796
I can do Message sends
to id just directly


387
00:18:57,796 --> 00:18:58,816
by doing a Message Send.


388
00:18:59,206 --> 00:19:02,786
I can subscript an id
if I really feel like.


389
00:19:03,516 --> 00:19:08,546
In Swift, any object is
the equivalent to id.


390
00:19:08,546 --> 00:19:13,376
And it provides these same
core operations - Upcasting,


391
00:19:13,796 --> 00:19:15,576
Message Sends, Subscripting -


392
00:19:15,876 --> 00:19:17,736
that you can do on
id in Objective-C.


393
00:19:17,736 --> 00:19:23,316
Now one of the things we know
from using id in Objective-C is


394
00:19:23,316 --> 00:19:25,636
that you sometimes have
to be a little bit careful


395
00:19:26,906 --> 00:19:28,816
because if you send a
message to an object


396
00:19:29,386 --> 00:19:31,256
that doesn't have a
corresponding method,


397
00:19:31,446 --> 00:19:33,036
you're going to get
a runtime failure


398
00:19:33,036 --> 00:19:34,866
that this is an unrecognized
selector.


399
00:19:35,916 --> 00:19:37,976
Now in Objective-C we
have an answer for this.


400
00:19:38,456 --> 00:19:40,476
Using this respondsToSelector
idiom.


401
00:19:40,966 --> 00:19:44,186
Do an if. Check whether it
respondsToSelector, then do it.


402
00:19:45,356 --> 00:19:47,556
In Swift we like to do
a little bit better.


403
00:19:48,556 --> 00:19:49,916
So let's take the same call


404
00:19:49,916 --> 00:19:52,466
and let's do a
removeFromSuperview() call


405
00:19:52,466 --> 00:19:53,076
on this object.


406
00:19:54,506 --> 00:19:59,216
And the thing to note here
is that removeFromSuperview()


407
00:19:59,836 --> 00:20:02,576
on an object of unknown type,


408
00:20:02,946 --> 00:20:04,976
it may be there, it
may not be there.


409
00:20:06,226 --> 00:20:07,876
Well, how do we deal with
this notion in Swift?


410
00:20:08,246 --> 00:20:11,406
We use an "optional" that says
there may be a value there;


411
00:20:11,496 --> 00:20:12,226
there may not be.


412
00:20:12,566 --> 00:20:14,726
And so the reference to
removeFromSuperview()


413
00:20:14,726 --> 00:20:17,086
on object is in effect,
optional.


414
00:20:17,506 --> 00:20:20,936
That means we can use the
optional Chaining Operator here


415
00:20:21,886 --> 00:20:22,026
to -


416
00:20:23,516 --> 00:20:29,066
[ Applause ]


417
00:20:29,566 --> 00:20:30,616
What we're doing, of course,


418
00:20:30,806 --> 00:20:33,266
is we're folding the
respondsToSelector check in,


419
00:20:33,696 --> 00:20:36,566
so we do the reference, go
look for RemoveFromSuperview.


420
00:20:36,976 --> 00:20:39,126
If it's there, go on, call it.


421
00:20:39,886 --> 00:20:42,176
If it's not there, stop
evaluating this expression.


422
00:20:42,176 --> 00:20:42,536
We're done.


423
00:20:44,276 --> 00:20:47,156
Now, something that id does


424
00:20:47,156 --> 00:20:50,496
that AnyObject does not
do is implicitly downcast.


425
00:20:50,816 --> 00:20:54,316
So I have Object, which is a
type AnyObject, and I'm trying


426
00:20:54,316 --> 00:20:56,486
to assign it into a UIView.


427
00:20:57,506 --> 00:20:59,166
This is going to
produce a compiler error


428
00:20:59,166 --> 00:21:01,786
because this is a
unsafe downcast.


429
00:21:02,276 --> 00:21:05,146
How do we deal with this?


430
00:21:05,236 --> 00:21:06,666
Well, there's really
two cases here that need


431
00:21:06,666 --> 00:21:07,866
that you need to think about.


432
00:21:08,536 --> 00:21:12,796
One case is, I know it's a
UIView but for some reason


433
00:21:12,796 --> 00:21:15,496
that strong type information
got lost when going


434
00:21:15,496 --> 00:21:16,626
through some API somewhere.


435
00:21:17,226 --> 00:21:19,126
If I know for sure
it's a UIView,


436
00:21:19,456 --> 00:21:23,086
I can use the cast
operator, "as", to say,


437
00:21:23,086 --> 00:21:25,066
"Treat this object as a UIView."


438
00:21:26,466 --> 00:21:29,326
We're going to do these kind
of class check at runtime


439
00:21:29,326 --> 00:21:31,196
to make sure that's
absolutely true.


440
00:21:31,836 --> 00:21:36,336
But the type system will
believe you at this point.


441
00:21:36,516 --> 00:21:40,976
Now if you don't know whether
this object is a UIView


442
00:21:40,976 --> 00:21:42,906
or not, you can use the "as?"


443
00:21:43,036 --> 00:21:45,976
to perform a conditional
downcast.


444
00:21:46,516 --> 00:21:52,606
[ Applause ]


445
00:21:53,106 --> 00:21:54,286
Think you guys have
figured it out?


446
00:21:54,286 --> 00:21:57,476
But just to be sure, this is
doing "is kind of" class check.


447
00:21:57,476 --> 00:22:00,936
And it's wrapping the result
in an optional UIView.


448
00:22:01,756 --> 00:22:03,336
It's nil if the check failed.


449
00:22:03,636 --> 00:22:06,426
It has the UIView if
the check succeeded.


450
00:22:06,826 --> 00:22:08,256
We can do an if-let here


451
00:22:08,676 --> 00:22:10,986
to completely do this
entire thing safely,


452
00:22:11,336 --> 00:22:13,896
and view in here is the
UIView we were looking for.


453
00:22:15,276 --> 00:22:17,886
So let's take a little
bit of detour and talk


454
00:22:17,886 --> 00:22:19,366
about tiny bit of protocols.


455
00:22:19,836 --> 00:22:24,026
Here's an Objective-C Protocol
for a UITableViewDataSource


456
00:22:24,536 --> 00:22:27,426
and its Swift equivalent.


457
00:22:27,786 --> 00:22:31,496
Not a whole lot new here.


458
00:22:31,706 --> 00:22:33,866
But there are two things that
I do I want to point out.


459
00:22:33,926 --> 00:22:38,076
The first thing I want to point
out is optional and required.


460
00:22:38,546 --> 00:22:39,856
So in Objective-C optional


461
00:22:39,856 --> 00:22:42,406
and required are essentially
modes in the protocol.


462
00:22:42,916 --> 00:22:44,826
You say @optional,
and everything


463
00:22:44,826 --> 00:22:47,636
that follows is optional
up until the point


464
00:22:47,636 --> 00:22:50,066
where you hit an @required and
then everything is required.


465
00:22:50,836 --> 00:22:54,426
And we're not totally thrilled
with this decision now.


466
00:22:54,976 --> 00:22:56,996
And the basic reason is
that you can't just look


467
00:22:56,996 --> 00:22:59,126
at one single declaration
in the protocol


468
00:22:59,126 --> 00:23:00,846
and know whether it's
optional or required.


469
00:23:00,846 --> 00:23:03,636
You have to go scan up
your protocol to find it.


470
00:23:04,006 --> 00:23:06,056
And so we did something a
little bit different in Swift


471
00:23:06,756 --> 00:23:10,876
in that requirements in
protocol are required


472
00:23:10,876 --> 00:23:12,506
by default in Swift.


473
00:23:12,806 --> 00:23:15,326
If you want to make them
optional, then tag them


474
00:23:15,326 --> 00:23:17,596
with the optional attribute
to make them optional.


475
00:23:18,936 --> 00:23:20,696
The other thing I want
to point out here.


476
00:23:21,016 --> 00:23:23,216
We're doing a little bit
of Protocol Inheritance


477
00:23:23,916 --> 00:23:26,416
and we're inheriting
from NSObjectProtocol.


478
00:23:28,196 --> 00:23:31,946
So in Objective-C we will
have NSObject the class


479
00:23:32,116 --> 00:23:34,046
and NSObject the protocol.


480
00:23:35,216 --> 00:23:38,716
And they have the same name so
we have to add the "the class"


481
00:23:38,716 --> 00:23:40,746
or "the protocol" at the
end when we talk about it.


482
00:23:41,106 --> 00:23:45,296
The language keeps these in
syntactically distinct points


483
00:23:45,736 --> 00:23:47,456
so the language isn't confused.


484
00:23:48,086 --> 00:23:50,606
But in Swift we wanted
to bring all these things


485
00:23:50,606 --> 00:23:53,476
into the same namespace because
that's far more convenient


486
00:23:53,476 --> 00:23:54,476
for the general case.


487
00:23:54,876 --> 00:23:56,436
And so we needed to
rename something.


488
00:23:57,056 --> 00:23:59,376
And essentially when there's a
conflict between a class name


489
00:23:59,376 --> 00:24:01,336
and a protocol name,
we'll append protocol


490
00:24:01,336 --> 00:24:03,286
to the name of the protocol.


491
00:24:03,846 --> 00:24:06,286
Why did we do this?


492
00:24:06,286 --> 00:24:10,766
Well, let's take a look at
another use of id that we see


493
00:24:10,846 --> 00:24:14,086
in Objective-C, and that's
protocol-qualified id.


494
00:24:15,086 --> 00:24:19,426
So this dataSource here is an
object of some unknown type.


495
00:24:20,626 --> 00:24:22,336
But we know that
the type conforms


496
00:24:22,336 --> 00:24:24,346
to the UITableViewDataSource
protocol.


497
00:24:25,526 --> 00:24:27,416
We describe that a
little bit more directly


498
00:24:27,416 --> 00:24:30,056
in the Swift language by
just saying the dataSource is


499
00:24:30,056 --> 00:24:31,486
a UITableViewDataSource!.


500
00:24:32,146 --> 00:24:33,026
That's it.


501
00:24:33,716 --> 00:24:38,006
Now some of you here noticed
with protocol-qualified id,


502
00:24:38,256 --> 00:24:40,766
you can have many different
protocols if you want.


503
00:24:41,346 --> 00:24:44,836
We can use the protocol
keyword with angle brackets


504
00:24:44,996 --> 00:24:46,396
to describe more
than one protocol.


505
00:24:46,396 --> 00:24:49,456
Now, one of the things we do


506
00:24:49,456 --> 00:24:52,116
with Protocol Conformance is we
have an object of unknown type


507
00:24:52,116 --> 00:24:55,266
and we want to determine, does
it conform to the protocol?


508
00:24:55,456 --> 00:24:57,606
This is the "conforms
to protocol check"


509
00:24:57,606 --> 00:25:00,236
in the Objective-C runtime.


510
00:25:00,356 --> 00:25:02,506
In Swift, we do this same thing


511
00:25:03,056 --> 00:25:05,276
with the conditional
downcast operator.


512
00:25:05,836 --> 00:25:09,106
So we can just ask, is my object
the UITableViewDataSource"


513
00:25:09,686 --> 00:25:11,916
conforms to protocol check,
happens in the runtime,


514
00:25:12,196 --> 00:25:13,826
captures the results
in an optional.


515
00:25:14,216 --> 00:25:17,026
Here we can go easily do
that, call one of the methods


516
00:25:17,026 --> 00:25:19,926
and compute the number of
rows in the first section


517
00:25:19,976 --> 00:25:21,406
of this TableViewDataSource.


518
00:25:21,916 --> 00:25:25,146
Let's make our example a
little bit more interesting.


519
00:25:25,766 --> 00:25:28,446
Let's compute the number of
rows in the last section.


520
00:25:29,716 --> 00:25:32,446
So here we need to compute the
number of sections that exist


521
00:25:32,446 --> 00:25:36,936
in the TableView, subtract one
off of it, and then we can ask


522
00:25:36,936 --> 00:25:38,576
for the number of
rows in that section.


523
00:25:39,076 --> 00:25:41,506
Now there's a problem
with this code.


524
00:25:42,566 --> 00:25:45,226
And the problem is the number
of sections in TableView,


525
00:25:45,266 --> 00:25:48,186
as you might remember,
is an optional method.


526
00:25:48,766 --> 00:25:50,196
It might not be there
at runtime.


527
00:25:50,886 --> 00:25:53,876
So we're going to need to
compile error out of this


528
00:25:53,876 --> 00:25:55,706
because we need to deal
with the optionality


529
00:25:55,706 --> 00:25:57,006
of this protocol method.


530
00:25:57,836 --> 00:25:59,796
And we deal with this
the same way we deal


531
00:25:59,796 --> 00:26:02,736
with optionality everywhere
else in the Swift language,


532
00:26:03,576 --> 00:26:05,166
using the mechanisms we have.


533
00:26:05,166 --> 00:26:07,836
So here we're going to
use the chaining "?"


534
00:26:07,836 --> 00:26:11,916
operator. We're checking, does
my DataSource have a number


535
00:26:11,916 --> 00:26:13,626
of sections in TableView method?


536
00:26:14,066 --> 00:26:16,606
If so, call it, given
the TableView,


537
00:26:16,956 --> 00:26:19,156
and then we capture the
result in numSections


538
00:26:19,456 --> 00:26:21,226
so we can compute the
last section number


539
00:26:21,696 --> 00:26:23,926
and get the number of rows


540
00:26:24,026 --> 00:26:28,766
in the last section
of our TableView.


541
00:26:29,046 --> 00:26:30,996
That's about all we're going to
talk about with Protocols here.


542
00:26:31,716 --> 00:26:33,776
If you're interested
in Protocols and some


543
00:26:33,776 --> 00:26:35,196
of the amazing things
they can do,


544
00:26:35,586 --> 00:26:37,996
there's an "Advanced Swift"
talk tomorrow morning.


545
00:26:38,556 --> 00:26:41,756
It goes into more depth on
those and their interaction


546
00:26:42,296 --> 00:26:46,196
with the generic system.


547
00:26:46,196 --> 00:26:51,646
So, wrapping up here, AnyObject
is Swift's equivalent to id.


548
00:26:52,346 --> 00:26:53,856
The functionality is similar.


549
00:26:53,856 --> 00:26:56,386
The ideas are similar
and the uses are similar.


550
00:26:56,746 --> 00:26:58,706
However, it's more
safe by default.


551
00:26:59,756 --> 00:27:02,826
Now we didn't talk about it,
but there's also AnyClass,


552
00:27:02,956 --> 00:27:06,706
which is Swift's equivalent
to class and has most


553
00:27:06,706 --> 00:27:07,876
of the same behaviors.


554
00:27:08,446 --> 00:27:12,256
Now the other thing that we've
seen is how Optionals are used


555
00:27:12,336 --> 00:27:15,656
throughout the language to
represent dynamic checks.


556
00:27:16,276 --> 00:27:18,456
We've taken "is kind
of" class checks,


557
00:27:18,826 --> 00:27:22,416
conforms to protocol checks,
responds to selector checks,


558
00:27:22,706 --> 00:27:25,616
and folded them all into
the notion of Optionals


559
00:27:25,616 --> 00:27:28,706
within the language with
their optimized syntax


560
00:27:28,746 --> 00:27:31,976
to make them easy to use and
easy to do the right thing.


561
00:27:32,526 --> 00:27:38,336
With that, let's switch
gears a little bit and talk


562
00:27:38,336 --> 00:27:40,546
about Bridging of
Cocoa data types.


563
00:27:41,106 --> 00:27:44,516
Now first, let's talk a little
bit about the native Strings,


564
00:27:44,516 --> 00:27:46,736
Arrays, and the Dictionaries
within Swift.


565
00:27:47,586 --> 00:27:50,006
The goal of Swift
is to have one set


566
00:27:50,006 --> 00:27:53,296
of general-purpose native
value types that you use


567
00:27:53,296 --> 00:27:54,456
for nearly everything.


568
00:27:55,396 --> 00:27:57,066
These need to be
safe by default.


569
00:27:57,066 --> 00:27:58,846
This means bounds
restricting for arrays,


570
00:27:58,846 --> 00:28:00,796
automatic memory
management, and so on.


571
00:28:01,926 --> 00:28:04,636
They need to have predictable
performance so that you can look


572
00:28:04,636 --> 00:28:07,176
at code and have a sense
of how it's going to behave


573
00:28:07,176 --> 00:28:09,356
with no surprises, how
it's going to perform.


574
00:28:10,746 --> 00:28:13,116
And, of course, we want
arrays and dictionaries


575
00:28:13,616 --> 00:28:16,956
to be collections and they need
to be strongly typed collections


576
00:28:16,956 --> 00:28:17,946
that work with any type.


577
00:28:18,056 --> 00:28:19,886
We can't limit them
just to objects


578
00:28:19,926 --> 00:28:22,486
because sometimes you need
an array of strings or ints.


579
00:28:23,576 --> 00:28:26,746
And we don't have a seed to
fall back to for the cases


580
00:28:26,746 --> 00:28:27,976
where the other tools
don't work.


581
00:28:28,416 --> 00:28:31,206
This is it.


582
00:28:31,476 --> 00:28:34,776
Now, to support having
this one notion of one set


583
00:28:34,776 --> 00:28:37,656
of general purpose native value
types, we're going to bridge


584
00:28:37,656 --> 00:28:40,446
from Cocoa's NSString,
NSArray, NSDictionary,


585
00:28:40,816 --> 00:28:42,496
into the Swift-native
equivalents.


586
00:28:44,616 --> 00:28:46,836
So let's first talk a little bit


587
00:28:46,986 --> 00:28:49,226
about the native
string type itself.


588
00:28:50,326 --> 00:28:54,146
So, String is an efficient,
Unicode-compliant string type.


589
00:28:55,556 --> 00:28:59,356
Core string type of Swift
has Unicode built in through


590
00:28:59,356 --> 00:29:01,056
and through so it makes
it easy to work with.


591
00:29:01,626 --> 00:29:02,706
We provide flexible


592
00:29:02,706 --> 00:29:06,226
and efficient high-level
APIs to work with strings.


593
00:29:06,226 --> 00:29:08,696
You can easily do
concatenation, searches,


594
00:29:08,816 --> 00:29:11,076
prefix matches, sub-strings.


595
00:29:11,516 --> 00:29:14,106
And the strings provide
value semantics,


596
00:29:14,206 --> 00:29:15,716
which makes them
easier to work with.


597
00:29:16,416 --> 00:29:21,286
And value semantics is generally
a fairly simple notion of,


598
00:29:21,606 --> 00:29:23,476
you know, if I have two
variables of string type,


599
00:29:24,106 --> 00:29:27,706
modifying one of them doesn't
affect the other one, all right.


600
00:29:27,796 --> 00:29:30,436
This is very nice for a
fundamental data type.


601
00:29:32,716 --> 00:29:34,976
Now, of course, you can also
think of strings as a unit,


602
00:29:34,976 --> 00:29:37,026
but you can also think
of them as being composed


603
00:29:37,026 --> 00:29:39,496
of characters which,
in fact, they are.


604
00:29:40,476 --> 00:29:44,576
And so we can go walk over a
string and using the for loop,


605
00:29:44,816 --> 00:29:47,196
and get all of the
characters out of the string.


606
00:29:47,506 --> 00:29:49,596
And you get the answer
that you would expect.


607
00:29:49,646 --> 00:29:52,806
There are five characters here
even though there's no emoji


608
00:29:53,596 --> 00:29:55,516
at the end.


609
00:29:55,516 --> 00:30:01,016
So I want to talk a little bit
about characters and code points


610
00:30:02,106 --> 00:30:03,856
because the character
that you're getting


611
00:30:03,856 --> 00:30:04,976
out of here is a full
Unicode character.


612
00:30:05,236 --> 00:30:09,166
It's not a UTF-8 code
point or UTF-16 code point


613
00:30:09,166 --> 00:30:09,936
that you have to deal with.


614
00:30:10,376 --> 00:30:12,226
It is a Unicode character.


615
00:30:13,386 --> 00:30:16,706
And now, one of the challenges
with the Unicode characters is,


616
00:30:16,706 --> 00:30:20,866
you really can't encode
them efficiently in a way


617
00:30:20,866 --> 00:30:24,866
that treats a string as
just an array of characters.


618
00:30:25,586 --> 00:30:26,456
It would be too large.


619
00:30:27,096 --> 00:30:28,946
And so what you generally see is


620
00:30:28,946 --> 00:30:33,346
that a string is encoded
as, say, UTF-8 or UTF-16.


621
00:30:34,376 --> 00:30:37,446
But working with those
UTF-8 or UTF-16 code points,


622
00:30:37,736 --> 00:30:40,556
that requires Unicode expertise
to get right all the time.


623
00:30:42,246 --> 00:30:44,126
And so we made a really
interesting decision here.


624
00:30:45,336 --> 00:30:49,066
We decided not to provide the
super low-level operations


625
00:30:49,066 --> 00:30:52,856
like length and characterAtIndex
to let you poke directly


626
00:30:52,856 --> 00:30:55,796
at the UTF-16 or UTF-8 code
points, or whatever is stored


627
00:30:55,796 --> 00:30:59,786
in the string because doing
so causes big problems.


628
00:30:59,886 --> 00:31:03,876
Instead we want you to
use the high-level APIs


629
00:31:04,186 --> 00:31:06,726
and let the library do
the hard work of dealing


630
00:31:06,726 --> 00:31:08,516
with all the intricacies
of Unicode.


631
00:31:09,086 --> 00:31:13,056
Of course, there's still common
operations you want to use.


632
00:31:13,546 --> 00:31:16,836
You may want to count the number
of characters in a string,


633
00:31:17,526 --> 00:31:19,946
so there's this countElements
algorithm.


634
00:31:19,946 --> 00:31:23,296
It works on any sequence
and allows you to, well,


635
00:31:23,366 --> 00:31:25,176
just count the number of
characters in a string,


636
00:31:25,546 --> 00:31:27,146
and this produces
the right answer,


637
00:31:27,146 --> 00:31:29,566
which is there are five
characters in this string.


638
00:31:30,426 --> 00:31:32,846
Some of you will want to
work with code points, right.


639
00:31:33,336 --> 00:31:36,006
You may be Unicode experts
and that's wonderful.


640
00:31:36,396 --> 00:31:38,206
You can get access
to the code points.


641
00:31:38,356 --> 00:31:42,996
There's a property UTF-16 that
gives you a lazily computed view


642
00:31:42,996 --> 00:31:46,976
on the string producing
the UTF-16 code points


643
00:31:46,976 --> 00:31:47,746
in that string.


644
00:31:49,316 --> 00:31:53,216
And we can go walk over
the 16-bit unsigned integer


645
00:31:53,546 --> 00:31:54,656
code points.


646
00:31:55,096 --> 00:31:58,536
We can print out the number of
code points here and, of course,


647
00:31:58,536 --> 00:32:00,836
you'll get the answer "6"


648
00:32:01,306 --> 00:32:04,966
because there are six UTF-16
code points in this string.


649
00:32:06,056 --> 00:32:06,956
The last thing I want to talk


650
00:32:06,956 --> 00:32:09,376
about with strings
is the relationship


651
00:32:09,376 --> 00:32:11,466
between string and NSSring.


652
00:32:12,726 --> 00:32:14,686
So NSString has a wealth


653
00:32:14,926 --> 00:32:17,586
of really great text
processing APIs


654
00:32:17,916 --> 00:32:19,856
that you've probably
been using for years.


655
00:32:20,376 --> 00:32:23,886
So we've made all those
Foundation APIs directly


656
00:32:23,886 --> 00:32:26,846
available on the string
type, so the APIs you know


657
00:32:26,846 --> 00:32:29,506
and love are there,
and you can use them.


658
00:32:30,716 --> 00:32:33,706
Now in doing so, we've made
them a little bit more Swift.


659
00:32:33,706 --> 00:32:35,976
We've tightened up the
type signatures so that


660
00:32:35,976 --> 00:32:38,996
if you're going to split a
string into its components,


661
00:32:38,996 --> 00:32:41,826
well, you're getting it back
an array of strings rather


662
00:32:41,826 --> 00:32:43,726
than just an array
of somethings.


663
00:32:45,596 --> 00:32:49,316
Now you may have developed
your own categories on NSString


664
00:32:49,566 --> 00:32:51,426
with additional functionality
that you use


665
00:32:51,426 --> 00:32:52,896
within your own applications.


666
00:32:53,896 --> 00:32:55,946
You can get to those
with a simple Cast.


667
00:32:56,086 --> 00:32:59,626
So you can take a Swift string,
turn it into an NSString,


668
00:32:59,796 --> 00:33:00,926
so this is just a conversion,


669
00:33:01,986 --> 00:33:04,426
and then call your
NSStringMethod.


670
00:33:05,636 --> 00:33:07,996
If you find yourselves
doing this a lot,


671
00:33:08,696 --> 00:33:10,646
feel free to just go ahead


672
00:33:10,646 --> 00:33:12,656
and extend the underlying
string type.


673
00:33:12,966 --> 00:33:15,196
Add your StringMethod,
make it a little more Swift


674
00:33:15,196 --> 00:33:17,486
with strong type signatures,
closures if you'd like.


675
00:33:18,766 --> 00:33:22,146
But this should help you feel
at home in Swift fairly quickly


676
00:33:22,376 --> 00:33:24,166
and use the String type.


677
00:33:25,476 --> 00:33:29,306
Now let's move from
String to a container.


678
00:33:29,566 --> 00:33:31,486
Let's talk about Arrays.


679
00:33:32,376 --> 00:33:36,396
So here we have toolbar
items that is in an NSArray.


680
00:33:37,036 --> 00:33:43,386
That's going to come into
Swift as an array of AnyObject.


681
00:33:44,386 --> 00:33:46,656
Now these two types
are fairly similar.


682
00:33:47,346 --> 00:33:49,826
You can iterate over them
and what you're going to get


683
00:33:49,826 --> 00:33:52,396
out of it are values
of type AnyObject.


684
00:33:52,466 --> 00:33:54,646
They're objects but you don't
know what kind of object it is.


685
00:33:55,356 --> 00:33:57,486
You can subscript into
them and, of course,


686
00:33:57,486 --> 00:33:58,786
you will get an AnyObject.


687
00:34:00,256 --> 00:34:04,976
Now, in Swift, you tend to deal
in typed arrays more often.


688
00:34:05,446 --> 00:34:07,906
And so there are
some other operations


689
00:34:07,906 --> 00:34:09,846
that the core language
needs to provide


690
00:34:09,846 --> 00:34:11,315
for you to make this clean.


691
00:34:12,085 --> 00:34:16,696
So maybe I'm composing my
toolbar items into a Swift array


692
00:34:17,176 --> 00:34:20,406
and that Swift array is going
to contain UIBarButtonItems.


693
00:34:20,926 --> 00:34:24,716
That's what actually goes into
the toolbar items property.


694
00:34:25,706 --> 00:34:29,636
I can work with that Swift
Array and then I can assign it


695
00:34:29,636 --> 00:34:31,335
into the AnyObject array.


696
00:34:31,335 --> 00:34:35,065
So this is essentially doing
a safe upcast of any array


697
00:34:35,065 --> 00:34:37,636
of ToolbarItems to any
array of AnyObjects.


698
00:34:38,456 --> 00:34:40,906
It also happens to be
calling into Objective-C,


699
00:34:41,085 --> 00:34:43,916
which we'll get to in a minute.


700
00:34:44,076 --> 00:34:48,025
Now we also see the flip side
of this where we want to, say,


701
00:34:48,025 --> 00:34:49,636
iterate over all
the ToolbarItems


702
00:34:50,735 --> 00:34:56,295
in this particular view
controller and here we're going


703
00:34:56,295 --> 00:34:59,476
to get AnyObject values and,
we talked about cast earlier,


704
00:34:59,476 --> 00:35:01,226
so we can downcast each of them.


705
00:35:01,756 --> 00:35:04,406
This is fine but it's a little
bit on the tedious side.


706
00:35:04,766 --> 00:35:07,076
And so we have specialized
syntax here


707
00:35:07,296 --> 00:35:12,836
to downcast an entire
array at a time doing the


708
00:35:12,836 --> 00:35:14,656
"is kind of" class
checks necessary


709
00:35:14,656 --> 00:35:17,436
to make this safe
lazily behind the scenes.


710
00:35:18,596 --> 00:35:19,966
And then you can walk
over all with them.


711
00:35:20,516 --> 00:35:26,086
[ Applause ]


712
00:35:26,586 --> 00:35:29,646
Now, we've seen NSArrays
in the Objective-C side,


713
00:35:30,176 --> 00:35:32,506
Swift arrays on the Swift side.


714
00:35:32,946 --> 00:35:35,116
Let's take a little bit
of a peek under the hood


715
00:35:35,296 --> 00:35:38,226
at how this actually
works because you're going


716
00:35:38,226 --> 00:35:41,526
to be writing a lot of Swift
code that interacts with a lot


717
00:35:41,526 --> 00:35:43,626
of Objective-C code and we
want this to perform well.


718
00:35:45,456 --> 00:35:48,496
So there's a Swift array.


719
00:35:48,536 --> 00:35:52,896
And the Swift array actually has
two internal representations.


720
00:35:53,826 --> 00:35:56,726
Its first representation is
probably what you'd expect


721
00:35:56,726 --> 00:35:57,286
out of Swift.


722
00:35:57,756 --> 00:35:59,206
It's a native representation.


723
00:35:59,596 --> 00:36:02,166
It has a length, which is the
number of elements in the array.


724
00:36:02,166 --> 00:36:04,316
It has a capacity that's used


725
00:36:04,316 --> 00:36:07,026
so we can algorithmically
efficiently add things


726
00:36:07,026 --> 00:36:07,556
to the array.


727
00:36:09,126 --> 00:36:12,926
And then it has the buffer of
elements that are in the array.


728
00:36:14,416 --> 00:36:17,916
And, of course, those buffered
elements, whatever kind


729
00:36:17,916 --> 00:36:19,736
of array it is, that's how
much storage they take.


730
00:36:19,736 --> 00:36:21,906
If we have an array
of 32-bit integers,


731
00:36:21,906 --> 00:36:24,156
each element takes
32 bits of storage.


732
00:36:24,156 --> 00:36:25,966
There's not extra
boxing going on here,


733
00:36:26,666 --> 00:36:27,776
no extra performance loss.


734
00:36:27,946 --> 00:36:30,986
It's just a native buffer.


735
00:36:31,166 --> 00:36:33,906
Now we also have this
second representation


736
00:36:34,526 --> 00:36:37,446
and we do a couple of pointer
tricks so that we can fit it


737
00:36:37,446 --> 00:36:39,546
into just a tiny
amount of memory.


738
00:36:40,116 --> 00:36:42,076
And that's the Cocoa
representation.


739
00:36:43,236 --> 00:36:49,096
So any Swift array can actually
be an NSArray underneath


740
00:36:49,256 --> 00:36:50,346
as representation.


741
00:36:50,966 --> 00:36:54,476
And all the operations
on an array handle both


742
00:36:54,476 --> 00:36:55,996
of these representations.


743
00:36:56,486 --> 00:37:00,386
So if I subscript my array and
it happens to be an NSArray,


744
00:37:00,916 --> 00:37:02,886
we'll use object and
index behind the scenes.


745
00:37:03,666 --> 00:37:04,926
So you get the result
that you want.


746
00:37:05,916 --> 00:37:07,606
If we do append to
such an array, well,


747
00:37:07,636 --> 00:37:10,196
we can flip the representation
quickly and give you


748
00:37:10,196 --> 00:37:11,566
that efficient append operation.


749
00:37:12,166 --> 00:37:16,176
So given these two
representations,


750
00:37:16,356 --> 00:37:20,066
we can talk about the notion
of bridging, of converting


751
00:37:20,666 --> 00:37:23,746
between an NSArray, as
Objective-C would see,


752
00:37:24,786 --> 00:37:26,936
and a Swift array that
you use within Swift.


753
00:37:28,256 --> 00:37:29,216
There's two directions here:


754
00:37:29,696 --> 00:37:31,686
going to Objective-C
and coming back.


755
00:37:32,986 --> 00:37:36,416
So first, let's talk
about coming back.


756
00:37:37,196 --> 00:37:39,036
So we have an Objective-C
method.


757
00:37:39,036 --> 00:37:41,336
In this case, it's the
getter for toolbar items.


758
00:37:41,766 --> 00:37:43,686
In Objective-C, that
returns NSArray.


759
00:37:44,406 --> 00:37:47,576
In Swift, that's going to come
back as an array of AnyObject.


760
00:37:48,236 --> 00:37:49,136
How do we do this?


761
00:37:49,586 --> 00:37:51,406
Well, given our two
representations,


762
00:37:51,956 --> 00:37:53,386
it's extremely efficient
to do it


763
00:37:53,386 --> 00:37:54,976
because we have our
representation


764
00:37:55,266 --> 00:37:57,846
that can just take
that NSArray directly.


765
00:37:58,426 --> 00:38:00,616
All we need to do is
one copy operation


766
00:38:00,946 --> 00:38:03,256
to make sure the contents
don't change underneath us


767
00:38:03,256 --> 00:38:04,616
if it's a mutable array.


768
00:38:05,746 --> 00:38:08,206
But the common case here is
that it's not a mutable array.


769
00:38:08,336 --> 00:38:12,436
It's an immutable NSArray and so
this copy operation is trivial.


770
00:38:12,436 --> 00:38:14,966
It's a message send, it's
a retain, and that's it.


771
00:38:15,366 --> 00:38:16,926
So its conversion
is extremely fast.


772
00:38:17,746 --> 00:38:20,646
Let's talk about
the other direction,


773
00:38:21,576 --> 00:38:23,656
going from a Swift
array to an NSArray.


774
00:38:24,146 --> 00:38:27,556
So this would happen when we
take, say, our ToolbarItems.


775
00:38:27,556 --> 00:38:28,436
It's a Swift array.


776
00:38:28,946 --> 00:38:31,036
And we call the Objective-C
setter,


777
00:38:31,446 --> 00:38:32,886
which expects an NSArray.


778
00:38:33,586 --> 00:38:36,036
Well, now we have an
interesting question


779
00:38:36,906 --> 00:38:38,686
because there's two possible
representations here.


780
00:38:39,176 --> 00:38:40,496
There's the really easy answer.


781
00:38:41,036 --> 00:38:43,186
It's already in the
Cocoa representation


782
00:38:43,386 --> 00:38:46,246
and we can just hand off
the NSArray, no work at all.


783
00:38:47,696 --> 00:38:50,546
But the native one, that a
different question entirely.


784
00:38:51,406 --> 00:38:55,906
We could copy the whole buffer
but that would be awful.


785
00:38:55,906 --> 00:38:59,016
We could possibly go
allocate a little shim object.


786
00:38:59,016 --> 00:39:00,636
That's also possible.


787
00:39:01,346 --> 00:39:05,096
Instead, we decided to make
our native representation


788
00:39:06,016 --> 00:39:08,866
into a little bit of an
Objective-C object [laughter].


789
00:39:09,526 --> 00:39:12,376
It's already an NSArray.


790
00:39:13,516 --> 00:39:15,986
And we've optimized
the allocation here


791
00:39:16,406 --> 00:39:18,656
so we can build these
objects super fast


792
00:39:19,476 --> 00:39:21,776
and just pass off our
native representation


793
00:39:21,956 --> 00:39:24,826
as if it were an NSArray
and it works beautifully


794
00:39:24,826 --> 00:39:26,466
on the Objective-C side.


795
00:39:29,516 --> 00:39:33,856
[ Applause ]


796
00:39:34,356 --> 00:39:37,216
I think that's enough
of Bridging.


797
00:39:37,696 --> 00:39:39,106
Let's talk about subclassing.


798
00:39:41,206 --> 00:39:52,556
Okay. So, Swift objects are
all Objective-C objects.


799
00:39:53,776 --> 00:39:56,546
Now what this means is that,
if you define a class in Swift,


800
00:39:57,456 --> 00:39:59,976
it has basic Objective-C
interoperability built in.


801
00:40:00,226 --> 00:40:05,136
We use the same layout as an
Objective-C class so there's an


802
00:40:05,136 --> 00:40:06,346
"isa" pointer in there.


803
00:40:06,346 --> 00:40:09,366
The "isa" pointer points
out to Objective-C metadata.


804
00:40:10,166 --> 00:40:12,306
There's the same
underlying infrastructure,


805
00:40:12,306 --> 00:40:15,836
the thing that makes "arch" work
and the basic frameworks work


806
00:40:15,836 --> 00:40:16,906
with retain and release.


807
00:40:17,116 --> 00:40:18,296
You can expect a class.


808
00:40:19,136 --> 00:40:19,786
That sort of thing.


809
00:40:20,086 --> 00:40:20,896
They're all available.


810
00:40:22,416 --> 00:40:25,376
Now, if you really want to
make use of your classes


811
00:40:25,486 --> 00:40:29,386
from within your
Objective-C code, well,


812
00:40:29,386 --> 00:40:32,246
then you should inherit
from an Objective-C class,


813
00:40:32,616 --> 00:40:35,106
whether it's NSObject
or some other class.


814
00:40:35,596 --> 00:40:38,926
And this is going to expose your
class to the Objective-C world


815
00:40:38,926 --> 00:40:42,516
and make all the things you
write in Swift available also


816
00:40:42,516 --> 00:40:43,606
to your Objective-C code.


817
00:40:44,746 --> 00:40:47,226
So we're going to continue
with our UIDocument example


818
00:40:47,226 --> 00:40:50,636
from earlier and we're going to
create a little MyDocument class


819
00:40:50,676 --> 00:40:52,766
that inherits from UIDocument.


820
00:40:53,266 --> 00:40:57,046
And we're going to
talk about a couple


821
00:40:57,046 --> 00:40:58,666
of the things that
subclasses do.


822
00:40:59,076 --> 00:41:00,266
They override methods.


823
00:41:01,276 --> 00:41:03,546
So here we're going to
override the handleError,


824
00:41:03,546 --> 00:41:05,566
userInteractionPermitted method.


825
00:41:06,636 --> 00:41:09,486
And you do this exactly
the same way as you'd do it


826
00:41:09,486 --> 00:41:11,156
if you were overriding
a Swift method.


827
00:41:11,426 --> 00:41:12,196
It doesn't matter.


828
00:41:12,196 --> 00:41:13,486
The syntax is the same.


829
00:41:13,636 --> 00:41:15,856
The fact that the super class
is written in Objective-C?


830
00:41:16,116 --> 00:41:18,596
Completely irrelevant to
the syntax of the language


831
00:41:18,896 --> 00:41:19,796
and how you work with it.


832
00:41:21,856 --> 00:41:23,916
Now one thing to note
in Swift is that the


833
00:41:23,916 --> 00:41:26,726
"override" keyword is mandatory.


834
00:41:28,146 --> 00:41:28,976
Why do we do that?


835
00:41:29,296 --> 00:41:30,656
There's a couple of
reasons for doing that.


836
00:41:31,346 --> 00:41:35,136
One of the reasons is because
when you look at a method,


837
00:41:35,726 --> 00:41:38,306
you probably want to know
if the intention here is


838
00:41:38,306 --> 00:41:41,046
to override your
super class's behavior


839
00:41:41,046 --> 00:41:43,906
because that's a really
important part of your API.


840
00:41:44,136 --> 00:41:45,136
It's a really part


841
00:41:45,136 --> 00:41:48,166
of understanding what this
method is supposed to do.


842
00:41:48,766 --> 00:41:54,236
Now the other thing it does is
it helps overriding accidents.


843
00:41:55,236 --> 00:41:58,496
For example, I meant to override
something from my super class,


844
00:41:59,056 --> 00:42:01,046
but I typed part of
the selector wrong


845
00:42:01,796 --> 00:42:04,006
and the method name
no longer overrides.


846
00:42:04,286 --> 00:42:06,896
My code isn't running
and I have no idea why.


847
00:42:06,896 --> 00:42:09,696
Well, with mandatory
override, we catch that.


848
00:42:09,946 --> 00:42:12,286
If you didn't override something
and you thought you did,


849
00:42:12,986 --> 00:42:13,826
compiler will complain.


850
00:42:15,456 --> 00:42:19,196
There's also the real
surprise which is


851
00:42:19,256 --> 00:42:21,916
when you override something
from your super class


852
00:42:21,966 --> 00:42:23,786
that you didn't even
know existed.


853
00:42:24,386 --> 00:42:30,046
And this is the case where you
just wrote a method and maybe


854
00:42:30,046 --> 00:42:32,266
in this release that
method happens to exist


855
00:42:32,266 --> 00:42:34,276
or maybe it doesn't
exist in this release,


856
00:42:34,736 --> 00:42:37,516
but some joker added it to the
next release in the frameworks


857
00:42:37,516 --> 00:42:39,696
that you use and now
you're overriding something


858
00:42:39,696 --> 00:42:41,166
that you didn't know
existed at the time.


859
00:42:41,996 --> 00:42:44,886
We can catch that by
requiring override throughout


860
00:42:45,356 --> 00:42:45,926
the language.


861
00:42:46,516 --> 00:42:51,686
We could also talk a little bit
about overriding properties.


862
00:42:53,436 --> 00:42:57,406
So, in Swift, you don't
override the getter


863
00:42:57,586 --> 00:42:58,926
or the setter separately.


864
00:42:59,146 --> 00:43:01,796
Instead you override
the property itself


865
00:43:02,396 --> 00:43:06,116
and then you provide a getter
or a setter as appropriate.


866
00:43:06,716 --> 00:43:08,276
So here we're doing
something very simple.


867
00:43:08,276 --> 00:43:10,476
We're overriding the
description property


868
00:43:11,046 --> 00:43:12,616
and providing a new
getter for it.


869
00:43:13,806 --> 00:43:16,176
Now what this means to
the Objective-C runtime,


870
00:43:16,416 --> 00:43:17,636
to your Objective-C code,


871
00:43:17,636 --> 00:43:19,326
is that you've overridden
the getter.


872
00:43:20,546 --> 00:43:23,276
But the semantic model
in Swift is different.


873
00:43:23,276 --> 00:43:26,386
It's based on overriding the
actual thing that was declared.


874
00:43:26,386 --> 00:43:27,646
In this case, the property.


875
00:43:28,216 --> 00:43:32,636
As I mentioned before,
NSError is going to come back.


876
00:43:33,446 --> 00:43:35,966
So we have contentsForType
error we're going


877
00:43:35,966 --> 00:43:37,346
to override in our subclass.


878
00:43:37,766 --> 00:43:40,576
And remember that the
Objective-C method took NSError,


879
00:43:42,226 --> 00:43:45,806
a C pointer to an NSError
which could be nil.


880
00:43:47,346 --> 00:43:49,986
The way we work with
these in Swift is


881
00:43:49,986 --> 00:43:53,646
that the NSErrorPointer class
provides a couple of operations


882
00:43:53,646 --> 00:43:55,336
that you would expect
out of a pointer.


883
00:43:55,736 --> 00:43:58,966
You can test it for nil, as
we do in the if check here,


884
00:43:59,396 --> 00:44:02,116
to see whether we were actually
given a valid point error


885
00:44:02,116 --> 00:44:04,216
where it's being given
nil by our caller.


886
00:44:05,426 --> 00:44:07,596
Now, if it's not
nil, we can point


887
00:44:07,596 --> 00:44:10,006
at the memory location
associated with that pointer


888
00:44:10,556 --> 00:44:14,756
by referring to it as
error.memory and we can read


889
00:44:14,756 --> 00:44:16,846
from that memory or
write to that memory


890
00:44:16,846 --> 00:44:18,356
by just reading or
signing to it.


891
00:44:19,566 --> 00:44:21,426
Now, and this error pointer
is going to take care


892
00:44:21,426 --> 00:44:24,726
of the nitty-gritty details
of making this auto-releasing


893
00:44:24,866 --> 00:44:27,146
to fit in with the
code conventions


894
00:44:27,146 --> 00:44:29,316
of Cocoa NSError handling.


895
00:44:29,316 --> 00:44:33,146
So it's actually fairly easy
to deal with the C pointer


896
00:44:33,346 --> 00:44:34,516
from within the Swift world.


897
00:44:35,266 --> 00:44:36,626
Now let's take a look
at the Swift class


898
00:44:36,626 --> 00:44:37,856
that we've been building here.


899
00:44:38,436 --> 00:44:42,266
We have MyDocument.


900
00:44:42,266 --> 00:44:43,796
It inherits from UIDocument.


901
00:44:44,356 --> 00:44:45,556
It has a property in it.


902
00:44:45,556 --> 00:44:47,226
It has some method overrides.


903
00:44:47,986 --> 00:44:50,106
It's just a Swift class
through and through.


904
00:44:51,256 --> 00:44:54,316
But all of this is
accessible directly


905
00:44:54,316 --> 00:44:56,096
in your Objective-C code.


906
00:44:57,386 --> 00:44:59,326
So if you project
this into Objective-C,


907
00:44:59,886 --> 00:45:01,656
it would look like this.


908
00:45:01,656 --> 00:45:04,406
All the same elements are there.


909
00:45:04,406 --> 00:45:05,306
We have properties.


910
00:45:05,306 --> 00:45:06,166
We have methods.


911
00:45:06,686 --> 00:45:08,636
Now there's some interesting
things to point out.


912
00:45:09,216 --> 00:45:12,596
Well, for one, we have
this item's property


913
00:45:12,596 --> 00:45:13,776
that is in an NSArray.


914
00:45:14,866 --> 00:45:16,596
Remember, we talked
about bridging here.


915
00:45:17,836 --> 00:45:21,046
The original Swift code
had an array of strings.


916
00:45:22,496 --> 00:45:25,416
We bridged that seamlessly
over to an NSArray


917
00:45:25,446 --> 00:45:27,666
that contains NSString objects


918
00:45:27,866 --> 00:45:29,626
for your Objective-C
code to use.


919
00:45:30,146 --> 00:45:35,166
So you can use strong typing
in the Swift world and it maps


920
00:45:35,166 --> 00:45:38,606
over to the natural thing
within the Objective-C world.


921
00:45:39,746 --> 00:45:43,486
The other thing I want to point
out is this really ugly name


922
00:45:43,486 --> 00:45:44,436
up top you've noticed.


923
00:45:45,346 --> 00:45:46,466
So this is a mangled name.


924
00:45:47,386 --> 00:45:50,986
Usually you're going to see
this as MyApp.MyDocument,


925
00:45:51,996 --> 00:45:53,716
unless you're poking at
the internal somewhere.


926
00:45:54,306 --> 00:46:00,126
And the purpose of this mangled
name is to put everything


927
00:46:00,126 --> 00:46:02,566
in a namespace of some
sort so you don't have


928
00:46:02,566 --> 00:46:04,756
to prefix all of
your class names.


929
00:46:05,616 --> 00:46:09,436
Instead, what Swift does
is it puts the module name,


930
00:46:09,496 --> 00:46:11,786
which is your target, your
framework, or your app -


931
00:46:12,886 --> 00:46:16,186
that name into the names
of the classes it creates


932
00:46:16,386 --> 00:46:18,956
so you can use the
simple names that you want


933
00:46:18,956 --> 00:46:21,486
to use throughout your
application and not worry


934
00:46:21,486 --> 00:46:24,246
about a conflict with something
else in the system somewhere.


935
00:46:26,516 --> 00:46:32,286
[ Applause ]


936
00:46:32,786 --> 00:46:34,106
When you're writing
your Swift Classes,


937
00:46:34,326 --> 00:46:36,436
you do need to be a
little bit cognizant


938
00:46:37,006 --> 00:46:38,886
of the limits of Objective-C.


939
00:46:39,906 --> 00:46:42,286
Swift has a lot of cool
features; you might want


940
00:46:42,286 --> 00:46:45,336
to use them -Tuples,
Generics and so on.


941
00:46:45,876 --> 00:46:48,426
And if you go crazy
in your classes


942
00:46:48,426 --> 00:46:51,526
and you use these features,
you might be a little surprised


943
00:46:51,526 --> 00:46:55,966
that this generic method that
returns a tuple doesn't show


944
00:46:55,966 --> 00:46:58,576
up in your Objective-C code
because Objective-C has no way


945
00:46:58,576 --> 00:46:59,766
to express that signature.


946
00:47:00,306 --> 00:47:01,076
There's nothing we can do.


947
00:47:01,076 --> 00:47:02,386
We don't have tuples
in Objective-C.


948
00:47:04,216 --> 00:47:07,186
So if this happens to you
and you're surprised by it,


949
00:47:08,176 --> 00:47:10,046
there's an attribute you
can add to your method.


950
00:47:10,716 --> 00:47:12,046
It's the objc attribute.


951
00:47:12,596 --> 00:47:16,656
And what this does is it
asks the compiler to check


952
00:47:17,166 --> 00:47:22,326
and make sure that this method
or property or initializer


953
00:47:22,326 --> 00:47:26,636
or whatever is expressible in
Objective-C so it can be used


954
00:47:26,636 --> 00:47:27,856
from your Objective-C code.


955
00:47:28,566 --> 00:47:31,566
And if it's not expressible in
Objective-C for some reason,


956
00:47:31,896 --> 00:47:33,696
the compiler will
give you a hard error


957
00:47:33,696 --> 00:47:36,536
to tell you this is not
something you can use


958
00:47:36,536 --> 00:47:37,246
from Objective-C.


959
00:47:39,006 --> 00:47:42,676
Now the objc attribute
actually has a second purpose.


960
00:47:42,866 --> 00:47:45,626
And that's controlling
the names that you see


961
00:47:45,626 --> 00:47:47,386
in the Objective-C
side of things.


962
00:47:48,456 --> 00:47:50,096
So, here's a property enabled.


963
00:47:50,286 --> 00:47:51,046
It has a getter.


964
00:47:51,046 --> 00:47:51,806
It has a setter.


965
00:47:53,486 --> 00:47:56,336
In Objective-C this is going to
come through as a property named


966
00:47:56,336 --> 00:48:00,216
"enabled," a getter named
"enabled," and a setter named


967
00:48:00,216 --> 00:48:04,436
"setEnabled:" That's
not Cocoa convention.


968
00:48:04,596 --> 00:48:07,346
You'd really rather the call,
the getter, "isEnabled".


969
00:48:08,726 --> 00:48:11,186
And so to do that we just
use the objc attribute,


970
00:48:11,946 --> 00:48:13,976
provide it with the
selector "isEnabled"


971
00:48:14,346 --> 00:48:17,136
so we can control
the mapping ourselves


972
00:48:17,136 --> 00:48:18,746
between these two languages.


973
00:48:19,476 --> 00:48:21,206
I don't expect you
to do this often,


974
00:48:21,856 --> 00:48:24,866
but it's there if you need it.


975
00:48:25,136 --> 00:48:29,746
You can also do this
for the name of a class.


976
00:48:29,916 --> 00:48:32,106
And what we have here
in the parentheses,


977
00:48:32,326 --> 00:48:36,806
in the objc attribute, is the
non-named space name of a class.


978
00:48:37,406 --> 00:48:38,706
So why would you do this?


979
00:48:39,206 --> 00:48:42,556
Well, perhaps you're porting
part of your application


980
00:48:42,556 --> 00:48:44,496
from Objective-C to
Swift for some reason.


981
00:48:45,036 --> 00:48:46,906
And so you had ABCMyDocument.


982
00:48:47,226 --> 00:48:48,816
Now you just want to
call it MyDocument


983
00:48:48,816 --> 00:48:50,316
because you're sick
of typing ABC.


984
00:48:51,346 --> 00:48:53,876
However, you have some
archives that you still want


985
00:48:53,876 --> 00:48:55,446
to have work, because
this is going


986
00:48:55,446 --> 00:48:57,466
to be a drop-in compatible
implementation.


987
00:48:58,316 --> 00:49:00,116
In Swift, for your
Objective-C class,


988
00:49:00,476 --> 00:49:01,976
you can use the objc attribute


989
00:49:02,116 --> 00:49:06,676
to give this class the
runtime name of ABCMyDocument


990
00:49:06,926 --> 00:49:08,526
and keep all of your
archives working.


991
00:49:08,526 --> 00:49:11,836
One last thing I
promised to talk about,


992
00:49:12,276 --> 00:49:14,246
and that's CF Interoperability.


993
00:49:15,286 --> 00:49:20,216
So by CF we're referring
to all of the C-like APIs


994
00:49:20,296 --> 00:49:22,686
that work with the C objects.


995
00:49:22,966 --> 00:49:24,476
So, this is Core Foundation.


996
00:49:24,476 --> 00:49:27,706
This is Core Graphics
and other frameworks,


997
00:49:27,706 --> 00:49:29,056
maybe some of your
own frameworks.


998
00:49:29,866 --> 00:49:32,976
And let's take a
little look at using CF,


999
00:49:33,196 --> 00:49:35,906
particularly Core
Graphics in Objective-C.


1000
00:49:36,256 --> 00:49:38,426
I'm going to do something
really simple here.


1001
00:49:38,496 --> 00:49:42,806
I'm going to draw a gradient in
a rectangle using Core Graphics.


1002
00:49:43,276 --> 00:49:46,686
Here's my start.


1003
00:49:47,096 --> 00:49:48,916
I need to go build
up the ColorSpace


1004
00:49:49,006 --> 00:49:49,986
and build up the Gradient.


1005
00:49:50,036 --> 00:49:54,496
Now there's a couple of things
of here that I find non-optimal.


1006
00:49:55,236 --> 00:49:56,956
So the one thing
is bridge casts.


1007
00:49:57,916 --> 00:49:58,726
So we're in ARC.


1008
00:50:00,056 --> 00:50:00,666
It's partly great.


1009
00:50:00,666 --> 00:50:02,366
It's handling our
NSArray for us.


1010
00:50:02,366 --> 00:50:04,596
We're using the nice
array literal syntax.


1011
00:50:04,846 --> 00:50:09,136
But now we need to do bridge
casts between CGColorRef and id


1012
00:50:09,136 --> 00:50:11,296
so we can put things
into the NSArray.


1013
00:50:12,866 --> 00:50:15,536
And we have this
CFArray cast sort


1014
00:50:15,536 --> 00:50:16,836
of doing toll-free
bridging there


1015
00:50:16,996 --> 00:50:19,296
between the NSArray
and the CFArray.


1016
00:50:20,666 --> 00:50:24,076
And there's also this
semi-amusing thing


1017
00:50:24,076 --> 00:50:26,656
that we're using three
different kinds of arrays


1018
00:50:27,186 --> 00:50:28,356
in four lines of code.


1019
00:50:28,796 --> 00:50:34,246
And you can write this - you
can try to write this better.


1020
00:50:34,246 --> 00:50:37,546
I couldn't, actually, find a way
to make it cleaner than this.


1021
00:50:38,216 --> 00:50:40,186
And it's really unfortunate


1022
00:50:40,416 --> 00:50:43,236
because the NSArray gives
us some useful behavior.


1023
00:50:43,236 --> 00:50:45,056
ARC is managing its
lifetime for us.


1024
00:50:45,056 --> 00:50:45,686
That's great.


1025
00:50:46,086 --> 00:50:49,676
We need the C Array because
we need to put CGFloats in it,


1026
00:50:50,246 --> 00:50:52,166
and we can't do that
within NSArray.


1027
00:50:53,596 --> 00:50:56,256
And finally, we need to
do the toll-free bridging


1028
00:50:56,256 --> 00:51:00,846
over to CFArrayRef
because that's what we use


1029
00:51:00,846 --> 00:51:04,846
with Core Graphics APIs.


1030
00:51:05,056 --> 00:51:07,066
Now, moving along, we
can create some points


1031
00:51:07,066 --> 00:51:10,696
with CGPointMake and, of course,
even though you're under ARC


1032
00:51:10,986 --> 00:51:12,996
where memory management
is automatic,


1033
00:51:13,366 --> 00:51:15,556
it's not automated
for CF things.


1034
00:51:15,556 --> 00:51:17,796
So we have to remember
to release the ColorSpace


1035
00:51:17,896 --> 00:51:18,906
and release the Gradient.


1036
00:51:19,636 --> 00:51:21,046
We feel like we can
do a little bit better


1037
00:51:21,046 --> 00:51:21,816
in the world of Swift.


1038
00:51:23,106 --> 00:51:26,686
So let's start again,
this time in Swift.


1039
00:51:27,126 --> 00:51:29,296
And first, let's
build our colorSpace.


1040
00:51:30,256 --> 00:51:33,156
So here we're just calling
CGColorSpaceCreateDeviceRGB().


1041
00:51:34,746 --> 00:51:35,996
Nothing different about that.


1042
00:51:36,856 --> 00:51:39,236
However, the type that we infer


1043
00:51:39,236 --> 00:51:43,106
for this ColorSpace
variable is CGColorSpace.


1044
00:51:44,016 --> 00:51:46,406
Note the lack of a ref
at the end of this.


1045
00:51:46,986 --> 00:51:49,006
This isn't some opaque pointer.


1046
00:51:49,686 --> 00:51:54,386
This is the CGColorSpace
class that we've created.


1047
00:51:55,866 --> 00:51:57,676
What's the nice thing
about being a class?


1048
00:51:57,996 --> 00:52:00,226
Well, that means we're in
the ARC model and we're going


1049
00:52:00,226 --> 00:52:02,606
to automatically manage
the memory for you.


1050
00:52:04,516 --> 00:52:09,946
[ Applause ]


1051
00:52:10,446 --> 00:52:13,166
Let's go a little
further and create


1052
00:52:13,166 --> 00:52:14,446
that Gradient we talked about.


1053
00:52:15,896 --> 00:52:18,936
So here, remember, we need to
pass a couple of arrays through.


1054
00:52:19,816 --> 00:52:23,426
We can use this nice
Swift array literal syntax


1055
00:52:23,906 --> 00:52:26,456
to form an array containing
startColor and Color.


1056
00:52:27,296 --> 00:52:30,166
We're doing all of the bridging
automatically here for you.


1057
00:52:30,426 --> 00:52:32,186
So we've created
the NSArray we need.


1058
00:52:32,516 --> 00:52:36,386
We've toll-free bridged it to
the CFArray behind the scenes


1059
00:52:36,536 --> 00:52:38,616
so you don't have to deal
with the fact that there are


1060
00:52:38,616 --> 00:52:40,106
so many array types
running around.


1061
00:52:40,606 --> 00:52:44,606
Did the exact same
thing for the C parts.


1062
00:52:45,226 --> 00:52:48,936
So here we just have an array
of floating point values.


1063
00:52:49,366 --> 00:52:52,756
So it's treated as a native
Swift array of CGFloats


1064
00:52:53,866 --> 00:52:57,516
that we bridged seamlessly
to the underlying C array


1065
00:52:57,776 --> 00:52:59,436
that this C function expects.


1066
00:52:59,926 --> 00:53:03,136
Let's keep going with
our example here.


1067
00:53:04,976 --> 00:53:08,716
CGPoint. You can use
CGPointMake if you want.


1068
00:53:09,086 --> 00:53:10,106
It's perfectly fine.


1069
00:53:10,106 --> 00:53:13,126
It works exactly the same way
as it does in Objective-C.


1070
00:53:14,256 --> 00:53:16,556
However, whenever
we import a struct,


1071
00:53:16,726 --> 00:53:20,346
like CGPoint is a struct, we
provide it with initializers


1072
00:53:21,126 --> 00:53:22,626
that have labeled arguments.


1073
00:53:23,056 --> 00:53:26,256
And so a better way to
build CGPoints in Swift is


1074
00:53:26,496 --> 00:53:29,706
to just construct a
CGPoint value using


1075
00:53:29,706 --> 00:53:32,046
that same construction
syntax we've been talking


1076
00:53:32,046 --> 00:53:33,266
about throughout this talk.


1077
00:53:34,726 --> 00:53:37,506
And then use the
argument labels x and y


1078
00:53:37,806 --> 00:53:39,926
to make it absolutely
clear what you're doing.


1079
00:53:39,926 --> 00:53:42,996
And this brings a
little bit of a flavor


1080
00:53:43,146 --> 00:53:46,646
of that nice Cocoa readability
using argument labels


1081
00:53:47,036 --> 00:53:48,646
into the underlying CF APIs.


1082
00:53:48,646 --> 00:53:52,366
And that's it for
our example in Swift.


1083
00:53:52,846 --> 00:53:53,626
It's smaller.


1084
00:53:53,626 --> 00:53:54,416
It's easier.


1085
00:53:54,416 --> 00:53:56,746
There's far fewer concepts
that you have to deal


1086
00:53:56,746 --> 00:53:58,976
with because we've automatically
taken over the management.


1087
00:53:59,516 --> 00:54:06,356
[ Applause ]


1088
00:54:06,856 --> 00:54:09,086
Now you may have some of
your own APIs that we refer


1089
00:54:09,086 --> 00:54:11,066
to as explicitly bridged.


1090
00:54:11,726 --> 00:54:14,046
So these are CF-like APIs


1091
00:54:14,526 --> 00:54:17,136
where we're not quite sure
whether you're following all the


1092
00:54:17,136 --> 00:54:22,066
CF memory conventions because,
unlike the world of Cocoa


1093
00:54:22,066 --> 00:54:25,126
which is fairly tame, and we've
been following conventions


1094
00:54:25,126 --> 00:54:28,016
fairly well for many years,
we haven't been following them


1095
00:54:28,016 --> 00:54:30,056
so well in C as a community.


1096
00:54:30,746 --> 00:54:34,356
And so we may have this
function GetRandomColor,


1097
00:54:34,696 --> 00:54:35,886
produces some random color.


1098
00:54:36,976 --> 00:54:40,836
When we pull this in, the Swift
compiler doesn't know whether we


1099
00:54:40,836 --> 00:54:43,886
can really trust that this
returns plus zero or not.


1100
00:54:43,956 --> 00:54:46,186
It has get in the name
but we're not sure.


1101
00:54:46,686 --> 00:54:49,126
And so we do the safe
thing and we import it


1102
00:54:49,126 --> 00:54:51,356
as an Unmanaged<CGColor>


1103
00:54:52,546 --> 00:54:55,326
which means we can't directly
manage the memory here


1104
00:54:55,326 --> 00:54:57,076
because we don't know
what the conventions are.


1105
00:54:58,656 --> 00:55:00,536
So what is this Unmanaged thing?


1106
00:55:00,966 --> 00:55:03,886
So Unmanaged is actually
a generic struct


1107
00:55:04,856 --> 00:55:05,916
over an arbitrary T.


1108
00:55:06,836 --> 00:55:09,316
Now the details of generic
structs we don't need


1109
00:55:09,316 --> 00:55:10,216
to go into now.


1110
00:55:10,326 --> 00:55:12,916
They're covered in the Advanced
talk which I highly recommend.


1111
00:55:13,536 --> 00:55:15,926
What we want to look at right
now is just the simple API


1112
00:55:16,526 --> 00:55:17,626
of this Unmanaged type.


1113
00:55:18,156 --> 00:55:21,706
We have two core operations
- takeUnretainedValue,


1114
00:55:21,876 --> 00:55:25,226
which you use for +0
returns, and takeRetainedValue


1115
00:55:25,226 --> 00:55:27,216
which you use for +1 returns.


1116
00:55:27,746 --> 00:55:32,116
Now, when we call our
CGColorGetRandomColor,


1117
00:55:32,766 --> 00:55:35,396
we want to immediately use
one of these two functions.


1118
00:55:35,536 --> 00:55:39,166
So we know that GetRandomColor
returns a plus zero,


1119
00:55:39,456 --> 00:55:41,306
so we're going to do a
takeUnretainedValue of it.


1120
00:55:42,126 --> 00:55:43,706
Now the reason to
do this immediately


1121
00:55:43,706 --> 00:55:47,286
after the call is
this gets us a CGColor


1122
00:55:47,486 --> 00:55:48,486
which takes us right back


1123
00:55:48,606 --> 00:55:51,186
into automatically
managing memory for you.


1124
00:55:52,286 --> 00:55:54,756
So the window in which
you have to do something


1125
00:55:54,926 --> 00:55:57,476
with manual memory
management is tiny.


1126
00:55:57,476 --> 00:55:59,256
It's just this one
little line of code


1127
00:55:59,556 --> 00:56:01,306
where you establish
what the convention is


1128
00:56:01,596 --> 00:56:03,776
for CGColorGetRandomColor.


1129
00:56:04,366 --> 00:56:12,706
Now, if you own
CGColorGetRandomColor,


1130
00:56:13,526 --> 00:56:17,036
you can audit your APIs to
make sure they follow the Core


1131
00:56:17,036 --> 00:56:20,046
Foundation naming conventions
for memory management.


1132
00:56:21,276 --> 00:56:24,226
And when they do, you can
use these annotations here


1133
00:56:24,226 --> 00:56:25,106
in core foundation -


1134
00:56:25,266 --> 00:56:27,586
CF-IMPLICIT-BRIDGING-ENABLED
and DISABLED.


1135
00:56:28,066 --> 00:56:31,616
Put this over a whole header
once you've audited all the


1136
00:56:31,616 --> 00:56:32,596
methods in that header.


1137
00:56:33,626 --> 00:56:38,046
And when you do that, well,
now your function when you use


1138
00:56:38,046 --> 00:56:42,056
from Swift, gets you right back
into the managed world directly.


1139
00:56:43,176 --> 00:56:46,016
So you have the great
automatic memory management


1140
00:56:46,386 --> 00:56:48,426
that Swift can provide for CF.


1141
00:56:49,816 --> 00:56:50,836
So let's wrap up here.


1142
00:56:50,836 --> 00:56:53,346
We've talked about a
lot of different topics.


1143
00:56:54,516 --> 00:56:55,896
We've talked about
interoperability


1144
00:56:55,896 --> 00:56:57,256
between Swift and Objective-C.


1145
00:56:57,616 --> 00:57:00,166
We've talked about a whole lot
of rules about how that works.


1146
00:57:00,476 --> 00:57:02,746
But let the tools and
documentation help you.


1147
00:57:03,046 --> 00:57:05,896
They can show you Swift and
Objective-C side-by-side


1148
00:57:05,986 --> 00:57:09,576
so you can get a feel for how
your Objective-C APIs work


1149
00:57:09,576 --> 00:57:10,086
in Swift.


1150
00:57:11,126 --> 00:57:12,626
We've talked about
some of the details


1151
00:57:12,626 --> 00:57:14,846
of bridging Core
Cocoa data types


1152
00:57:14,916 --> 00:57:17,226
and using Swift's native types.


1153
00:57:18,326 --> 00:57:22,166
And we talked about automated
CF memory management available


1154
00:57:23,136 --> 00:57:24,046
in Swift.


1155
00:57:24,206 --> 00:57:26,376
For more information,
check out the


1156
00:57:26,376 --> 00:57:30,086
"Swift Programming Language
Book," and also the "Using Swift


1157
00:57:30,086 --> 00:57:32,126
with Cocoa and Objective-C"
guide that goes


1158
00:57:32,126 --> 00:57:34,286
into more details
on the interplay


1159
00:57:34,286 --> 00:57:38,716
between these two
programming languages.


1160
00:57:39,136 --> 00:57:39,906
Thank you.


1161
00:57:40,516 --> 00:57:55,880
[ Applause ]

