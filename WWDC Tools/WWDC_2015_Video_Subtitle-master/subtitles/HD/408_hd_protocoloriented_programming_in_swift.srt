1
00:00:07,516 --> 00:00:15,516
[Music]


2
00:00:16,015 --> 00:00:26,000
[Silence]


3
00:00:26,516 --> 00:00:33,636
[Applause]


4
00:00:34,136 --> 00:00:34,746
>> Dave Abrahams: Hi, everybody.


5
00:00:35,346 --> 00:00:39,466
My name is Dave Abrahams,
and I'm the technical lead


6
00:00:39,526 --> 00:00:42,516
for the Swift standard library,
and it is truly my privilege


7
00:00:42,516 --> 00:00:44,036
to be with you here today.


8
00:00:44,036 --> 00:00:47,026
It is great to see all
of you in this room.


9
00:00:47,546 --> 00:00:52,076
The next 40 minutes are about
putting aside your usual way


10
00:00:52,076 --> 00:00:53,336
of thinking about programming.


11
00:00:54,466 --> 00:00:58,656
What we're going to do together
here won't necessarily be easy,


12
00:00:58,656 --> 00:01:00,336
but I promise you if
you stick with me,


13
00:01:00,956 --> 00:01:02,096
that it'll be worth your time.


14
00:01:02,096 --> 00:01:07,686
I'm here to talk to you
about themes at the heart


15
00:01:07,686 --> 00:01:11,716
of Swift's design, and introduce
you to a way of programming


16
00:01:11,916 --> 00:01:13,596
that has the potential
to change everything.


17
00:01:15,076 --> 00:01:17,856
But first, let me introduce
you to a friend of mine.


18
00:01:20,586 --> 00:01:21,636
This is Crusty.


19
00:01:23,396 --> 00:01:26,276
Now you've probably all worked
with some version of this guy.


20
00:01:26,456 --> 00:01:29,266
Crusty is that old-school
programmer


21
00:01:29,626 --> 00:01:35,036
who doesn't trust
debuggers, doesn't use IDEs.


22
00:01:35,036 --> 00:01:37,606
No, he favors an 80
x 24 terminal window


23
00:01:37,606 --> 00:01:39,356
and plain text, thank
you very much.


24
00:01:42,636 --> 00:01:45,506
And he takes a dim view of
the latest programming fads.


25
00:01:46,156 --> 00:01:49,286
Now I've learned
to expect Crusty


26
00:01:49,286 --> 00:01:51,986
to be a little bit
cynical and grumpy,


27
00:01:52,436 --> 00:01:55,266
but even so it sometimes
takes me by surprise.


28
00:01:55,886 --> 00:01:59,236
Like last month we were
talking about app development,


29
00:01:59,666 --> 00:02:02,916
and said flat out, 'I
don't do object-oriented.'


30
00:02:03,946 --> 00:02:06,406
I could hardly believe my ears.


31
00:02:07,056 --> 00:02:09,826
I mean, object-oriented
programming has been


32
00:02:09,826 --> 00:02:14,426
around since the 1970s, so it's
not exactly some new-fangled


33
00:02:14,426 --> 00:02:15,256
programming fad.


34
00:02:15,756 --> 00:02:19,566
And, furthermore, lots
of the amazing things


35
00:02:19,566 --> 00:02:23,686
that we've all built together,
you and I and the engineers


36
00:02:23,686 --> 00:02:26,936
on whose shoulders we stand,
were built with objects.


37
00:02:28,196 --> 00:02:30,406
'Come on,' I said
to him as I walked


38
00:02:30,406 --> 00:02:31,956
over to his old-school
chalkboard.


39
00:02:32,276 --> 00:02:33,176
'OOP is awesome.


40
00:02:33,176 --> 00:02:35,326
Look what you can
do with classes.'


41
00:02:36,516 --> 00:02:41,666
[Silence]


42
00:02:42,166 --> 00:02:47,236
Yes. So first you can group
related data and operations.


43
00:02:48,206 --> 00:02:52,206
And then we can build walls to
separate the inside of our code


44
00:02:52,296 --> 00:02:54,896
from the outside, and
that's what lets us


45
00:02:54,896 --> 00:02:56,076
maintain invariants.


46
00:02:58,516 --> 00:03:03,266
Then we use classes to represent
relatable ideas, like window


47
00:03:03,476 --> 00:03:05,116
or communication channel.


48
00:03:05,696 --> 00:03:11,176
They give us a namespace,
which helps prevent collisions


49
00:03:11,176 --> 00:03:12,986
as our software grows.


50
00:03:15,096 --> 00:03:18,026
They have amazing
expressive syntax.


51
00:03:18,316 --> 00:03:21,626
So we can write method
calls and properties


52
00:03:21,626 --> 00:03:22,766
and chain them together.


53
00:03:23,016 --> 00:03:24,316
We can make subscripts.


54
00:03:25,326 --> 00:03:27,726
We can even make properties
that do computation.


55
00:03:28,976 --> 00:03:32,936
Last, classes are open
for extensibility.


56
00:03:33,286 --> 00:03:36,606
So if a class author leaves
something out that I need, well,


57
00:03:36,606 --> 00:03:37,896
I can come along
and add it later.


58
00:03:39,026 --> 00:03:41,396
And, furthermore,
together, these things,


59
00:03:42,976 --> 00:03:44,636
these things let us
manage complexity


60
00:03:45,396 --> 00:03:47,576
and that's really the main
challenge in programming.


61
00:03:48,146 --> 00:03:52,746
These properties, they directly
address the problems we're


62
00:03:52,746 --> 00:03:54,316
trying to solve in
software development.


63
00:03:55,716 --> 00:03:57,826
At that point, I had gotten
myself pretty inspired,


64
00:03:58,176 --> 00:04:04,196
but Crusty just snorted
and [sighed].


65
00:04:05,806 --> 00:04:07,206
[hiss sound] He let all
the air out of my balloon.


66
00:04:09,506 --> 00:04:10,706
And if that wasn't bad enough,


67
00:04:10,826 --> 00:04:12,636
a moment later he
finished the sentence.


68
00:04:13,191 --> 00:04:15,191
[Laughter]


69
00:04:15,366 --> 00:04:17,596
Because it's true, in Swift,


70
00:04:17,896 --> 00:04:22,005
any type you can name is a first
class citizen and it's able


71
00:04:22,005 --> 00:04:24,896
to take advantage of
all these capabilities.


72
00:04:25,506 --> 00:04:29,846
So I took a step back
and tried to figure


73
00:04:29,846 --> 00:04:33,526
out what core capability enables
everything we've accomplished


74
00:04:33,526 --> 00:04:34,866
with object-oriented
programming.


75
00:04:36,786 --> 00:04:41,606
Obviously, it has to come from
something that you can only do


76
00:04:41,606 --> 00:04:44,076
with classes, like inheritance.


77
00:04:45,416 --> 00:04:48,006
And this got me thinking
specifically


78
00:04:48,006 --> 00:04:51,486
about how these structures
enable both code sharing


79
00:04:51,836 --> 00:04:53,396
and fine-grained customization.


80
00:04:54,746 --> 00:04:58,666
So, for example, a superclass
can define a substantial method


81
00:04:58,666 --> 00:05:01,576
with complex logic,
and subclasses get all


82
00:05:01,576 --> 00:05:03,476
of the work done by the
superclass for free.


83
00:05:04,776 --> 00:05:05,716
They just inherit it.


84
00:05:07,156 --> 00:05:11,036
But the real magic happens when
the superclass author breaks


85
00:05:11,036 --> 00:05:12,966
out a tiny part of
that operation


86
00:05:13,406 --> 00:05:15,276
into a separate customization
point


87
00:05:15,786 --> 00:05:18,966
that the subclass can override,


88
00:05:20,086 --> 00:05:22,176
and this customization
is overlaid


89
00:05:22,176 --> 00:05:23,696
on the inherited implementation.


90
00:05:24,256 --> 00:05:27,086
That allows the difficult logic


91
00:05:27,086 --> 00:05:30,386
to be reused while enabling
open-ended flexibility


92
00:05:30,386 --> 00:05:31,806
and specific variations.


93
00:05:32,086 --> 00:05:33,806
And now, I was sure, I had him.


94
00:05:34,406 --> 00:05:35,946
'Ha,' I said to Crusty.


95
00:05:36,156 --> 00:05:37,866
'Obviously, now you have to bow


96
00:05:37,866 --> 00:05:42,716
down before the power
of the class.'


97
00:05:42,856 --> 00:05:45,246
'Hold on just a darn
tootin' minute,' he replied.


98
00:05:46,196 --> 00:05:46,796
'First of all,


99
00:05:46,796 --> 00:05:49,596
I do customization
whatchamacallit all the time


100
00:05:49,596 --> 00:05:53,876
with structs, and second,
yes, classes are powerful


101
00:05:53,966 --> 00:05:57,596
but let's talk about the costs.


102
00:05:58,476 --> 00:06:04,566
I have got three major beefs
with classes,' said Crusty.


103
00:06:05,156 --> 00:06:07,376
And he started in on
his list of complaints.


104
00:06:08,766 --> 00:06:10,386
'First, you got your
automatic sharing.'


105
00:06:11,636 --> 00:06:13,116
Now you all know
what this looks like.


106
00:06:14,186 --> 00:06:18,176
A hands B some piece of
perfectly sober looking data,


107
00:06:18,706 --> 00:06:21,886
and B thinks, 'Great,
conversation over.'


108
00:06:22,986 --> 00:06:25,886
But now we've got
a situation where A


109
00:06:26,216 --> 00:06:31,026
and B each have their own very
reasonable view of the world


110
00:06:31,026 --> 00:06:32,346
that just happens to be wrong.


111
00:06:33,976 --> 00:06:39,566
Because this is the reality:
eventually A gets tired


112
00:06:39,566 --> 00:06:42,056
of serious data and decides
he likes ponies instead,


113
00:06:42,936 --> 00:06:44,066
and who doesn't love
a good pony?


114
00:06:44,626 --> 00:06:50,906
This is totally fine until
B digs up this data later,


115
00:06:51,046 --> 00:06:52,796
much later, that she got from A


116
00:06:52,796 --> 00:06:55,426
and there's been a
surprise mutation.


117
00:06:57,256 --> 00:06:59,206
B wants her data,
not A's ponies.


118
00:07:00,526 --> 00:07:03,816
Well, Crusty has a whole rant
about how this plays out.


119
00:07:06,386 --> 00:07:09,426
'First,' he says, 'you start
copying everything like crazy


120
00:07:09,426 --> 00:07:10,876
to squash the bugs in your code.


121
00:07:11,136 --> 00:07:12,836
But now you're making
too many copies,


122
00:07:13,256 --> 00:07:14,696
which slows the code down.


123
00:07:15,056 --> 00:07:17,576
And then one day you handle
something on a dispatch queue


124
00:07:17,846 --> 00:07:19,876
and suddenly you've
got a race condition


125
00:07:20,096 --> 00:07:22,026
because threads are
sharing a mutable state,


126
00:07:22,416 --> 00:07:25,296
so you start adding locks
to protect your invariants.


127
00:07:26,186 --> 00:07:28,366
But the locks slow the
code down some more


128
00:07:28,696 --> 00:07:30,076
and might even lead to deadlock.


129
00:07:30,356 --> 00:07:32,296
And all of this is
added complexity,


130
00:07:32,596 --> 00:07:36,296
whose effects can be summed
up in one word, bugs.'


131
00:07:36,866 --> 00:07:41,596
But none of this is news
to Cocoa programmers.


132
00:07:42,516 --> 00:07:44,516
[Laughter]


133
00:07:45,016 --> 00:07:50,000
[Applause]


134
00:07:50,316 --> 00:07:50,936
It's not news.


135
00:07:50,996 --> 00:07:54,156
We've been applying a
combination of language features


136
00:07:54,156 --> 00:07:57,006
like @property(copy)
and coding conventions


137
00:07:57,006 --> 00:07:58,886
over the years to handle this.


138
00:07:59,416 --> 00:08:02,136
And we still get bitten.


139
00:08:03,176 --> 00:08:05,586
For example, there's
this warning


140
00:08:05,586 --> 00:08:07,306
in the Cocoa documentation


141
00:08:07,526 --> 00:08:10,006
about modifying a mutable
collection while you're


142
00:08:10,006 --> 00:08:10,776
iterating through it.


143
00:08:12,086 --> 00:08:16,346
Right? And this is all
due to implicit sharing


144
00:08:16,416 --> 00:08:19,606
of mutable state, which
is inherent to classes.


145
00:08:20,106 --> 00:08:25,126
But this doesn't apply to Swift.


146
00:08:25,286 --> 00:08:30,776
Why not? It's because Swift
collections are all value types,


147
00:08:31,526 --> 00:08:32,666
so the one you're iterating


148
00:08:32,666 --> 00:08:34,476
and the one you're
modifying are distinct.


149
00:08:36,606 --> 00:08:39,395
Okay, number two
on Crusty's list,


150
00:08:40,466 --> 00:08:42,206
class inheritance
is too intrusive.


151
00:08:43,155 --> 00:08:46,096
First of all, it's monolithic.


152
00:08:46,636 --> 00:08:48,806
You get one and only
one superclass.


153
00:08:49,846 --> 00:08:52,216
So what if you need to
model multiple abstractions?


154
00:08:52,576 --> 00:08:56,096
Can you be a collection
and be serialized?


155
00:08:57,146 --> 00:08:59,986
Well, not if collection
and serialized are classes.


156
00:09:01,436 --> 00:09:04,196
And because class inheritance
is single inheritance,


157
00:09:04,656 --> 00:09:06,336
classes get bloated
as everything


158
00:09:06,336 --> 00:09:08,716
that might be related
gets thrown together.


159
00:09:09,356 --> 00:09:11,636
You also have to
choose your superclass


160
00:09:11,636 --> 00:09:13,136
at the moment you
define your class,


161
00:09:13,136 --> 00:09:14,936
not later in some extension.


162
00:09:15,466 --> 00:09:21,936
Next, if your superclass
had stored properties, well,


163
00:09:22,606 --> 00:09:23,456
you have to accept them.


164
00:09:24,536 --> 00:09:25,396
You don't get a choice.


165
00:09:26,726 --> 00:09:29,736
And then because it
has stored properties,


166
00:09:30,326 --> 00:09:31,306
you have to initialize it.


167
00:09:31,306 --> 00:09:35,996
And as Crusty says, 'designated
convenience required, oh, my.'


168
00:09:37,476 --> 00:09:39,706
So you also have to make
sure that you understand how


169
00:09:39,706 --> 00:09:43,386
to interact with your superclass
without breaking its invariants.


170
00:09:44,216 --> 00:09:48,866
Right? And, finally, it's
natural for class authors


171
00:09:49,436 --> 00:09:53,106
to write their code as though
they know what their methods are


172
00:09:53,106 --> 00:09:57,826
going to do, without using
final and without accounting


173
00:09:57,916 --> 00:10:00,516
for the chance that the
methods might get overridden.


174
00:10:01,646 --> 00:10:06,646
So, there's often a crucial
but unwritten contract


175
00:10:06,866 --> 00:10:08,746
about which things
you're allowed


176
00:10:08,746 --> 00:10:12,376
to actually override and,
like, do you have to chain


177
00:10:12,376 --> 00:10:13,486
to the superclass method?


178
00:10:13,746 --> 00:10:15,576
And if you're going to chain
to the superclass method,


179
00:10:15,576 --> 00:10:18,266
is it at the beginning of
your method, or at the end,


180
00:10:18,266 --> 00:10:22,626
or in the middle somewhere?


181
00:10:23,536 --> 00:10:26,626
So, again, not news to
Cocoa programmers, right?


182
00:10:26,986 --> 00:10:29,486
This is exactly why we use
the delegate pattern all


183
00:10:29,486 --> 00:10:30,476
over the place in Cocoa.


184
00:10:31,016 --> 00:10:37,596
Okay, last on Crusty's
list, classes just turn


185
00:10:37,596 --> 00:10:41,236
out to be a really
bad fit for problems


186
00:10:41,326 --> 00:10:42,766
where type relationships matter.


187
00:10:44,476 --> 00:10:46,826
So if you've ever
tried to use classes


188
00:10:47,206 --> 00:10:49,416
to represent a symmetric
operation,


189
00:10:49,416 --> 00:10:51,736
like Comparison, you
know what I mean.


190
00:10:53,006 --> 00:10:56,846
For example, if you want
to write a generalized sort


191
00:10:56,846 --> 00:10:59,116
or binary search like
this, you need a way


192
00:10:59,116 --> 00:11:00,326
to compare two elements.


193
00:11:00,916 --> 00:11:03,406
And with classes, you end
up with something like this.


194
00:11:04,236 --> 00:11:08,606
Of course, you can't just
write Ordered this way,


195
00:11:08,956 --> 00:11:11,366
because Swift demands a
method body for precedes.


196
00:11:11,366 --> 00:11:14,526
So, what can we put there?


197
00:11:16,156 --> 00:11:18,216
Remember, we don't know anything


198
00:11:18,216 --> 00:11:20,346
about an arbitrary
instance of Ordered yet.


199
00:11:21,656 --> 00:11:25,616
So if the method isn't
implemented by a subclass, well,


200
00:11:25,616 --> 00:11:27,536
there's really nothing we
can do other than trap.


201
00:11:29,756 --> 00:11:33,496
Now, this is the first sign that
we're fighting the type system.


202
00:11:34,026 --> 00:11:36,476
And if we fail to
recognize that,


203
00:11:36,876 --> 00:11:38,946
it's also where we start
lying to ourselves,


204
00:11:39,426 --> 00:11:43,226
because we brush the issue
aside, telling ourselves


205
00:11:43,226 --> 00:11:45,076
that as long as each subclass


206
00:11:45,076 --> 00:11:47,316
of Ordered implements
precedes, we'll be okay.


207
00:11:48,806 --> 00:11:51,456
Right? Make it the
subclasser's problem.


208
00:11:52,766 --> 00:11:55,866
So we press ahead and
implement an example of Ordered.


209
00:11:57,346 --> 00:11:58,816
So, here's a subclass.


210
00:11:59,376 --> 00:12:01,116
It's got a double value


211
00:12:01,466 --> 00:12:04,926
and we override precedes
to do the comparison.


212
00:12:05,446 --> 00:12:09,746
Right? Except, of
course, it doesn't work.


213
00:12:11,096 --> 00:12:14,056
See, "other" is just
some arbitrary Ordered


214
00:12:14,206 --> 00:12:17,006
and not a number, so
we don't know that


215
00:12:17,006 --> 00:12:19,726
"other" has a value property.


216
00:12:20,276 --> 00:12:22,556
In fact, it might turn
out to be a label,


217
00:12:23,156 --> 00:12:24,326
which has a text property.


218
00:12:25,916 --> 00:12:28,136
So, now we need to down-cast
just to get to the right type.


219
00:12:28,136 --> 00:12:34,126
But, wait a sec, suppose that
"other" turns out to be a label?


220
00:12:34,746 --> 00:12:38,866
Now, we're going to trap.


221
00:12:39,056 --> 00:12:42,936
Right? So, this is
starting to smell a lot


222
00:12:43,016 --> 00:12:46,336
like the problem we had when
writing the body for precedes


223
00:12:46,336 --> 00:12:51,406
in the superclass, and we
don't have a better answer now


224
00:12:51,406 --> 00:12:52,256
than we did before.


225
00:12:53,656 --> 00:12:55,226
This is a static
type safety hole.


226
00:12:56,656 --> 00:12:57,786
Why did it happen?


227
00:12:58,656 --> 00:13:02,296
Well, it's because classes don't
let us express this crucial type


228
00:13:02,296 --> 00:13:05,846
relationship between the type
of self and the type of other.


229
00:13:06,416 --> 00:13:09,606
In fact, you can use
this as a "code smell."


230
00:13:10,466 --> 00:13:13,786
So, any time you see a forced
down-cast in your code,


231
00:13:14,566 --> 00:13:17,366
it's a good sign that some
important type relationship has


232
00:13:17,366 --> 00:13:19,946
been lost, and often that's due


233
00:13:19,946 --> 00:13:21,546
to using classes
for abstraction.


234
00:13:23,896 --> 00:13:28,686
Okay, clearly what we need is
a better abstraction mechanism,


235
00:13:29,836 --> 00:13:33,616
one that doesn't force us
to accept implicit sharing,


236
00:13:34,156 --> 00:13:35,996
or lost type relationships,


237
00:13:36,766 --> 00:13:39,676
or force us to choose just
one abstraction and do it


238
00:13:39,676 --> 00:13:43,416
at the time we define our
types; one that doesn't force us


239
00:13:43,416 --> 00:13:45,636
to accept unwanted instance data


240
00:13:46,186 --> 00:13:48,856
or the associated
initialization complexity.


241
00:13:49,386 --> 00:13:54,016
And, finally, one that
doesn't leave ambiguity


242
00:13:54,016 --> 00:13:55,336
about what I need to override.


243
00:13:55,896 --> 00:13:58,696
Of course, I'm talking
about protocols.


244
00:13:59,886 --> 00:14:03,446
Protocols have all these
advantages, and that's why,


245
00:14:03,766 --> 00:14:07,086
when we made Swift, we made
the first protocol-oriented


246
00:14:07,086 --> 00:14:07,966
programming language.


247
00:14:08,516 --> 00:14:17,176
[Applause]


248
00:14:17,676 --> 00:14:21,206
So, yes, Swift is great for
object-oriented programming,


249
00:14:21,746 --> 00:14:25,386
but from the way for loops
and string literals work


250
00:14:25,786 --> 00:14:28,496
to the emphasis in the
standard library on generics,


251
00:14:28,946 --> 00:14:31,226
at its heart, Swift
is protocol-oriented.


252
00:14:32,586 --> 00:14:34,616
And, hopefully, by the
time you leave here,


253
00:14:35,046 --> 00:14:36,976
you'll be a little more
protocol-oriented yourself.


254
00:14:37,526 --> 00:14:42,176
So, to get you started
off on the right foot,


255
00:14:42,616 --> 00:14:43,756
we have a saying in Swift.


256
00:14:44,446 --> 00:14:45,536
Don't start with a class.


257
00:14:46,086 --> 00:14:47,256
Start with a protocol.


258
00:14:48,456 --> 00:14:51,636
So let's do that with
our last example.


259
00:14:53,396 --> 00:14:58,166
Okay, first, we need a protocol,
and right away Swift complains


260
00:14:58,316 --> 00:15:00,056
that we can't put
a method body here,


261
00:15:01,466 --> 00:15:03,476
which is actually pretty
good because it means


262
00:15:03,476 --> 00:15:07,526
that we're going to trade
that dynamic runtime check


263
00:15:08,026 --> 00:15:15,546
for a static check, right,
that precedes as implemented.


264
00:15:16,136 --> 00:15:20,496
Okay, next, it complains that
we're not overriding anything.


265
00:15:20,746 --> 00:15:22,156
Well, of course we're not.


266
00:15:22,706 --> 00:15:24,556
We don't have a baseclass
anymore, right?


267
00:15:24,646 --> 00:15:26,066
No superclass, no override.


268
00:15:26,066 --> 00:15:29,736
And we probably didn't even
want number to be a class


269
00:15:29,736 --> 00:15:31,826
in the first place, because we
want it to act like a number.


270
00:15:32,686 --> 00:15:36,586
Right? So, let's just
do two thing at once


271
00:15:36,586 --> 00:15:39,816
and make that a struct.


272
00:15:39,956 --> 00:15:43,056
Okay, I want to stop for a
moment here and appreciate


273
00:15:43,056 --> 00:15:46,036
where we are, because this
is all valid code again.


274
00:15:47,106 --> 00:15:51,036
Okay, the protocol is
playing exactly the same role


275
00:15:51,496 --> 00:15:55,546
that the class did in our
first version of this example.


276
00:15:56,236 --> 00:15:57,496
It's definitely a bit better.


277
00:15:57,646 --> 00:16:00,176
I mean, we don't have
that fatal error anymore,


278
00:16:00,786 --> 00:16:03,846
but we're not addressing the
underlying static type safety


279
00:16:03,846 --> 00:16:07,926
hole, because we still need
that forced down-cast because


280
00:16:08,286 --> 00:16:11,546
"other" is still some
arbitrary Ordered.


281
00:16:12,606 --> 00:16:16,656
Okay. So, let's make it a number
instead, and drop the type cast.


282
00:16:19,346 --> 00:16:20,896
Well, now Swift is
going to complain


283
00:16:20,896 --> 00:16:24,106
that the signatures
don't match up.


284
00:16:25,446 --> 00:16:28,096
To fix this, we need
to replace Ordered


285
00:16:28,096 --> 00:16:30,096
in the protocol signature
with Self.


286
00:16:32,776 --> 00:16:34,646
This is called a
Self-requirement.


287
00:16:35,676 --> 00:16:39,116
So when you see Self in a
protocol, it's a placeholder


288
00:16:39,446 --> 00:16:40,886
for the type that's
going to conform


289
00:16:40,886 --> 00:16:44,076
to that protocol,
the model type.


290
00:16:45,016 --> 00:16:46,586
So, now we have valid
code again.


291
00:16:47,626 --> 00:16:49,836
Now, let's take a look at
how you use this protocol.


292
00:16:50,406 --> 00:16:55,896
So, this is the binary
search that worked


293
00:16:55,896 --> 00:16:57,596
when Ordered was a class.


294
00:16:58,916 --> 00:17:01,866
And it also worked
perfectly before we added


295
00:17:01,866 --> 00:17:03,226
that Self-requirement
to Ordered.


296
00:17:04,736 --> 00:17:08,806
And this array of
ordered here is a claim.


297
00:17:09,796 --> 00:17:11,396
It's a claim that we're going


298
00:17:11,396 --> 00:17:14,256
to handle a heterogeneous
array of Ordered.


299
00:17:14,726 --> 00:17:18,056
So, this array could
contain numbers


300
00:17:18,056 --> 00:17:21,056
and labels mixed
together, right?


301
00:17:22,226 --> 00:17:26,175
Now that we've made
this change to Ordered


302
00:17:26,175 --> 00:17:28,536
and added the Self-requirement,
the compiler is going


303
00:17:28,536 --> 00:17:34,396
to force us to make this
homogeneous, like this.


304
00:17:35,936 --> 00:17:39,406
This one says, 'I work
on a homogeneous array


305
00:17:39,406 --> 00:17:41,676
of any single Ordered type T.'


306
00:17:43,866 --> 00:17:45,666
Now, you might think
that forcing the array


307
00:17:45,666 --> 00:17:49,056
to be homogeneous is too
restrictive or, like,


308
00:17:49,176 --> 00:17:51,926
a loss of functionality or
flexibility or something.


309
00:17:52,346 --> 00:17:53,396
But if you think about it,


310
00:17:54,046 --> 00:17:56,326
the original signature
was really a lie.


311
00:17:56,396 --> 00:17:59,906
I mean, we never really handled
the heterogeneous case other


312
00:17:59,906 --> 00:18:00,976
than by trapping.


313
00:18:01,516 --> 00:18:07,326
Right? A homogeneous
array is what we want.


314
00:18:08,586 --> 00:18:11,726
So, once you add a
Self-requirement to a protocol,


315
00:18:12,176 --> 00:18:15,476
it moves the protocol into
a very different world,


316
00:18:16,246 --> 00:18:21,126
where the capabilities have a
lot less overlap with classes.


317
00:18:21,656 --> 00:18:24,646
It stops being usable as a type.


318
00:18:26,076 --> 00:18:30,456
Collections become homogeneous
instead of heterogeneous.


319
00:18:30,936 --> 00:18:36,576
An interaction between instances
no longer implies an interaction


320
00:18:36,576 --> 00:18:37,866
between all model types.


321
00:18:40,026 --> 00:18:44,526
We trade dynamic polymorphism
for static polymorphism, but,


322
00:18:44,526 --> 00:18:47,046
in return for that extra type
information we're giving the


323
00:18:47,046 --> 00:18:48,876
compiler, it's more optimizable.


324
00:18:49,446 --> 00:18:52,076
So, two worlds.


325
00:18:54,086 --> 00:18:56,236
Later in the talk, I'll show
you how to build a bridge


326
00:18:56,236 --> 00:18:58,156
between them, at least one way.


327
00:18:59,596 --> 00:19:07,296
Okay. So, I understood
how the static aspect


328
00:19:07,296 --> 00:19:10,716
of protocols worked, but
I wasn't sure whether


329
00:19:10,716 --> 00:19:14,406
to believe Crusty that protocols
could really replace classes


330
00:19:14,866 --> 00:19:18,496
and so I set him a
challenge, to build something


331
00:19:19,236 --> 00:19:22,506
for which we'd normally use
OOP, but using protocols.


332
00:19:24,786 --> 00:19:26,556
I had in mind a little
diagramming app


333
00:19:26,836 --> 00:19:30,836
where you could drag and drop
shapes on a drawing surface


334
00:19:30,836 --> 00:19:31,786
and then interact with them.


335
00:19:32,796 --> 00:19:36,316
And so I asked Crusty to build
the document and display model.


336
00:19:37,336 --> 00:19:38,336
And here's what he came up with.


337
00:19:41,166 --> 00:19:43,006
First, he built some
drawing primitives.


338
00:19:43,656 --> 00:19:44,856
Now, as you might imagine,


339
00:19:44,926 --> 00:19:46,556
Crusty really doesn't
really do GUI's.


340
00:19:46,936 --> 00:19:47,966
He's more of a text man.


341
00:19:48,776 --> 00:19:50,186
So his primitives just print


342
00:19:50,186 --> 00:19:52,636
out the drawing commands
you issue, right?


343
00:19:53,116 --> 00:19:56,456
I grudgingly admitted that
this was probably enough


344
00:19:56,456 --> 00:20:01,426
to prove his point, and then
he created a Drawable protocol


345
00:20:01,836 --> 00:20:05,856
to provide a common interface
for all of our drawing elements.


346
00:20:06,856 --> 00:20:08,256
Okay, this is pretty
straightforward.


347
00:20:09,126 --> 00:20:12,266
And then he started
building shapes like Polygon.


348
00:20:13,006 --> 00:20:15,466
Now, the first thing
to notice here


349
00:20:15,466 --> 00:20:17,476
about Polygon is
it's a value type,


350
00:20:18,206 --> 00:20:19,786
built out of other value types.


351
00:20:20,486 --> 00:20:23,046
It's just a struct that
contains an array of points.


352
00:20:24,186 --> 00:20:27,766
And to draw a polygon, we
move to the last corner


353
00:20:28,206 --> 00:20:30,936
and then we cycle through all
the corners, drawing lines.


354
00:20:31,336 --> 00:20:33,836
Okay, and here's a Circle.


355
00:20:35,246 --> 00:20:38,646
Again, Circle is a value type,
built out of other value types.


356
00:20:38,696 --> 00:20:42,036
It's just a struct that contains
a center point and a radius.


357
00:20:43,326 --> 00:20:46,506
Now to draw a Circle, we make
an arc that sweeps all the way


358
00:20:46,626 --> 00:20:48,226
from zero to two pi radians.


359
00:20:51,696 --> 00:20:55,826
So, now we can build a diagram
out of circles and polygons.


360
00:20:59,076 --> 00:21:01,316
'Okay,' said Crusty,
'let's take her for a spin.'


361
00:21:02,256 --> 00:21:04,386
So, he did.


362
00:21:05,036 --> 00:21:08,416
This is a diagram.


363
00:21:10,006 --> 00:21:11,606
A diagram is just a Drawable.


364
00:21:11,606 --> 00:21:13,216
It's another value type.


365
00:21:14,246 --> 00:21:15,046
Why is it a value type?


366
00:21:15,046 --> 00:21:17,956
Because all Drawables are
value types, and so an array


367
00:21:17,956 --> 00:21:19,496
of Drawables is also
a value type.


368
00:21:19,696 --> 00:21:20,806
Let's go back to that.


369
00:21:22,206 --> 00:21:26,616
Wow. Okay, there.


370
00:21:26,616 --> 00:21:30,936
An array of Drawables is also
a value type and, therefore,


371
00:21:30,936 --> 00:21:33,636
since that's the only
thing in my Diagram,


372
00:21:33,636 --> 00:21:34,996
the Diagram is also
a value type.


373
00:21:35,546 --> 00:21:38,916
So, to draw it, we
just loop through all


374
00:21:38,916 --> 00:21:41,966
of the elements and
draw each one.


375
00:21:42,556 --> 00:21:45,646
Okay, now let's take
her for a spin.


376
00:21:47,046 --> 00:21:52,016
So, we're going to test it.


377
00:21:52,526 --> 00:21:55,046
So, Crusty created a Circle


378
00:21:55,046 --> 00:21:58,656
with curiously specific
center and radius.


379
00:21:59,076 --> 00:22:02,386
And then, with uncanny
Spock-like precision,


380
00:22:02,916 --> 00:22:03,886
he added a Triangle.


381
00:22:05,096 --> 00:22:07,246
And finally, he built a Diagram


382
00:22:07,246 --> 00:22:09,416
around them, and
told it to draw.


383
00:22:13,126 --> 00:22:14,806
'Voila,' said Crusty,
triumphantly.


384
00:22:15,136 --> 00:22:18,526
'As you can plainly see, this
is an equilateral triangle


385
00:22:18,526 --> 00:22:20,666
with a circle, inscribed
inside a circle.'


386
00:22:21,796 --> 00:22:25,756
Well, maybe I'm just not as
good at doing trigonometry


387
00:22:25,756 --> 00:22:29,696
in my head, as Crusty is,
but, 'No, Crusty,' I said,


388
00:22:29,696 --> 00:22:30,976
'I can't plainly see that,


389
00:22:31,376 --> 00:22:33,476
and I'd find this demo a
whole lot more compelling


390
00:22:33,476 --> 00:22:35,696
if I was doing something
actually useful


391
00:22:35,696 --> 00:22:38,586
for our app like, you know,
drawing to the screen.'


392
00:22:39,126 --> 00:22:41,996
After I got over my annoyance,


393
00:22:42,436 --> 00:22:46,256
I decided to rewrite his
Renderer to use CoreGraphics.


394
00:22:48,266 --> 00:22:52,076
And I told him I was
going to this and he said,


395
00:22:52,546 --> 00:22:54,096
'Hang on just a minute
there, monkey boy.


396
00:22:55,386 --> 00:22:58,066
If you do that, how am I
going to test my code?'


397
00:22:58,726 --> 00:23:04,156
And then he laid out a pretty
compelling case for the use


398
00:23:04,156 --> 00:23:06,296
of plaintext in testing.


399
00:23:06,706 --> 00:23:09,716
If something changes
in what we're doing,


400
00:23:10,206 --> 00:23:12,716
we'll immediately
see it in the output.


401
00:23:13,986 --> 00:23:16,136
Instead, he suggested
we do a little


402
00:23:16,336 --> 00:23:17,636
protocol-oriented programming.


403
00:23:18,756 --> 00:23:23,396
So he copied his Renderer and
made the copy into a protocol.


404
00:23:24,626 --> 00:23:32,616
Yeah, and then you have to
delete the bodies, okay.


405
00:23:33,066 --> 00:23:33,516
There it is.


406
00:23:33,516 --> 00:23:37,906
And then he renamed the original
Renderer and made it conform.


407
00:23:38,486 --> 00:23:44,046
Now, all of this refactoring
was making me impatient, like,


408
00:23:44,046 --> 00:23:46,566
I really want to see
this stuff on the screen.


409
00:23:47,876 --> 00:23:50,046
I wanted to rush on and
implement a Renderer


410
00:23:50,046 --> 00:23:52,816
for CoreGraphics,
but I had to wait


411
00:23:52,816 --> 00:23:54,616
until Crusty tested
his code again.


412
00:23:55,916 --> 00:23:59,826
And when he was finally
satisfied, he said to me, 'Okay,


413
00:23:59,826 --> 00:24:01,036
what are you going to
put in your Renderer?'


414
00:24:01,686 --> 00:24:04,786
And I said, 'Well, a CGContext.


415
00:24:05,206 --> 00:24:08,646
CGContext has basically
everything a Renderer needs."


416
00:24:09,806 --> 00:24:13,036
In fact, within the limits
of its plain C interface,


417
00:24:13,586 --> 00:24:14,756
it basically is a Renderer.


418
00:24:15,276 --> 00:24:17,106
'Great,' said Crusty.


419
00:24:17,106 --> 00:24:18,656
'Gimme that keyboard.'


420
00:24:18,846 --> 00:24:21,956
And he snatched something away
from me and he did something


421
00:24:21,956 --> 00:24:24,466
so quickly I barely saw it.


422
00:24:31,796 --> 00:24:33,776
'Wait a second,' I said.


423
00:24:34,306 --> 00:24:39,446
'Did you just make every
CGContext into a Renderer?'


424
00:24:40,076 --> 00:24:44,236
He had. I mean, it
didn't do anything yet,


425
00:24:45,126 --> 00:24:46,546
but this was kind of amazing.


426
00:24:46,546 --> 00:24:48,226
I didn't even have
to add a new type.


427
00:24:48,866 --> 00:24:51,816
'What are you waiting for?'


428
00:24:51,816 --> 00:24:52,506
said Crusty.


429
00:24:52,636 --> 00:24:53,516
'Fill in those braces.'


430
00:24:55,026 --> 00:24:57,516
So, I poured in the
necessary CoreGraphics goop,


431
00:24:57,926 --> 00:25:02,596
and threw it all into a
playground, and there it is.


432
00:25:02,746 --> 00:25:04,646
Now, you can download
this playground,


433
00:25:04,646 --> 00:25:07,736
which demonstrates everything
I'm talking about here


434
00:25:07,736 --> 00:25:09,656
in the talk, after we're done.


435
00:25:10,326 --> 00:25:13,606
But back to our example.


436
00:25:14,906 --> 00:25:17,626
Just to mess with me,
Crusty then did this.


437
00:25:18,146 --> 00:25:23,296
Now, it took me a second to
realize why Drawing wasn't going


438
00:25:23,296 --> 00:25:26,616
into an infinite recursion at
this point, and if you want


439
00:25:26,616 --> 00:25:28,376
to know more about
that, you should go


440
00:25:28,376 --> 00:25:31,016
to this session, on Friday.


441
00:25:32,606 --> 00:25:36,286
But it also didn't
change the display at all.


442
00:25:37,456 --> 00:25:40,166
Eventually, Crusty decided
to show me what was happening


443
00:25:40,166 --> 00:25:41,336
in his plaintext output.


444
00:25:42,106 --> 00:25:45,336
So it turns out that it was
just repeating the same drawing


445
00:25:45,336 --> 00:25:48,806
commands, twice.


446
00:25:49,736 --> 00:25:52,846
So, being more of a
graphics-oriented guy,


447
00:25:52,846 --> 00:25:54,796
I really wanted to
see the results.


448
00:25:55,256 --> 00:25:58,796
So, I built a little scaling
adapter and wrapped it


449
00:25:58,796 --> 00:26:03,576
around the Diagram and
this is the result.


450
00:26:04,016 --> 00:26:06,196
And you can see this in the
playground, so I'm not going


451
00:26:06,196 --> 00:26:08,256
to go into the scaling
adapter here.


452
00:26:10,046 --> 00:26:12,806
But that's kind of
a demonstration


453
00:26:12,806 --> 00:26:16,606
that with protocols, we can do
all the same kinds of things


454
00:26:16,606 --> 00:26:18,386
that we're used to
doing with classes.


455
00:26:18,706 --> 00:26:21,116
Adapters, usual design patterns.


456
00:26:21,516 --> 00:26:25,926
Okay, now I'd like to
just reflect a second


457
00:26:25,926 --> 00:26:27,936
on what Crusty did with
TestRenderer though,


458
00:26:28,526 --> 00:26:29,946
because it's actually
kind of brilliant.


459
00:26:32,516 --> 00:26:36,356
See, by decoupling the document
model from a specific Renderer,


460
00:26:36,966 --> 00:26:40,086
he's able to plug in an
instrumented component


461
00:26:40,546 --> 00:26:43,516
that reveals everything
that we do,


462
00:26:43,516 --> 00:26:44,906
that our code does, in detail.


463
00:26:45,496 --> 00:26:49,196
And we've since applied this
approach throughout our code.


464
00:26:50,246 --> 00:26:53,136
We find that, the more we
decouple things with protocols,


465
00:26:53,516 --> 00:26:55,606
the more testable
everything gets.


466
00:26:56,176 --> 00:26:59,686
This kind of testing is
really similar to what you get


467
00:26:59,686 --> 00:27:01,836
with mocks, but it's
so much better.


468
00:27:03,086 --> 00:27:06,586
See, mocks are inherently
fragile, right?


469
00:27:06,586 --> 00:27:09,016
You have to couple
your testing code


470
00:27:09,016 --> 00:27:11,466
to the implementation details
of the code under test.


471
00:27:12,606 --> 00:27:16,026
And because of that
fragility, they don't play well


472
00:27:16,026 --> 00:27:20,436
with Swift's strong
static type system.


473
00:27:20,646 --> 00:27:23,506
See, protocols give us
a principled interface


474
00:27:23,816 --> 00:27:26,136
that we can use, that's
enforced by the language,


475
00:27:26,686 --> 00:27:29,206
but still gives us the
hooks to plug in all


476
00:27:29,206 --> 00:27:31,026
of the instrumentation we need.


477
00:27:32,866 --> 00:27:36,776
Okay, back to our example,
because now we seriously need


478
00:27:36,776 --> 00:27:38,676
to talk about bubbles.


479
00:27:40,016 --> 00:27:43,176
Okay. We wanted this diagramming
app to be popular with the kids,


480
00:27:43,176 --> 00:27:44,636
and the kids love
bubbles, of course.


481
00:27:45,066 --> 00:27:51,126
So, in a Diagram, a bubble is
just an inner circle offset


482
00:27:51,956 --> 00:27:55,896
around the center of the
outer circle that you use


483
00:27:55,896 --> 00:27:57,006
to represent a highlight.


484
00:27:57,836 --> 00:27:58,746
So, you have two circles.


485
00:27:59,476 --> 00:27:59,976
Just like that.


486
00:28:00,966 --> 00:28:03,936
And when I put this
code in context though,


487
00:28:03,936 --> 00:28:06,096
Crusty started getting
really agitated.


488
00:28:07,116 --> 00:28:09,046
All the code repetition
was making him ornery,


489
00:28:09,726 --> 00:28:11,866
and if Crusty ain't
happy, ain't nobody happy.


490
00:28:13,051 --> 00:28:15,051
[Laughter]


491
00:28:15,086 --> 00:28:16,976
'Look, they're all complete
circles,' he shouted.


492
00:28:16,976 --> 00:28:18,176
'I just want to write this.'


493
00:28:19,176 --> 00:28:20,796
I said, 'Calm down, Crusty.


494
00:28:20,926 --> 00:28:21,346
Calm down.


495
00:28:22,076 --> 00:28:22,656
We can do that.


496
00:28:24,166 --> 00:28:28,156
All we need to do is add another
requirement to the protocol.


497
00:28:28,156 --> 00:28:29,276
All right?


498
00:28:29,816 --> 00:28:32,886
Then of course we update
our models to supply it.


499
00:28:33,786 --> 00:28:34,896
There's test Renderer.


500
00:28:36,246 --> 00:28:37,656
And then the CGContext.'


501
00:28:37,656 --> 00:28:42,706
Now, at this point Crusty's got
his boot off and he's beating it


502
00:28:42,706 --> 00:28:45,916
on the desk, because here we
were again, repeating code.


503
00:28:47,206 --> 00:28:49,776
He snatched the keyboard back
from me, muttering something


504
00:28:49,776 --> 00:28:53,596
about having to do everything
his own self, and he proceeded


505
00:28:53,596 --> 00:28:55,946
to school me using a
new feature in Swift.


506
00:28:56,436 --> 00:29:01,896
This is a protocol extension.


507
00:29:03,276 --> 00:29:05,806
This says 'all models


508
00:29:05,806 --> 00:29:08,246
of Renderer have this
implementation of circleAt.'


509
00:29:09,516 --> 00:29:13,446
Now we have an implementation
that is shared among all


510
00:29:13,446 --> 00:29:14,346
of the models of Renderer.


511
00:29:14,936 --> 00:29:18,286
So, notice that we still have
this circleAt requirement


512
00:29:18,476 --> 00:29:18,856
up there.


513
00:29:19,566 --> 00:29:21,026
You might ask, 'what
does it means


514
00:29:21,026 --> 00:29:23,856
to have a requirement that's
also fulfilled immediately


515
00:29:24,166 --> 00:29:25,166
in an extension?'


516
00:29:26,376 --> 00:29:26,856
Good question.


517
00:29:27,506 --> 00:29:31,436
The answer is that a
protocol requirement creates a


518
00:29:31,436 --> 00:29:32,456
customization point.


519
00:29:33,736 --> 00:29:38,166
To see how this plays out,
let's collapse this method body


520
00:29:38,726 --> 00:29:40,546
and add another method
to the extension.


521
00:29:40,846 --> 00:29:43,446
One that isn't backed
by a requirement.


522
00:29:43,956 --> 00:29:48,766
And now we can extend
Crusty's TestRenderer


523
00:29:49,036 --> 00:29:51,466
to implement both
of these methods.


524
00:29:51,836 --> 00:29:57,756
And then we'll just call them.


525
00:29:57,976 --> 00:30:01,696
Okay. Now, what happens here
is totally unsurprising.


526
00:30:02,186 --> 00:30:04,856
We're directly calling the
implementations in TestRenderer


527
00:30:05,796 --> 00:30:08,406
and the protocol isn't
even involved, right?


528
00:30:08,896 --> 00:30:12,316
We'd get the same result if
we removed that conformance.


529
00:30:14,566 --> 00:30:19,026
But now, let's change
the context


530
00:30:19,026 --> 00:30:22,276
so Swift only knows it has a
Renderer, not a TestRenderer.


531
00:30:22,856 --> 00:30:27,056
And here's what happens.


532
00:30:28,146 --> 00:30:30,506
So because circleAt
is a requirement,


533
00:30:31,316 --> 00:30:33,986
our model gets the
privilege of customizing it,


534
00:30:34,396 --> 00:30:35,776
and the customization
gets called.


535
00:30:38,896 --> 00:30:46,516
That one. But rectangleAt
isn't a requirement,


536
00:30:46,516 --> 00:30:48,436
so the implementation
in TestRenderer,


537
00:30:48,846 --> 00:30:52,896
it only shadows the one in the
protocol and in this context,


538
00:30:53,456 --> 00:30:56,086
where you only know you have a
Renderer and not a TestRenderer,


539
00:30:56,586 --> 00:30:58,066
the protocol implementation
is called.


540
00:30:58,626 --> 00:31:01,226
Which is kind of weird, right?


541
00:31:02,516 --> 00:31:03,786
So, does this mean


542
00:31:03,786 --> 00:31:05,996
that rectangleAt should
have been a requirement?


543
00:31:07,066 --> 00:31:08,316
Maybe, in this case, it should,


544
00:31:08,626 --> 00:31:11,236
because some Renderers
are highly likely


545
00:31:11,236 --> 00:31:13,676
to have a more efficient
way to draw rectangles, say,


546
00:31:13,916 --> 00:31:15,916
aligned with a coordinate
system.


547
00:31:17,576 --> 00:31:21,376
But, should everything in your
protocol extension also be


548
00:31:21,376 --> 00:31:22,456
backed by a requirement?


549
00:31:22,896 --> 00:31:23,736
Not necessarily.


550
00:31:24,356 --> 00:31:28,476
I mean, some APIs
are just not intended


551
00:31:28,476 --> 00:31:29,996
as customization points.


552
00:31:30,716 --> 00:31:32,876
So, sometimes the right fix is


553
00:31:32,876 --> 00:31:37,476
to just not shadow the
requirement in the model,


554
00:31:38,026 --> 00:31:39,916
not shadow the method
in the model.


555
00:31:40,686 --> 00:31:47,196
Okay. So, this new
feature, incidentally,


556
00:31:47,196 --> 00:31:50,496
it's revolutionized our work
on the Swift Standard Library.


557
00:31:51,836 --> 00:31:54,336
Sometimes what we can do
with protocol extensions,


558
00:31:55,336 --> 00:31:56,696
it just feels like magic.


559
00:31:57,916 --> 00:32:01,176
I really hope that you'll enjoy
working with the latest library


560
00:32:01,516 --> 00:32:03,226
as much as we've
enjoyed applying this


561
00:32:03,256 --> 00:32:04,256
to it and updating it.


562
00:32:04,256 --> 00:32:08,386
And I want to put our
story aside for a second,


563
00:32:08,386 --> 00:32:11,676
so I can show you some things
that we did in Standard Library


564
00:32:12,006 --> 00:32:14,896
with protocol extensions,
and few other tricks besides.


565
00:32:16,506 --> 00:32:19,226
So, first, there's a
new indexOf method.


566
00:32:20,706 --> 00:32:23,046
So, this just walks through
the indices of the collection


567
00:32:23,426 --> 00:32:26,626
until it finds an element that's
equal to what we're looking for


568
00:32:26,936 --> 00:32:28,456
and it returns that index.


569
00:32:28,986 --> 00:32:30,746
And if it doesn't find
one, it returns nil.


570
00:32:31,546 --> 00:32:32,336
Simple enough, right?


571
00:32:32,886 --> 00:32:36,366
But if we write it this
way, we have a problem.


572
00:32:37,846 --> 00:32:41,826
See the elements of an arbitrary
collection can't be compared


573
00:32:41,826 --> 00:32:42,476
with equal-equal.


574
00:32:42,996 --> 00:32:48,586
So, to fix that, we can
constrain the extension.


575
00:32:49,376 --> 00:32:51,626
This is another aspect
of this new feature.


576
00:32:54,896 --> 00:32:58,766
So, by saying this extension
applies when the element type


577
00:32:58,766 --> 00:33:00,186
of the collection is Equatable,


578
00:33:01,396 --> 00:33:04,456
we've given Swift the
information it needs to allow


579
00:33:04,456 --> 00:33:05,986
that equality comparison.


580
00:33:06,506 --> 00:33:10,336
And now that we've
seen a simple example


581
00:33:10,406 --> 00:33:13,886
of a constrained extension,
let's revisit our binary search.


582
00:33:15,266 --> 00:33:19,346
And let's use it
on an array of Int.


583
00:33:21,036 --> 00:33:24,676
Hmm. Okay, Int doesn't
conform to Ordered.


584
00:33:25,696 --> 00:33:26,886
Well that's a simple fix, right?


585
00:33:27,386 --> 00:33:28,586
We'll just add a conformance.


586
00:33:29,986 --> 00:33:33,076
Okay, now what about Strings?


587
00:33:33,256 --> 00:33:34,476
Well, of course,
this doesn't work


588
00:33:34,476 --> 00:33:35,966
for Strings, so we do it again.


589
00:33:36,686 --> 00:33:39,316
Now before Crusty starts banging
on his desk, we really want


590
00:33:39,316 --> 00:33:40,716
to factor this stuff out, right?


591
00:33:41,016 --> 00:33:44,236
The less-than operator
is present


592
00:33:44,236 --> 00:33:47,296
in the Comparable
protocol, so we could do this


593
00:33:47,296 --> 00:33:48,836
with an extension to comparable.


594
00:33:49,386 --> 00:33:51,176
Like this.


595
00:33:52,146 --> 00:33:58,426
Now we're providing the
precedes for those conformances.


596
00:33:58,746 --> 00:34:01,826
So, on the one hand, this
is really nice, right?


597
00:34:01,826 --> 00:34:03,736
When I want a binary
search for Doubles, well,


598
00:34:04,106 --> 00:34:08,846
all I have to is add this
conformance and I can do it.


599
00:34:08,976 --> 00:34:13,295
On the other hand, it's
kind of icky, because even


600
00:34:13,295 --> 00:34:15,156
if I take away the conformance,


601
00:34:15,516 --> 00:34:19,266
I still have this precedes
function that's been glommed


602
00:34:19,266 --> 00:34:22,045
onto Doubles, which already have
enough of an interface, right?


603
00:34:22,496 --> 00:34:25,466
We maybe would like to be
a little bit more selective


604
00:34:25,466 --> 00:34:27,466
about adding stuff to Double.


605
00:34:28,116 --> 00:34:33,846
So, and even though
I can do that,


606
00:34:33,846 --> 00:34:35,755
I can't binarySearch with it.


607
00:34:35,755 --> 00:34:38,255
So it's really, that precedes
function buys me nothing.


608
00:34:39,806 --> 00:34:41,766
Fortunately, I can
be more selective


609
00:34:41,766 --> 00:34:43,315
about what gets a precedes API,


610
00:34:44,235 --> 00:34:46,295
by using a constrained
extension on Ordered.


611
00:34:46,985 --> 00:34:52,786
So, this says that a type that
is Comparable and is declared


612
00:34:52,786 --> 00:34:55,476
to be Ordered will
automatically be able


613
00:34:55,476 --> 00:34:57,166
to satisfy the precedes
requirement,


614
00:34:57,806 --> 00:35:00,406
which is exactly what we want.


615
00:35:00,566 --> 00:35:02,786
I'm sorry, but I think
that's just really cool.


616
00:35:03,236 --> 00:35:05,866
[Applause] We've got
the same abstraction.


617
00:35:06,846 --> 00:35:08,446
The same logical
abstraction coming


618
00:35:08,446 --> 00:35:09,476
from two different places,


619
00:35:09,476 --> 00:35:12,316
and we've just made them
interoperate seamlessly.


620
00:35:12,896 --> 00:35:17,656
Thank you for the applause,
but I just, I think it's cool.


621
00:35:17,656 --> 00:35:22,646
Okay, ready for a
palate cleanser?


622
00:35:23,066 --> 00:35:25,136
That's just showing it work.


623
00:35:25,786 --> 00:35:31,386
Okay. This is the signature of
a fully generalized binarySearch


624
00:35:32,046 --> 00:35:33,736
that works on any Collection


625
00:35:34,116 --> 00:35:36,876
with the appropriate
Index and Element types.


626
00:35:37,596 --> 00:35:40,386
Now, I can already hear you guys
getting uncomfortable out there.


627
00:35:40,656 --> 00:35:42,236
I'm not going to write
the body out here,


628
00:35:42,236 --> 00:35:44,806
because this is already pretty
awful to look at, right?


629
00:35:45,776 --> 00:35:48,786
Swift 1 had lots of generic
free functions like this.


630
00:35:49,986 --> 00:35:52,576
In Swift 2, we used protocol
extensions to make them


631
00:35:52,576 --> 00:35:55,816
into methods like this,
which is awesome, right?


632
00:35:56,506 --> 00:36:00,156
Now, everybody focuses on
the improvement this makes


633
00:36:00,156 --> 00:36:04,596
at the call site, which
is now clearly chock full


634
00:36:04,906 --> 00:36:06,546
of method-y goodness, right?


635
00:36:06,976 --> 00:36:08,906
But as the guy writing
binarySearch,


636
00:36:09,486 --> 00:36:10,976
I love what it did
for the signature.


637
00:36:11,866 --> 00:36:15,306
By separating the conditions
under which this method applies


638
00:36:15,616 --> 00:36:17,116
from the rest of
the declaration,


639
00:36:17,816 --> 00:36:19,776
which now just reads
like a regular method.


640
00:36:21,406 --> 00:36:22,816
No more angle bracket blindness.


641
00:36:24,516 --> 00:36:28,556
[Applause]


642
00:36:29,056 --> 00:36:30,976
Thank you very much.


643
00:36:31,196 --> 00:36:35,036
Okay, last trick before
we go back to our story.


644
00:36:35,836 --> 00:36:39,346
This is a playground
containing a minimal model


645
00:36:39,346 --> 00:36:41,596
of Swift's new OptionSetType
protocol.


646
00:36:42,786 --> 00:36:43,626
It's just a struct


647
00:36:43,626 --> 00:36:46,706
with a read-only Int
property, called rawValue.


648
00:36:47,486 --> 00:36:52,036
Now take a look at the broad
Set-like interface you actually


649
00:36:52,036 --> 00:36:54,146
get for free once
you've done that.


650
00:36:55,246 --> 00:36:57,586
All of this comes from
protocol extensions.


651
00:36:58,966 --> 00:37:01,026
And when you get a chance,
I invite you to take a look


652
00:37:01,026 --> 00:37:02,736
at how those extensions
are declared


653
00:37:03,176 --> 00:37:06,046
in the Standard Library, because
several layers are working


654
00:37:06,046 --> 00:37:08,356
together to provide
this rich API.


655
00:37:11,326 --> 00:37:15,126
Okay, so those are some of the
cool things that you can do


656
00:37:15,126 --> 00:37:16,306
with protocol extensions.


657
00:37:17,376 --> 00:37:20,176
Now, for the piece de
resistance, I'd like to return


658
00:37:20,176 --> 00:37:21,406
to our diagramming example.


659
00:37:24,146 --> 00:37:25,836
Always make value
types equatable.


660
00:37:27,696 --> 00:37:30,076
Why? Because I said so.


661
00:37:30,806 --> 00:37:32,206
Also, eat your vegetables.


662
00:37:32,856 --> 00:37:36,136
No, actually, if you want to
know why, go to this session


663
00:37:36,136 --> 00:37:37,716
on Friday, which I
told you about already.


664
00:37:39,576 --> 00:37:41,726
It's a really cool
talk and they're going


665
00:37:41,726 --> 00:37:44,776
to discuss this issue in detail.


666
00:37:44,866 --> 00:37:48,276
Anyway, Equatable is easy
for most types, right?


667
00:37:48,276 --> 00:37:51,546
You just compare corresponding
parts for equality, like this.


668
00:37:52,946 --> 00:37:55,236
But, now, let's see what
happens with Diagram.


669
00:37:55,826 --> 00:38:03,366
Uh-oh. We can't compare two
arrays of Drawable for equality.


670
00:38:05,206 --> 00:38:07,196
All right, maybe we can do it


671
00:38:07,196 --> 00:38:09,756
by comparing the
individual elements,


672
00:38:09,756 --> 00:38:14,366
which looks something like this.


673
00:38:15,766 --> 00:38:19,046
Okay, I'll go through
it for you.


674
00:38:19,176 --> 00:38:21,496
First, you make sure they have
the same number of elements,


675
00:38:21,646 --> 00:38:23,906
then you zip the
two arrays together.


676
00:38:23,906 --> 00:38:25,756
If they do have the same number
of elements, then you look


677
00:38:25,846 --> 00:38:28,576
for one where you have
a pair that's not equal.


678
00:38:28,576 --> 00:38:30,386
All right, you can
take my word for it.


679
00:38:30,386 --> 00:38:36,116
This isn't the interesting
part of the problem.


680
00:38:36,226 --> 00:38:36,986
Oops, right?


681
00:38:37,206 --> 00:38:40,166
This is, the whole reason we
couldn't compare the arrays is


682
00:38:40,196 --> 00:38:43,596
because Drawables
aren't equatable, right?


683
00:38:43,786 --> 00:38:46,596
So, we didn't have an equality
operator for the arrays.


684
00:38:47,056 --> 00:38:48,846
We don't have an
equality operator


685
00:38:48,846 --> 00:38:49,966
for the underlying Drawables.


686
00:38:49,966 --> 00:38:52,526
So, can we just make
all Drawables Equatable?


687
00:38:53,196 --> 00:38:55,146
We change our design like this.


688
00:38:56,516 --> 00:39:01,296
Well, the problem with this is


689
00:39:01,336 --> 00:39:03,266
that Equatable has
Self-requirements,


690
00:39:04,346 --> 00:39:07,206
which means that Drawable
now has Self-requirements.


691
00:39:08,396 --> 00:39:11,326
And a Self-requirement
puts Drawable squarely


692
00:39:11,326 --> 00:39:15,556
in the homogeneous, statically
dispatched world, right?


693
00:39:16,176 --> 00:39:20,036
But Diagram really needs
a heterogeneous array


694
00:39:20,266 --> 00:39:21,866
of Drawables, right?


695
00:39:21,896 --> 00:39:25,216
So we can put polygons and
circles in the same Diagram.


696
00:39:25,216 --> 00:39:28,066
So Drawable has to stay
in the heterogeneous,


697
00:39:28,066 --> 00:39:29,316
dynamically dispatched world.


698
00:39:30,366 --> 00:39:31,316
And we've got a contradiction.


699
00:39:31,966 --> 00:39:36,286
Making Drawable equatable
is not going to work.


700
00:39:37,796 --> 00:39:39,746
We'll need to do
something like this,


701
00:39:39,746 --> 00:39:42,786
which means adding a new
isEqualTo requirement


702
00:39:42,786 --> 00:39:43,336
to Drawable.


703
00:39:44,676 --> 00:39:49,956
But, oh, no, we can't
use Self, right?


704
00:39:49,956 --> 00:39:51,836
Because we need to
stay heterogeneous.


705
00:39:52,176 --> 00:39:54,946
And without Self, this is just


706
00:39:54,946 --> 00:39:57,846
like implementing
Ordered with classes was.


707
00:39:58,756 --> 00:40:00,836
We're now going to
force all Drawables


708
00:40:01,136 --> 00:40:04,066
to handle the heterogeneous
comparison case.


709
00:40:06,366 --> 00:40:08,606
Fortunately, there's
a way out this time.


710
00:40:08,986 --> 00:40:13,286
Unlike most symmetric
operations, equality is special


711
00:40:14,366 --> 00:40:16,626
because there's an
obvious, default answer


712
00:40:16,626 --> 00:40:18,526
when the types don't
match up, right?


713
00:40:18,526 --> 00:40:21,336
We can say if you have
two different types,


714
00:40:21,636 --> 00:40:22,166
they're not equal.


715
00:40:22,686 --> 00:40:27,516
With that insight, we
can implement isEqualTo


716
00:40:27,516 --> 00:40:32,036
for all Drawables when
they're Equatable.


717
00:40:32,726 --> 00:40:35,186
Like this.


718
00:40:35,406 --> 00:40:36,316
So, let me walk you through it.


719
00:40:37,546 --> 00:40:38,916
The extension is
just what we said.


720
00:40:39,116 --> 00:40:48,036
It's for all Drawables
that are Equatable.


721
00:40:49,046 --> 00:40:53,066
Okay, first we conditionally
down-cast other


722
00:40:53,106 --> 00:40:53,876
to the Self type.


723
00:40:54,486 --> 00:40:57,156
Right? And if that
succeeds, then we can go ahead


724
00:40:57,156 --> 00:40:58,526
and use equality comparison,


725
00:40:58,526 --> 00:41:00,496
because we have an
Equatable conformance.


726
00:41:01,466 --> 00:41:04,056
Otherwise, the instances
are deemed unequal.


727
00:41:08,516 --> 00:41:12,876
Okay, so, big picture,
what just happened here?


728
00:41:13,216 --> 00:41:15,996
We made a deal with the
implementers of Drawable.


729
00:41:16,466 --> 00:41:19,426
We said, 'If you
really want to go


730
00:41:19,426 --> 00:41:22,586
and handle the heterogeneous
case, be my guest.


731
00:41:22,916 --> 00:41:24,746
Go and implement isEqualTo.


732
00:41:25,636 --> 00:41:30,116
But if you just want to just
use the regular way we express


733
00:41:30,116 --> 00:41:33,366
homogeneous comparison,
we'll handle all the burdens


734
00:41:33,366 --> 00:41:36,356
of the heterogeneous
comparison for you.'


735
00:41:38,116 --> 00:41:41,266
So, building bridges
between the static


736
00:41:41,266 --> 00:41:44,336
and dynamic worlds is a
fascinating design space,


737
00:41:44,836 --> 00:41:46,966
and I encourage you
to look into more.


738
00:41:46,966 --> 00:41:51,986
This particular problem we
solved using a special property


739
00:41:51,986 --> 00:41:55,556
of equality, but the
problems aren't all like that,


740
00:41:55,906 --> 00:42:00,456
and there's lots of really
cool stuff you can do.


741
00:42:01,376 --> 00:42:04,226
So, that property of equality
doesn't necessarily apply,


742
00:42:04,226 --> 00:42:06,196
but what does apply
almost universally?


743
00:42:07,686 --> 00:42:08,696
Protocol-based design.


744
00:42:10,126 --> 00:42:20,046
Okay, so, I want to say a few
words before we wrap up about


745
00:42:20,046 --> 00:42:22,866
when to use classes, because
they do have their place.


746
00:42:23,856 --> 00:42:26,656
Okay? There are times when you
really do want implicit sharing,


747
00:42:27,206 --> 00:42:31,336
for example, when the
fundamental operations


748
00:42:31,336 --> 00:42:34,676
of a value type don't make any
sense, like copying this thing.


749
00:42:34,676 --> 00:42:35,906
What would a copy mean?


750
00:42:35,906 --> 00:42:37,396
If you can't figure
out what that means,


751
00:42:38,036 --> 00:42:40,426
then maybe you really do want
it to be a reference type.


752
00:42:41,326 --> 00:42:42,776
Or a comparison.


753
00:42:43,326 --> 00:42:43,886
The same thing.


754
00:42:44,016 --> 00:42:46,106
That's another fundamental
part of being a value.


755
00:42:46,786 --> 00:42:48,006
So, for example, a Window.


756
00:42:48,676 --> 00:42:50,216
What would it mean
to copy a Window?


757
00:42:50,476 --> 00:42:52,666
Would you actually
want to see, you know,


758
00:42:52,666 --> 00:42:53,706
a new graphical Window?


759
00:42:53,816 --> 00:42:55,266
What, right on top
of the other one?


760
00:42:55,266 --> 00:42:56,986
I don't know.


761
00:42:57,116 --> 00:42:58,876
It wouldn't be part of
your view hierarchy.


762
00:42:59,976 --> 00:43:00,676
Doesn't make sense.


763
00:43:01,186 --> 00:43:04,146
So, another case
where the lifetime


764
00:43:04,146 --> 00:43:09,116
of your instance is tied to
some external side effect,


765
00:43:09,506 --> 00:43:11,686
like files appearing
on your disk.


766
00:43:12,736 --> 00:43:17,286
Part of this is because values
get created very liberally


767
00:43:17,286 --> 00:43:20,366
by the compiler, and
created and destroyed,


768
00:43:20,626 --> 00:43:22,766
and we try to optimize
that as well as possible.


769
00:43:23,616 --> 00:43:26,726
It's the reference types that
have this stable identity,


770
00:43:26,726 --> 00:43:28,986
so if you're going to make
something that corresponds


771
00:43:28,986 --> 00:43:31,986
to an external entity,
you might want


772
00:43:32,116 --> 00:43:33,016
to make it a reference type.


773
00:43:33,576 --> 00:43:38,706
A class. Another case
is where the instances


774
00:43:38,706 --> 00:43:40,356
of the abstraction
are just "sinks."


775
00:43:40,826 --> 00:43:42,536
Like, our Renderers,
for example.


776
00:43:43,726 --> 00:43:47,966
So, we're just pumping, we're
just pumping information


777
00:43:47,966 --> 00:43:49,606
into that thing, into
that Renderer, right?


778
00:43:49,606 --> 00:43:50,976
We tell it to draw a line.


779
00:43:52,136 --> 00:43:55,456
So, for example, if you
wanted to make a TestRenderer


780
00:43:55,456 --> 00:44:00,636
that accumulated the text
to output of these commands


781
00:44:00,846 --> 00:44:03,606
into a String instead of just
dumping them to the console,


782
00:44:03,996 --> 00:44:06,706
you might do it like this.


783
00:44:06,916 --> 00:44:08,866
But notice a couple
of things about this.


784
00:44:09,356 --> 00:44:12,336
First, it's final, right?


785
00:44:13,146 --> 00:44:15,076
Second, it doesn't
have a base class.


786
00:44:15,426 --> 00:44:16,446
That's still a protocol.


787
00:44:17,066 --> 00:44:18,996
I'm using the protocol
for the abstraction.


788
00:44:19,576 --> 00:44:25,306
Okay, a couple of more cases.


789
00:44:27,706 --> 00:44:30,696
So, we live in an
object-oriented world, right?


790
00:44:30,856 --> 00:44:33,656
Cocoa and Cocoa Touch
deal in objects.


791
00:44:34,736 --> 00:44:36,066
They're going to
give you baseclasses


792
00:44:36,146 --> 00:44:37,396
and expect you to subclass them.


793
00:44:37,836 --> 00:44:40,756
They're going to expect
objects in their APIs.


794
00:44:41,476 --> 00:44:43,576
Don't fight the system, okay?


795
00:44:43,986 --> 00:44:45,086
That would just be futile.


796
00:44:46,406 --> 00:44:51,226
But, at the same time,
be circumspect about it.


797
00:44:51,976 --> 00:44:55,056
You know, nothing in your
program should ever get too big,


798
00:44:55,056 --> 00:44:57,906
and that goes for classes
just as well as anything else.


799
00:44:58,816 --> 00:45:01,826
So, when you're refactoring
and factoring something


800
00:45:01,826 --> 00:45:07,216
out of class, consider
using a value type instead.


801
00:45:07,576 --> 00:45:10,326
Okay, to sum up.


802
00:45:10,976 --> 00:45:14,226
Protocols, much greater than
superclasses for abstraction.


803
00:45:16,196 --> 00:45:21,126
Second, protocol
extensions, this new feature


804
00:45:21,126 --> 00:45:23,286
to let you do almost
magic things.


805
00:45:23,826 --> 00:45:27,716
Third, did I mention you should
go see this talk on Friday?


806
00:45:29,786 --> 00:45:30,716
Go see this talk on Friday.


807
00:45:31,576 --> 00:45:33,676
Eat your vegetables.


808
00:45:34,826 --> 00:45:35,466
Be like Crusty.


809
00:45:36,746 --> 00:45:37,346
Thank you very much.


810
00:45:38,516 --> 00:45:42,516
[Applause]


811
00:45:43,016 --> 00:45:51,576
[Silence]

