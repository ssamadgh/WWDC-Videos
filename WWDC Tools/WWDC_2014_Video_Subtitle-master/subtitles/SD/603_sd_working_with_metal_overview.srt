1
00:00:13,356 --> 00:00:14,436
>> Welcome everyone.


2
00:00:14,896 --> 00:00:17,336
Welcome. Welcome to WWDC,


3
00:00:17,656 --> 00:00:19,906
and welcome to our
Introductory Session


4
00:00:20,196 --> 00:00:21,676
about Working with Metal.


5
00:00:22,796 --> 00:00:25,206
Now we're incredibly
excited to get to talk


6
00:00:25,206 --> 00:00:26,386
to you today about Metal.


7
00:00:27,076 --> 00:00:30,696
We believe it's literally going
to be a game changer for you,


8
00:00:31,336 --> 00:00:33,586
your applications, and for iOS.


9
00:00:34,566 --> 00:00:36,246
Now as you've heard
in the keynote,


10
00:00:36,846 --> 00:00:40,926
Metal is our new
low-overhead, high-performance,


11
00:00:41,006 --> 00:00:43,926
and incredibly efficient
GPU programming API.


12
00:00:45,046 --> 00:00:49,016
It provides dramatically reduced
overhead for executing work


13
00:00:49,196 --> 00:00:51,356
such as graphics and
compute on a GPU.


14
00:00:52,406 --> 00:00:54,866
And with the support
for precompiled shaders


15
00:00:55,046 --> 00:00:58,176
and incredibly efficient
multithreading, we designed it


16
00:00:58,536 --> 00:01:01,096
to run like a dream
on the A7 chip.


17
00:01:02,476 --> 00:01:05,355
Now today in this session,
I'm going to talk to you


18
00:01:05,355 --> 00:01:07,986
at a relatively high level
about the background, the how


19
00:01:07,986 --> 00:01:09,756
and why we created
Metal and some


20
00:01:09,756 --> 00:01:12,046
of the conceptual
framework for the API.


21
00:01:12,046 --> 00:01:15,836
I'll also touch briefly on
the Metal shading language


22
00:01:16,416 --> 00:01:17,596
and our developer tools.


23
00:01:18,816 --> 00:01:21,136
The sessions that follow
will go into much more detail


24
00:01:21,136 --> 00:01:23,746
about exactly how to use
the Metal API and how


25
00:01:23,746 --> 00:01:25,806
to build your applications,
but we'll keep things


26
00:01:25,806 --> 00:01:27,326
at a high level for
this session.


27
00:01:28,686 --> 00:01:31,346
So, first, a bit of
background on Metal itself.


28
00:01:31,576 --> 00:01:35,616
Now you also heard in the
keynote that Metal provides


29
00:01:36,046 --> 00:01:39,606
up to 10x the number of draw
calls for your application.


30
00:01:40,186 --> 00:01:41,986
Now what does that really mean?


31
00:01:42,886 --> 00:01:45,736
Well, it's important to think
about draw calls in this way:


32
00:01:46,056 --> 00:01:50,546
each draw call requires its
own graphics state vector.


33
00:01:51,266 --> 00:01:54,166
So when you're specifying that
you would like to draw something


34
00:01:54,166 --> 00:01:57,886
with the GPU, you also need
to tell the GPU which shaders,


35
00:01:57,886 --> 00:02:00,246
which states, how you want
to configure the textures


36
00:02:00,246 --> 00:02:01,566
and the rendering destinations.


37
00:02:02,676 --> 00:02:05,356
This is very important in order


38
00:02:05,356 --> 00:02:07,306
to get the effect you're
looking for from the GPU.


39
00:02:08,015 --> 00:02:08,876
But, unfortunately,


40
00:02:08,916 --> 00:02:11,166
with previous APIs
changing state vectors,


41
00:02:11,316 --> 00:02:12,966
it'd be extremely expensive.


42
00:02:13,526 --> 00:02:17,076
You have to translate between
the API state and the state


43
00:02:17,076 --> 00:02:18,336
that the hardware's
going to consume.


44
00:02:19,436 --> 00:02:23,346
When I say expensive, I mean,
not for the GPU, but for the CPU


45
00:02:24,126 --> 00:02:26,646
because it's the CPU that's
doing that type of translation.


46
00:02:26,646 --> 00:02:30,406
So let's take a look
at a quick example.


47
00:02:31,416 --> 00:02:34,006
If your application is
setting up for a new draw call,


48
00:02:34,176 --> 00:02:35,906
you'll want to specify
the shaders and the state


49
00:02:35,906 --> 00:02:39,986
and the textures for each
draw operation, and you'll do


50
00:02:39,986 --> 00:02:42,326
that each time you want to
specify a new draw call.


51
00:02:42,776 --> 00:02:44,846
And then the CPU gets
involved and spends a bunch


52
00:02:44,846 --> 00:02:49,116
of time translating those state
changes and those requests


53
00:02:49,116 --> 00:02:53,096
to draw into hardware commands
before sending it to the GPU.


54
00:02:54,216 --> 00:02:56,706
So if we had a way to make
that much less expensive,


55
00:02:56,876 --> 00:02:59,616
we could give you a lot
more draw calls per frame,


56
00:03:00,266 --> 00:03:01,536
and you might ask
yourself, well,


57
00:03:01,606 --> 00:03:03,206
why do I want more
draw calls per frame?


58
00:03:03,916 --> 00:03:07,336
Well, more draw calls lets
you build much better games


59
00:03:07,336 --> 00:03:08,266
and applications.


60
00:03:08,776 --> 00:03:11,046
You can build many
more unique objects,


61
00:03:11,326 --> 00:03:13,906
have many more bad guys, or
other characters in the scene.


62
00:03:14,506 --> 00:03:17,226
You can add a lot more
visual variety to your games.


63
00:03:17,926 --> 00:03:21,506
But probably the most important
reason is your game artists


64
00:03:21,556 --> 00:03:23,606
and designers are going
to thank you profusely


65
00:03:23,606 --> 00:03:25,406
because you're going to
give them more freedom


66
00:03:25,406 --> 00:03:29,276
to realize their vision without
having to jump through all types


67
00:03:29,276 --> 00:03:32,956
of draw call gymnastics to fit
what they'd like to see onscreen


68
00:03:33,166 --> 00:03:34,586
into a tiny number
of draw calls.


69
00:03:34,586 --> 00:03:37,796
Now let's take a
little bit of a look


70
00:03:38,306 --> 00:03:40,246
at what life was
like before Metal.


71
00:03:41,386 --> 00:03:45,796
Now, Apple has a long history
of GPU programming APIs,


72
00:03:45,826 --> 00:03:46,896
both implementing them,


73
00:03:46,896 --> 00:03:48,356
maintaining them,
developing them.


74
00:03:49,566 --> 00:03:53,646
We've supported standard
APIs like OpenGL and OpenCL.


75
00:03:54,996 --> 00:03:57,276
We've supported APIs across
a wide variety of domains,


76
00:03:57,276 --> 00:03:59,716
both at the high level and the
low level of GP programming


77
00:03:59,716 --> 00:04:01,246
for things like 2D, 3D,


78
00:04:01,406 --> 00:04:03,026
animations, and image
processing.


79
00:04:03,936 --> 00:04:07,836
And we've supported a wide
variety of architectures


80
00:04:08,216 --> 00:04:12,266
in the hardware, across
platforms, computers, devices,


81
00:04:12,646 --> 00:04:17,466
phones, iPads, and a
wide variety of GPUs.


82
00:04:18,466 --> 00:04:20,416
And during all this time,
as we're supporting all


83
00:04:20,416 --> 00:04:21,755
of this variety, we realized


84
00:04:21,755 --> 00:04:24,776
that there was something pretty
fundamental missing from all


85
00:04:24,776 --> 00:04:29,966
of these APIs, and that was
the level of deep integration


86
00:04:30,246 --> 00:04:32,126
that Apple brings
to its products.


87
00:04:32,866 --> 00:04:36,176
Now Apple, as you know,
provides the operating system,


88
00:04:36,916 --> 00:04:40,816
the hardware, and the
products as a complete package.


89
00:04:41,076 --> 00:04:42,876
They're designed to work
together seamlessly.


90
00:04:43,676 --> 00:04:45,026
And so we thought to ourselves:


91
00:04:45,976 --> 00:04:49,376
what if we could take the same
approach to GPU programming


92
00:04:49,376 --> 00:04:50,986
that we take to our
products as a whole?


93
00:04:51,906 --> 00:04:53,676
If we could build these
to work seamlessly,


94
00:04:54,266 --> 00:04:56,556
we knew we could do the
same for GPU programming,


95
00:04:57,086 --> 00:04:58,256
and that's what we've
done with Metal.


96
00:04:58,256 --> 00:05:01,836
Now as I said, we have a
long history of looking


97
00:05:01,836 --> 00:05:03,326
at these different types
of programming APIs,


98
00:05:03,326 --> 00:05:07,486
and we realized that if we
wanted to get a tenfold --


99
00:05:07,486 --> 00:05:09,656
an order of magnitude --
improvement in performance,


100
00:05:09,976 --> 00:05:11,906
we're going to have to do
some pretty radical things.


101
00:05:12,376 --> 00:05:20,076
We decided to take a clean
sheet approach to this design,


102
00:05:20,656 --> 00:05:25,146
and the key design goals that
we had were outlined here.


103
00:05:26,146 --> 00:05:29,796
First, we knew we wanted to
have the thinnest possible API


104
00:05:29,796 --> 00:05:31,386
that we could create.


105
00:05:31,516 --> 00:05:34,266
We wanted to be --
reduce the amount of code


106
00:05:34,266 --> 00:05:36,866
that was executing in
between your application


107
00:05:37,056 --> 00:05:38,616
and the GPU to a bare minimum.


108
00:05:40,656 --> 00:05:43,096
We knew it needed to
support the most modern GPU


109
00:05:43,196 --> 00:05:44,106
hardware features.


110
00:05:44,686 --> 00:05:47,146
We didn't want it bogged down
with the cruft of 20 years


111
00:05:47,426 --> 00:05:48,726
of previous GPU designs.


112
00:05:48,726 --> 00:05:52,006
We wanted it focused entirely
and squarely on the future.


113
00:05:52,426 --> 00:05:56,006
We knew that there were some
expensive CPU operations


114
00:05:56,006 --> 00:05:58,876
that needed to take place, but
we wanted to carefully control


115
00:05:58,936 --> 00:06:00,656
when those happen and
make sure they happen


116
00:06:00,656 --> 00:06:02,496
as infrequently as possible.


117
00:06:02,866 --> 00:06:06,486
And we wanted to give
you, the developer,


118
00:06:07,136 --> 00:06:10,456
predictable performance so
you would know exactly when


119
00:06:10,556 --> 00:06:13,536
and how those expensive
operations could take place.


120
00:06:13,876 --> 00:06:18,026
We wanted to give
you explicit control


121
00:06:18,026 --> 00:06:22,176
over when the work was executed
on the GPU, so you could decide


122
00:06:22,516 --> 00:06:25,806
when and how to kick off that
work, and never be surprised


123
00:06:25,896 --> 00:06:29,546
by what the implementation
might do behind your back.


124
00:06:29,546 --> 00:06:32,296
And, last but not least, we
knew it had to be highly,


125
00:06:32,296 --> 00:06:35,426
highly optimized for
the A7 CPU behavior


126
00:06:35,946 --> 00:06:37,746
as this will become
key in a few moments.


127
00:06:38,086 --> 00:06:40,896
So how to think about Metal.


128
00:06:41,086 --> 00:06:43,116
Well, where does it fit?


129
00:06:43,266 --> 00:06:45,296
Well, let's say you have your
application here represented


130
00:06:45,296 --> 00:06:47,026
at the top of this
diagram in green,


131
00:06:47,416 --> 00:06:48,756
and you'd like to
talk to the GPU.


132
00:06:49,456 --> 00:06:53,026
Well, Apple provides a wide
variety of APIs to do just that,


133
00:06:53,686 --> 00:06:56,266
but they come at different
levels of abstraction,


134
00:06:56,516 --> 00:06:58,466
different levels of
conceptual distance


135
00:06:58,496 --> 00:07:00,046
between you and the GPU.


136
00:07:00,846 --> 00:07:04,196
So at a high level, you have
awesome APIs like SceneKit


137
00:07:04,196 --> 00:07:07,206
and SpriteKit that give high
level services for scene graphs


138
00:07:07,206 --> 00:07:09,896
for 2D and 3D animations,
and they're great.


139
00:07:10,166 --> 00:07:13,786
They provide a lot of services,
but they are relatively far


140
00:07:13,886 --> 00:07:15,596
from the GPU in terms
of abstraction.


141
00:07:16,816 --> 00:07:19,206
And then, of course, we have
our 2D graphics and imaging APIs


142
00:07:19,206 --> 00:07:22,916
such as Core Animation, Core
Image, and Core Graphics,


143
00:07:23,346 --> 00:07:25,006
and these, too, provide
a lot of services.


144
00:07:25,236 --> 00:07:27,296
And if this is the type
of operation you're doing,


145
00:07:27,896 --> 00:07:30,856
these are perfect APIs for you.


146
00:07:30,856 --> 00:07:33,816
And, as always, we have the
standards-based 3D graphics


147
00:07:33,816 --> 00:07:35,446
approach with OpenGL ES.


148
00:07:36,796 --> 00:07:38,466
But when we wanted to
do something better,


149
00:07:38,466 --> 00:07:42,076
and to give you high
efficiency GPU access


150
00:07:42,376 --> 00:07:44,126
at the thinnest possible
API layer,


151
00:07:44,446 --> 00:07:46,046
that's where Metal comes in.


152
00:07:47,016 --> 00:07:51,036
So how do we do this?


153
00:07:51,036 --> 00:07:52,396
Well, first thing we wanted


154
00:07:52,396 --> 00:07:55,316
to understand is how
most modern games try


155
00:07:55,316 --> 00:07:57,786
to manage their CPU
and GPU workloads.


156
00:07:58,216 --> 00:08:00,606
So most games will
target a frame rate.


157
00:08:00,966 --> 00:08:02,756
Oftentimes, it could
be 60 frames a second,


158
00:08:03,416 --> 00:08:04,266
sometimes at 30.


159
00:08:04,396 --> 00:08:06,666
In this example, we're using
30, which works out to be


160
00:08:06,666 --> 00:08:09,796
about 33.3 milliseconds
per frame.


161
00:08:11,096 --> 00:08:13,576
Now on this timeline, you can
see how most games would try


162
00:08:13,576 --> 00:08:16,136
to optimize for this
type of timeline.


163
00:08:16,606 --> 00:08:21,866
They'll try to balance the
amount of CPU work and the type


164
00:08:21,866 --> 00:08:25,286
of GPU work to fill the entire
frame, but they'll do so offset.


165
00:08:25,356 --> 00:08:27,316
So the CPU will be working
and generating commands


166
00:08:27,316 --> 00:08:30,336
for one frame, and the GPU will
then consume those commands


167
00:08:30,336 --> 00:08:32,956
in the next frame, and
while the CPU is doing that,


168
00:08:33,285 --> 00:08:37,885
the GPU is busily working on the
previous frame, and you lay this


169
00:08:37,885 --> 00:08:40,385
out on a timeline, and you
can see how you get relatively


170
00:08:40,385 --> 00:08:41,576
perfect parallelism.


171
00:08:42,046 --> 00:08:45,936
Well, let's look at one frame
in particular, and you'll notice


172
00:08:45,936 --> 00:08:49,716
in this example we're assuming
a completely balanced frame


173
00:08:50,206 --> 00:08:55,016
where the CPU and the GPU are
occupying all of the time.


174
00:08:55,196 --> 00:08:58,176
Now, unfortunately, real life
is not quite so balanced,


175
00:08:58,546 --> 00:09:01,756
and oftentimes you'll find
that the CPU can take more time


176
00:09:01,896 --> 00:09:05,596
to generate these commands than
the GPU does to consume them,


177
00:09:06,046 --> 00:09:10,316
and this is unfortunate because
it often leaves the GPU idle.


178
00:09:10,646 --> 00:09:13,246
So you're not even using the
system to its fullest capacity,


179
00:09:13,676 --> 00:09:14,836
and if you were, it would be


180
00:09:14,836 --> 00:09:16,836
like having a 50
percent faster GPU,


181
00:09:17,056 --> 00:09:18,056
but it's just sitting
there dark.


182
00:09:18,056 --> 00:09:22,086
So you say to yourself, "Well,
I'd like to fix this problem.


183
00:09:22,086 --> 00:09:25,646
I'm just going to give more work
to the GPU", and, unfortunately,


184
00:09:25,646 --> 00:09:28,506
what you'll find is that to give
more work to the GPU you have


185
00:09:28,506 --> 00:09:30,516
to first spin up
more work on the CPU.


186
00:09:31,306 --> 00:09:33,186
And if you were already bound by
the amount of work you could do


187
00:09:33,186 --> 00:09:35,926
on the CPU, this pushes out
your frame time even further.


188
00:09:35,926 --> 00:09:38,566
Now we're below our 30
frames per second target.


189
00:09:39,696 --> 00:09:42,476
And to add insult to
injury, the GPU is still idle


190
00:09:42,956 --> 00:09:45,006
because now our frame
time is actually longer,


191
00:09:45,206 --> 00:09:46,746
and the GPU can't
fill that work either.


192
00:09:47,256 --> 00:09:51,476
So to understand what's
happening here, it's helpful


193
00:09:51,476 --> 00:09:54,216
to realize that the CPU
workload is actually split


194
00:09:54,216 --> 00:09:55,136
into two parts.


195
00:09:56,226 --> 00:09:58,576
You have the applications
workload (what you guys are


196
00:09:58,576 --> 00:10:01,376
providing) and then you have
all the implementation work


197
00:10:01,376 --> 00:10:01,976
for the GPU API itself.


198
00:10:02,366 --> 00:10:06,216
So whenever you make a
GPU programming call,


199
00:10:07,026 --> 00:10:08,406
we're going to have to translate


200
00:10:08,406 --> 00:10:09,936
that in the way I
described earlier.


201
00:10:11,176 --> 00:10:14,586
Well, it's this GPU
programming API time on the CPU


202
00:10:14,586 --> 00:10:16,186
that we're focused
on with Metal,


203
00:10:16,916 --> 00:10:19,936
and Metal dramatically
reduces this time


204
00:10:21,076 --> 00:10:22,136
down to a bare minimum.


205
00:10:23,236 --> 00:10:25,166
Now in this example,
we've actually freed


206
00:10:25,166 --> 00:10:27,176
up additional CPU time.


207
00:10:27,176 --> 00:10:28,526
Now it's the CPU that's idle,


208
00:10:28,816 --> 00:10:31,216
and our frame time has
become limited by the GPU,


209
00:10:31,376 --> 00:10:33,776
and we're actually beating our
30 frames per second target.


210
00:10:34,256 --> 00:10:35,996
So if that was your goal,
you can now Render faster


211
00:10:35,996 --> 00:10:39,166
than 30 frames per second,
but you have another option.


212
00:10:39,756 --> 00:10:42,976
You can actually use that
CPU time to improve your game


213
00:10:42,976 --> 00:10:43,826
and make it even better.


214
00:10:44,396 --> 00:10:49,246
You could add more physics,
or more AI in, or other types


215
00:10:49,306 --> 00:10:51,386
of workloads to your
application.


216
00:10:52,196 --> 00:10:54,146
We have a little bit of
CPU idle time here left.


217
00:10:55,016 --> 00:10:56,586
We can actually choose
to go back


218
00:10:56,586 --> 00:10:58,586
to our 30 frames
per second target,


219
00:10:59,216 --> 00:11:01,806
and add even more draw calls
with Metal providing you


220
00:11:01,806 --> 00:11:03,816
up to a 10x increase
in efficiency,


221
00:11:04,296 --> 00:11:06,836
and you can either draw
more things with the GPU,


222
00:11:06,966 --> 00:11:09,376
or maybe just draw them in
a much more flexible manner


223
00:11:09,846 --> 00:11:11,216
so you can get more
visual variety.


224
00:11:12,266 --> 00:11:13,746
So that's what we're
trying to do with Metal.


225
00:11:15,946 --> 00:11:19,466
Now why is this GPU programming
so expensive on the CPU?


226
00:11:19,466 --> 00:11:21,356
To understand what we did
with Metal, it's helpful


227
00:11:21,356 --> 00:11:24,426
to take a deeper look here, too,
and there are 3 main reasons.


228
00:11:25,546 --> 00:11:28,646
First, you have what's
called state validation.


229
00:11:29,336 --> 00:11:32,216
Now some people think state
validation is just having the


230
00:11:32,216 --> 00:11:34,976
implementation verify that
you're calling the API


231
00:11:34,976 --> 00:11:37,016
in the right way and
that's certainly true,


232
00:11:37,946 --> 00:11:41,166
but it also involves encoding
the state from the API


233
00:11:41,786 --> 00:11:45,456
to the hardware and translating
it and oftentimes looking


234
00:11:45,456 --> 00:11:46,806
at different aspects
of the state


235
00:11:46,806 --> 00:11:49,176
and different state objects in
the API and figuring out how


236
00:11:49,176 --> 00:11:50,726
to combine them into a way


237
00:11:50,726 --> 00:11:52,396
that the hardware's
going to understand.


238
00:11:52,726 --> 00:11:53,586
This can be expensive,


239
00:11:54,336 --> 00:11:56,026
and perhaps the most
expensive version


240
00:11:56,026 --> 00:11:58,286
of this is actually the
shader compilation itself.


241
00:11:59,436 --> 00:12:01,796
So you take your source
code shaders for your vertex


242
00:12:01,796 --> 00:12:04,326
and pixel shaders, and they
have to be compiled at run time


243
00:12:04,696 --> 00:12:07,546
and to generate the
GPU's machine code.


244
00:12:08,126 --> 00:12:12,366
What's worse is that in a lot
of APIs before Metal, the state


245
00:12:13,216 --> 00:12:16,176
and the shader code was not
described in the API in a way


246
00:12:16,176 --> 00:12:19,096
that really mapped well to what
the hardware actually was going


247
00:12:19,096 --> 00:12:19,726
to expect.


248
00:12:20,356 --> 00:12:22,816
And so when you change
certain states, you could find


249
00:12:22,816 --> 00:12:24,876
that behind the scenes,
we actually had to go back


250
00:12:24,876 --> 00:12:27,756
and recompile your shaders,
causing even more CPU work.


251
00:12:29,096 --> 00:12:32,566
And, last, they're sending
the work to the GPU itself,


252
00:12:32,826 --> 00:12:33,836
and this can be expensive.


253
00:12:34,236 --> 00:12:36,996
The resources, the memory, the
textures have to all be managed


254
00:12:36,996 --> 00:12:39,016
and given to the GPU in
the way it can expect.


255
00:12:39,016 --> 00:12:42,516
And because those first
two items are so expensive,


256
00:12:42,806 --> 00:12:45,186
we often have encouraged you
with previous APIs to batch


257
00:12:45,186 --> 00:12:46,406
up lots of work to send --


258
00:12:46,766 --> 00:12:48,756
to try to amortize
these expensive costs


259
00:12:49,096 --> 00:12:50,646
across a fewer number
of draw calls


260
00:12:50,646 --> 00:12:52,926
and just give more per
draw call to the GPU.


261
00:12:53,566 --> 00:12:57,526
And, of course, this tends to
work at the cost of flexibility


262
00:12:57,526 --> 00:12:59,686
to you, the developer, and
to your game designers,


263
00:13:00,346 --> 00:13:03,456
but it also increases latency
because now the GPU has more


264
00:13:03,456 --> 00:13:05,266
to work on in a single chunk.


265
00:13:06,336 --> 00:13:08,976
So we wanted to fix
these 3 key areas


266
00:13:09,416 --> 00:13:11,346
of expense for GPU programming.


267
00:13:12,296 --> 00:13:16,576
To do that, we thought
about 3 times, 3 occurrences


268
00:13:16,906 --> 00:13:18,976
in the application life
cycle to focus in on.


269
00:13:19,456 --> 00:13:20,756
There's the application
build time,


270
00:13:21,616 --> 00:13:23,616
there's when you're loading
the content for your game,


271
00:13:23,916 --> 00:13:25,206
and then when, there's
when you draw.


272
00:13:25,686 --> 00:13:27,196
And they occur at
different frequencies.


273
00:13:28,396 --> 00:13:30,496
So, first, application
build time.


274
00:13:31,156 --> 00:13:32,556
This basically never occurs.


275
00:13:33,806 --> 00:13:35,636
I see some surprised
look on your faces


276
00:13:35,636 --> 00:13:38,066
because as developers you think
you're building your application


277
00:13:38,186 --> 00:13:40,606
all the time, and that's true.


278
00:13:41,126 --> 00:13:43,556
But from your customer's
perspective,


279
00:13:43,556 --> 00:13:45,196
from the people using
your application,


280
00:13:45,446 --> 00:13:46,396
they never see this.


281
00:13:46,396 --> 00:13:49,126
So if we can move things to
occur at application build time,


282
00:13:49,586 --> 00:13:51,046
you've just eliminated
this expense


283
00:13:51,296 --> 00:13:52,396
from the experience
of your game.


284
00:13:52,856 --> 00:13:55,096
And then you have
content loading time,


285
00:13:55,416 --> 00:13:58,456
which is relatively rare, again,
from a user's perspective.


286
00:13:58,456 --> 00:14:01,156
They're only going to load a
level a few times per play.


287
00:14:01,656 --> 00:14:04,696
You have draw calls,
on the other hand...


288
00:14:04,996 --> 00:14:07,106
you're going to do this
thousands (ideally thousands)


289
00:14:07,106 --> 00:14:07,956
of times per frame.


290
00:14:08,746 --> 00:14:10,986
And before Metal, unfortunately,


291
00:14:10,986 --> 00:14:13,676
all three of those
expensive bits of operations


292
00:14:13,706 --> 00:14:18,226
for the CPU occurred in this
last time, at draw call time.


293
00:14:18,946 --> 00:14:21,076
Thousands of time per
frame, or more likely,


294
00:14:21,246 --> 00:14:22,416
a few hundred times per frame


295
00:14:22,416 --> 00:14:24,076
because that's all
the CPU could absorb.


296
00:14:25,296 --> 00:14:28,946
Now with metal, we've moved
these expensive operations


297
00:14:28,946 --> 00:14:30,736
to occur much more optimally.


298
00:14:31,416 --> 00:14:34,556
So you put shader compilation to
occur at application build time,


299
00:14:34,716 --> 00:14:37,586
again, out of the field of view
for the users of your game.


300
00:14:38,326 --> 00:14:41,826
And content loading, that's
when we do state validation.


301
00:14:42,336 --> 00:14:43,896
This, again, is relatively rare.


302
00:14:44,656 --> 00:14:46,056
This means the only
thing we have to do


303
00:14:46,056 --> 00:14:47,946
at draw call time is the
most important thing to do


304
00:14:47,946 --> 00:14:50,606
at draw call time, which is
kick off the work on the GPU.


305
00:14:51,086 --> 00:14:56,156
So that's the how and the why
we created Metal, and now I want


306
00:14:56,156 --> 00:14:59,636
to take a deeper look at the API
itself, and we'll take a look


307
00:14:59,636 --> 00:15:02,496
at some of the conceptual
framework for the API starting


308
00:15:03,256 --> 00:15:04,466
with the objects in the API.


309
00:15:05,166 --> 00:15:08,286
So the first object to talk


310
00:15:08,286 --> 00:15:10,096
about in the Metal
API is the device,


311
00:15:10,846 --> 00:15:13,196
and this essentially is just
an abstraction on the GPU,


312
00:15:13,196 --> 00:15:13,796
the thing that's going


313
00:15:13,796 --> 00:15:16,476
to consume your rendering
and compute commands.


314
00:15:17,936 --> 00:15:20,286
Those commands will be
stored and submitted


315
00:15:20,286 --> 00:15:21,816
to the GPU in a command queue.


316
00:15:22,566 --> 00:15:25,036
Now the command queue, its
job is simply to decide


317
00:15:25,036 --> 00:15:27,906
and let you specify in what
order those commands will


318
00:15:27,906 --> 00:15:28,846
be executed.


319
00:15:30,156 --> 00:15:31,826
Those commands themselves
are stored


320
00:15:31,826 --> 00:15:33,206
in what's called
a command buffer.


321
00:15:34,216 --> 00:15:36,966
This stores the translated
hardware commands ready


322
00:15:36,966 --> 00:15:38,866
for consumption by the GPU.


323
00:15:39,296 --> 00:15:44,536
And the command encoder is the
API object that's responsible


324
00:15:44,536 --> 00:15:45,596
for that translation.


325
00:15:45,886 --> 00:15:49,166
So when you create a command
encoder, and you use it to write


326
00:15:49,166 --> 00:15:51,936
into a command buffer,
that's the translation.


327
00:15:53,946 --> 00:15:56,566
The state of the API is
described in a series


328
00:15:56,566 --> 00:15:58,566
of state objects for things


329
00:15:58,566 --> 00:16:01,446
like how your framebuffers are
set up, how you're blending


330
00:16:01,446 --> 00:16:03,376
and your depth and your
sampling state is set up.


331
00:16:03,456 --> 00:16:06,546
These are all described to the
API in objects, which we'll talk


332
00:16:06,546 --> 00:16:08,806
about in all three
sessions today.


333
00:16:10,006 --> 00:16:12,276
And you have the
code: your shaders,


334
00:16:12,276 --> 00:16:13,876
your vertex, your pixel shaders.


335
00:16:14,156 --> 00:16:21,346
And, last, you have your data:
your resources, your memory,


336
00:16:21,346 --> 00:16:23,966
the textures and
the vertex buffers


337
00:16:23,966 --> 00:16:24,986
and the shader constants.


338
00:16:25,016 --> 00:16:26,936
Those are all stored
in resources.


339
00:16:27,306 --> 00:16:28,926
So let's take a look
next at kind


340
00:16:28,926 --> 00:16:31,286
of how these objects
fit together by walking


341
00:16:31,286 --> 00:16:33,416
through a bit about how
we construct the objects


342
00:16:33,546 --> 00:16:35,806
in the API.


343
00:16:36,026 --> 00:16:38,126
So first thing you
have is the device.


344
00:16:39,216 --> 00:16:41,336
So like we said, this is
the device in the GPU,


345
00:16:41,336 --> 00:16:42,716
the thing that's going
to consume your commands.


346
00:16:42,916 --> 00:16:44,816
And from that you
create the command queue,


347
00:16:45,066 --> 00:16:47,216
and typically you'll have one
of these in your application.


348
00:16:48,076 --> 00:16:49,976
From the command
queue, you'll create one


349
00:16:49,976 --> 00:16:52,566
or more command buffers to use
to store the hardware commands,


350
00:16:52,766 --> 00:16:54,076
and you'll write
into those commands


351
00:16:54,336 --> 00:16:56,446
with a Render Command
Encoder (in this example).


352
00:16:58,386 --> 00:17:00,556
Now, in order to
generate those commands,


353
00:17:00,556 --> 00:17:01,976
you need to specify
some information


354
00:17:01,976 --> 00:17:02,966
of the Render Command Encoder,


355
00:17:03,296 --> 00:17:06,016
and you do that by
attaching various objects


356
00:17:06,126 --> 00:17:07,756
to the Render Command
Encoder before you use it.


357
00:17:08,296 --> 00:17:10,876
So, for instance, you
specify your data buffers


358
00:17:11,096 --> 00:17:13,356
and your textures
that you want to use


359
00:17:13,526 --> 00:17:15,036
to do this rendering operation.


360
00:17:15,826 --> 00:17:18,425
Now you'll notice in this
diagram we also show something


361
00:17:18,425 --> 00:17:19,776
called the texture descriptor,


362
00:17:20,156 --> 00:17:23,046
and the texture descriptor is
used to create the textures.


363
00:17:23,185 --> 00:17:25,306
It specifies all of the
necessary state used


364
00:17:25,306 --> 00:17:26,566
for texture object creation.


365
00:17:28,236 --> 00:17:30,926
Probably the biggest state
object is the Render Pipeline


366
00:17:30,926 --> 00:17:34,126
state, and it, too, is
constructed from a descriptor,


367
00:17:34,756 --> 00:17:36,826
and the descriptor in
this case describes all


368
00:17:36,826 --> 00:17:38,926
of the 3D rendering
state you need


369
00:17:38,926 --> 00:17:41,606
to create a single
Render Pipeline.


370
00:17:42,566 --> 00:17:45,686
Similarly, you have descriptors
for your depth and stencil state


371
00:17:45,686 --> 00:17:50,376
that you use to create those
objects, and we have a series


372
00:17:50,376 --> 00:17:53,996
of state for describing
the render pass itself;


373
00:17:54,186 --> 00:17:55,886
how you're going to
output your rendering.


374
00:17:56,536 --> 00:17:59,156
Now the reason we split the
state up into descriptors


375
00:17:59,486 --> 00:18:02,826
and state objects is because
once you've specified what all


376
00:18:02,826 --> 00:18:06,366
these state combinations should
be, Metal bakes all of these


377
00:18:06,406 --> 00:18:09,126
into a small number of
state objects, that --


378
00:18:09,126 --> 00:18:11,136
Now, all of the state
has been translated,


379
00:18:11,136 --> 00:18:12,446
all the shaders have
been compiled,


380
00:18:12,916 --> 00:18:14,476
and the system is ready to go.


381
00:18:14,816 --> 00:18:17,356
You can now issue your draw
calls incredibly quickly


382
00:18:17,516 --> 00:18:19,676
without worrying that the
implementation's going to have


383
00:18:19,676 --> 00:18:22,376
to come around and do some late
binding translation or figure


384
00:18:22,376 --> 00:18:24,356
out if what you're trying to
do is valid in the first place.


385
00:18:24,686 --> 00:18:26,756
A couple more notes.


386
00:18:27,326 --> 00:18:30,566
So, the source resources (the
textures and buffers here),


387
00:18:30,566 --> 00:18:31,876
you can change those as you go.


388
00:18:32,386 --> 00:18:34,356
The render targets
themselves are fixed


389
00:18:34,426 --> 00:18:35,966
for a given render
command decoder.


390
00:18:36,466 --> 00:18:41,866
We'll talk more about why that's
important in just a moment.


391
00:18:41,866 --> 00:18:43,516
Now inverting this
diagram a little bit,


392
00:18:43,516 --> 00:18:45,736
we can see how objects
are actually sending data


393
00:18:45,736 --> 00:18:46,396
to the device.


394
00:18:46,686 --> 00:18:48,606
You can have one or more
Render Command Encoders,


395
00:18:48,806 --> 00:18:51,756
one for each rendering pass,
writing into the command buffer.


396
00:18:53,056 --> 00:18:55,566
You can also interleave
different types of commands.


397
00:18:55,666 --> 00:18:57,496
In this case, I'm
using compute commands


398
00:18:57,526 --> 00:19:00,206
in the middle of my frame.


399
00:19:01,176 --> 00:19:05,066
And, as we said, Metal supports
efficient multi-threading.


400
00:19:05,066 --> 00:19:07,526
You can actually construct
multiple command buffers


401
00:19:07,526 --> 00:19:09,486
in parallel using
multiple threads.


402
00:19:09,486 --> 00:19:12,036
So let's talk a little bit more


403
00:19:12,036 --> 00:19:13,676
about the command
submission model itself


404
00:19:13,766 --> 00:19:14,886
to understand how this works.


405
00:19:15,626 --> 00:19:18,566
Just as we've said, command
encoders will encode the API


406
00:19:18,566 --> 00:19:20,976
of your, uh, it will
encode the API commands


407
00:19:20,976 --> 00:19:21,906
into the hardware state,


408
00:19:22,456 --> 00:19:24,176
and then they'll
store those commands


409
00:19:24,276 --> 00:19:25,606
in the hardware command buffer.


410
00:19:27,176 --> 00:19:29,116
There are 3 types
of command encoders


411
00:19:29,116 --> 00:19:32,476
for generating 3 different
types of work on the GPU.


412
00:19:32,926 --> 00:19:35,976
We have Render, Compute,
and Blit, and we'll talk


413
00:19:35,976 --> 00:19:37,016
about each of them in detail.


414
00:19:37,766 --> 00:19:38,886
But important to realize here is


415
00:19:38,886 --> 00:19:41,026
that you can interleave these
different types of operations


416
00:19:41,336 --> 00:19:42,606
in a single command buffer


417
00:19:42,866 --> 00:19:45,066
and within a single
frame very efficiently.


418
00:19:45,586 --> 00:19:48,416
And this is because the command
encoders themselves encapsulate


419
00:19:48,416 --> 00:19:50,526
all the state necessary
so that we don't have


420
00:19:50,566 --> 00:19:53,676
to do implicit transitions
between different types


421
00:19:53,676 --> 00:19:56,836
of operations and behind the
scenes we don't have to try


422
00:19:56,836 --> 00:19:58,876
to save and restore all
of the state necessary


423
00:19:58,876 --> 00:19:59,976
for using these different
types of operations.


424
00:20:00,106 --> 00:20:02,656
It's all under your
explicit control.


425
00:20:03,156 --> 00:20:07,876
The command buffers themselves
are incredibly lightweight,


426
00:20:07,876 --> 00:20:10,336
and most applications are
going to create a large number


427
00:20:10,336 --> 00:20:11,526
of these in their frames.


428
00:20:11,876 --> 00:20:15,846
And you control exactly when


429
00:20:15,846 --> 00:20:19,606
and how these get
submitted to the GPU.


430
00:20:19,796 --> 00:20:20,896
Once they've been submitted,


431
00:20:21,166 --> 00:20:22,966
Metal signals you
(the application)


432
00:20:23,466 --> 00:20:25,606
when those command buffers
have completed their execution


433
00:20:25,606 --> 00:20:26,086
on the GPU.


434
00:20:26,086 --> 00:20:29,216
And so you get very fine grain
control and clear notifications


435
00:20:29,216 --> 00:20:31,226
about exactly what's happening
at any one point in time.


436
00:20:32,556 --> 00:20:35,736
And very important to realize
is that these command encoders,


437
00:20:35,976 --> 00:20:38,686
they're not just sending some
work off that later is going


438
00:20:38,686 --> 00:20:40,796
to be consumed by the CPU.


439
00:20:40,926 --> 00:20:43,206
They're actually generating
these commands immediately.


440
00:20:43,206 --> 00:20:44,866
There's no deferred
state validation.


441
00:20:45,246 --> 00:20:47,266
It's essentially like
they're making a direct call


442
00:20:47,436 --> 00:20:48,336
to the GPU driver.


443
00:20:48,856 --> 00:20:52,346
Now as I mentioned, you can
also multi-thread this command


444
00:20:52,346 --> 00:20:54,706
encoding to get even
more performance.


445
00:20:55,736 --> 00:20:57,666
Multiple command buffers
can be encoded in parallel


446
00:20:57,666 --> 00:21:01,036
across threads, and, yet,
you get to decide exactly


447
00:21:01,036 --> 00:21:02,816
when those commands
will be executed.


448
00:21:02,816 --> 00:21:03,876
So you have the control
to both --


449
00:21:03,876 --> 00:21:06,686
to split out the order in which
the commands will be constructed


450
00:21:07,406 --> 00:21:08,956
while maintaining
the order you wish


451
00:21:09,036 --> 00:21:10,446
for their execution on the GPU.


452
00:21:11,076 --> 00:21:13,386
And we've provided an incredibly
efficient implementation


453
00:21:13,386 --> 00:21:15,506
with no automic locks, to
make sure you can get scalable


454
00:21:15,506 --> 00:21:17,666
performance across CPU cores.


455
00:21:18,266 --> 00:21:19,686
So that's the commands.


456
00:21:20,366 --> 00:21:22,756
Next we're going to take a look
at the resources, the memory,


457
00:21:22,876 --> 00:21:25,606
the objects in the API
for specifying data.


458
00:21:26,266 --> 00:21:30,286
Now we've designed the resource
model in Metal explicitly


459
00:21:30,286 --> 00:21:33,066
for the A7's unified
memory system.


460
00:21:33,916 --> 00:21:37,466
This means that the CPU and the
GPU are sharing the exact same


461
00:21:37,466 --> 00:21:39,656
memory for exchanging data.


462
00:21:40,136 --> 00:21:41,456
There's no implicit copies.


463
00:21:41,456 --> 00:21:44,306
We're not coming in behind
the scenes and taking the data


464
00:21:44,306 --> 00:21:47,426
and moving it somewhere
else for the GPU to see it.


465
00:21:47,926 --> 00:21:51,396
We also manage the CPU and
GPU cache coherency for you.


466
00:21:51,646 --> 00:21:53,336
You don't have to worry
about flushing caches


467
00:21:53,336 --> 00:21:54,636
between the CPU and the GPU.


468
00:21:54,926 --> 00:21:57,476
You simply have to make sure
that you schedule your work


469
00:21:57,476 --> 00:22:00,926
to occur such that the GPU
and the CPU are not writing


470
00:22:00,926 --> 00:22:02,546
to the same chunk of
memory at the same time,


471
00:22:02,676 --> 00:22:05,016
but you don't have to do
anything to manage caches.


472
00:22:05,656 --> 00:22:08,556
And by you taking on
this responsibility


473
00:22:08,556 --> 00:22:10,826
for synchronization
between the GPU and the CPU,


474
00:22:10,976 --> 00:22:13,106
we can offer you
significantly higher performance


475
00:22:13,526 --> 00:22:15,416
because we're not implicitly
synchronizing things


476
00:22:15,416 --> 00:22:17,436
that didn't necessarily
need to be synchronized.


477
00:22:19,376 --> 00:22:21,616
There are 2 different
types of resources for you


478
00:22:22,166 --> 00:22:23,766
to use in your application.


479
00:22:24,396 --> 00:22:28,096
The first is textures, which
are simply formatted image data


480
00:22:28,096 --> 00:22:31,986
that you use for
rendering for source data


481
00:22:32,316 --> 00:22:35,226
or for rendering destinations,
and there are data buffers


482
00:22:35,346 --> 00:22:38,666
which are essentially
unformatted ranges of memory.


483
00:22:38,756 --> 00:22:40,266
You can think of them
like just a bag of bytes


484
00:22:40,266 --> 00:22:42,336
to store your vertex data,
your shader constants,


485
00:22:42,336 --> 00:22:45,086
any output memory from
your GPU workloads.


486
00:22:45,086 --> 00:22:49,206
The important thing to remember
with Metal is that the structure


487
00:22:49,736 --> 00:22:52,386
of these resources is immutable.


488
00:22:52,386 --> 00:22:53,276
You cannot change it.


489
00:22:53,276 --> 00:22:56,706
Once you create a texture of
a given size or given level


490
00:22:56,706 --> 00:22:59,226
or a given format, it's baked,


491
00:22:59,716 --> 00:23:02,796
and this lets us avoid
costly resource validation


492
00:23:03,516 --> 00:23:05,416
that would previously have
taken place in other APIs


493
00:23:05,416 --> 00:23:07,646
where we'd have to
figure out, "hey,


494
00:23:07,646 --> 00:23:10,056
now that you've changed how
a texture is structured,


495
00:23:10,416 --> 00:23:11,236
is it still valid?


496
00:23:11,236 --> 00:23:13,296
Can we still use it as
a rendering destination?


497
00:23:13,296 --> 00:23:14,546
Is it still mipmap complete?"


498
00:23:14,546 --> 00:23:15,506
We don't have to do any of that


499
00:23:15,506 --> 00:23:17,196
because you've specified
it all up front.


500
00:23:18,326 --> 00:23:20,846
If you want to use two different
textures with - Ah, sorry.


501
00:23:20,846 --> 00:23:23,666
If you want to use two different
formats for your texture,


502
00:23:23,666 --> 00:23:25,436
you simply create two
different textures,


503
00:23:25,766 --> 00:23:27,096
and this is actually
much more efficient.


504
00:23:27,096 --> 00:23:29,936
We can rapidly switch
between these on, ah,


505
00:23:30,036 --> 00:23:31,136
in the Metal implementation.


506
00:23:31,656 --> 00:23:35,676
Of course, you can still change
the contents of your textures


507
00:23:35,766 --> 00:23:37,746
for your buffers,
and to do that,


508
00:23:38,026 --> 00:23:39,146
we provide several methods.


509
00:23:39,976 --> 00:23:41,826
So you can update
data buffers directly.


510
00:23:42,006 --> 00:23:44,276
You simply get a pointer
to the underlying storage.


511
00:23:44,636 --> 00:23:47,106
There's no lock API needed
because, again, this is running


512
00:23:47,106 --> 00:23:50,306
on a unified memory
system, and for textures,


513
00:23:50,556 --> 00:23:52,816
we have what's called an
implementation private storage.


514
00:23:53,116 --> 00:23:54,676
Now this doesn't mean that
we're copying the data


515
00:23:54,676 --> 00:23:55,886
and moving it somewhere else.


516
00:23:56,126 --> 00:23:58,396
This simply means that we
will reformat the textures


517
00:23:58,396 --> 00:24:00,476
for efficient rendering
on the GPU,


518
00:24:00,476 --> 00:24:03,556
but we provide some
blazing fast update routines


519
00:24:03,626 --> 00:24:05,016
in Metal to do that.


520
00:24:05,446 --> 00:24:09,426
If you need an asynchronous
update routine for your textures


521
00:24:09,426 --> 00:24:11,556
or your buffers, you can do
this via the Blit Encoder,


522
00:24:11,836 --> 00:24:14,156
and we'll talk in just a
moment about how that works.


523
00:24:16,726 --> 00:24:19,146
Now one other thing you can do
with resources, and textures


524
00:24:19,146 --> 00:24:21,326
in particular, is you can
actually share the underlying


525
00:24:21,326 --> 00:24:23,266
storage across multiple textures


526
00:24:23,636 --> 00:24:26,826
and reinterpret the pixel
data differently in each one.


527
00:24:27,456 --> 00:24:29,026
So, for instance, if
you have a texture


528
00:24:29,446 --> 00:24:32,916
that is using a single
32-bit integer pixel format,


529
00:24:33,466 --> 00:24:36,096
you can have another texture
which is using a 4-component


530
00:24:36,466 --> 00:24:41,096
"RGBA eights" pixel format, and
they can actually be pointing


531
00:24:41,096 --> 00:24:42,336
at the same underlying storage


532
00:24:42,556 --> 00:24:45,206
because the pixel size is
the same between the two.


533
00:24:46,496 --> 00:24:48,556
And you can also share
the texture storage


534
00:24:48,966 --> 00:24:49,666
with data buffers.


535
00:24:50,126 --> 00:24:53,506
This will allow you direct
access to the underlying storage


536
00:24:53,506 --> 00:24:55,556
with the CPU and to use
the underlying storage


537
00:24:55,556 --> 00:24:58,806
as a data buffer, and we
simply assume row-lineal --


538
00:24:58,986 --> 00:25:02,336
row-linear pixel order
in this particular case.


539
00:25:02,496 --> 00:25:04,046
OK. Those are resources.


540
00:25:04,266 --> 00:25:05,286
Now I'm going to talk briefly


541
00:25:05,446 --> 00:25:08,146
about the command encoders
themselves, and as I mentioned,


542
00:25:08,226 --> 00:25:10,316
there are 3 basic
command encoder types.


543
00:25:11,146 --> 00:25:15,336
You have your Render, Compute,
and Blit command encoders,


544
00:25:15,496 --> 00:25:18,066
and I'm going to talk about
each of these in sequence.


545
00:25:18,776 --> 00:25:21,196
So first off: the
Render Command Encoder.


546
00:25:21,196 --> 00:25:24,576
Now the Render Command Encoder,
you can think about this as all


547
00:25:24,576 --> 00:25:25,996
of the hardware commands
necessary


548
00:25:26,136 --> 00:25:29,496
for generating a single
rendering pass, and by pass,


549
00:25:29,496 --> 00:25:32,516
I mean all of the rendering
to one framebuffer object,


550
00:25:32,516 --> 00:25:33,696
one set of render targets.


551
00:25:34,226 --> 00:25:37,656
If you want to change to
another set of render targets,


552
00:25:37,736 --> 00:25:38,846
to another framebuffer,


553
00:25:39,386 --> 00:25:41,626
you simply use another
Render Command Encoder,


554
00:25:42,216 --> 00:25:45,096
and this is all the state
for specifying the vertex


555
00:25:45,096 --> 00:25:47,896
and fragment stages
of the 3D pipeline.


556
00:25:48,416 --> 00:25:51,366
It allows you to interleave
these state changes,


557
00:25:51,486 --> 00:25:53,966
the resources, and any
draw calls necessary


558
00:25:53,966 --> 00:25:56,356
for constructing your
pass, but, critically,


559
00:25:56,726 --> 00:25:59,016
there's no draw time
compilation.


560
00:25:59,926 --> 00:26:01,706
You get to control --
the app developer --


561
00:26:01,736 --> 00:26:04,796
exactly when and how all
of the state compilation


562
00:26:04,796 --> 00:26:06,846
and expensive validation
actually takes place.


563
00:26:08,166 --> 00:26:11,296
And you do that with a series
of API calls and state objects,


564
00:26:11,466 --> 00:26:12,906
and I'll show you just
a few of those here.


565
00:26:13,576 --> 00:26:15,966
So as we talked about, you have
your depth and stencil objects,


566
00:26:16,546 --> 00:26:18,176
sampler objects,
the Render Pipeline,


567
00:26:18,476 --> 00:26:20,436
and they describe
various aspects


568
00:26:20,516 --> 00:26:23,596
of the 3D rendering state.


569
00:26:25,146 --> 00:26:28,246
Basically, almost everything
fits in the Render Pipeline


570
00:26:28,526 --> 00:26:30,246
where you -- that's where
you specify your shaders,


571
00:26:30,776 --> 00:26:33,386
your blend states, all, how
your vertex data is actually


572
00:26:33,386 --> 00:26:36,736
specified, and all of that can
fit into these state objects.


573
00:26:36,936 --> 00:26:40,166
Now important to
realize in Metal is


574
00:26:40,166 --> 00:26:42,406
that not all state
objects are created equal.


575
00:26:42,716 --> 00:26:45,176
Some of the states are actually
very expensive to change,


576
00:26:45,356 --> 00:26:47,986
and for these, we've put them
in what's called immutable


577
00:26:47,986 --> 00:26:49,466
or unchangeable state objects,


578
00:26:50,456 --> 00:26:51,826
and you can't change
these states


579
00:26:51,876 --> 00:26:53,376
after you've created
the objects.


580
00:26:53,696 --> 00:26:56,616
These are the types of things
that affect expensive operations


581
00:26:56,616 --> 00:26:58,686
or cause recompilation to occur.


582
00:26:59,346 --> 00:27:01,986
So things like the shaders
themselves we don't want


583
00:27:02,036 --> 00:27:03,096
to be -- you don't
want us to be --


584
00:27:03,096 --> 00:27:04,466
recompiling them all the time.


585
00:27:04,856 --> 00:27:07,436
So once you specified
those into a state object,


586
00:27:07,866 --> 00:27:08,506
you can't change them.


587
00:27:09,226 --> 00:27:10,926
But other things, like
the viewport and scissor,


588
00:27:10,926 --> 00:27:13,366
are actually really cheap
to specify and really cheap


589
00:27:13,366 --> 00:27:15,636
to change, and so
those remain flexible.


590
00:27:16,146 --> 00:27:21,106
Now I talked a few times
about how the API was designed


591
00:27:21,386 --> 00:27:25,766
with the A7 in mind, and one of
the key ways you can see this is


592
00:27:25,766 --> 00:27:28,166
in how we handle
framebuffer loads and stores.


593
00:27:28,166 --> 00:27:34,346
Now the A7 GPU is a tile-based
deferred-mode renderer.


594
00:27:34,346 --> 00:27:37,716
Now I'm not going to go into
the details of what this means,


595
00:27:37,716 --> 00:27:39,786
but one important
piece of that is


596
00:27:39,786 --> 00:27:45,366
that it has what's called a tile
cache, and a tile cache is used


597
00:27:45,366 --> 00:27:47,466
at the beginning and end
of each rendering pass


598
00:27:47,766 --> 00:27:50,806
to load the contents of
the previous framebuffer


599
00:27:50,806 --> 00:27:53,726
or to write it up to memory.


600
00:27:53,726 --> 00:27:57,366
And so you need some explicit
control over this tile cache


601
00:27:57,366 --> 00:27:58,586
to get optimal performance


602
00:27:58,586 --> 00:28:00,486
and to make sure you're
not doing needless reads


603
00:28:00,486 --> 00:28:01,206
and writes to memory.


604
00:28:01,886 --> 00:28:04,846
In Metal, you can specify
load and store actions


605
00:28:04,846 --> 00:28:07,556
on the framebuffer to make
this incredibly efficient,


606
00:28:07,556 --> 00:28:09,216
and I'll show you an example
of how that works here.


607
00:28:10,626 --> 00:28:13,546
So let's say, as an example,
this is before Metal,


608
00:28:14,016 --> 00:28:17,296
you had one frame
for which you wanted


609
00:28:17,296 --> 00:28:20,376
to do two rendering passes, and
in this example, you're going


610
00:28:20,376 --> 00:28:22,436
to take the color framebuffer,
you're going to have to redo it


611
00:28:22,436 --> 00:28:23,636
at the beginning,
you're going to write it


612
00:28:23,636 --> 00:28:25,846
out at one pass through, and
then you're going to do the same


613
00:28:25,846 --> 00:28:26,666
for the second pass...


614
00:28:26,896 --> 00:28:29,716
and you'll probably want to
use a depth buffer as well.


615
00:28:30,166 --> 00:28:33,916
So before Metal, you can
actually see here there was


616
00:28:33,916 --> 00:28:35,526
quite a lot of memory
bandwidth taking place


617
00:28:35,526 --> 00:28:36,506
across these passes.


618
00:28:36,826 --> 00:28:40,086
You end up with 2 reads and 2
writes for each of the color


619
00:28:40,086 --> 00:28:42,576
and the depth buffer, which
is a lot of memory traffic.


620
00:28:43,916 --> 00:28:46,876
Well, with Metal, we
actually let you specify


621
00:28:47,166 --> 00:28:49,746
which of those reads and writes
you actually need to occur.


622
00:28:50,206 --> 00:28:51,856
So, for instance,
you can say, well,


623
00:28:51,856 --> 00:28:54,496
I'm going to render every
pixel of my frame anyway.


624
00:28:54,496 --> 00:28:56,846
There's no point in loading
the tile cache at the beginning


625
00:28:56,846 --> 00:28:58,696
of the frame, and I can
save that bandwidth.


626
00:28:59,466 --> 00:29:01,736
And if you're going to write
out the pass and then read it


627
00:29:01,736 --> 00:29:04,526
in the second pass, you probably
would need to actually do that,


628
00:29:05,186 --> 00:29:07,266
but when you look at the depth
buffer, you can see a lot


629
00:29:07,266 --> 00:29:08,646
of unnecessary reads and writes.


630
00:29:08,926 --> 00:29:11,876
And so you can specify that we
should probably just clear the


631
00:29:11,876 --> 00:29:13,356
depth buffer at the
beginning of the frame


632
00:29:13,356 --> 00:29:15,206
because you're not going to
need its previous contents,


633
00:29:15,596 --> 00:29:17,296
and you don't need to write
it out at the end of the frame


634
00:29:17,296 --> 00:29:18,796
because you're not using
it in a second pass.


635
00:29:18,796 --> 00:29:21,216
You're simply going to clear it
again, and then you don't need


636
00:29:21,216 --> 00:29:22,126
to write it out there either,


637
00:29:22,586 --> 00:29:24,846
and we can get some
dramatic reductions


638
00:29:24,876 --> 00:29:26,526
in memory traffic
as a result of this.


639
00:29:27,786 --> 00:29:30,456
You can reduce the overall
amount of reads and writes


640
00:29:30,646 --> 00:29:32,376
to a fraction of
what it was before,


641
00:29:32,546 --> 00:29:34,296
and you can gain
significant performance


642
00:29:34,296 --> 00:29:35,066
for your application.


643
00:29:35,856 --> 00:29:37,336
So this is just one of the ways


644
00:29:37,336 --> 00:29:39,506
in which we've designed
Metal with the A7 in mind.


645
00:29:39,916 --> 00:29:42,566
Alright. That's rendering.


646
00:29:42,566 --> 00:29:45,376
Now we're going to look at
the next area we introduced


647
00:29:45,376 --> 00:29:48,416
with Metal, a functionality,
which is Compute.


648
00:29:49,156 --> 00:29:51,086
So we're not going to spend
a lot of time today talking


649
00:29:51,086 --> 00:29:53,856
about general-purpose
data-parallel computation


650
00:29:53,856 --> 00:29:56,076
in the GPU, but for those of
you who have done this type


651
00:29:56,076 --> 00:29:57,826
of operation before,
you're going to find


652
00:29:57,826 --> 00:29:59,976
that this is a very familiar
run-time and memory model.


653
00:30:00,066 --> 00:30:03,266
It uses the same
textures and data buffers


654
00:30:03,266 --> 00:30:07,496
from the Metal graphics APIs,
has the same basic kinds


655
00:30:07,496 --> 00:30:10,096
of memory hierarchy,
barriers, memories,


656
00:30:10,096 --> 00:30:11,156
and load stores you might find


657
00:30:11,156 --> 00:30:13,036
in other data parallel
programming APIs,


658
00:30:13,516 --> 00:30:14,486
and you can configure


659
00:30:14,486 --> 00:30:16,696
and specify exactly
how the work groups


660
00:30:16,696 --> 00:30:19,236
for your Compute operations
will be executed by the GPU.


661
00:30:21,116 --> 00:30:24,716
Probably more important
to realize with Metal is


662
00:30:24,716 --> 00:30:27,256
that it is -- the Compute
operations are fully integrated


663
00:30:27,256 --> 00:30:27,746
with graphics.


664
00:30:28,856 --> 00:30:32,106
This means you get a unified
API, a single shading language,


665
00:30:32,286 --> 00:30:34,446
and a single set of
fantastic developer tools


666
00:30:34,446 --> 00:30:37,046
for both graphics and
compute operations on the GPU.


667
00:30:37,046 --> 00:30:40,316
And probably more
important for performance,


668
00:30:40,756 --> 00:30:43,266
we can efficiently
interleave these operations


669
00:30:43,436 --> 00:30:45,116
between Compute, Rendering,


670
00:30:45,506 --> 00:30:49,536
and data [inaudible]
operations and Blits.


671
00:30:49,666 --> 00:30:53,416
Similarly, to graphics, there's
no execution time compilation


672
00:30:53,566 --> 00:30:54,716
with the Compute operations.


673
00:30:55,036 --> 00:30:59,116
You control exactly when these
expensive compilation activities


674
00:30:59,116 --> 00:30:59,546
will occur.


675
00:31:00,056 --> 00:31:02,316
And probably a little
bit different


676
00:31:02,316 --> 00:31:06,156
from how graphics looks in
Metal, there's very little state


677
00:31:06,206 --> 00:31:07,556
in the Compute Command Encoder.


678
00:31:07,976 --> 00:31:09,546
There's some state
for specifying exactly


679
00:31:09,546 --> 00:31:10,996
which Compute kernels
you're going to be using


680
00:31:10,996 --> 00:31:12,516
and how you're going to
configure work groups,


681
00:31:12,516 --> 00:31:13,476
and that's pretty much it.


682
00:31:13,966 --> 00:31:15,586
And that's it.


683
00:31:15,746 --> 00:31:17,456
If the Compute Command
Encoder seems simple,


684
00:31:17,486 --> 00:31:19,856
that's because it is,
and that brings us


685
00:31:19,856 --> 00:31:22,666
to our last command encoder,
the Blit Command Encoder,


686
00:31:23,226 --> 00:31:25,976
and this is what you're going to
use for asynchronous data copies


687
00:31:26,006 --> 00:31:29,216
between resources on the GPU,
and this can happen in parallel


688
00:31:29,216 --> 00:31:31,376
with your compute and
your graphics operations.


689
00:31:32,216 --> 00:31:34,606
You can use this to upload
textures, to copy data


690
00:31:34,606 --> 00:31:38,846
between textures and buffers,
or to generate your mipmaps.


691
00:31:39,596 --> 00:31:42,756
You can also update the data
buffers themselves, again,


692
00:31:42,756 --> 00:31:45,016
copying to and from
textures or other buffers,


693
00:31:45,196 --> 00:31:47,716
and you can actually fill
the buffers themselves


694
00:31:47,716 --> 00:31:49,896
with constant values in
Blit Command Encoder.


695
00:31:50,266 --> 00:31:53,956
Alright. That's it for the
API high level summary.


696
00:31:53,956 --> 00:31:55,416
Now I'm going to
take a quick tour


697
00:31:55,626 --> 00:31:56,746
through the shading
language itself.


698
00:32:00,506 --> 00:32:04,216
Alright. So the Metal
shading language is a unified


699
00:32:04,216 --> 00:32:04,986
shading language.


700
00:32:05,306 --> 00:32:07,926
This means using the same
language, syntax, constructs,


701
00:32:07,926 --> 00:32:10,096
tool chains for both graphics
and compute processing,


702
00:32:10,696 --> 00:32:14,636
and it's based on C++11,
essentially a static subset


703
00:32:14,856 --> 00:32:19,186
of this language, and it's
built out of LLVM and clang,


704
00:32:19,366 --> 00:32:21,316
which means you get
incredibly high performance


705
00:32:21,316 --> 00:32:24,696
and incredibly high quality
code generation for the GPU.


706
00:32:25,006 --> 00:32:28,336
The only thing we've really
had to do was add some syntax


707
00:32:28,336 --> 00:32:30,356
for describing certain
hardware functionality


708
00:32:30,356 --> 00:32:32,116
such as how you're going
to control texture sampling


709
00:32:32,116 --> 00:32:34,806
and rasterization, and then
we've added a few things


710
00:32:34,806 --> 00:32:37,086
to make shader authoring
much more convenient,


711
00:32:37,086 --> 00:32:39,426
such as function overloading
and basic template support.


712
00:32:40,456 --> 00:32:40,966
But that's it.


713
00:32:41,046 --> 00:32:44,666
If you know C++, you understand
the Metal shading language.


714
00:32:44,956 --> 00:32:50,076
As I said, we added just a
few data types and some syntax


715
00:32:50,076 --> 00:32:52,306
for handling graphics and
compute functionality.


716
00:32:52,466 --> 00:32:55,296
Some basic data types you'll
probably find very useful


717
00:32:55,296 --> 00:32:56,926
such as scaler, vector,
and matrix types,


718
00:32:57,516 --> 00:33:01,106
and then we've used what's
called the attribute syntax


719
00:33:01,136 --> 00:33:04,926
to specify a lot of the
connection between the Metal API


720
00:33:04,926 --> 00:33:06,276
and the Metal shading language.


721
00:33:06,496 --> 00:33:08,886
So things like, how do you get
data in and out of your shaders?


722
00:33:08,886 --> 00:33:11,076
You specify those with
function arguments


723
00:33:11,076 --> 00:33:13,506
and you use the attribute
syntax to actually identify


724
00:33:13,876 --> 00:33:15,656
which textures and
buffers you want to use.


725
00:33:16,606 --> 00:33:19,186
Or how to implement programmable
blending in your shaders?


726
00:33:19,186 --> 00:33:20,536
You can actually use
the attribute syntax


727
00:33:20,536 --> 00:33:23,856
to specify pixels you want
to read from the framebuffer.


728
00:33:24,236 --> 00:33:27,706
The Metal shading language
itself is incredibly easy


729
00:33:27,706 --> 00:33:28,236
to use.


730
00:33:28,436 --> 00:33:30,936
You can put multiple shaders
in a single source code file,


731
00:33:31,126 --> 00:33:34,276
and then we will build those
source code files with Xcode,


732
00:33:34,276 --> 00:33:35,976
when you're building
your application,


733
00:33:36,376 --> 00:33:38,416
into Metal library files.


734
00:33:38,916 --> 00:33:41,586
And the Metal library files
are essentially just an archive


735
00:33:41,586 --> 00:33:42,576
of your Metal shaders.


736
00:33:43,596 --> 00:33:44,686
With the Metal run-time APIs,


737
00:33:44,686 --> 00:33:46,526
you can actually
load a Metal library,


738
00:33:46,596 --> 00:33:48,396
and then you can
finalize the compilation


739
00:33:48,396 --> 00:33:51,016
into this device's
machine-specific code.


740
00:33:52,036 --> 00:33:54,716
We also include an
awesome standard library


741
00:33:54,716 --> 00:33:58,336
of very commonly-used and
incredibly performant graphics


742
00:33:58,336 --> 00:33:59,166
and compute functions.


743
00:33:59,556 --> 00:34:02,866
One other thing to realize


744
00:34:02,866 --> 00:34:04,826
about the Metal shading language
is you need to get data in


745
00:34:04,826 --> 00:34:05,786
and out of your shaders.


746
00:34:05,986 --> 00:34:09,076
So we specify -- use a
method called argument tables


747
00:34:09,106 --> 00:34:11,755
to let you specify which
arguments, which resources,


748
00:34:12,036 --> 00:34:14,136
and which data needs
to move between the API


749
00:34:14,136 --> 00:34:15,795
and the shading environment.


750
00:34:17,735 --> 00:34:20,536
So each command encoder will
include what's called an


751
00:34:20,536 --> 00:34:22,656
argument table, and
this is simply a list


752
00:34:22,656 --> 00:34:25,235
of the resources you want to use
in the API that you want to read


753
00:34:25,235 --> 00:34:28,386
and access and write in
the shader themselves.


754
00:34:28,755 --> 00:34:34,466
There's one table for each type
of resource, and then the shader


755
00:34:34,686 --> 00:34:38,036
and the host code will simply
use an index into that table


756
00:34:38,036 --> 00:34:39,255
to refer to the same resource.


757
00:34:39,255 --> 00:34:40,025
Let's see an example.


758
00:34:40,196 --> 00:34:44,746
So on the right here, I simply
have a representation of one


759
00:34:44,746 --> 00:34:45,746
of the command encoders;


760
00:34:45,746 --> 00:34:47,795
it could be Render Command
Encoder, for instance.


761
00:34:48,426 --> 00:34:51,136
And you have a table
in the command encoder


762
00:34:51,136 --> 00:34:53,226
that describes the resources.


763
00:34:53,295 --> 00:34:55,846
So you have a list of all
of the textures you want


764
00:34:55,846 --> 00:34:57,206
to use in your shaders.


765
00:34:59,256 --> 00:35:01,806
Similar tables exist for
buffers and samplers.


766
00:35:02,196 --> 00:35:03,366
Now I've simplified
this a little bit


767
00:35:03,366 --> 00:35:05,666
because there's actually one of
these sets of tables for each


768
00:35:05,666 --> 00:35:07,356
of the vertex and
fragment shader stages.


769
00:35:07,596 --> 00:35:09,116
Well, let's take a look
at an example shader.


770
00:35:09,266 --> 00:35:13,236
So in this, we have a vertex
shader and a fragment shader


771
00:35:13,416 --> 00:35:14,596
in Metal shader code
on the left,


772
00:35:14,596 --> 00:35:16,336
and you'll see it
looks quite familiar.


773
00:35:16,666 --> 00:35:18,666
You'll get a lot more
information about how this works


774
00:35:18,666 --> 00:35:20,576
in the next session, but
you can get a good sense


775
00:35:20,576 --> 00:35:21,776
of how this works
just from looking


776
00:35:21,776 --> 00:35:25,226
at the code itself right here.


777
00:35:25,226 --> 00:35:28,946
So in the fragment shader, we're
simply referring to texture


778
00:35:29,056 --> 00:35:32,096
at index 1 to identify that we
would like to use the texture


779
00:35:32,096 --> 00:35:34,906
that we set up in the
command encoder to read


780
00:35:35,226 --> 00:35:36,176
in this fragment shader.


781
00:35:36,996 --> 00:35:39,906
And, similarly, in the vertex
shader, we can do the same thing


782
00:35:39,906 --> 00:35:42,706
with the buffers, and use those
as inputs to the vertex shader


783
00:35:42,746 --> 00:35:45,356
and refer back to the
argument index table


784
00:35:45,516 --> 00:35:46,286
in the command encoder.


785
00:35:46,726 --> 00:35:49,126
So you set up the command
encoder's argument tables


786
00:35:49,336 --> 00:35:53,036
with the API and simply
refer to those resources


787
00:35:53,466 --> 00:35:55,396
in your shaders using
the attribute syntax


788
00:35:55,616 --> 00:35:56,946
in the function arguments
themselves.


789
00:35:57,306 --> 00:35:58,666
And that's it.


790
00:35:59,206 --> 00:36:01,406
The shading language is
actually pretty simple,


791
00:36:01,476 --> 00:36:03,156
and we think you're
going to really like it.


792
00:36:03,566 --> 00:36:04,936
And, next, I'm going
to talk about how


793
00:36:04,936 --> 00:36:07,126
to build your Metal
application using our awesome


794
00:36:07,126 --> 00:36:07,966
developer tools.


795
00:36:08,296 --> 00:36:09,826
And probably the most important


796
00:36:09,826 --> 00:36:14,566
of those developer tools is
the Metal shader complier.


797
00:36:15,726 --> 00:36:17,626
Now, ideally, you don't
even know this exists


798
00:36:17,896 --> 00:36:20,426
because we're simply going to
build your shader sources just


799
00:36:20,426 --> 00:36:22,396
like we build the rest of
your application sources


800
00:36:22,516 --> 00:36:23,626
at application build time.


801
00:36:24,006 --> 00:36:26,756
There's no need for you to
separate out your shaders


802
00:36:26,756 --> 00:36:28,096
and specify them at run time.


803
00:36:28,386 --> 00:36:29,736
You can actually ship them


804
00:36:30,026 --> 00:36:32,826
with your application already
having been precompiled.


805
00:36:32,826 --> 00:36:34,656
So there's no source
code that needs to go


806
00:36:34,656 --> 00:36:36,836
with your application
for your shaders.


807
00:36:37,176 --> 00:36:39,406
But probably more important from
the developer's point of view is


808
00:36:39,406 --> 00:36:41,966
that we can actually give you
errors and warnings and guidance


809
00:36:41,966 --> 00:36:44,116
about your shaders at
the time you're building


810
00:36:44,116 --> 00:36:44,886
your application.


811
00:36:45,106 --> 00:36:45,956
So you don't have to wait


812
00:36:46,336 --> 00:36:49,186
until your customers are
running your game to find


813
00:36:49,186 --> 00:36:50,746
out that you have an error
in one of your shaders.


814
00:36:51,586 --> 00:36:52,136
This is awesome.


815
00:36:53,436 --> 00:36:56,346
Those shaders will then be
compiled into Metal libraries


816
00:36:56,346 --> 00:36:59,456
by Xcode and then
compiled to device code


817
00:36:59,796 --> 00:37:02,046
at the time you create your
state objects themselves.


818
00:37:02,416 --> 00:37:04,366
So, again, there's no
draw time compilation,


819
00:37:05,276 --> 00:37:07,466
and we will cache
this compilation --


820
00:37:07,546 --> 00:37:09,876
this final device
machine-specific compilation --


821
00:37:10,676 --> 00:37:11,386
on the device.


822
00:37:12,196 --> 00:37:15,106
So we won't be continually doing
even this last translation step.


823
00:37:16,396 --> 00:37:19,436
Now for those of you who like
to specify your source code


824
00:37:19,676 --> 00:37:21,556
at run time -- perhaps
you're constructing strings


825
00:37:21,556 --> 00:37:24,226
on the fly -- we do provide a
runtime shader compiler as well.


826
00:37:24,466 --> 00:37:26,196
This can also be really
useful for debugging.


827
00:37:27,586 --> 00:37:29,876
It, too, has no draw time
compilation overhead.


828
00:37:30,046 --> 00:37:32,376
It operates just like
the precompile shaders,


829
00:37:32,916 --> 00:37:34,366
but for best performance,


830
00:37:34,366 --> 00:37:36,656
we generally recommend you
use the offline compiler.


831
00:37:36,826 --> 00:37:38,266
We can give you the
most information


832
00:37:38,266 --> 00:37:40,646
to help you build the
best possible shaders


833
00:37:40,646 --> 00:37:41,316
if you do it this way.


834
00:37:41,946 --> 00:37:43,066
Well, let's see what
this would look like.


835
00:37:43,346 --> 00:37:44,416
So here's an example.


836
00:37:44,416 --> 00:37:47,656
You're building your application
in Xcode, and you have a series


837
00:37:48,086 --> 00:37:52,226
of Metal shader files, and
these shader files are passed


838
00:37:52,436 --> 00:37:54,696
to the Metal shader
compiler, the compiler


839
00:37:54,696 --> 00:37:55,806
of the Metal shader sources,


840
00:37:55,916 --> 00:37:57,286
at the time you build
your application,


841
00:37:57,536 --> 00:37:59,826
and a Metal library
file is generated.


842
00:38:00,656 --> 00:38:04,536
That Metal library file will be
packaged with your application,


843
00:38:04,986 --> 00:38:08,036
and so then when you deploy
your application to a device,


844
00:38:09,486 --> 00:38:11,436
that Metal library file
goes along for the ride.


845
00:38:11,996 --> 00:38:13,306
Then at application run time


846
00:38:13,306 --> 00:38:15,866
when you're constructing
your pipeline objects,


847
00:38:16,506 --> 00:38:19,456
you specify which vertex
and fragment shaders you'd


848
00:38:19,456 --> 00:38:21,656
like to use from
that Metal library.


849
00:38:22,466 --> 00:38:25,056
Metal implementation then will
look up those shaders to see


850
00:38:25,056 --> 00:38:27,616
if it's already cached them
once before, and if not,


851
00:38:27,676 --> 00:38:30,206
will compile them to the
final machine device code


852
00:38:31,226 --> 00:38:32,176
and send it to the GPU.


853
00:38:32,666 --> 00:38:34,516
And that's it.


854
00:38:34,946 --> 00:38:37,296
Most of this happens
automatically for you, but,


855
00:38:37,296 --> 00:38:41,786
critically, exactly
when you want it to.


856
00:38:41,996 --> 00:38:45,016
Now if you've used our OpenGL
ES debugging tools in Xcode,


857
00:38:45,016 --> 00:38:46,366
you're going to feel
right at home.


858
00:38:46,366 --> 00:38:49,606
We have an awesome set of
GPU programming, debugging


859
00:38:49,606 --> 00:38:52,026
and profiling tools integrated
right into Xcode, and I'm going


860
00:38:52,526 --> 00:38:53,976
to give you a quick
tour of those now.


861
00:38:54,496 --> 00:38:58,976
So this is an example
application inside Xcode


862
00:38:58,976 --> 00:39:01,776
where you get visual
debugging tools built right


863
00:39:01,776 --> 00:39:03,406
into the same environment
you're using


864
00:39:03,406 --> 00:39:04,686
to build the rest
of your application.


865
00:39:05,046 --> 00:39:07,866
On the left-hand side, we
have what's called the Frame


866
00:39:07,866 --> 00:39:11,516
Navigator, which shows you
exactly which Metal API calls,


867
00:39:11,516 --> 00:39:15,046
draw calls you issued and
in what order they occurred,


868
00:39:15,506 --> 00:39:17,956
and in the middle, you
have the Frame Navigator --


869
00:39:17,956 --> 00:39:19,116
or, sorry, the Framebuffer View,


870
00:39:19,116 --> 00:39:22,416
where you can actually see the
results of those draw calls


871
00:39:22,416 --> 00:39:25,026
and state operations
happening live


872
00:39:25,026 --> 00:39:26,226
as you're constructing
your frame.


873
00:39:27,616 --> 00:39:30,106
We also have the Resource
View, where you can see all


874
00:39:30,106 --> 00:39:33,196
of the textures, resources, data
buffers, everything you're using


875
00:39:33,196 --> 00:39:36,096
to construct your frame,
inspect them, and make sure


876
00:39:36,096 --> 00:39:37,796
that they're exactly
as you set them up.


877
00:39:38,226 --> 00:39:42,696
And at the bottom, you can
see the Metal State Inspector,


878
00:39:42,696 --> 00:39:44,926
where you can see all
of the API state and all


879
00:39:44,926 --> 00:39:47,996
of the important bits of
control and information you have


880
00:39:48,386 --> 00:39:49,816
about your application in Metal.


881
00:39:51,786 --> 00:39:55,516
We also provide some
really fantastic profiling


882
00:39:55,516 --> 00:39:56,666
and performance tools.


883
00:39:57,216 --> 00:39:58,326
So in this example,


884
00:39:58,606 --> 00:39:59,976
we're showing the Metal
Performance Report.


885
00:40:01,056 --> 00:40:02,906
You can see things
like your frame rate


886
00:40:03,246 --> 00:40:04,536
or how much you're
using the GPU.


887
00:40:04,566 --> 00:40:09,236
You can also see exactly which
shaders are the most expensive,


888
00:40:09,816 --> 00:40:12,496
and you can see how much time
they're taking per frame.


889
00:40:13,206 --> 00:40:13,906
This is awesome.


890
00:40:14,286 --> 00:40:16,886
You can also see for
each of those shaders


891
00:40:17,256 --> 00:40:20,086
in milliseconds how much time
they're taking as a whole,


892
00:40:20,646 --> 00:40:22,166
but you can get a feel


893
00:40:22,166 --> 00:40:25,716
for exactly what are the most
expensive lines of each shader.


894
00:40:25,716 --> 00:40:28,376
So if you want to really
optimize your shaders,


895
00:40:28,576 --> 00:40:31,366
you can find out which line
is taking up the most time


896
00:40:31,726 --> 00:40:33,926
and focus in on that,
and this is all built


897
00:40:33,926 --> 00:40:36,186
for you right inside of Xcode.


898
00:40:37,516 --> 00:40:42,386
[ Applause ]


899
00:40:42,886 --> 00:40:43,196
Yeah, excellent.


900
00:40:43,196 --> 00:40:44,246
I'm glad you like it.


901
00:40:45,126 --> 00:40:47,436
So you can also build
your shaders,


902
00:40:47,436 --> 00:40:48,646
as we said, inside Xcode.


903
00:40:48,646 --> 00:40:49,876
You can actually
edit them as well,


904
00:40:49,876 --> 00:40:51,976
and you get all the
familiar syntax highlighting


905
00:40:52,246 --> 00:40:55,636
and code completion, and you
get warnings and errors right


906
00:40:55,636 --> 00:40:56,786
for you inside of Xcode, too.


907
00:40:57,346 --> 00:40:58,746
We think this is
really fantastic.


908
00:40:58,746 --> 00:41:00,286
It makes writing and editing


909
00:41:00,286 --> 00:41:02,706
and profiling shaders a
much more natural part


910
00:41:02,706 --> 00:41:04,516
of the process, and
we've designed Metal


911
00:41:04,516 --> 00:41:06,806
to work seamlessly
in this environment.


912
00:41:07,436 --> 00:41:11,046
Alright. So that's the developer
tools, the API concepts,


913
00:41:11,046 --> 00:41:12,276
and the shading language.


914
00:41:12,516 --> 00:41:15,656
Now as you heard in the keynote,
we've been working, with Metal,


915
00:41:16,366 --> 00:41:18,866
with some leading
game engine providers


916
00:41:19,416 --> 00:41:23,256
such as Electronic Arts,
Epic, Unity, and Crytek,


917
00:41:23,726 --> 00:41:25,766
and we've been amazed at what
they've been able to create


918
00:41:25,926 --> 00:41:27,256
in just a short amount of time.


919
00:41:27,796 --> 00:41:29,496
Well, I'm very happy
to introduce


920
00:41:29,496 --> 00:41:31,536
up on stage Sean
Tracey from Crytek,


921
00:41:31,756 --> 00:41:33,746
who's going to show you what
they've been able to create


922
00:41:33,746 --> 00:41:35,356
with Metal in just a few weeks.


923
00:41:35,866 --> 00:41:36,076
Sean?


924
00:41:37,456 --> 00:41:41,496
>> Thanks a lot, Jeremy.


925
00:41:42,256 --> 00:41:44,176
Crytek is known for
pushing the boundaries


926
00:41:44,806 --> 00:41:47,526
and for developing
blockbuster hits such as Crysis


927
00:41:47,526 --> 00:41:48,676
and Ryse for the consoles.


928
00:41:49,326 --> 00:41:51,716
The CRYENGINE is going
mobile, and our latest game,


929
00:41:51,716 --> 00:41:53,986
The Collectables, was recently
released on the App Store.


930
00:41:54,366 --> 00:41:57,186
Integrating Metal into the
game gives us opportunities


931
00:41:57,186 --> 00:41:58,286
that we didn't have before,


932
00:41:58,346 --> 00:42:01,026
and the added performance
changes the way we think


933
00:42:01,026 --> 00:42:03,646
about creating mobile game
play and mobile game content.


934
00:42:04,346 --> 00:42:05,976
Today, we'd like to show
you the next version


935
00:42:05,976 --> 00:42:08,446
of The Collectables, and to
show you how we used Metal


936
00:42:08,566 --> 00:42:09,546
to change the game.


937
00:42:10,016 --> 00:42:10,586
Let's take a look.


938
00:42:11,346 --> 00:42:15,446
In The Collectables, you control
a renegade team of mercenaries,


939
00:42:15,446 --> 00:42:17,476
and today we're on a daring
hit-and-run mission to take


940
00:42:17,476 --> 00:42:18,536
out the enemy artillery.


941
00:42:19,506 --> 00:42:21,966
As you can see, the environment
is incredibly dynamic


942
00:42:22,456 --> 00:42:26,836
and very rich with wind
affecting vegetation and more.


943
00:42:28,046 --> 00:42:29,726
Looks like the enemy's
set up a roadblock ahead.


944
00:42:29,726 --> 00:42:31,546
Let's take out these
jeeps with our RPGs.


945
00:42:31,596 --> 00:42:36,046
Booyah! So you can
see this level


946
00:42:36,046 --> 00:42:38,296
of cinematic destruction
simply wasn't possible


947
00:42:38,296 --> 00:42:39,086
on mobile before.


948
00:42:39,376 --> 00:42:40,296
When those jeeps explode,


949
00:42:40,296 --> 00:42:43,006
there's over 168 unique
pieces that come flying off.


950
00:42:43,316 --> 00:42:45,436
The tires, windshield,
engine block, and more.


951
00:42:46,666 --> 00:42:47,626
Using the power of Metal,


952
00:42:47,626 --> 00:42:50,356
we're able to leverage
our Geom cache technology


953
00:42:50,666 --> 00:42:52,086
as seen in Ryse on console.


954
00:42:53,026 --> 00:42:56,306
And there it is, our
objective, the enemy artillery.


955
00:42:56,656 --> 00:42:57,736
It's a pretty big mother.


956
00:42:57,736 --> 00:42:58,666
So let's go ahead and call


957
00:42:58,666 --> 00:43:00,656
in our AC130 gunship
for air support.


958
00:43:01,516 --> 00:43:07,466
[ Background Sounds ]


959
00:43:07,966 --> 00:43:11,176
Geom cache uses cache-based
animation


960
00:43:11,466 --> 00:43:14,806
to realize extremely complex
simulation and special effects,


961
00:43:15,046 --> 00:43:16,926
as you saw in the
destruction of those buildings.


962
00:43:18,376 --> 00:43:20,666
So as our players make their
way to their next objective,


963
00:43:21,006 --> 00:43:22,426
let's take a look
at another example


964
00:43:22,426 --> 00:43:26,146
of how we can use this power
to turn the environment


965
00:43:26,296 --> 00:43:27,836
into a weapon for our player.


966
00:43:28,346 --> 00:43:30,296
Sounds like trouble ahead.


967
00:43:30,856 --> 00:43:31,786
Yeah, they've got a tank.


968
00:43:31,786 --> 00:43:33,676
Alright. We need to block off
that road and get out of here,


969
00:43:33,676 --> 00:43:34,506
or we're going to be toast.


970
00:43:34,826 --> 00:43:35,826
Let's try taking
out the chimney.


971
00:43:41,596 --> 00:43:43,726
And that's how you stop a
tank in The Collectables.


972
00:43:44,386 --> 00:43:45,836
When that building
and chimney come down,


973
00:43:45,836 --> 00:43:48,216
there's over 4,000
draw calls on screen,


974
00:43:48,456 --> 00:43:50,676
4,000 draw calls -- on an iPad!


975
00:43:51,936 --> 00:43:54,796
Oh, they've got another tank
and, um, we're out of chimneys.


976
00:43:54,856 --> 00:43:56,036
So mission accomplished.


977
00:43:56,246 --> 00:43:56,836
Let's get out of here.


978
00:43:59,186 --> 00:44:00,616
As you can see, the
performance gained


979
00:44:00,616 --> 00:44:03,626
with Metal gives us a
tenfold performance increase


980
00:44:03,846 --> 00:44:07,676
that allows us to bring the
Crytek DNA alive on mobile.


981
00:44:08,266 --> 00:44:09,886
We look forward to seeing
you guys in the game.


982
00:44:10,326 --> 00:44:10,976
Thanks a lot.


983
00:44:11,516 --> 00:44:17,776
[ Applause ]


984
00:44:18,276 --> 00:44:18,576
>> Alright.


985
00:44:18,576 --> 00:44:19,206
Thanks, Sean.


986
00:44:19,866 --> 00:44:20,906
That's really amazing.


987
00:44:20,906 --> 00:44:23,776
So 4,000 draw calls
is a tenfold increase


988
00:44:24,096 --> 00:44:26,116
over what was previously
possible before Metal,


989
00:44:26,116 --> 00:44:28,606
and we're are truly, truly
excited to see it in action.


990
00:44:29,936 --> 00:44:31,166
Alright. So that's Metal.


991
00:44:31,456 --> 00:44:33,566
Metal is our new low overhead,


992
00:44:33,836 --> 00:44:37,546
high-performance GPU programming
API which can provide you


993
00:44:37,546 --> 00:44:40,316
with dramatic increase
in efficiency


994
00:44:40,316 --> 00:44:41,416
and performance for your game.


995
00:44:42,256 --> 00:44:46,356
We've designed it from
scratch to run like a dream


996
00:44:46,356 --> 00:44:49,756
on the A7 chip and
our iOS products.


997
00:44:50,346 --> 00:44:51,996
And we've streamlined
the feature set


998
00:44:51,996 --> 00:44:55,636
and the API footprint to focus
on the most modern GPU features,


999
00:44:55,766 --> 00:44:57,376
such as unified graphics
and compute,


1000
00:44:57,626 --> 00:45:00,746
and the most modern GPU
game programming techniques,


1001
00:45:01,016 --> 00:45:02,936
such that require
fine-grained control


1002
00:45:02,936 --> 00:45:04,666
and efficient multi-threading.


1003
00:45:05,396 --> 00:45:08,956
With support for precompiled
shaders and a fantastic set


1004
00:45:08,956 --> 00:45:11,546
of developer tools, we
believe you're going to be able


1005
00:45:11,546 --> 00:45:14,326
to use Metal to create
an entirely new class


1006
00:45:14,466 --> 00:45:16,716
of games for your customers.


1007
00:45:17,416 --> 00:45:19,226
We're really looking forward
to what you guys are going


1008
00:45:19,226 --> 00:45:20,736
to be able to create with Metal.


1009
00:45:20,876 --> 00:45:24,086
We think it's just a truly,
truly fantastic thing.


1010
00:45:24,606 --> 00:45:27,276
For more information
about Metal,


1011
00:45:27,776 --> 00:45:30,726
you can come see our
Evangelists, Filip and Allan,


1012
00:45:31,106 --> 00:45:33,916
and we have an amazing set
of documentation about Metal


1013
00:45:33,916 --> 00:45:35,306
on our developer
relations website.


1014
00:45:35,696 --> 00:45:37,826
You can also check out
the developer forums


1015
00:45:37,826 --> 00:45:40,726
where you can talk with folks
about Metal, and you can come


1016
00:45:41,026 --> 00:45:43,656
to the next two sessions which
we're going to go into Metal


1017
00:45:43,656 --> 00:45:45,286
in a much more level of detail.


1018
00:45:45,286 --> 00:45:48,386
So you can see how Metal
works in your application,


1019
00:45:48,386 --> 00:45:51,456
how to build your first Metal
application, how to build scenes


1020
00:45:51,456 --> 00:45:54,816
out of Metal and use
it to control the GPU,


1021
00:45:54,816 --> 00:45:56,626
how the Metal shading
language itself works,


1022
00:45:57,106 --> 00:45:58,546
and then we'll have
a second session


1023
00:45:58,676 --> 00:46:00,726
where we cover some
more advanced techniques


1024
00:46:01,026 --> 00:46:03,426
such as using multi-pass
rendering and Compute.


1025
00:46:04,306 --> 00:46:06,376
We're really looking forward
to what you're going to be able


1026
00:46:06,376 --> 00:46:07,956
to create with this API.


1027
00:46:07,956 --> 00:46:08,976
Thank you very much for coming.

