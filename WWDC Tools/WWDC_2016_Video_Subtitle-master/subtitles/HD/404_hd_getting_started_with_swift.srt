1
00:00:07,516 --> 00:00:18,516
[ Music ]


2
00:00:19,516 --> 00:00:22,566
[ Applause ]


3
00:00:23,066 --> 00:00:26,586
>> Hello, and welcome to
Getting Started with Swift.


4
00:00:26,586 --> 00:00:28,956
I'm Dave Addey, and together
with my colleagues Brian


5
00:00:28,956 --> 00:00:31,526
and Alex, I'd like to
give you a quick overview


6
00:00:31,526 --> 00:00:32,826
of the Swift Programming
Language.


7
00:00:33,836 --> 00:00:36,936
In the next 60 minutes you'll
learn enough about Swift 3


8
00:00:36,936 --> 00:00:38,926
to be able to read
Swift code and hopefully


9
00:00:38,926 --> 00:00:42,186
to start writing it, too.


10
00:00:42,446 --> 00:00:45,226
So let's start by taking a
look at some of the basics


11
00:00:45,286 --> 00:00:48,626
of the language, and here's
some code I wrote two years ago.


12
00:00:48,996 --> 00:00:51,196
I've written a constant,
indicated with let,


13
00:00:51,826 --> 00:00:54,016
it's called language,
and it's a string.


14
00:00:54,076 --> 00:00:57,416
And this colon in the middle,
you'll see this often in Swift,


15
00:00:57,596 --> 00:00:58,866
this means is of type.


16
00:00:59,206 --> 00:01:02,836
So language is of type string,
and I've just given it a value


17
00:01:02,836 --> 00:01:05,886
of Swift, using a string
literal in my code.


18
00:01:06,076 --> 00:01:06,856
Let's make a few more.


19
00:01:07,426 --> 00:01:09,526
Let's have an integer
called introduced.


20
00:01:09,636 --> 00:01:11,546
We'll that to 2014.


21
00:01:11,546 --> 00:01:13,196
And a Boolean called isAwesome.


22
00:01:13,546 --> 00:01:15,986
And we'll set that to true.


23
00:01:16,126 --> 00:01:19,276
Now, you might notice that none
of these values need to change.


24
00:01:19,566 --> 00:01:21,456
The language's name
isn't going to change,


25
00:01:21,706 --> 00:01:22,936
nor is the year it
was introduced.


26
00:01:23,816 --> 00:01:26,186
And two years on,
Swift is still awesome,


27
00:01:26,186 --> 00:01:28,166
so that can probably
be a constant as well.


28
00:01:29,046 --> 00:01:30,846
And this is the general
principle in Swift.


29
00:01:31,386 --> 00:01:32,786
If something doesn't
need to change,


30
00:01:32,976 --> 00:01:35,726
we declare it as a constant.


31
00:01:35,726 --> 00:01:37,876
Now, you might also
notice a naming trend here.


32
00:01:38,686 --> 00:01:41,656
Constants and variables tend to
be written as lower camel case,


33
00:01:42,076 --> 00:01:45,986
and types, such as String, Ints
and Bool, is upper camel case.


34
00:01:47,306 --> 00:01:48,876
Now, if we look at the
things on the right here,


35
00:01:49,406 --> 00:01:52,476
it's pretty obvious, actually,
that what I want is a string,


36
00:01:52,956 --> 00:01:54,306
an integer and a Boolean,


37
00:01:54,836 --> 00:01:58,586
and where this is the case
Swift can infer the type for us.


38
00:01:58,586 --> 00:02:00,346
We don't actually need
to write it ourselves.


39
00:02:00,956 --> 00:02:03,126
So you still get things
that are explicitly typed,


40
00:02:03,126 --> 00:02:04,906
but you don't have to
write as much code.


41
00:02:06,326 --> 00:02:07,746
So that's some constants.


42
00:02:08,015 --> 00:02:08,856
What about variables?


43
00:02:08,856 --> 00:02:10,606
Things do sometimes
need to change.


44
00:02:10,795 --> 00:02:12,576
So here's a variable
indicated with var,


45
00:02:12,936 --> 00:02:14,726
and it's for the
version of the language.


46
00:02:14,726 --> 00:02:15,526
This has changed.


47
00:02:16,116 --> 00:02:17,926
So let's bring it
up to date to 2016.


48
00:02:19,376 --> 00:02:21,456
Now, if I try to do
this for a constant,


49
00:02:22,036 --> 00:02:25,276
if I try to set isAwesome to
false, Swift would tell me


50
00:02:25,276 --> 00:02:27,166
that it was an error,
and quite right, too.


51
00:02:29,266 --> 00:02:31,636
So a common thing to want
to do in programming is


52
00:02:31,636 --> 00:02:33,196
to build strings
from other values.


53
00:02:33,736 --> 00:02:36,146
We could do this by
concatenating strings together,


54
00:02:36,146 --> 00:02:39,136
as shown here, but Swift
has a neater way to do this,


55
00:02:39,626 --> 00:02:42,216
known as string interpolation,
and this is how it looks.


56
00:02:42,606 --> 00:02:46,096
And we can put strings and other
values inside a larger string


57
00:02:46,426 --> 00:02:49,296
by wrapping them in parentheses
preceded by a backslash.


58
00:02:49,596 --> 00:02:51,756
Here we're making the
message, Hello WWDC.


59
00:02:53,246 --> 00:02:54,986
We're not just limited
to strings, however.


60
00:02:54,986 --> 00:02:56,426
We can add other values as well,


61
00:02:56,426 --> 00:02:58,456
such as integers here
putting the year in.


62
00:02:59,146 --> 00:03:01,696
And we could even add
expressions as well.


63
00:03:01,696 --> 00:03:03,536
We can add year +
1 for some code


64
00:03:03,536 --> 00:03:05,176
that would work for
a future year.


65
00:03:06,376 --> 00:03:09,426
Now, strings in Swift are
fully Unicode friendly.


66
00:03:09,866 --> 00:03:12,416
They're just as happy
with ASCII as they are


67
00:03:12,416 --> 00:03:13,876
with dog, cows or with flags.


68
00:03:15,036 --> 00:03:18,086
And the same also
goes for any constants


69
00:03:18,086 --> 00:03:19,106
and variables you create.


70
00:03:19,106 --> 00:03:21,646
You can use pretty much
any character in the name


71
00:03:21,646 --> 00:03:24,826
of your constants and variables.


72
00:03:24,826 --> 00:03:26,036
Talking of [inaudible]
characters,


73
00:03:26,036 --> 00:03:29,466
Swift does all the hard work
of working out what it means


74
00:03:29,466 --> 00:03:30,946
to be an individual character,


75
00:03:31,396 --> 00:03:33,716
regardless of how your string
is encoded behind the scenes


76
00:03:34,066 --> 00:03:35,176
or how it appears on screen.


77
00:03:35,716 --> 00:03:38,636
So here I have a
string called dogString.


78
00:03:39,476 --> 00:03:43,206
You might think that this
has six characters in it.


79
00:03:43,206 --> 00:03:46,296
D, O, G, ?, !, dog face.


80
00:03:47,266 --> 00:03:48,096
But you would be wrong.


81
00:03:49,046 --> 00:03:50,966
There are five characters
here, not six.


82
00:03:51,786 --> 00:03:54,716
This is a special character
called question exclamation


83
00:03:54,716 --> 00:03:56,126
mark, which is really,


84
00:03:56,126 --> 00:04:00,456
really good for expressing
incredulity about dogs.


85
00:04:00,456 --> 00:04:03,406
Now, if you don't believe me,
let's get Swift to prove it.


86
00:04:03,816 --> 00:04:06,216
Every string has a
property called characters.


87
00:04:06,336 --> 00:04:08,386
It gives us a collection of
the characters in the string


88
00:04:08,386 --> 00:04:11,166
and we can access the count
property of that collection


89
00:04:11,476 --> 00:04:12,456
to see how many there are.


90
00:04:13,276 --> 00:04:14,716
If we pass that to
the print function,


91
00:04:15,116 --> 00:04:17,386
we find out that we do,
indeed, have five characters.


92
00:04:18,245 --> 00:04:21,636
But if you still don't
believe me, well, let's iterate


93
00:04:21,636 --> 00:04:24,396
over each of those characters
in turn, using the for-in loop


94
00:04:24,396 --> 00:04:26,526
and print each one of
them on its own line,


95
00:04:26,876 --> 00:04:29,076
and you can see we do,
indeed, have five characters;


96
00:04:29,726 --> 00:04:30,626
D, O, G, ?!


97
00:04:31,136 --> 00:04:33,866
and dog face.


98
00:04:35,616 --> 00:04:39,456
Now, in addition to all of these
fundamental types we also have


99
00:04:39,456 --> 00:04:41,096
some built-in collections.


100
00:04:41,516 --> 00:04:43,136
We have array and dictionary.


101
00:04:43,656 --> 00:04:45,586
You might know dictionary
as a hash


102
00:04:45,586 --> 00:04:46,976
or map table from
other languages.


103
00:04:47,856 --> 00:04:49,566
And the easiest way
to create an array


104
00:04:49,616 --> 00:04:51,226
or a dictionary is
with a literal.


105
00:04:51,306 --> 00:04:53,706
This is an array literal
written with square bracketry


106
00:04:53,706 --> 00:04:55,676
on the outside and
commas between each value.


107
00:04:56,756 --> 00:04:59,806
Here we have an array of
four names, four strings.


108
00:05:01,066 --> 00:05:02,356
Dictionaries look very similar.


109
00:05:02,826 --> 00:05:04,866
Their keys and values are
separated with a colon.


110
00:05:05,336 --> 00:05:08,096
Here we have a dictionary whose
keys are strings, the names,


111
00:05:08,556 --> 00:05:09,816
and whose values are integers.


112
00:05:11,716 --> 00:05:15,336
Now, you might notice from
the things in this array


113
00:05:15,596 --> 00:05:17,516
that they're all the same
type; they're all strings.


114
00:05:18,356 --> 00:05:20,956
It wouldn't make sense to insert
something else in a names array,


115
00:05:21,326 --> 00:05:24,096
to have an integer or
a Boolean or a bicycle.


116
00:05:24,096 --> 00:05:25,676
That would be just weird.


117
00:05:26,446 --> 00:05:28,676
For names we always
want them to be strings,


118
00:05:28,676 --> 00:05:30,736
and in Swift we can
express this.


119
00:05:30,736 --> 00:05:34,156
We can say we want an array
of strings, so we know as soon


120
00:05:34,156 --> 00:05:35,296
as we get anything out of it,


121
00:05:35,296 --> 00:05:37,446
we can do string
like things with it.


122
00:05:37,946 --> 00:05:39,066
So this is how we write that.


123
00:05:39,066 --> 00:05:40,706
This is how we write
an array of strings,


124
00:05:40,706 --> 00:05:42,316
a string with square
brackets around it.


125
00:05:43,606 --> 00:05:46,626
But as we saw earlier
on, when it's clear


126
00:05:46,626 --> 00:05:49,076
from the right hand side
what kind of type we want,


127
00:05:49,726 --> 00:05:52,336
Swift works it out for us,
and that happens here as well.


128
00:05:52,336 --> 00:05:53,936
We actually don't need
to write the type.


129
00:05:54,386 --> 00:05:56,556
It's clear we want
an array of strings.


130
00:05:57,976 --> 00:05:58,976
The same goes for
our dictionary.


131
00:05:59,336 --> 00:06:02,276
Here it's clear we want string
keys and integer values,


132
00:06:02,516 --> 00:06:04,206
so Swift can infer
that for us as well,


133
00:06:04,356 --> 00:06:08,346
but everything is
still clearly typed.


134
00:06:08,526 --> 00:06:11,486
Swift has all of the loops you
might know from other languages.


135
00:06:11,826 --> 00:06:14,476
We have a while loop that checks
its condition before first


136
00:06:14,476 --> 00:06:15,396
executing its body.


137
00:06:16,046 --> 00:06:17,086
And a repeat-while loop,


138
00:06:17,486 --> 00:06:19,836
which executes its body once
before checking a condition


139
00:06:19,836 --> 00:06:20,976
to see if it should continue.


140
00:06:21,506 --> 00:06:25,096
And as we saw earlier, we have
the for in loop, which we used


141
00:06:25,096 --> 00:06:26,556
to iterate over the
characters of a string.


142
00:06:27,476 --> 00:06:30,466
But that's not the only thing
the for in can be used with.


143
00:06:31,546 --> 00:06:33,696
We can use it to
iterate over a range.


144
00:06:34,336 --> 00:06:37,026
Here we have a range that
runs through from 1 through 5


145
00:06:37,026 --> 00:06:39,206
and includes most of those
numbers, which we're using


146
00:06:39,206 --> 00:06:41,376
to print five entries
from the four times table.


147
00:06:42,186 --> 00:06:44,786
We write this as 1...5.


148
00:06:45,056 --> 00:06:46,216
That is called a closed range


149
00:06:46,216 --> 00:06:47,626
because it includes
both of those numbers.


150
00:06:48,726 --> 00:06:51,646
However, sometimes it's useful
to have a range that runs


151
00:06:51,646 --> 00:06:53,856
up to one less than
its final number.


152
00:06:54,586 --> 00:06:55,886
Here's an example of
where that's useful.


153
00:06:56,806 --> 00:06:58,986
I have an array of
integers, but I only want


154
00:06:58,986 --> 00:06:59,966
to print the first five.


155
00:07:00,766 --> 00:07:02,726
Now, because array
indices start from 0,


156
00:07:02,726 --> 00:07:04,986
I actually want indices
0 through 4.


157
00:07:05,726 --> 00:07:08,006
So for that we can use the
half-closed range operator,


158
00:07:08,406 --> 00:07:10,926
..< because it runs the one less


159
00:07:10,926 --> 00:07:12,576
than the final number,
in this case 5.


160
00:07:14,696 --> 00:07:16,756
We can use a for-in
loop with an array.


161
00:07:16,756 --> 00:07:18,616
Here we're printing
a message for each


162
00:07:18,616 --> 00:07:19,656
of the names in our array.


163
00:07:20,486 --> 00:07:22,176
And we can also use
it with a dictionary.


164
00:07:23,056 --> 00:07:25,726
Now, note here that we're
iterating over the key


165
00:07:25,726 --> 00:07:28,676
and the value, the name and
the age, at the same time.


166
00:07:29,596 --> 00:07:32,296
And this is an example of
Swift speech known as a tuple,


167
00:07:32,296 --> 00:07:34,626
which lets you combine those
multiple values together


168
00:07:34,626 --> 00:07:35,646
and use them at the same time.


169
00:07:35,736 --> 00:07:37,816
And we'll see another
example of this later on.


170
00:07:38,496 --> 00:07:39,886
And it makes for
much clearer code


171
00:07:40,086 --> 00:07:41,286
when iterating over
a dictionary.


172
00:07:43,276 --> 00:07:45,466
So how would we modify
these collections?


173
00:07:46,456 --> 00:07:49,096
Well, here's my packing
list for WWDC this year.


174
00:07:49,266 --> 00:07:51,576
I've declared it as a
variable so I can change it,


175
00:07:52,276 --> 00:07:54,896
but I've included the
essentials, socks and shoes.


176
00:07:55,526 --> 00:08:01,796
Now, at WWDC 2014 I
forgot to pack my socks


177
00:08:02,386 --> 00:08:05,536
and it was a nightmare, so I'm
not making that mistake again.


178
00:08:06,286 --> 00:08:08,286
So let's check that
the first item


179
00:08:08,286 --> 00:08:09,906
in this array is
definitely socks.


180
00:08:10,026 --> 00:08:12,716
After 2014, if I put it on
the list, it will be first.


181
00:08:13,666 --> 00:08:15,066
We do this using a subscript,


182
00:08:15,476 --> 00:08:18,316
writing an index inside square
brackets after the array name,


183
00:08:18,576 --> 00:08:19,756
and if we print this value,


184
00:08:19,876 --> 00:08:22,956
I have indeed remembered
to add socks.


185
00:08:23,186 --> 00:08:24,986
Socks and shoes will
not be enough, however,


186
00:08:24,986 --> 00:08:26,186
for a week of the conference.


187
00:08:26,186 --> 00:08:27,106
I'll need more things.


188
00:08:27,616 --> 00:08:28,886
So let's append a new item.


189
00:08:28,946 --> 00:08:31,186
Let's append some trousers
to this array as well,


190
00:08:31,186 --> 00:08:32,916
which we do using
the append method.


191
00:08:33,405 --> 00:08:35,616
But there's a problem here.


192
00:08:36,816 --> 00:08:39,726
The conference is in America and
they don't call them trousers,


193
00:08:40,346 --> 00:08:42,535
they call them pants,
and that's going


194
00:08:42,676 --> 00:08:44,316
to cause all kinds of confusion.


195
00:08:44,966 --> 00:08:46,696
So let's change a
value in our array.


196
00:08:47,226 --> 00:08:48,926
Let's change this
to be jeans instead.


197
00:08:49,246 --> 00:08:50,986
Again, we use a subscript
to do so,


198
00:08:51,146 --> 00:08:52,566
to change the item in index two.


199
00:08:52,936 --> 00:08:54,206
Jeans are called the
same thing everywhere,


200
00:08:54,206 --> 00:08:55,326
so this shouldn't
cause confusion.


201
00:08:57,406 --> 00:08:59,016
Now, the conference
is in California


202
00:08:59,166 --> 00:09:00,756
where it is always
hot and sunny,


203
00:09:01,436 --> 00:09:02,806
so let's add a few more items.


204
00:09:02,806 --> 00:09:06,506
Let's add some shorts, some
sandals and some sunblock.


205
00:09:07,266 --> 00:09:10,346
We can do this using the append
contents of method and pass


206
00:09:10,346 --> 00:09:12,566
in a compatible array,
another array of strings here,


207
00:09:13,186 --> 00:09:16,466
and they all get
appended at the same time.


208
00:09:16,526 --> 00:09:19,346
That said, whilst the
conference is in California,


209
00:09:20,006 --> 00:09:23,216
it's in San Francisco, where
it is not always hot and sunny.


210
00:09:23,956 --> 00:09:26,596
So maybe let's change those
three items and replace them


211
00:09:26,596 --> 00:09:28,286
with a hoodie and
a scarf instead.


212
00:09:29,206 --> 00:09:31,656
We can do this by passing
a range into the subscript.


213
00:09:32,076 --> 00:09:34,046
And note that we're changing
three items with two,


214
00:09:34,166 --> 00:09:37,766
this is still perfectly
valid in Swift.


215
00:09:38,006 --> 00:09:38,906
So what about a dictionary?


216
00:09:38,906 --> 00:09:40,036
Let's modify a dictionary.


217
00:09:40,656 --> 00:09:43,976
Well, here I have my ages
dictionary from before.


218
00:09:44,476 --> 00:09:47,346
I'd like to add somebody else
to it, and I do this just


219
00:09:47,346 --> 00:09:50,556
by adding a value for a key
that's not already there using


220
00:09:50,556 --> 00:09:51,136
a subscript.


221
00:09:51,356 --> 00:09:52,156
Here I've added Justyn.


222
00:09:52,726 --> 00:09:56,036
But thinking about it, it was
Justyn's birthday last week


223
00:09:56,396 --> 00:09:57,676
so this value is now incorrect.


224
00:09:57,676 --> 00:09:59,956
I need to update it, which I
do in exactly the same way.


225
00:10:00,156 --> 00:10:02,896
I just assign a different
value for the same key


226
00:10:03,036 --> 00:10:04,216
and now my dictionary's correct.


227
00:10:06,716 --> 00:10:09,446
What if I want to retrieve
a value from the dictionary?


228
00:10:10,176 --> 00:10:13,546
What if I want to see if we have
an age for Devon or for Daryl,


229
00:10:13,546 --> 00:10:15,016
or perhaps for Daniel?


230
00:10:16,456 --> 00:10:18,996
Well, there might be a value in
the dictionary for these people,


231
00:10:18,996 --> 00:10:22,166
but there might not, and we
need a way to model that,


232
00:10:22,626 --> 00:10:24,296
and this is a great use case


233
00:10:24,296 --> 00:10:25,906
for a Swift feature
known as Optionals.


234
00:10:25,906 --> 00:10:28,916
If we tried this for Amy,


235
00:10:29,276 --> 00:10:31,576
we might expect a
value of 40 perhaps.


236
00:10:31,736 --> 00:10:34,976
But if we tried it for Daryl,
what should we get then?


237
00:10:34,976 --> 00:10:37,976
There's no value here for Daryl.


238
00:10:38,186 --> 00:10:38,886
Think of it like this.


239
00:10:40,046 --> 00:10:42,716
There either is a value in the
dictionary and it's an Int,


240
00:10:43,086 --> 00:10:46,466
that's for Amy, or there's
no value, there's no Int,


241
00:10:46,946 --> 00:10:47,756
as in the case of Daryl.


242
00:10:47,836 --> 00:10:51,716
So what we have here
is an optional Int,


243
00:10:52,336 --> 00:10:54,026
which we write as
Int question mark.


244
00:10:54,736 --> 00:10:56,776
And the question mark means
there might be a value here,


245
00:10:57,176 --> 00:10:58,306
but there might not.


246
00:10:59,716 --> 00:11:02,096
Now, we can check to
see if we found a value


247
00:11:02,336 --> 00:11:03,686
by comparing it against nil.


248
00:11:03,686 --> 00:11:05,126
Nil is just a special way,


249
00:11:05,126 --> 00:11:06,926
a shorthand way of
writing no value.


250
00:11:07,456 --> 00:11:09,926
If we try this for
Daryl, there is no value,


251
00:11:10,076 --> 00:11:12,536
we'd print the message.


252
00:11:12,536 --> 00:11:13,216
Age not found.


253
00:11:13,896 --> 00:11:16,646
If we try this for Amy,
well, we do find a value


254
00:11:16,946 --> 00:11:20,996
so it doesn't equal nil and
so we don't print the message.


255
00:11:21,146 --> 00:11:23,416
Typically, however, we don't
just want to check for a value.


256
00:11:23,416 --> 00:11:24,846
We actually want to
use it if it exists,


257
00:11:25,486 --> 00:11:28,526
and Swift has a really good
shorthand for writing this,


258
00:11:28,526 --> 00:11:31,216
which we write as if let.


259
00:11:31,256 --> 00:11:34,616
Now, this says here the
dictionary contains a value


260
00:11:34,616 --> 00:11:38,826
for Amy, let a new constant
called age equal that value.


261
00:11:38,826 --> 00:11:42,006
And then we can use that
value inside the if statement.


262
00:11:42,916 --> 00:11:45,256
And note that we use it
as an actual integer.


263
00:11:45,256 --> 00:11:46,356
It's not optional anymore.


264
00:11:47,416 --> 00:11:50,026
The if statements checks
for the value, unwraps it


265
00:11:50,216 --> 00:11:51,646
and gives us back
a normal integer


266
00:11:51,756 --> 00:11:53,396
that we can do integer
like things with.


267
00:11:55,436 --> 00:11:57,696
So we've seen a few
if statements so far.


268
00:11:57,986 --> 00:11:59,706
Here's another that
prints a birthday message.


269
00:12:00,046 --> 00:12:03,116
There are two things to
note about this statement.


270
00:12:04,096 --> 00:12:06,036
Firstly, we don't
need parentheses


271
00:12:06,036 --> 00:12:07,876
around the conditions so we can
just write them as they are.


272
00:12:09,066 --> 00:12:12,516
And secondly, we do add
curly braces around each part


273
00:12:12,516 --> 00:12:14,656
of the statement to make
it explicit which bits


274
00:12:14,656 --> 00:12:18,256
of code are going to be run.


275
00:12:18,306 --> 00:12:21,156
In addition to if, we also
have a switch statement,


276
00:12:21,566 --> 00:12:23,676
and this is useful for
writing maybe more complex,


277
00:12:23,676 --> 00:12:24,606
more powerful matches.


278
00:12:25,386 --> 00:12:28,176
This switches over the
current value of a constant


279
00:12:28,176 --> 00:12:30,876
or a variable and matches
certain cases that can occur.


280
00:12:31,496 --> 00:12:34,386
So, for example, we can have
the case here for an age


281
00:12:34,826 --> 00:12:36,826
where the value is
one and we want


282
00:12:36,826 --> 00:12:39,156
to print a simple happy
first birthday message.


283
00:12:40,256 --> 00:12:41,826
We can also match
against ranges.


284
00:12:42,396 --> 00:12:44,526
Here matching any value that
would make someone a teenager.


285
00:12:45,666 --> 00:12:48,886
And we can match more complex
patterns, such as this one,


286
00:12:49,136 --> 00:12:53,276
which says that a temporary
constant called decade equal the


287
00:12:53,276 --> 00:12:54,386
value that we're
currently matching,


288
00:12:55,426 --> 00:12:58,956
check if it will divide
cleanly by 10, and if so,


289
00:12:59,366 --> 00:13:01,646
use it to print a
special birthday message


290
00:13:02,016 --> 00:13:04,436
for anyone who's
just turned 30 or 40


291
00:13:04,656 --> 00:13:06,036
or some other significant age.


292
00:13:06,586 --> 00:13:10,286
But there's a problem with
this statement as it stands.


293
00:13:11,336 --> 00:13:13,626
What would happen if we wanted
to print a message for someone


294
00:13:13,626 --> 00:13:17,316
who was 41, or 97 or 56?


295
00:13:17,316 --> 00:13:20,046
Well, they wouldn't
get a message,


296
00:13:20,386 --> 00:13:21,766
and that seems really
unfortunate,


297
00:13:21,826 --> 00:13:25,026
especially on their birthday.


298
00:13:25,096 --> 00:13:26,406
Frankly, Swift helps
us out here.


299
00:13:27,166 --> 00:13:29,896
Swift makes sure that every
switch statement is complete,


300
00:13:29,896 --> 00:13:32,186
that you don't accidentally
forget one


301
00:13:32,186 --> 00:13:33,556
of the cases that
you might need.


302
00:13:34,416 --> 00:13:36,986
And in this case we can
add a default statement


303
00:13:37,426 --> 00:13:40,666
which catches every other case
we hadn't already caught above


304
00:13:41,026 --> 00:13:45,876
and just says, Happy
plain old boring birthday.


305
00:13:45,876 --> 00:13:47,026
Here's another switch statement.


306
00:13:48,176 --> 00:13:52,066
This one takes a string value,
user name, and a Boolean value


307
00:13:52,066 --> 00:13:54,776
that indicates whether that
user's password is valid,


308
00:13:55,496 --> 00:13:58,286
and we'll use both of these
values together to work


309
00:13:58,286 --> 00:14:01,056
out an appropriate message to
display when this user tries


310
00:14:01,056 --> 00:14:02,416
to log into a restricted area.


311
00:14:03,326 --> 00:14:06,496
And to do this we can
switch over both values


312
00:14:06,496 --> 00:14:09,746
at the same time using a tuple,
same as we did earlier on.


313
00:14:11,006 --> 00:14:12,496
So this means we can
write some really,


314
00:14:12,496 --> 00:14:13,646
really interesting use cases,


315
00:14:13,646 --> 00:14:14,946
some really interesting
switch cases.


316
00:14:15,636 --> 00:14:17,616
We can have the case where
the user name is admin


317
00:14:17,716 --> 00:14:19,936
and the password is
true, and print a message


318
00:14:19,936 --> 00:14:21,286
to welcome back our
administrator.


319
00:14:23,046 --> 00:14:26,206
Now, in the case of a guest we
never want to allow the guest


320
00:14:26,206 --> 00:14:28,816
into the restricted area even
if their password is valid,


321
00:14:29,496 --> 00:14:31,246
and so we can ignore
the password


322
00:14:31,466 --> 00:14:32,496
by writing an underscore,


323
00:14:33,406 --> 00:14:36,896
and this means just match
any possible value here.


324
00:14:37,036 --> 00:14:39,896
For all other users we actually
don't care what the user


325
00:14:39,896 --> 00:14:40,266
name is.


326
00:14:40,266 --> 00:14:41,546
We just care about the password.


327
00:14:41,996 --> 00:14:45,046
So we can ignore the user
name again, and instead,


328
00:14:45,476 --> 00:14:47,246
we've switched on
what we want to do


329
00:14:47,246 --> 00:14:48,456
with the password's validity.


330
00:14:49,056 --> 00:14:51,586
To do this we create a temporary
constant called IsValid,


331
00:14:52,526 --> 00:14:55,456
and we then use the ternary
conditional operator,


332
00:14:55,776 --> 00:14:57,476
that's the question
mark and colon here,


333
00:14:57,616 --> 00:15:01,336
to say if it's valid,
use this message;


334
00:15:01,806 --> 00:15:03,586
otherwise, use this message.


335
00:15:04,896 --> 00:15:06,876
So let's run that through
for a few examples.


336
00:15:06,876 --> 00:15:10,096
If we take our administrator,
the password's valid,


337
00:15:10,436 --> 00:15:12,676
they get a special administrator
message, as expected.


338
00:15:13,746 --> 00:15:15,216
If we try this for
a guest, well,


339
00:15:15,216 --> 00:15:18,386
even though their password is
valid, they get the I'm sorry,


340
00:15:18,386 --> 00:15:19,466
you can't come in message.


341
00:15:19,886 --> 00:15:22,656
If we try it for Bob,
his password is valid,


342
00:15:23,176 --> 00:15:24,856
he gets the welcome
message as expected.


343
00:15:25,436 --> 00:15:28,406
But if his password is not
valid, he gets access denied.


344
00:15:30,436 --> 00:15:32,956
Now, there is one
final thing of note


345
00:15:33,226 --> 00:15:34,286
about this switch statement,


346
00:15:34,936 --> 00:15:37,426
and that's that it doesn't
have a default condition.


347
00:15:37,706 --> 00:15:40,186
And the reason it doesn't
is it doesn't need one.


348
00:15:40,416 --> 00:15:42,566
It's already complete.


349
00:15:42,566 --> 00:15:46,206
If we take a look at
the final case here,


350
00:15:46,816 --> 00:15:49,626
this actually covers all
of the possible conditions


351
00:15:49,626 --> 00:15:51,026
that we haven't already
matched above


352
00:15:51,506 --> 00:15:53,556
and so the switch
statement is complete


353
00:15:53,556 --> 00:15:55,976
without needing a default.


354
00:15:56,086 --> 00:15:58,596
So those are some of the
basics of the Swift language.


355
00:15:59,086 --> 00:16:01,426
I'd now like to hand over to my
colleague Brian to introduce you


356
00:16:01,426 --> 00:16:03,366
to functions and
closures in Swift.


357
00:16:05,016 --> 00:16:08,816
[ Applause ]


358
00:16:09,316 --> 00:16:09,546
>> All right.


359
00:16:09,756 --> 00:16:10,776
Thanks, Dave, as I was saying.


360
00:16:10,916 --> 00:16:12,226
Let's get started by looking


361
00:16:12,226 --> 00:16:13,706
at how you define a
function in Swift.


362
00:16:14,356 --> 00:16:16,796
You define a function
using the func keyword


363
00:16:17,166 --> 00:16:19,266
and you implement it
inside of the curly braces.


364
00:16:19,806 --> 00:16:22,276
Here we've defined a simple
function called sendMessage


365
00:16:22,586 --> 00:16:24,106
that prints a message
to the console.


366
00:16:24,496 --> 00:16:27,476
And you call this message
in an intuitive way


367
00:16:27,996 --> 00:16:30,096
by writing its name,
sendMessage,


368
00:16:30,606 --> 00:16:32,246
followed by an empty
pair of parentheses.


369
00:16:32,946 --> 00:16:35,166
So let's add a parameter
to the function


370
00:16:35,166 --> 00:16:38,096
that indicates whether the
message should be sent shouting.


371
00:16:39,176 --> 00:16:41,656
You write the parameter's
name, followed by colon


372
00:16:41,656 --> 00:16:43,836
and the parameter's
type, just like you do


373
00:16:43,836 --> 00:16:46,176
when you declare a
constant or a variable.


374
00:16:47,076 --> 00:16:48,866
Here we've added a
parameter called shouting,


375
00:16:48,996 --> 00:16:49,906
which is of type Bool.


376
00:16:50,576 --> 00:16:52,036
And when you call the function,


377
00:16:52,036 --> 00:16:54,236
the parameter's name
provides a label


378
00:16:54,236 --> 00:16:57,796
for the argument you pass in.


379
00:16:57,796 --> 00:17:00,356
Labeling your arguments
makes your code read better


380
00:17:00,356 --> 00:17:03,196
and makes the purpose or
intent of each argument clear.


381
00:17:03,196 --> 00:17:06,086
In this case, if you left
out the shouting label,


382
00:17:06,415 --> 00:17:08,215
someone reading your
code later might think


383
00:17:08,215 --> 00:17:10,846
that true just indicated whether
the message should be sent


384
00:17:10,846 --> 00:17:11,376
at all.


385
00:17:13,215 --> 00:17:15,016
So you can shout a message,
but who are you going


386
00:17:15,016 --> 00:17:16,536
to send the message to.


387
00:17:16,536 --> 00:17:19,036
Let's add another parameter
that lets us address the message


388
00:17:19,036 --> 00:17:19,935
to someone in particular.


389
00:17:20,476 --> 00:17:23,306
So here we've added a
parameter called recipient,


390
00:17:23,596 --> 00:17:24,596
which is of type string,


391
00:17:24,776 --> 00:17:26,455
and we've included
the recipient's name


392
00:17:26,935 --> 00:17:28,926
in our message using
string interpolation.


393
00:17:30,236 --> 00:17:32,456
And now when you call the
function, you can pass


394
00:17:32,456 --> 00:17:33,406
in the recipient's name.


395
00:17:34,666 --> 00:17:37,046
Now, although the message
prints as you'd expect,


396
00:17:37,476 --> 00:17:39,446
it doesn't read very
well when you call it.


397
00:17:40,246 --> 00:17:43,106
sendMessage recipient
Morgan is pretty awkward.


398
00:17:44,046 --> 00:17:46,156
When you call a function, you
want it to read naturally.


399
00:17:46,156 --> 00:17:49,256
In this case you'd like it to
say something like sendMessage


400
00:17:49,256 --> 00:17:52,046
to Morgan, which forms a
nice grammatical phrase.


401
00:17:52,596 --> 00:17:54,646
And you could do this
by changing the name


402
00:17:54,646 --> 00:17:56,686
of the parameter, which
then changes the name


403
00:17:56,686 --> 00:17:59,786
of the argument label, and this
does make the function read


404
00:17:59,786 --> 00:18:02,276
better when you call it,
sendMessage to Morgan,


405
00:18:03,076 --> 00:18:06,236
but it doesn't work so well
inside the body of the function.


406
00:18:07,286 --> 00:18:09,816
Inside the body you really
want a noun for the parameter,


407
00:18:09,816 --> 00:18:13,316
not a preposition, hey
there to, isn't so great.


408
00:18:14,696 --> 00:18:16,456
But sometimes there
isn't a single word


409
00:18:16,456 --> 00:18:20,276
that works well both inside the
function's body and as a label


410
00:18:20,276 --> 00:18:21,226
when you call the function.


411
00:18:22,166 --> 00:18:23,876
In Swift you don't have
to give one of these up.


412
00:18:24,676 --> 00:18:27,216
When a parameter's name
isn't appropriate as a label


413
00:18:27,896 --> 00:18:29,236
for the argument
when you call it,


414
00:18:29,716 --> 00:18:33,006
you can explicitly provide
a more suitable one.


415
00:18:33,326 --> 00:18:35,856
You write the explicit
argument label in front


416
00:18:35,856 --> 00:18:36,726
of the parameter's name.


417
00:18:37,016 --> 00:18:39,596
Here we've added to as an
explicit argument label


418
00:18:39,596 --> 00:18:42,436
in addition to the recipient
parameter, and this just means


419
00:18:42,436 --> 00:18:44,126
that you can use to when
you call the function,


420
00:18:44,746 --> 00:18:48,286
sendMessage to Morgan, and you
can still use recipient inside


421
00:18:48,286 --> 00:18:49,366
the body of the function.


422
00:18:49,906 --> 00:18:53,546
Let's add one more
parameter to the function


423
00:18:53,546 --> 00:18:56,226
which lets you provide a custom
message when you call it.


424
00:18:57,256 --> 00:18:59,736
Here we've added a message
parameter of type string.


425
00:19:00,376 --> 00:19:01,536
Now when you call the function,


426
00:19:01,536 --> 00:19:04,716
you can pass on your
own message.


427
00:19:04,846 --> 00:19:07,176
Now, once again, this
code works as expected,


428
00:19:07,626 --> 00:19:09,266
but it doesn't read
very well either.


429
00:19:10,166 --> 00:19:12,646
sendMessage message
is redundant.


430
00:19:13,706 --> 00:19:16,436
The message label isn't
helping to clarify the role


431
00:19:16,486 --> 00:19:19,336
of the first argument
because it's already clear


432
00:19:19,336 --> 00:19:21,256
from the base name of the
function, sendMessage.


433
00:19:22,026 --> 00:19:24,956
Here the argument label actually
makes the code harder to read.


434
00:19:24,956 --> 00:19:28,276
In the cases like these, you
can write an underscore in front


435
00:19:28,276 --> 00:19:29,226
of the parameter's name.


436
00:19:30,366 --> 00:19:32,626
And this means that you don't
provide a label for the argument


437
00:19:32,976 --> 00:19:37,106
when you call the function.


438
00:19:37,226 --> 00:19:39,346
And now our function reads
naturally when you call it;


439
00:19:39,466 --> 00:19:41,456
sendMessage, See you
at the bash, to Morgan.


440
00:19:42,006 --> 00:19:46,506
Now, it's not very often that
we need to shout our message,


441
00:19:46,546 --> 00:19:49,536
so we usually pass in
false for that argument,


442
00:19:49,536 --> 00:19:52,486
and in Swift you can actually
capture this behavior right


443
00:19:52,486 --> 00:19:53,906
in the declaration
of the function.


444
00:19:54,716 --> 00:19:57,416
Whenever a parameter has a
single commonly used value,


445
00:19:57,896 --> 00:20:01,536
you can provide that value as
the default, and you do this


446
00:20:01,536 --> 00:20:04,096
by assigning a default
value, in this case false,


447
00:20:04,706 --> 00:20:06,216
right after the type
of the parameter,


448
00:20:07,126 --> 00:20:08,926
and now when you call the
function, you can leave


449
00:20:08,926 --> 00:20:12,466
out the corresponding argument
and the default value is used.


450
00:20:14,876 --> 00:20:16,966
And when you're deciding
whether to use or when


451
00:20:16,966 --> 00:20:20,796
to use an explicit argument
label, when to omit one or when


452
00:20:20,796 --> 00:20:22,906
to provide default
values for parameters,


453
00:20:23,246 --> 00:20:25,626
remember that functions
are declared only once,


454
00:20:25,996 --> 00:20:27,216
but they're used repeatedly.


455
00:20:27,516 --> 00:20:30,386
So the most important thing is
that the function reads clearly


456
00:20:30,386 --> 00:20:31,916
and concisely when it's called.


457
00:20:32,296 --> 00:20:35,146
Now, to learn much
more about the kinds


458
00:20:35,146 --> 00:20:36,236
of things you should consider


459
00:20:36,516 --> 00:20:37,816
when you're writing
great Swift API,


460
00:20:38,986 --> 00:20:41,446
check out the Swift
API Guidelines talk.


461
00:20:42,066 --> 00:20:44,796
So we've looked at lots of
ways functions can take values.


462
00:20:45,296 --> 00:20:47,756
Let's take a look at some of
the ways they can return values.


463
00:20:48,896 --> 00:20:50,206
Let's say you want
to write a function


464
00:20:50,206 --> 00:20:51,856
that returns a first
string in an array


465
00:20:52,076 --> 00:20:53,176
that has a given prefix.


466
00:20:54,656 --> 00:20:58,556
The function takes a string
prefix, an array of strings,


467
00:20:59,046 --> 00:21:01,856
and it returns the string
with a given prefix.


468
00:21:02,016 --> 00:21:04,826
As you can see, you use an
arrow to indicate what type


469
00:21:04,826 --> 00:21:06,376
of values your function
can return.


470
00:21:06,806 --> 00:21:07,726
In this case a string.


471
00:21:08,636 --> 00:21:09,966
So let's see how it works.


472
00:21:11,196 --> 00:21:13,956
First use a for-in loop to
iterate through each string


473
00:21:13,956 --> 00:21:16,766
in the array and then you
check whether a string has a


474
00:21:16,766 --> 00:21:17,686
given prefix.


475
00:21:18,256 --> 00:21:21,926
You need to check whether the
string has a given prefix using


476
00:21:21,926 --> 00:21:23,306
strings.hasprefix method.


477
00:21:23,336 --> 00:21:27,236
If it does, you're done and you
can simply return the string


478
00:21:27,236 --> 00:21:28,746
by writing it in a
return statement.


479
00:21:30,516 --> 00:21:31,726
But what do you return


480
00:21:31,726 --> 00:21:34,166
if the array doesn't contain
the string you're looking for?


481
00:21:35,196 --> 00:21:37,586
Well, because this function was
declared to return a string,


482
00:21:37,906 --> 00:21:40,726
the only option you have
is some valid string value,


483
00:21:41,056 --> 00:21:42,236
in this case the empty string.


484
00:21:43,056 --> 00:21:44,426
But this is not good Swift code.


485
00:21:45,556 --> 00:21:48,136
However, as Dave showed
earlier, optionals are perfect


486
00:21:48,136 --> 00:21:50,386
for representing values
that may be missing.


487
00:21:51,786 --> 00:21:54,076
So you just need to change the
return type of this function


488
00:21:54,076 --> 00:21:56,426
to be an optional string
by writing a question mark


489
00:21:56,426 --> 00:21:58,876
after string, and now
you can return nil


490
00:21:59,066 --> 00:22:00,316
when the string isn't found.


491
00:22:01,336 --> 00:22:03,916
And because the function
returns an optional string,


492
00:22:04,166 --> 00:22:06,256
you can call it safely
in an if-let statement.


493
00:22:07,626 --> 00:22:10,376
Now, notice that Swift infers
a return type of the function,


494
00:22:10,806 --> 00:22:13,436
so there's no need to
write it explicitly here.


495
00:22:14,256 --> 00:22:16,736
So we've looked at some of
the ways functions can take


496
00:22:16,986 --> 00:22:19,796
and return values of various
types, such as strings,


497
00:22:19,876 --> 00:22:22,796
integers, arrays and
even optional types.


498
00:22:23,446 --> 00:22:25,836
Let's take a look at writing
one more kind of function.


499
00:22:28,036 --> 00:22:30,236
Let's say you want to write a
function that filters an array


500
00:22:30,236 --> 00:22:31,886
of numbers based
on some condition.


501
00:22:33,036 --> 00:22:34,786
Let's think about what
this function needs to do.


502
00:22:34,786 --> 00:22:39,396
It's going to take in an array
of numbers and for each number


503
00:22:39,396 --> 00:22:41,606
in the array it's going to
determine whether to include


504
00:22:41,606 --> 00:22:43,266
that number in the
filtered results.


505
00:22:44,296 --> 00:22:46,536
For example, if you wanted
an array that's been filtered


506
00:22:46,536 --> 00:22:48,506
to contain only the
even numbers here,


507
00:22:49,516 --> 00:22:51,656
you could test whether each
number is divisible by two.


508
00:22:52,416 --> 00:22:54,386
In this case, of
course, four is even,


509
00:22:54,546 --> 00:22:57,336
so it's included in
the result array.


510
00:22:58,096 --> 00:23:00,176
If a number isn't
even, such as 17,


511
00:23:00,176 --> 00:23:03,096
the filtering function just
moves on to the next number


512
00:23:03,096 --> 00:23:05,696
to test, and so on through
the rest of the array.


513
00:23:06,736 --> 00:23:10,766
Now, let's look at writing
this function in code.


514
00:23:10,936 --> 00:23:12,876
The function declaration
is what you might expect,


515
00:23:12,876 --> 00:23:16,276
but what type do you put in for
the includeNumber parameter?


516
00:23:17,056 --> 00:23:19,236
As you saw a few moments
ago, deciding whether


517
00:23:19,236 --> 00:23:20,156
to include a number


518
00:23:20,156 --> 00:23:23,416
in the filtered result is
itself actually a function,


519
00:23:23,736 --> 00:23:26,146
not just a simple value,
like a string or a number,


520
00:23:27,256 --> 00:23:31,176
and in Swift functions can take
other functions as parameters.


521
00:23:32,066 --> 00:23:33,966
So what does the type
of a function look like.


522
00:23:33,966 --> 00:23:37,566
Well, all function types in
Swift have this basic form.


523
00:23:38,186 --> 00:23:40,226
The type of the function's
parameters, if any,


524
00:23:40,736 --> 00:23:43,716
go inside of the parentheses,
followed by an arrow


525
00:23:43,716 --> 00:23:45,446
and the function's return type.


526
00:23:46,056 --> 00:23:48,996
So, for example, here's our
basic send message function


527
00:23:48,996 --> 00:23:49,556
from earlier.


528
00:23:50,296 --> 00:23:52,176
It has the type,
empty parentheses


529
00:23:52,406 --> 00:23:54,956
because it doesn't take
any parameters, arrow Void.


530
00:23:55,886 --> 00:23:58,306
Here void just means it
doesn't return any values.


531
00:23:59,486 --> 00:24:01,796
And in Swift if your function
doesn't return anything,


532
00:24:01,796 --> 00:24:03,966
you don't need to write
the arrow Void explicitly.


533
00:24:09,056 --> 00:24:11,046
And here's the firstString
function.


534
00:24:11,506 --> 00:24:13,196
Its signature is a
little more complicated,


535
00:24:13,526 --> 00:24:15,496
but its type follows
the same basic form.


536
00:24:16,356 --> 00:24:18,456
It takes a string,
an array of strings


537
00:24:18,456 --> 00:24:19,616
and it returns an
optional string.


538
00:24:20,456 --> 00:24:23,236
So now that you've seen this
syntax for function types,


539
00:24:23,286 --> 00:24:24,776
it's pretty clear how you need


540
00:24:24,776 --> 00:24:26,796
to finish the declaration
for filterInts.


541
00:24:27,936 --> 00:24:30,546
The includeNumber
parameter can be any function


542
00:24:31,086 --> 00:24:33,886
that takes an integer and
returns a Boolean, and you write


543
00:24:33,886 --> 00:24:37,386
that type as Int in
parentheses, arrow Bool.


544
00:24:38,236 --> 00:24:40,116
So let's go ahead and write
the rest of this function.


545
00:24:40,476 --> 00:24:44,186
You need to build up an
array of filtered numbers,


546
00:24:44,326 --> 00:24:45,826
so here's a variable
called result.


547
00:24:46,056 --> 00:24:48,246
It's been initialized to
an empty array of Ints.


548
00:24:49,386 --> 00:24:51,146
And as you iterate through
the array of numbers,


549
00:24:51,146 --> 00:24:52,876
pass into the function, you need


550
00:24:52,876 --> 00:24:54,556
to check whether each
number should be included


551
00:24:54,556 --> 00:24:55,496
in the result array.


552
00:24:56,946 --> 00:25:00,146
To do that you pass each number
to the includeNumber function,


553
00:25:00,616 --> 00:25:02,816
and notice that inside
the body of filterInts,


554
00:25:02,816 --> 00:25:05,946
the includeNumber parameter
is treated as a name


555
00:25:06,026 --> 00:25:08,526
of the function it's passed
in, and that just means


556
00:25:08,526 --> 00:25:09,826
that you can call
it in the same way


557
00:25:09,826 --> 00:25:11,146
that you do any other function.


558
00:25:11,246 --> 00:25:13,876
So that's how you
write a function


559
00:25:13,976 --> 00:25:15,826
that takes another
function as a parameter.


560
00:25:16,576 --> 00:25:18,476
But how do you call one of
these kind of functions?


561
00:25:19,636 --> 00:25:21,126
Well, first you're going
to need some values


562
00:25:21,126 --> 00:25:22,186
to pass into filterInts.


563
00:25:22,956 --> 00:25:24,286
So here's an array of numbers


564
00:25:24,526 --> 00:25:26,836
and a simple function
called divisibleByTwo


565
00:25:27,086 --> 00:25:28,756
that indicates whether
an integer is even.


566
00:25:29,796 --> 00:25:32,836
As you can see, the type


567
00:25:32,836 --> 00:25:35,836
of divisibleByTwo
matches exactly the type


568
00:25:35,836 --> 00:25:37,146
of the includeNumber parameter.


569
00:25:37,866 --> 00:25:42,686
So that means that we can pass
the divisibleByTwo function


570
00:25:43,206 --> 00:25:44,896
as an argument to filterInts.


571
00:25:45,436 --> 00:25:48,546
You do this by simply
passing in the name


572
00:25:48,546 --> 00:25:52,436
of the divisibleByTwo function
and now you've got an array


573
00:25:52,436 --> 00:25:53,736
of only the even numbers.


574
00:25:54,906 --> 00:25:56,996
Now, notice that you don't
include the parentheses


575
00:25:57,246 --> 00:25:59,526
when you pass in the
divisibleByTwo function,


576
00:25:59,806 --> 00:26:02,046
and that's because you're
not calling it at this point.


577
00:26:02,566 --> 00:26:05,236
Instead, it's called later
inside the body of filterInts.


578
00:26:05,726 --> 00:26:09,956
Also notice that we passed in
the array of numbers by name,


579
00:26:11,336 --> 00:26:14,266
but you could have passed
in a literal array instead;


580
00:26:14,586 --> 00:26:16,836
for instance, if you just
needed to pass in a few values


581
00:26:17,106 --> 00:26:19,666
without needing to create
a constant for later reuse.


582
00:26:20,936 --> 00:26:24,126
The same is true for passing
in functions as arguments.


583
00:26:26,616 --> 00:26:29,616
It's not very likely that the
divisibleByTwo function will


584
00:26:29,616 --> 00:26:30,806
find much reuse.


585
00:26:31,286 --> 00:26:32,846
And it would be pretty
cumbersome to have


586
00:26:32,846 --> 00:26:35,666
to make a new function every
time you wanted to pass


587
00:26:35,666 --> 00:26:37,146
in a different filterInt
condition.


588
00:26:37,726 --> 00:26:40,916
And if you look at the important
parts of divisibleByTwo,


589
00:26:40,916 --> 00:26:43,046
you can see that
giving it a name


590
00:26:43,046 --> 00:26:46,476
at all is really just a
convenience geared toward reuse.


591
00:26:47,736 --> 00:26:51,456
divisibleByTwo is just a
name for the functionality


592
00:26:51,456 --> 00:26:52,636
that you see highlighted.


593
00:26:54,496 --> 00:26:57,126
And in Swift, just as you
can write a literal string


594
00:26:57,496 --> 00:27:00,226
or a literal array, you can
write a literal function


595
00:27:00,826 --> 00:27:02,826
without a name called
a closure expression


596
00:27:03,156 --> 00:27:04,286
and pass it around in your code.


597
00:27:05,496 --> 00:27:08,136
The syntax for writing a closure
expression is very similar


598
00:27:08,136 --> 00:27:09,266
to a function declaration,


599
00:27:09,266 --> 00:27:10,876
except that it doesn't
have a name.


600
00:27:11,356 --> 00:27:14,496
You write the entire body
of the closure inside


601
00:27:14,496 --> 00:27:17,766
of the curly braces and you
separate the closure's body


602
00:27:18,106 --> 00:27:20,406
from its signature
using the Int keyword,


603
00:27:20,936 --> 00:27:24,536
as in use the parameter
number of type Int in the body


604
00:27:24,536 --> 00:27:26,166
of this closure,
which returns a Bool.


605
00:27:26,166 --> 00:27:30,886
Now, this is the most
explicit or complete way


606
00:27:30,886 --> 00:27:33,546
to write a closure, but
as you've seen before,


607
00:27:33,546 --> 00:27:35,376
Swift can infer a
lot of information


608
00:27:35,376 --> 00:27:37,656
from the context
your code appears in.


609
00:27:39,216 --> 00:27:42,686
For example, the function type
of the closure is already known


610
00:27:42,886 --> 00:27:44,866
from the type of the
includeNumber parameter,


611
00:27:45,926 --> 00:27:47,996
and this means you don't
need to write it explicitly.


612
00:27:48,536 --> 00:27:51,046
And when the entire body


613
00:27:51,046 --> 00:27:54,076
of the closure is a single
return statement, as it is here,


614
00:27:54,856 --> 00:27:56,906
you don't need to write
the return keyword either.


615
00:27:57,506 --> 00:28:01,426
So this is much cleaner syntax,
but because the closure's


616
00:28:01,426 --> 00:28:05,396
so short, even the number
parameter seems a bit redundant.


617
00:28:06,216 --> 00:28:09,236
And in cases like these Swift
provides implicit argument


618
00:28:09,236 --> 00:28:10,636
names, so there's no need


619
00:28:10,636 --> 00:28:13,366
to even write the parameter
name or the Int keyword.


620
00:28:13,886 --> 00:28:17,436
These implicit arguments
start with dollar sign


621
00:28:17,436 --> 00:28:18,626
and a number beginning at 0.


622
00:28:18,626 --> 00:28:21,676
So $0 refers to the first
argument to the closure,


623
00:28:21,676 --> 00:28:23,076
$1 the second, and so on.


624
00:28:23,236 --> 00:28:25,916
And even though these
are available to use


625
00:28:25,916 --> 00:28:29,226
in any closure expression,
use them when doing


626
00:28:29,226 --> 00:28:32,566
so doesn't make your
code harder to read.


627
00:28:33,676 --> 00:28:36,606
Now, you've seen that Swift
provides lots of convenient ways


628
00:28:36,606 --> 00:28:37,456
for writing closures,


629
00:28:38,096 --> 00:28:42,026
but passing them directly inside
a function's parentheses is a


630
00:28:42,026 --> 00:28:43,396
little punctuation heavy.


631
00:28:44,206 --> 00:28:45,996
A closing curly brace right next


632
00:28:45,996 --> 00:28:48,196
to a closing paren
is pretty terrible.


633
00:28:48,196 --> 00:28:53,206
However, when the closure is the
last argument to the function,


634
00:28:53,206 --> 00:28:56,076
as it is in this case,
you can write it instead


635
00:28:56,076 --> 00:28:59,176
as a trailing closure right
outside of the parentheses.


636
00:29:00,426 --> 00:29:03,606
And as you'll see later, if
the closure's the only argument


637
00:29:03,606 --> 00:29:06,436
to a function, you can drop
the parentheses altogether.


638
00:29:07,046 --> 00:29:09,846
Now, trailing closures
are especially nice


639
00:29:10,446 --> 00:29:12,946
when the closure contains
more than one line of code.


640
00:29:13,886 --> 00:29:16,256
For example, here's a
more complex closure


641
00:29:16,486 --> 00:29:19,846
that determines whether the sum
of a number's digits is even.


642
00:29:21,156 --> 00:29:24,956
Trailing closure syntax ensures
that even complex closures


643
00:29:24,956 --> 00:29:28,776
with multiline functionality
read naturally and elegantly.


644
00:29:29,316 --> 00:29:34,006
Now, the filterInts function is
pretty useful if all you want


645
00:29:34,006 --> 00:29:37,326
to do is filter integers,
but what if you want


646
00:29:37,326 --> 00:29:39,196
to filter arrays of other
types, like strings.


647
00:29:40,506 --> 00:29:42,566
For example, say you
have an array of names


648
00:29:42,916 --> 00:29:45,376
and you want a filtered array
that contains only the names


649
00:29:45,376 --> 00:29:47,426
that have less than a
certain number of characters.


650
00:29:48,776 --> 00:29:51,006
You could do this by writing
a filter string function


651
00:29:51,006 --> 00:29:51,976
like the one you see here,


652
00:29:52,776 --> 00:29:54,956
and since you've already
written a filterInts function,


653
00:29:55,466 --> 00:29:58,166
let's see whether you can
reuse any of that logic.


654
00:29:59,316 --> 00:30:01,536
Well, first, you'd obviously
want to do some bookkeeping


655
00:30:01,766 --> 00:30:03,226
and change all the
places that refer


656
00:30:03,226 --> 00:30:05,246
to numbers to refer to strings.


657
00:30:06,566 --> 00:30:08,036
And next you need to change all


658
00:30:08,036 --> 00:30:11,146
of the Int types
to be string types.


659
00:30:11,696 --> 00:30:14,766
And because the behavior


660
00:30:14,766 --> 00:30:16,436
of these two functions
is actually the same


661
00:30:16,436 --> 00:30:17,876
for both integers and strings,


662
00:30:18,346 --> 00:30:19,756
there's really nothing
else to do.


663
00:30:19,906 --> 00:30:21,336
They're essentially
the same function.


664
00:30:22,406 --> 00:30:23,646
And now you have this function


665
00:30:23,646 --> 00:30:24,946
that filters an array
of strings.


666
00:30:26,146 --> 00:30:28,456
Now, if you want a
filtered function that works


667
00:30:28,456 --> 00:30:32,186
for other kinds of types, you
can repeat this process over


668
00:30:32,186 --> 00:30:34,496
and over and over again
for each kind of type,


669
00:30:35,166 --> 00:30:37,536
but this would obviously
get boring pretty quickly.


670
00:30:38,696 --> 00:30:41,676
So instead, you can write
one function that works


671
00:30:41,676 --> 00:30:43,496
with arrays of any kind of type.


672
00:30:43,946 --> 00:30:45,436
This is called a
generic function.


673
00:30:46,456 --> 00:30:48,956
So let's look at
how you write one.


674
00:30:48,956 --> 00:30:51,106
Writing one is not
much different


675
00:30:51,106 --> 00:30:52,096
than what you've seen already.


676
00:30:53,016 --> 00:30:54,846
First you change the
names to be more generic.


677
00:30:55,226 --> 00:30:58,176
So, for example, the function's
name is simply filter,


678
00:30:58,176 --> 00:31:00,536
rather than filterInts
or filterStrings.


679
00:31:01,716 --> 00:31:04,406
Next, and more importantly, you
need to fill in the placeholders


680
00:31:04,406 --> 00:31:07,266
that you see here with
the type of the elements,


681
00:31:07,976 --> 00:31:09,906
but you don't know
what that type is yet.


682
00:31:10,956 --> 00:31:13,666
So instead, what you really
want is a type parameter.


683
00:31:14,206 --> 00:31:16,986
The actual type is determined
when the function is called.


684
00:31:17,446 --> 00:31:19,836
Here we filled in
the placeholders


685
00:31:20,576 --> 00:31:22,746
with a generic type
parameter called element.


686
00:31:23,686 --> 00:31:25,066
And so that you can
tell the difference


687
00:31:25,066 --> 00:31:28,316
between type parameters and
actual pre existing types


688
00:31:28,316 --> 00:31:31,916
like strings or integers,
you write the type parameters


689
00:31:31,916 --> 00:31:34,996
up front inside of the
angle brackets right


690
00:31:34,996 --> 00:31:36,086
after the function's name.


691
00:31:36,866 --> 00:31:39,126
And now you have a generic
filter function that works


692
00:31:39,126 --> 00:31:44,566
with an array that
contains any type of values.


693
00:31:44,626 --> 00:31:47,126
You call this kind of function
in the same way as before.


694
00:31:47,486 --> 00:31:49,896
You don't need to specify the
type you want the function


695
00:31:49,896 --> 00:31:51,976
to work with because
it's all inferred


696
00:31:51,976 --> 00:31:54,586
from the values you pass in.


697
00:31:54,786 --> 00:31:56,816
Filtering is such
a useful operation


698
00:31:56,816 --> 00:32:00,226
that the Swift standard library
has a filter method that works


699
00:32:00,226 --> 00:32:02,136
with any kind of
sequence or collection.


700
00:32:02,946 --> 00:32:05,366
It works in basically
the same way


701
00:32:05,366 --> 00:32:08,736
as the filter function you just
saw, except that it's a method


702
00:32:08,736 --> 00:32:10,416
so you call it using
dot notation,


703
00:32:10,816 --> 00:32:12,786
names.filter, as you see here.


704
00:32:13,436 --> 00:32:16,586
The Swift standard
library actually has lots


705
00:32:16,586 --> 00:32:19,356
of other methods that take
closures as arguments.


706
00:32:19,966 --> 00:32:22,456
And another really useful
one is the map method,


707
00:32:22,806 --> 00:32:24,956
and it also works with any
sequence or collection.


708
00:32:25,336 --> 00:32:29,196
Map returns a new array
that contains the result


709
00:32:29,196 --> 00:32:30,896
of a plan enclosure
to each element.


710
00:32:31,396 --> 00:32:33,636
So here's an example that
calls map on the array


711
00:32:33,636 --> 00:32:35,006
of short names from above.


712
00:32:35,226 --> 00:32:38,276
It passes a closure that
simply upper cases each string.


713
00:32:40,656 --> 00:32:42,496
You can even chain
these together


714
00:32:42,496 --> 00:32:44,556
to perform multiple operations.


715
00:32:44,946 --> 00:32:46,816
So, for example, you can
perform the filtering


716
00:32:46,816 --> 00:32:48,966
and the upper casing
in one expression.


717
00:32:49,596 --> 00:32:52,036
By chaining these two
method calls together using


718
00:32:52,036 --> 00:32:52,716
dot notation.


719
00:32:53,266 --> 00:32:55,926
The filtering happens first,
and then map is called


720
00:32:55,926 --> 00:32:56,976
on the filtered array,


721
00:32:57,246 --> 00:32:59,616
which then finally returns
the upper cased strings.


722
00:33:01,546 --> 00:33:02,976
And this reads nicely even


723
00:33:02,976 --> 00:33:05,126
when you're using the
trailing closure syntax.


724
00:33:05,636 --> 00:33:09,706
So the combination of closures
and functions that take them


725
00:33:09,706 --> 00:33:13,596
as arguments makes it possible
to write really complex,


726
00:33:14,426 --> 00:33:18,226
powerful code in a concise
yet highly expressive way.


727
00:33:18,956 --> 00:33:21,186
So we've looked at
functions and closures,


728
00:33:21,186 --> 00:33:23,026
and even a bit of
generic functions.


729
00:33:23,296 --> 00:33:25,606
I'd like to invite Alex
on stage to tell you all


730
00:33:25,606 --> 00:33:26,976
about data types in Swift.


731
00:33:27,516 --> 00:33:33,906
[ Applause ]


732
00:33:34,406 --> 00:33:35,096
>> Thanks, Brian.


733
00:33:36,236 --> 00:33:38,816
You've seen how to use
existing data types in Swift.


734
00:33:39,626 --> 00:33:41,066
Now let's take a look at how


735
00:33:41,066 --> 00:33:44,426
to create some data
types of our own.


736
00:33:44,676 --> 00:33:46,136
Let's start with structures.


737
00:33:46,766 --> 00:33:48,856
You create one like this.


738
00:33:49,086 --> 00:33:51,476
You write the struct
keyword followed


739
00:33:51,476 --> 00:33:52,726
by the name of a structure.


740
00:33:53,206 --> 00:33:54,486
Here, rectangle.


741
00:33:55,896 --> 00:34:01,726
Then inside the curly braces
you write the properties


742
00:34:01,726 --> 00:34:02,566
of the structure.


743
00:34:03,776 --> 00:34:07,356
Properties use the same
syntax you've seen before


744
00:34:07,356 --> 00:34:09,315
for variables and constants.


745
00:34:10,876 --> 00:34:14,456
Both properties here have
the value assigned as part


746
00:34:14,456 --> 00:34:17,735
of the declaration, so
you can create a rectangle


747
00:34:18,136 --> 00:34:20,356
by just writing rectangle,
the name,


748
00:34:21,206 --> 00:34:22,936
followed by a pair
of parentheses.


749
00:34:24,005 --> 00:34:27,726
And to access the properties,
you use dot notation.


750
00:34:29,735 --> 00:34:33,766
You don't have to provide a
value for a property as part


751
00:34:33,766 --> 00:34:34,996
of the types declaration.


752
00:34:35,496 --> 00:34:37,636
In fact, most of
the time you don't.


753
00:34:38,386 --> 00:34:43,176
More often, you write just the
type and then you set the value


754
00:34:43,275 --> 00:34:44,666
when you create the instance.


755
00:34:46,206 --> 00:34:47,846
So another property


756
00:34:47,846 --> 00:34:51,366
of a rectangle besides its
dimensions is its area.


757
00:34:52,636 --> 00:34:54,966
You wouldn't want to
store the area though.


758
00:34:55,166 --> 00:34:58,736
You'd have to update it every
time the dimensions changed.


759
00:34:59,586 --> 00:35:03,976
What you want is a property
whose value is calculated right


760
00:35:03,976 --> 00:35:06,456
at the point you need
it and you can do


761
00:35:06,456 --> 00:35:08,706
that using a computed property.


762
00:35:10,206 --> 00:35:14,996
To make a computed property,
after the property's name


763
00:35:15,096 --> 00:35:19,216
and its type, you write a
function body that's responsible


764
00:35:19,216 --> 00:35:23,476
for computing and returning the
current value of the function.


765
00:35:24,766 --> 00:35:27,536
Even though it's computed
rather than being stored,


766
00:35:27,746 --> 00:35:30,266
you still access it
using dot notation.


767
00:35:31,776 --> 00:35:33,796
There's more that you
can do with properties.


768
00:35:34,476 --> 00:35:38,936
You can have setters and
observers, and you can find


769
00:35:38,936 --> 00:35:42,786
out information about those
in the Properties chapter


770
00:35:43,326 --> 00:35:45,386
of the Swift Programming
Language.


771
00:35:47,716 --> 00:35:50,956
Just like you can define
properties on a structure,


772
00:35:51,346 --> 00:35:52,936
you can also define methods.


773
00:35:54,276 --> 00:35:57,666
They use the same syntax you've
seen already for functions.


774
00:35:58,976 --> 00:36:03,546
And just like properties, you
access them using dot notation


775
00:36:03,786 --> 00:36:08,416
when you need to call them.


776
00:36:08,616 --> 00:36:12,286
You've seen this syntax a few
times to create a rectangle.


777
00:36:13,066 --> 00:36:15,506
Let's look at what it does
in a little bit more detail.


778
00:36:17,256 --> 00:36:20,076
It looks a little bit
like a function call


779
00:36:20,226 --> 00:36:21,736
because of the parenthesis,


780
00:36:22,226 --> 00:36:24,356
but it's actually
calling an initializer.


781
00:36:25,136 --> 00:36:29,556
So far we've been using a
special initializer called a


782
00:36:29,556 --> 00:36:32,946
member wise initializer
that Swift implements


783
00:36:33,056 --> 00:36:34,826
for you on structures.


784
00:36:35,766 --> 00:36:37,926
Here's what it would
look like if you write


785
00:36:37,926 --> 00:36:39,986
that initializer out explicitly.


786
00:36:41,276 --> 00:36:46,036
You write the init keyword and
then inside you set a value


787
00:36:46,126 --> 00:36:47,796
for the rectangle's properties.


788
00:36:49,046 --> 00:36:52,036
Notice that there are two
things here called width.


789
00:36:52,686 --> 00:36:57,676
There's a property and there's
a parameter, and you write self.


790
00:36:58,356 --> 00:37:00,706
to explicitly refer
to the property.


791
00:37:01,646 --> 00:37:04,406
So that's how you write
your own initializer.


792
00:37:06,516 --> 00:37:10,036
There's enough code in
this rectangle structure


793
00:37:10,396 --> 00:37:14,536
that it could benefit from some
organization, and one way to do


794
00:37:14,536 --> 00:37:17,146
that in Swift is
using extensions.


795
00:37:18,136 --> 00:37:21,196
An extension lets
you add functionality


796
00:37:21,456 --> 00:37:22,626
to an existing type.


797
00:37:23,926 --> 00:37:28,626
In Swift you can use extensions
to divide up your code.


798
00:37:29,846 --> 00:37:33,626
Core functionality can go in
the structure's declaration


799
00:37:33,626 --> 00:37:39,256
and additional functionality can
go in one or more extensions.


800
00:37:40,586 --> 00:37:43,216
You're not limited to
extending your own types.


801
00:37:43,916 --> 00:37:47,516
If you need to, you can extend
types from other places,


802
00:37:47,856 --> 00:37:51,246
such as foundation or
the standard library.


803
00:37:53,306 --> 00:37:56,386
You saw earlier how you
can make a generic function


804
00:37:56,836 --> 00:37:59,046
which performs the
same operations


805
00:37:59,486 --> 00:38:00,926
on data of different types.


806
00:38:02,056 --> 00:38:04,326
You can also make
a generic structure


807
00:38:04,826 --> 00:38:07,206
which contains data
of different types.


808
00:38:08,336 --> 00:38:10,076
The syntax looks very similar.


809
00:38:10,646 --> 00:38:15,186
You still have the generic type
parameters inside angle brackets


810
00:38:15,346 --> 00:38:16,026
after the name.


811
00:38:16,776 --> 00:38:20,166
This example attaches
a name to an array


812
00:38:20,166 --> 00:38:21,816
of some kind of element.


813
00:38:23,216 --> 00:38:26,326
This would be a useful data
structure, for example,


814
00:38:26,586 --> 00:38:31,386
to populate a table view that
has sections with heading names.


815
00:38:31,856 --> 00:38:35,956
You create a generic
structure instance just


816
00:38:35,956 --> 00:38:39,606
like an instance
of another type.


817
00:38:39,806 --> 00:38:43,076
Here you can see if you
write the type annotations,


818
00:38:44,236 --> 00:38:47,896
board games and primes
have different types.


819
00:38:49,016 --> 00:38:51,196
One is an array of strings


820
00:38:51,436 --> 00:38:53,586
and the other is an
array of integers.


821
00:38:54,066 --> 00:38:56,256
They have different
element types


822
00:38:57,076 --> 00:39:00,116
so they are different types.


823
00:39:00,296 --> 00:39:02,016
You don't have to
write the arrays.


824
00:39:02,746 --> 00:39:06,076
Swift infers what
element is automatically.


825
00:39:08,036 --> 00:39:09,606
So that's structures.


826
00:39:11,356 --> 00:39:14,596
Another data type
in Swift is classes.


827
00:39:15,816 --> 00:39:19,106
You write class before
the name, but everything


828
00:39:19,106 --> 00:39:21,256
about structures still applies.


829
00:39:21,706 --> 00:39:25,376
Properties, methods,
initializers, and so on.


830
00:39:26,086 --> 00:39:30,826
So why would you want
to create a class?


831
00:39:30,986 --> 00:39:35,286
One reason is that your code
can refer to the same instance


832
00:39:35,316 --> 00:39:38,266
of a class from several
different places,


833
00:39:38,346 --> 00:39:41,236
and that's different than
the behavior you have


834
00:39:41,236 --> 00:39:42,196
for structures.


835
00:39:42,736 --> 00:39:45,926
A structure acts
like one big value.


836
00:39:46,936 --> 00:39:51,476
For example, in a game, if
you make a score for player1,


837
00:39:52,436 --> 00:39:55,466
and then give player2
the same score,


838
00:39:55,846 --> 00:39:58,076
you have two independent scores.


839
00:39:59,066 --> 00:40:03,756
Changing player2's score
doesn't change player1's score.


840
00:40:04,936 --> 00:40:10,166
However, both players need to
refer to the same file on disk


841
00:40:10,646 --> 00:40:12,616
when they log their high scores.


842
00:40:13,936 --> 00:40:18,786
Since it's a class, that's
the behavior that you get.


843
00:40:18,786 --> 00:40:23,256
When player2 gets a new
high score and then logs it


844
00:40:23,256 --> 00:40:26,996
to the file, both
players see the change.


845
00:40:28,596 --> 00:40:32,146
If you're coming from another
object oriented language,


846
00:40:32,476 --> 00:40:35,256
you might be used to
writing a lot of classes,


847
00:40:35,916 --> 00:40:38,426
and in Swift you don't
need to write them


848
00:40:38,526 --> 00:40:40,086
as often as you might think.


849
00:40:41,346 --> 00:40:45,826
Anytime it makes sense to check
for equality or to make a copy,


850
00:40:46,936 --> 00:40:50,016
you usually want a value
type like a structure.


851
00:40:51,316 --> 00:40:55,896
For more information about how
and why to use value types,


852
00:40:56,256 --> 00:40:58,756
there's a great talk
you can check out.


853
00:40:59,416 --> 00:41:03,036
Another reason to use
classes is when you need


854
00:41:03,036 --> 00:41:05,336
to subclass an existing class.


855
00:41:06,616 --> 00:41:09,716
For example, suppose
you have a framework


856
00:41:09,976 --> 00:41:12,766
that gives you this
fish class with sort


857
00:41:12,766 --> 00:41:14,706
of core fish functionality.


858
00:41:16,096 --> 00:41:18,656
You can subclass it
to add functionality,


859
00:41:19,296 --> 00:41:22,166
like a FlyingFish can
add a flying method.


860
00:41:23,176 --> 00:41:27,786
You indicate that this is a
subclass by writing colon fish.


861
00:41:28,636 --> 00:41:31,836
Subclasses can also
override a method


862
00:41:32,326 --> 00:41:34,346
to provide their
own implementation.


863
00:41:35,536 --> 00:41:37,136
Like this ComplainingFish.


864
00:41:37,656 --> 00:41:41,816
It swims like a normal fish, it
just complains about it first.


865
00:41:44,666 --> 00:41:49,706
You write super.swim to call
the superclass' implementation.


866
00:41:50,826 --> 00:41:52,706
This code doesn't compile yet.


867
00:41:54,006 --> 00:41:56,306
When you override
a method in Swift,


868
00:41:56,746 --> 00:42:00,816
you have to mark it
explicitly by writing override,


869
00:42:01,666 --> 00:42:03,326
and now this code works.


870
00:42:04,616 --> 00:42:08,666
Just like it's an error to
override something by accident,


871
00:42:09,206 --> 00:42:12,076
it's also an error
to write override


872
00:42:12,346 --> 00:42:14,316
when you don't override
anything.


873
00:42:15,766 --> 00:42:19,656
That means if you misspell a
method name that you're trying


874
00:42:19,656 --> 00:42:22,066
to override, Swift tells you


875
00:42:22,066 --> 00:42:26,266
about the error right
at compile time.


876
00:42:26,446 --> 00:42:29,146
A segue can also
provide an initializer.


877
00:42:30,436 --> 00:42:35,056
For example, fish that has an
initializer that takes a name.


878
00:42:35,946 --> 00:42:38,686
ComplainingFish needs
an initializer


879
00:42:38,806 --> 00:42:41,006
with both a name
and a complaint.


880
00:42:42,796 --> 00:42:46,686
Inside the initializer
you set the initial value


881
00:42:46,686 --> 00:42:49,506
for the properties
declared by the subclass,


882
00:42:50,376 --> 00:42:53,726
and then you call super.init


883
00:42:54,866 --> 00:42:58,096
to let the superclass
finish the initialization.


884
00:42:59,536 --> 00:43:02,186
There's more you can
do with initializers,


885
00:43:02,516 --> 00:43:04,296
especially around classes.


886
00:43:05,146 --> 00:43:09,396
You can read all about it
in the Initializers chapter


887
00:43:09,616 --> 00:43:11,676
of the Swift Programming
Language.


888
00:43:13,306 --> 00:43:15,596
You've seen how you
can use subclasses.


889
00:43:16,026 --> 00:43:18,746
Now let's talk about
a subclassing problem.


890
00:43:20,366 --> 00:43:22,716
Continuing the game example,


891
00:43:23,066 --> 00:43:25,456
suppose you have this
player base class.


892
00:43:26,586 --> 00:43:28,686
Since every player
can take a turn,


893
00:43:29,056 --> 00:43:31,936
there's a method to do that.


894
00:43:32,006 --> 00:43:33,706
You have two kinds of players.


895
00:43:34,576 --> 00:43:37,756
You have a HumanPlayer
class, which takes its turn


896
00:43:38,016 --> 00:43:39,826
by showing UI to the user.


897
00:43:40,606 --> 00:43:44,476
And you have a ComputerPlayer
class which takes its turn


898
00:43:44,736 --> 00:43:47,016
by finding the best legal move.


899
00:43:48,276 --> 00:43:51,236
So the question then
is what goes


900
00:43:51,306 --> 00:43:53,196
in the base class
implementation?


901
00:43:54,556 --> 00:43:57,656
Well, there's no shared behavior


902
00:43:57,966 --> 00:44:00,486
between human and
computer players.


903
00:44:01,126 --> 00:44:05,296
There isn't any shared
code to factor out.


904
00:44:05,296 --> 00:44:10,066
And in the surrounding code you
would never want an instance


905
00:44:10,256 --> 00:44:11,536
of the player base class.


906
00:44:12,586 --> 00:44:15,596
So this method should
never be called.


907
00:44:16,306 --> 00:44:20,636
The only reasonable thing you
could write here is some sort


908
00:44:20,636 --> 00:44:24,586
of fatal error to help
you catch mistakes early


909
00:44:24,586 --> 00:44:25,846
in the development process.


910
00:44:26,596 --> 00:44:31,966
All the player class is doing
is describing what it means


911
00:44:32,066 --> 00:44:36,216
to be a player, that every
player can take a turn.


912
00:44:37,026 --> 00:44:39,726
It's a sort of blueprint
for players.


913
00:44:41,276 --> 00:44:43,696
In Swift you express this kind


914
00:44:43,696 --> 00:44:46,696
of relationship using
a protocol.


915
00:44:47,436 --> 00:44:51,636
Protocols specify requirements
like methods and properties.


916
00:44:52,736 --> 00:44:56,086
They're like interfaces
or abstract classes


917
00:44:56,396 --> 00:44:58,566
that you might know
from other languages.


918
00:44:59,836 --> 00:45:02,526
You make one using
the protocol keyword.


919
00:45:03,626 --> 00:45:07,506
And because it describes
requirements for other types


920
00:45:07,506 --> 00:45:11,156
to fulfill, you don't
provide an implementation.


921
00:45:12,656 --> 00:45:17,516
Types conform to a protocol by
providing that implementation


922
00:45:18,426 --> 00:45:22,446
and you declare conformance
by writing : player,


923
00:45:23,006 --> 00:45:25,166
just like you do when
there's a superclass.


924
00:45:25,996 --> 00:45:30,026
At this point you're
not subclassing anymore


925
00:45:30,516 --> 00:45:33,496
so these methods are
not overriding anything.


926
00:45:34,916 --> 00:45:36,896
So you don't write override.


927
00:45:39,256 --> 00:45:42,856
There's no real reason these
need to be classes anymore,


928
00:45:43,406 --> 00:45:45,096
so let's make them structures.


929
00:45:46,616 --> 00:45:50,346
And let's take a closer
look at HumanPlayer.


930
00:45:50,936 --> 00:45:56,106
It has a few other properties,
like a name and a score.


931
00:45:56,106 --> 00:46:02,146
And if you make an instance of
player, you can print it out.


932
00:46:02,416 --> 00:46:04,566
You get a default
description here


933
00:46:05,106 --> 00:46:08,266
because the standard
library has a conversion


934
00:46:08,546 --> 00:46:12,356
from any type to a string.


935
00:46:12,546 --> 00:46:15,336
But what if you wanted to
customize the conversion


936
00:46:15,526 --> 00:46:17,236
to print a nicer description?


937
00:46:18,146 --> 00:46:21,846
The standard library also
has a protocol called


938
00:46:21,846 --> 00:46:23,556
CustomStringConvertible


939
00:46:24,016 --> 00:46:27,826
which lets you provide a custom
description, and here's what


940
00:46:27,826 --> 00:46:29,216
that protocol looks like.


941
00:46:30,196 --> 00:46:33,496
It has one requirement --
a description property.


942
00:46:34,996 --> 00:46:38,656
Any type that conforms
to this protocol uses the


943
00:46:38,656 --> 00:46:39,736
custom description.


944
00:46:40,766 --> 00:46:44,026
Okay. So where should
you implement the


945
00:46:44,026 --> 00:46:45,166
description property.


946
00:46:46,656 --> 00:46:50,236
Remember from earlier how you
can organize your code using


947
00:46:50,236 --> 00:46:52,866
extensions with core
functionality


948
00:46:53,306 --> 00:46:54,756
in type declarations,


949
00:46:55,146 --> 00:46:57,996
and additional functionality
in extensions.


950
00:46:59,246 --> 00:47:02,706
Having a custom string
conversion definitely falls


951
00:47:02,706 --> 00:47:04,196
into the second category.


952
00:47:04,506 --> 00:47:08,446
It's not core functionality, so
let's put it in an extension.


953
00:47:09,126 --> 00:47:13,316
Here's how you extend a type
to add protocol conformance.


954
00:47:14,536 --> 00:47:17,486
You write colon
CustomStringConvertible


955
00:47:17,786 --> 00:47:18,746
in the first line.


956
00:47:19,996 --> 00:47:23,156
And then you implement the
requirements inside the


957
00:47:23,156 --> 00:47:24,186
extension body.


958
00:47:26,196 --> 00:47:29,226
Now when you call print,
you get the customized


959
00:47:29,226 --> 00:47:30,266
string conversion.


960
00:47:31,656 --> 00:47:35,576
There's a lot that you can
do in Swift using protocols


961
00:47:35,576 --> 00:47:39,756
and extensions to organize your
code and create abstractions.


962
00:47:40,336 --> 00:47:43,706
For more information
check out this talk


963
00:47:43,956 --> 00:47:47,756
on Protocol Oriented
Programming from 2015.


964
00:47:48,956 --> 00:47:54,376
That brings us to the last data
type in Swift -- enumerations.


965
00:47:55,356 --> 00:47:59,026
You use an enumeration when
there's a list of values


966
00:47:59,026 --> 00:48:00,496
that you know ahead of time.


967
00:48:01,336 --> 00:48:04,056
Here's an enumeration
that supports left


968
00:48:04,246 --> 00:48:07,436
and right alignment for text.


969
00:48:07,626 --> 00:48:09,126
When you use an enumeration,


970
00:48:09,546 --> 00:48:12,796
you use dot notation
to access its cases.


971
00:48:14,056 --> 00:48:17,726
Here there are only two
cases, so it's still readable


972
00:48:17,936 --> 00:48:19,476
if you write them on one line.


973
00:48:21,336 --> 00:48:24,886
Because an enumeration has
a list of possible values,


974
00:48:25,176 --> 00:48:29,906
it's very common to use one
with a switch, one switch case


975
00:48:30,156 --> 00:48:33,356
for each enumeration case.


976
00:48:33,826 --> 00:48:37,266
Writing alignment over and
over is a little repetitive


977
00:48:37,776 --> 00:48:39,596
and here it's not necessary.


978
00:48:41,076 --> 00:48:43,596
The switch is considering
textAlignment,


979
00:48:44,246 --> 00:48:46,546
so the only possible
values to check


980
00:48:46,666 --> 00:48:50,356
for are enumeration cases
from that alignment.


981
00:48:51,366 --> 00:48:54,416
That means you can omit
the enumeration name


982
00:48:54,906 --> 00:48:56,726
and write just .left.


983
00:48:58,296 --> 00:49:01,776
Also, notice that there's
no default case here.


984
00:49:02,956 --> 00:49:05,336
That's for the same
reason you saw earlier.


985
00:49:06,246 --> 00:49:10,116
The switch already covers
every possible alignment value,


986
00:49:10,706 --> 00:49:13,926
so there's nothing left for
a default case to handle.


987
00:49:15,256 --> 00:49:18,766
Omitting the default case
has a nice advantage.


988
00:49:19,256 --> 00:49:23,306
If you come back later and
add a new enumeration case,


989
00:49:23,776 --> 00:49:28,036
but forget to update the switch,
Swift will highlight the error


990
00:49:28,666 --> 00:49:30,486
until you add the missing code.


991
00:49:32,476 --> 00:49:34,446
Now let's take a quick look


992
00:49:34,786 --> 00:49:38,146
at two more things you
can do with enumerations.


993
00:49:40,796 --> 00:49:44,786
You can associate values
with each enumeration case.


994
00:49:45,716 --> 00:49:51,206
For example, the alignment can
specify how much padding to use


995
00:49:52,616 --> 00:49:55,376
and you can get that
padding value back


996
00:49:55,586 --> 00:50:00,536
out as part of the switch case.


997
00:50:00,736 --> 00:50:05,796
You can also give each
enumeration case a raw value


998
00:50:06,006 --> 00:50:09,776
from some other type, such
as a string or an integer,


999
00:50:11,376 --> 00:50:14,546
which lets you improve
type safety in your code


1000
00:50:15,076 --> 00:50:18,566
by using enumerations
instead of string constants.


1001
00:50:21,276 --> 00:50:25,896
You've seen a lot of Swift this
afternoon, but there isn't time


1002
00:50:25,896 --> 00:50:27,096
to show you everything.


1003
00:50:28,036 --> 00:50:31,546
One last thing I'd like to
show you is error handling.


1004
00:50:33,416 --> 00:50:38,996
In Swift you can use an
enumeration to describe errors.


1005
00:50:40,556 --> 00:50:43,216
You use throws to
mark a function


1006
00:50:43,366 --> 00:50:44,836
that can throw an error.


1007
00:50:46,836 --> 00:50:51,676
You write defer before a block
of code that must be executed,


1008
00:50:51,906 --> 00:50:53,586
whether or not there's an error,


1009
00:50:54,176 --> 00:50:58,466
and that execution happens
just before exiting scope,


1010
00:50:58,466 --> 00:51:00,106
such as returning
from a function.


1011
00:51:03,446 --> 00:51:06,496
Before calling code that
might throw an error,


1012
00:51:06,836 --> 00:51:11,546
you mark it with try,
and you can catch


1013
00:51:11,716 --> 00:51:14,786
and throw errors
using catch and throw.


1014
00:51:16,056 --> 00:51:18,586
For all the details
about error handling,


1015
00:51:19,196 --> 00:51:21,386
take a look at the
Error Handling chapter


1016
00:51:21,786 --> 00:51:23,746
in the Swift Programming
Language.


1017
00:51:25,586 --> 00:51:29,396
You can find a link to that
book and other resources here.


1018
00:51:31,356 --> 00:51:34,326
There are lots of other
great Swift talks to check


1019
00:51:34,326 --> 00:51:36,956
out later this week or on video.


1020
00:51:37,736 --> 00:51:37,976
Thank you.


1021
00:51:38,516 --> 00:51:46,150
[ Applause ]

