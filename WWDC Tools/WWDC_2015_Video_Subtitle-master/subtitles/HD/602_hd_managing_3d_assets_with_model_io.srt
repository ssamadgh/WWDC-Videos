1
00:00:25,046 --> 00:00:25,496
>> NICK PORCINO:
Hello, everybody.


2
00:00:25,796 --> 00:00:28,086
Welcome to managing 3D
Assets with Model I/O.


3
00:00:28,446 --> 00:00:31,796
I'm Nick Porcino in the image,
media, and graphics group.


4
00:00:33,576 --> 00:00:35,916
Today, I'm really excited


5
00:00:35,916 --> 00:00:38,756
to introduce the new Model
I/O framework to you.


6
00:00:38,976 --> 00:00:43,196
We are raising the bar on --
or actually we are enabling you


7
00:00:43,196 --> 00:00:46,586
to raise the bar on interactive
and realistic graphics.


8
00:00:46,996 --> 00:00:51,076
Up until now, the graphics
frameworks and hardware


9
00:00:51,076 --> 00:00:53,726
that you've been dealing
with come from an age


10
00:00:53,966 --> 00:00:56,966
when hardware was a lot
more limited than it is now.


11
00:00:57,426 --> 00:00:59,506
The thing you have in your
pocket is absolutely amazing.


12
00:01:00,166 --> 00:01:04,696
Now we got new frameworks that
enable you to get the power


13
00:01:04,696 --> 00:01:09,396
out to your users, but you
have to feed that framework


14
00:01:09,396 --> 00:01:11,056
with really good looking stuff.


15
00:01:11,636 --> 00:01:15,496
So in the new world of
really high performance


16
00:01:15,496 --> 00:01:21,106
and low overhead graphics APIs,
you need a way to get things


17
00:01:21,106 --> 00:01:23,796
that are realistic, realistic
means physically derived


18
00:01:23,796 --> 00:01:24,986
and physically based things.


19
00:01:25,556 --> 00:01:29,906
And so there's a lot of research
and knowledge that you need


20
00:01:30,056 --> 00:01:31,156
in order to pull that off.


21
00:01:31,696 --> 00:01:33,776
You need to understand
the physics of cameras,


22
00:01:33,816 --> 00:01:36,026
the physics of materials,
the physics of light


23
00:01:37,266 --> 00:01:39,656
and you can certainly go out
and read all of that stuff


24
00:01:39,656 --> 00:01:41,046
and I encourage you to do so.


25
00:01:41,406 --> 00:01:43,306
And implementing each one


26
00:01:43,306 --> 00:01:45,816
of those things requires a
fair amount of heavy work,


27
00:01:45,816 --> 00:01:49,046
a fair amount of reading and
then a whole lot of integration.


28
00:01:49,996 --> 00:01:53,736
So what we have done with
Model I/O is we've gone out,


29
00:01:54,256 --> 00:01:55,836
we have done a whole
bunch of research,


30
00:01:55,836 --> 00:01:57,496
we have done a whole
bunch of integration,


31
00:01:57,986 --> 00:02:01,216
and we've prepared a unified
set of data structures


32
00:02:01,216 --> 00:02:03,286
to describe these things
in a consistent way


33
00:02:03,286 --> 00:02:04,886
and an easy to use API.


34
00:02:06,456 --> 00:02:10,045
So as it says, Model
I/O is a framework


35
00:02:10,045 --> 00:02:12,166
for handling 3D assets and data.


36
00:02:12,986 --> 00:02:17,896
So at its most basic level,
you can use Model I/O to bring


37
00:02:17,896 --> 00:02:20,746
in common file formats
and export them.


38
00:02:21,666 --> 00:02:25,676
You can describe in a physically
realistic way lighting,


39
00:02:25,906 --> 00:02:27,366
materials, environments.


40
00:02:28,176 --> 00:02:31,336
You can get assets and
art work from your artists


41
00:02:31,666 --> 00:02:35,136
into Model I/O, do some
interesting processes


42
00:02:35,136 --> 00:02:37,856
which we'll get into
as the talk progresses.


43
00:02:38,506 --> 00:02:43,546
And there's a lot of
tools now that you can get


44
00:02:43,636 --> 00:02:44,696
that are focused


45
00:02:44,696 --> 00:02:47,396
on physically-based
rendering and materials.


46
00:02:47,836 --> 00:02:50,776
And Model I/O gives you
access to those things


47
00:02:50,886 --> 00:02:53,966
in your own pipelines.


48
00:02:54,066 --> 00:02:58,686
Model I/O is integrated into
Xcode 7, and the GameKit APIs,


49
00:02:58,856 --> 00:03:03,266
it's on iOS 9, and OS 10.11.


50
00:03:04,796 --> 00:03:10,176
So in a nut shell, the
big green box there is


51
00:03:10,176 --> 00:03:12,206
where Model I/O fits
in your framework


52
00:03:12,576 --> 00:03:13,946
or in your application.


53
00:03:14,566 --> 00:03:16,706
We start in the contact
creation tool.


54
00:03:16,706 --> 00:03:17,836
Your artist does some great work


55
00:03:17,836 --> 00:03:20,616
and you import it
into Model I/O.


56
00:03:21,196 --> 00:03:26,596
Model I/O then does the annoying
and tedious and error-prone step


57
00:03:26,816 --> 00:03:32,126
of creating buffers for various
frameworks to render quickly.


58
00:03:32,566 --> 00:03:34,626
So those frameworks
that we're supporting


59
00:03:34,826 --> 00:03:40,346
out of the box are
SceneKit, Metal, and OpenGL.


60
00:03:40,536 --> 00:03:44,846
Now Model I/O doesn't just
load files and save them.


61
00:03:45,636 --> 00:03:48,466
It also lets you
perform useful operations


62
00:03:48,596 --> 00:03:50,716
that are time consuming
or whatever,


63
00:03:51,096 --> 00:03:53,526
that serve to improve
the look of your assets,


64
00:03:54,186 --> 00:03:56,466
and you can take an asset.


65
00:03:56,776 --> 00:03:59,316
You can do one of these baking
operations which we'll get into,


66
00:03:59,576 --> 00:04:02,246
bring it back into the unified
representation and Model I/O


67
00:04:03,086 --> 00:04:07,156
and get it off to your
hardware ready buffers.


68
00:04:07,316 --> 00:04:12,786
Also, you can just complete the
loop here, export your asset,


69
00:04:12,786 --> 00:04:15,236
out of Model I/O after
you did something exotic


70
00:04:15,326 --> 00:04:18,216
that Model I/O provides for
you, send it all the way back


71
00:04:18,216 --> 00:04:21,076
to the content creation
tool, let the artist noodle


72
00:04:21,076 --> 00:04:23,076
around on it and perhaps
add some, you know,


73
00:04:23,076 --> 00:04:24,346
special sweetness or whatever,


74
00:04:24,346 --> 00:04:26,866
and then you can just
keep iterating the cycle


75
00:04:26,866 --> 00:04:29,866
until you achieve the
look and level of quality


76
00:04:29,866 --> 00:04:31,786
that you need for your app.


77
00:04:32,836 --> 00:04:34,926
So what we're going to talk


78
00:04:34,926 --> 00:04:37,616
about today is what
are the features?


79
00:04:38,576 --> 00:04:39,466
What are the data types?


80
00:04:39,466 --> 00:04:40,736
Where does the physical
motivation


81
00:04:40,736 --> 00:04:41,996
for those data types come from?


82
00:04:42,666 --> 00:04:45,056
And we're going to
talk about support


83
00:04:45,056 --> 00:04:47,506
for various geometrical
features and voxels


84
00:04:48,136 --> 00:04:52,736
and some advanced lighting
and our baking steps.


85
00:04:57,096 --> 00:04:57,426
All right.


86
00:04:57,516 --> 00:05:01,426
So here we go, bread and
butter, reading things in.


87
00:05:01,426 --> 00:05:05,846
So import formats,
we start with some


88
00:05:05,846 --> 00:05:09,116
of the most commonly
used formats.


89
00:05:11,156 --> 00:05:15,896
Alembic is a very high
performance format and it comes


90
00:05:15,896 --> 00:05:17,046
from the film industry


91
00:05:17,046 --> 00:05:19,456
and is heavily uses
in games now as well.


92
00:05:20,026 --> 00:05:23,906
And it is the most modern of
the formats listed up here.


93
00:05:23,906 --> 00:05:28,686
It includes information on
animation and material bindings


94
00:05:28,686 --> 00:05:30,806
and all kinds of
interesting things.


95
00:05:31,316 --> 00:05:35,236
Polygon is the standard polygon
format that you are going to get


96
00:05:35,236 --> 00:05:36,786
out of a lot of academic
research.


97
00:05:37,286 --> 00:05:42,416
Triangles are commonly
originated and ingested by CAD


98
00:05:42,416 --> 00:05:43,596
and CAM applications


99
00:05:43,596 --> 00:05:46,886
and Wavefront .obj
is universally


100
00:05:46,886 --> 00:05:47,666
available everywhere.


101
00:05:48,376 --> 00:05:51,336
And for exporting at the
moment, you can export


102
00:05:51,336 --> 00:05:57,246
out to your CAD/CAM
stuff and [inaudible].


103
00:05:57,756 --> 00:05:59,746
So importing is that easy.


104
00:06:00,016 --> 00:06:02,846
You get an MDLAsset,
by initWithURL.


105
00:06:03,416 --> 00:06:07,026
And you can send it back out
somewhere with exportAssetToURL.


106
00:06:09,376 --> 00:06:12,366
So just a few words
about physical realism


107
00:06:12,826 --> 00:06:16,376
without getting super detailed.


108
00:06:16,616 --> 00:06:21,676
Lights, historically have had
like a position, and, you know,


109
00:06:21,676 --> 00:06:23,296
a cone angle and falloff


110
00:06:23,376 --> 00:06:26,446
and some other physically
unrealistic parameters


111
00:06:26,446 --> 00:06:28,766
that just are mathematically
united to the way hardware


112
00:06:28,766 --> 00:06:30,336
and graphics APIs used to be.


113
00:06:30,846 --> 00:06:36,046
What we are providing here
is access to IES profiles.


114
00:06:36,256 --> 00:06:39,516
Now, if you go to the
hardware store and find, like,


115
00:06:39,646 --> 00:06:41,056
a light fixture that
you really like.


116
00:06:41,106 --> 00:06:42,556
Like, say I really like
that light up there


117
00:06:42,556 --> 00:06:43,696
and I found it in the store.


118
00:06:43,696 --> 00:06:47,596
I can go to the manufacturers
website after reading the label


119
00:06:47,596 --> 00:06:51,106
on the side and I can
find an IES profile file


120
00:06:51,186 --> 00:06:55,016
which is a data file, where they
have done measurements all the


121
00:06:55,016 --> 00:06:56,886
way around the light
to get the irradiance


122
00:06:56,886 --> 00:06:57,846
from every different angle.


123
00:06:58,856 --> 00:07:02,836
We read that in into a so-called
light web, which is a set


124
00:07:02,836 --> 00:07:05,006
of data that's pretty easy
to load up into a shader.


125
00:07:05,336 --> 00:07:09,016
So if you want, you can have
physically motivated lights


126
00:07:09,236 --> 00:07:11,836
that match real world
lights in your shaders.


127
00:07:12,456 --> 00:07:14,716
Now, when you buy a light
at the hardware store,


128
00:07:14,976 --> 00:07:17,976
the light isn't specified
as an RGB value or whatever.


129
00:07:17,976 --> 00:07:20,336
It's specified as
a temperature like,


130
00:07:20,336 --> 00:07:21,756
you know 4,000K or whatever.


131
00:07:22,306 --> 00:07:25,496
So you can specify these heights
in degrees Kelvin as well.


132
00:07:25,976 --> 00:07:28,816
We also provide image based
lighting which is in play


133
00:07:28,936 --> 00:07:30,386
on the excavator there.


134
00:07:30,976 --> 00:07:35,286
The materials, historically,
everything has been Lambertian,


135
00:07:35,446 --> 00:07:38,316
which means fall off
according to angle,


136
00:07:38,806 --> 00:07:40,626
and with the Blinn-Phong
specular


137
00:07:40,626 --> 00:07:42,906
which means a plastically
shiny highlight.


138
00:07:43,426 --> 00:07:44,496
We also provide you


139
00:07:44,606 --> 00:07:47,996
with a baseline physical
bidirectional reflection


140
00:07:48,046 --> 00:07:52,796
function, or a BRDF which
is what you really need


141
00:07:53,016 --> 00:07:54,596
if you want real
world materials.


142
00:07:55,006 --> 00:08:00,256
And once again, that excavator
has got physical BDRF on it.


143
00:08:00,716 --> 00:08:03,366
Cameras, historically
have been pinhole cameras.


144
00:08:03,676 --> 00:08:06,816
We are describing them all the
way from the lens to the sensor


145
00:08:07,206 --> 00:08:09,366
and we are providing
you some utilities


146
00:08:09,366 --> 00:08:10,796
for processing environments


147
00:08:10,796 --> 00:08:12,926
from photographs and
procedural skies.


148
00:08:13,526 --> 00:08:19,616
Now, you are going to see
tools in Xcode to do baking,


149
00:08:19,966 --> 00:08:24,586
and what I'm telling you here
on this slide is that the tools


150
00:08:24,586 --> 00:08:26,206
that you have in Xcode


151
00:08:26,286 --> 00:08:29,086
to perform these operations are
available to you in Model I/O


152
00:08:29,086 --> 00:08:29,936
through the framework.


153
00:08:30,416 --> 00:08:31,976
So if you want to
make your own line --


154
00:08:32,176 --> 00:08:35,726
your own offline pipeline
to bake your own assets


155
00:08:35,726 --> 00:08:39,746
from beginning to end, in
giant batches or on a farm,


156
00:08:39,826 --> 00:08:41,306
all of those things
are available


157
00:08:41,916 --> 00:08:42,785
through the frameworks API.


158
00:08:43,556 --> 00:08:46,576
We have introduced voxels.


159
00:08:46,576 --> 00:08:50,796
So you can take a big old mesh
and turn it into giant cache


160
00:08:50,796 --> 00:08:52,576
of indexes that you can
associate your own data with.


161
00:08:53,076 --> 00:08:53,896
More on that later.


162
00:08:54,996 --> 00:08:56,996
Once again, it's
very straightforward,


163
00:08:57,276 --> 00:09:00,206
create your voxels from
an asset and find voxels


164
00:09:00,206 --> 00:09:01,086
in a particular region.


165
00:09:01,086 --> 00:09:03,706
You can do constructive
solid geometry


166
00:09:03,706 --> 00:09:06,926
and you can turn the voxels
back into a mesh using some type


167
00:09:06,926 --> 00:09:08,156
of smoothing algorithm.


168
00:09:08,426 --> 00:09:10,256
Some kind.


169
00:09:11,106 --> 00:09:16,186
So system integration, Model
I/O is integrated directly


170
00:09:16,976 --> 00:09:21,396
into SceneKit and it's
utilized in MetalKit and GLKit.


171
00:09:22,526 --> 00:09:26,616
Model I/O is used to do preview
in the Finder and in Quick Look.


172
00:09:26,676 --> 00:09:30,496
So you can go find an Alembic
.abc cache hit the space bar


173
00:09:30,496 --> 00:09:32,836
and it'll pop up in the Finder
and you can tumble your asset


174
00:09:32,836 --> 00:09:35,526
and preview it without
even opening up any type


175
00:09:35,526 --> 00:09:36,636
of auditioning environment.


176
00:09:36,806 --> 00:09:39,626
You can edit assets
in the Xcode.


177
00:09:39,626 --> 00:09:43,746
The excavator here is loaded
in Xcode in this picture.


178
00:09:44,276 --> 00:09:48,016
And Model I/O works in
Playgrounds and with Swift.


179
00:09:48,016 --> 00:09:48,566
All right.


180
00:09:50,396 --> 00:09:54,176
Down to the nitty-gritty
of data types.


181
00:09:55,276 --> 00:10:00,616
So MDLAsset is the thing
that you get from a URL


182
00:10:01,016 --> 00:10:02,826
and it's the big
overall container


183
00:10:02,826 --> 00:10:04,076
that you will often
be working with.


184
00:10:04,586 --> 00:10:07,786
It's an index container, you
know, for fast enumeration


185
00:10:07,786 --> 00:10:11,316
and stuff, it has transform
hierarchies in it, meshes,


186
00:10:11,586 --> 00:10:14,346
cameras and lights and you
can make them using the API


187
00:10:15,076 --> 00:10:17,166
or loading from a URL.


188
00:10:18,136 --> 00:10:21,836
So a typical asset that
you might pull out of


189
00:10:21,836 --> 00:10:23,946
like a big old Alembic file,
is going to have a whole bunch


190
00:10:23,946 --> 00:10:25,526
of interesting things in it.


191
00:10:25,916 --> 00:10:31,086
This particular example here
has got a couple of cameras


192
00:10:31,286 --> 00:10:35,136
and a light, a root
transform, the blue box


193
00:10:35,136 --> 00:10:36,486
over on the right there.


194
00:10:36,836 --> 00:10:39,786
And underneath it, are
the bits of the excavator


195
00:10:39,786 --> 00:10:42,486
and the orange boxes
just indicate that, yes,


196
00:10:42,486 --> 00:10:44,106
you can indicate your
material assignments


197
00:10:44,106 --> 00:10:45,296
and things like that as well.


198
00:10:45,916 --> 00:10:47,576
So that's what's in an asset.


199
00:10:48,026 --> 00:10:50,816
It's all the stuff that
logically belongs together


200
00:10:50,816 --> 00:10:52,096
and you will get
a bunch of assets


201
00:10:52,096 --> 00:10:55,496
and compose them into a scene.


202
00:10:55,746 --> 00:11:01,606
So an asset has allocators
in case you need


203
00:11:01,606 --> 00:11:04,856
to manage memory yourself,
you can add an allocator.


204
00:11:05,476 --> 00:11:09,346
It has descriptors and
which teach about the things


205
00:11:09,346 --> 00:11:10,486
that are inside of the asset.


206
00:11:10,956 --> 00:11:13,056
There's the import
and export facilities


207
00:11:13,416 --> 00:11:14,766
and a bunch of children.


208
00:11:15,346 --> 00:11:17,826
And the children are MDLObjects.


209
00:11:19,316 --> 00:11:23,036
MDLObjects themselves
can comprise a hierarchy.


210
00:11:23,666 --> 00:11:27,206
Now, a typical scene
graph, of course,


211
00:11:27,206 --> 00:11:28,856
has transformation hierarchies.


212
00:11:29,396 --> 00:11:35,176
And so an MDLObject has
got a transform component.


213
00:11:36,276 --> 00:11:39,476
We are not implementing
the transform in, you know,


214
00:11:39,476 --> 00:11:41,406
the standard way of
putting a matrix everywhere.


215
00:11:41,406 --> 00:11:43,016
We actually have a
transformation component


216
00:11:43,536 --> 00:11:45,696
and components are
very interesting,


217
00:11:45,846 --> 00:11:47,846
because it allows us
to make scene graphs


218
00:11:47,846 --> 00:11:51,126
that aren't limited just
to the parent of or child


219
00:11:51,126 --> 00:11:52,466
of type relationships.


220
00:11:52,956 --> 00:11:55,356
Instead you can define
your own components.


221
00:11:56,726 --> 00:12:00,686
Now, I guess I should have
mentioned that the nice thing is


222
00:12:01,036 --> 00:12:02,566
that the API is designed


223
00:12:02,636 --> 00:12:04,696
that you can write your own
importers and exporters.


224
00:12:05,136 --> 00:12:08,626
You can write -- if you have
your own custom file format,


225
00:12:09,356 --> 00:12:12,406
you can implement that
and so back to this,


226
00:12:12,876 --> 00:12:17,886
I've got a custom component
which is a TriggerComponent


227
00:12:17,886 --> 00:12:20,266
like a volume your character
enters a region and some sort


228
00:12:20,266 --> 00:12:21,236
of action should occur.


229
00:12:21,536 --> 00:12:24,986
You can just make that yourself
and define what the behavior is


230
00:12:24,986 --> 00:12:28,516
and what it connects to,
the API lets you do that.


231
00:12:29,356 --> 00:12:33,596
Now, a mesh contains one
or more vertex buffers.


232
00:12:33,866 --> 00:12:36,266
That's positions and normals
the thing that has to go off


233
00:12:36,266 --> 00:12:38,166
to the GPU for rasterization.


234
00:12:38,796 --> 00:12:41,226
And submeshers.


235
00:12:42,266 --> 00:12:46,436
Submeshes, to get an idea
of what exactly it is,


236
00:12:46,656 --> 00:12:49,476
you might have, like, a
character who is going


237
00:12:49,476 --> 00:12:50,646
to drive the excavator


238
00:12:50,646 --> 00:12:53,736
and he might have some optional
components like a hard hat,


239
00:12:54,066 --> 00:12:55,876
it shouldn't be optional,
but it is.


240
00:12:56,286 --> 00:13:01,326
So in one index buffer, I
might have the whole character


241
00:13:01,326 --> 00:13:03,516
without the hat, and in
another index buffer,


242
00:13:03,516 --> 00:13:05,206
I might just have
all indexes referring


243
00:13:05,206 --> 00:13:07,016
to the original mesh
vertex buffers


244
00:13:07,186 --> 00:13:08,216
that have got his hat in it.


245
00:13:08,706 --> 00:13:11,726
So by rendering or not
rendering that submesh, he does


246
00:13:11,726 --> 00:13:13,286
or does not have a hat.


247
00:13:14,496 --> 00:13:17,126
Submeshes can share the
data in the vertex buffers


248
00:13:17,206 --> 00:13:19,266
so this just allows you to
have a single submission


249
00:13:19,266 --> 00:13:21,516
for the hardware.


250
00:13:21,616 --> 00:13:26,026
So the mesh, besides holding
vertex and index buffers,


251
00:13:27,136 --> 00:13:30,596
also has utility functions, and
there's generators to make all


252
00:13:30,596 --> 00:13:33,536
of your usual things, like
boxes and spheres and what not.


253
00:13:34,176 --> 00:13:35,336
There's modifiers.


254
00:13:35,726 --> 00:13:39,496
So if a mesh that didn't have
normals or tangent bases,


255
00:13:39,496 --> 00:13:42,916
or any of those things, you
can generate those on demand,


256
00:13:43,396 --> 00:13:46,596
thinking back to that
bake and export cycle


257
00:13:46,596 --> 00:13:47,556
that I showed earlier.


258
00:13:48,356 --> 00:13:50,156
And there's, of course
the bakers.


259
00:13:50,726 --> 00:13:57,436
Now, a mesh buffer is the thing
that has to go to the hardware.


260
00:13:57,796 --> 00:13:59,856
It's got the data in it.


261
00:14:00,816 --> 00:14:01,666
The actual data.


262
00:14:02,256 --> 00:14:05,386
How big the buffer is,
how you allocated it.


263
00:14:05,886 --> 00:14:09,646
And you have to describe
those vertex buffers.


264
00:14:09,646 --> 00:14:12,796
You have to say what the
intention of the buffer is,


265
00:14:12,796 --> 00:14:13,876
like is this a position?


266
00:14:14,366 --> 00:14:15,846
How big is it?


267
00:14:15,846 --> 00:14:18,076
How many bytes does it take
and so on and so forth.


268
00:14:19,376 --> 00:14:22,596
So finally the stride from
one vertex to the next,


269
00:14:22,656 --> 00:14:23,866
that's what the hardware
needs to know.


270
00:14:24,276 --> 00:14:26,716
The same sort of
thing for the submesh.


271
00:14:26,886 --> 00:14:28,436
You say what kind of
indexes do you have.


272
00:14:28,646 --> 00:14:30,966
Are they 16s or 32s or whatever.


273
00:14:31,216 --> 00:14:32,166
The geometry type.


274
00:14:32,166 --> 00:14:35,746
Is it a triangle strip, or
is it a point or a line,


275
00:14:36,136 --> 00:14:37,146
and finally a material.


276
00:14:38,626 --> 00:14:43,976
Materials, as I said are going
to be physically motivated


277
00:14:43,976 --> 00:14:45,476
if you use these APIs.


278
00:14:46,056 --> 00:14:47,836
And to tell you what that means,


279
00:14:48,096 --> 00:14:51,056
we have got bidirectional
reflectance functions


280
00:14:51,116 --> 00:14:53,996
with ten simple parameters
that are designed


281
00:14:53,996 --> 00:14:55,346
by artists to be intuitive.


282
00:14:55,926 --> 00:14:59,086
So one of the more
important features is just


283
00:14:59,086 --> 00:15:01,556
to specify whether the
material is dialectic


284
00:15:01,556 --> 00:15:03,976
like clay or if it's a metal.


285
00:15:04,046 --> 00:15:07,266
If you set this value all the
way to one end, it's dialectic


286
00:15:07,266 --> 00:15:10,706
like clay all the
way to the other end,


287
00:15:10,706 --> 00:15:15,136
it will behave like a metal.


288
00:15:15,286 --> 00:15:19,056
Here I have combined the two to
put an acrylic clear coat on top


289
00:15:19,056 --> 00:15:25,266
of the metallic base and here I
tweaked up one of the parameters


290
00:15:25,266 --> 00:15:27,186
to give a satin finish.


291
00:15:27,716 --> 00:15:34,216
And here's an actual
artist-prepared piece


292
00:15:34,216 --> 00:15:37,206
of spaceship with all kinds
of different materials on it,


293
00:15:37,476 --> 00:15:40,206
just to give you an
idea that a small number


294
00:15:40,236 --> 00:15:43,616
of parameters can give you
a wide variety of looks.


295
00:15:44,806 --> 00:15:48,646
So, materials have a
name, just like everything


296
00:15:48,786 --> 00:15:50,886
in Model I/O has properties.


297
00:15:51,076 --> 00:15:54,126
You specify the scattering
function, whether you want it


298
00:15:54,126 --> 00:15:57,056
to be Lambert Blinn-Phong
because you need compatibility


299
00:15:57,056 --> 00:16:00,966
with an older system, and,
or physically plausible


300
00:16:00,966 --> 00:16:02,906
if you're going into
this brave new world


301
00:16:02,906 --> 00:16:04,186
of physical motivation.


302
00:16:05,466 --> 00:16:09,016
The materials are singly
inherited and so what


303
00:16:09,016 --> 00:16:12,126
that means is you might
have some kind of a uniform


304
00:16:12,256 --> 00:16:15,416
that only varies by a number
or something on each character.


305
00:16:15,416 --> 00:16:18,296
So you can specify a base
material and override properties


306
00:16:18,976 --> 00:16:20,756
and subclass materials.


307
00:16:20,756 --> 00:16:24,756
The material properties have
names, and they have a semantic


308
00:16:24,756 --> 00:16:27,526
which means how are
they to be used, a type,


309
00:16:27,576 --> 00:16:30,316
like is it a floating point
value or a color and a value.


310
00:16:31,726 --> 00:16:32,346
And lights.


311
00:16:32,946 --> 00:16:37,006
And lights have physical
parameters


312
00:16:37,156 --> 00:16:40,436
and physical properties
and they have geometry.


313
00:16:40,626 --> 00:16:42,436
They have, you know,
an extent and a width.


314
00:16:42,846 --> 00:16:46,866
And the light itself emits
light in a certain way.


315
00:16:47,126 --> 00:16:49,326
You can specify it with
lumens and color temperature.


316
00:16:49,746 --> 00:16:51,626
One thing I'm really
excited about overall


317
00:16:51,626 --> 00:16:55,696
in Model I/O is we've
got support for color


318
00:16:56,026 --> 00:17:00,146
that can be specified using
modern color pipelines.


319
00:17:00,646 --> 00:17:04,336
So if you want to use SRGB,
we have a well-specified SRGB.


320
00:17:04,336 --> 00:17:06,506
If you want to use Rec.709


321
00:17:06,506 --> 00:17:10,165
or the new Asus CG color
profiles you can ensure


322
00:17:10,165 --> 00:17:11,205
that your color started


323
00:17:11,556 --> 00:17:14,646
in a content production
app a certain way


324
00:17:14,646 --> 00:17:18,205
and it got all the way
to the end, without going


325
00:17:18,205 --> 00:17:20,236
through odd transformations
that might give you some,


326
00:17:20,236 --> 00:17:21,746
you know, color surprises.


327
00:17:24,415 --> 00:17:28,766
So there we have our
physically plausible light


328
00:17:29,506 --> 00:17:32,556
and various subclasses,
procedure area light,


329
00:17:32,996 --> 00:17:35,566
I should say it procedural
description of an area light.


330
00:17:36,096 --> 00:17:41,146
And the photometric light from
an IES profile, and light probes


331
00:17:41,486 --> 00:17:44,206
that take reflective
maps or irradiance maps


332
00:17:44,586 --> 00:17:46,826
and you can use them to compute
spherical harmonics and stuff


333
00:17:46,826 --> 00:17:49,096
like that to compactly
represent what's going on.


334
00:17:50,396 --> 00:17:54,696
And our camera is no longer
merely a pinhole camera


335
00:17:54,696 --> 00:17:57,076
with an infinite in
focus projection.


336
00:17:57,716 --> 00:18:01,966
We describe a camera from
one end to the other.


337
00:18:02,416 --> 00:18:07,116
My picture here is supposed
to have a lens, shutter


338
00:18:07,116 --> 00:18:08,216
and sensor plain there.


339
00:18:08,586 --> 00:18:12,846
We describe what the lens can
see, the properties of the lens,


340
00:18:12,846 --> 00:18:15,426
what kind of distortion,
barrel distortion,


341
00:18:15,596 --> 00:18:18,566
or chromatic aberration that
sort of thing, the geometry


342
00:18:18,566 --> 00:18:21,186
of the lens and how big is the
glass, how long is the barrel.


343
00:18:21,696 --> 00:18:22,896
The exit aperture.


344
00:18:22,896 --> 00:18:27,036
How tightly have you closed the
aperture, how big is the sensor


345
00:18:27,336 --> 00:18:30,076
and what is the exposure
characteristics of the sensor.


346
00:18:30,646 --> 00:18:34,826
So the end result of all of that
is, if you specify your cameras


347
00:18:34,826 --> 00:18:41,146
in this way, if you mount a
35 or say a 50-millimeter lens


348
00:18:41,146 --> 00:18:45,396
with an F1.8 aperture
and go check Wikipedia,


349
00:18:45,606 --> 00:18:47,926
what are the characteristics
of a lens like that,


350
00:18:47,996 --> 00:18:51,816
what is the field of view, and
what's the out of focus light,


351
00:18:52,036 --> 00:18:55,696
highlight size and things like
that, the utility functions


352
00:18:55,696 --> 00:18:59,016
on the MDLCamera will agree with
what you find in a textbook.


353
00:18:59,016 --> 00:19:01,956
So that's a handy and fun thing.


354
00:19:02,196 --> 00:19:04,416
And I encourage you to
incorporate those kinds


355
00:19:04,416 --> 00:19:06,886
of calculations into your
shaders and pipelines.


356
00:19:08,346 --> 00:19:09,646
Just a quick example here.


357
00:19:10,776 --> 00:19:13,166
When I first load this
thing up in my viewer,


358
00:19:13,446 --> 00:19:15,386
these are the default
exposure settings.


359
00:19:15,676 --> 00:19:18,706
Some of the detail is lost,
it's a bit washed out.


360
00:19:18,886 --> 00:19:23,466
We can't see a lot of detail on
the dark areas of the excavator.


361
00:19:24,316 --> 00:19:29,556
Sorry for the brightness here,
but I underexposed this image


362
00:19:29,606 --> 00:19:32,176
and then flashed the
sensor in order to bring


363
00:19:32,176 --> 00:19:35,746
out shadow detail, and raise
the overall levels while


364
00:19:35,746 --> 00:19:36,586
reducing glare.


365
00:19:37,706 --> 00:19:41,076
Just like a photographer
might do, if you are playing


366
00:19:41,076 --> 00:19:45,716
around with settings on
your own real camera.


367
00:19:45,826 --> 00:19:46,536
Now, skies.


368
00:19:47,876 --> 00:19:49,656
We have two ways
to create skies.


369
00:19:49,976 --> 00:19:53,916
The first way is to use a
procedural sky generator.


370
00:19:53,996 --> 00:19:56,406
It uses physics.


371
00:19:56,496 --> 00:19:59,416
You give it time of day,
essentially how high is the sun.


372
00:19:59,716 --> 00:20:01,446
What are the atmospheric
conditions.


373
00:20:01,446 --> 00:20:04,016
Is there a lot of back
scatter from the ground,


374
00:20:04,016 --> 00:20:05,276
is there a lot of
junk in the air.


375
00:20:05,786 --> 00:20:09,646
We calculate exactly
what the sky would look


376
00:20:09,946 --> 00:20:11,896
like through some
fairly heavy math.


377
00:20:13,476 --> 00:20:16,526
So the other way
you can create --


378
00:20:16,526 --> 00:20:19,856
it creates a cube that you
can then just, you know, use.


379
00:20:20,346 --> 00:20:24,486
Now, the other way you can
create sky for illumination


380
00:20:24,606 --> 00:20:27,266
in this physically based
realm is through photography.


381
00:20:27,266 --> 00:20:29,416
You can take a spherical
panorama


382
00:20:29,626 --> 00:20:30,896
with your phone or a DSLR.


383
00:20:30,896 --> 00:20:33,106
I made this picture
with my iPhone.


384
00:20:33,726 --> 00:20:39,676
Then you can prepare it for
rendering using the MDLTexture


385
00:20:39,676 --> 00:20:44,526
and initWithURL API,
create a cube map


386
00:20:45,036 --> 00:20:46,286
for reflectance and irradiance.


387
00:20:46,286 --> 00:20:48,536
Irradiance is the incoming
light that we can deduce


388
00:20:48,596 --> 00:20:51,806
from the image, so there it's
been converted into a cube.


389
00:20:52,406 --> 00:20:58,336
And then, from that, you
can compute the irradiance


390
00:20:58,846 --> 00:21:02,876
and what these three strips
show is the original image,


391
00:21:03,106 --> 00:21:07,286
the middle line is a texture
map showing the irradiance


392
00:21:07,286 --> 00:21:09,636
at a certain convolution
or level of blur


393
00:21:10,236 --> 00:21:12,276
and the third one is really fun.


394
00:21:12,276 --> 00:21:14,596
The middle one is a texture and
it uses a fair amount of memory.


395
00:21:14,596 --> 00:21:18,106
And the third one is actually
spherical harmonic coefficients


396
00:21:18,326 --> 00:21:23,056
and so it's 27 floats
that reproduce the look


397
00:21:23,056 --> 00:21:24,406
of the irradiant environment


398
00:21:24,496 --> 00:21:27,926
that previously took
several dozen K to represent


399
00:21:27,926 --> 00:21:29,566
in the middle slide
or the middle strip.


400
00:21:30,836 --> 00:21:32,016
So putting that all together,


401
00:21:32,566 --> 00:21:36,356
this excavator is fairly well
situated in its environment,


402
00:21:36,896 --> 00:21:40,886
in that I photographed
and that's, I think,


403
00:21:40,886 --> 00:21:43,206
a pretty exciting result,
and I hope you guys can think


404
00:21:43,206 --> 00:21:44,506
of cool things to do with that.


405
00:21:44,556 --> 00:21:49,386
Now, I just want to
talk a little bit


406
00:21:49,386 --> 00:21:51,346
about how Model I/O
integrates with SceneKit.


407
00:21:52,556 --> 00:21:55,346
There's essentially a
one-to-one correspondence


408
00:21:55,666 --> 00:22:00,246
between top level Model I/O
elements and SceneKit elements.


409
00:22:00,246 --> 00:22:02,566
MDLAsset corresponds
to SceneKit root node


410
00:22:03,406 --> 00:22:07,116
and MDLMesh coordinates with
SCNNode with SCNGeometry.


411
00:22:07,426 --> 00:22:11,246
MDLLight with SCNLight camera
camera, material material.


412
00:22:11,936 --> 00:22:16,216
Where exact analogs don't exist
between a SceneKit parameter


413
00:22:16,216 --> 00:22:19,816
and about a Model I/O
parameter, we translate


414
00:22:20,056 --> 00:22:21,756
to get a close approximation.


415
00:22:23,616 --> 00:22:26,746
Now, Model I/O doesn't
actually do rendering for you.


416
00:22:26,746 --> 00:22:29,026
You probably gathered
that since I mentioned all


417
00:22:29,026 --> 00:22:31,546
of these other APIs
that do do rendering.


418
00:22:32,136 --> 00:22:35,086
So in MetalKit, you are
much closer to the metal.


419
00:22:35,956 --> 00:22:39,356
The correspondence that
you get between Model I/O


420
00:22:39,356 --> 00:22:43,316
and MetalKit is an
MDLMesh can be converted


421
00:22:43,606 --> 00:22:46,136
into a model kit
array kit of meshes.


422
00:22:46,676 --> 00:22:49,566
Once you have that array
of meshes, it's up to you


423
00:22:49,566 --> 00:22:53,086
to write shaders, traverse
the mesh, find the materials,


424
00:22:53,086 --> 00:22:55,396
the lighting condition,
and do the rendering.


425
00:22:55,876 --> 00:22:57,936
But getting those
metal buffers prepared


426
00:22:57,936 --> 00:23:00,186
for you is absolutely
transparent.


427
00:23:01,036 --> 00:23:07,216
So with that, I would like to
pass the mic to Claudia Roberts


428
00:23:07,216 --> 00:23:09,626
to talk about geometry
and voxels.


429
00:23:10,516 --> 00:23:17,716
[ Applause ]


430
00:23:18,216 --> 00:23:18,946
>> CLAUDIA ROBERTS:
Hello, everyone,


431
00:23:18,946 --> 00:23:21,516
my name is Claudia Roberts
and as Nick mentioned,


432
00:23:21,516 --> 00:23:23,556
I will give you an
overview of some


433
00:23:23,556 --> 00:23:25,356
of the different
ways you can describe


434
00:23:25,356 --> 00:23:28,046
and characterize
geometry in Model I/O.


435
00:23:28,786 --> 00:23:32,306
The motivation being to help you
create games and applications


436
00:23:32,306 --> 00:23:35,046
that have a more physically
plausible look and feel.


437
00:23:35,686 --> 00:23:39,506
To give you all some context
of where we are headed,


438
00:23:39,506 --> 00:23:42,656
first I will discuss how Model
I/O supports normal smoothing


439
00:23:43,016 --> 00:23:45,736
then go into subdivision
surfaces followed


440
00:23:45,736 --> 00:23:48,466
by a discussion on
voxels and a quick demo.


441
00:23:49,076 --> 00:23:51,616
Okay. Let's get started.


442
00:23:51,616 --> 00:23:52,576
Normal smoothing.


443
00:23:53,506 --> 00:23:56,036
Normal smoothing is a cool
technique that tricks people


444
00:23:56,036 --> 00:23:58,986
into believing that your
models have way more geometry


445
00:23:58,986 --> 00:23:59,946
than they actually do.


446
00:24:00,996 --> 00:24:02,546
By default, the vertices


447
00:24:02,546 --> 00:24:04,836
of a polygon all share
the same face normal.


448
00:24:05,326 --> 00:24:06,806
And thus all points on the face


449
00:24:06,806 --> 00:24:08,836
of the polygon have the
same normal as well.


450
00:24:09,766 --> 00:24:12,876
This creates a perceived crease
between adjacent polygons


451
00:24:13,196 --> 00:24:15,096
which is the result
of the abrupt change


452
00:24:15,096 --> 00:24:17,696
and vertex normals during
the rasterization process.


453
00:24:18,836 --> 00:24:21,116
This sharp contrast in
colors can be mitigated


454
00:24:21,296 --> 00:24:24,396
by introducing a shared normal
whose value is the average


455
00:24:24,396 --> 00:24:27,816
of the vertex normals that share
the same coordinate position.


456
00:24:28,676 --> 00:24:32,356
Now, during the GPU's lighting
calculations the normal


457
00:24:32,356 --> 00:24:33,736
at each point on the face


458
00:24:33,736 --> 00:24:36,686
of the polygon will be the
interpolation of vertex normals


459
00:24:36,686 --> 00:24:39,206
that are no longer all
the same, giving a nice,


460
00:24:39,316 --> 00:24:40,246
smooth shading effect.


461
00:24:41,916 --> 00:24:45,396
Using the MDLMesh API, you
can add smoothed out normals


462
00:24:45,436 --> 00:24:49,846
to your object, by calling the
addNormalsWithAttributeNamed


463
00:24:49,996 --> 00:24:53,186
method and you can control when
normal smoothing is applied


464
00:24:53,496 --> 00:24:55,486
by setting the crease
threshold value.


465
00:24:56,836 --> 00:25:00,036
With our spaceship, we
see our default mesh


466
00:25:00,036 --> 00:25:01,706
with the flat shading
on the left


467
00:25:02,316 --> 00:25:06,066
and the smooth shading
on the right.


468
00:25:06,326 --> 00:25:08,106
Next, subdivision surfaces.


469
00:25:08,536 --> 00:25:12,036
Surface subdivision
is a common technique


470
00:25:12,036 --> 00:25:15,766
for using low detailed
geometry to generate


471
00:25:15,856 --> 00:25:18,196
and render a smooth
surface for rendering.


472
00:25:19,066 --> 00:25:22,486
This technique allows you to use
a simple polygon control mesh


473
00:25:22,696 --> 00:25:25,186
to create varying levels
of detail as needed.


474
00:25:25,736 --> 00:25:27,826
For instance, it would
make a lot of sense


475
00:25:27,826 --> 00:25:30,626
to render a character at a low
polygon count when further away


476
00:25:30,626 --> 00:25:34,036
and increase the level of detail
as the character gets closer


477
00:25:34,126 --> 00:25:35,666
and closer to the camera.


478
00:25:36,916 --> 00:25:38,836
By varying the subdivision
level of a model,


479
00:25:38,836 --> 00:25:40,896
you can generate these
different meshes without needing


480
00:25:40,896 --> 00:25:42,266
to manually create them all.


481
00:25:43,466 --> 00:25:46,026
In Model I/O, you can
create subdivision surfaces


482
00:25:46,386 --> 00:25:51,826
by calling the newSubdividedMesh
routine, also found in MDLMesh.


483
00:25:52,746 --> 00:25:55,486
Here at the bottom, we achieve
the smooth mesh on the right,


484
00:25:55,876 --> 00:25:58,616
by setting the subdivision
level to two,


485
00:25:58,616 --> 00:26:01,346
significantly increasing
the number of polygons.


486
00:26:04,036 --> 00:26:05,826
Finally, voxels.


487
00:26:06,736 --> 00:26:09,626
In addition to providing support
for various advanced techniques


488
00:26:09,746 --> 00:26:12,056
for polygonal representations
of 3D models,


489
00:26:12,576 --> 00:26:15,696
Model I/O also supports
volumetric representations.


490
00:26:17,016 --> 00:26:19,316
By representing a model
as a close approximation


491
00:26:19,316 --> 00:26:22,186
of how it is actually found in
the real world, that is a set


492
00:26:22,186 --> 00:26:24,306
of particles or discreet
points in space


493
00:26:24,386 --> 00:26:28,016
with inherent properties such as
volume, mass, velocity, color,


494
00:26:28,636 --> 00:26:30,606
the door becomes
wide open to a range


495
00:26:30,606 --> 00:26:32,376
of physically realistic
techniques,


496
00:26:32,746 --> 00:26:34,416
analysis, and manipulations.


497
00:26:35,766 --> 00:26:38,856
Where as with polygon meshes
it's difficult to model


498
00:26:38,856 --> 00:26:40,476
and represent surfaceless
phenomena


499
00:26:40,476 --> 00:26:42,416
such as clouds, water, fire.


500
00:26:42,936 --> 00:26:45,706
It becomes much easier with
the volume representation.


501
00:26:46,596 --> 00:26:49,496
Now, instead of trying to
mingle and twist a rigid shell


502
00:26:49,496 --> 00:26:52,426
of polygons, the model
becomes a deformable mass


503
00:26:52,666 --> 00:26:54,916
that can change its
properties at any time.


504
00:26:55,976 --> 00:26:58,816
Along those same lines
this representation allows


505
00:26:58,816 --> 00:27:02,136
for procedural generation and
modeling, meaning it can make


506
00:27:02,136 --> 00:27:04,646
for exciting and novel
opportunities and game play.


507
00:27:05,036 --> 00:27:07,526
Think modification and
destruction of objects


508
00:27:07,526 --> 00:27:08,646
and terrain on the fly.


509
00:27:09,316 --> 00:27:14,796
Because a voxel model is a
more accurate representation


510
00:27:14,796 --> 00:27:18,186
of the real world, it lends
itself to being analyzed,


511
00:27:18,186 --> 00:27:21,446
explored, and operated on in
a more natural and real way


512
00:27:21,446 --> 00:27:22,666
like slicing and cutting.


513
00:27:23,876 --> 00:27:25,996
This fact is proven to
be particularly useful


514
00:27:25,996 --> 00:27:28,866
in the medical imaging
field where, lucky for us,


515
00:27:28,866 --> 00:27:32,376
scientists have proven than our
skulls are not really comprised


516
00:27:32,376 --> 00:27:34,346
of an empty shell of triangles.


517
00:27:36,026 --> 00:27:39,136
And finally, given that you have
a few solid voxelized models,


518
00:27:39,136 --> 00:27:41,636
you can perform Constructive
Solid Geometry Boolean


519
00:27:41,636 --> 00:27:43,816
operations on them in
order to create a slew


520
00:27:43,816 --> 00:27:45,786
of more interesting
and complex models.


521
00:27:46,376 --> 00:27:50,346
In Model I/O, we
expose the support


522
00:27:50,346 --> 00:27:53,166
of voxels via the
MDLVoxelArray API.


523
00:27:54,186 --> 00:27:56,306
Our implementation
represents volume models


524
00:27:56,306 --> 00:27:59,146
as a sparse volume grid,
where voxels can be accessed


525
00:27:59,146 --> 00:28:01,086
by using a simple spatial index.


526
00:28:02,236 --> 00:28:04,646
This representation allows
for quick neighbor finding


527
00:28:04,646 --> 00:28:05,886
and neighborhood traversal.


528
00:28:06,476 --> 00:28:10,276
In addition to the grid
coordinates each voxel contains


529
00:28:10,306 --> 00:28:13,306
a shell level value
which indicates how close


530
00:28:13,306 --> 00:28:16,216
or far a voxel is to the
surface of the model,


531
00:28:16,696 --> 00:28:18,946
both in the positive
exterior direction


532
00:28:18,946 --> 00:28:21,196
and the negative
interior direction.


533
00:28:22,536 --> 00:28:24,646
And Model I/O also
supports the creation


534
00:28:24,686 --> 00:28:26,506
of closed meshes model cleanup


535
00:28:26,506 --> 00:28:28,316
and conversion back
to a polygon mesh.


536
00:28:29,386 --> 00:28:31,776
I will now show you the handful
of API calls you will need


537
00:28:31,776 --> 00:28:35,786
in order to get started
with voxel and Model I/Os.


538
00:28:36,046 --> 00:28:39,356
So given an initialized
MDLVoxelArray you can generate


539
00:28:39,356 --> 00:28:42,056
its voxel data from
an MDMMesh object


540
00:28:42,586 --> 00:28:44,916
by calling the setVoxelsForMesh
method.


541
00:28:45,976 --> 00:28:48,786
The divisions parameter is
used to set the resolution


542
00:28:48,786 --> 00:28:51,356
of your voxel model by
specifying the number


543
00:28:51,356 --> 00:28:52,826
of layers your model
will be divided


544
00:28:52,826 --> 00:28:54,206
into on the vertical extent.


545
00:28:55,266 --> 00:28:57,516
You can also specify how
thick you want the interior


546
00:28:57,516 --> 00:28:59,076
and the exterior walls
of your model to be


547
00:28:59,076 --> 00:29:00,336
with the last two parameters.


548
00:29:00,846 --> 00:29:04,226
Once you have your voxel
array objects set up,


549
00:29:04,876 --> 00:29:07,036
you can perform various
operations on them,


550
00:29:07,036 --> 00:29:10,076
such as intersect, union,
and differenceWithVoxel


551
00:29:10,166 --> 00:29:12,646
which perform expected
basic Boolean operations.


552
00:29:13,206 --> 00:29:16,936
To actually retrieve your
voxel data for processing


553
00:29:16,936 --> 00:29:20,536
and inspection, simply call
the getVoxelIndices method


554
00:29:21,536 --> 00:29:24,166
and once your done with your
processing convert your voxel


555
00:29:24,166 --> 00:29:26,486
model back to a polygonal
representation,


556
00:29:26,726 --> 00:29:28,846
using the meshUsingAllocator
routine.


557
00:29:30,716 --> 00:29:31,676
Simple as that.


558
00:29:32,556 --> 00:29:35,236
And now, I will show you voxels
in action with a quick demo.


559
00:29:55,046 --> 00:29:55,856
>> CLAUDIA ROBERTS: So
here we have this demo.


560
00:29:56,346 --> 00:29:59,116
It actually took about one
hour to create from start


561
00:29:59,116 --> 00:30:00,836
to finish using SceneKit editor.


562
00:30:00,836 --> 00:30:04,026
We simply dragged and dropped in
the ground and we did the same


563
00:30:04,076 --> 00:30:07,106
for our red panda which
you actually saw yesterday


564
00:30:07,106 --> 00:30:08,316
at the state of the union.


565
00:30:08,656 --> 00:30:11,636
It's just a regular polygon
mesh and you can use any mesh


566
00:30:11,636 --> 00:30:12,786
that you want for this.


567
00:30:13,676 --> 00:30:16,856
And then using the MDLVoxelArray
API, it only took two lines


568
00:30:16,856 --> 00:30:19,356
of code to turn this
mesh into voxels.


569
00:30:20,286 --> 00:30:24,126
And then for each voxel,
we creates an SCN box,


570
00:30:24,126 --> 00:30:25,156
and this is what it looks like.


571
00:30:29,416 --> 00:30:33,876
And now that we have our voxels
in SceneKit, the exciting thing


572
00:30:33,876 --> 00:30:36,686
about that is we
can take advantage


573
00:30:36,686 --> 00:30:39,586
of all the really cool things
that SceneKit has to offer.


574
00:30:39,746 --> 00:30:42,916
For instance, with one line
of code, we can turn all


575
00:30:42,916 --> 00:30:45,716
of these SCN boxes
into SCN spheres.


576
00:30:46,316 --> 00:30:50,006
And just for fun, we
will apply SceneKit body


577
00:30:50,006 --> 00:30:52,326
to all the nodes
and explode him.


578
00:30:52,436 --> 00:30:56,596
Wee! I am hand it over
to Remi now who will talk


579
00:30:56,596 --> 00:30:59,286
about advanced topics in
lighting and Xcode support.


580
00:31:00,516 --> 00:31:09,156
[ Applause ]


581
00:31:09,656 --> 00:31:11,936
>> REMI PALANDRI: Hey,
everyone, and thanks, Claudia.


582
00:31:11,976 --> 00:31:16,366
So hi. As Chris said today, I
will be talking about advances


583
00:31:16,366 --> 00:31:18,936
in baking and how Model I/O
does all of that for you.


584
00:31:20,116 --> 00:31:22,586
So what exactly is is
advanced lighting and baking.


585
00:31:22,586 --> 00:31:23,286
What's the goal here?


586
00:31:23,836 --> 00:31:26,156
The goal is to introduce
to your frameworks


587
00:31:26,156 --> 00:31:27,236
and your rendering pipelines


588
00:31:27,236 --> 00:31:29,416
in your games is something
called global illumination.


589
00:31:30,186 --> 00:31:30,766
So what is that?


590
00:31:31,526 --> 00:31:34,576
It's not the way of saying,
all right I have a point height


591
00:31:34,576 --> 00:31:35,896
and I have a triangle
and let's light it


592
00:31:35,896 --> 00:31:38,916
up using dot products
and be done with it.


593
00:31:39,036 --> 00:31:41,396
We are going to try to pretend
that that scene is real.


594
00:31:41,636 --> 00:31:44,856
We're going to try to simulate
how light would actually move


595
00:31:45,166 --> 00:31:47,436
in that scene how light
will reflect off the walls


596
00:31:47,726 --> 00:31:50,176
and occlude because it
can't go through triangles.


597
00:31:51,126 --> 00:31:53,646
The issue is that
it's very expensive.


598
00:31:53,796 --> 00:31:55,826
It's been used a long
time in the movies


599
00:31:55,826 --> 00:31:58,196
because you can take a half
hour to reframe if you want,


600
00:31:58,696 --> 00:31:59,916
but that doesn't work for us.


601
00:31:59,916 --> 00:32:03,676
If you look at the picture
here, you can see, for example,


602
00:32:03,676 --> 00:32:07,836
that the wall here, the red wall
on the left irradiates a bit


603
00:32:07,836 --> 00:32:09,546
of red light on that sphere.


604
00:32:10,176 --> 00:32:14,416
The wall isn't really the light
per se, but lights as it does


605
00:32:14,416 --> 00:32:17,816
in real life reflection off the
wall and irradiated the sphere.


606
00:32:18,386 --> 00:32:20,936
In the back of the
sphere, it's a bit dark,


607
00:32:20,936 --> 00:32:23,146
because this sphere occludes
some lighting from going there.


608
00:32:23,176 --> 00:32:24,826
It's not a real direct a shadow


609
00:32:24,826 --> 00:32:26,086
but there is still
something going on.


610
00:32:27,836 --> 00:32:30,006
The issue is that this is
really hard to do in realtime.


611
00:32:30,006 --> 00:32:32,946
So we are going to show you
ways to actually get some


612
00:32:32,946 --> 00:32:35,796
of that precomputed before
you even launch your game


613
00:32:35,796 --> 00:32:36,556
during precompilation.


614
00:32:37,076 --> 00:32:40,136
So that you can get a really
realistic rounded look


615
00:32:40,486 --> 00:32:42,356
without having any of
the performance drawbacks


616
00:32:42,716 --> 00:32:44,306
and we will balance
performance and quality


617
00:32:44,626 --> 00:32:46,776
so you can get the look
that you want with very,


618
00:32:46,776 --> 00:32:48,846
very few performance overheads.


619
00:32:49,416 --> 00:32:52,936
So global illumination today
will have two different heads.


620
00:32:52,936 --> 00:32:56,716
So we are going to first
show you ambient occlusion


621
00:32:57,366 --> 00:32:58,526
and then light maps.


622
00:32:59,376 --> 00:33:00,786
And to introduce
ambient occlusion,


623
00:33:00,886 --> 00:33:01,936
I would like to show
you an example.


624
00:33:02,556 --> 00:33:05,936
If you look at the spaceship
it's the default SceneKit


625
00:33:05,996 --> 00:33:07,316
spaceship, it looks good.


626
00:33:07,666 --> 00:33:08,576
It's a great spaceship.


627
00:33:08,576 --> 00:33:11,226
I love to play the game,
but it's a bit flat.


628
00:33:11,316 --> 00:33:15,346
If you look at the wing or the
engine, it's not extremely clear


629
00:33:15,346 --> 00:33:18,466
where the wing ends
or the engine starts.


630
00:33:18,466 --> 00:33:20,736
If you look at the two
fins on the right image,


631
00:33:21,586 --> 00:33:24,266
it's weird because you have
the same light as you have


632
00:33:24,266 --> 00:33:26,436
on the front of the ship
but the fins should block


633
00:33:26,436 --> 00:33:26,856
out the lights.


634
00:33:27,636 --> 00:33:30,106
If you were to add ambient
occlusion it would look


635
00:33:31,246 --> 00:33:31,766
like this.


636
00:33:31,766 --> 00:33:34,526
Same shader, but the look
is a bit more realistic,


637
00:33:34,526 --> 00:33:37,496
because there is now a
shadow between an occlusion


638
00:33:37,736 --> 00:33:38,986
between the wing and the engine.


639
00:33:39,516 --> 00:33:41,516
If I were to add ambient
occlusion to the second one,


640
00:33:41,726 --> 00:33:43,436
it would look like
this, same thing,


641
00:33:43,686 --> 00:33:46,526
but you can see light
that's occluded


642
00:33:46,856 --> 00:33:49,216
and it's a more compelling
experience.


643
00:33:49,216 --> 00:33:50,846
It's a better looking picture.


644
00:33:51,686 --> 00:33:53,096
What exactly is ambient
occlusion?


645
00:33:54,306 --> 00:33:57,736
What ambient occlusion is
is very simply a measure


646
00:33:57,736 --> 00:33:58,736
of geometry occlusion.


647
00:33:58,986 --> 00:34:01,776
What that means is, for
my point or my mesh,


648
00:34:02,356 --> 00:34:04,346
how much of the light
that arrives


649
00:34:04,346 --> 00:34:07,726
from my world can actually
go to my point and how much


650
00:34:07,726 --> 00:34:09,646
of my light is actually
blocked by my mesh


651
00:34:09,866 --> 00:34:10,766
and its surrounding meshes.


652
00:34:11,746 --> 00:34:14,996
So it's basically a
signal, one, for white,


653
00:34:14,996 --> 00:34:17,666
saying I have absolutely
no blocking.


654
00:34:17,666 --> 00:34:20,485
The whole light arrives
and/or commuting,


655
00:34:20,485 --> 00:34:22,045
most of my light can't go there.


656
00:34:22,476 --> 00:34:23,636
If we were to look
at the signal,


657
00:34:23,976 --> 00:34:24,815
that's what it looks like.


658
00:34:25,545 --> 00:34:28,016
Mostly white, because
most light can go there.


659
00:34:28,346 --> 00:34:31,466
But you see some [inaudible]
physical data there.


660
00:34:32,315 --> 00:34:33,775
How do we compute that.


661
00:34:34,496 --> 00:34:37,166
We compute that using
offline raytracing.


662
00:34:37,166 --> 00:34:39,545
So your mesh gets
into a [inaudible]


663
00:34:39,596 --> 00:34:41,795
and we send rays everywhere.


664
00:34:42,096 --> 00:34:44,106
And we calculate how much rays


665
00:34:44,606 --> 00:34:46,505
if I send rays all
around my points.


666
00:34:46,626 --> 00:34:50,485
How much rays hit the mesh and
how much rays go to the sky box.


667
00:34:50,806 --> 00:34:53,206
Difference between both is
my ambient occlusion signal.


668
00:34:54,315 --> 00:34:55,716
So what do we require
from you guys?


669
00:34:56,545 --> 00:34:59,186
An input. It's a
mesh, my spaceship,


670
00:34:59,626 --> 00:35:00,696
and a set of occlusion meshes.


671
00:35:01,276 --> 00:35:02,776
So here it's only a spaceship.


672
00:35:02,776 --> 00:35:04,446
If I were, for example,
to represent


673
00:35:04,446 --> 00:35:07,636
that scene right there, and
I wanted to make the ground.


674
00:35:07,636 --> 00:35:09,366
So it would compute ambient
occlusion for the ground.


675
00:35:09,556 --> 00:35:13,666
I would also need all the chairs
and the people and the floors


676
00:35:13,666 --> 00:35:15,716
and all of that to stop the rays


677
00:35:15,766 --> 00:35:18,826
so that I have a very
nicely looking mesh.


678
00:35:18,826 --> 00:35:19,776
So that would be a nice set.


679
00:35:20,876 --> 00:35:21,956
And what do I get as output,


680
00:35:21,956 --> 00:35:25,776
a set of occlusion values
just for every point.


681
00:35:26,626 --> 00:35:27,736
What is the occlusion
of that point.


682
00:35:29,136 --> 00:35:30,396
So how exactly do we store that?


683
00:35:30,826 --> 00:35:34,176
We have two ways, either
vertices or textures.


684
00:35:34,676 --> 00:35:36,536
So if my mesh has
lots of vertices


685
00:35:36,536 --> 00:35:39,566
for example a big
spaceship with plenty


686
00:35:39,566 --> 00:35:42,066
of triangles we can just
store that in vertices.


687
00:35:42,316 --> 00:35:44,996
It works very well because its
very cheap it's nearly one float


688
00:35:44,996 --> 00:35:50,056
per vertex and using
rasterization for your metal


689
00:35:50,056 --> 00:35:52,286
or pipeline, it's
extremely cheap to render,


690
00:35:53,596 --> 00:35:56,916
but for example, that spaceship
is actually fairly low triangles


691
00:35:57,176 --> 00:35:58,286
and so we need a texture.


692
00:35:59,686 --> 00:36:02,386
So we actually built for
you guys inside Model I/O,


693
00:36:02,696 --> 00:36:05,976
a UV mapper that creates
2D texture and wraps it


694
00:36:05,976 --> 00:36:08,246
around the 3D mesh, and
so that corresponds.


695
00:36:08,746 --> 00:36:11,816
And then for every pixel
of that texture we have an


696
00:36:11,816 --> 00:36:12,496
ambient occlusion.


697
00:36:12,936 --> 00:36:14,986
If we were to look at what
that texture looks like for


698
00:36:14,986 --> 00:36:16,196
that spaceship, it
looks like this.


699
00:36:16,196 --> 00:36:20,286
So you can see it's
basically the texture wrapped


700
00:36:20,286 --> 00:36:22,176
around the spaceship.


701
00:36:22,176 --> 00:36:26,576
You can see the wings and the
engine base and all of that.


702
00:36:26,806 --> 00:36:27,866
How do we compute that?


703
00:36:27,966 --> 00:36:28,726
It's very easy.


704
00:36:28,916 --> 00:36:30,066
It's literally a one liner.


705
00:36:30,376 --> 00:36:32,566
You can look at the
top one for example,


706
00:36:33,066 --> 00:36:35,026
shipMesh
generateAmbientOcclusion,


707
00:36:35,816 --> 00:36:36,596
here it's vertex.


708
00:36:36,596 --> 00:36:40,916
And so we have two parameters
quality and attenuation factor.


709
00:36:41,656 --> 00:36:44,816
If we increase quality, what it
will do, it will send more rays


710
00:36:44,926 --> 00:36:46,886
to get a better looking
signal but it's going


711
00:36:46,886 --> 00:36:48,396
to take a bit more
time to compute.


712
00:36:49,276 --> 00:36:52,536
Because it's baking, it's
before you even launch the game,


713
00:36:52,536 --> 00:36:52,906
but still.


714
00:36:53,486 --> 00:36:56,536
And if we have a textural bake,
then the texture will be bigger


715
00:36:56,536 --> 00:36:58,946
so it will increase a
bit your memory cost.


716
00:36:58,946 --> 00:37:01,746
And then that attenuation will
simply attenuate the signal


717
00:37:01,816 --> 00:37:03,666
so only the darker
parts stay dark.


718
00:37:04,916 --> 00:37:07,566
The really cool thing here
is we actually partnered


719
00:37:07,566 --> 00:37:09,926
with the SceneKit team to
integrate those features


720
00:37:09,926 --> 00:37:12,436
in both SceneKit but even
in the SceneKit editor


721
00:37:12,436 --> 00:37:14,126
that you guys saw at
the state of the union.


722
00:37:14,566 --> 00:37:20,266
And I would like to
show you that right now.


723
00:37:20,956 --> 00:37:22,876
So it works.


724
00:37:23,236 --> 00:37:26,756
So I just loaded
here a little scene


725
00:37:27,066 --> 00:37:31,356
that literally has a
spaceship and a sky box around.


726
00:37:31,466 --> 00:37:33,666
The ship is very
nicely flying in space.


727
00:37:33,966 --> 00:37:38,196
I added no lights here,
which is why is is very flat.


728
00:37:38,196 --> 00:37:40,406
The only thing that we are
visualizing right now is


729
00:37:40,406 --> 00:37:40,956
ambient lighting.


730
00:37:41,506 --> 00:37:45,146
And as you can see the ambient
lighting does not take what the


731
00:37:45,246 --> 00:37:47,066
ship looks like into
account whatsoever.


732
00:37:47,066 --> 00:37:49,956
It doesn't give the user
nice feedback in terms


733
00:37:49,956 --> 00:37:52,146
of where the geometry
is, so its very flat.


734
00:37:52,226 --> 00:37:53,526
We're going to change that.


735
00:37:54,136 --> 00:37:56,146
So I'm going to click
on my mesh and first,


736
00:37:56,146 --> 00:37:58,616
I will see that we actually have
a fair amount of vertexes here


737
00:37:58,826 --> 00:37:59,816
so we will do a vertex bake.


738
00:38:00,086 --> 00:38:02,336
I will bring up the
geometry tab.


739
00:38:02,876 --> 00:38:05,796
I'm going to go here
and under occlusion bake


740
00:38:05,886 --> 00:38:06,606
and choose the vertex,


741
00:38:07,716 --> 00:38:10,996
those values are
perfect, and press bake.


742
00:38:11,606 --> 00:38:12,316
So what's happening here?


743
00:38:12,846 --> 00:38:16,356
For every little vertex of that
ship, we will send between 100


744
00:38:16,356 --> 00:38:20,346
to 200 rays around and
then it looks like this.


745
00:38:21,366 --> 00:38:23,156
See? Way better!


746
00:38:23,736 --> 00:38:27,306
We had this and now
we have got this.


747
00:38:27,306 --> 00:38:28,206
And it makes perfect sense.


748
00:38:28,356 --> 00:38:30,676
If you look at, for
example, here, the top deck,


749
00:38:30,946 --> 00:38:32,446
created occlusion
on the bottom one,


750
00:38:32,446 --> 00:38:34,306
because the light can't
arrive there easily.


751
00:38:34,516 --> 00:38:38,246
If we look at the windows
inside here, here the inner port


752
00:38:38,246 --> 00:38:40,366
of the windows have more
occlusion than the outer parts.


753
00:38:41,366 --> 00:38:42,896
If we look here.


754
00:38:43,236 --> 00:38:43,886
Let me zoom in.


755
00:38:44,706 --> 00:38:46,786
If we look here at the
cannons underneath,


756
00:38:47,106 --> 00:38:48,986
the top of the cannons
are really dark


757
00:38:48,986 --> 00:38:51,526
because the whole ship stops
the light from arriving there.


758
00:38:51,906 --> 00:38:53,776
If we were to look
at the bottom parts,


759
00:38:53,856 --> 00:38:55,936
all white, makes sense, right?


760
00:38:56,746 --> 00:39:00,356
So by just adding one float
per vertex, we were able


761
00:39:00,486 --> 00:39:04,406
to give our ambient light
away to light up our scenes


762
00:39:04,406 --> 00:39:05,706
and give a better look.


763
00:39:06,816 --> 00:39:09,136
And that's available in the
[inaudible] of SceneKit.


764
00:39:09,936 --> 00:39:12,486
So let's go back to the slides.


765
00:39:13,796 --> 00:39:15,086
So that was ambient occlusion.


766
00:39:15,196 --> 00:39:18,046
I will finish today
by introducing you


767
00:39:18,046 --> 00:39:20,036
to advanced lighting
with light maps.


768
00:39:21,246 --> 00:39:22,826
So what is light maps?


769
00:39:23,326 --> 00:39:27,226
What light maps are is a way
to get your diffused lighting


770
00:39:27,226 --> 00:39:30,256
into the game and precomputing
how the diffused lighting


771
00:39:30,256 --> 00:39:33,126
affects your textures to not
have to do that in realtime.


772
00:39:33,286 --> 00:39:35,986
As you guys know, if you have
done some game programming,


773
00:39:36,446 --> 00:39:38,566
lighting is extremely expensive.


774
00:39:38,746 --> 00:39:41,806
If you have ten lights then for
every frame you need to compute


775
00:39:41,916 --> 00:39:46,546
that lights' aspect and how
that interferes with your game.


776
00:39:46,866 --> 00:39:48,146
That's very expensive.


777
00:39:48,146 --> 00:39:52,806
So what we have here, I just
dragged and dropped a plane


778
00:39:52,806 --> 00:39:55,886
and two boxes inside a simulator
and put eight lights there


779
00:39:56,276 --> 00:39:58,396
and I computed, before I
even launched the game,


780
00:39:58,396 --> 00:40:02,486
using light map baker how those
light maps light up my scene


781
00:40:02,486 --> 00:40:03,586
and light up the texture.


782
00:40:04,996 --> 00:40:08,136
And if we were to
look at the scene,


783
00:40:08,516 --> 00:40:09,796
that's what it looks like.


784
00:40:09,856 --> 00:40:11,976
It's really realistic.


785
00:40:12,066 --> 00:40:12,896
We've got the shadows
and the lights


786
00:40:13,426 --> 00:40:16,536
but this costs me
literally one texture fetch.


787
00:40:17,626 --> 00:40:18,846
That's it.


788
00:40:19,736 --> 00:40:22,346
Usually rendering eight lights
especially if you've got shadows


789
00:40:22,346 --> 00:40:23,686
and shadow maps they
are very expensive.


790
00:40:24,296 --> 00:40:25,316
That's what the texture
looks like.


791
00:40:25,436 --> 00:40:27,586
Very straightforward,
you see my boxes


792
00:40:27,586 --> 00:40:29,096
in the middle and my shadows.


793
00:40:29,616 --> 00:40:33,696
The cool thing is this is
just a texture fetch, right?


794
00:40:33,736 --> 00:40:35,246
So it supports lots of lights.


795
00:40:35,406 --> 00:40:38,136
I could have 100,000
lights if I wanted


796
00:40:38,136 --> 00:40:41,336
and it would have the
exact same runtime costs.


797
00:40:41,686 --> 00:40:43,856
Even the shadows
look really cool.


798
00:40:44,266 --> 00:40:47,506
When you do spotlights like
this, that are really close


799
00:40:47,506 --> 00:40:50,786
to the ground then the
shadow maps you reach kind


800
00:40:50,786 --> 00:40:54,066
of precision issues but
with this, for every pixel


801
00:40:54,066 --> 00:40:57,296
on the thing, we send rays and
see which ones are in the light


802
00:40:57,296 --> 00:40:58,236
and which ones are not.


803
00:40:58,476 --> 00:41:00,506
So your shadows look
really realistic.


804
00:41:00,506 --> 00:41:01,616
Calculate it offline.


805
00:41:02,136 --> 00:41:07,096
And the cool thing is we
support super complex slide


806
00:41:07,146 --> 00:41:10,936
that you couldn't even
dream of doing at run time.


807
00:41:10,936 --> 00:41:14,836
For example our real lights have
for a long time been really hard


808
00:41:14,836 --> 00:41:17,486
to do at runtime because
they are really hard to do


809
00:41:17,486 --> 00:41:21,596
with normal point light to
triangle illumination processes


810
00:41:21,826 --> 00:41:23,706
but here we are using
ray tracing.


811
00:41:23,706 --> 00:41:25,226
So we just send the ray and see


812
00:41:25,226 --> 00:41:27,376
which ones arrive [inaudible]
and which ones don't.


813
00:41:28,036 --> 00:41:29,946
We also support the
cool IS lights,


814
00:41:30,486 --> 00:41:31,876
that Nick talked to you before.


815
00:41:32,536 --> 00:41:34,816
And that was light maps.


816
00:41:35,376 --> 00:41:38,926
So to close this talk, I
would like to summarize a bit.


817
00:41:39,136 --> 00:41:40,826
Today we introduced
a great new framework


818
00:41:40,826 --> 00:41:42,336
and we are super happy about it.


819
00:41:43,136 --> 00:41:47,416
First it does the basics imports
and exports 3D asset files.


820
00:41:47,646 --> 00:41:49,346
But is actually does
so much more for you.


821
00:41:49,846 --> 00:41:52,476
It introduces concepts for
physical basis for rendering,


822
00:41:52,876 --> 00:41:54,776
with models, lights,
cameras, materials,


823
00:41:54,776 --> 00:41:56,976
and skies that aren't
just defined with floats


824
00:41:56,976 --> 00:41:59,556
but are actually based
on stuff in real life.


825
00:42:00,136 --> 00:42:03,206
We have integration of system
in the frameworks and tools


826
00:42:03,286 --> 00:42:05,396
in Xcode that you guys can
play with that and have fun.


827
00:42:07,046 --> 00:42:10,296
For more information, we invite
you to look at our documentation


828
00:42:10,296 --> 00:42:12,416
and videos and forums
and our technical support


829
00:42:12,856 --> 00:42:15,636
and for any general inquiries,
you can contact Allan Schaffer.


830
00:42:16,596 --> 00:42:19,386
Related sessions
are "Enhancements


831
00:42:19,386 --> 00:42:22,096
to SceneKit" tomorrow
and "What's New


832
00:42:22,096 --> 00:42:22,986
In Metal" on Thursday.


833
00:42:23,366 --> 00:42:27,026
And we would like to see you
at Model I/O Lab right now


834
00:42:27,086 --> 00:42:28,776
and tomorrow morning at 9AM.


835
00:42:29,246 --> 00:42:32,096
Thank you all for your
time and have a great WWDC.


836
00:42:33,516 --> 00:42:45,850
[ Applause ]

