1
00:00:14,616 --> 00:00:16,976
>> Hi. Welcome to the
Advanced CloudKit session.


2
00:00:17,516 --> 00:00:20,546
[ Cheering & Applause ]


3
00:00:21,046 --> 00:00:21,416
Thank you.


4
00:00:21,546 --> 00:00:23,526
My name is Jacob Farkas.


5
00:00:23,526 --> 00:00:25,496
I'm a Software Engineer
at Apple and one


6
00:00:25,496 --> 00:00:26,896
of the designers of
the CloudKit API.


7
00:00:27,656 --> 00:00:29,766
And my colleagues and I
have put a lot of hard work


8
00:00:29,766 --> 00:00:30,706
into the CloudKit API.


9
00:00:30,706 --> 00:00:33,356
I'm really excited to talk
to you guys about it today.


10
00:00:33,356 --> 00:00:35,306
So, let's jump right into it.


11
00:00:36,276 --> 00:00:40,616
So, CloudKit is this thing
that we've built on top


12
00:00:40,616 --> 00:00:41,886
of our iCloud servers.


13
00:00:41,886 --> 00:00:45,286
We've built a lot of iCloud
services, and what we're doing


14
00:00:45,286 --> 00:00:48,626
with CloudKit is exposing those
database servers that we use


15
00:00:48,626 --> 00:00:51,246
at Apple to all of
you developers.


16
00:00:52,186 --> 00:00:54,026
So, we're actually using this.


17
00:00:54,026 --> 00:00:56,796
This is something that we
use in the new iCloud Photos


18
00:00:56,796 --> 00:00:58,956
and iCloud Drive feature
that we're introducing,


19
00:00:59,516 --> 00:01:02,366
and we're building all of
that on top of CloudKit.


20
00:01:03,366 --> 00:01:06,056
If all of this is unfamiliar to
you, you might want to go back


21
00:01:06,056 --> 00:01:08,206
and check out the
Introducing CloudKit session.


22
00:01:08,206 --> 00:01:11,506
It was given on Tuesday and
there should be videos online.


23
00:01:12,876 --> 00:01:14,306
So, we're going to
jump right into this.


24
00:01:14,456 --> 00:01:15,886
What we're going to learn today,


25
00:01:15,886 --> 00:01:18,736
we're going to over the CloudKit
private database, which is a way


26
00:01:18,736 --> 00:01:21,236
for you store private user
information in iCloud.


27
00:01:22,266 --> 00:01:24,386
We're going to talk about
modeling your data in CloudKit.


28
00:01:25,516 --> 00:01:27,956
We're going to talk about
advanced record manipulation


29
00:01:27,956 --> 00:01:30,066
and different ways of saving
records to the server.


30
00:01:31,466 --> 00:01:34,276
We're going to go over how to
handle notifications reliably,


31
00:01:34,526 --> 00:01:36,156
if you miss a push, what to do.


32
00:01:37,666 --> 00:01:39,866
And finally, we're going to
go over the iCloud Dashboard


33
00:01:39,866 --> 00:01:41,456
which is a web-based interface


34
00:01:41,456 --> 00:01:43,126
for managing your
CloudKit application.


35
00:01:45,496 --> 00:01:47,246
So, let's start off by looking


36
00:01:47,246 --> 00:01:48,916
at the CloudKit API
really quick.


37
00:01:50,346 --> 00:01:53,606
We designed the CloudKit API
to be highly asynchronous.


38
00:01:53,606 --> 00:01:57,416
Everything has a callback,
nothing is synchronous.


39
00:01:57,486 --> 00:01:59,056
And we did this because all


40
00:01:59,056 --> 00:02:00,836
of these requests are
going out over the network.


41
00:02:01,316 --> 00:02:03,686
When you get the network
involved, anything can happen,


42
00:02:03,686 --> 00:02:06,446
you know, the server might
not be responding quickly,


43
00:02:06,446 --> 00:02:08,036
there might be a bad
network connection.


44
00:02:08,395 --> 00:02:11,736
We don't want to block the UI
and cause a bad user experience.


45
00:02:12,816 --> 00:02:16,036
And to help do this, we've used
NSOperation almost everywhere


46
00:02:16,036 --> 00:02:16,516
in our API.


47
00:02:17,576 --> 00:02:20,636
I say almost everywhere
because if you went


48
00:02:20,636 --> 00:02:21,986
to the introductory session,


49
00:02:21,986 --> 00:02:24,406
you remember seeing what we
called the Convenience API.


50
00:02:25,276 --> 00:02:29,086
And the Convenience API is our
way of helping you get started


51
00:02:29,086 --> 00:02:30,916
with CloudKit really
quickly and simply.


52
00:02:31,406 --> 00:02:35,046
All of these APIs are, you
know, single calls that work


53
00:02:35,046 --> 00:02:36,986
on one record at a time.


54
00:02:36,986 --> 00:02:39,116
So, in this case, we're
fetching one record


55
00:02:39,606 --> 00:02:41,076
and it's asynchronous.


56
00:02:41,076 --> 00:02:43,286
We get that one record back
in our completionHandler.


57
00:02:44,156 --> 00:02:46,496
But, as you use CloudKit
more, you might find


58
00:02:46,496 --> 00:02:48,026
that you need some
additional functionality.


59
00:02:48,676 --> 00:02:51,376
And that's where the
NSOperation-based API comes in.


60
00:02:52,066 --> 00:02:55,506
So, what we've got here is
the CKFetchRecordsOperation.


61
00:02:55,556 --> 00:02:58,696
And this is an NSOperation
that does the equivalent


62
00:02:58,696 --> 00:03:00,436
of that convenience
API we just saw.


63
00:03:01,136 --> 00:03:02,656
We give you a lot
more functionality


64
00:03:02,656 --> 00:03:04,996
when you use the
NSOperation-based API.


65
00:03:05,596 --> 00:03:09,316
So, you can see here that our
initializer takes an array


66
00:03:09,316 --> 00:03:09,876
of record IDs.


67
00:03:09,876 --> 00:03:13,046
You can fetch a whole batch
of records all at once.


68
00:03:14,286 --> 00:03:16,296
We also give you more
feedback on what's happening.


69
00:03:16,296 --> 00:03:18,886
We've got a completion
block for each record,


70
00:03:18,886 --> 00:03:20,326
and we also give you progress


71
00:03:20,326 --> 00:03:22,056
as we download those
records from the server.


72
00:03:22,646 --> 00:03:28,306
And finally, these operations
give you more knobs and levers


73
00:03:28,306 --> 00:03:32,196
to tweak what is returned
and what the operation does.


74
00:03:32,196 --> 00:03:34,816
In this case, we've got
a desiredKeys property


75
00:03:34,816 --> 00:03:36,916
that lets you specify
what key should come back


76
00:03:36,916 --> 00:03:40,436
on the records that you fetch.


77
00:03:40,656 --> 00:03:43,086
So, since all of this
is built on NSOperation,


78
00:03:43,086 --> 00:03:44,176
let's do a quick overview


79
00:03:44,176 --> 00:03:46,366
of what the NSOperation
class looks like.


80
00:03:47,466 --> 00:03:50,446
What we've got in NSOperation
is a completionBlock


81
00:03:50,446 --> 00:03:53,176
and a cancel call so that
you can manage the life cycle


82
00:03:53,176 --> 00:03:53,946
of your operation.


83
00:03:55,406 --> 00:03:56,586
We've got a couple of variables


84
00:03:56,586 --> 00:03:58,606
that tell you some state
about the operation.


85
00:03:59,756 --> 00:04:01,916
And NSOperations
have dependencies,


86
00:04:01,916 --> 00:04:04,376
so you can link two
NSOperations together.


87
00:04:06,956 --> 00:04:09,336
Once you have an NSOperation,
you're going to want to start


88
00:04:09,336 --> 00:04:11,566
that operation, and you
do that by adding it


89
00:04:11,566 --> 00:04:13,266
to an NSOperationQueue.


90
00:04:13,806 --> 00:04:16,276
When you have an
NSOperationQueue,


91
00:04:16,276 --> 00:04:19,276
you can also manage the life
cycle of that operation queue.


92
00:04:19,276 --> 00:04:21,156
You can suspend it
and resume it,


93
00:04:21,456 --> 00:04:23,826
and you can cancel
the operations in it.


94
00:04:26,156 --> 00:04:28,836
So, if you go to look at
our NSOperation-based API,


95
00:04:28,836 --> 00:04:30,906
you might just see this
big list of a bunch


96
00:04:30,906 --> 00:04:32,026
of different operations.


97
00:04:32,026 --> 00:04:33,896
It's kind of overwhelming
and confusing.


98
00:04:34,396 --> 00:04:36,796
The best way to think
about this API is to think


99
00:04:36,796 --> 00:04:38,736
about the objects that
you want to deal with.


100
00:04:39,236 --> 00:04:41,076
If you remember from
the introductory talk,


101
00:04:41,756 --> 00:04:44,936
CloudKits-based objects
are records and zones


102
00:04:44,936 --> 00:04:48,546
and subscriptions, and you'll
see that up here we have a fetch


103
00:04:48,546 --> 00:04:50,926
and a modify operation
for all of those items.


104
00:04:50,926 --> 00:04:57,476
One of the really cool
things about NSOperation is


105
00:04:57,476 --> 00:04:58,616
that is has dependencies.


106
00:04:58,616 --> 00:05:01,656
So, you can set a dependency
between two operations


107
00:05:02,226 --> 00:05:04,506
and the second operation
won't fire


108
00:05:04,506 --> 00:05:06,226
until the first operation
is completed.


109
00:05:06,786 --> 00:05:09,796
This is really handy
with CloudKit if you want


110
00:05:09,796 --> 00:05:13,146
to do something like fetch a
record, add a property to it,


111
00:05:13,146 --> 00:05:14,936
and save that record
back to the server.


112
00:05:15,576 --> 00:05:17,696
You can make the
FetchRecordsOperation,


113
00:05:17,856 --> 00:05:21,646
make the modify operation at the
same time, set up a dependency,


114
00:05:22,046 --> 00:05:24,046
and when the fetch completes,
you can put that data


115
00:05:24,046 --> 00:05:26,286
in the modify operation, and
it'll start automatically.


116
00:05:26,836 --> 00:05:30,786
These dependencies also
work between queues.


117
00:05:30,786 --> 00:05:34,566
So, even though CloudKit has
its own internal operation queue


118
00:05:34,566 --> 00:05:37,006
that you can use to run
operations, you're welcome


119
00:05:37,326 --> 00:05:39,486
to create your own
NSOperation queue,


120
00:05:39,856 --> 00:05:41,436
and you can then
manage its life cycle.


121
00:05:41,436 --> 00:05:47,716
You can stop operations or
suspend them or cancel them.


122
00:05:47,926 --> 00:05:51,326
One tip with using
NSOperation though is


123
00:05:51,326 --> 00:05:55,146
that the NSOperation-based class
has a completionBlock on it.


124
00:05:55,766 --> 00:05:56,926
This completionBlock ends


125
00:05:56,926 --> 00:05:59,496
up firing asynchronously
with dependencies.


126
00:05:59,496 --> 00:06:01,056
So, if you've set
up dependencies


127
00:06:01,096 --> 00:06:03,466
and you're using the
NSOperation's completion block,


128
00:06:03,916 --> 00:06:05,586
they might happen
at the same time,


129
00:06:05,996 --> 00:06:07,586
and that data you
were trying to funnel


130
00:06:07,586 --> 00:06:10,596
into the next operation won't
get there in time, you know,


131
00:06:10,596 --> 00:06:11,876
that operation has
already started.


132
00:06:12,576 --> 00:06:15,056
So, what we've done with
the CloudKit API is we have


133
00:06:15,106 --> 00:06:16,996
CloudKit-specific
completion blocks.


134
00:06:17,416 --> 00:06:21,316
And if we look at what we had
for that fetchRecords operation,


135
00:06:21,806 --> 00:06:23,766
we have a
fetchRecordsCompletionBlock.


136
00:06:24,456 --> 00:06:26,946
You'll see this pattern on
all of our NSOperations.


137
00:06:26,946 --> 00:06:29,366
And these completion
blocks hand back all


138
00:06:29,366 --> 00:06:30,906
of the information
you needed to know


139
00:06:30,906 --> 00:06:32,286
about the operation
that just ran.


140
00:06:32,806 --> 00:06:35,756
In this case, we've got the
errors for that operation,


141
00:06:35,756 --> 00:06:38,396
and we've also got the
records that were fetched.


142
00:06:40,466 --> 00:06:43,146
And finally, NSOperations can
have their own priorities.


143
00:06:43,146 --> 00:06:45,856
So, you can set background
operations and have them run


144
00:06:45,856 --> 00:06:48,656
at a really low priority
and keep your UI responsive.


145
00:06:49,066 --> 00:06:52,226
So, when we were
designing CloudKit,


146
00:06:52,306 --> 00:06:53,406
one of the things we noticed is


147
00:06:53,406 --> 00:06:55,546
that there's two general
classes of applications.


148
00:06:56,366 --> 00:06:59,816
There's one class of application
that stores a whole bunch


149
00:06:59,816 --> 00:07:02,836
of data up on the server, and
when you use the application,


150
00:07:02,836 --> 00:07:04,476
it's just presenting
the view of that data.


151
00:07:04,476 --> 00:07:07,556
It downloads it on demand,
displays it to the user,


152
00:07:07,556 --> 00:07:10,096
and then, you know,
tosses it out because it's,


153
00:07:10,096 --> 00:07:11,446
the real copy's on the server.


154
00:07:12,266 --> 00:07:13,866
But there's another
class of application


155
00:07:13,866 --> 00:07:16,346
that has just a little
bit of data, but you want


156
00:07:16,346 --> 00:07:18,376
that same data on
all of your clients.


157
00:07:19,706 --> 00:07:21,536
So, if you remember from
the introductory talk,


158
00:07:21,536 --> 00:07:24,446
we talked about what we
called Big Data, Little Phone.


159
00:07:24,446 --> 00:07:26,826
That's that case where we have
a lot of data on the server.


160
00:07:27,306 --> 00:07:30,156
It's not all going to fit on
one phone, and you download it


161
00:07:30,156 --> 00:07:31,196
and view it on demand.


162
00:07:31,456 --> 00:07:33,886
So, you can see these clients
are downloading records,


163
00:07:33,916 --> 00:07:37,156
viewing them, and the truth
lives up on the server.


164
00:07:38,716 --> 00:07:40,966
However, there's another
class of application,


165
00:07:41,626 --> 00:07:43,686
where it's a small
amount of data.


166
00:07:43,686 --> 00:07:46,816
It lives on one client, but you
want it on all your clients.


167
00:07:47,086 --> 00:07:48,986
An example of this
is an application


168
00:07:48,986 --> 00:07:50,076
that manages your receipts.


169
00:07:50,146 --> 00:07:53,836
So, every time you buy
something, you take a picture


170
00:07:53,836 --> 00:07:57,846
of the receipt, and you want
that information on your phone,


171
00:07:57,846 --> 00:08:00,746
in your iPad, in your Mac,
and you want them all to be


172
00:08:00,746 --> 00:08:02,306
up to date with the
same receipts.


173
00:08:05,716 --> 00:08:07,556
So, what we've done
to help you solve


174
00:08:07,556 --> 00:08:11,146
that is we've got something
in CloudKit that does that.


175
00:08:11,146 --> 00:08:13,946
If you remember, we have, every
application gets a container.


176
00:08:14,756 --> 00:08:17,146
In every container is a
public and private database.


177
00:08:18,016 --> 00:08:20,296
And just as a refresher,


178
00:08:20,296 --> 00:08:22,676
that private database is
actually one private database


179
00:08:22,676 --> 00:08:23,476
for every user.


180
00:08:26,156 --> 00:08:27,516
Inside of those databases,


181
00:08:27,516 --> 00:08:29,196
we then subdivide
them down into zones.


182
00:08:29,316 --> 00:08:32,706
So, both the public and the
private database have a default


183
00:08:32,736 --> 00:08:33,265
zone in them.


184
00:08:34,426 --> 00:08:37,275
But we've also given you
what we call custom zones,


185
00:08:37,275 --> 00:08:40,486
and these custom zones allow us
to give you some extra features


186
00:08:40,486 --> 00:08:42,816
that we can't provide
in the default zones.


187
00:08:44,536 --> 00:08:47,786
You can create these custom
zones and use the new features.


188
00:08:47,846 --> 00:08:50,556
Let's go over a couple of them.


189
00:08:50,756 --> 00:08:53,246
The first feature
is atomic commits.


190
00:08:54,516 --> 00:08:57,286
So, CloudKit has
relationships between records.


191
00:08:57,286 --> 00:09:00,596
And if you start using CloudKit
and using these relationships,


192
00:09:00,596 --> 00:09:03,476
you're going to build up an
object graph, and you're going


193
00:09:03,476 --> 00:09:06,966
to realize you want
consistency in your data.


194
00:09:06,966 --> 00:09:09,466
If, you know, you might have
an object graph that you want


195
00:09:09,466 --> 00:09:10,556
to commit all at once.


196
00:09:10,586 --> 00:09:13,186
And if some of those
things don't get committed,


197
00:09:13,186 --> 00:09:15,996
the data on the server
doesn't make sense.


198
00:09:16,296 --> 00:09:18,296
On the public database,
we can't guarantee


199
00:09:18,296 --> 00:09:20,616
that because there might
be thousands or millions


200
00:09:20,616 --> 00:09:22,246
of users hitting
the same database.


201
00:09:22,246 --> 00:09:25,496
So, there's no way to lock the
database while we, you know,


202
00:09:25,496 --> 00:09:27,106
commit your very
special records.


203
00:09:27,916 --> 00:09:31,416
But in the private database,
you only have one user.


204
00:09:31,416 --> 00:09:33,156
It's the current user's account.


205
00:09:33,196 --> 00:09:40,506
And in that case, we can provide
you things like atomic commits.


206
00:09:40,586 --> 00:09:43,176
So, with atomic commits,
these batch operations


207
00:09:43,206 --> 00:09:46,726
in the NSOperation API will
succeed or fail as a whole.


208
00:09:47,106 --> 00:09:49,216
So, if any record had a problem,


209
00:09:49,926 --> 00:09:52,886
you will get back a
CKErrorPartialFailure.


210
00:09:54,546 --> 00:09:56,846
Inside of that partial
failure error, you're going


211
00:09:56,846 --> 00:09:59,526
to see a user, the
userInfo dictionary is going


212
00:09:59,576 --> 00:10:02,246
to have this
CKPartialErrorsByItemID key.


213
00:10:03,386 --> 00:10:05,796
And that's going to be a
dictionary of record IDs


214
00:10:06,306 --> 00:10:08,336
to errors for each
of those records.


215
00:10:09,116 --> 00:10:10,556
And some of those
errors are going


216
00:10:10,556 --> 00:10:12,416
to be the real failures
that you care about.


217
00:10:12,476 --> 00:10:14,636
These are the reasons that
the atomic commit failed.


218
00:10:15,376 --> 00:10:17,486
But, you know, the rest
of the records failed


219
00:10:17,486 --> 00:10:19,726
because it was atomic commit,
and we need to let you know


220
00:10:19,726 --> 00:10:21,476
that they failed,
so you're also going


221
00:10:21,556 --> 00:10:23,576
to see
CKErrorBatchRequestFailed.


222
00:10:24,306 --> 00:10:26,006
That's just a way of
saying that something else


223
00:10:26,006 --> 00:10:27,816
in this batch failed,
and, you know,


224
00:10:27,816 --> 00:10:32,726
this wasn't the real problem, it
was that other record in here.


225
00:10:32,946 --> 00:10:34,466
Another great feature
that we give you


226
00:10:34,466 --> 00:10:36,566
with custom zones
are delta downloads.


227
00:10:37,946 --> 00:10:40,656
So, delta downloads are a
way for that second class


228
00:10:40,656 --> 00:10:43,586
of application to be
possible in CloudKit.


229
00:10:43,966 --> 00:10:46,456
You can download only the
changes that were made


230
00:10:46,456 --> 00:10:48,996
in that zone, and you can
cache them all locally.


231
00:10:48,996 --> 00:10:51,926
So, what does that look like?


232
00:10:52,236 --> 00:10:55,306
Well, we've got our Mac here,
and we've got our iPhone,


233
00:10:55,736 --> 00:10:57,126
and we've got a custom zone.


234
00:10:57,936 --> 00:11:00,096
So, let's step through a
delta download really quick.


235
00:11:00,896 --> 00:11:02,966
We've got an orange
record and a green record


236
00:11:02,966 --> 00:11:05,496
over on the Mac here, and we
want them on the phone as well.


237
00:11:05,856 --> 00:11:08,346
So, we're going to first
upload those both into CloudKit


238
00:11:08,346 --> 00:11:12,346
in our custom zone, and
then our iPhone is going


239
00:11:12,346 --> 00:11:15,946
to perform a delta
download to get up to date.


240
00:11:17,456 --> 00:11:19,396
So, these delta downloads
are based


241
00:11:19,396 --> 00:11:20,836
on what we call change tokens.


242
00:11:20,836 --> 00:11:23,406
And a change token is a
way of tracking the state


243
00:11:23,406 --> 00:11:25,226
of the server the last
time you talked to it.


244
00:11:26,176 --> 00:11:28,256
So, this phone has never
talked to the server,


245
00:11:28,726 --> 00:11:31,536
and what it's going to do is
send up a nil change token.


246
00:11:31,536 --> 00:11:33,466
And that's a way of saying,
"I've never talked to you,


247
00:11:33,466 --> 00:11:35,216
just send me all the
records in the zone."


248
00:11:36,106 --> 00:11:38,176
So, the server is the going
to take that nil change token,


249
00:11:38,936 --> 00:11:41,376
send down an, the orange
record and green record.


250
00:11:41,876 --> 00:11:44,056
The phone is going to save
them into its local database.


251
00:11:44,646 --> 00:11:47,106
And then the server is going to
send down a new change token.


252
00:11:47,556 --> 00:11:50,466
In this case, it's change
token A, and that means that,


253
00:11:50,466 --> 00:11:53,566
you know, the records you
have are all from state A.


254
00:11:53,566 --> 00:11:56,766
If the phone came back
again with change tag A,


255
00:11:56,766 --> 00:11:58,296
the server will go, "Well,
I don't have anything


256
00:11:58,296 --> 00:11:59,856
for you, A is good enough.


257
00:11:59,986 --> 00:12:00,916
There's nothing to download."


258
00:12:01,446 --> 00:12:05,796
But let's say the Mac
comes along and it creates


259
00:12:05,796 --> 00:12:08,386
that purple record, and it
deletes the green record.


260
00:12:08,626 --> 00:12:10,736
And it uploads those
changes to the server.


261
00:12:11,716 --> 00:12:14,076
The server is going to track
the changes, so it'll note


262
00:12:14,076 --> 00:12:15,476
that that green record
was deleted.


263
00:12:15,556 --> 00:12:17,346
It'll note that there's
a new purple record.


264
00:12:18,106 --> 00:12:20,566
And now, when the iPhone
comes back with change tag A,


265
00:12:21,106 --> 00:12:23,786
the server goes, "All right,
well, we're are at B now.


266
00:12:24,186 --> 00:12:25,086
That's farther than A.


267
00:12:25,916 --> 00:12:27,336
Here's a delete of
the green record


268
00:12:27,336 --> 00:12:30,136
and here's a new purple record
that happened while, you know,


269
00:12:30,136 --> 00:12:31,286
since the last time we talked."


270
00:12:32,686 --> 00:12:34,696
Then it sends back
that new change token


271
00:12:34,986 --> 00:12:37,026
and everyone is up to date.


272
00:12:38,356 --> 00:12:40,526
So, you can use this
delta download


273
00:12:40,526 --> 00:12:43,016
to implement an offline
cache in your application.


274
00:12:43,736 --> 00:12:46,146
If you want to do
that, there's a couple


275
00:12:46,146 --> 00:12:47,156
of steps your app
should to take.


276
00:12:47,156 --> 00:12:49,936
This is kind of an outline
of a basic state machine


277
00:12:49,936 --> 00:12:52,196
for every time you talk
to the server and you want


278
00:12:52,196 --> 00:12:53,146
to do a delta download.


279
00:12:54,556 --> 00:12:56,776
The first thing you're going
to want to do in your app is


280
00:12:56,846 --> 00:12:58,456
to track the local changes.


281
00:12:58,916 --> 00:13:00,716
You're going to want
to make a change table,


282
00:13:01,286 --> 00:13:03,966
and every time the user makes
an edit in your application,


283
00:13:03,966 --> 00:13:04,916
you want to write that down.


284
00:13:04,916 --> 00:13:07,766
You're going to want to do this
because you might be offline


285
00:13:07,766 --> 00:13:10,266
when the user makes the changes,
and you're going to need


286
00:13:10,266 --> 00:13:12,496
to replay all those
changes back to the server


287
00:13:12,496 --> 00:13:14,106
when you can talk to it.


288
00:13:16,116 --> 00:13:17,166
Then, you're going to need


289
00:13:17,166 --> 00:13:19,046
to send all those
changes up to the server.


290
00:13:19,046 --> 00:13:21,006
You want to do that before
you fetch the changes


291
00:13:21,056 --> 00:13:23,666
because someone else might
have changed the record


292
00:13:23,666 --> 00:13:26,356
in the meantime, and you need
to resolve these conflicts.


293
00:13:27,606 --> 00:13:29,776
So, we'll go over conflict
handling in just a little bit,


294
00:13:29,866 --> 00:13:31,196
but just keep in mind


295
00:13:31,196 --> 00:13:33,186
that that's an important
step in this process here.


296
00:13:34,666 --> 00:13:37,086
Finally, you're ready to
do the delta download.


297
00:13:37,086 --> 00:13:38,146
This is the point
where you're going


298
00:13:38,146 --> 00:13:40,526
to call
CKFetchRecordChangesOperation.


299
00:13:41,666 --> 00:13:45,576
The server is going to send
you back updates and deletes


300
00:13:45,576 --> 00:13:48,766
and modifies and adds of
records, and you're going


301
00:13:48,766 --> 00:13:50,496
to save those into
your local database.


302
00:13:51,696 --> 00:13:53,016
Finally, the server is going


303
00:13:53,016 --> 00:13:54,646
to send you back a
new change token.


304
00:13:54,716 --> 00:13:56,396
And that's the change
token you want to save


305
00:13:56,396 --> 00:13:58,296
so that the next time
you talk to the server,


306
00:13:58,746 --> 00:13:59,916
you can get only the records


307
00:13:59,916 --> 00:14:01,646
that have changed
and not everything.


308
00:14:04,476 --> 00:14:07,296
So, one of the other features
we give you with custom zones


309
00:14:07,296 --> 00:14:09,346
and delta downloads
are zone subscriptions.


310
00:14:09,346 --> 00:14:12,956
In the case of that state
machine I just talked about,


311
00:14:13,276 --> 00:14:16,376
you could pull every, you
know, 10 minutes or 5 minutes


312
00:14:16,376 --> 00:14:18,466
or whatever and hope that
there are changes up there.


313
00:14:19,136 --> 00:14:21,256
But wouldn't it be great if
the server just told you,


314
00:14:21,256 --> 00:14:22,226
"Hey, I've got changes.


315
00:14:22,226 --> 00:14:23,356
It's time for delta download."


316
00:14:23,946 --> 00:14:24,816
Well, we give you that.


317
00:14:24,886 --> 00:14:27,296
We give you what we
call zone subscriptions.


318
00:14:27,766 --> 00:14:29,646
These look like query
subscriptions,


319
00:14:29,706 --> 00:14:30,826
but they're a little
bit different.


320
00:14:31,586 --> 00:14:34,746
What they do is every
time something changes


321
00:14:34,746 --> 00:14:37,336
in a custom zone, you'll
get a push notification.


322
00:14:38,076 --> 00:14:39,556
When you see that
push notification,


323
00:14:39,556 --> 00:14:42,056
you know you should go do a
delta download with the server,


324
00:14:42,366 --> 00:14:43,456
and you'll get new records.


325
00:14:43,536 --> 00:14:50,696
So, a couple of notes on
designing custom zones


326
00:14:50,696 --> 00:14:51,716
and when you should use them.


327
00:14:52,956 --> 00:14:56,206
These custom zones are meant
to compartmentalize your data.


328
00:14:56,656 --> 00:14:59,696
Because of that, there's a
couple of restrictions on them.


329
00:14:59,696 --> 00:15:02,416
The first is that you can't
move records between zones.


330
00:15:03,226 --> 00:15:05,096
You can pick these
records up and copy them


331
00:15:05,096 --> 00:15:09,806
and make a new copy in the new
zone, but you can't move them.


332
00:15:09,806 --> 00:15:12,676
You also can't make
any cross-zone delete


333
00:15:12,676 --> 00:15:13,916
self relationships.


334
00:15:14,006 --> 00:15:17,656
So, you have to think of
these zones as self-contained.


335
00:15:17,656 --> 00:15:20,096
If you have records that need to
go across zones, you might want


336
00:15:20,096 --> 00:15:21,086
to rethink your model.


337
00:15:23,696 --> 00:15:26,306
And finally, these zones
determine the level of updates.


338
00:15:26,306 --> 00:15:28,476
If you're using a zone
subscription, you're going


339
00:15:28,476 --> 00:15:30,976
to get a push every single
time something has changed


340
00:15:30,976 --> 00:15:31,526
in that zone.


341
00:15:31,526 --> 00:15:36,006
If you have a lot of data on
the server and you only care


342
00:15:36,006 --> 00:15:38,196
about getting updates for
one part of that data,


343
00:15:38,196 --> 00:15:41,486
you might want to make that a
zone so that you can ignore the,


344
00:15:41,486 --> 00:15:43,956
you know, really busy
stuff going on over here


345
00:15:43,956 --> 00:15:51,236
and just download the
things you care about.


346
00:15:52,276 --> 00:15:54,776
So, let's talk about some
advanced record operations.


347
00:15:55,826 --> 00:15:59,266
When you're using CKRecord,
any changes you make


348
00:15:59,266 --> 00:16:03,676
to a CKRecord object locally get
tracked, and then when we talk


349
00:16:03,676 --> 00:16:06,076
to the server, we're only
going to send the changes


350
00:16:06,076 --> 00:16:07,466
that you made to that CKRecord.


351
00:16:08,636 --> 00:16:10,926
This is the default behavior,
and it works great most


352
00:16:10,926 --> 00:16:14,286
of the time, but you might
want some additional control


353
00:16:14,286 --> 00:16:15,906
over what we're sending
to the server.


354
00:16:16,666 --> 00:16:18,606
And we give you that
with save policies.


355
00:16:19,846 --> 00:16:23,156
So, these save policies,
we have three of them.


356
00:16:23,276 --> 00:16:25,226
They're
CKRecordSaveIfServerUnchanged.


357
00:16:26,266 --> 00:16:32,046
We have CKRecordSaveChangedKeys,
and we have CKRecordSaveAllKeys.


358
00:16:34,236 --> 00:16:37,186
So, let's look at the
differences between those.


359
00:16:38,236 --> 00:16:42,336
The biggest difference is
what they determine for a,


360
00:16:42,376 --> 00:16:43,866
what I'm going to
call a locked save.


361
00:16:44,636 --> 00:16:46,856
And a locked save is
a way of making sure


362
00:16:46,856 --> 00:16:48,646
that you don't overwrite
data on the server


363
00:16:48,646 --> 00:16:50,716
that someone else
has already written.


364
00:16:50,716 --> 00:16:52,156
When you perform a locked save,


365
00:16:52,156 --> 00:16:56,576
it says that if the record has
changed since-on the server


366
00:16:56,576 --> 00:16:57,736
since the time you fetched it,


367
00:16:58,206 --> 00:17:00,336
the server will give you an
error saying your record is


368
00:17:00,336 --> 00:17:03,466
out of date, you need to resolve
this conflict and try again.


369
00:17:04,596 --> 00:17:09,816
So, the only thing that performs
a locked save here is CKRecord


370
00:17:09,816 --> 00:17:12,086
save policy
SaveIfServerUnchanged.


371
00:17:12,786 --> 00:17:16,076
The other two actually force
these changes to the server.


372
00:17:16,076 --> 00:17:17,336
So, SaveChangedKeys


373
00:17:17,336 --> 00:17:20,386
and SaveAllKeys always overwrite
the values on the server.


374
00:17:22,435 --> 00:17:25,626
These policies also determine
how much data we're sending


375
00:17:25,626 --> 00:17:26,106
to the server.


376
00:17:27,546 --> 00:17:29,756
In the case of
SaveIfServerUnchanged


377
00:17:29,816 --> 00:17:34,286
and SaveChangedKeys, we're only
going to send up the, sorry,


378
00:17:34,286 --> 00:17:35,626
we're only going to
send up the values


379
00:17:35,626 --> 00:17:37,466
on the record that have changed.


380
00:17:38,036 --> 00:17:39,386
In the case of SaveAllKeys,


381
00:17:39,386 --> 00:17:41,686
we're going to send the
entire record, all the values,


382
00:17:41,746 --> 00:17:43,726
whether you've changed
them or not.


383
00:17:45,216 --> 00:17:48,486
So, back to locked updates.


384
00:17:48,486 --> 00:17:50,676
We've got this thing
called locking,


385
00:17:50,676 --> 00:17:53,526
and if you don't use it,
here's what could go wrong


386
00:17:53,526 --> 00:17:54,526
with an unlocked update.


387
00:17:54,676 --> 00:17:57,026
Right now, we've got
this contact card.


388
00:17:57,076 --> 00:17:59,456
We've got the same name,
first name, last name,


389
00:17:59,456 --> 00:18:02,496
picture on two clients,
and in iCloud.


390
00:18:02,496 --> 00:18:03,626
Everything is good right now.


391
00:18:04,526 --> 00:18:07,466
But let's say the iPhone
changes that contact completely.


392
00:18:07,466 --> 00:18:10,136
So it modifies the picture,
it modifies the first name,


393
00:18:10,136 --> 00:18:11,476
and it modifies the last name.


394
00:18:12,436 --> 00:18:15,296
Well, it's going to perform a
SaveChangedKeys to the server,


395
00:18:15,616 --> 00:18:17,806
which is going to send up
the things that have changed,


396
00:18:18,156 --> 00:18:20,286
and that's going to overwrite
whatever is on the server.


397
00:18:20,286 --> 00:18:25,536
Next, before the Mac gets a
chance to download that record,


398
00:18:25,536 --> 00:18:26,896
the user edited the first name


399
00:18:26,896 --> 00:18:28,466
of that record and
just changed it.


400
00:18:29,496 --> 00:18:33,456
And that Mac then sends- does a
SaveChangedKeys with the server,


401
00:18:34,156 --> 00:18:36,496
and it sent up just the
property that was modified.


402
00:18:37,176 --> 00:18:40,556
And now, we've got a problem
here, oops, we've got a problem.


403
00:18:40,556 --> 00:18:44,206
This contact record isn't
what either the clients meant


404
00:18:44,206 --> 00:18:45,036
to have.


405
00:18:45,866 --> 00:18:49,096
So, to work around this,
we have locked updates.


406
00:18:49,736 --> 00:18:52,346
And locked updates are
a way of making sure


407
00:18:52,346 --> 00:18:55,376
that the server knows that
you're updating the same values


408
00:18:55,446 --> 00:18:56,536
that are already on the server.


409
00:18:57,376 --> 00:18:58,836
And we do this with
a change tag.


410
00:18:59,266 --> 00:19:01,606
So, the change tag is a
property on the record


411
00:19:02,286 --> 00:19:05,976
that necessarily changes anytime
a value in the record changes.


412
00:19:06,626 --> 00:19:09,416
In this case, we've got change
tag A both on the server


413
00:19:09,416 --> 00:19:12,926
and locally, and so we know that
they both have the same values.


414
00:19:13,796 --> 00:19:17,396
If we go and we add a new
property on the local record,


415
00:19:18,296 --> 00:19:21,256
when we save that to the server
using the default save policy,


416
00:19:21,366 --> 00:19:23,356
it's going to send up
both the change tag


417
00:19:23,946 --> 00:19:25,476
and the property that changed.


418
00:19:26,866 --> 00:19:29,096
The servers then,
before it does anything,


419
00:19:29,096 --> 00:19:30,756
it's going to check
the two change tags,


420
00:19:31,216 --> 00:19:34,296
and if they're equal, it'll
apply the change that you made.


421
00:19:34,996 --> 00:19:40,096
If on the other hand we have
another client that, oh, sorry,


422
00:19:40,096 --> 00:19:43,056
and then the server is going
to send back a new change tag


423
00:19:43,086 --> 00:19:44,586
because we did change
a property.


424
00:19:45,586 --> 00:19:49,386
We return this new record to
you with the updated change tag


425
00:19:49,386 --> 00:19:50,576
in the completion block.


426
00:19:50,576 --> 00:19:53,716
So, if you take the record that
we gave you at the end of a save


427
00:19:54,286 --> 00:19:56,836
and you do all your subsequent
modifications on that,


428
00:19:57,316 --> 00:19:59,136
you'll be using the
updated change token,


429
00:19:59,166 --> 00:20:01,586
and you shouldn't have any
conflicts with the server.


430
00:20:03,716 --> 00:20:05,656
Now, let's say we had
another client that, you know,


431
00:20:05,656 --> 00:20:07,896
hadn't seen that change and
he was still at version A.


432
00:20:08,556 --> 00:20:10,506
And he decides to add
a different property


433
00:20:10,506 --> 00:20:11,036
on the record.


434
00:20:11,766 --> 00:20:13,996
Well, he's going to save it to
the server, he's going to send


435
00:20:13,996 --> 00:20:16,716
up the change tag and
the modified property,


436
00:20:17,416 --> 00:20:19,476
and the server is going
to realize that, hey,


437
00:20:19,476 --> 00:20:20,836
those two values
aren't the same.


438
00:20:21,626 --> 00:20:24,266
And the client is going to
get back an error saying,


439
00:20:24,266 --> 00:20:25,286
you know, you have a conflict.


440
00:20:26,496 --> 00:20:28,146
So, how do we handle
these conflicts?


441
00:20:29,876 --> 00:20:32,976
Well, if you run into this
case of a locked save failing,


442
00:20:33,456 --> 00:20:36,616
you're going to get an error
that CKErrorServerRecordChanged.


443
00:20:37,236 --> 00:20:39,726
And because you guys all
went to the introductory talk


444
00:20:39,726 --> 00:20:42,206
and you learned about how
great error handling is


445
00:20:42,206 --> 00:20:43,076
and how important it is,


446
00:20:43,076 --> 00:20:46,226
you've got some fantastic error
handling here, and it's going


447
00:20:46,226 --> 00:20:48,676
to check for
CKErrorServerRecordChanged.


448
00:20:49,946 --> 00:20:52,656
When you see that, you know that
you're out of date, you're going


449
00:20:52,656 --> 00:20:54,236
to need to get the new
record from the server.


450
00:20:54,506 --> 00:20:56,296
You're going to need to
take your local changes,


451
00:20:56,296 --> 00:20:58,506
apply them to that record
and try to save again.


452
00:20:59,566 --> 00:21:01,066
And we've already
anticipated that.


453
00:21:01,156 --> 00:21:03,596
So, what we're going to do
is help you out a little bit,


454
00:21:03,596 --> 00:21:06,366
and we're going to return
those records to you already


455
00:21:06,416 --> 00:21:09,386
because we know that's the
next logical thing to do.


456
00:21:10,096 --> 00:21:12,686
So, inside of the userInfo
dictionary of this error,


457
00:21:12,806 --> 00:21:14,526
you're going to find three
copies of the record.


458
00:21:15,826 --> 00:21:18,176
You're going to find the record
that you attempted to save


459
00:21:18,176 --> 00:21:20,866
to the server, the one
that encountered the error.


460
00:21:22,116 --> 00:21:23,536
You're going to find
the original copy


461
00:21:23,536 --> 00:21:26,736
of the local record, which
is the copy we downloaded


462
00:21:26,736 --> 00:21:28,696
from the server before
you made any changes.


463
00:21:29,816 --> 00:21:32,126
And finally, we're going to
give you the server record back.


464
00:21:32,276 --> 00:21:34,006
This is the copy of the
record with the most


465
00:21:34,006 --> 00:21:36,906
up to date change tag.


466
00:21:37,086 --> 00:21:40,216
You're going to want to figure
out what makes sense out of all


467
00:21:40,216 --> 00:21:42,196
of those copies of
values and keys.


468
00:21:42,766 --> 00:21:44,746
You're going to apply them
all to the server version


469
00:21:44,746 --> 00:21:50,326
of the record, and then you're
going to retry that save.


470
00:21:50,526 --> 00:21:52,186
So, you might be wondering
at this point, you know,


471
00:21:52,186 --> 00:21:55,006
what type of save
policy should you use?


472
00:21:55,476 --> 00:21:57,286
And the simple answer to that is


473
00:21:57,286 --> 00:22:00,846
that you should just always
use CKRecordSaveIfUnchanged,


474
00:22:01,436 --> 00:22:02,686
and it's the default.


475
00:22:02,686 --> 00:22:03,936
It's the default for a reason,


476
00:22:04,006 --> 00:22:05,896
and that's because
it's the safest.


477
00:22:06,086 --> 00:22:08,816
If you remember that example
of an unlocked update gone bad,


478
00:22:09,486 --> 00:22:11,676
you could end up with really
mixed-up, corrupt data


479
00:22:11,676 --> 00:22:13,626
on the server if you're
not using locking.


480
00:22:15,196 --> 00:22:17,446
However, there is
always a time and place


481
00:22:17,446 --> 00:22:19,226
for using unlocked updates.


482
00:22:19,816 --> 00:22:23,226
And the biggest case for these
are highly contentious updates.


483
00:22:23,746 --> 00:22:25,676
If you're doing anything
in the public database,


484
00:22:25,676 --> 00:22:27,886
you might have hundreds
or thousands or millions


485
00:22:27,886 --> 00:22:29,866
of clients accessing
it at the same time.


486
00:22:30,766 --> 00:22:33,706
And if every one of those
clients is trying to save if,


487
00:22:34,226 --> 00:22:36,706
save the same record and
you're locking on that,


488
00:22:37,616 --> 00:22:39,696
most of those clients are going
to be hitting locking errors,


489
00:22:39,736 --> 00:22:41,676
they're going to hit
conflicts, and they're going


490
00:22:41,676 --> 00:22:43,116
to be retrying really
frequently.


491
00:22:43,976 --> 00:22:46,456
So, if you know this is going to
be a really contentious update,


492
00:22:46,996 --> 00:22:50,096
you can structure your client
to do unlocked updates as long


493
00:22:50,096 --> 00:22:52,496
as you know you're always
writing consistent properties.


494
00:22:53,286 --> 00:22:55,636
On the case of that unlocked
update that failed, you know,


495
00:22:55,636 --> 00:22:57,786
you could make sure you
always write both the first


496
00:22:57,786 --> 00:23:00,196
and last name, and you
know it'll be consistent.


497
00:23:02,176 --> 00:23:05,956
The other reason to use an
unlocked update in the case


498
00:23:06,056 --> 00:23:07,666
of SaveAllKeys would
be if you want


499
00:23:07,696 --> 00:23:08,976
to force something
to the server.


500
00:23:09,086 --> 00:23:11,816
The client might say, you know,
the copy on the server is bad,


501
00:23:11,816 --> 00:23:13,716
but I know I have a good
copy of the record here.


502
00:23:14,296 --> 00:23:18,376
I want to just force that all
on top of the server's copy.


503
00:23:19,836 --> 00:23:23,566
There are some catches
to using SaveAllKeys,


504
00:23:23,606 --> 00:23:27,846
and one of the problems is
that any property on the server


505
00:23:28,406 --> 00:23:30,846
that doesn't exist in the
local record that you're trying


506
00:23:30,846 --> 00:23:32,276
to save isn't going


507
00:23:32,276 --> 00:23:36,116
to get removed unless
you explicitly remove


508
00:23:36,116 --> 00:23:37,676
that property on the record.


509
00:23:38,496 --> 00:23:41,536
All those words are
really confusing,


510
00:23:41,616 --> 00:23:43,006
and it's really hard to explain.


511
00:23:43,006 --> 00:23:44,346
So instead, I'm going
to try and explain


512
00:23:44,346 --> 00:23:45,266
that with the picture here.


513
00:23:46,376 --> 00:23:48,346
So, we've got our
contact record again.


514
00:23:48,436 --> 00:23:51,086
What we're going to do is
add a couple of properties.


515
00:23:51,086 --> 00:23:52,386
We're going to change
the first name,


516
00:23:52,386 --> 00:23:53,556
we're going to add
a new property,


517
00:23:54,006 --> 00:23:55,346
and we're going to
delete the hobby.


518
00:23:56,786 --> 00:23:59,756
We're now going to do a
SaveAllKeys to the server.


519
00:24:01,306 --> 00:24:04,316
What that's going to do is send
up all of these properties,


520
00:24:04,846 --> 00:24:07,986
even the ones we didn't change
locally, and they're going


521
00:24:07,986 --> 00:24:09,516
to update the values
on the server.


522
00:24:10,216 --> 00:24:12,026
But what you'll notice here is


523
00:24:12,026 --> 00:24:14,016
that the server had
an additional property


524
00:24:14,016 --> 00:24:17,446
that we didn't have in our
original copy of the record.


525
00:24:17,446 --> 00:24:19,406
This hometown property
wasn't removed.


526
00:24:20,736 --> 00:24:23,756
We do this to help you with
versioning of your app.


527
00:24:24,046 --> 00:24:28,156
You might release a version 2
of your app that adds hometowns


528
00:24:28,216 --> 00:24:30,386
but version 1 didn't ever
know about the hometown.


529
00:24:30,926 --> 00:24:33,506
And if version 1 was
using SaveAllKeys,


530
00:24:33,926 --> 00:24:35,966
it's going to overwrite these
properties on the server


531
00:24:35,966 --> 00:24:38,766
that it never knew about, and
that's kind of a bad thing.


532
00:24:38,766 --> 00:24:42,086
You can't have backwards
compatible code easily that way.


533
00:24:43,386 --> 00:24:46,406
So, what we do instead is we
still allow you to remove that,


534
00:24:46,496 --> 00:24:48,936
but you need to explicitly
tell us that you want


535
00:24:48,936 --> 00:24:50,416
that property deleted
on the server.


536
00:24:51,216 --> 00:24:53,376
So, even though there's
no hometown property


537
00:24:53,376 --> 00:24:57,696
on this record, we can still
call CKRecordSetValueForKey nil


538
00:24:58,066 --> 00:25:00,246
or we can call
removeObjectForKey.


539
00:25:01,246 --> 00:25:02,466
We're going to remove
the hometown,


540
00:25:02,466 --> 00:25:04,246
and now when we save
it up to the server,


541
00:25:04,526 --> 00:25:08,996
that delete will also
go up with the save.


542
00:25:09,146 --> 00:25:12,646
Finally, one of the really
neat things about CKRecord is


543
00:25:12,646 --> 00:25:14,346
that we allow you to
have partial records.


544
00:25:15,126 --> 00:25:17,736
So, you might have a really
big record on the server,


545
00:25:17,736 --> 00:25:20,056
and you only care about one
or two properties of that.


546
00:25:20,736 --> 00:25:23,346
Well, with the desiredKeys
property, we allow you


547
00:25:23,346 --> 00:25:26,306
to fetch just a certain
subset of the properties


548
00:25:26,306 --> 00:25:27,216
that are on the server.


549
00:25:28,546 --> 00:25:32,406
And we expose this desiredKeys
property on any operation


550
00:25:32,406 --> 00:25:34,116
that fetches a record,
so you're going to see it


551
00:25:34,116 --> 00:25:37,956
on CKFetchRecordsOperation,
CKQueryOperation,


552
00:25:37,956 --> 00:25:40,476
and
CKFetchRecordChangesOperation.


553
00:25:42,146 --> 00:25:43,346
And the really neat thing


554
00:25:43,346 --> 00:25:46,006
about this is you can then
take these partial records


555
00:25:46,006 --> 00:25:47,636
and save them back
up to the server.


556
00:25:47,716 --> 00:25:50,316
You don't need to work
with entirely full records.


557
00:25:50,856 --> 00:25:53,096
You can, you know, if you
want to update just one value


558
00:25:53,096 --> 00:25:55,676
on a record, fetch that
one value from the record,


559
00:25:55,796 --> 00:25:58,206
update it, and do a
save of just that record


560
00:25:58,206 --> 00:25:59,186
that has that one value.


561
00:25:59,836 --> 00:26:01,956
If you're doing this
with locking enabled,


562
00:26:02,306 --> 00:26:05,266
you know it's safe because
if the record is changed


563
00:26:05,266 --> 00:26:13,216
on the server since then,
you're going to get a conflict.


564
00:26:13,436 --> 00:26:14,736
So now, let's talk a little bit


565
00:26:14,736 --> 00:26:16,626
about modeling your
data for CloudKit.


566
00:26:17,976 --> 00:26:20,446
If we go back to that
example of a Receipts app,


567
00:26:20,796 --> 00:26:23,926
let's say we have a shoebox
that holds all our receipts


568
00:26:24,456 --> 00:26:27,126
and that's going to be
one object in the cloud,


569
00:26:27,596 --> 00:26:28,766
and we're going to
have an object


570
00:26:28,766 --> 00:26:29,946
for each one of our receipts.


571
00:26:31,036 --> 00:26:34,586
And the initial way you might
design this is you create a


572
00:26:34,586 --> 00:26:36,456
receipts array inside
of your shoebox,


573
00:26:37,156 --> 00:26:39,596
and every time you add a
new receipt, you're going


574
00:26:39,596 --> 00:26:42,576
to add new entry to that
array and that entry is going


575
00:26:42,576 --> 00:26:44,626
to be a reference to the
record you just created.


576
00:26:45,376 --> 00:26:47,136
We call these forward
references.


577
00:26:47,136 --> 00:26:49,636
These are references from
a parent to its child.


578
00:26:50,666 --> 00:26:52,086
And the problem with
these is that you end


579
00:26:52,086 --> 00:26:54,046
up getting bottlenecked
on that receipts array.


580
00:26:54,046 --> 00:26:57,746
If this was a public database,
you might have hundreds


581
00:26:57,746 --> 00:26:59,606
of clients trying to
save this record at once.


582
00:27:00,386 --> 00:27:03,166
And every time a client
tries to add a new record,


583
00:27:03,866 --> 00:27:06,616
they need to update that
array on the shoebox,


584
00:27:06,816 --> 00:27:08,976
and even though the clients
might be adding different


585
00:27:08,976 --> 00:27:13,216
records, different receipts,
they're all going to run


586
00:27:13,266 --> 00:27:16,376
into conflicts on the shoebox
app, or on the shoebox record.


587
00:27:17,146 --> 00:27:20,106
So, we recommend that you try
and avoid forward references


588
00:27:20,106 --> 00:27:24,496
in your design, and instead, use
what we call back references.


589
00:27:25,056 --> 00:27:26,886
So, instead of having
the shoebox point


590
00:27:26,886 --> 00:27:29,736
at the receipt that's in
it, have the receipt point


591
00:27:29,736 --> 00:27:30,906
at the shoebox that it's in.


592
00:27:32,506 --> 00:27:35,566
The great thing about this
is it's very scalable.


593
00:27:35,566 --> 00:27:39,376
You can have millions of clients
adding receipts all at once,


594
00:27:39,476 --> 00:27:40,586
and there's no bottleneck.


595
00:27:40,586 --> 00:27:42,956
They can create their receipt,
point at who owns them,


596
00:27:43,596 --> 00:27:47,296
and none of them are going
to run into conflicts.


597
00:27:47,296 --> 00:27:49,476
When you need to go get
everything that's in a shoebox,


598
00:27:49,476 --> 00:27:51,706
rather than fetching that
shoebox, getting the array


599
00:27:51,706 --> 00:27:54,186
of records in it, and
fetching all those records,


600
00:27:54,646 --> 00:27:56,186
you can instead just
use a query.


601
00:27:56,976 --> 00:27:59,636
That query is going to select
all of the records that have


602
00:27:59,636 --> 00:28:04,446
that shoebox as an owner.


603
00:28:04,446 --> 00:28:05,696
One other neat feature
we give you


604
00:28:05,696 --> 00:28:08,416
with the relationships
are cascading deletes.


605
00:28:09,116 --> 00:28:10,866
So, cascading deletes
are a way for you


606
00:28:10,866 --> 00:28:14,656
to make your object graph
get cleaned up automatically,


607
00:28:15,356 --> 00:28:17,556
and you do this by
marking your references


608
00:28:17,596 --> 00:28:20,356
with a
CKReferenceActionDeleteSelf,


609
00:28:21,036 --> 00:28:23,636
and that means that
when the record


610
00:28:23,636 --> 00:28:26,586
that you referenced is deleted,
you will also be deleted.


611
00:28:26,826 --> 00:28:28,616
In this case, the
green record has


612
00:28:28,676 --> 00:28:30,946
that reference action
pointed in the orange record.


613
00:28:31,646 --> 00:28:32,976
When the orange record
gets deleted,


614
00:28:33,476 --> 00:28:34,356
the green record is going


615
00:28:34,356 --> 00:28:36,266
to get automatically
deleted by the server.


616
00:28:38,016 --> 00:28:39,836
These deletes also cascade.


617
00:28:39,976 --> 00:28:42,556
So, if we had a whole
tree of objects hang off


618
00:28:42,556 --> 00:28:45,236
of that one orange record,
those deletes are going


619
00:28:45,236 --> 00:28:49,806
to cascade all the way down
and clean up our graph for us.


620
00:28:54,496 --> 00:28:56,076
But one thing to keep in mind


621
00:28:56,076 --> 00:28:57,986
with these delete
self references is


622
00:28:57,986 --> 00:29:00,216
that they're not
reference counted.


623
00:29:00,216 --> 00:29:03,606
That means that if you have
multiple references coming


624
00:29:03,606 --> 00:29:05,666
out of one record, the first one


625
00:29:05,666 --> 00:29:12,076
of those records that's deleted
will cause you to get deleted.


626
00:29:12,166 --> 00:29:16,436
And finally, these delete
self references give you one


627
00:29:16,436 --> 00:29:17,256
additional feature.


628
00:29:17,526 --> 00:29:20,866
If you're doing a batch save and
you've got a jumble of records


629
00:29:20,866 --> 00:29:23,666
in this graph, and they
have delete self references


630
00:29:23,666 --> 00:29:25,316
between them, CloudKit is going


631
00:29:25,316 --> 00:29:27,906
to do an automatic
topological sort for you.


632
00:29:27,906 --> 00:29:30,586
We're going to upload
the records in order


633
00:29:30,586 --> 00:29:33,146
so that all the records that
are referenced will be up there


634
00:29:33,146 --> 00:29:35,586
by the time the record
reference in them is uploaded.


635
00:29:36,076 --> 00:29:38,196
This is really great
in the public database


636
00:29:38,196 --> 00:29:41,606
where you don't have atomic
commits but you still want


637
00:29:41,606 --> 00:29:44,636
to be able to upload data that
looks consistent at any point


638
00:29:44,636 --> 00:29:46,326
when a client downloads it.


639
00:29:48,846 --> 00:29:51,956
So, while developing CloudKit
internally, we've had a couple


640
00:29:51,956 --> 00:29:54,016
of our clients ask us,
you know, why do I need


641
00:29:54,016 --> 00:29:55,346
to use these reference objects?


642
00:29:55,346 --> 00:29:58,306
I have to, you know, alloc and
omit and it's so much work.


643
00:29:58,306 --> 00:30:01,646
You know, I've got a record
ID, why can't I just put it


644
00:30:01,646 --> 00:30:02,976
in the string and put
that in my record?


645
00:30:03,696 --> 00:30:04,896
You can, so, you know, you come


646
00:30:04,896 --> 00:30:06,806
up with this clever
little RecordIDToString,


647
00:30:07,366 --> 00:30:09,196
but then you look at
the recordID class


648
00:30:09,196 --> 00:30:11,696
and you realize it's
actually two properties,


649
00:30:11,696 --> 00:30:14,426
and you can't just store the
description of the record


650
00:30:14,426 --> 00:30:16,966
on the server so you
get a little smarter


651
00:30:16,966 --> 00:30:21,346
and you store the recordID
and the name and the zoneID.


652
00:30:21,986 --> 00:30:25,686
But then, you look at zoneID
and that's also composite.


653
00:30:26,426 --> 00:30:30,676
We need to know what, where
zone is and whose account it is.


654
00:30:31,256 --> 00:30:32,986
So, you get a little more clever


655
00:30:32,986 --> 00:30:34,976
and you make this
RecordIDToString


656
00:30:34,976 --> 00:30:39,066
and ZoneIDToString, and now
you call that everywhere.


657
00:30:39,226 --> 00:30:41,936
The problem is now you're
not forwards compatible.


658
00:30:42,006 --> 00:30:45,346
If anything ever gets added to
references, all of your records


659
00:30:45,346 --> 00:30:47,856
on the server are already going
to have this hard coded format,


660
00:30:48,256 --> 00:30:49,996
and you're going to have
to go through a lot of work


661
00:30:49,996 --> 00:30:51,156
when you query records.


662
00:30:52,316 --> 00:30:54,726
Instead, just use references.


663
00:30:54,726 --> 00:30:56,166
It's going to make
your code really clean.


664
00:30:56,166 --> 00:30:58,356
I mean that shoebox
could be a recordID,


665
00:30:58,356 --> 00:31:01,106
that shoebox could be a record
itself, it could be a reference.


666
00:31:01,566 --> 00:31:04,046
All of those will just work as
long as you use the CKReference.


667
00:31:04,946 --> 00:31:10,556
A couple last notes on
modeling your data in CloudKit.


668
00:31:11,896 --> 00:31:14,866
One of them is that CloudKit
is a transport mechanism.


669
00:31:14,986 --> 00:31:17,776
What we've tried to do here
is give you an easy way


670
00:31:17,776 --> 00:31:21,446
to access the CloudKit
servers, but we're not meant


671
00:31:21,446 --> 00:31:23,296
to be a local persistence layer.


672
00:31:23,296 --> 00:31:26,516
We want that to be up to
you, and you need to figure


673
00:31:26,516 --> 00:31:28,096
out the best way to
store your objects.


674
00:31:28,746 --> 00:31:33,336
And to that extent, we recommend
that you don't subclass CKItems.


675
00:31:33,526 --> 00:31:36,516
You should take those items when
you receive them from the server


676
00:31:37,216 --> 00:31:40,896
and translate them into your own
model objects, and you can do


677
00:31:40,896 --> 00:31:42,046
that on the way out as well.


678
00:31:42,046 --> 00:31:44,606
When you need to save one of
your model objects, translate it


679
00:31:44,606 --> 00:31:55,036
into a CKRecord and upload
all of that to the server.


680
00:31:55,216 --> 00:31:57,136
So, if you remember from
the introductory talk,


681
00:31:57,136 --> 00:31:59,466
we have these things that
we call subscriptions.


682
00:31:59,596 --> 00:32:01,686
They're persistent queries
that run on the server,


683
00:32:02,536 --> 00:32:05,396
and every time something
changes that matches that query,


684
00:32:06,186 --> 00:32:07,616
you're going to get
a push notification.


685
00:32:08,546 --> 00:32:11,206
And these push notifications
are sent via the Apple Push


686
00:32:11,206 --> 00:32:14,026
Notification Service, just the
same way that it would work


687
00:32:14,026 --> 00:32:15,106
if you built your own server.


688
00:32:16,766 --> 00:32:18,356
But there are some drawbacks


689
00:32:18,356 --> 00:32:20,336
with Apple Push Notification
Service.


690
00:32:20,336 --> 00:32:22,966
One of them is that they
can't make any guarantees


691
00:32:22,966 --> 00:32:24,366
on delivery of these pushes.


692
00:32:24,446 --> 00:32:26,536
They're kind of meant to
be these ephemeral, little,


693
00:32:26,536 --> 00:32:28,086
you know, here's a
push, here's a push.


694
00:32:28,586 --> 00:32:31,096
If one of them gets dropped
because of a bad network


695
00:32:31,096 --> 00:32:35,306
or anything else going
on, there's no guarantee.


696
00:32:35,636 --> 00:32:37,316
So, in practice,
they're really good


697
00:32:37,316 --> 00:32:38,536
about delivering these pushes.


698
00:32:39,006 --> 00:32:40,606
And one of the reasons is


699
00:32:40,656 --> 00:32:42,346
because the server
will store pushes


700
00:32:42,346 --> 00:32:43,596
for you if you're offline.


701
00:32:44,246 --> 00:32:45,936
So, if you put your
phone in Airplane Mode


702
00:32:45,936 --> 00:32:48,216
and you get a push, as
soon as you come back


703
00:32:48,216 --> 00:32:50,366
out of Airplane Mode, the
server will have that saved


704
00:32:50,366 --> 00:32:51,806
and still deliver
the push on to you.


705
00:32:52,976 --> 00:32:56,226
But the problem with this is
the server only stores one push


706
00:32:56,296 --> 00:32:56,796
per client.


707
00:32:57,776 --> 00:33:00,376
So, if you received a bunch of
pushes while you're offline,


708
00:33:00,376 --> 00:33:02,086
you're only going to
get the most recent one.


709
00:33:03,676 --> 00:33:04,416
What does that look like?


710
00:33:04,456 --> 00:33:07,026
Well, we've got our
CloudKit server,


711
00:33:07,026 --> 00:33:09,866
we've got the APS server, and
we've got the iPhone up here.


712
00:33:10,366 --> 00:33:13,486
And we send a push, and we're
online, everything goes through,


713
00:33:13,486 --> 00:33:15,036
we get our badge,
everyone's happy.


714
00:33:16,536 --> 00:33:18,196
But then, we get on an airplane.


715
00:33:18,196 --> 00:33:21,126
Our phone is in Airplane Mode;
we have no network connection.


716
00:33:22,136 --> 00:33:24,176
And when that push gets sent,


717
00:33:24,176 --> 00:33:26,176
the APS server helpfully
stores it for us.


718
00:33:26,306 --> 00:33:28,126
If we were going to come
back online right now,


719
00:33:28,126 --> 00:33:30,636
we would get our subscription
push and we'd be happy.


720
00:33:31,626 --> 00:33:34,596
But this is a long plane flight
and while we're on the plane,


721
00:33:34,716 --> 00:33:37,696
we got a zone update push,
that new zone subscription


722
00:33:37,696 --> 00:33:38,546
that I was talking about.


723
00:33:39,556 --> 00:33:42,916
When that gets to the APS
server, it's going to drop


724
00:33:42,916 --> 00:33:44,416
that previous subscription push,


725
00:33:44,916 --> 00:33:48,296
and now when your phone comes
back online, all you're going


726
00:33:48,296 --> 00:33:49,566
to receive is the zone update.


727
00:33:51,096 --> 00:33:52,736
The problem with this
is that you never heard


728
00:33:52,736 --> 00:33:54,096
about that subscription
that fired.


729
00:33:54,806 --> 00:33:56,016
So, how do we solve this?


730
00:33:56,016 --> 00:33:59,356
Well, we've created a
notification collection


731
00:33:59,356 --> 00:34:00,006
in CloudKit.


732
00:34:01,406 --> 00:34:04,376
Every time the server sends
a push to the APS server,


733
00:34:04,836 --> 00:34:06,616
it also makes a copy
of that push


734
00:34:06,616 --> 00:34:07,936
in the notification collection.


735
00:34:08,896 --> 00:34:11,356
So, you can see we have that
same problem where we're


736
00:34:11,356 --> 00:34:13,686
in Airplane Mode, we dropped
our subscription push,


737
00:34:14,446 --> 00:34:16,346
our phone comes online,
and it gets the push,


738
00:34:17,416 --> 00:34:19,406
and because this is a
well-behaved client,


739
00:34:19,406 --> 00:34:21,485
it knows every time
it receives a push,


740
00:34:21,545 --> 00:34:23,726
it should go check the
notification collection to find


741
00:34:23,726 --> 00:34:25,846
out about anything
it might have missed.


742
00:34:26,896 --> 00:34:28,116
So, how does that work?


743
00:34:28,116 --> 00:34:30,786
Well, this notification
collection is a lot


744
00:34:30,786 --> 00:34:32,686
like the delta downloads
I talked about earlier.


745
00:34:33,275 --> 00:34:34,676
It's all change token-based.


746
00:34:35,126 --> 00:34:36,656
You hand a change
token to the server,


747
00:34:37,005 --> 00:34:39,116
and the server hands back
all the notifications


748
00:34:39,116 --> 00:34:41,016
that have changed
since then along


749
00:34:41,016 --> 00:34:42,255
with an updated change token.


750
00:34:42,826 --> 00:34:45,716
So, since this is our
first time talking


751
00:34:45,716 --> 00:34:47,366
to the notification
collection, we're going to send


752
00:34:47,366 --> 00:34:48,456
up a nil change token.


753
00:34:49,576 --> 00:34:51,676
We're going to get back
both of those pushes,


754
00:34:51,676 --> 00:34:53,045
one of them which we missed.


755
00:34:53,525 --> 00:34:57,005
And then we're also going to
get an updated change token


756
00:34:57,005 --> 00:34:59,566
for the current state.


757
00:35:00,376 --> 00:35:04,396
One thing with subscriptions is
that you might want to use those


758
00:35:04,396 --> 00:35:06,516
to change some UI
in your application.


759
00:35:07,056 --> 00:35:10,946
For example in our Receipts app,
we might want a subscription


760
00:35:11,006 --> 00:35:14,176
for any receipt that
was over 100 dollars.


761
00:35:14,176 --> 00:35:16,986
If that happens, we want to mark


762
00:35:17,626 --> 00:35:19,256
that receipt in a
different color.


763
00:35:19,446 --> 00:35:21,736
So we're going to get this
push for a subscription,


764
00:35:22,656 --> 00:35:24,226
and now that receipt is blue


765
00:35:24,226 --> 00:35:26,036
because it was a big
expensive receipt.


766
00:35:27,396 --> 00:35:30,046
But, you know, this is going
to happen on all your clients,


767
00:35:30,046 --> 00:35:32,336
so you're going to have you iPad
showing that receipt in blue,


768
00:35:32,336 --> 00:35:34,536
you're going to have your Mac
showing that receipt in blue,


769
00:35:35,016 --> 00:35:38,356
and once this acknowledges
it, you want that UI state


770
00:35:38,396 --> 00:35:40,776
to go away on all your clients.


771
00:35:41,666 --> 00:35:44,476
Well, the way we do that is we
let you mark a subscription,


772
00:35:44,646 --> 00:35:46,806
sorry, we let you mark
a notification as red.


773
00:35:46,856 --> 00:35:49,366
And when you do that,
you're going to get a push


774
00:35:49,366 --> 00:35:51,576
for the updated subscription,


775
00:35:51,856 --> 00:35:53,816
updated notification
on every client.


776
00:35:54,486 --> 00:35:56,136
So, in this case,
we mark our receipt.


777
00:35:56,136 --> 00:35:58,826
We're going to go mark
that subscription as red


778
00:35:58,826 --> 00:36:00,846
on the server, and now
there's a new entry.


779
00:36:02,406 --> 00:36:04,786
And if we switch over to our
Mac which is still showing it


780
00:36:04,786 --> 00:36:06,286
in blue, it's going
to get a push,


781
00:36:06,516 --> 00:36:08,356
it's going to check the
notification collection,


782
00:36:09,126 --> 00:36:11,856
it's going to get that
subscription notification,


783
00:36:12,006 --> 00:36:14,466
and it can tear down
its UI and now all


784
00:36:14,466 --> 00:36:16,926
of your clients are
in the same state.


785
00:36:19,426 --> 00:36:20,966
So, with the notification
collection,


786
00:36:20,966 --> 00:36:22,976
keep in mind every
time you get a push,


787
00:36:22,976 --> 00:36:24,826
you should check the
notification collection.


788
00:36:25,086 --> 00:36:27,306
You never know what
you might have missed.


789
00:36:28,236 --> 00:36:31,366
And this isn't just for
Airplane Mode or bad networks.


790
00:36:31,526 --> 00:36:34,946
This can happen if you get
multiple pushes in a row.


791
00:36:34,946 --> 00:36:36,836
If there's a lot of changes
that happen all at once,


792
00:36:37,376 --> 00:36:39,256
the CloudKit server
might coalesce them,


793
00:36:39,256 --> 00:36:43,646
or the push server might
coalesce those pushes.


794
00:36:43,646 --> 00:36:46,836
And of course, because a lot
of these are mobile devices,


795
00:36:46,836 --> 00:36:48,966
they're iPhones, they're
going to be moving in


796
00:36:48,966 --> 00:36:50,056
and out of network states.


797
00:36:50,096 --> 00:36:53,786
They might be on Wi-Fi, or they
might be on a bad cell network.


798
00:36:53,786 --> 00:36:55,516
You never know what
your network is like.


799
00:36:56,356 --> 00:36:58,686
Just assume that there
might have been more pushes


800
00:36:58,726 --> 00:37:00,206
that you didn't hear about.


801
00:37:04,176 --> 00:37:06,696
So, now we're going to go
over the iCloud Dashboard.


802
00:37:07,036 --> 00:37:09,996
And the iCloud Dashboard
is our web-based interface


803
00:37:10,076 --> 00:37:13,166
for managing your
application in CloudKit.


804
00:37:14,536 --> 00:37:17,346
The iCloud Dashboard
lets you view your data.


805
00:37:18,076 --> 00:37:20,636
It lets you manage the schema
that we're creating for you.


806
00:37:21,666 --> 00:37:25,926
It lets you control what's
indexed, and it helps you moving


807
00:37:25,926 --> 00:37:27,136
from development to production.


808
00:37:27,136 --> 00:37:29,486
I'm going to explain all of
those in detail in a bit.


809
00:37:29,756 --> 00:37:31,526
Let's start with viewing data.


810
00:37:33,596 --> 00:37:38,166
So, if you remember the view
of our containers up here,


811
00:37:38,166 --> 00:37:40,466
we've got a public database
and a private database.


812
00:37:41,556 --> 00:37:44,706
And when you're viewing your
data in the iCloud Dashboard,


813
00:37:45,426 --> 00:37:48,506
all of that data in the public
database is of course public.


814
00:37:48,936 --> 00:37:52,356
So, in the dashboard, you'll
be able to see every record


815
00:37:52,356 --> 00:37:53,536
in your public database.


816
00:37:54,996 --> 00:37:58,266
But if you remember, the private
database is again one database


817
00:37:58,336 --> 00:37:59,706
for each individual user.


818
00:38:00,646 --> 00:38:03,266
And in this case, we're
only logged in as one user.


819
00:38:03,266 --> 00:38:04,976
We're logged in as
our developer account.


820
00:38:05,826 --> 00:38:09,126
So, all we're going to see in
the iCloud Dashboard is the data


821
00:38:09,426 --> 00:38:13,036
in the private database
for our developer account.


822
00:38:13,036 --> 00:38:13,966
This is really important.


823
00:38:13,966 --> 00:38:16,006
You know, you might use a
different account for testing


824
00:38:16,006 --> 00:38:17,586
and a different account
for viewing data


825
00:38:17,586 --> 00:38:18,696
in the iCloud Dashboard.


826
00:38:19,196 --> 00:38:20,476
If you do that, you
won't be able


827
00:38:20,476 --> 00:38:22,696
to view your private
data in the dashboard.


828
00:38:22,696 --> 00:38:26,226
So, what does the
dashboard look like?


829
00:38:26,266 --> 00:38:29,736
Well, we log in, and the
first thing we're going


830
00:38:29,736 --> 00:38:31,856
to see here are our
different record types.


831
00:38:32,376 --> 00:38:34,856
So, you can see we're
using the Party app.


832
00:38:34,856 --> 00:38:37,226
We've got parties,
and over here,


833
00:38:37,226 --> 00:38:39,476
we see the different schema


834
00:38:39,576 --> 00:38:41,676
for those values
that's been created.


835
00:38:43,426 --> 00:38:45,556
When you're developing
a CloudKit application,


836
00:38:45,996 --> 00:38:47,736
you're talking at the
development environment,


837
00:38:48,386 --> 00:38:49,286
and the server


838
00:38:49,286 --> 00:38:52,166
in the development environment
creates a just-in-time schema


839
00:38:52,246 --> 00:38:52,566
for you.


840
00:38:53,256 --> 00:38:55,946
So, we did this because we
wanted you to be able to develop


841
00:38:55,946 --> 00:38:57,256
as rapidly as possible.


842
00:38:57,256 --> 00:39:01,706
We didn't want you have to go
to a, this dashboard and plan


843
00:39:01,706 --> 00:39:03,576
out what you were going
to do in your application


844
00:39:03,576 --> 00:39:05,066
and choose all the data types.


845
00:39:05,066 --> 00:39:07,746
That's not as much fun as
just writing some code.


846
00:39:08,016 --> 00:39:10,856
So, we let you dive right
in, you write some code,


847
00:39:11,436 --> 00:39:14,726
and the things that you upload
to CloudKit as you upload them,


848
00:39:15,146 --> 00:39:17,376
those values get
locked in into a schema.


849
00:39:18,526 --> 00:39:20,496
So, you can see here
that we've got a couple


850
00:39:20,496 --> 00:39:23,426
of different values, and we've
got their, couple different keys


851
00:39:23,426 --> 00:39:26,146
and their values but we
notice that we made a mistake


852
00:39:26,146 --> 00:39:27,476
when we're developing this app.


853
00:39:27,666 --> 00:39:30,666
We uploaded a date
value or a date key,


854
00:39:31,106 --> 00:39:32,276
but we use a string value.


855
00:39:32,276 --> 00:39:34,136
And what we really want
there is a date value.


856
00:39:34,886 --> 00:39:37,306
The iCloud Dashboard is
going to let us fix that up.


857
00:39:37,826 --> 00:39:40,026
So we can go to this
and we can delete it.


858
00:39:41,016 --> 00:39:42,386
We can remove it
from our schema,


859
00:39:43,336 --> 00:39:46,296
and now we can recompile
our app, use a date value,


860
00:39:46,756 --> 00:39:49,696
upload that record again,
and when the server sees


861
00:39:49,696 --> 00:39:52,446
that record, it will
create a new schema entry


862
00:39:52,556 --> 00:39:59,866
for the date value using an
actual date instead of a string.


863
00:40:00,066 --> 00:40:02,306
So next up, you can
view all the records


864
00:40:02,306 --> 00:40:05,376
in your public database
using the iCloud Dashboard.


865
00:40:05,696 --> 00:40:07,486
So, you can see here,
we already have a couple


866
00:40:07,486 --> 00:40:09,496
of different parties
in the public database.


867
00:40:10,736 --> 00:40:14,306
What you can also do is create
records in the public database.


868
00:40:14,396 --> 00:40:18,356
So, you can tap on this Plus
button and fill out a new entry.


869
00:40:19,026 --> 00:40:22,226
We're going to make a new
party for coffee on Friday,


870
00:40:23,276 --> 00:40:26,966
and we can save that and you'll
see that that actually got saved


871
00:40:27,036 --> 00:40:28,276
into the public database.


872
00:40:28,316 --> 00:40:31,256
Any clients that are fetching
records are going to see


873
00:40:31,256 --> 00:40:33,316
that change in the
public database.


874
00:40:33,876 --> 00:40:37,796
We can also search for records.


875
00:40:37,796 --> 00:40:39,136
This is just like CKQuery.


876
00:40:39,136 --> 00:40:41,866
So we can click on
that magnifying glass,


877
00:40:42,816 --> 00:40:46,326
and we can type any
string, and we can filter


878
00:40:46,326 --> 00:40:49,316
down to any party
that mentions WWDC.


879
00:40:50,566 --> 00:40:52,856
Additionally, this gives
us all the functionality


880
00:40:52,856 --> 00:40:54,246
that we have in CKQuery.


881
00:40:54,246 --> 00:40:56,836
We can build compound queries
right in the dashboard.


882
00:40:57,326 --> 00:41:01,516
So, if you click on the Plus
button, let's choose location,


883
00:41:01,516 --> 00:41:03,716
and let's filter down
to everything that's


884
00:41:03,716 --> 00:41:06,246
within 5 kilometers
of Moscone Center.


885
00:41:06,366 --> 00:41:08,016
I happen to have
those memorized.


886
00:41:08,636 --> 00:41:12,826
So, that filtered everything
down just to the two parties


887
00:41:12,826 --> 00:41:13,726
that are in this area.


888
00:41:16,556 --> 00:41:18,766
Finally, in the public database,


889
00:41:19,076 --> 00:41:22,336
by default every record
can be read by every user,


890
00:41:23,346 --> 00:41:25,426
and it can be created
by any user.


891
00:41:25,726 --> 00:41:29,016
Once you create a record, that
record can only be updated


892
00:41:29,016 --> 00:41:31,096
or deleted by the
user that created it.


893
00:41:32,106 --> 00:41:34,296
But we understand that that
doesn't provide all the


894
00:41:34,296 --> 00:41:36,746
functionality that you might
need to make an application


895
00:41:36,746 --> 00:41:37,766
in the public database.


896
00:41:38,356 --> 00:41:41,186
So, what we've given you
are what we call roles.


897
00:41:41,186 --> 00:41:44,106
These roles let you
choose sets of users


898
00:41:44,106 --> 00:41:46,606
that have different
permissions for record types


899
00:41:46,606 --> 00:41:47,696
in the public database.


900
00:41:48,566 --> 00:41:52,156
So, one example of that might
be that I want to restrict it


901
00:41:52,156 --> 00:41:55,056
so that only I can create
parties in the public database.


902
00:41:55,716 --> 00:41:57,106
So, what I'm going
to do in order to do


903
00:41:57,106 --> 00:41:58,556
that is create a new role.


904
00:41:58,556 --> 00:42:04,336
I'm going to call this, you
know, PartyAdmin, and in that,


905
00:42:04,336 --> 00:42:07,206
I need to choose a record type
and give it special permissions.


906
00:42:07,286 --> 00:42:11,676
So I'm going to choose parties,
and I'm going to give it Create,


907
00:42:11,676 --> 00:42:13,586
Read, and Write permissions
for those parties.


908
00:42:16,466 --> 00:42:19,596
Now, what I need to do is go to
the record type and restrict it


909
00:42:19,596 --> 00:42:21,366
so that no one else
can create a party.


910
00:42:21,756 --> 00:42:25,586
So, I'm going to find my
party, my party record type,


911
00:42:26,106 --> 00:42:29,376
and you can see up there
that parties can be created


912
00:42:29,376 --> 00:42:30,666
by anyone who's authenticated.


913
00:42:31,226 --> 00:42:33,496
We don't want that, we
want only party admins


914
00:42:33,536 --> 00:42:34,416
to create this record.


915
00:42:34,506 --> 00:42:38,296
So, we're going to
uncheck that value.


916
00:42:38,386 --> 00:42:40,626
Now, we need to assign
people to that role


917
00:42:40,696 --> 00:42:42,976
so that there's actually users
out there that can do this.


918
00:42:43,796 --> 00:42:45,246
If we go to the user records,


919
00:42:45,246 --> 00:42:47,776
we can see everyone who's
used this app so far.


920
00:42:48,626 --> 00:42:51,636
If they have marked themselves
as discoverable, you're going


921
00:42:51,636 --> 00:42:53,306
to be able to see their
first and last name.


922
00:42:53,756 --> 00:42:55,296
If they haven't,
you're just going to see


923
00:42:55,296 --> 00:42:57,826
that recordID up there.


924
00:42:58,036 --> 00:43:01,396
So, I'm going to click on
my user, and then I'm going


925
00:43:01,396 --> 00:43:05,976
to add myself as a party admin.


926
00:43:05,976 --> 00:43:08,326
And now, I'm the only user
in the public database


927
00:43:08,396 --> 00:43:11,676
that can create a party.


928
00:43:13,516 --> 00:43:18,486
[ Applause ]


929
00:43:18,986 --> 00:43:22,626
So, one of the last things the
iCloud Dashboard helps you do is


930
00:43:22,626 --> 00:43:25,066
move from development
into production.


931
00:43:25,376 --> 00:43:27,186
So, as I talked about earlier,


932
00:43:27,286 --> 00:43:29,986
we wanted the development
environment to be as quick


933
00:43:29,986 --> 00:43:31,556
and easy to use as possible.


934
00:43:32,056 --> 00:43:34,076
We wanted you to hit the
ground running, we wanted you


935
00:43:34,076 --> 00:43:37,046
to just open up Xcode,
start typing some code,


936
00:43:37,046 --> 00:43:39,806
save your record to the server,
and see immediate results.


937
00:43:40,496 --> 00:43:43,786
And that all works great because
the server does just-in-time


938
00:43:43,786 --> 00:43:47,256
schemas, but that's not very
efficient if we're working


939
00:43:47,256 --> 00:43:49,986
in a public database that
might have millions of users.


940
00:43:50,066 --> 00:43:52,916
We need to prepare some
things before we go


941
00:43:52,916 --> 00:43:55,946
into the environment that all of
our customers are going to hit.


942
00:43:56,656 --> 00:43:59,216
So, the way this works
is we've got our records,


943
00:43:59,326 --> 00:44:00,696
we're developing
our app right now,


944
00:44:01,586 --> 00:44:03,916
and we just created a record
for the very first time,


945
00:44:03,916 --> 00:44:05,896
and we uploaded it in the
development environment.


946
00:44:07,076 --> 00:44:08,206
The server is going to see that


947
00:44:08,256 --> 00:44:10,656
and since this is the first
time it's seen a party,


948
00:44:10,656 --> 00:44:13,316
it's going to automatically
create a new party record type.


949
00:44:13,316 --> 00:44:16,556
And then for each of
these keys and values,


950
00:44:17,056 --> 00:44:19,986
it's going to create an entry
in a schema, and it's going


951
00:44:19,986 --> 00:44:22,206
to create an index on
every one of those values.


952
00:44:23,316 --> 00:44:26,606
This index is what lets you
query for any value in a record.


953
00:44:27,096 --> 00:44:29,656
So, while you're in development,
you can just run a query


954
00:44:29,656 --> 00:44:32,506
and search on any value
for any key in a record.


955
00:44:33,966 --> 00:44:36,196
And let's say we're going ahead
and we're developing this app


956
00:44:36,196 --> 00:44:38,686
and we decide we want to
add an additional property,


957
00:44:38,686 --> 00:44:42,116
so we decide we want to
have a background property


958
00:44:42,116 --> 00:44:43,356
for the color of the party.


959
00:44:43,916 --> 00:44:45,556
So, this party's
background is blue.


960
00:44:46,046 --> 00:44:47,556
All we have to do is
upload that record.


961
00:44:48,116 --> 00:44:50,566
It's going to send all those
other properties to the index,


962
00:44:51,156 --> 00:44:52,936
and the server is
going to notice, "Oh,


963
00:44:52,936 --> 00:44:54,056
there's a new property in here."


964
00:44:54,546 --> 00:44:57,146
It's going to create a new
schema entry, build a new index,


965
00:44:57,536 --> 00:44:58,606
and index that property.


966
00:45:00,536 --> 00:45:03,006
When you're ready to release
your app, you're going to want


967
00:45:03,006 --> 00:45:05,406
to make sure you've run
everything in development first


968
00:45:05,506 --> 00:45:07,466
so that you've built up
this just-in-time schema.


969
00:45:08,726 --> 00:45:11,476
You're then going to use
the iCloud Dashboard to move


970
00:45:11,476 --> 00:45:13,896
that schema from
development into production,


971
00:45:13,896 --> 00:45:15,826
and you're going to want to
check all of these fields


972
00:45:15,826 --> 00:45:17,316
to make sure that
they're the right values,


973
00:45:17,836 --> 00:45:19,066
make sure that every key


974
00:45:19,066 --> 00:45:21,706
that your app will ever
use exists in the schema.


975
00:45:22,646 --> 00:45:25,146
And when you do that, you're
going to move it into production


976
00:45:25,146 --> 00:45:26,476
and lock that schema in.


977
00:45:28,066 --> 00:45:31,406
Additionally, all of these
indexes take up a decent amount


978
00:45:31,406 --> 00:45:33,306
of space because
it has to make it


979
00:45:33,306 --> 00:45:35,926
so that you can query
those records.


980
00:45:35,926 --> 00:45:38,216
If you know you're never
going to query a value


981
00:45:38,216 --> 00:45:40,266
like we know we're never
going to query for records


982
00:45:40,266 --> 00:45:43,636
with just a blue background,
you can drop that index,


983
00:45:43,686 --> 00:45:47,036
and this will help free up some
space in your app's database


984
00:45:47,036 --> 00:45:48,746
or in your user's database.


985
00:45:51,716 --> 00:45:54,886
So, finally, a couple
CloudKit tips and tricks.


986
00:45:56,286 --> 00:45:57,866
So, we already went over this


987
00:45:57,866 --> 00:46:00,286
in the intro talk
about error handling.


988
00:46:00,716 --> 00:46:02,346
Please handle your
errors in CloudKit.


989
00:46:02,416 --> 00:46:03,486
This is really important.


990
00:46:03,536 --> 00:46:07,496
I know error handling is
hard and it's not fun to do,


991
00:46:07,946 --> 00:46:11,886
but CloudKit is all based
on network communication.


992
00:46:12,526 --> 00:46:15,716
And when you're talking over the
network, anything can go wrong.


993
00:46:16,526 --> 00:46:18,256
You know, the network
can get dropped.


994
00:46:18,256 --> 00:46:20,096
Because we have other
people talking


995
00:46:20,096 --> 00:46:21,706
to the server, we
can get conflicts.


996
00:46:21,706 --> 00:46:22,526
We can get errors.


997
00:46:23,146 --> 00:46:26,646
All kinds of things can
happen, and as Paul said


998
00:46:26,646 --> 00:46:29,876
in the first talk, this is the
difference between a working app


999
00:46:29,876 --> 00:46:30,976
and a not working app.


1000
00:46:30,976 --> 00:46:34,606
It's not the difference between
a good app and a great app.


1001
00:46:34,606 --> 00:46:36,096
If you don't handle errors,


1002
00:46:36,176 --> 00:46:39,446
your app just isn't
going to work right.


1003
00:46:39,646 --> 00:46:42,786
In CloudKit also, we've tried
to avoid any sort of magic.


1004
00:46:42,906 --> 00:46:46,376
We don't want to try and handle
these errors for you and figure


1005
00:46:46,376 --> 00:46:47,406
out what might be best.


1006
00:46:47,896 --> 00:46:50,556
We want to just tell
you what happened.


1007
00:46:50,556 --> 00:46:53,306
We want you to be able to figure
out what you need to do next,


1008
00:46:53,306 --> 00:46:56,896
and we want to give you all
the information to do that.


1009
00:46:57,136 --> 00:46:59,236
So, keep in mind when you're
handling your errors here


1010
00:46:59,236 --> 00:47:01,566
that your operations
can have partial errors.


1011
00:47:02,036 --> 00:47:05,316
These partial errors when you're
using the NSOperation API,


1012
00:47:05,316 --> 00:47:07,746
you might be sending
up a batch of records.


1013
00:47:08,406 --> 00:47:10,636
And if you're saving them
to the public database,


1014
00:47:10,736 --> 00:47:12,806
it could be the case
that just one


1015
00:47:12,806 --> 00:47:15,746
of those records had a conflict
but the rest saved just fine.


1016
00:47:16,526 --> 00:47:18,626
If that happens, you're
going to get a partial error,


1017
00:47:18,746 --> 00:47:20,876
and inside of that, you're
going to find one error


1018
00:47:20,876 --> 00:47:21,966
for the record that failed.


1019
00:47:22,816 --> 00:47:25,386
If this was in a custom
zone, you might see


1020
00:47:25,386 --> 00:47:27,276
that as an atomic update error.


1021
00:47:27,276 --> 00:47:30,006
So, you might see that one
of those records failed,


1022
00:47:30,006 --> 00:47:33,366
and the rest got the
batch error in there.


1023
00:47:34,356 --> 00:47:37,096
And finally, we want
you to make sure


1024
00:47:37,096 --> 00:47:39,436
that you retry any
server busy errors.


1025
00:47:40,176 --> 00:47:42,476
It could be the case
that the, you know,


1026
00:47:42,546 --> 00:47:45,046
a bunch of people are going at
the servers at the same time


1027
00:47:45,046 --> 00:47:46,236
and the servers can't handle it


1028
00:47:46,236 --> 00:47:47,906
and they need clients
to back off.


1029
00:47:48,096 --> 00:47:50,686
It could also be that
your client is misbehaving


1030
00:47:50,686 --> 00:47:52,286
and hitting the server
too frequently,


1031
00:47:52,286 --> 00:47:55,686
and the server is saying,
"Slow down, buddy."


1032
00:47:55,686 --> 00:47:57,556
This is our way of
saying, "You know,


1033
00:47:57,556 --> 00:47:58,656
we need a little more time.


1034
00:47:58,656 --> 00:48:00,796
This request was OK, but
please try it again".


1035
00:48:01,426 --> 00:48:03,556
And anytime we give you
a server busy error,


1036
00:48:03,556 --> 00:48:06,496
we're going to hand back
a CKErrorRetryAfterKey.


1037
00:48:07,026 --> 00:48:09,456
This is a number of seconds
that we'd like you to wait


1038
00:48:09,456 --> 00:48:11,426
and retry your request.


1039
00:48:14,116 --> 00:48:17,046
So, limits, in the
keynote, it was mentioned


1040
00:48:17,046 --> 00:48:18,936
that CloudKit is
free with limits.


1041
00:48:19,556 --> 00:48:21,326
How do those limits work?


1042
00:48:21,326 --> 00:48:25,116
Well, anything stored in the
public database is counted


1043
00:48:25,116 --> 00:48:26,336
against your app's quota.


1044
00:48:26,386 --> 00:48:29,766
We give every app a
quota, and that's just


1045
00:48:29,766 --> 00:48:30,626
for the public database.


1046
00:48:31,726 --> 00:48:34,086
Anything you put in the
private database is counted


1047
00:48:34,086 --> 00:48:35,516
against the user's account.


1048
00:48:35,706 --> 00:48:39,656
So, every iCloud account gets
5 gigabytes of free storage,


1049
00:48:40,146 --> 00:48:43,446
but users might have bought
more, or they might have filled


1050
00:48:43,446 --> 00:48:46,356
up all that space with
emails or backups or photos.


1051
00:48:46,866 --> 00:48:48,796
So, every user is going
to have a different amount


1052
00:48:48,796 --> 00:48:49,516
of storage in there.


1053
00:48:50,126 --> 00:48:52,216
And because this is
kind of the user space


1054
00:48:52,216 --> 00:48:54,116
and it's shared space,
we want you to, you know,


1055
00:48:54,346 --> 00:48:55,916
remember to be nice
to your users.


1056
00:48:55,916 --> 00:49:01,086
It's technically free space for
you because it's theirs but,


1057
00:49:01,086 --> 00:49:03,326
you know, don't fill it
up with unnecessary stuff.


1058
00:49:03,906 --> 00:49:08,226
So again, with the
limits, how much do you get


1059
00:49:08,226 --> 00:49:09,096
for your app container?


1060
00:49:09,096 --> 00:49:10,766
Well, what we're concerned


1061
00:49:10,766 --> 00:49:13,666
with here is customers
having a great experience,


1062
00:49:14,166 --> 00:49:17,536
and these limits that we've
specified here are really


1063
00:49:17,576 --> 00:49:19,056
to try and prevent abuse.


1064
00:49:19,056 --> 00:49:20,936
We don't want to
prevent legitimate use.


1065
00:49:20,936 --> 00:49:23,446
We just don't want
anyone abusing CloudKit.


1066
00:49:24,496 --> 00:49:26,736
And the numbers that we
give you here also scale


1067
00:49:26,736 --> 00:49:28,356
with the number of
users you have.


1068
00:49:28,356 --> 00:49:29,946
If you go on
developer.apple.com,


1069
00:49:29,946 --> 00:49:32,666
you can get the full breakdown
of the different values,


1070
00:49:32,666 --> 00:49:36,916
but as an example, if you had
10 million users of your app,


1071
00:49:36,916 --> 00:49:39,486
we're going to give you a
petabyte of asset storage,


1072
00:49:39,486 --> 00:49:41,186
10 terabytes of database
storage,


1073
00:49:41,186 --> 00:49:44,676
some pretty high transfer
limits, and this is all


1074
00:49:44,766 --> 00:49:46,986
for your public database
in your application.


1075
00:49:49,556 --> 00:49:51,666
So, finally, a note
on efficiency.


1076
00:49:52,336 --> 00:49:54,916
One thing about CloudKit
is, again,


1077
00:49:54,916 --> 00:49:56,876
it's a transport mechanism.


1078
00:49:56,876 --> 00:49:59,976
We are only there to talk to
the iCloud servers for you.


1079
00:50:00,676 --> 00:50:02,636
We're not storing any records.


1080
00:50:02,636 --> 00:50:03,796
We're not caching records.


1081
00:50:04,316 --> 00:50:06,456
Anytime we give you back
a record, it's something


1082
00:50:06,456 --> 00:50:07,536
that we got from the server.


1083
00:50:08,156 --> 00:50:10,206
We're trying to be as
transparent about that


1084
00:50:10,206 --> 00:50:13,876
as possible and not do any
caching shenanigans here.


1085
00:50:13,876 --> 00:50:16,326
We're always just giving
you what the server gave us.


1086
00:50:17,666 --> 00:50:21,116
In terms of efficiency
though, you might remember


1087
00:50:21,166 --> 00:50:23,226
from the save policies
that we're only going


1088
00:50:23,226 --> 00:50:25,366
to save the values that
have changed on the records.


1089
00:50:25,366 --> 00:50:27,856
So, we try and be smart about
what we send over the wire.


1090
00:50:29,106 --> 00:50:30,846
When we're sending up assets,


1091
00:50:30,956 --> 00:50:33,586
those can be potentially
really big blobs of data,


1092
00:50:34,246 --> 00:50:36,496
and that data is
transferred efficiently.


1093
00:50:36,496 --> 00:50:38,896
So, if the server already
has a copy of a file,


1094
00:50:39,306 --> 00:50:40,306
we won't re-upload it.


1095
00:50:40,486 --> 00:50:42,236
If we already have
that file locally,


1096
00:50:42,236 --> 00:50:46,506
we don't need to re-download it.


1097
00:50:46,696 --> 00:50:50,076
So, in summary, we're really
excited about CloudKit here.


1098
00:50:50,076 --> 00:50:52,446
We've built a lot of
really great features


1099
00:50:52,926 --> 00:50:55,306
and it's something that
we actually use at Apple.


1100
00:50:55,306 --> 00:50:58,466
We've built iCloud Drive, we've
built iCloud Photos on top


1101
00:50:58,466 --> 00:51:02,326
of this, and we want you guys to
start using the same technology


1102
00:51:02,326 --> 00:51:03,646
that we're using at Apple.


1103
00:51:04,536 --> 00:51:06,906
I'm really excited to see
what's going to happen.


1104
00:51:06,906 --> 00:51:09,036
I can't wait to see some
apps that use CloudKit,


1105
00:51:09,566 --> 00:51:12,376
and good luck with
using CloudKit.


1106
00:51:14,516 --> 00:51:21,176
[ Applause ]


1107
00:51:21,676 --> 00:51:24,816
So, if you need any, if
you need to contact anyone,


1108
00:51:24,816 --> 00:51:26,316
Dave DeLong is our Evangelist.


1109
00:51:26,316 --> 00:51:28,376
He's the guy with the bowtie.


1110
00:51:28,426 --> 00:51:31,976
If you need documentation,
it's on developer.apple.com.


1111
00:51:31,976 --> 00:51:35,086
We had a Introducing CloudKit
session earlier in the week.


1112
00:51:35,246 --> 00:51:37,836
There's a couple more
related sessions.


1113
00:51:38,876 --> 00:51:39,216
Thank you.


1114
00:51:40,016 --> 00:51:41,000
[ Applause ]

