1
00:00:28,136 --> 00:00:28,656
>> WIL TURNER: Good morning.


2
00:00:29,286 --> 00:00:32,356
And welcome to UI
testing in Xcode.


3
00:00:33,146 --> 00:00:34,046
My name is Wil Turner.


4
00:00:34,636 --> 00:00:35,976
With me is Brooke Callahan.


5
00:00:36,716 --> 00:00:39,626
We both work on the
Xcode developer tools.


6
00:00:40,536 --> 00:00:44,466
And I am extremely excited
today because we are sharing


7
00:00:44,466 --> 00:00:48,506
with you a huge expansion
of the testing technology


8
00:00:48,506 --> 00:00:50,166
in the Xcode developer tools.


9
00:00:51,316 --> 00:00:52,726
That is UI testing.


10
00:00:53,196 --> 00:00:57,986
With UI testing you can find
user interface elements,


11
00:00:58,546 --> 00:01:03,086
interact with them, and validate
the UI properties in state.


12
00:01:04,256 --> 00:01:07,756
Along with UI testing, we've
introduced UI recording


13
00:01:07,896 --> 00:01:10,796
which will allow you
to really rapidly set


14
00:01:10,796 --> 00:01:12,996
up UI testing for your projects.


15
00:01:14,256 --> 00:01:17,806
Finally, we've updated
the test reports in Xcode,


16
00:01:17,806 --> 00:01:21,516
which show the pass and fail and
results of your test outcomes,


17
00:01:21,646 --> 00:01:24,466
to accommodate new data
we have with UI testing.


18
00:01:26,166 --> 00:01:29,106
So I want to talk about
the core technologies


19
00:01:29,386 --> 00:01:31,566
for UI testing, the
first is XCTest.


20
00:01:32,566 --> 00:01:34,616
The second is accessibility.


21
00:01:35,766 --> 00:01:38,606
So XCTest is Xcode's
testing framework.


22
00:01:38,926 --> 00:01:42,506
In it, you create subclasses
for your test cases,


23
00:01:42,856 --> 00:01:46,956
you implement test methods, and
you use assertions to validate


24
00:01:47,036 --> 00:01:49,356
that your expected
outcomes are holding true.


25
00:01:50,676 --> 00:01:55,056
XCtest is integrated with Xcode,
which means you get everything


26
00:01:55,056 --> 00:01:58,536
from the ID in terms of
code completion, debugging,


27
00:01:58,536 --> 00:02:01,216
and the ability to run
your tests directly


28
00:02:01,306 --> 00:02:04,356
from your source code, and
see the results right there.


29
00:02:05,436 --> 00:02:08,656
You also get continuous
integration via Xcode Server


30
00:02:08,656 --> 00:02:09,576
and Xcodebuild.


31
00:02:10,856 --> 00:02:14,806
Finally, XCTest supports
both Swift and Objective-C,


32
00:02:14,906 --> 00:02:16,966
so you can choose the
native coding language


33
00:02:17,026 --> 00:02:18,786
that you're most
comfortable with.


34
00:02:20,116 --> 00:02:24,196
XCTest was introduced in Xcode
5 as a unit testing framework.


35
00:02:24,376 --> 00:02:28,716
In Xcode 6, we expanded it to
support performance testing.


36
00:02:29,246 --> 00:02:31,776
This allows you to catch
regressions in your code,


37
00:02:31,976 --> 00:02:33,236
and ensure that it continues


38
00:02:33,236 --> 00:02:36,306
to perform optimally,
release to release.


39
00:02:37,106 --> 00:02:40,886
Now in Xcode 7, we've introduced
UI testing which you can use


40
00:02:40,886 --> 00:02:43,086
for both correctness
and performance testing.


41
00:02:44,596 --> 00:02:45,366
So that's XCTest.


42
00:02:46,016 --> 00:02:47,676
Now let's take a look
at Accessibility.


43
00:02:48,576 --> 00:02:51,456
Accessibility is the
technology on our platforms,


44
00:02:51,666 --> 00:02:54,786
that gives disabled people
the same great experience


45
00:02:54,786 --> 00:02:56,716
on our devices and
with our applications


46
00:02:57,056 --> 00:02:58,416
that all other users receive.


47
00:02:59,116 --> 00:03:02,336
To make Accessibility
work, it offers a rich set


48
00:03:02,336 --> 00:03:05,966
of semantic data about the UI
that technologies like Voice


49
00:03:05,966 --> 00:03:08,976
Over can use to guide users
through the application.


50
00:03:09,676 --> 00:03:13,406
UI testing uses that, and
Accessibility is integrated


51
00:03:13,406 --> 00:03:16,536
with the UI kit, and app kit,
so, when you use controls


52
00:03:16,536 --> 00:03:19,516
from those frameworks, you get
a lot of accessibility support


53
00:03:19,786 --> 00:03:21,336
for free, right out of the box.


54
00:03:22,306 --> 00:03:24,206
It also provides
APIs that allow you


55
00:03:24,206 --> 00:03:27,256
to fine tune the accessibility
data that is exposed.


56
00:03:28,646 --> 00:03:31,016
The key about this is
that with UI testing,


57
00:03:31,176 --> 00:03:32,486
your tests will interact


58
00:03:32,926 --> 00:03:34,956
with the application
just the way a user does.


59
00:03:36,636 --> 00:03:38,496
UI testing has a
few requirements


60
00:03:38,646 --> 00:03:39,876
that you should understand.


61
00:03:39,946 --> 00:03:44,236
The first is it depends
on new features in the OS.


62
00:03:44,236 --> 00:03:48,856
For iOS you need iOS 9 and
for OS X you need OS 10.11.


63
00:03:50,746 --> 00:03:52,426
UI testing protects
your privacy.


64
00:03:52,856 --> 00:03:57,126
And to do so it means your
iOS devices need to be enabled


65
00:03:57,126 --> 00:04:02,546
for development and connected
to a trusted host running Xcode.


66
00:04:03,496 --> 00:04:05,746
On OS X you'll need
to grant permission


67
00:04:05,746 --> 00:04:09,066
to a special Xcode helper app,
and you will be prompted to do


68
00:04:09,066 --> 00:04:12,996
so the first time
you run UI tests.


69
00:04:13,246 --> 00:04:15,946
Let's take a look at what
you need to get started


70
00:04:16,216 --> 00:04:17,486
with UI test in your project.


71
00:04:18,536 --> 00:04:20,826
First of all there's a
new Xcode target type.


72
00:04:21,226 --> 00:04:24,596
Traditionally, unit tests were
a specific target type in Xcode,


73
00:04:24,916 --> 00:04:27,166
and now UI tests are
target type as well.


74
00:04:28,096 --> 00:04:30,876
We've also introduced a
large set of set of new APIs


75
00:04:31,066 --> 00:04:35,486
for UI test, and of
course UI recording,


76
00:04:35,646 --> 00:04:37,936
which will really get
you started quickly.


77
00:04:38,506 --> 00:04:43,856
So the Xcode testing targets
support the special requirements


78
00:04:43,966 --> 00:04:45,016
that UI tests have.


79
00:04:45,416 --> 00:04:47,726
This includes executing
in a separate process


80
00:04:47,726 --> 00:04:49,296
from your application
that you are testing.


81
00:04:49,296 --> 00:04:52,616
And it also handles the
permission to use Accessibility


82
00:04:52,616 --> 00:04:53,736
in the privacy protection.


83
00:04:55,376 --> 00:04:59,346
These targets have new templates
for both Cocoa and Cocoa Touch


84
00:04:59,896 --> 00:05:01,916
and the assistant for
these will set everything


85
00:05:01,916 --> 00:05:04,156
up the way you need
it to get started.


86
00:05:05,116 --> 00:05:08,196
There's a target to be tested
setting for UI test bundles


87
00:05:08,236 --> 00:05:10,796
that identifies the application
that you are testing.


88
00:05:11,446 --> 00:05:16,486
In the new APIs there
are three key classes.


89
00:05:16,946 --> 00:05:18,376
The first is applications.


90
00:05:19,556 --> 00:05:20,956
The second is elements.


91
00:05:21,106 --> 00:05:23,386
And the third is element query.


92
00:05:23,906 --> 00:05:25,976
We will take a deep dive


93
00:05:25,976 --> 00:05:28,756
into these APIs a little bit
later in the presentation.


94
00:05:30,356 --> 00:05:32,636
UI Recording lets you interact


95
00:05:32,636 --> 00:05:34,886
with your application
hands-on your device,


96
00:05:34,886 --> 00:05:38,346
the simulator, or OS X Mac.


97
00:05:38,636 --> 00:05:42,406
While you are doing so, it
generates the code necessary


98
00:05:42,406 --> 00:05:43,966
to recreate those interactions.


99
00:05:44,536 --> 00:05:50,256
You can do this to create new
tests or expand existing tests.


100
00:05:51,126 --> 00:05:54,446
So let's take a look at
what this is all about.


101
00:05:55,056 --> 00:05:56,696
Brooke, let's see a quick demo.


102
00:05:58,516 --> 00:06:04,276
[Applause]


103
00:06:04,776 --> 00:06:05,116
>> BROOKE CALLAHAN: Thanks, Wil.


104
00:06:05,606 --> 00:06:07,916
So, without further ado.


105
00:06:08,696 --> 00:06:10,246
The project I'm going
to be using


106
00:06:10,246 --> 00:06:12,316
for the demo today is
the lister application.


107
00:06:12,316 --> 00:06:14,486
This is an example project
that you can download


108
00:06:14,486 --> 00:06:15,706
from developer.Apple.com.


109
00:06:16,246 --> 00:06:19,306
So, let's get started, now it's
got my target configured just


110
00:06:19,306 --> 00:06:21,176
the way I want, but the one
part I want to point out is


111
00:06:21,176 --> 00:06:23,656
that the target to be tested
is the lister application.


112
00:06:23,656 --> 00:06:25,006
This is the one application


113
00:06:25,006 --> 00:06:30,826
that my tests will be
able to interact with.


114
00:06:31,036 --> 00:06:35,316
So now I've got my
new test class here.


115
00:06:35,886 --> 00:06:40,476
And there's a little stub test
method here and a setup function


116
00:06:40,616 --> 00:06:43,336
which is going to
call, which is going


117
00:06:43,336 --> 00:06:47,576
to launch the application
before my test method is called.


118
00:06:47,576 --> 00:06:49,786
And it's going to do that for
all the test methods I add


119
00:06:49,786 --> 00:06:50,416
to this class.


120
00:06:51,666 --> 00:06:54,446
So Let's add a new test
from the lister app.


121
00:06:54,646 --> 00:06:59,806
I'm going to put the keyboard
cursor in the method and click


122
00:06:59,806 --> 00:07:04,586
on the record button
down the debug bar.


123
00:07:04,806 --> 00:07:06,356
Now, Xcode is launching
my application.


124
00:07:06,926 --> 00:07:07,676
And here it is.


125
00:07:08,126 --> 00:07:12,026
The lister application allows
me to manage a series of lists.


126
00:07:12,406 --> 00:07:17,366
So probably the most common
thing people do is add


127
00:07:17,626 --> 00:07:19,136
and remove items
from their list.


128
00:07:19,416 --> 00:07:21,066
So I am going to
click here, add item.


129
00:07:21,496 --> 00:07:23,566
It looks like we have a lot


130
00:07:23,566 --> 00:07:25,886
of health some things
in this grocery list.


131
00:07:25,886 --> 00:07:27,636
So I'm going to add cookies.


132
00:07:27,976 --> 00:07:33,216
You can see that, as I'm typing,
the source header is updating.


133
00:07:33,216 --> 00:07:36,916
If I press delete, it also
removes what I removed


134
00:07:36,916 --> 00:07:37,636
from the text field.


135
00:07:38,666 --> 00:07:45,776
Next thing I'm going to do
is tap on the cookies item


136
00:07:46,026 --> 00:07:47,046
to mark it as completed.


137
00:07:47,586 --> 00:07:49,286
And another thing I can do


138
00:07:49,286 --> 00:07:51,816
in this application is
remove items from the list.


139
00:07:51,816 --> 00:07:55,366
So I'll click on edit,
and then delete cookies,


140
00:07:55,836 --> 00:07:58,296
and the delete confirmation
button, and finally done.


141
00:07:59,406 --> 00:08:01,976
Great. Now I have a
simple test that adds


142
00:08:01,976 --> 00:08:03,546
and removes an item
from the list.


143
00:08:03,546 --> 00:08:04,876
So I'll click stop.


144
00:08:05,796 --> 00:08:06,646
Let's see that in action.


145
00:08:14,686 --> 00:08:18,026
It added the cookies
and it is removing it.


146
00:08:18,726 --> 00:08:19,216
And we are done.


147
00:08:20,516 --> 00:08:27,316
[Applause]


148
00:08:27,816 --> 00:08:30,626
Thanks. As the test
interacts with UI elements,


149
00:08:30,626 --> 00:08:33,586
we get implicit validation
that those UI elements exist.


150
00:08:33,905 --> 00:08:36,166
But What we don't
get validation of,


151
00:08:36,265 --> 00:08:38,145
are things like state
changes in the application.


152
00:08:38,265 --> 00:08:40,856
For example, when we tapped
on that cookies button,


153
00:08:41,166 --> 00:08:43,866
we don't get any
validation that the state


154
00:08:43,866 --> 00:08:45,166
of the button actually changed.


155
00:08:46,436 --> 00:08:49,696
And later on in the
test, when it taps


156
00:08:49,696 --> 00:08:52,436
on the delete confirmation
button,


157
00:08:52,856 --> 00:08:55,616
we know that the delete
confirmation button was tapped.


158
00:08:56,036 --> 00:08:58,936
but running the test
doesn't validate


159
00:08:58,936 --> 00:09:01,356
that the cookies row
actually is removed.


160
00:09:02,406 --> 00:09:04,846
So to get validation
of those for my test,


161
00:09:04,846 --> 00:09:07,126
I want to add some
explicit assertions.


162
00:09:07,156 --> 00:09:11,636
First thing I am going
to do is add an assertion


163
00:09:11,676 --> 00:09:15,726
that the cookies button here
actually changes its state.


164
00:09:15,806 --> 00:09:17,676
To do that, I will
add a new constant.


165
00:09:17,676 --> 00:09:19,706
Call this let cookies button.


166
00:09:20,376 --> 00:09:27,436
I'm going to change the test
to tap on that constant.


167
00:09:27,436 --> 00:09:31,196
Now, to add the assertion I
need some state, some properties


168
00:09:31,196 --> 00:09:35,256
of the element to assert on.


169
00:09:35,616 --> 00:09:38,386
And cookies button
is XUI element


170
00:09:39,036 --> 00:09:41,456
and XUI elements have
a value property.


171
00:09:41,966 --> 00:09:43,836
What I'm going to do, is I'm
going to set a breakpoint here,


172
00:09:44,706 --> 00:09:52,676
and run the test to that point.


173
00:09:53,056 --> 00:09:54,926
So here we have the
test in the state


174
00:09:54,926 --> 00:09:56,646
where it's added
the cookies row.


175
00:09:57,416 --> 00:09:59,396
And it has yet to
tap on that button.


176
00:09:59,456 --> 00:10:03,316
So I'm going to go
in the debugger,


177
00:10:03,926 --> 00:10:08,166
and print out the value
of this cookies button.


178
00:10:08,166 --> 00:10:08,996
Little typo.


179
00:10:13,716 --> 00:10:17,186
-- there we go.


180
00:10:17,606 --> 00:10:28,566
I can see that the value of the
cookies button is the string


181
00:10:28,916 --> 00:10:30,046
with the number zero in it.


182
00:10:32,006 --> 00:10:34,516
Next I'm going to
step over that line.


183
00:10:34,696 --> 00:10:36,056
So now it's tap the
cookies button.


184
00:10:36,146 --> 00:10:41,126
I will print out the value
of it again and now I can see


185
00:10:41,126 --> 00:10:43,886
that the value of the button is
the string with the number one.


186
00:10:44,436 --> 00:10:46,166
Great. So now I have all
the information that I need


187
00:10:46,446 --> 00:10:51,436
to assert that the value of the
button changes when it's tapped.


188
00:10:51,576 --> 00:10:56,416
So I'm going to add an assertion
using XCT assert equal.


189
00:10:56,416 --> 00:11:02,296
I'll assert that the value


190
00:11:02,296 --> 00:11:04,756
after the tap is a string
with the number one.


191
00:11:05,196 --> 00:11:07,526
The value is in any object.


192
00:11:07,586 --> 00:11:11,546
So I am going to need to
assert that this is a string.


193
00:11:11,956 --> 00:11:13,586
So I'll use as string.


194
00:11:13,586 --> 00:11:18,326
And assert that it's
number one after the tap.


195
00:11:19,006 --> 00:11:21,846
And I'll assert that
it is the number string


196
00:11:21,846 --> 00:11:25,716
with the number zero
before the tap.


197
00:11:25,716 --> 00:11:30,926
And lastly, after the delete
confirmation button is tapped I


198
00:11:30,926 --> 00:11:34,336
want to assert that that
cookies row goes away.


199
00:11:34,336 --> 00:11:36,816
I'll call XCT assert
equal and assert


200
00:11:37,136 --> 00:11:38,876
that the button no
longer exists.


201
00:11:43,636 --> 00:11:46,406
Now iIf I run this test again we
should see it does all the same


202
00:11:46,406 --> 00:11:48,176
thing but also passing
these assertions.


203
00:11:57,516 --> 00:12:00,626
Great, so now I have
just added my first test.


204
00:12:01,936 --> 00:12:02,436
Back to you, Wil.


205
00:12:03,516 --> 00:12:09,446
[Applause]


206
00:12:09,946 --> 00:12:10,946
>> WIL TURNER: That
was pretty awesome.


207
00:12:10,946 --> 00:12:13,446
You can see just how easily
Brooke took an existing


208
00:12:13,446 --> 00:12:16,836
application and used it,
just like he would as a user,


209
00:12:17,426 --> 00:12:19,816
and in a handful of
minutes he created a test.


210
00:12:20,226 --> 00:12:22,676
He could expand that
test using XCT assert


211
00:12:22,676 --> 00:12:27,136
to do some additional validation
and he just added reliability


212
00:12:27,136 --> 00:12:29,256
to his project with
minimal effort.


213
00:12:29,916 --> 00:12:32,846
That's pretty exciting.


214
00:12:33,216 --> 00:12:36,376
So you can see we added
UI testing target,


215
00:12:36,736 --> 00:12:38,926
very straightforward just like
all our other other targets,


216
00:12:38,926 --> 00:12:40,426
with an assistant and templates.


217
00:12:41,406 --> 00:12:46,636
Used recording, interacted with
the app, and it creates the code


218
00:12:46,636 --> 00:12:49,206
that uses the elements
and synthesizes the events


219
00:12:49,296 --> 00:12:53,446
and then the additional
validation with XCT assert.


220
00:12:55,696 --> 00:12:58,856
Let's take a look at
this UI testing API.


221
00:13:00,586 --> 00:13:02,596
I mentioned earlier that
there are three classes.


222
00:13:02,846 --> 00:13:05,436
They are XCUIApplication,


223
00:13:05,666 --> 00:13:09,466
XCUIElement, and
XCUIElementQuery.


224
00:13:10,166 --> 00:13:10,816
How do they work?


225
00:13:11,586 --> 00:13:14,606
Let's start with a very
simple, something even simpler


226
00:13:14,956 --> 00:13:16,686
than Brooke's example.


227
00:13:17,276 --> 00:13:21,076
Line-by-line going through here
first I am instantiating my


228
00:13:21,076 --> 00:13:22,126
application object.


229
00:13:22,126 --> 00:13:24,856
This is a proxy for
my application.


230
00:13:25,606 --> 00:13:26,406
Then I launch it.


231
00:13:26,866 --> 00:13:27,936
That brings it up for me.


232
00:13:29,376 --> 00:13:32,646
And then I use element and
query to find the add button.


233
00:13:33,756 --> 00:13:36,976
And then I synthesize the
event that taps on it.


234
00:13:36,976 --> 00:13:40,156
Finally, I add in an
assertion just like Brooke did


235
00:13:40,596 --> 00:13:43,016
to make sure that the UI
had the expected state


236
00:13:43,156 --> 00:13:45,416
at the end of the test.


237
00:13:46,166 --> 00:13:48,916
So I mentioned that
UIApplication is a proxy


238
00:13:49,006 --> 00:13:50,246
for the tested application.


239
00:13:51,206 --> 00:13:54,126
It is independent of the
lifecycle of the launch


240
00:13:54,126 --> 00:13:55,866
and termination lifecycle
of your app.


241
00:13:56,256 --> 00:13:58,316
Because Your tests are
running in a separate process.


242
00:13:58,756 --> 00:14:01,586
You get explicit control
over when the app is launched


243
00:14:01,926 --> 00:14:06,466
and when it is terminated.


244
00:14:06,466 --> 00:14:09,976
When you launch we will
always spawn a new process.


245
00:14:10,246 --> 00:14:13,006
So that's something
we do to kind


246
00:14:13,006 --> 00:14:17,076
of not give you completely Clean
Slate because you have a lot


247
00:14:17,076 --> 00:14:19,586
of state in your application
that it's up to you to control.


248
00:14:19,976 --> 00:14:23,016
But by launching a
process clean each time,


249
00:14:23,316 --> 00:14:25,956
we help you minimize the number
of variables that you have


250
00:14:25,996 --> 00:14:26,826
to deal with in your test.


251
00:14:27,916 --> 00:14:29,556
So if it's already running,


252
00:14:29,716 --> 00:14:32,746
calling launch will terminate
the previous existing instance.


253
00:14:34,776 --> 00:14:38,466
Application is also the starting
point for finding elements.


254
00:14:38,966 --> 00:14:40,266
Let's talk about elements.


255
00:14:40,926 --> 00:14:44,906
XCUIElement, just like
Application, is a proxy object,


256
00:14:45,226 --> 00:14:47,456
but this time for user
interface elements


257
00:14:47,646 --> 00:14:48,906
in the tested application.


258
00:14:49,596 --> 00:14:50,826
Elements have types.


259
00:14:51,476 --> 00:14:54,196
Types are like button, or
cell, or window, and so forth.


260
00:14:54,326 --> 00:14:58,536
They have what we call
identifiers, strings of data


261
00:14:58,536 --> 00:15:00,316
that we get from the
accessibility system,


262
00:15:00,906 --> 00:15:04,376
hich are an identifier or
label or title, so forth.


263
00:15:05,886 --> 00:15:08,656
Most of the time you'll find
elements using a combination


264
00:15:08,656 --> 00:15:10,206
of the type and the label.


265
00:15:10,206 --> 00:15:12,276
For example, if you have
a bullton which is add,


266
00:15:12,276 --> 00:15:16,786
you'll look for the button
type with the identifier add.


267
00:15:17,496 --> 00:15:20,436
Elements form a hierarchy
in your application.


268
00:15:20,496 --> 00:15:22,996
The application is
the root of a tree.


269
00:15:23,296 --> 00:15:25,636
If you think back to your
computer science days you'll


270
00:15:25,636 --> 00:15:26,916
remember tree data structures.


271
00:15:27,716 --> 00:15:33,026
With the lister application we
have this very simple tree here


272
00:15:33,026 --> 00:15:35,036
with the application
at the top and we have


273
00:15:35,036 --> 00:15:39,816
like the nav bar
and the add button.


274
00:15:39,876 --> 00:15:40,946
Groceries label.


275
00:15:41,076 --> 00:15:42,116
So on and so forth.


276
00:15:42,696 --> 00:15:44,546
So each of these is an element


277
00:15:45,266 --> 00:15:47,376
that you can reference
in your tests.


278
00:15:48,056 --> 00:15:50,196
These are used by queries.


279
00:15:50,666 --> 00:15:53,466
This hierarchy, as well
as type and identifier,


280
00:15:53,626 --> 00:15:54,616
to find your elements.


281
00:15:56,376 --> 00:15:58,046
Elements, when you
work with them


282
00:15:58,046 --> 00:16:00,166
in your test, must be unique.


283
00:16:00,876 --> 00:16:01,726
So what does that mean?


284
00:16:02,156 --> 00:16:04,666
Well, every one of these
elements is backed by a query.


285
00:16:05,006 --> 00:16:07,856
The query has to resolve
to a single instance.


286
00:16:09,206 --> 00:16:11,746
Otherwise when we go to
synthesize the events


287
00:16:11,746 --> 00:16:14,406
that you tell us to tap but
there's multiple buttons


288
00:16:14,406 --> 00:16:16,596
that match that, it
is not deterministic.


289
00:16:16,596 --> 00:16:18,686
We can't really know what
you mean for us to do.


290
00:16:19,086 --> 00:16:22,486
Similarly, if you ask us for
a property of the element,


291
00:16:22,976 --> 00:16:25,946
we don't know which one
did you really mean?


292
00:16:25,946 --> 00:16:27,166
Maybe there wasn't one at all.


293
00:16:27,626 --> 00:16:29,706
So it's important to the
queries for the elements


294
00:16:29,706 --> 00:16:31,906
to resolve to exactly one match.


295
00:16:33,106 --> 00:16:36,636
If they don't, when you access
the element we'll raise a


296
00:16:36,636 --> 00:16:37,376
failure for that.


297
00:16:38,306 --> 00:16:40,166
There is one exception to this,


298
00:16:40,266 --> 00:16:44,086
which is an API called the
exists property on XCUIElement.


299
00:16:44,626 --> 00:16:48,186
This allows you to test for the
existence of the element safely.


300
00:16:48,756 --> 00:16:50,916
You can use this as
Brooke did to verify


301
00:16:50,916 --> 00:16:52,676
that the element had
been removed from the UI


302
00:16:52,776 --> 00:16:56,086
and you can also use
this to handle cases


303
00:16:56,086 --> 00:16:57,466
where you have conditional UI


304
00:16:57,596 --> 00:16:59,386
that might display
in some context.


305
00:16:59,386 --> 00:17:02,506
For example, if you are
saving a file to a location


306
00:17:02,506 --> 00:17:05,425
where another file already
exists, you might get some kind


307
00:17:05,425 --> 00:17:06,526
of confirmation sheet.


308
00:17:06,945 --> 00:17:08,826
That wouldn't be
present all the time.


309
00:17:08,826 --> 00:17:10,476
Just the case where
there's these conflicts.


310
00:17:10,476 --> 00:17:13,826
You can use an exist
check for those cases.


311
00:17:15,126 --> 00:17:18,256
Elements are where event
synthesis APIs live.


312
00:17:18,886 --> 00:17:22,736
Event synthesis is how we
simulate user interaction,


313
00:17:22,736 --> 00:17:26,165
and do this at the lowest level
of the system so everything goes


314
00:17:26,165 --> 00:17:29,796
through the same channels it
would when the user interacts.


315
00:17:29,796 --> 00:17:32,486
The APIs for event synthesis
are platform-specific


316
00:17:33,006 --> 00:17:33,986
with some exceptions.


317
00:17:34,576 --> 00:17:37,136
We have button click,
for example in OS X


318
00:17:37,136 --> 00:17:41,796
and the corresponding
is button tap on iOS.


319
00:17:41,796 --> 00:17:44,806
We have type text which is
the same on both platforms


320
00:17:44,806 --> 00:17:48,316
and takes a string of text.


321
00:17:48,856 --> 00:17:53,176
XCUIElementQuery is our API
for specifying elements.


322
00:17:54,136 --> 00:17:58,806
Queries resolve to collections
of accessible elements.


323
00:17:58,806 --> 00:18:01,856
They can only find elements that
are visible to Accessibility.


324
00:18:02,756 --> 00:18:07,376
And they will resolve
to a set of these.


325
00:18:07,596 --> 00:18:08,886
That means you can
get the number


326
00:18:08,886 --> 00:18:10,656
of matches using
the count property.


327
00:18:10,656 --> 00:18:15,116
And you can also
specify distinct elements


328
00:18:15,386 --> 00:18:18,156
in that set using
subscripting with an identifier


329
00:18:19,136 --> 00:18:21,076
or using an element
at index API.


330
00:18:21,076 --> 00:18:23,906
We will look at these
more in a moment.


331
00:18:24,436 --> 00:18:26,496
So how do queries work?


332
00:18:27,756 --> 00:18:29,566
So I mentioned that
element hierarchy.


333
00:18:30,426 --> 00:18:34,016
So the relationships in
that hierarchy are one side


334
00:18:34,016 --> 00:18:34,916
of how queries work.


335
00:18:35,126 --> 00:18:36,816
The other side is by filtering.


336
00:18:37,836 --> 00:18:40,456
Filtering is taking
one set and reducing


337
00:18:40,456 --> 00:18:42,996
that set according
to certain criteria.


338
00:18:44,416 --> 00:18:48,206
With our lister example again
here is how we might express


339
00:18:48,206 --> 00:18:51,276
certain relationships, the
first of which is descendants.


340
00:18:51,276 --> 00:18:54,076
In this case I'm
showing the view.


341
00:18:54,756 --> 00:18:57,066
All the gold cells
are its descendents.


342
00:18:58,226 --> 00:19:01,366
On the other hand children is a
more restrictive relationship.


343
00:19:01,366 --> 00:19:04,906
It's just the elements that
are directly below the element


344
00:19:04,906 --> 00:19:05,556
you're querying.


345
00:19:05,626 --> 00:19:08,016
So, the table's children
are just the cells.


346
00:19:08,976 --> 00:19:11,746
The final relationship
we use is containment.


347
00:19:12,176 --> 00:19:14,696
This happens to be very
useful when we have cases


348
00:19:14,696 --> 00:19:17,406
where the elements, like the
cells, they don't have a lot


349
00:19:17,406 --> 00:19:19,576
of data that unique
them from each other,


350
00:19:19,946 --> 00:19:22,116
but they contain
elements which are unique.


351
00:19:22,416 --> 00:19:25,226
For example, the first cell
contains the groceries label.


352
00:19:26,706 --> 00:19:31,106
Filtering lets us take
things like the element type,


353
00:19:32,266 --> 00:19:35,596
or its identifiers,
to create queries


354
00:19:35,846 --> 00:19:37,816
that filter a previous query.


355
00:19:38,396 --> 00:19:41,976
We can also do this with
predicates which will allow us


356
00:19:42,286 --> 00:19:45,316
to go beyond the identifiers
to look at the values


357
00:19:45,646 --> 00:19:47,766
or do partial matching
such as "begins with"


358
00:19:47,766 --> 00:19:50,576
and that sort of thing.


359
00:19:50,576 --> 00:19:54,066
We combine relationships and
the filtering in the APIs


360
00:19:54,136 --> 00:19:57,196
and the first of which is
descendantsMatchingType.


361
00:19:57,286 --> 00:19:59,166
You can figure out
what that does.


362
00:19:59,626 --> 00:20:02,146
It find the descendants
that match a certain type.


363
00:20:02,556 --> 00:20:05,276
This turns out to be the
most common query you'll use.


364
00:20:05,666 --> 00:20:09,106
Some examples of this are,
I can find all the buttons


365
00:20:09,106 --> 00:20:11,566
in an application
by calling app,


366
00:20:12,256 --> 00:20:13,826
descendentsMatchingType button.


367
00:20:15,006 --> 00:20:17,746
Similarly I can find
all the cells in a table


368
00:20:18,206 --> 00:20:21,386
by telling the table to give me
descendentsMatchingType cell,


369
00:20:22,106 --> 00:20:24,116
or, another example,
with menu items.


370
00:20:25,426 --> 00:20:29,076
This is such a common query
that we provide convenience API


371
00:20:29,076 --> 00:20:32,096
for every one of these types.


372
00:20:32,456 --> 00:20:35,836
DescendentsMatchingType
buttons, becomes just buttons.


373
00:20:37,486 --> 00:20:40,326
DescendentsMatchingType
cell becomes just cells,


374
00:20:41,216 --> 00:20:43,136
and so on and so forth.


375
00:20:44,016 --> 00:20:48,216
These convenience APIs help
make your tests very expressive


376
00:20:48,376 --> 00:20:49,346
yet concise.


377
00:20:51,516 --> 00:20:56,036
[Applause]


378
00:20:56,536 --> 00:20:59,036
ChildrenMatchingType is
the other combination


379
00:20:59,036 --> 00:21:00,356
of relationships in filtering.


380
00:21:01,066 --> 00:21:03,816
So in that, that allows
us to differentiate


381
00:21:03,816 --> 00:21:06,466
between descendants, all the
descendants that match a type,


382
00:21:06,636 --> 00:21:08,796
and just those that
match, that are children.


383
00:21:10,406 --> 00:21:13,696
Again the all buttons
example, is app.buttons,


384
00:21:13,796 --> 00:21:17,086
if I want to find just the
buttons that are children


385
00:21:17,086 --> 00:21:19,156
of my nav bar, I
can take my nav bar


386
00:21:19,156 --> 00:21:20,696
and say childrenMatchingType
button.


387
00:21:21,236 --> 00:21:24,096
It is not as common a
query, but there are cases


388
00:21:24,096 --> 00:21:26,496
where it becomes very
useful to differentiate.


389
00:21:28,016 --> 00:21:29,766
Finally, containing type.


390
00:21:30,366 --> 00:21:34,416
This allows us to find elements
by describing their descendants.


391
00:21:35,306 --> 00:21:37,496
So in the example
we have the cells


392
00:21:37,576 --> 00:21:40,716
that are each somewhat
anonymous.


393
00:21:40,716 --> 00:21:43,076
They don't have any
identifying characteristics,


394
00:21:43,696 --> 00:21:45,756
but they do contain
unique labels.


395
00:21:46,426 --> 00:21:48,316
Labels are also known
as static texts.


396
00:21:49,396 --> 00:21:53,226
So here I can form a cell
query which takes the cells


397
00:21:53,286 --> 00:21:56,206
and finds the one that is
containing the type static text


398
00:21:56,346 --> 00:21:58,166
with the identifier groceries.


399
00:21:58,666 --> 00:21:59,976
That will find the
first cell for me.


400
00:22:00,706 --> 00:22:04,836
There's also predicate
variant for this API.


401
00:22:05,486 --> 00:22:07,056
So those are our three APIs


402
00:22:07,056 --> 00:22:09,306
that combine relationships
and filtering.


403
00:22:09,596 --> 00:22:12,046
DescendentsMatchingType,
childrenMatchingType,


404
00:22:12,556 --> 00:22:15,526
containingType, and of course
all the convenience APIs


405
00:22:15,526 --> 00:22:16,646
for descendentsMatchingType.


406
00:22:18,756 --> 00:22:20,676
The other powerful
thing about query is


407
00:22:20,676 --> 00:22:22,376
that they can be
chained together.


408
00:22:22,746 --> 00:22:26,906
So we can take the output of
one query and make it the input


409
00:22:26,906 --> 00:22:29,556
of the next, just like you
would pipe commands together


410
00:22:29,556 --> 00:22:30,636
on a Unix command line.


411
00:22:31,396 --> 00:22:33,316
This is ver powerful,
and lets you build


412
00:22:33,316 --> 00:22:35,706
up very complex queries,
again in a way


413
00:22:35,706 --> 00:22:37,146
that is concise and expressive.


414
00:22:38,266 --> 00:22:41,496
So here we have our
application and I want


415
00:22:41,496 --> 00:22:43,496
to find just the
labels in the table.


416
00:22:43,996 --> 00:22:44,946
So I start with the app.


417
00:22:45,866 --> 00:22:46,996
And then I get the tables.


418
00:22:47,646 --> 00:22:50,016
And I ask for static
texts and I'm done.


419
00:22:50,166 --> 00:22:51,316
I have those three labels.


420
00:22:53,196 --> 00:22:56,656
So queries are sometimes
the end unto themselves.


421
00:22:56,656 --> 00:22:59,426
You want to get the count of
the query and maybe assert


422
00:22:59,426 --> 00:23:01,236
that you have the right
number of items in there.


423
00:23:01,586 --> 00:23:04,576
But often the goal of a
query is to find an element.


424
00:23:04,576 --> 00:23:06,886
All of our elements
are backed by a query.


425
00:23:07,346 --> 00:23:10,616
To get an element from a
query we provide several


426
00:23:10,616 --> 00:23:11,436
different choices.


427
00:23:11,756 --> 00:23:14,776
The first is subscripting,
which allows us to take a query


428
00:23:14,776 --> 00:23:17,326
and then subscript
using an identifier.


429
00:23:17,596 --> 00:23:19,176
That would give me
back an element


430
00:23:19,406 --> 00:23:20,576
which is the groceries label.


431
00:23:20,576 --> 00:23:23,826
It can also do this
with element and index.


432
00:23:24,076 --> 00:23:26,586
If I have a set, maybe
the rows in the table


433
00:23:26,586 --> 00:23:27,856
and I want to iterate over them.


434
00:23:27,856 --> 00:23:32,256
I could one at a time call
element and index on these.


435
00:23:32,256 --> 00:23:35,206
If I have a query which
I know resolves uniquely,


436
00:23:35,496 --> 00:23:38,546
hat is to a single thing, maybe
I only have one navigation bar


437
00:23:38,546 --> 00:23:41,346
in my application, I can
use the element property


438
00:23:41,626 --> 00:23:45,506
to create a new element
backed by that query.


439
00:23:46,666 --> 00:23:48,916
So when are queries evaluated?


440
00:23:49,546 --> 00:23:51,396
So they are not actually
evaluated just


441
00:23:51,396 --> 00:23:52,366
when you create them.


442
00:23:52,426 --> 00:23:54,936
They are evaluated on-demand
or as they are needed.


443
00:23:55,686 --> 00:23:59,786
This means that with an element,
the query will be evaluated


444
00:24:00,066 --> 00:24:04,206
when you synthesize events
or read property values.


445
00:24:04,206 --> 00:24:06,516
You can create the element
but until you use it,


446
00:24:06,516 --> 00:24:07,826
the query won't be evaluated.


447
00:24:08,536 --> 00:24:12,106
Similarly if you create a query
directly it will be evaluated


448
00:24:12,106 --> 00:24:15,216
when you get the number of
matches or if you call one


449
00:24:15,216 --> 00:24:16,986
of the APIs that
returns all the matches.


450
00:24:16,986 --> 00:24:19,236
It will have to be
evaluated at that point


451
00:24:20,266 --> 00:24:23,896
and we will reevaluate
queries when the UI changes.


452
00:24:24,216 --> 00:24:27,046
So you are always working
with the most current view


453
00:24:27,046 --> 00:24:30,306
of the application rather
than data from ten seconds ago


454
00:24:30,306 --> 00:24:32,336
or two minutes ago, depending
on the length of your test.


455
00:24:33,946 --> 00:24:36,466
So in this way you
can think of queries


456
00:24:36,466 --> 00:24:38,936
and elements being
somewhat similar to URLs.


457
00:24:39,636 --> 00:24:42,636
They are, with a URL
you can create a URL


458
00:24:42,636 --> 00:24:44,876
but it doesn't fetch a
resource immediately.


459
00:24:44,876 --> 00:24:48,386
It is not until you actually
go to create your URL request


460
00:24:48,386 --> 00:24:52,386
or session that the
actual URL gets resolved.


461
00:24:52,866 --> 00:24:55,216
And so even if the
URL was invalid,


462
00:24:55,406 --> 00:24:57,816
no error would be
raised until that point.


463
00:24:58,746 --> 00:25:03,406
Similarly, queries and elements,
they are just specifications


464
00:25:03,576 --> 00:25:06,136
for accessible elements
in the tested application.


465
00:25:06,876 --> 00:25:11,746
So creating them doesn't do
anything until you need them


466
00:25:11,866 --> 00:25:13,436
and at that point
they are resolved.


467
00:25:14,126 --> 00:25:16,706
So that's the API.


468
00:25:17,736 --> 00:25:20,376
There's three classes:
The application


469
00:25:20,376 --> 00:25:23,306
for launching your
application; elements,


470
00:25:23,736 --> 00:25:26,736
which like the application
are proxy objects for elements


471
00:25:26,736 --> 00:25:29,366
in your app; and
finally queries,


472
00:25:29,696 --> 00:25:32,586
which are more complex
ways to specify elements.


473
00:25:34,356 --> 00:25:36,036
So now I want to
talk a little bit


474
00:25:36,036 --> 00:25:37,936
about Accessibility
and UI testing.


475
00:25:38,396 --> 00:25:39,336
I mentioned earlier


476
00:25:39,646 --> 00:25:43,076
that accessibility data is
what makes UI testing possible.


477
00:25:44,596 --> 00:25:48,856
So given that, it is not
hard to see how the quality


478
00:25:49,116 --> 00:25:53,356
of the accessibility data
really impacts your testing.


479
00:25:53,706 --> 00:25:55,556
In fact, the better
the accessibility data


480
00:25:55,556 --> 00:25:58,316
for your application, the
easier it is to write tests


481
00:25:58,316 --> 00:26:01,506
and the more reliable
those tests are over time.


482
00:26:02,136 --> 00:26:05,296
So you get a double benefit


483
00:26:05,296 --> 00:26:07,236
when you improve
the accessibility


484
00:26:07,236 --> 00:26:08,156
in your application.


485
00:26:08,836 --> 00:26:11,086
You've not only made it
easier for your own testing


486
00:26:11,296 --> 00:26:13,376
but you've improved
the experience for all


487
00:26:13,376 --> 00:26:14,506
of our disabled users.


488
00:26:14,916 --> 00:26:17,786
I would really encourage you to
keep that in mind when you work


489
00:26:17,786 --> 00:26:19,346
with UI testing and
accessibility.


490
00:26:21,436 --> 00:26:23,316
Sometimes up's need
to do some debugging.


491
00:26:23,876 --> 00:26:27,536
It's an element may not be
accessible, may not be showing


492
00:26:27,536 --> 00:26:29,576
up for you even when
you are using recording.


493
00:26:30,456 --> 00:26:32,886
That could be because of
the custom view subclass


494
00:26:32,956 --> 00:26:34,816
that may not be accessible
by default.


495
00:26:35,526 --> 00:26:38,076
Or it's actually not a view.


496
00:26:38,256 --> 00:26:41,526
It's a graphics object in a
lower level graphics subsystem


497
00:26:41,526 --> 00:26:43,576
such as a layer and
that sort of thing.


498
00:26:44,686 --> 00:26:46,636
In other cases, the
element is visible


499
00:26:46,636 --> 00:26:49,026
but has poor accessibility data.


500
00:26:49,356 --> 00:26:50,976
All those table cells
I was looking


501
00:26:51,076 --> 00:26:54,756
at in the containment query,
partly that might have gone away


502
00:26:54,756 --> 00:26:57,356
if the cells themselves had
better accessibility data.


503
00:26:58,476 --> 00:27:00,816
When this happens, there's
a couple tools I would point


504
00:27:00,816 --> 00:27:01,106
you at.


505
00:27:01,396 --> 00:27:04,006
The first of which is
UI recording itself


506
00:27:04,286 --> 00:27:06,796
because UI recording will
give you the closest view


507
00:27:07,106 --> 00:27:09,986
into how the testing
system sees the elements.


508
00:27:10,416 --> 00:27:13,366
But beyond that there's also
great accessibility inspectors


509
00:27:13,366 --> 00:27:14,126
on our platform.


510
00:27:14,426 --> 00:27:17,156
They'll let you see the
raw accessibility data


511
00:27:17,456 --> 00:27:19,456
as it is exposed
by the application.


512
00:27:20,046 --> 00:27:23,576
When you need to go
and improve that data,


513
00:27:24,066 --> 00:27:25,996
your first stop should
be Interface Builder.


514
00:27:26,606 --> 00:27:31,076
Interface Builder has a
great accessibility inspector


515
00:27:31,506 --> 00:27:34,106
which allows you to enable
or disable accessibility,


516
00:27:34,366 --> 00:27:37,116
set values for the various
accessibility attributes,


517
00:27:37,526 --> 00:27:40,226
and configure the traits
which have a direct impact


518
00:27:40,286 --> 00:27:43,366
on how the element is expressed
as a type in UI testing.


519
00:27:45,126 --> 00:27:47,466
There's also API if you're
working with elements


520
00:27:47,506 --> 00:27:50,316
that you can't access
through Interface Builder.


521
00:27:50,896 --> 00:27:53,676
You can use APIs
in NSAccessibility


522
00:27:53,736 --> 00:27:57,956
and UIAccessibility to directly
control how the element is


523
00:27:57,956 --> 00:27:59,246
expressed to Accessibility.


524
00:27:59,886 --> 00:28:04,386
So with that in mind,
let's see another demo.


525
00:28:04,856 --> 00:28:05,976
This time Brooke
is going to take us


526
00:28:05,976 --> 00:28:09,456
through more complex test
cases and also a little bit


527
00:28:09,456 --> 00:28:10,656
of accessibility debugging.


528
00:28:11,166 --> 00:28:11,296
Brooke?


529
00:28:11,296 --> 00:28:11,556
>> BROOKE CALLAHAN: Thanks, Wil.


530
00:28:12,516 --> 00:28:19,396
[Applause]


531
00:28:19,896 --> 00:28:22,236
>> BROOKE CALLAHAN: So in the
last demo we saw adding a test


532
00:28:22,236 --> 00:28:27,066
that can add and remove
an item from the list.


533
00:28:27,596 --> 00:28:30,506
So while I'm here I would
like to add some more tests


534
00:28:30,506 --> 00:28:32,006
around this area
of user interface.


535
00:28:32,406 --> 00:28:33,586
First I'm going to add a test


536
00:28:34,106 --> 00:28:37,846
that adds multiple
items to the same list.


537
00:28:38,316 --> 00:28:41,876
With this multiple items
with the same name to a list.


538
00:28:42,586 --> 00:28:45,646
So to do that I'm going
to copy this code here


539
00:28:45,646 --> 00:28:46,536
from the last test.


540
00:28:47,056 --> 00:28:51,926
And I'll call this new
test, add to cookies.


541
00:28:53,036 --> 00:28:54,116
I'll just paste that code in.


542
00:28:55,306 --> 00:28:59,736
Great. Now I have a test
that is going to tap


543
00:28:59,736 --> 00:29:01,746
on the groceries label.


544
00:29:02,456 --> 00:29:05,356
Next it is going to add the
new cookies item to the list,


545
00:29:05,756 --> 00:29:08,656
and then it is going to
tap on that cookies button


546
00:29:08,656 --> 00:29:12,146
in that item, and verify
that it actually gets


547
00:29:12,146 --> 00:29:14,256
to that tapped state.


548
00:29:15,126 --> 00:29:16,976
So to add the second
item I'm just going


549
00:29:16,976 --> 00:29:17,856
to copy this code here.


550
00:29:17,856 --> 00:29:23,816
And then to verify that the new
button exists and gets tapped,


551
00:29:24,586 --> 00:29:26,126
I'm going to copy that section.


552
00:29:26,676 --> 00:29:34,406
So let's run this test
and see how that works.


553
00:29:34,606 --> 00:29:35,836
Now let's add the first one.


554
00:29:37,116 --> 00:29:37,626
Second one.


555
00:29:38,786 --> 00:29:40,546
Ahh, failed an assertion here.


556
00:29:40,906 --> 00:29:44,566
So on this line here, where
we are getting the value


557
00:29:44,766 --> 00:29:47,986
of the cookies button for
the second time around,


558
00:29:48,636 --> 00:29:49,996
we are actually failing
the assertion.


559
00:29:50,426 --> 00:29:52,586
Looks like it's failing because
multiple matches are found.


560
00:29:53,036 --> 00:29:55,206
I think I have an idea
of what went wrong here.


561
00:29:56,546 --> 00:30:00,246
The way that the cookies
button constant is specified,


562
00:30:00,246 --> 00:30:02,646
it is just looking for all
the buttons in the table,


563
00:30:02,736 --> 00:30:05,726
and giving me one
that's called cookies.


564
00:30:06,206 --> 00:30:07,796
By this point in the test,


565
00:30:07,796 --> 00:30:11,226
there are two buttons
called cookies in the table.


566
00:30:11,226 --> 00:30:15,136
It will find both of them
and there is not going


567
00:30:15,136 --> 00:30:17,946
to be one value that
the element can return


568
00:30:17,946 --> 00:30:19,266
because there's these
two matches.


569
00:30:20,236 --> 00:30:23,256
Now, I only know that because
I just saw the test running.


570
00:30:23,686 --> 00:30:27,346
Normally you are not going to be
watching your test as it runs.


571
00:30:28,356 --> 00:30:30,926
So we thought we should
provide a way for you


572
00:30:30,926 --> 00:30:33,956
to see what the test looks
like when it last ran


573
00:30:34,816 --> 00:30:38,126
and we've added this information
to the test reports in Xcode.


574
00:30:39,596 --> 00:30:42,456
So if I go to the report
navigator and click


575
00:30:42,456 --> 00:30:43,686
on the most recent test report,


576
00:30:44,066 --> 00:30:47,366
you can see the test
add to cookies test.


577
00:30:48,336 --> 00:30:51,946
If I expand this item, you
can see all of the activities


578
00:30:51,946 --> 00:30:53,376
that happen during the test.


579
00:30:54,216 --> 00:30:57,056
And down here I see this last
find the cookies button item.


580
00:30:57,326 --> 00:30:58,066
There's my failure.


581
00:30:58,066 --> 00:30:59,156
Multiple matches found.


582
00:30:59,896 --> 00:31:03,626
There's also a quick look button
here, where I can look on that


583
00:31:03,626 --> 00:31:05,746
and it will show
me the exact state


584
00:31:05,746 --> 00:31:07,246
of the application
when that happened.


585
00:31:07,246 --> 00:31:09,516
Just like we know
happened, yeah,


586
00:31:09,516 --> 00:31:10,946
there's two rows called cookies.


587
00:31:11,516 --> 00:31:13,596
One of them is tapped and
one of them is not tapped.


588
00:31:14,516 --> 00:31:18,936
[Applause]


589
00:31:19,436 --> 00:31:21,876
>> BROOKE CALLAHAN: I am going
to close that and if I want


590
00:31:21,876 --> 00:31:23,506
to see the complete
assertion failure,


591
00:31:23,506 --> 00:31:25,426
I can go to the log section


592
00:31:26,506 --> 00:31:32,396
and on this line I can
expand the log for that test.


593
00:31:32,566 --> 00:31:37,326
And here we can see the complete
assertion failure showing the


594
00:31:37,326 --> 00:31:40,176
accessibility hierarchy
of both those buttons.


595
00:31:40,776 --> 00:31:44,366
And here on the side I can see
that yeah, there's one button


596
00:31:44,366 --> 00:31:46,686
that is unchecked and
the other one is checked,


597
00:31:47,666 --> 00:31:49,186
just like I expect.


598
00:31:49,996 --> 00:31:51,436
Let's go back and fix that test.


599
00:31:52,626 --> 00:31:55,656
The easiest way for
me to fix this test is


600
00:31:55,656 --> 00:31:56,556
to use recording again.


601
00:31:57,096 --> 00:31:59,576
I'll set a breakpoint on this
line right before the assertion


602
00:31:59,576 --> 00:32:11,096
failure, and run the
test at that point.


603
00:32:11,316 --> 00:32:11,586
All right.


604
00:32:11,656 --> 00:32:14,846
So now I've got the application
in exactly the state I need it


605
00:32:14,846 --> 00:32:18,176
to be to get the value
of that unchecked button.


606
00:32:18,326 --> 00:32:20,906
All I'm going to do is I'm
going to click on recording,


607
00:32:20,906 --> 00:32:25,466
tap on that button,
and stop recording.


608
00:32:26,506 --> 00:32:29,416
Now I have a way to refer
to that second button.


609
00:32:30,206 --> 00:32:30,806
I'm going to clean this


610
00:32:30,806 --> 00:32:33,446
up by using the table
constant in both.


611
00:32:33,446 --> 00:32:36,696
I'm going to call this
cookies button two,


612
00:32:36,806 --> 00:32:38,866
a new constant in my test.


613
00:32:45,306 --> 00:32:47,856
And now to fix the test
I'm going to change each


614
00:32:47,856 --> 00:32:49,656
of the next three lines
to use that new reference.


615
00:32:53,476 --> 00:32:56,036
And when I run the test again,
we should see that it works.


616
00:33:06,896 --> 00:33:07,156
Great!


617
00:33:08,516 --> 00:33:13,156
[Applause]


618
00:33:13,656 --> 00:33:13,916
All right.


619
00:33:14,246 --> 00:33:16,636
Now I've got one test that
can add and remove an item


620
00:33:16,636 --> 00:33:18,816
from the list and another
test that can add two items


621
00:33:18,816 --> 00:33:21,456
to the same list, and
verify they both exist.


622
00:33:21,456 --> 00:33:23,226
Now I want to build a test


623
00:33:23,506 --> 00:33:26,296
that will remove all
the items from the list.


624
00:33:26,896 --> 00:33:30,856
Once again I'm going
to use recording.


625
00:33:30,856 --> 00:33:39,516
I am going to tap on groceries,
edit, and then I'm going


626
00:33:39,516 --> 00:33:45,586
to remove the apples
row from the test.


627
00:33:45,756 --> 00:33:46,036
All right?


628
00:33:46,126 --> 00:33:47,256
I'll tap stop recording.


629
00:33:48,026 --> 00:33:53,086
So all this much of the test
is pretty much how I want,


630
00:33:53,646 --> 00:33:57,766
but what I want to do is, I
want to make my test agnostic


631
00:33:57,766 --> 00:33:59,166
to the data of the application.


632
00:33:59,436 --> 00:34:01,766
I want it to remove all these
items, but I don't want it


633
00:34:01,766 --> 00:34:05,246
to actually refer to the
items by their labels.


634
00:34:06,486 --> 00:34:08,286
Because that is going to
get kind of wordy here.


635
00:34:08,716 --> 00:34:14,585
So first thing I'm going to
do, you see these tokens here,


636
00:34:14,585 --> 00:34:20,565
the tokens provide multiple ways
to get to the same UI element.


637
00:34:20,565 --> 00:34:23,846
In this case, for that
first delete apples button,


638
00:34:23,846 --> 00:34:27,815
I can get to this by calling
table.button delete apples.


639
00:34:28,016 --> 00:34:34,056
I can be more specific and say
it's the delete apples button


640
00:34:34,565 --> 00:34:35,676
in the cell called apples.


641
00:34:35,716 --> 00:34:38,146
So I'm going to use that.


642
00:34:38,146 --> 00:34:45,136
And I'm going to double click
on it to convert it to text.


643
00:34:45,136 --> 00:34:48,516
So now I've got two rows here


644
00:34:48,596 --> 00:34:50,985
where we are getting the
elements the same way.


645
00:34:51,275 --> 00:34:55,156
What I would like to do is
get the cell simply by index.


646
00:34:55,156 --> 00:35:00,116
I will add a constant called let
cell, table., and set this equal


647
00:35:00,436 --> 00:35:03,456
to table.cells elements index.


648
00:35:03,926 --> 00:35:09,126
Since the apples row was index
one, I'm going to use that.


649
00:35:09,506 --> 00:35:17,406
I can simply replace these with
the reference to that constant.


650
00:35:17,406 --> 00:35:17,586
All right.


651
00:35:17,586 --> 00:35:18,406
I'm almost done.


652
00:35:19,536 --> 00:35:22,486
The next part I need to change
here is how I'm getting the


653
00:35:22,486 --> 00:35:25,836
button out of the cell because
the other rows are not going


654
00:35:25,986 --> 00:35:27,296
to have a delete apples button.


655
00:35:27,296 --> 00:35:29,906
They will have a delete
oranges button or delete bread.


656
00:35:30,276 --> 00:35:33,306
What I need is a way
to find the button


657
00:35:33,846 --> 00:35:35,946
where the label starts
with the word delete.


658
00:35:36,626 --> 00:35:41,806
To do that I'm going
to use a predicate.


659
00:35:41,886 --> 00:35:45,706
So here I'm using
matching predicate


660
00:35:45,836 --> 00:35:49,506
to find the button whose label
begins with the word delete.


661
00:35:49,506 --> 00:35:50,226
All right.


662
00:35:51,096 --> 00:35:54,866
So the last thing I
need to change here,


663
00:35:54,986 --> 00:35:56,776
I want to add an
assertion just like before.


664
00:35:56,836 --> 00:35:59,106
I want to verify that
that cell goes away


665
00:35:59,106 --> 00:36:00,566
after we've removed it.


666
00:36:00,566 --> 00:36:02,656
I am going to use
XCTAssertEqual,


667
00:36:02,656 --> 00:36:06,676
and assert that the cells
exist property returns false


668
00:36:06,676 --> 00:36:09,136
after we tap that delete
confirmation button.


669
00:36:09,136 --> 00:36:11,756
I'm going to run the test now.


670
00:36:12,436 --> 00:36:26,176
It is removing the apples
row but failed the assertion.


671
00:36:26,736 --> 00:36:28,886
I have an idea what
might be going on here.


672
00:36:30,456 --> 00:36:33,506
To show you what is going
on I'll use the debugger.


673
00:36:33,606 --> 00:36:36,216
I'll set a breakpoint here
and run the test again,


674
00:36:36,256 --> 00:36:44,946
to that same breakpoint.


675
00:36:45,296 --> 00:36:45,596
All right.


676
00:36:45,656 --> 00:36:48,876
Now in the debugger, I'm going


677
00:36:48,876 --> 00:36:50,636
to call debug description
on the cell.


678
00:36:58,556 --> 00:37:01,826
So the debug description
has a lot of information


679
00:37:01,826 --> 00:37:03,906
about how the cell
is actually resolved.


680
00:37:04,376 --> 00:37:07,116
So I can see here
that when I call it,


681
00:37:07,886 --> 00:37:10,646
this cell result first
finds the application


682
00:37:12,776 --> 00:37:16,046
and then it finds the
table in the application.


683
00:37:17,296 --> 00:37:18,306
Then all the cells.


684
00:37:18,306 --> 00:37:21,946
And then the element and
index in those cells.


685
00:37:22,596 --> 00:37:24,816
I can see that it's actually
finding the oranges row.


686
00:37:25,966 --> 00:37:28,016
It looks like what might
be happening here is


687
00:37:29,196 --> 00:37:34,886
when we call the exist property
on this element called cell,


688
00:37:35,696 --> 00:37:37,526
it is actually re-resolving
itself.


689
00:37:37,866 --> 00:37:41,096
Even though we just
removed the apples row


690
00:37:41,096 --> 00:37:45,926
from the table there's now
a new cell at index one.


691
00:37:46,836 --> 00:37:49,026
So that is no problem.


692
00:37:50,286 --> 00:37:52,986
It just means I need to
use a different way to find


693
00:37:53,156 --> 00:37:55,456
out whether or not
we've removed the row.


694
00:37:56,026 --> 00:37:57,996
So I'm going to add
an assertion,


695
00:37:58,026 --> 00:37:59,936
assert that the number of cells


696
00:38:00,156 --> 00:38:03,396
in the table goes
down at this point.


697
00:38:03,396 --> 00:38:05,886
So I'm going to add a new
constant called "count"


698
00:38:06,466 --> 00:38:11,576
and I'll set this equal to the
count of the cells in the table.


699
00:38:12,126 --> 00:38:18,356
And then I'll simply assert that
that's equal to count minus 1.


700
00:38:18,356 --> 00:38:22,626
Now, the last thing I need
to do, I said this was going


701
00:38:22,626 --> 00:38:24,346
to be a remove all items test.


702
00:38:24,346 --> 00:38:31,076
I'm going to change it to add
a wild loop and simply do this


703
00:38:31,076 --> 00:38:33,196
over and over again as
long as there's more


704
00:38:33,196 --> 00:38:39,016
than one cell in the table.


705
00:38:39,186 --> 00:38:40,366
Let's run that.


706
00:38:43,576 --> 00:38:49,426
So it's removing the
apples row, and oranges.


707
00:38:55,556 --> 00:38:56,256
All right.


708
00:38:57,516 --> 00:39:04,096
[Applause]


709
00:39:04,596 --> 00:39:07,676
>> BROOKE CALLAHAN: Last thing
I would like to do is add a test


710
00:39:07,816 --> 00:39:10,626
to use that color row that
we saw in the edit UI.


711
00:39:15,216 --> 00:39:20,666
And once again I'm going to
use the recorder for this.


712
00:39:21,386 --> 00:39:23,526
I'll tap on groceries and edit.


713
00:39:24,066 --> 00:39:29,586
Now, the color UI here lets me
change the color for a list.


714
00:39:29,866 --> 00:39:31,316
It looks like right
now this list is green.


715
00:39:31,906 --> 00:39:35,726
So I'll try changing it
to red or how about blue?


716
00:39:37,776 --> 00:39:40,006
Okay, so when I tap on
those buttons it looks


717
00:39:40,006 --> 00:39:42,806
like it's not actually
recording what I want.


718
00:39:42,806 --> 00:39:44,946
It looks like it's
recording a tap


719
00:39:45,266 --> 00:39:47,826
on the static text called
color, which you see over here.


720
00:39:48,566 --> 00:39:51,906
So I think what might
be going on here is


721
00:39:51,906 --> 00:39:54,196
that these UI elements
simply might not be visible


722
00:39:54,196 --> 00:39:54,956
to Accessibility.


723
00:39:54,956 --> 00:39:56,976
So I'm going to stop recording,


724
00:39:56,976 --> 00:40:01,696
and I can actually use the
accessibility inspector


725
00:40:01,696 --> 00:40:02,616
to tell me what's going on.


726
00:40:03,176 --> 00:40:05,706
I'll right click on Xcode and
go to open developer tool,


727
00:40:05,736 --> 00:40:06,836
accessibility inspector.


728
00:40:08,326 --> 00:40:11,466
And the accessibility inspector
provides a lot of information,


729
00:40:11,466 --> 00:40:15,776
but all I want to use it for
is ths shortcut, command S7.


730
00:40:15,776 --> 00:40:18,716
It will highlight the UI
element that's underneath the


731
00:40:18,716 --> 00:40:19,226
mouse cursor.


732
00:40:19,796 --> 00:40:22,976
If I put the mouse cursor


733
00:40:22,976 --> 00:40:26,126
over the word bread here,
and press command F7.


734
00:40:26,126 --> 00:40:27,336
it highlights bread.


735
00:40:28,006 --> 00:40:31,416
If I put it over the
delete bread button,


736
00:40:31,776 --> 00:40:33,426
you can see that
it highlights that.


737
00:40:35,426 --> 00:40:37,976
Now, let's see what happens
if I put the mouse cursor


738
00:40:37,976 --> 00:40:42,136
over this yellow color button.


739
00:40:42,276 --> 00:40:44,236
Aha! So it highlighted
the whole row.


740
00:40:44,236 --> 00:40:46,916
So that pretty much confirms


741
00:40:46,916 --> 00:40:49,656
that this UI element is simply
not visible to accessibility.


742
00:40:51,096 --> 00:40:52,466
Luckily I can actually
change this,


743
00:40:52,816 --> 00:40:55,306
and fix this problem
using the story board.


744
00:40:55,306 --> 00:41:05,316
I'll open the story board now.


745
00:41:05,546 --> 00:41:07,866
So here I've got the same
buttons in my story board


746
00:41:09,696 --> 00:41:12,856
and if I open the
inspector, here I can see


747
00:41:12,856 --> 00:41:17,986
that these buttons actually have
a class of color tappable view.


748
00:41:18,276 --> 00:41:19,976
I'm familiar with this class.


749
00:41:19,976 --> 00:41:22,506
I know it's actually
not UI button.


750
00:41:23,116 --> 00:41:24,436
It's custom view.


751
00:41:24,436 --> 00:41:26,566
If I go down to the
accessibility part


752
00:41:26,706 --> 00:41:30,296
of the inspector, I can see
it's not enabled for them.


753
00:41:30,296 --> 00:41:33,626
I have gone through and
added labels for them.


754
00:41:34,276 --> 00:41:37,806
To fix this all I need to do
is select all of the buttons.


755
00:41:37,806 --> 00:41:45,346
And then I'll check the enabled
for accessibility check box.


756
00:41:45,616 --> 00:41:46,816
Since they behave like buttons,


757
00:41:46,816 --> 00:41:48,006
I am going to give
these the button trait.


758
00:41:48,546 --> 00:41:48,706
All right?


759
00:41:51,336 --> 00:41:54,166
Now let's run the
application again.


760
00:42:02,266 --> 00:42:05,806
And now I'm going to record
this test one more time.


761
00:42:06,086 --> 00:42:08,626
Tap on groceries and edit.


762
00:42:09,486 --> 00:42:12,516
Then red. And orange.


763
00:42:12,806 --> 00:42:16,946
Yellow, green, blue, and gray.


764
00:42:17,196 --> 00:42:21,486
Great. Now it actually
recorded all those.


765
00:42:21,646 --> 00:42:23,966
I'll stop recording and
let's run it and see


766
00:42:23,966 --> 00:42:32,996
if it can play it back as well.


767
00:42:32,996 --> 00:42:35,946
Great. I've fixed
accessibility in my application.


768
00:42:36,666 --> 00:42:38,276
And I've also made
it more testable.


769
00:42:38,596 --> 00:42:40,326
If I was going to
complete this test,


770
00:42:41,456 --> 00:42:43,886
I would probably add
some assertions to verify


771
00:42:43,886 --> 00:42:45,246
that the state of
these buttons changes.


772
00:42:45,466 --> 00:42:46,716
For now, I'll hand
the stage back to Wil.


773
00:42:47,516 --> 00:42:53,426
[Applause]


774
00:42:53,926 --> 00:42:55,366
>> WIL TURNER: So that's
really quite awesome,


775
00:42:55,486 --> 00:42:58,916
especially just how easy
it was to make this view


776
00:42:58,916 --> 00:43:01,356
that previously a Voice Over
user would have had no luck


777
00:43:01,356 --> 00:43:04,876
with at all and just
with a few quick changes


778
00:43:04,876 --> 00:43:07,186
in interface builder
Brooke was able to make


779
00:43:07,216 --> 00:43:09,656
that both accessible
and UI testable.


780
00:43:10,266 --> 00:43:15,186
So in the demo, some sort
of more advanced UI testing.


781
00:43:15,186 --> 00:43:17,786
You saw he had cases where
he dealt with a conflict


782
00:43:17,786 --> 00:43:20,906
and a query, and how to
correct those queries,


783
00:43:20,906 --> 00:43:25,296
and how to debug it, and also
how he can loop over elements


784
00:43:25,736 --> 00:43:28,826
and validate them, and how you
can use the exists property


785
00:43:28,826 --> 00:43:32,456
and also highlighted how
queries are reevaluated.


786
00:43:32,696 --> 00:43:35,946
They use the criteria that
you created them with.


787
00:43:35,996 --> 00:43:39,256
That specification is
what gets reevaluated.


788
00:43:39,686 --> 00:43:41,976
We used element at index one.


789
00:43:41,976 --> 00:43:45,056
That pointed to the apples
label the first time through.


790
00:43:45,276 --> 00:43:47,436
As soon as that was
gone and the UI changed,


791
00:43:47,606 --> 00:43:50,866
now that was pointing to the
oranges label.And then finally,


792
00:43:51,576 --> 00:43:52,766
how to improve accessibility,


793
00:43:53,016 --> 00:43:57,526
and the rewards are truly
fantastic for doing that.


794
00:43:58,256 --> 00:44:01,116
Brooke also gave you a
peek at the test reports.


795
00:44:01,116 --> 00:44:03,826
We have done some
work in Xcode 7


796
00:44:03,906 --> 00:44:07,366
to overhaul them for UI testing.


797
00:44:07,716 --> 00:44:11,096
To recap are, the test reports
are where you see the results


798
00:44:11,096 --> 00:44:12,376
for all the tests that ran.


799
00:44:12,956 --> 00:44:16,336
It shows the pass or the
fail, the failure message,


800
00:44:16,976 --> 00:44:18,266
performance metrics


801
00:44:18,266 --> 00:44:20,296
for performance tests
are shown in the reports.


802
00:44:21,056 --> 00:44:24,236
You get the same UI in
XCode and in Xcode server.


803
00:44:24,366 --> 00:44:26,416
It's a consistent
experience regardless


804
00:44:26,416 --> 00:44:28,946
of whether you are looking
at integrations or the run


805
00:44:28,946 --> 00:44:30,576
that you just did on
your local computer.


806
00:44:31,426 --> 00:44:34,016
On Xcode server you also
get per-device results,


807
00:44:34,016 --> 00:44:36,886
because you can have the devices
integrating multiple devices


808
00:44:36,886 --> 00:44:37,696
at the same time.


809
00:44:38,466 --> 00:44:41,116
The additions for UI testing,


810
00:44:41,536 --> 00:44:43,836
we collected additional
data during UI testing,


811
00:44:43,836 --> 00:44:45,666
and this includes screen shots.


812
00:44:46,316 --> 00:44:50,366
You saw how it helped Brooke
debug the conflict in his query


813
00:44:50,366 --> 00:44:53,066
by pulling up the screen shot
at the time that query failed.


814
00:44:54,096 --> 00:44:59,126
Also, we organized the API calls
into these nested activities


815
00:44:59,126 --> 00:45:02,126
that help you understand
how the API call is working.


816
00:45:02,766 --> 00:45:04,636
So let's take a look
at an example of this.


817
00:45:04,986 --> 00:45:06,336
This is not the list draft.


818
00:45:06,336 --> 00:45:07,456
It is a different application.


819
00:45:07,876 --> 00:45:11,106
But I'm going to show you
how there are several steps


820
00:45:11,106 --> 00:45:12,876
in the nested activities
breakdown.


821
00:45:13,596 --> 00:45:15,806
This example we're
typing into a test field


822
00:45:15,806 --> 00:45:18,876
so the high level you
call the API type test.


823
00:45:19,686 --> 00:45:21,206
But internally that breaks down.


824
00:45:21,616 --> 00:45:24,246
In the first step where we wait
for the application to idle.


825
00:45:24,626 --> 00:45:27,136
We're actually observing
the main run loop


826
00:45:27,446 --> 00:45:28,776
of the tested application.


827
00:45:29,126 --> 00:45:31,276
Because We don't want
to send events to it,


828
00:45:31,616 --> 00:45:33,026
when it's busy processing.


829
00:45:33,026 --> 00:45:34,996
We want it to be
responsive as possible.


830
00:45:35,726 --> 00:45:41,186
Once it's idled we capture the
data we need from Accessibility


831
00:45:41,586 --> 00:45:42,846
and we resolve the query,


832
00:45:42,846 --> 00:45:45,066
make sure it matches
exactly one thing.


833
00:45:46,166 --> 00:45:48,616
Next step, we synthesize
the actual events


834
00:45:48,716 --> 00:45:50,646
that insert the text
into that field.


835
00:45:51,616 --> 00:45:55,086
Finally, we wait one more time
for the app to idle afterwards.


836
00:45:55,166 --> 00:45:58,226
Because, again, we want to
hand off control in a way


837
00:45:58,226 --> 00:46:01,446
where things are reliable
and deterministic.


838
00:46:01,976 --> 00:46:05,586
The quick looks are
provided for screen shots


839
00:46:05,586 --> 00:46:07,586
that are captured
during critical steps.


840
00:46:07,976 --> 00:46:11,476
You can see here is the state
right after I type that text in.


841
00:46:11,736 --> 00:46:14,326
Make sure everything looked
just the way you expected.


842
00:46:15,196 --> 00:46:19,986
So UI testing is obviously
a huge expansion of the kind


843
00:46:19,986 --> 00:46:22,056
of testing you can do
for your applications.


844
00:46:22,436 --> 00:46:24,046
So when do you use it, right?


845
00:46:24,466 --> 00:46:26,736
We've got unit testing already.


846
00:46:27,116 --> 00:46:30,166
UI testing is a complement to
UI testing, not a replacement.


847
00:46:30,556 --> 00:46:33,536
You should continue to use unit
testing for your model objects,


848
00:46:33,536 --> 00:46:35,196
and your controller logic,


849
00:46:35,536 --> 00:46:38,476
because unit testing will more
precisely pinpoint failures


850
00:46:38,476 --> 00:46:39,506
when they happen in your code.


851
00:46:40,196 --> 00:46:43,446
UI testing allows you to
cover much broader ranges


852
00:46:43,446 --> 00:46:45,726
of functionality, but tracking


853
00:46:45,726 --> 00:46:47,346
down the failures can
be more challenging.


854
00:46:47,736 --> 00:46:51,156
It's a balance in your project,
of finding the right blend


855
00:46:51,186 --> 00:46:53,106
between unit testing
and UI testing.


856
00:46:54,796 --> 00:46:56,726
Some great candidates
for UI testing.


857
00:46:57,216 --> 00:46:58,136
Well, think about your app.


858
00:46:58,186 --> 00:47:00,306
You have customers,
you show it to them,


859
00:47:00,306 --> 00:47:02,826
and you have little demo
sequences that you show to them,


860
00:47:02,826 --> 00:47:03,776
and you walk them
through, "well,


861
00:47:03,776 --> 00:47:05,006
here's how you do
this with the app."


862
00:47:05,506 --> 00:47:08,656
Demo sequences are great
candidates for UI testing.


863
00:47:08,656 --> 00:47:11,926
You'll know nightly
build after nightly build


864
00:47:12,256 --> 00:47:13,746
that those demos are
going to work for you.


865
00:47:14,636 --> 00:47:17,056
Second, beyond that,
common workflows.


866
00:47:17,646 --> 00:47:20,986
What the app is used for,
if it's an editing app,


867
00:47:21,066 --> 00:47:22,426
how you edit the documents.


868
00:47:22,426 --> 00:47:25,916
Any custom views you
have in the application.


869
00:47:26,526 --> 00:47:29,456
And finally document-based
workflows, opening and saving.


870
00:47:29,756 --> 00:47:31,116
These are all great
things to automate.


871
00:47:31,116 --> 00:47:33,596
They are really hard to
capture with unit testing.


872
00:47:33,976 --> 00:47:36,646
When they go wrong they
have a huge impact on users.


873
00:47:38,756 --> 00:47:40,496
So UI testing.


874
00:47:41,576 --> 00:47:42,706
New in XCode 7.


875
00:47:43,776 --> 00:47:45,606
Opens up a world
of possibilities


876
00:47:45,606 --> 00:47:47,796
for how you can test
your applications.


877
00:47:49,266 --> 00:47:51,916
In UI testing you
find and interact


878
00:47:52,146 --> 00:47:55,256
with user interface elements
and you synthesize events


879
00:47:55,296 --> 00:47:57,996
that drives them, just
the way a user does.


880
00:47:58,986 --> 00:48:01,646
You can validate the UI
properties and state.


881
00:48:03,126 --> 00:48:06,616
And UI recording lets you
create these tests super quick,


882
00:48:06,856 --> 00:48:07,646
super easy.


883
00:48:09,196 --> 00:48:11,586
Finally, we've overhauled
the test reports


884
00:48:12,066 --> 00:48:15,566
to make you better able to
understand how your tests work


885
00:48:16,066 --> 00:48:17,666
and collect additional
data about them.


886
00:48:18,666 --> 00:48:19,446
So that's UI testing.


887
00:48:20,516 --> 00:48:27,916
[Applause]


888
00:48:28,416 --> 00:48:30,726
>> WIL TURNER: So for more
information we've got great


889
00:48:30,726 --> 00:48:32,026
documentation on XCTest.


890
00:48:32,236 --> 00:48:35,226
You can get to it through Xcode
itself and on our website.


891
00:48:35,556 --> 00:48:37,866
And Accessibility also
has great documentation,


892
00:48:37,866 --> 00:48:39,056
and I encourage you
to check out.


893
00:48:40,516 --> 00:48:43,286
Developer Forums are great
places to raise questions


894
00:48:43,286 --> 00:48:47,226
and trade tips with other users
about how you're using things.


895
00:48:47,406 --> 00:48:50,346
Our evangelist Stefan
Lesser is a great contact


896
00:48:50,566 --> 00:48:51,506
to get you started.


897
00:48:52,736 --> 00:48:55,546
There's some related sessions
if you want to dial back in time


898
00:48:55,546 --> 00:48:58,036
and watch the accessibility
session from yesterday morning,


899
00:48:58,456 --> 00:49:00,396
probably watch the video
on your lunch if you want,


900
00:49:01,056 --> 00:49:04,466
and continuous integration and
code coverage, new technology


901
00:49:04,796 --> 00:49:07,946
in Xcode server, you can
see tomorrow afternoon --


902
00:49:07,946 --> 00:49:08,706
tomorrow morning.


903
00:49:09,096 --> 00:49:09,976
Have great conference,
everybody.


904
00:49:10,516 --> 00:49:13,500
[Applause]

