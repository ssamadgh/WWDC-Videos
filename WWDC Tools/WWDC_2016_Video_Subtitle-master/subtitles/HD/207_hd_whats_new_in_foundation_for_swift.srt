1
00:00:07,516 --> 00:00:19,500
[ Music ]


2
00:00:27,516 --> 00:00:31,756
[ Applause ]


3
00:00:32,256 --> 00:00:32,496
>> Thank you.


4
00:00:34,746 --> 00:00:35,416
Hello, and welcome.


5
00:00:35,936 --> 00:00:36,936
My name is Tony Parker.


6
00:00:36,936 --> 00:00:38,666
I am the manager of the
Foundation team at Apple,


7
00:00:38,816 --> 00:00:40,956
and I'm here with my
colleague Michael LeHew to talk


8
00:00:40,956 --> 00:00:42,836
about what's new in
Foundation for Swift.


9
00:00:44,636 --> 00:00:46,846
This year the Foundation
team has put a lot of effort


10
00:00:46,846 --> 00:00:49,096
into improving the way
that you use the Cocoa


11
00:00:49,096 --> 00:00:51,186
and Cocoa Touch APIs in Swift.


12
00:00:51,856 --> 00:00:54,326
We started by working on the
Swift API Design Guidelines.


13
00:00:55,106 --> 00:00:57,546
After that, we looked at how
all of the Objective-C code


14
00:00:57,546 --> 00:01:01,316
that the Cocoa SDK uses and your
own code is imported into Swift,


15
00:01:02,536 --> 00:01:04,066
but we knew that we
could go further.


16
00:01:04,236 --> 00:01:06,926
So, we have introduced a
brand new set of value types


17
00:01:06,926 --> 00:01:09,686
in Foundation, and
along with that a ton


18
00:01:09,686 --> 00:01:12,316
of new Swift-specific API.


19
00:01:13,056 --> 00:01:15,196
So, let's go ahead and jump
into design guidelines.


20
00:01:17,186 --> 00:01:19,316
Now, this year we're
working on Swift 3, and yet,


21
00:01:19,516 --> 00:01:21,886
from the beginning our goals for
Swift have remained the same.


22
00:01:22,476 --> 00:01:25,856
We want you to write code that's
fast, safe, and expressive.


23
00:01:26,946 --> 00:01:28,876
We've built the libraries,
the standard library,


24
00:01:28,876 --> 00:01:30,726
and the language
around these core ideas.


25
00:01:30,726 --> 00:01:33,576
And many of you have also
internalized those same


26
00:01:33,576 --> 00:01:36,066
principals and built your
application around that.


27
00:01:36,886 --> 00:01:39,426
However, we all know that there
is another part to that story,


28
00:01:39,556 --> 00:01:41,006
and that it the Cocoa SDK.


29
00:01:41,956 --> 00:01:45,526
Your app depends on this just as
much, or maybe even more than,


30
00:01:45,526 --> 00:01:46,626
the Swift standard library.


31
00:01:47,086 --> 00:01:49,516
It needs to feel like it's
part of the same ecosystem.


32
00:01:50,486 --> 00:01:52,996
Because the SDK is a
critical part of that story


33
00:01:53,166 --> 00:01:56,186
about how we develop apps on our
platforms, it's really important


34
00:01:56,186 --> 00:01:59,026
that the language and the
libraries work together.


35
00:02:01,086 --> 00:02:03,826
So this year we focused on
this idea of expressiveness.


36
00:02:04,386 --> 00:02:05,826
When I say expressive,
I actually mean it


37
00:02:05,826 --> 00:02:06,626
in two different ways.


38
00:02:07,016 --> 00:02:10,256
First is your ability as app
authors to write Swift code


39
00:02:10,256 --> 00:02:13,596
that expresses your intent to
the compiler and the libraries,


40
00:02:14,206 --> 00:02:15,416
but it goes the other way too.


41
00:02:15,836 --> 00:02:18,096
The libraries need to be
able to express their intent,


42
00:02:18,246 --> 00:02:20,976
their design patterns and
their ideas about how best


43
00:02:20,976 --> 00:02:23,636
to use the API to
you as an app author.


44
00:02:25,596 --> 00:02:27,486
And so, while working
on the guidelines,


45
00:02:27,486 --> 00:02:29,966
we focused on this idea of
a consistent experience.


46
00:02:30,316 --> 00:02:32,916
Every decision made about those
guidelines was done in support


47
00:02:32,916 --> 00:02:34,006
of the idea that the language


48
00:02:34,006 --> 00:02:35,386
and the libraries
don't stand alone.


49
00:02:35,566 --> 00:02:36,596
They have to work together.


50
00:02:37,266 --> 00:02:38,876
So, for example,
from the libraries,


51
00:02:39,226 --> 00:02:40,936
they bring a huge
number of features.


52
00:02:41,336 --> 00:02:43,166
Many of the features that
you see in the new versions


53
00:02:43,166 --> 00:02:45,846
of our platforms this year
are based on new features


54
00:02:45,846 --> 00:02:48,486
in the libraries that you
can also adopt in your apps


55
00:02:48,656 --> 00:02:50,286
to improve your experience.


56
00:02:51,176 --> 00:02:53,476
These libraries have a
widespread adoption across all


57
00:02:53,476 --> 00:02:56,736
of our platforms, including
this year new, Swift Auto ARC


58
00:02:56,736 --> 00:02:57,676
and Swift Open Source.


59
00:02:58,266 --> 00:03:00,186
So, we have Swift
core libs foundation


60
00:03:00,416 --> 00:03:02,836
which is bringing the
Foundation API, much of it,


61
00:03:03,136 --> 00:03:04,686
to other platforms like Linux.


62
00:03:05,846 --> 00:03:07,886
These libraries have a
battle-tested implementation.


63
00:03:08,486 --> 00:03:10,176
Many of them have been
around since the beginning


64
00:03:10,176 --> 00:03:12,646
of OS X or even further back.


65
00:03:13,576 --> 00:03:14,786
They also bring with them,


66
00:03:14,786 --> 00:03:16,346
thanks to the Cocoa
naming guidelines,


67
00:03:16,456 --> 00:03:17,976
a consistent set of conventions.


68
00:03:18,336 --> 00:03:20,286
This means that when you
see a new piece of API,


69
00:03:20,286 --> 00:03:22,326
you can understand how it works


70
00:03:22,326 --> 00:03:24,086
and what it does
almost immediately.


71
00:03:24,816 --> 00:03:27,076
And finally and importantly,
these libraries are


72
00:03:27,076 --> 00:03:29,036
under continuous and
active development.


73
00:03:29,466 --> 00:03:31,176
Not only are we adding
those new features,


74
00:03:31,446 --> 00:03:34,226
but we're making enhancements,
fixing bugs, and more,


75
00:03:34,226 --> 00:03:37,186
and we're going to continue
to do that every year


76
00:03:37,356 --> 00:03:38,316
as we release new OSs.


77
00:03:38,316 --> 00:03:42,576
Now, on the other hand,
the language, Swift,


78
00:03:42,726 --> 00:03:45,416
brings with it things that we
just didn't have in Objective-C.


79
00:03:45,806 --> 00:03:47,876
For example, first class
abort for generics,


80
00:03:48,536 --> 00:03:51,266
and built in support for
mutation, which is a key part


81
00:03:51,266 --> 00:03:52,646
of Swift's story about safety.


82
00:03:53,936 --> 00:03:55,806
There's also things like
protocol extensions,


83
00:03:55,806 --> 00:03:58,006
function overloading, and
default argument values,


84
00:03:58,476 --> 00:03:59,876
all of which make
a dramatic impact


85
00:03:59,876 --> 00:04:01,796
on how you design
your API in Swift.


86
00:04:03,096 --> 00:04:04,556
This isn't a complete
list on either side,


87
00:04:04,556 --> 00:04:05,726
by the way I just
ran out of space.


88
00:04:05,986 --> 00:04:07,166
There's plenty more
to go around.


89
00:04:07,846 --> 00:04:12,176
So, we came up with
three key documents.


90
00:04:12,666 --> 00:04:16,156
The first was SE-0023,
the API Design Guidelines.


91
00:04:16,216 --> 00:04:17,986
Now, all these documents
were sent


92
00:04:18,086 --> 00:04:21,106
to the Swift Evolution
mailing list, which gives you


93
00:04:21,106 --> 00:04:22,756
and the rest of the
Swift community a chance


94
00:04:22,756 --> 00:04:25,646
to participate in the design
and evolution of the language.


95
00:04:26,246 --> 00:04:29,376
Now, we see these guidelines as
a unifying document for current


96
00:04:29,376 --> 00:04:30,766
and future Swift libraries.


97
00:04:31,186 --> 00:04:32,846
Along with that we have SE-0006,


98
00:04:32,906 --> 00:04:35,426
which applied those design
guidelines to Standard Library,


99
00:04:35,796 --> 00:04:38,286
giving us a consistent and
predicable set of primitives


100
00:04:38,286 --> 00:04:41,296
that we can build on
top of, and SE-0005,


101
00:04:41,696 --> 00:04:44,756
which dramatically improved the
expressivity of the Cocoa SDK,


102
00:04:45,126 --> 00:04:47,036
by doing things like
adding default arguments,


103
00:04:47,286 --> 00:04:49,206
improving option sets
and building properties,


104
00:04:49,506 --> 00:04:51,776
even automatically adopting
protocols in some cases.


105
00:04:51,956 --> 00:04:56,846
We had a whole talk about this
that I definitely recommend


106
00:04:56,846 --> 00:04:59,986
that you check out if you missed
it, Swift API Design Guidelines.


107
00:05:02,136 --> 00:05:04,206
Now, all these were
tremendous advances,


108
00:05:04,816 --> 00:05:06,606
but we knew that we
could go even further.


109
00:05:07,226 --> 00:05:09,756
That's because Swift goals
go beyond just the names.


110
00:05:11,366 --> 00:05:14,856
Mutability in particular is
a key part of the language,


111
00:05:15,616 --> 00:05:18,466
and so, we turned our
attention to Foundation.


112
00:05:19,956 --> 00:05:21,836
Now, if you're wondering
why Foundation?


113
00:05:22,626 --> 00:05:24,416
The answer is because
it's kind of special,


114
00:05:24,756 --> 00:05:26,546
and I'm not just saying
that because I work on it.


115
00:05:27,486 --> 00:05:30,976
Foundation occupies a
unique spot in the SDK.


116
00:05:31,056 --> 00:05:33,006
What's interesting about it
is that it's low enough level


117
00:05:33,006 --> 00:05:35,576
to be used everywhere, on all
those platforms I mentioned.


118
00:05:36,276 --> 00:05:38,496
Yet, at the same time,
it's also high enough level


119
00:05:38,906 --> 00:05:42,646
to establish a whole new set of
common types and design patterns


120
00:05:42,646 --> 00:05:44,966
that again you see reflected
throughout the entire SDK.


121
00:05:44,966 --> 00:05:48,296
If we go back to our picture
from earlier and sort of zoom


122
00:05:48,296 --> 00:05:52,456
in on the Cocoa SDK, you'll see
lots of frameworks that you use


123
00:05:52,456 --> 00:05:56,226
in your apps every day, from
UIKit to SpriteKit, and WatchKit


124
00:05:56,226 --> 00:05:58,256
to CoreData, and many
other cores and kits


125
00:05:58,346 --> 00:05:59,516
that don't fit here either.


126
00:06:00,376 --> 00:06:02,646
Now, what's interesting
here is that almost all


127
00:06:02,646 --> 00:06:04,646
of these are built
on top of Foundation.


128
00:06:05,616 --> 00:06:07,676
So, we see Foundation
as a leverage point.


129
00:06:08,696 --> 00:06:10,876
What that means is that we can
make a small set of changes


130
00:06:10,876 --> 00:06:14,976
in Foundation, and that can have
a big impact on the entire SDK.


131
00:06:16,476 --> 00:06:18,486
Partly, that's because
Foundation is the home


132
00:06:18,486 --> 00:06:20,526
of many value types.


133
00:06:21,456 --> 00:06:25,436
So, we focused on this idea
of evolution over revolution.


134
00:06:25,926 --> 00:06:27,856
We've seen everything
that those libraries bring


135
00:06:27,856 --> 00:06:29,136
to the development of your apps.


136
00:06:29,606 --> 00:06:31,166
We're not going to
throw all that away


137
00:06:31,466 --> 00:06:32,656
because we have a new language.


138
00:06:32,996 --> 00:06:35,146
Instead what we're doing is
we're bringing the language


139
00:06:35,146 --> 00:06:37,106
and the libraries
closer together


140
00:06:37,176 --> 00:06:39,136
by making incremental
improvements to both.


141
00:06:39,756 --> 00:06:40,656
The changes that we're talking


142
00:06:40,656 --> 00:06:43,676
about today are a
continuation of that process.


143
00:06:44,166 --> 00:06:46,716
And so with that in mind,


144
00:06:46,716 --> 00:06:49,306
the Foundation team put forth
two additional proposals


145
00:06:49,306 --> 00:06:50,696
to the Swift Evolution
mailing list.


146
00:06:51,246 --> 00:06:53,776
The first was mutability
in Foundation value types,


147
00:06:54,186 --> 00:06:56,706
which is about embracing
that Swift mutability model


148
00:06:56,706 --> 00:06:57,816
in the Foundation framework.


149
00:06:59,766 --> 00:07:02,876
And also, dropping the NS
prefix in Swift Foundation,


150
00:07:03,256 --> 00:07:05,316
which is about establishing
those common types


151
00:07:05,316 --> 00:07:06,816
and design patterns for Swift,


152
00:07:07,156 --> 00:07:08,686
no matter which platform
you're using.


153
00:07:09,306 --> 00:07:13,846
So here is an overview of some


154
00:07:13,846 --> 00:07:15,496
of the API improvements
we've made this year.


155
00:07:15,876 --> 00:07:18,416
First and foremost, value
semantics, a brand new set


156
00:07:18,416 --> 00:07:20,616
of value types that you're
going to see across the SDK.


157
00:07:21,436 --> 00:07:23,076
Beyond that, we did
an additional set


158
00:07:23,076 --> 00:07:23,946
of naming improvements,


159
00:07:24,016 --> 00:07:26,946
beyond what the Objective-C
translation into Swift can do.


160
00:07:27,656 --> 00:07:29,516
We've adopted many
standard library protocols


161
00:07:29,516 --> 00:07:30,886
on these types, which means


162
00:07:30,886 --> 00:07:32,506
that your generic
algorithms can now work


163
00:07:32,506 --> 00:07:33,896
on Foundation types as well.


164
00:07:34,746 --> 00:07:36,846
We've added additional
type safety and a lot


165
00:07:36,846 --> 00:07:38,366
of new Swift-specific features.


166
00:07:38,366 --> 00:07:42,986
So, let's do a quick
overview of value types.


167
00:07:43,546 --> 00:07:45,656
Now, value types
are distinguished


168
00:07:45,656 --> 00:07:49,196
from reference types, primarily
based on their behavior


169
00:07:49,196 --> 00:07:53,266
around copying, so value types
copy their content on assignment


170
00:07:53,266 --> 00:07:54,426
or passed as a parameter.


171
00:07:54,596 --> 00:07:55,486
Here's a quick example.


172
00:07:55,796 --> 00:07:56,436
I've got a point.


173
00:07:57,046 --> 00:07:59,306
I use the equals operator
to assign that point


174
00:07:59,346 --> 00:08:01,966
to another point, and when
I mutate that second point,


175
00:08:02,166 --> 00:08:03,856
you see that only
the copy is mutated.


176
00:08:03,856 --> 00:08:05,346
I didn't affect the
content of both.


177
00:08:05,686 --> 00:08:08,106
That's because CGPoint
is a value type.


178
00:08:09,226 --> 00:08:10,016
Now, on the other hand,


179
00:08:10,016 --> 00:08:12,096
reference types share
their content by default.


180
00:08:12,816 --> 00:08:14,906
Here I'm going to create some
data using the reference type


181
00:08:14,906 --> 00:08:15,816
and its mutable data.


182
00:08:16,776 --> 00:08:19,486
Then I use that same
equal operator to assign


183
00:08:19,486 --> 00:08:20,526
that data to otherData.


184
00:08:21,126 --> 00:08:23,686
However, this time, when
I mutate that second data,


185
00:08:24,106 --> 00:08:25,966
you can see that it
affects the content of both.


186
00:08:26,066 --> 00:08:28,706
Now, it's important to
understand that neither


187
00:08:28,706 --> 00:08:30,216
of these is better
than the other.


188
00:08:30,866 --> 00:08:32,186
You just use them
in different ways.


189
00:08:33,265 --> 00:08:35,285
I like to think of it as a
couple of tools in the tool box


190
00:08:35,285 --> 00:08:38,876
that you can reach for when
you have a particular problem


191
00:08:39,525 --> 00:08:40,635
to solve.


192
00:08:41,326 --> 00:08:43,216
So, when you're trying
to decide for yourself


193
00:08:43,996 --> 00:08:46,166
if your type is a value
type or a reference type,


194
00:08:46,906 --> 00:08:49,796
you should think about object
identity and stored contents.


195
00:08:49,796 --> 00:08:52,326
Let me explain by way
of a couple of examples.


196
00:08:52,906 --> 00:08:56,626
So, in Foundation, we
have a class called.


197
00:08:57,376 --> 00:09:00,276
OperationQueue has a singleton,
called the main operation queue.


198
00:09:01,386 --> 00:09:03,416
That operation queue,
the main operation queue,


199
00:09:03,416 --> 00:09:04,596
is where you put
work that you want


200
00:09:04,596 --> 00:09:05,666
to happen on the main thread.


201
00:09:06,056 --> 00:09:07,596
And so, there's only
one of them.


202
00:09:07,856 --> 00:09:09,076
It has a kind of identity.


203
00:09:09,436 --> 00:09:11,996
If I were to copy the main
OperationQueue then it would no


204
00:09:11,996 --> 00:09:13,416
longer be the main
operation queue.


205
00:09:13,986 --> 00:09:15,076
So, we believe


206
00:09:15,146 --> 00:09:17,646
that OperationQueue
is a reference type.


207
00:09:18,646 --> 00:09:19,776
Another example, a pattern


208
00:09:19,776 --> 00:09:22,366
that you see throughout the
Cocoa SDKs is a delegation.


209
00:09:23,146 --> 00:09:25,106
So here is the delegate,
or one of the delegates


210
00:09:25,106 --> 00:09:27,506
for URL session,
and you'll notice


211
00:09:27,666 --> 00:09:30,156
that the delegate protocol
has an argument, right there,


212
00:09:30,306 --> 00:09:33,826
called Session, and that
tells the object that's being


213
00:09:33,826 --> 00:09:37,336
delegated to which URLSession
it's doing work on behalf of,


214
00:09:37,906 --> 00:09:41,796
and that idea of which
URLSession it is implies,


215
00:09:41,906 --> 00:09:42,786
again, identity.


216
00:09:43,186 --> 00:09:45,036
So, we believe that types


217
00:09:45,036 --> 00:09:47,006
with delegates are
usually reference types.


218
00:09:47,566 --> 00:09:50,776
On the other hand,
many types are more


219
00:09:50,776 --> 00:09:52,196
about their store contents.


220
00:09:52,256 --> 00:09:53,506
For example, Date.


221
00:09:53,506 --> 00:09:55,306
This is one of our new
Foundation value types.


222
00:09:56,376 --> 00:09:57,866
Date is an absolute
point in time.


223
00:09:58,596 --> 00:10:01,276
We can have two Dates
that have the same value,


224
00:10:01,406 --> 00:10:03,016
the same absolute point in time,


225
00:10:03,336 --> 00:10:04,656
and be talking about
the same Date.


226
00:10:04,656 --> 00:10:07,086
We don't need to talk about the
reference to that point in time.


227
00:10:07,626 --> 00:10:09,536
In fact, if we look inside
the implementation of Date,


228
00:10:09,776 --> 00:10:11,856
as you see here, it's
actually just a double,


229
00:10:12,346 --> 00:10:13,716
and a double is something
that we sort


230
00:10:13,716 --> 00:10:15,876
of already intuitively
understand as a value type.


231
00:10:17,106 --> 00:10:18,476
Another example is Data.


232
00:10:19,006 --> 00:10:21,536
Data is another one of our
new Foundation value types.


233
00:10:22,126 --> 00:10:24,966
Data, normally you care about
the contents of that Data,


234
00:10:25,206 --> 00:10:28,376
the bytes that are there, not
the actual NSData instance.


235
00:10:28,546 --> 00:10:33,976
So, Foundation has made
Data into a value type.


236
00:10:34,146 --> 00:10:36,626
Now, copying the data
every time that we pass it


237
00:10:36,626 --> 00:10:38,476
as a parameter would
quickly get very expensive.


238
00:10:39,026 --> 00:10:41,626
So, we performed an optimization
called Copy on Write.


239
00:10:42,496 --> 00:10:44,136
So, here I'm going
to create some data,


240
00:10:44,896 --> 00:10:47,596
and you see I've got a
struct, but inside that struct,


241
00:10:47,596 --> 00:10:48,856
I also have a reference.


242
00:10:48,886 --> 00:10:50,816
So, another example of
things working better


243
00:10:50,816 --> 00:10:51,636
when they work together.


244
00:10:51,976 --> 00:10:53,866
Here I'm using both a
reference and a value


245
00:10:54,266 --> 00:10:55,976
to get the performance
characteristics


246
00:10:56,276 --> 00:10:58,946
that I want along with the value
semantics that are important.


247
00:11:00,026 --> 00:11:02,756
Now, if I use that equal
operator to assign that data


248
00:11:02,756 --> 00:11:05,116
to another data,
then you can see


249
00:11:05,116 --> 00:11:07,616
that I've got another
struct, but it points


250
00:11:07,616 --> 00:11:09,446
at the same class
under the hood.


251
00:11:10,146 --> 00:11:14,006
However, if I mutate that Data,
then we will copy the Data,


252
00:11:14,486 --> 00:11:17,506
mutate the copy, and now we've
got two independent Datas.


253
00:11:18,876 --> 00:11:20,456
If I continue to
mutate the second Data,


254
00:11:20,986 --> 00:11:23,616
we can tell that that Data
is uniquely referenced,


255
00:11:23,616 --> 00:11:25,066
and we don't need to
copy it each time.


256
00:11:25,996 --> 00:11:28,556
So, this is an extension, or
actually, just another use


257
00:11:28,556 --> 00:11:31,256
of the same technique that
we've talked about in the past,


258
00:11:31,256 --> 00:11:33,366
including last year,
with building better apps


259
00:11:33,366 --> 00:11:34,396
and value types in Swift.


260
00:11:34,396 --> 00:11:36,046
So, check that out if you
want some more information


261
00:11:36,046 --> 00:11:38,486
on how this works.


262
00:11:38,656 --> 00:11:41,386
So, we did a survey of
every API in Foundation,


263
00:11:41,656 --> 00:11:43,476
and we came up with
this list of things


264
00:11:43,476 --> 00:11:45,196
that we think would
make great value types,


265
00:11:45,656 --> 00:11:47,566
and I think you'll be happy
to see many of the types


266
00:11:47,566 --> 00:11:49,566
that you use every
day on this list.


267
00:11:49,976 --> 00:11:51,976
That includes Data and
Date, as I mentioned,


268
00:11:52,326 --> 00:11:54,766
but also other types that
are really popular like URL,


269
00:11:55,166 --> 00:11:57,986
IndexPath, CharacterSet,
and a lot more.


270
00:11:58,286 --> 00:12:00,426
And many of these types not
only became value types,


271
00:12:00,726 --> 00:12:03,186
but gained a lot of
great new API as well.


272
00:12:03,716 --> 00:12:06,946
Now, to give you an idea
of what that looks like,


273
00:12:07,036 --> 00:12:08,406
I'd like to invite
Michael on stage.


274
00:12:09,516 --> 00:12:13,796
[ Applause ]


275
00:12:14,296 --> 00:12:14,846
>> Thank you, Tony.


276
00:12:15,616 --> 00:12:17,626
Let's start by visiting
the new homes of many


277
00:12:17,626 --> 00:12:19,046
of Foundation's enumerations.


278
00:12:19,696 --> 00:12:22,176
Now, as you know,
Objective-C enumerations


279
00:12:22,176 --> 00:12:24,166
and option sets live in
the global namespace,


280
00:12:24,226 --> 00:12:25,896
alongside the types
that consume them.


281
00:12:26,166 --> 00:12:30,066
For example, NSNumberFormatter
alone defines four enumerations


282
00:12:30,226 --> 00:12:33,676
for the style, behavior, pad
position, and rounding mode.


283
00:12:34,476 --> 00:12:37,106
And each of these are implicitly
associated with NumberFormatter


284
00:12:37,466 --> 00:12:39,346
through careful and
consistent naming convention.


285
00:12:39,996 --> 00:12:42,226
In Swift 2 as you
know, these important


286
00:12:42,226 --> 00:12:43,576
to the global namespace as well.


287
00:12:43,576 --> 00:12:46,896
But that doesn't feel
like native Swift.


288
00:12:47,426 --> 00:12:49,286
Swift supports nested types,


289
00:12:49,886 --> 00:12:53,126
and so in Swift 3 we made the
decision to relocate these types


290
00:12:53,876 --> 00:12:56,496
to be declared inside,
where they're destined to.


291
00:12:56,496 --> 00:12:59,026
So NumberFormatter now has
internal types of style,


292
00:12:59,066 --> 00:13:00,526
behavior, pad position,
and rounding mode.


293
00:13:00,886 --> 00:13:02,816
And their names are
no longer redundant,


294
00:13:03,716 --> 00:13:05,856
and this greatly reduces
the number of types


295
00:13:05,856 --> 00:13:08,066
that Foundation declares
in the top-level namespace,


296
00:13:08,506 --> 00:13:10,486
and now the relationship
is explicit,


297
00:13:10,526 --> 00:13:12,946
our APIs more expressive
and more discoverable.


298
00:13:14,476 --> 00:13:16,806
Sticking with the
theme of enumerations,


299
00:13:17,196 --> 00:13:20,836
many Foundation APIs also use
families of streamed constants.


300
00:13:20,986 --> 00:13:24,626
Examples include notification
names, URL resource keys.


301
00:13:25,066 --> 00:13:29,136
Now of course, Swift has support
for enumerations that rely


302
00:13:29,136 --> 00:13:31,496
on raw representations
that are other


303
00:13:31,496 --> 00:13:33,396
than integers, including string.


304
00:13:33,816 --> 00:13:35,486
Wouldn't it be great if
we could do the same thing


305
00:13:35,486 --> 00:13:36,326
in Objective-C?


306
00:13:37,336 --> 00:13:40,346
Well, new this year we can, and
the constants are now defined


307
00:13:40,346 --> 00:13:42,806
in terms of very specific
kinds of string constants,


308
00:13:43,026 --> 00:13:46,286
like notification name
and URL resource key,


309
00:13:46,596 --> 00:13:47,746
and many, many more.


310
00:13:49,706 --> 00:13:53,846
And these constants remain
extensible, in Objective-C


311
00:13:54,556 --> 00:14:00,966
and also in Swift, where we can
also see that we nest them just


312
00:14:00,966 --> 00:14:04,036
like their integral
cousins, so that using them


313
00:14:04,036 --> 00:14:06,166
in Swift 3 is both
natural and expressive.


314
00:14:06,896 --> 00:14:10,036
Now another common Foundation
design pattern is associating


315
00:14:10,036 --> 00:14:10,876
state with a type.


316
00:14:11,226 --> 00:14:14,066
For instance, the
standardUserDefaults.


317
00:14:14,886 --> 00:14:16,106
Now, of course, Swift support


318
00:14:16,106 --> 00:14:19,516
for class properties are
a great fit for this idea,


319
00:14:20,126 --> 00:14:22,956
and new in this year, we
have brought class properties


320
00:14:22,956 --> 00:14:25,266
to Objective-C, and
they're declared just


321
00:14:25,266 --> 00:14:26,476
like instance properties,


322
00:14:26,786 --> 00:14:29,446
except we now accept
this fancy class keyword,


323
00:14:29,796 --> 00:14:33,536
and because we know that
it's a class property,


324
00:14:33,536 --> 00:14:35,286
we no longer need to
import it as a func


325
00:14:35,286 --> 00:14:36,506
as we did in Swift 2.2.


326
00:14:36,696 --> 00:14:40,316
It can now appear as a class
property, just as you would


327
00:14:40,316 --> 00:14:41,946
if you were defining
this natively in Swift.


328
00:14:43,036 --> 00:14:44,836
But we didn't stop there.


329
00:14:44,836 --> 00:14:48,266
There's some redundant
words here, and in Swift 3,


330
00:14:48,266 --> 00:14:50,976
we overhauled the way that
Swift code is manifested,


331
00:14:50,976 --> 00:14:53,066
or Objective-C code
is manifest in Swift,


332
00:14:53,366 --> 00:14:56,556
so that our final API could
look a little more like this.


333
00:14:57,106 --> 00:15:00,166
We know it's our user defaults,
and by helping Foundation grow


334
00:15:00,166 --> 00:15:02,346
to be more Swift-like, we've
achieved great benefits


335
00:15:02,346 --> 00:15:04,026
for both Objective-C and Swift.


336
00:15:04,516 --> 00:15:08,896
Now Tony mentioned many
Foundation types deserve


337
00:15:08,896 --> 00:15:11,316
to be value types, and so I'm
going to talk about a few.


338
00:15:11,526 --> 00:15:13,986
We'll start with Date.


339
00:15:14,356 --> 00:15:16,396
Now let's suppose we want
to schedule a reminder


340
00:15:16,396 --> 00:15:17,766
for when we should go home.


341
00:15:17,816 --> 00:15:21,336
We'll start with Swift 2.2,
just to motivate our example.


342
00:15:21,616 --> 00:15:23,486
Let's suppose that we have
a function that can answer


343
00:15:23,486 --> 00:15:28,486
when we need to go home, and we
call it, and five minutes seems


344
00:15:28,486 --> 00:15:30,776
like a good time for our
reminder, so we'll go ahead and,


345
00:15:31,106 --> 00:15:32,456
you know, offset
that a little bit.


346
00:15:33,236 --> 00:15:35,636
Now, it's worth pointing
out, NSDate is


347
00:15:35,636 --> 00:15:38,746
and remains a reference type,
and so there's actually two,


348
00:15:39,156 --> 00:15:41,356
potentially two dynamic
allocations going on here.


349
00:15:41,796 --> 00:15:43,756
One here, and another here.


350
00:15:44,346 --> 00:15:48,186
Now in Swift 3, we gain
access to the Date value type.


351
00:15:49,206 --> 00:15:50,516
So, let's go ahead and use it,


352
00:15:51,746 --> 00:15:53,106
and consuming it
is very similar,


353
00:15:53,166 --> 00:15:56,446
however now this var takes on
a whole new kind of behavior.


354
00:15:56,946 --> 00:15:59,456
We specifically, we now
allow inline mutation.


355
00:16:00,326 --> 00:16:01,536
And so, we've done zero,


356
00:16:02,056 --> 00:16:04,556
these two examples here are
doing the exact same thing,


357
00:16:04,556 --> 00:16:08,076
except with the value
type we've done no extra


358
00:16:08,076 --> 00:16:09,166
dynamic allocations.


359
00:16:09,466 --> 00:16:10,556
Let's continue our example.


360
00:16:10,886 --> 00:16:12,836
Now, of course, we can
do this inline as well.


361
00:16:12,836 --> 00:16:17,336
Now, with reminders, it's
only really meaningful


362
00:16:17,336 --> 00:16:19,486
to schedule them if
they haven't happened,


363
00:16:20,076 --> 00:16:21,986
and one of the great
things that Swift brings


364
00:16:21,986 --> 00:16:25,156
to the table is automatic
conformance to protocols


365
00:16:25,156 --> 00:16:29,066
when you satisfy certain
criteria, and so in this case,


366
00:16:29,066 --> 00:16:31,606
Date Auto has conforms
to comparable,


367
00:16:31,756 --> 00:16:33,486
which gives us access
to the less


368
00:16:33,536 --> 00:16:35,816
than operator, which we use now.


369
00:16:36,336 --> 00:16:38,276
And we can go ahead
and schedule our timer,


370
00:16:38,276 --> 00:16:39,426
but first we need to create it.


371
00:16:39,486 --> 00:16:41,996
And so we'll use another new
Foundation API this year,


372
00:16:42,356 --> 00:16:45,666
which is this fancy
closure-based timer API,


373
00:16:46,286 --> 00:16:48,356
where we initialize the
timer with a closure.


374
00:16:48,356 --> 00:16:50,556
So no more selectors
and targets there,


375
00:16:50,556 --> 00:16:53,236
and we'll schedule it
on our main run loop.


376
00:16:54,516 --> 00:16:58,606
[ Applause ]


377
00:16:59,106 --> 00:17:00,566
I'll also call out thread


378
00:17:00,566 --> 00:17:03,106
and run loop have those
as well I believe.


379
00:17:03,106 --> 00:17:06,046
And we schedule them on our
main run loop and we're done.


380
00:17:06,476 --> 00:17:08,066
And this is a great
example of how all


381
00:17:08,066 --> 00:17:10,546
of these familiar Foundation
APIs really can come


382
00:17:10,546 --> 00:17:12,215
across so beautifully
in Swift 3.


383
00:17:12,856 --> 00:17:14,965
This is some of the most
Foundationy code I could


384
00:17:14,965 --> 00:17:16,106
possibly have in a demo.


385
00:17:16,106 --> 00:17:18,056
I have a run loop, I have
a timer and some dates.


386
00:17:18,236 --> 00:17:19,986
I just, there's only
a few other things,


387
00:17:19,986 --> 00:17:21,425
and this is pretty
much all of Foundation.


388
00:17:21,566 --> 00:17:23,606
And there isn't a
square bracket in sight.


389
00:17:25,606 --> 00:17:27,756
So, another new example,
or another new type


390
00:17:27,846 --> 00:17:30,226
in Foundation is the
measurement value type.


391
00:17:31,156 --> 00:17:33,456
And let's suppose with
a new example here,


392
00:17:33,456 --> 00:17:34,956
we care about how
long our commute is,


393
00:17:34,956 --> 00:17:37,876
and we're lucky enough to
live two short streets away


394
00:17:37,876 --> 00:17:38,646
from where we work.


395
00:17:39,386 --> 00:17:40,656
Now, measurements
are value types,


396
00:17:40,656 --> 00:17:43,046
and Swift supports
operator overloading,


397
00:17:43,376 --> 00:17:44,806
and not only are they
value types, though.


398
00:17:45,036 --> 00:17:47,306
They're mathematical in
nature, and so it makes sense


399
00:17:47,306 --> 00:17:50,796
to specify operators on them.


400
00:17:50,796 --> 00:17:54,646
No one will look the other
way, or make a sour face


401
00:17:54,646 --> 00:17:57,116
if we contemplate
adding them together,


402
00:17:57,116 --> 00:18:00,636
and so we can compute their sum,
and we can even convert them


403
00:18:00,636 --> 00:18:01,786
to a different kind of unit.


404
00:18:01,786 --> 00:18:04,376
And let's suppose we were
curious how long it took


405
00:18:04,376 --> 00:18:05,256
for us to get to work.


406
00:18:05,256 --> 00:18:08,506
Well, we could do that as
well, except in Swift 3,


407
00:18:08,506 --> 00:18:10,996
if we were to try to build
this code, it would fail,


408
00:18:10,996 --> 00:18:13,516
and it would fail at
compile time because,


409
00:18:13,656 --> 00:18:16,526
thanks to the power of Swift 3's
generics in type constraints,


410
00:18:16,916 --> 00:18:19,976
we actually have designed this
in a way that the difference


411
00:18:19,976 --> 00:18:21,826
in units is knowable
at compile time,


412
00:18:22,046 --> 00:18:24,106
and so the Swift compiler
can detect us and tell us


413
00:18:24,146 --> 00:18:25,796
that we're trying to do
an invalid conversion.


414
00:18:26,746 --> 00:18:28,526
To learn more about
measurement and units


415
00:18:28,526 --> 00:18:30,136
and the whole new
ecosystem of types


416
00:18:30,136 --> 00:18:33,346
that we've introduced this year,
be sure to check out this talk


417
00:18:33,346 --> 00:18:35,776
on Friday afternoon
to learn more


418
00:18:35,776 --> 00:18:36,986
about measurements and units.


419
00:18:38,076 --> 00:18:39,926
I'm going to switch
to another example.


420
00:18:40,886 --> 00:18:43,096
I did say this was going
to be an adventure.


421
00:18:43,326 --> 00:18:45,656
Suppose we want to
buy some MacBooks.


422
00:18:45,846 --> 00:18:48,116
We'll use the new URL
Component's value type


423
00:18:48,916 --> 00:18:50,446
and we can do this
very expressively.


424
00:18:51,166 --> 00:18:53,476
We'll begin by describing
mutable components,


425
00:18:53,476 --> 00:18:55,526
which we'll use as
a template below.


426
00:18:55,826 --> 00:18:57,656
And we iterate through
the products that we want


427
00:18:57,696 --> 00:19:02,856
to purchase, make a copy of
our template, and then mutate


428
00:19:02,856 --> 00:19:06,176
that copy, specifying the
product that we wish to buy.


429
00:19:07,046 --> 00:19:07,766
Note that we're safe


430
00:19:07,766 --> 00:19:09,756
to explicitly unwrap
this optional here,


431
00:19:10,146 --> 00:19:13,256
because we specified that it was
non-nill in our template above.


432
00:19:14,466 --> 00:19:16,956
We can go ahead and
print our URLs and we see


433
00:19:16,956 --> 00:19:21,136
that we have been able to build,
you know, the URLs that we'd


434
00:19:21,136 --> 00:19:26,606
like to purchase with no
memory management whatsoever.


435
00:19:26,926 --> 00:19:29,276
All we had to do was
declare our intent, whether


436
00:19:29,276 --> 00:19:31,576
or not something was mutable or
not, and the language took care


437
00:19:31,576 --> 00:19:33,766
of the rest of the
details for us.


438
00:19:34,676 --> 00:19:37,106
Now, another thing
that Swift 3 brings,


439
00:19:37,216 --> 00:19:38,286
or Swift in general brings


440
00:19:38,286 --> 00:19:40,126
to the table is protocol
components.


441
00:19:40,126 --> 00:19:42,506
In many Foundation
types, like Date,


442
00:19:42,706 --> 00:19:46,516
getting useful new capabilities
thanks to new conformances.


443
00:19:46,716 --> 00:19:48,136
For instance, CharacterSet


444
00:19:48,136 --> 00:19:51,236
and IndexSet are now
conformed to SetAlgebra.


445
00:19:51,496 --> 00:19:54,206
So you can union, intersect, and
symmetric difference these guys


446
00:19:54,206 --> 00:19:55,106
to your hearts' content.


447
00:19:56,356 --> 00:19:59,006
Data is also now a
MutableCollection,


448
00:19:59,296 --> 00:20:02,776
MutableRandomAccessCollection
of unsigned eight-bit integers,


449
00:20:03,466 --> 00:20:06,526
but, like you always
thought it was.


450
00:20:06,806 --> 00:20:08,546
Let's look at some of the
things we can do with some


451
00:20:08,546 --> 00:20:09,926
of Data's new conformances.


452
00:20:11,016 --> 00:20:13,236
First we're going to need
some data, and I happen


453
00:20:13,236 --> 00:20:15,456
to have some base64
data lying around,


454
00:20:15,616 --> 00:20:17,656
which we'll parse using
the normal initializer.


455
00:20:18,476 --> 00:20:23,796
In the explicit unwrap here
is, I know it's safe to do this


456
00:20:23,826 --> 00:20:25,126
because this is a demo,


457
00:20:25,126 --> 00:20:26,546
and I know that that's
valid base64 [laughter].


458
00:20:26,546 --> 00:20:31,446
You should probably use a
try there if you do this


459
00:20:31,446 --> 00:20:35,376
for yourself, but let's say,
you know, I like statistics


460
00:20:35,376 --> 00:20:36,826
and the nice thing to look


461
00:20:36,826 --> 00:20:38,546
at when you have
statistics is a histogram.


462
00:20:38,546 --> 00:20:39,416
That's always a good
thing to start.


463
00:20:39,416 --> 00:20:40,426
So we're going to
build a histogram.


464
00:20:40,646 --> 00:20:42,126
We'll use as our
backing storage,


465
00:20:42,126 --> 00:20:44,806
we'll use a native Swift array,
which will initialize to zero,


466
00:20:44,996 --> 00:20:48,466
and we'll just use the byte
value of each byte in the data


467
00:20:48,466 --> 00:20:51,216
as the index and maintain
a frequency count.


468
00:20:52,046 --> 00:20:54,696
So let's, because Data
is a collection iterating


469
00:20:54,696 --> 00:20:58,026
through its bytes, is natural
and expressive, which we can do


470
00:20:58,026 --> 00:21:01,066
with a four N loop, and so
we'll produce our histogram.


471
00:21:01,066 --> 00:21:01,856
And let's take a look.


472
00:21:01,856 --> 00:21:04,636
Well that definitely
looks like a histogram,


473
00:21:04,896 --> 00:21:07,076
and like all histograms,
there's signal and noise,


474
00:21:07,076 --> 00:21:09,216
and I'm seeing a lot of high
frequency data in there,


475
00:21:09,856 --> 00:21:11,436
and I'd like to filter that out,


476
00:21:11,726 --> 00:21:14,536
and luckily Data's a collection
now, and so we gain access


477
00:21:14,536 --> 00:21:16,396
to things like Map,
Reduce, and Filter,


478
00:21:16,396 --> 00:21:19,106
and all of your other
favorite collection functions.


479
00:21:19,656 --> 00:21:21,606
And so, let's say we wanted
to remove all the data


480
00:21:21,606 --> 00:21:23,486
that was greater than three.


481
00:21:23,786 --> 00:21:25,996
It's as simple as
specifying a predicate now,


482
00:21:26,436 --> 00:21:29,666
and we can generate
our new filtered data.


483
00:21:30,666 --> 00:21:33,306
And also as a collection,
Data is sliceable,


484
00:21:33,816 --> 00:21:37,156
and these slices work just
like the mutable collections,


485
00:21:37,326 --> 00:21:38,256
or value type collections


486
00:21:38,256 --> 00:21:40,306
that you're already
accustomed to in Swift.


487
00:21:41,456 --> 00:21:44,456
Mutating them invokes the
same copy on write machinery


488
00:21:44,456 --> 00:21:48,166
that Tony described earlier and
they work just the same way.


489
00:21:49,826 --> 00:21:53,426
Now, Data also remains
extensible through inheritance


490
00:21:53,426 --> 00:21:54,946
of the underlying
reference type,


491
00:21:55,176 --> 00:21:57,866
and that's a very big sentence,
so I'll walk through an example


492
00:21:57,866 --> 00:21:59,636
to show what I mean by that.


493
00:22:00,056 --> 00:22:01,346
As an example, let's go ahead


494
00:22:01,346 --> 00:22:04,106
and create a custom
NSData subclass


495
00:22:04,426 --> 00:22:05,676
that allocates no storage,


496
00:22:05,906 --> 00:22:08,446
but represents a virtual
collection of all ones.


497
00:22:09,116 --> 00:22:10,556
We'll call it an AllOnesData.


498
00:22:10,806 --> 00:22:11,556
Very descriptive.


499
00:22:11,556 --> 00:22:14,006
And I'm only going to show the
implementation a single method


500
00:22:14,006 --> 00:22:17,916
here, specifically
getBytes, wherein the promise


501
00:22:17,916 --> 00:22:20,596
of this class is more
or less fulfilled.


502
00:22:20,736 --> 00:22:21,976
We set all the bytes to one.


503
00:22:22,436 --> 00:22:26,016
So we don't need to store
anything, and let's go ahead


504
00:22:26,016 --> 00:22:27,936
and create a read-only
instance of this.


505
00:22:28,496 --> 00:22:30,116
But we won't just
use the reference.


506
00:22:30,116 --> 00:22:33,906
We're actually going
to create a value type


507
00:22:33,906 --> 00:22:35,636
that wraps the reference
type here.


508
00:22:35,926 --> 00:22:39,546
And using that, we just use
the new initializer for Data,


509
00:22:39,546 --> 00:22:41,786
and it works exactly the
way you would expect.


510
00:22:42,536 --> 00:22:46,226
We have a ones value type that's
now pointing to the reference


511
00:22:46,226 --> 00:22:47,946
of all ones, and those
ones are virtual.


512
00:22:47,946 --> 00:22:50,306
They don't actually consume
bytes in memory currently.


513
00:22:50,626 --> 00:22:53,106
Let's go ahead and create
a mutable copy, and again,


514
00:22:53,236 --> 00:22:56,156
we've not done any mutation,
so we don't need to allocate


515
00:22:56,156 --> 00:22:58,266
or manifest any of those
bytes in memory currently.


516
00:22:59,096 --> 00:23:01,646
But let's get ready to mutate
those bytes, and to do that,


517
00:23:01,646 --> 00:23:04,146
we're going to actually use
another new Foundation API this


518
00:23:04,146 --> 00:23:07,646
year, which is the
Scoped Pointer Accessor,


519
00:23:08,626 --> 00:23:10,856
called withUnsafe MutableBytes.


520
00:23:11,046 --> 00:23:13,456
And this is much better than
just calling mutable bytes


521
00:23:13,456 --> 00:23:18,646
on the data itself, because
we're scoping the access


522
00:23:18,646 --> 00:23:20,886
to those bytes within the
closure that we're specifying,


523
00:23:21,236 --> 00:23:23,956
which it makes it very easy to
reason about where, you know,


524
00:23:23,956 --> 00:23:25,446
you don't have pointers
just flying around.


525
00:23:25,446 --> 00:23:27,536
Pointers are only going to
be in these little accessors.


526
00:23:28,596 --> 00:23:31,916
And so we actually perform our
mutation, invoking the copy


527
00:23:31,916 --> 00:23:34,066
on right machinery, and
those bytes are now,


528
00:23:34,176 --> 00:23:38,966
the copies bytes are now
manifested memory for reals.


529
00:23:39,066 --> 00:23:40,036
Let's move on to
another example.


530
00:23:40,036 --> 00:23:41,296
I'm tired of talking about Data.


531
00:23:42,006 --> 00:23:47,216
Let's talk about, URLs
and URL properties.


532
00:23:47,546 --> 00:23:49,866
Now to motivate this
example, I want to talk first


533
00:23:49,866 --> 00:23:53,146
about how we did
this in Swift 2.2.


534
00:23:53,146 --> 00:23:56,456
So in Swift 2.2, we would
ask for a NSURL file URL,


535
00:23:56,456 --> 00:23:58,626
we're going to talk about by
special file, and this file is


536
00:23:58,626 --> 00:24:01,336
so special, I keep it at
the root of my file system.


537
00:24:02,086 --> 00:24:03,676
And I'm curious about
three properties.


538
00:24:03,676 --> 00:24:06,966
I care about the creation date,
whether or not it's regular,


539
00:24:07,306 --> 00:24:10,016
and for some reason, the
maximum file size for the volume


540
00:24:10,016 --> 00:24:11,186
that this file's located on.


541
00:24:11,866 --> 00:24:14,116
And these are just strings
in Swift 2.2 and you just,


542
00:24:14,116 --> 00:24:15,646
this is just an array
of strings.


543
00:24:16,036 --> 00:24:18,426
And when I ask my URL
for its resource values,


544
00:24:18,426 --> 00:24:21,516
I just get a regular dictionary,
and there's no type information.


545
00:24:21,516 --> 00:24:25,016
It's just a string to an
object, which means consuming


546
00:24:25,016 --> 00:24:29,676
that result requires a lot of
as is typing, and so I have to,


547
00:24:29,676 --> 00:24:31,086
you know, suggest
that it's a Boolean,


548
00:24:31,086 --> 00:24:32,376
and suggest that
it's an integer,


549
00:24:32,376 --> 00:24:35,246
and I'm constantly consulting
the references to make sure


550
00:24:35,246 --> 00:24:38,696
that I'm getting it right, and
further, mutation is also just


551
00:24:38,696 --> 00:24:39,826
in terms of the dictionary.


552
00:24:40,336 --> 00:24:45,236
And so you can do
absurd things like this,


553
00:24:45,366 --> 00:24:48,206
and it's every failure is
going to a runtime failure.


554
00:24:49,166 --> 00:24:51,126
So, let's see how this
gets better in Swift 3.


555
00:24:51,796 --> 00:24:55,416
In Swift 3, creating
the URL is similar,


556
00:24:55,416 --> 00:24:59,006
but we no longer use a
class factory method.


557
00:24:59,006 --> 00:25:02,626
This is moved into a
regular initializer syntax.


558
00:25:03,456 --> 00:25:05,036
We're still talking
about my special file,


559
00:25:05,996 --> 00:25:09,656
and instead of asking with an
array of strings we're going


560
00:25:09,656 --> 00:25:11,966
to use those new strongly
typed string enumerations


561
00:25:11,966 --> 00:25:14,566
that I mentioned earlier, and
we'll produce a set of them,


562
00:25:14,566 --> 00:25:17,546
and when we ask the URL
for the resource values,


563
00:25:17,546 --> 00:25:19,296
no longer are we going
to get a dictionary,


564
00:25:19,606 --> 00:25:21,876
but instead we're
going to get a value,


565
00:25:21,966 --> 00:25:24,326
a new Foundation value
type, and let's see what


566
00:25:24,326 --> 00:25:26,746
that Foundation value type
is for the three properties


567
00:25:26,776 --> 00:25:28,296
that we're asking
about right now.


568
00:25:29,346 --> 00:25:31,476
As you can see, creation
date is a Date,


569
00:25:31,846 --> 00:25:33,176
its regular file is a Bool,


570
00:25:33,176 --> 00:25:35,366
and volume maximum file
size is an integer.


571
00:25:35,796 --> 00:25:38,686
And it's also worth pointing


572
00:25:38,686 --> 00:25:42,396
out that the URLResourceValue
struct itself is lazy.


573
00:25:42,396 --> 00:25:45,626
It's still implemented in terms
of the dictionary that was done


574
00:25:45,626 --> 00:25:48,606
in the Swift 2 API, so we're not
necessarily this giant struct


575
00:25:48,746 --> 00:25:51,176
of things that are
going to consume memory.


576
00:25:51,176 --> 00:25:52,926
It's still going to be,
I asked for three things,


577
00:25:52,926 --> 00:25:54,356
I get potentially
three things back.


578
00:25:54,746 --> 00:25:56,246
And further, if you
have custom keys,


579
00:25:56,246 --> 00:25:58,356
the dictionary is still here,
but no longer are you going


580
00:25:58,356 --> 00:25:59,676
to ask for a string,
you're going to ask


581
00:25:59,676 --> 00:26:01,576
for the URL resource key
that you're interested in.


582
00:26:02,656 --> 00:26:04,836
Now, you might be noticing
there's a lot of question marks


583
00:26:04,836 --> 00:26:07,276
and the reason why is, well,
there's two reasons why.


584
00:26:07,276 --> 00:26:09,056
The first is that you
didn't ask for it.


585
00:26:09,366 --> 00:26:11,616
So, if you didn't ask for the
creation date it won't be there,


586
00:26:11,616 --> 00:26:13,776
and that again, goes back to
that sparseness of the data.


587
00:26:14,256 --> 00:26:16,246
The second reason why
it might not be there is


588
00:26:16,246 --> 00:26:20,526
that the property itself might
be failable, and as an example


589
00:26:20,526 --> 00:26:21,796
of VolumeMaximumFileSize.


590
00:26:22,066 --> 00:26:24,266
Let's look at two
examples of how that works.


591
00:26:25,536 --> 00:26:28,916
So because we asked for regular
file, we're entirely justified


592
00:26:28,916 --> 00:26:30,686
to explicitly unwrap
our optional here.


593
00:26:30,686 --> 00:26:31,576
It will be there.


594
00:26:31,576 --> 00:26:32,586
We asked for it.


595
00:26:32,696 --> 00:26:35,696
However, the documentation
for VolumeMaximumFileSize says


596
00:26:35,696 --> 00:26:38,676
that not all volumes and not all
file systems support a maximum


597
00:26:38,676 --> 00:26:41,206
file system size, and so
it might not be there.


598
00:26:41,416 --> 00:26:45,336
And as a perfect example of a
time to use the if let construct


599
00:26:45,336 --> 00:26:47,686
in Swift, to conditionally
set that local variable.


600
00:26:47,686 --> 00:26:51,226
Now, let's talk about mutation.


601
00:26:51,396 --> 00:26:54,446
Of course, the mutation
API now for the URLs


602
00:26:54,446 --> 00:26:57,176
in URLResourceValues is in
terms of its new value type,


603
00:26:57,516 --> 00:26:58,776
and so when you try
to, you know,


604
00:26:58,776 --> 00:27:00,986
even though this is my special
file, and I'm trying very hard


605
00:27:00,986 --> 00:27:04,236
to say that it's not regular,
the compiler will catch me


606
00:27:04,236 --> 00:27:06,246
at compile time instead
of letting me discover


607
00:27:06,246 --> 00:27:07,286
that problem at run time.


608
00:27:07,856 --> 00:27:12,386
And further, the creation date
is strongly typed as a Date,


609
00:27:12,386 --> 00:27:14,676
and so something absurd
like this might work


610
00:27:14,676 --> 00:27:16,856
with Siri, can't work with code.


611
00:27:17,466 --> 00:27:20,396
Now the last thing
I want to talk


612
00:27:20,396 --> 00:27:23,076
about on this Foundation
adventure is I want to talk


613
00:27:23,076 --> 00:27:24,746
about Swift's native
enumerations.


614
00:27:24,956 --> 00:27:27,576
And we're going to talk about
data again one more time,


615
00:27:27,576 --> 00:27:29,136
because there's a
really good example.


616
00:27:30,256 --> 00:27:32,686
When data takes ownership
of an UnsafeMutablePointer,


617
00:27:32,856 --> 00:27:35,116
you have the option of
specifying a deallocator.


618
00:27:36,636 --> 00:27:38,456
Data supports many
of these by default,


619
00:27:38,456 --> 00:27:43,426
and including the option to
specify a custom deallocator.


620
00:27:44,256 --> 00:27:49,106
Now, Swift supports
associated values with enums


621
00:27:49,106 --> 00:27:50,616
and oftentimes you'll
see these with, you know,


622
00:27:50,616 --> 00:27:52,996
integers where you can do case
expressions and stuff like that


623
00:27:52,996 --> 00:27:56,206
to be able to, you know, do
really cool pattern matching


624
00:27:56,206 --> 00:27:57,586
with it, but here
we're taking a closure,


625
00:27:57,966 --> 00:28:00,526
because we actually want
to wrap the behavior


626
00:28:00,526 --> 00:28:01,486
that you want to provide.


627
00:28:01,746 --> 00:28:03,066
Let's see this in action.


628
00:28:03,216 --> 00:28:04,966
We'll start simple
with a malloc case.


629
00:28:05,296 --> 00:28:07,256
Of course, you can
still malloc in Swift,


630
00:28:07,256 --> 00:28:10,316
although you probably don't
see it in a slide very often.


631
00:28:10,536 --> 00:28:14,986
So, you malloc, and when you
hand this pointer off to Data,


632
00:28:15,216 --> 00:28:17,036
you can, you'll deallocate
it with free,


633
00:28:17,116 --> 00:28:20,796
and the syntax there
is just simple


634
00:28:20,856 --> 00:28:23,156
as using the integration
values themselves.


635
00:28:23,526 --> 00:28:24,826
Let's look at a custom example.


636
00:28:24,936 --> 00:28:27,026
Let's suppose we have a
function that allows us


637
00:28:27,026 --> 00:28:30,156
to create glorious pointers,
which we want to make sure we


638
00:28:30,156 --> 00:28:32,446
that we free gloriously,
lest they be offended,


639
00:28:32,826 --> 00:28:35,606
and so we can specify the custom
deallocator, it's as simple


640
00:28:35,606 --> 00:28:38,596
as providing a closure
and making sure


641
00:28:38,596 --> 00:28:40,186
that you do the custom
thing that you like to do.


642
00:28:40,186 --> 00:28:45,656
And this is really powerful, and
really powerful concept or idea


643
00:28:45,656 --> 00:28:46,976
for framework developers,


644
00:28:47,246 --> 00:28:50,836
because in other languages
we would have needed


645
00:28:50,836 --> 00:28:52,886
to provide a second
function pointer-based API,


646
00:28:53,256 --> 00:28:57,566
but now in Swift 3, we can
provide a single enum-based API


647
00:28:57,566 --> 00:29:00,096
that expresses all of
these ideas very cleanly,


648
00:29:00,476 --> 00:29:01,166
and expressively.


649
00:29:02,386 --> 00:29:04,276
And so that concludes our
API adventure for now.


650
00:29:04,586 --> 00:29:06,416
Hopefully we saw a great
many wonders, and I'm going


651
00:29:06,416 --> 00:29:07,376
to hand things back to Tony


652
00:29:07,376 --> 00:29:08,646
to talk a little
more about adoption.


653
00:29:09,516 --> 00:29:15,746
[ Applause ]


654
00:29:16,246 --> 00:29:16,686
>> Thanks Michael.


655
00:29:17,216 --> 00:29:21,026
All right, now you've seen just
a little bit of what's possible.


656
00:29:21,676 --> 00:29:23,616
Let's talk about how you
can use it in your app.


657
00:29:24,986 --> 00:29:26,656
First, let's talk
about bridging.


658
00:29:27,046 --> 00:29:29,066
So, keeping with this theme
of iterative improvement,


659
00:29:29,486 --> 00:29:31,036
we've extended the
exact same concept


660
00:29:31,036 --> 00:29:33,716
that you're already familiar
with from Swift 2 for bridging


661
00:29:33,716 --> 00:29:36,976
between Objective-C and Swift,
so if you understand how String


662
00:29:36,976 --> 00:29:38,726
and NSString are
bridged, we've extended


663
00:29:38,726 --> 00:29:40,786
that exact same concepts
for Data and NSData


664
00:29:40,786 --> 00:29:42,666
and all the other value
types that you see here.


665
00:29:43,916 --> 00:29:47,466
That means that all
of the imported API


666
00:29:47,506 --> 00:29:50,696
from Cocoa SDK is going to
use these new value types,


667
00:29:51,136 --> 00:29:54,586
and that's a key part of how we
achieve this idea of leverage.


668
00:29:55,126 --> 00:29:59,346
So for example, in
AppKit in Swift 2.2,


669
00:29:59,556 --> 00:30:02,246
you'll see this class called
NSDatePicker, which let's,


670
00:30:02,746 --> 00:30:06,466
presents a UI to allow your
user to pick a date and it has,


671
00:30:06,536 --> 00:30:09,176
among others, two properties
for controlling those dates


672
00:30:09,476 --> 00:30:11,406
and you see here their
marked as @NSCopying,


673
00:30:11,676 --> 00:30:13,616
and also NSDate reference types.


674
00:30:15,016 --> 00:30:17,146
In Swift 3, with no
change to AppKit,


675
00:30:17,536 --> 00:30:19,306
just by making these
changes in Foundation,


676
00:30:19,666 --> 00:30:20,766
this class looks like this.


677
00:30:20,926 --> 00:30:23,746
You see we've got the struct
date type, and we no longer need


678
00:30:23,746 --> 00:30:27,126
to mark this as @NSCopying
because they're value types,


679
00:30:27,186 --> 00:30:28,756
and we handle the
copying for you.


680
00:30:29,366 --> 00:30:34,666
Now there can be a performance
cost for crossing this bridge


681
00:30:34,846 --> 00:30:37,916
and to explain what that is, I'd
like to dive into some details


682
00:30:37,916 --> 00:30:39,546
on how the bridging
actually works.


683
00:30:39,856 --> 00:30:42,796
We have two major strategies for
bridging, one for large types,


684
00:30:42,886 --> 00:30:45,416
which hold a reference, and
a second for small types,


685
00:30:45,556 --> 00:30:46,646
which create a reference.


686
00:30:47,356 --> 00:30:51,106
So, for example, we're
going back to data.


687
00:30:51,186 --> 00:30:53,496
Here I've created data
again, and you see a struct


688
00:30:53,536 --> 00:30:54,716
that wraps a reference type.


689
00:30:55,246 --> 00:30:58,326
Now, if I call some
Objective-C API, what happens is


690
00:30:58,326 --> 00:31:01,106
that we hand the reference
over to the Objective-C side.


691
00:31:01,486 --> 00:31:02,216
That's because, of course,


692
00:31:02,216 --> 00:31:03,866
Objective-C doesn't
deal with struct Data.


693
00:31:03,866 --> 00:31:05,466
It only understands NSData.


694
00:31:05,966 --> 00:31:07,996
Now, in this case perhaps
a synchronous method call,


695
00:31:08,326 --> 00:31:10,616
that Objective-C code isn't
going to hold onto that data


696
00:31:10,616 --> 00:31:11,636
for any period of time.


697
00:31:11,636 --> 00:31:13,266
It may access it, and
then forget about it.


698
00:31:13,436 --> 00:31:15,206
So, just holding the reference


699
00:31:15,206 --> 00:31:16,476
for a short period
of time is enough.


700
00:31:17,066 --> 00:31:20,106
On the other hand, you'll see
many APIs that, for example,


701
00:31:20,106 --> 00:31:23,436
take a data for longer period
of time, usually marked


702
00:31:23,436 --> 00:31:25,926
as properties that have
the copying attribute.


703
00:31:26,916 --> 00:31:28,766
In that case, in Objective-C,


704
00:31:29,126 --> 00:31:31,646
this Objective-C code will
call copy on that data,


705
00:31:32,106 --> 00:31:33,876
and that's because it
needs to protect itself


706
00:31:33,876 --> 00:31:36,066
from any potential mutation
that happens to that data


707
00:31:36,066 --> 00:31:38,286
that it just received from
a totally unknown source.


708
00:31:39,236 --> 00:31:42,436
So that means that when crossing
this bridge, a copy can occur.


709
00:31:43,296 --> 00:31:44,336
Let's flip that around
the other way.


710
00:31:44,526 --> 00:31:45,706
Let's say I've got
some Swift code


711
00:31:45,706 --> 00:31:48,326
that is calling an Objective-C
method that returns some data.


712
00:31:48,846 --> 00:31:50,766
Here, the Objective-C
code has, of course,


713
00:31:50,766 --> 00:31:53,996
created the class NSData and
when it's returned to Swift,


714
00:31:54,746 --> 00:31:57,036
we create the struct Data,
which wraps the reference


715
00:31:57,106 --> 00:31:59,596
and it calls copy, for exactly
the same reason as we saw


716
00:31:59,596 --> 00:32:00,336
in the previous slide.


717
00:32:00,846 --> 00:32:03,206
The struct needs to maintain
its control over this copy


718
00:32:03,206 --> 00:32:06,386
so that it can provide the
proper value semantics for you.


719
00:32:07,776 --> 00:32:10,426
Fortunately, almost all data
that you receive this way


720
00:32:10,426 --> 00:32:11,986
from the SDK is immutable,


721
00:32:12,276 --> 00:32:14,416
which means that the copy
is actually just a retain.


722
00:32:14,606 --> 00:32:16,236
However, it is important
to understand


723
00:32:16,526 --> 00:32:18,846
that when crossing this
bridge, a copy may occur.


724
00:32:19,966 --> 00:32:23,456
For small types, like Date, you
can see there is no reference.


725
00:32:23,516 --> 00:32:24,866
We saw earlier the
implementation,


726
00:32:24,866 --> 00:32:25,486
just had a double.


727
00:32:25,996 --> 00:32:30,366
So, in Swift, if we call an
Objective-C function, or method,


728
00:32:30,906 --> 00:32:34,766
which takes a date, then we
have to allocate an NSDate


729
00:32:34,766 --> 00:32:37,296
on the bridging, and
that's again, of course,


730
00:32:37,296 --> 00:32:38,836
because the Objective-C
code only knows how


731
00:32:38,836 --> 00:32:39,726
to deal with references.


732
00:32:40,236 --> 00:32:42,886
Now, we do a lot of tricks in
Objective-C to make allocation


733
00:32:42,886 --> 00:32:44,786
of things like NSDates
really cheap.


734
00:32:45,156 --> 00:32:46,906
However, it is important
to understand


735
00:32:46,906 --> 00:32:48,976
that an allocation can
occur on that bridge.


736
00:32:53,516 --> 00:32:56,016
So, we optimize these
sites for use within Swift.


737
00:32:56,976 --> 00:32:58,916
In your code, you should
avoid crossing back and forth


738
00:32:58,916 --> 00:33:00,776
over that bridge repeatedly.


739
00:33:01,826 --> 00:33:04,206
This is because we wanted our
code to be safe by default,


740
00:33:04,656 --> 00:33:07,186
but it does mean that there
is a potential copy there.


741
00:33:07,186 --> 00:33:08,846
So, something to be aware
of when you're looking


742
00:33:08,846 --> 00:33:10,216
at adopting these
new value types.


743
00:33:10,666 --> 00:33:13,326
Next, let's talk
about migration.


744
00:33:14,296 --> 00:33:15,296
So, first, some good news.


745
00:33:16,166 --> 00:33:18,086
These new types we're
talking about today exist


746
00:33:18,086 --> 00:33:19,816
for all Swift deployment
targets.


747
00:33:20,496 --> 00:33:22,026
They're part of the
Swift Standard Library,


748
00:33:22,496 --> 00:33:24,266
which means you don't need
to wait for your customers


749
00:33:24,266 --> 00:33:26,376
to upgrade to the newest
versions of our platforms.


750
00:33:26,826 --> 00:33:29,016
As soon as Swift 3 and
S Creator are released,


751
00:33:29,016 --> 00:33:30,386
you can begin using
them immediately.


752
00:33:31,216 --> 00:33:34,936
Now, to help you, we've of
course upgraded the Migrator,


753
00:33:35,416 --> 00:33:38,706
and that means that when you
open your project in Xcode 8,


754
00:33:38,706 --> 00:33:41,346
you'll see a dialog box like
this one, and I recommend


755
00:33:41,346 --> 00:33:42,156
that you click convert.


756
00:33:42,526 --> 00:33:43,766
So, let me show you a few things


757
00:33:43,986 --> 00:33:45,676
that the Migrator
will do for you.


758
00:33:46,676 --> 00:33:49,616
So here we have in
Swift 2.2 some NSDates,


759
00:33:49,826 --> 00:33:52,886
and we're calling a method on
that, dateByAddingtimeInterval.


760
00:33:53,456 --> 00:33:56,616
The Migrator will fix up
the reference type NSDate


761
00:33:56,616 --> 00:33:58,486
into the value type
of struct Date,


762
00:33:59,206 --> 00:34:00,996
and it will change the methods


763
00:34:01,216 --> 00:34:02,746
because they've changed
according


764
00:34:02,746 --> 00:34:04,606
to our new Swift 3
API Design Guidelines,


765
00:34:05,016 --> 00:34:07,566
both for the reference types
and for the value types.


766
00:34:08,335 --> 00:34:09,376
Here's another example.


767
00:34:10,085 --> 00:34:12,606
Here, I'm creating an
NSDateComponents in Swift 2,


768
00:34:12,956 --> 00:34:16,496
and then setting some of its
properties, and I can do this


769
00:34:16,496 --> 00:34:19,866
because NSDateComponents is an
always mutable reference type.


770
00:34:20,656 --> 00:34:21,366
Now, in Swift 3,


771
00:34:21,366 --> 00:34:23,235
we've introduced a
struct DateComponents.


772
00:34:23,636 --> 00:34:25,775
So the Migrator will change
the reference to the struct,


773
00:34:26,416 --> 00:34:29,216
but also it notices that you're
mutating it, and changes the let


774
00:34:29,216 --> 00:34:30,446
to a var for you as well.


775
00:34:31,466 --> 00:34:33,505
Now the Migrator can
do quite a bit for you,


776
00:34:33,896 --> 00:34:35,956
but there are some places
where if you go back and look


777
00:34:35,956 --> 00:34:38,596
at what it's done, you can do
even better by taking advantage


778
00:34:38,596 --> 00:34:40,315
of some additional things
that we've added for you.


779
00:34:40,726 --> 00:34:43,536
In this case, DateComponents
has a new initializer,


780
00:34:43,536 --> 00:34:45,186
and this is something
we can only do in Swift.


781
00:34:45,186 --> 00:34:48,545
The initializer has
arguments for every property


782
00:34:48,545 --> 00:34:50,295
in the DateComponents,
and they're all optional,


783
00:34:50,406 --> 00:34:51,505
and they all have
default values,


784
00:34:51,835 --> 00:34:53,966
which means that you can create
a DataComponents using only the


785
00:34:53,966 --> 00:34:56,426
values you care about, your
month and day in this case.


786
00:34:56,696 --> 00:34:58,066
And you can change
the var back to a let


787
00:34:58,176 --> 00:34:59,826
because now you don't
need to mutate it


788
00:34:59,826 --> 00:35:01,386
after you've initialized it.


789
00:35:02,986 --> 00:35:04,656
And finally, our
friend data again.


790
00:35:05,156 --> 00:35:08,036
Here in Swift 2, see that I'm
creating an NSMutableData,


791
00:35:08,206 --> 00:35:10,556
the reference type, and
appending some data to it.


792
00:35:11,846 --> 00:35:14,556
In Swift 3, the Migrator
will fix up the method names,


793
00:35:14,826 --> 00:35:18,196
like contentsOf URL,
and appendData,


794
00:35:19,376 --> 00:35:21,796
and it will change NSData
into the struct Data.


795
00:35:22,246 --> 00:35:24,536
However, it's left the
NSMutableData reference


796
00:35:24,536 --> 00:35:25,006
type alone.


797
00:35:25,526 --> 00:35:28,046
In some cases like this, there's
just not enough information


798
00:35:28,046 --> 00:35:29,066
for the Migrator in order


799
00:35:29,066 --> 00:35:31,236
to do what we think is the
best option, so we're going


800
00:35:31,236 --> 00:35:33,036
to leave it as is and
it should still work.


801
00:35:33,726 --> 00:35:36,176
However, if you go back and
do some additional fix ups


802
00:35:36,176 --> 00:35:38,676
on your own, you can
do something cool here.


803
00:35:38,736 --> 00:35:41,056
We can change the
MutableData into a struct Data,


804
00:35:41,636 --> 00:35:43,516
which means that we
change it from let to var.


805
00:35:43,866 --> 00:35:46,046
And we can remove
the options argument


806
00:35:46,046 --> 00:35:47,426
because it has a
default value now.


807
00:35:48,006 --> 00:35:51,596
So, we've talked
about a lot today,


808
00:35:51,596 --> 00:35:53,316
and I'd like to just
briefly recap what we saw.


809
00:35:54,496 --> 00:35:55,826
We believe that these
improvements


810
00:35:55,826 --> 00:35:58,316
to Foundation are going
to benefit the entire SDK


811
00:35:58,316 --> 00:36:00,486
and your whole development
experience in Swift.


812
00:36:01,366 --> 00:36:03,496
Partly that was due
to the API renaming,


813
00:36:03,966 --> 00:36:06,406
but we also took the
opportunity to go farther,


814
00:36:06,596 --> 00:36:08,446
and add a brand new
set of value types,


815
00:36:08,566 --> 00:36:10,426
and a lot of new
Swift-specific API.


816
00:36:11,626 --> 00:36:14,846
We see this as the start
of a journey, and we intend


817
00:36:14,846 --> 00:36:16,886
to continue to be this
leverage point in the future.


818
00:36:16,886 --> 00:36:19,006
We're going to make many
improvements over time


819
00:36:19,006 --> 00:36:22,056
to make your Swift apps safer,
faster, and more expressive.


820
00:36:23,296 --> 00:36:25,406
So for more information,
check out this struct URL,


821
00:36:26,556 --> 00:36:30,186
and these related sessions,
including, Going Server-side


822
00:36:30,186 --> 00:36:31,976
with Swift Open Source,
Measurements and Units.


823
00:36:32,111 --> 00:36:34,111
[ Applause ]


824
00:36:34,206 --> 00:36:34,446
Thank you.


825
00:36:35,508 --> 00:36:37,508
[ Applause ]

