1
00:00:00,506 --> 00:00:10,606
[ Silence ]


2
00:00:11,106 --> 00:00:14,116
>> Welcome to this
afternoon's, this year's edition


3
00:00:14,116 --> 00:00:15,816
of "What's New in
Foundation Networking."


4
00:00:16,676 --> 00:00:18,166
Foundation Networking
is, of course,


5
00:00:18,166 --> 00:00:20,156
the layer of networking
that's available


6
00:00:20,156 --> 00:00:23,706
to application developers
on Mac OS X and iOS.


7
00:00:23,706 --> 00:00:28,826
It's our goal to provide
you guys with the protocol


8
00:00:28,826 --> 00:00:30,146
and networking support
that you need


9
00:00:30,146 --> 00:00:31,756
to make great applications
on our platform.


10
00:00:31,756 --> 00:00:33,846
And, of course, we use
these APIs ourselves.


11
00:00:35,246 --> 00:00:36,786
Here's a standard picture


12
00:00:36,786 --> 00:00:39,516
of what frameworks look
like on our system.


13
00:00:40,046 --> 00:00:41,286
Your application sits on top,


14
00:00:41,806 --> 00:00:45,606
and nowadays you're also having
extensions that are sitting


15
00:00:45,606 --> 00:00:46,836
on top of all these frameworks.


16
00:00:46,916 --> 00:00:48,816
Extensions are particularly
interesting


17
00:00:48,816 --> 00:00:49,916
for background networking


18
00:00:50,666 --> 00:00:53,646
because when your extension
terminates, you might still need


19
00:00:53,646 --> 00:00:55,826
to have work done, and you
can use background networking


20
00:00:55,946 --> 00:01:00,026
through NSURLSession
to get that work done.


21
00:01:00,376 --> 00:01:02,956
Looking at the different
levels that actually make


22
00:01:03,016 --> 00:01:05,926
up Foundation Networking,
that we start


23
00:01:06,296 --> 00:01:09,856
with the Core OS BSD
networking layer.


24
00:01:09,856 --> 00:01:13,806
This is the lowest level that
sockets its bind, its addresses.


25
00:01:14,346 --> 00:01:15,996
It's kind of like
building a car from a kit.


26
00:01:16,836 --> 00:01:22,546
Back when Mac OS started,
we took the foundation layer


27
00:01:22,786 --> 00:01:25,776
of things from NeXTSTEP,
and we said, "Well,


28
00:01:25,776 --> 00:01:26,996
we need something
that's a C API."


29
00:01:26,996 --> 00:01:28,626
And CoreFoundation
came out of that.


30
00:01:28,626 --> 00:01:29,856
And CFNetwork came out of that.


31
00:01:30,596 --> 00:01:32,976
As time has gone
on, we find more


32
00:01:32,976 --> 00:01:35,196
and more developers want
a higher level approach.


33
00:01:35,196 --> 00:01:38,536
Foundation and Foundation
Networking provides


34
00:01:40,106 --> 00:01:44,846
NSURLSession, replacing
NSURLConnection, NSStream,


35
00:01:44,846 --> 00:01:50,766
and NSNetServices as
Cocoa-style APIs for developers


36
00:01:50,766 --> 00:01:53,726
to use on Mac OS X and iOS.


37
00:01:55,916 --> 00:01:58,616
These APIs serve
different purposes.


38
00:01:59,436 --> 00:02:05,926
NSStream is an API that is used
to synch bytes into the system


39
00:02:05,926 --> 00:02:07,686
in various places
or to receive bytes


40
00:02:07,796 --> 00:02:09,936
out when you maybe
don't have an idea


41
00:02:09,936 --> 00:02:10,996
of how many bytes there are.


42
00:02:11,556 --> 00:02:12,976
You could have a file
on disk and you know


43
00:02:12,976 --> 00:02:14,026
that it's a certain size.


44
00:02:14,076 --> 00:02:17,486
So you create an
NSInputStream from a file.


45
00:02:18,216 --> 00:02:20,676
Or you could receive an
NSInputStream from an API.


46
00:02:20,676 --> 00:02:23,916
You don't know how big it is,
so you schedule the stream


47
00:02:23,916 --> 00:02:27,016
and then you start
reading bytes out of it.


48
00:02:27,016 --> 00:02:30,676
NSNetServices is an
API that allows you


49
00:02:30,926 --> 00:02:35,196
to do peer-to-peer servers
and clients on your machine,


50
00:02:35,196 --> 00:02:36,876
on your device, talking
to other devices.


51
00:02:36,876 --> 00:02:39,596
It's a great way
of publishing work


52
00:02:39,596 --> 00:02:42,066
that you want other apps to do.


53
00:02:42,066 --> 00:02:47,036
NSURLSession provides sort
of a message-based delivery.


54
00:02:47,236 --> 00:02:50,246
You're talking about putting
a request on the network


55
00:02:50,246 --> 00:02:53,616
and receiving a response
and some data code.


56
00:02:53,616 --> 00:02:57,936
In this talk, we're going
to talk about those APIs:


57
00:02:58,086 --> 00:03:00,986
NSStream NSNetServices
and NSURLSession.


58
00:03:00,986 --> 00:03:02,786
We're going to review
NSURLSession,


59
00:03:02,786 --> 00:03:04,406
which is what we
introduced last year.


60
00:03:04,796 --> 00:03:06,056
So there will be a
bit of review here.


61
00:03:07,416 --> 00:03:10,206
We have some new
protocol support,


62
00:03:10,206 --> 00:03:12,826
and if you saw Craig's
talk yesterday,


63
00:03:13,296 --> 00:03:16,526
there's on one slide there was a
little mention of a new protocol


64
00:03:16,526 --> 00:03:17,216
that we'll talk about.


65
00:03:17,936 --> 00:03:19,626
And lastly we're going to
spend some time talking


66
00:03:19,626 --> 00:03:22,556
about the best way
to use NSURLSession


67
00:03:22,556 --> 00:03:23,486
and background networking.


68
00:03:24,526 --> 00:03:26,736
Let's get the new APIs
out of the way first.


69
00:03:27,186 --> 00:03:29,056
NSNetServices has
a single, new API.


70
00:03:29,056 --> 00:03:32,476
But it's not really new because
it was available last year


71
00:03:32,476 --> 00:03:33,236
in iOS 7.


72
00:03:33,866 --> 00:03:35,826
This year includes
peer-to-peer is available


73
00:03:35,826 --> 00:03:39,306
on Mac OS X Yosemite on
hardware that supports it


74
00:03:39,306 --> 00:03:42,376
which is recent, 2012
or later Mac hardware.


75
00:03:42,936 --> 00:03:44,826
That's really the only
API change available,


76
00:03:44,826 --> 00:03:48,846
but it is now available
for you to use.


77
00:03:48,916 --> 00:03:51,426
NSStream gets two new APIs.


78
00:03:51,636 --> 00:03:57,876
Now NSStream is-it's Toll-Free
Bridged with CFStream,


79
00:03:57,876 --> 00:04:00,576
which means that there's a lower
level API that this works with.


80
00:04:02,016 --> 00:04:03,366
But at some point
we lost the ability


81
00:04:03,366 --> 00:04:06,336
of just creating a stream
to a host on the internet.


82
00:04:06,776 --> 00:04:09,996
So adding back a new
API gets streams to host


83
00:04:09,996 --> 00:04:11,726
with name specifying a port.


84
00:04:11,726 --> 00:04:15,056
Then the host could
be a dotted IP,


85
00:04:15,186 --> 00:04:16,906
IPv6 or regular internet
host name.


86
00:04:17,856 --> 00:04:19,946
The result is an inputStream
and an outputStream


87
00:04:19,946 --> 00:04:23,396
that you then open,
schedule, and read and write


88
00:04:23,396 --> 00:04:24,866
from as those streams get opened


89
00:04:25,166 --> 00:04:26,776
or if you pass on
to another layer.


90
00:04:27,506 --> 00:04:30,126
So, for instance, if you had an
audio streaming app that wanted


91
00:04:30,126 --> 00:04:33,046
to read bytes off of a network
resource that was providing you


92
00:04:33,046 --> 00:04:37,736
with audio data, you could use
this API to get an NSInputStream


93
00:04:37,736 --> 00:04:39,016
from that and pass


94
00:04:39,016 --> 00:04:41,056
that NSInputStream off
to the audio player.


95
00:04:42,286 --> 00:04:45,066
Well, if you had bytes that you
were generating that you wanted


96
00:04:45,136 --> 00:04:48,016
to send into that audio
player, or if you wanted


97
00:04:48,016 --> 00:04:49,496
to filter those bytes,
you might need


98
00:04:49,496 --> 00:04:51,096
to implement your own NSStream.


99
00:04:51,556 --> 00:04:53,366
You could do that by
subclassing NSStream


100
00:04:53,666 --> 00:04:55,396
or the preferred
way we'd want you


101
00:04:55,666 --> 00:04:58,556
to do it is creating what
we call a "bound pair".


102
00:04:58,866 --> 00:05:00,976
That creates an input and
output stream and a buffer.


103
00:05:01,726 --> 00:05:03,896
So you'll write bytes
into the output stream,


104
00:05:04,286 --> 00:05:07,446
and the audio unit or whatever
it is will consume the bytes


105
00:05:07,666 --> 00:05:08,646
out of the input stream.


106
00:05:09,386 --> 00:05:11,136
So that's just a
couple of new APIs


107
00:05:11,216 --> 00:05:13,996
in NSNetServices and NSStream.


108
00:05:15,416 --> 00:05:17,056
I'm going to talk
about NSURLSession.


109
00:05:17,246 --> 00:05:19,366
And a lot of this is
review from last year.


110
00:05:20,016 --> 00:05:22,066
NSURLSession is sort
of a big machine


111
00:05:22,216 --> 00:05:23,906
that has a lot of moving parts.


112
00:05:24,406 --> 00:05:27,296
And in this picture it
kind of looks like a boat.


113
00:05:28,116 --> 00:05:31,416
It's an object that you
create with a configuration


114
00:05:31,416 --> 00:05:33,376
and it references
storage objects.


115
00:05:33,376 --> 00:05:36,416
The storage objects are
needed to supply information


116
00:05:36,416 --> 00:05:38,106
about how to perform a load.


117
00:05:38,766 --> 00:05:39,626
Well, if it's a boat,


118
00:05:39,626 --> 00:05:41,126
the captain of the
boat is your delegate


119
00:05:41,126 --> 00:05:43,266
that you bind into the system.


120
00:05:43,876 --> 00:05:47,706
The purpose of this boat as it's
running along is to take data


121
00:05:47,706 --> 00:05:51,326
in a request and to produce
responses and data objects out.


122
00:05:51,706 --> 00:05:55,096
So it's like carrying
passengers and a duty-free shop


123
00:05:55,096 --> 00:05:57,076
out the other side where
you get whatever it is


124
00:05:57,226 --> 00:05:58,736
that you're getting.


125
00:05:59,506 --> 00:05:59,656
All right.


126
00:06:00,136 --> 00:06:02,036
So the concepts of
an NSURLSession.


127
00:06:02,036 --> 00:06:03,986
The session object itself.


128
00:06:04,196 --> 00:06:05,896
The API is called
an NSURLSession.


129
00:06:06,316 --> 00:06:08,986
The main factory class is
called an NSURLSession.


130
00:06:09,826 --> 00:06:12,606
An NSURLSessionClass is created


131
00:06:12,606 --> 00:06:14,926
with an NSURLSession
configuration object.


132
00:06:15,586 --> 00:06:18,556
The configuration object is
a dictionary of properties


133
00:06:19,366 --> 00:06:23,716
that dictate things like the
how many connections we can make


134
00:06:23,716 --> 00:06:24,276
to a server.


135
00:06:24,366 --> 00:06:26,476
What kind of SSL
we're going to use.


136
00:06:26,476 --> 00:06:28,876
What storage objects
we're going to use.


137
00:06:29,336 --> 00:06:32,746
The session creates
task objects.


138
00:06:32,746 --> 00:06:36,706
These represent the
sort of transient state


139
00:06:37,016 --> 00:06:38,556
of a resource as
it's being loaded.


140
00:06:39,186 --> 00:06:42,756
A task object is created
from a request or a URL.


141
00:06:42,856 --> 00:06:45,276
And its initial state
is suspended.


142
00:06:45,276 --> 00:06:48,436
You resume it; it does its
work within the session,


143
00:06:48,726 --> 00:06:50,366
conferring with your
delegate as needed,


144
00:06:50,786 --> 00:06:53,306
and in the end the
task becomes finished.


145
00:06:53,906 --> 00:06:56,326
And you're done;
you've got your data.


146
00:06:57,066 --> 00:07:00,496
Okay. The delegate itself
is something you supply.


147
00:07:00,496 --> 00:07:04,716
The delegate is has
to conform to a bunch


148
00:07:04,716 --> 00:07:05,836
of different protocols.


149
00:07:05,836 --> 00:07:07,626
There are protocols
for session, for task


150
00:07:07,626 --> 00:07:09,246
and for the various
task subclasses.


151
00:07:10,826 --> 00:07:15,976
There are storage objects that
exist in the system by default.


152
00:07:15,976 --> 00:07:18,696
There is a Keychain-based
credential store.


153
00:07:19,436 --> 00:07:21,926
There is a cookie
store-a cookie jar.


154
00:07:22,306 --> 00:07:25,706
Cookies are sort of a degenerate
form of authentication.


155
00:07:26,196 --> 00:07:27,976
They serve the same purpose.


156
00:07:27,976 --> 00:07:30,416
They identify you to a
website, and allow that website


157
00:07:30,416 --> 00:07:34,186
to communicate with you in
what it thinks is a secure way.


158
00:07:35,816 --> 00:07:39,626
Protocols are objects that you
can register with a session


159
00:07:40,306 --> 00:07:42,586
that override the
default behavior


160
00:07:42,586 --> 00:07:43,876
or provide additional behavior.


161
00:07:43,876 --> 00:07:48,746
So a URL looks like "HTTP:",
your protocol could be "MOOF:"


162
00:07:48,746 --> 00:07:52,296
and you could deal with MOOF
protocols however you want,


163
00:07:53,056 --> 00:07:56,176
including rewriting them
to become HTTP protocols.


164
00:07:58,886 --> 00:08:01,546
Lastly, there's the URL cache
object, which is what we're able


165
00:08:01,546 --> 00:08:04,476
to consult in order to avoid
going out on the network at all.


166
00:08:05,596 --> 00:08:08,896
In NSURLSession, the other
configuration object,


167
00:08:08,976 --> 00:08:11,386
you can specify your
own subclasses for all


168
00:08:11,386 --> 00:08:12,866
of these storage objects.


169
00:08:13,616 --> 00:08:19,946
The configuration object
itself, as I mentioned,


170
00:08:19,996 --> 00:08:23,146
it basically is a dictionary
although it is comprised


171
00:08:23,146 --> 00:08:24,946
of a bunch of property
attributes.


172
00:08:25,706 --> 00:08:28,796
When you create one, when you
get a configuration object,


173
00:08:28,796 --> 00:08:30,106
you modify it however you want.


174
00:08:30,146 --> 00:08:31,686
And then you're going
to create a session


175
00:08:31,686 --> 00:08:32,905
with that configuration.


176
00:08:33,426 --> 00:08:35,535
Once you've created a
session with a configuration,


177
00:08:35,796 --> 00:08:36,895
you can't modify it again.


178
00:08:37,296 --> 00:08:39,895
These are some of the
attributes that you can change


179
00:08:39,895 --> 00:08:43,306
within a configuration: the
TLS levels, whether you want


180
00:08:43,306 --> 00:08:46,616
to support the latest TLS
level, restrict it to that,


181
00:08:46,616 --> 00:08:49,616
or to allow the previous
one, whether or not


182
00:08:49,726 --> 00:08:53,636
to allow a request to go over
the network (cell network).


183
00:08:53,636 --> 00:08:57,016
Network service type is,
well, "I'm doing video data.


184
00:08:57,016 --> 00:08:58,886
I want a higher priority
if that's available."


185
00:09:00,356 --> 00:09:03,416
I won't try and list all
the configuration options,


186
00:09:03,456 --> 00:09:04,396
because there are quite a few


187
00:09:04,396 --> 00:09:08,266
and they're all in
the header file.


188
00:09:08,266 --> 00:09:09,826
To get a configuration object,


189
00:09:09,826 --> 00:09:11,936
you can ask for the default
session configuration.


190
00:09:11,936 --> 00:09:13,946
This is a factory method
that returns an object


191
00:09:14,546 --> 00:09:17,476
that captures the global
state of the framework.


192
00:09:17,476 --> 00:09:19,316
If you look at the
Foundation Framework,


193
00:09:19,316 --> 00:09:23,026
there are some classes like
NSData that have a class method,


194
00:09:23,086 --> 00:09:24,516
NSData dataWithContentsOfURL.


195
00:09:24,576 --> 00:09:28,246
If you were to pass
an HTTP URL into that,


196
00:09:28,686 --> 00:09:30,626
it would use all
the global defaults


197
00:09:30,626 --> 00:09:32,836
of the Foundation
Framework in order to go


198
00:09:32,836 --> 00:09:34,686
out on the network
and get that data.


199
00:09:35,196 --> 00:09:38,626
Never call that API because
it blocks and it will end


200
00:09:38,626 --> 00:09:41,506
up hanging whatever thread
you're executing it on.


201
00:09:41,506 --> 00:09:44,436
The point is that that
configuration is what the


202
00:09:44,436 --> 00:09:46,426
default session configuration
represents.


203
00:09:47,546 --> 00:09:49,986
If you get a default session
configuration and modify it,


204
00:09:50,386 --> 00:09:52,606
you're only modifying
that configuration.


205
00:09:52,606 --> 00:09:55,246
You're not modifying the
global configuration.


206
00:09:56,836 --> 00:09:59,526
There's a factory method for an
ephemeral session configuration.


207
00:09:59,926 --> 00:10:02,066
This is set up so that none


208
00:10:02,066 --> 00:10:05,536
of the storage objects
actually persist data to this.


209
00:10:06,026 --> 00:10:08,246
You would use it in private
browsing, for instance.


210
00:10:09,206 --> 00:10:13,426
The third factory method is used
to create a background session.


211
00:10:13,986 --> 00:10:17,676
You specify an identifier
which is a string that,


212
00:10:17,676 --> 00:10:22,906
when your app is re-launched,
you use the same string in order


213
00:10:23,056 --> 00:10:26,396
to get re-associated with that
session in the background.


214
00:10:26,896 --> 00:10:28,936
Then you'll start receiving
events for that session.


215
00:10:30,366 --> 00:10:32,036
There's a factory
method for a session


216
00:10:32,036 --> 00:10:33,116
that gives you a shared session.


217
00:10:33,116 --> 00:10:34,506
The shared session is, well,


218
00:10:34,876 --> 00:10:40,806
going back to that NSData
dataWithContentsOfURL example,


219
00:10:41,406 --> 00:10:43,576
that would be using the
shared session to do its work.


220
00:10:43,646 --> 00:10:47,076
It's representing the
global environment.


221
00:10:47,076 --> 00:10:50,036
It's a very handy thing
to use when you just want


222
00:10:50,036 --> 00:10:51,316
to get a resource
off the network.


223
00:10:52,986 --> 00:10:55,016
Once you have a configuration
object that's set up though,


224
00:10:55,016 --> 00:10:57,056
you might want to create
a session all your own


225
00:10:57,616 --> 00:10:59,726
that uses only your
own resources


226
00:10:59,826 --> 00:11:01,906
and maybe only your
own storage classes.


227
00:11:03,146 --> 00:11:05,096
You don't have to specify
a delegate though, because,


228
00:11:05,096 --> 00:11:06,606
as we're going to talk
about in a few minutes,


229
00:11:07,036 --> 00:11:09,086
there's some asynchronous
convenience routines


230
00:11:09,616 --> 00:11:12,966
that don't require you
to implement a delegate


231
00:11:13,306 --> 00:11:14,746
with your NSURLSessions.


232
00:11:16,226 --> 00:11:20,256
But if you do specify a
delegate, which you need to do


233
00:11:20,256 --> 00:11:24,256
for background transfers,
then this is the API you use:


234
00:11:24,386 --> 00:11:25,996
sessionWithConfiguration passing


235
00:11:25,996 --> 00:11:28,136
of a delegate and
a delegateQueue.


236
00:11:28,136 --> 00:11:30,096
And a delegateQueue can
be a concurrent queue.


237
00:11:30,696 --> 00:11:35,416
So, task objects themselves.


238
00:11:35,416 --> 00:11:37,726
The session creates
task objects.


239
00:11:38,136 --> 00:11:40,686
There's a base class task object
that has a couple of methods:


240
00:11:41,166 --> 00:11:43,266
-cancel, -suspend, and -resume.


241
00:11:43,826 --> 00:11:46,316
When a task object is
created, it is suspended.


242
00:11:46,436 --> 00:11:48,476
You have to send it the
resume message in order


243
00:11:48,476 --> 00:11:49,376
for it to start working.


244
00:11:49,816 --> 00:11:53,256
There are two subclasses,
which are really only available


245
00:11:54,836 --> 00:11:57,866
for the purposes of providing
some sort of semantic glue.


246
00:11:58,276 --> 00:12:02,706
Currently, there's a
delegate for data tasks,


247
00:12:02,756 --> 00:12:06,486
but there's no delegate specific
for download-for upload tasks.


248
00:12:06,606 --> 00:12:09,346
But if there were in the future,
we would have the ability


249
00:12:09,346 --> 00:12:10,976
to differentiate
between the types.


250
00:12:11,806 --> 00:12:13,276
There's also a download task.


251
00:12:13,476 --> 00:12:14,976
And all this adds on top


252
00:12:14,976 --> 00:12:18,816
of the normal task object is
cancelByProducingResumeData.


253
00:12:19,476 --> 00:12:23,136
When a download is
cancelled if you use this API,


254
00:12:24,046 --> 00:12:26,536
we're able to capture the
state of the download and,


255
00:12:26,536 --> 00:12:29,526
at a later time, you can
create a download task using


256
00:12:29,526 --> 00:12:31,236
that resumeData and avoid having


257
00:12:31,236 --> 00:12:34,386
to download all those bytes
again if the server supports it


258
00:12:34,386 --> 00:12:37,136
and if the conditions warrant
it and blah, blah, blah.


259
00:12:37,136 --> 00:12:38,866
There are all sorts of reasons
why that might not work.


260
00:12:39,366 --> 00:12:41,336
But if you want it to
have a chance of working,


261
00:12:41,336 --> 00:12:43,126
this is how you'd
get that resumeData.


262
00:12:44,566 --> 00:12:49,546
To create task objects from
a session, dataTaskWithURL:


263
00:12:49,546 --> 00:12:53,126
You just give it an
arbitrary URL-HTTP, MOOF,


264
00:12:53,236 --> 00:12:55,586
whatever is going to be
supported by the protocols.


265
00:12:56,886 --> 00:13:00,786
dataWithRequest, which takes
an NSURLRequest, which is sort


266
00:13:00,786 --> 00:13:06,956
of the older way of specifying
binding a URL with a method


267
00:13:07,376 --> 00:13:11,336
or however your protocol is
going to interpret that request.


268
00:13:12,696 --> 00:13:16,596
Upload tasks are similar,
except that we don't allow you


269
00:13:16,596 --> 00:13:18,206
to create an upload
task from a URL.


270
00:13:18,206 --> 00:13:20,836
You have to create an
upload task from a request


271
00:13:20,996 --> 00:13:23,716
where you've specified the
method like post or put.


272
00:13:25,106 --> 00:13:27,606
We give you the option of
performing an upload from a file


273
00:13:27,606 --> 00:13:29,396
or a data; either
of these are great.


274
00:13:30,156 --> 00:13:33,276
But we also give you the option
of creating an upload task


275
00:13:33,406 --> 00:13:36,436
with a stream-we say
"streamed request".


276
00:13:36,526 --> 00:13:40,396
That means we're going to ask
your delegate for a stream


277
00:13:40,566 --> 00:13:42,606
when we're ready
to write the bytes


278
00:13:42,876 --> 00:13:45,596
of your upload to the network.


279
00:13:46,356 --> 00:13:48,136
The reason we have to do that is


280
00:13:48,136 --> 00:13:50,326
because sometimes we will
open a connection to a server


281
00:13:50,326 --> 00:13:51,266
and we'll start writing bytes.


282
00:13:51,266 --> 00:13:54,236
And the server will come
back and off-challenge us.


283
00:13:54,426 --> 00:13:56,026
And we'll have to talk
with your delegate.


284
00:13:56,436 --> 00:13:58,236
But at that point we've
already sent bytes along.


285
00:13:58,926 --> 00:14:01,266
And if we're doing an
upload from a stream,


286
00:14:01,686 --> 00:14:03,206
we're going to have to
throw that stream away


287
00:14:03,266 --> 00:14:04,716
and ask your delegate
for a new one.


288
00:14:05,266 --> 00:14:08,406
If we did the upload from a
file or from a data object,


289
00:14:08,796 --> 00:14:10,386
we know how to restart
that stream


290
00:14:10,446 --> 00:14:12,096
without having to
ask you for it.


291
00:14:12,566 --> 00:14:17,716
If you're trying to do uploads
for background transfers,


292
00:14:18,106 --> 00:14:20,666
you have to do it from a file
because we want to capture


293
00:14:20,666 --> 00:14:22,656
that file so we can upload
it in the background.


294
00:14:25,516 --> 00:14:26,616
Download tasks are similar.


295
00:14:26,616 --> 00:14:27,846
You can download from a URL.


296
00:14:27,846 --> 00:14:31,686
I want to copy: I want a URL
that goes from, you know,


297
00:14:31,686 --> 00:14:38,106
my big file .tgz or from an
NSURLRequest or create it


298
00:14:38,106 --> 00:14:39,746
from a resumeData block.


299
00:14:39,746 --> 00:14:42,256
And that gives you
back a downloadTask


300
00:14:42,256 --> 00:14:43,016
which you then resume.


301
00:14:44,786 --> 00:14:48,686
The lifecycle of a data
task starts out suspended,


302
00:14:48,686 --> 00:14:52,016
referencing the request that
we're going to deal with.


303
00:14:52,926 --> 00:14:54,636
You tell it, "Okay, resume."


304
00:14:54,686 --> 00:14:55,656
The state goes to running.


305
00:14:56,106 --> 00:14:57,886
And then the delegate
starts getting called.


306
00:14:57,886 --> 00:14:59,296
didReceiveResponse occurs.


307
00:14:59,706 --> 00:15:02,826
It handed you the response, and
the response is also available


308
00:15:02,826 --> 00:15:04,656
as a property on
the task object.


309
00:15:05,426 --> 00:15:09,316
As data comes in, will call
didReceiveData delegate message


310
00:15:09,316 --> 00:15:10,516
0 or more times.


311
00:15:11,156 --> 00:15:16,006
If the task is in a
session that was enabled


312
00:15:16,006 --> 00:15:17,356
that has enabled caching,


313
00:15:17,846 --> 00:15:19,466
we're going to call
your willCacheResponse.


314
00:15:19,466 --> 00:15:20,696
This gives you the
opportunity to say,


315
00:15:20,696 --> 00:15:23,116
"It's for a particular
resource," "I don't want


316
00:15:23,116 --> 00:15:26,596
to cache this," or you want
to modify the cache response,


317
00:15:27,296 --> 00:15:29,946
but we're going to call that
at this point before we call


318
00:15:29,946 --> 00:15:31,856
didCompleteWithError
and the state


319
00:15:31,856 --> 00:15:33,016
of the task goes to finish.


320
00:15:33,856 --> 00:15:35,776
One thing to note,
didCompleteWithError


321
00:15:35,776 --> 00:15:39,176
as the final thing that gets
sent to your delegate on behalf


322
00:15:39,176 --> 00:15:41,756
of the task, the error
is going to be nil


323
00:15:42,406 --> 00:15:44,756
if the server gave
us a valid response.


324
00:15:44,756 --> 00:15:47,696
A valid response
would be 200 OK.


325
00:15:48,266 --> 00:15:51,706
But a valid response is
also 404 FileNotFound.


326
00:15:51,926 --> 00:15:55,296
Because the body that came back
might be interesting to you.


327
00:15:55,296 --> 00:15:56,976
You might want to
display that body.


328
00:15:57,986 --> 00:16:00,396
The error parameter
here then is strictly


329
00:16:00,396 --> 00:16:03,546
for transmission errors, like,
the host cannot be resolved,


330
00:16:04,076 --> 00:16:05,796
or a timeout occurred,


331
00:16:06,326 --> 00:16:09,756
or you cancelled the task
while it was in flight.


332
00:16:09,756 --> 00:16:13,656
When you look at the error here,
it's going to contain, well,


333
00:16:13,656 --> 00:16:15,836
the reason why the transfer
failed, and you should assume


334
00:16:15,836 --> 00:16:18,616
that the response and the data
that you got back are invalid.


335
00:16:19,476 --> 00:16:22,276
A download task works
very similarly.


336
00:16:22,276 --> 00:16:24,286
You create a download task.


337
00:16:24,286 --> 00:16:26,356
In this case, you reference some
file that you're going to get,


338
00:16:26,356 --> 00:16:29,946
and it starts doing its work
as soon as you say resume-yeah,


339
00:16:29,946 --> 00:16:31,476
you send it the resume message.


340
00:16:31,706 --> 00:16:32,546
So it goes to running


341
00:16:33,166 --> 00:16:35,766
and it will periodically
call didWriteData.


342
00:16:35,766 --> 00:16:37,726
It will tell you, "Yes,
I'm making progress


343
00:16:37,806 --> 00:16:39,166
on this download as it's going."


344
00:16:39,646 --> 00:16:41,696
Note that this is also
what's going to happen


345
00:16:41,696 --> 00:16:42,986
for a background download.


346
00:16:42,986 --> 00:16:45,716
If this task were created
for a background download


347
00:16:45,716 --> 00:16:47,296
and your app is running,
you're going


348
00:16:47,296 --> 00:16:49,516
to receive didWriteData
callbacks.


349
00:16:50,376 --> 00:16:52,596
Finally, we've written
all the bytes


350
00:16:52,596 --> 00:16:54,756
of this file to the file system.


351
00:16:55,186 --> 00:16:57,586
We're going to invoke the
didFinishDownloadingToURL


352
00:16:57,586 --> 00:16:57,906
message.


353
00:16:57,906 --> 00:17:00,986
And we're going to give you
a file URL in your container.


354
00:17:01,746 --> 00:17:03,696
You have to move that to
a more permanent location.


355
00:17:03,856 --> 00:17:05,616
Move the file to a
more permanent location


356
00:17:05,616 --> 00:17:08,566
in your container because, when
you return from this delegate,


357
00:17:08,906 --> 00:17:09,836
we're going to delete the file.


358
00:17:10,856 --> 00:17:13,336
Then we will call
didCompleteWithError:nil,


359
00:17:13,336 --> 00:17:18,996
because we successfully got
the file all the way to disk.


360
00:17:18,996 --> 00:17:22,356
Creating NSURLSessionTasks
can be done just-you know,


361
00:17:22,506 --> 00:17:24,675
throw a request in,
get a task out.


362
00:17:25,016 --> 00:17:27,246
But there's some convenience
routines that are really handy,


363
00:17:27,496 --> 00:17:29,006
especially when you
have a session


364
00:17:29,006 --> 00:17:30,826
that doesn't use a
delegate or, I should say,


365
00:17:31,496 --> 00:17:34,376
particularly you can only
use these with a session


366
00:17:34,376 --> 00:17:37,896
that doesn't have a delegate.


367
00:17:37,896 --> 00:17:40,256
So you say
dataTaskWithURL:completion


368
00:17:40,296 --> 00:17:41,656
and you give it a
completionHandler.


369
00:17:42,536 --> 00:17:46,216
The task object that comes
back has to be resumed.


370
00:17:46,856 --> 00:17:51,396
But it doesn't bother calling
any of the delegate messages


371
00:17:51,396 --> 00:17:54,556
that might be in the
session, or it might not.


372
00:17:54,556 --> 00:17:58,376
And when the work is done it
invokes your completionHandler.


373
00:17:58,376 --> 00:18:02,626
This is true for, you know,
with an upload via file or data,


374
00:18:03,086 --> 00:18:06,076
or a download to disk.


375
00:18:06,336 --> 00:18:06,886
In that case,


376
00:18:06,886 --> 00:18:09,746
the completionHandler
references the file.


377
00:18:09,746 --> 00:18:12,556
And, like the delegate for
didFinish LoadingToFile,


378
00:18:13,006 --> 00:18:14,396
you have to move that file away.


379
00:18:15,596 --> 00:18:18,216
This is what this looks like
(the convenience routines).


380
00:18:18,216 --> 00:18:20,436
Very simply you just create
a URL that you're going


381
00:18:20,436 --> 00:18:21,976
to request off the network.


382
00:18:22,736 --> 00:18:25,166
In this case I'm going to create
a configuration object using the


383
00:18:25,166 --> 00:18:28,866
ephemeralSessionConfiguration
prototype object.


384
00:18:29,346 --> 00:18:31,736
I don't want to store anything
and I don't want anybody


385
00:18:31,736 --> 00:18:32,986
to know about this resource.


386
00:18:33,116 --> 00:18:35,396
I'm going to create
a private session.


387
00:18:35,806 --> 00:18:37,586
And then I'm going
to create a task


388
00:18:37,586 --> 00:18:39,846
with that private
session and with that URL.


389
00:18:40,086 --> 00:18:43,626
So I tell the session,
dataTaskWithURL, "Here's my URL.


390
00:18:43,626 --> 00:18:44,776
Here's my completionHandler."


391
00:18:45,216 --> 00:18:47,256
The signature for the
completionHandler is data,


392
00:18:47,826 --> 00:18:48,936
response and error.


393
00:18:49,946 --> 00:18:52,406
Error will be nil if data
and response are valid.


394
00:18:54,056 --> 00:18:56,846
I resume the task, and then I go
back to running in the run loop.


395
00:18:57,186 --> 00:18:59,826
If you were to just exit right
here, nothing would happen


396
00:19:00,096 --> 00:19:01,936
because we're not
doing anything.


397
00:19:01,936 --> 00:19:05,056
We have to run the run loop
or dispatchMain in order


398
00:19:05,056 --> 00:19:07,036
for this completionHandler
to get called.


399
00:19:07,436 --> 00:19:08,846
It gets called and
we're able to deal


400
00:19:08,846 --> 00:19:11,926
with the data that came back.


401
00:19:12,476 --> 00:19:17,056
The delegate that you create a
session with then, is comprised


402
00:19:17,056 --> 00:19:18,816
of a number of different
protocols.


403
00:19:19,506 --> 00:19:22,026
The session level
delegate is sort


404
00:19:22,026 --> 00:19:24,006
of meta information
about the session.


405
00:19:24,736 --> 00:19:27,766
When a session is created,
it might become invalid.


406
00:19:27,826 --> 00:19:29,246
You can send an "invalidate"
message,


407
00:19:29,246 --> 00:19:32,316
in which case the session
invalidation delegate message


408
00:19:32,316 --> 00:19:32,986
will be called.


409
00:19:33,976 --> 00:19:37,316
But there's a more interesting
delegate message sent


410
00:19:37,316 --> 00:19:40,106
to a session delegate, which is


411
00:19:40,106 --> 00:19:41,966
for connection-level
authentication.


412
00:19:42,466 --> 00:19:46,486
If you connected to a website
that has SSL encryption,


413
00:19:47,346 --> 00:19:50,566
we're going to call your
session-level authentication


414
00:19:50,676 --> 00:19:54,016
challengeHandler to ask
whether or not you want


415
00:19:54,016 --> 00:19:55,406
to continue connecting
to a site.


416
00:19:55,956 --> 00:19:58,886
We're going to put multiple
requests on the same socket.


417
00:19:59,006 --> 00:20:02,726
We're not going to make a new
socket and off-challenge you


418
00:20:02,726 --> 00:20:03,986
for each request as they go.


419
00:20:04,026 --> 00:20:07,986
We're going to do it once.


420
00:20:08,126 --> 00:20:11,026
On the basis of each
task, on each request,


421
00:20:11,226 --> 00:20:13,056
there's an
NSURLSessionTaskDelegate.


422
00:20:13,056 --> 00:20:15,006
You can see that these
things are sort of building


423
00:20:15,006 --> 00:20:15,976
on top of one another.


424
00:20:17,146 --> 00:20:19,886
The most important thing
that this delegate responds


425
00:20:19,886 --> 00:20:22,516
to is didFinishLoadingWithError.


426
00:20:23,936 --> 00:20:25,406
And again, if the error is nil,


427
00:20:25,406 --> 00:20:27,666
that means that the
response was valid


428
00:20:28,056 --> 00:20:30,086
and you should deal
with the data.


429
00:20:30,376 --> 00:20:33,426
If the error is not nil, then
something happened that kept us


430
00:20:33,426 --> 00:20:35,026
from being able to
transmit your request.


431
00:20:35,946 --> 00:20:38,546
There is also request
authentication handling here.


432
00:20:39,046 --> 00:20:41,986
If the server says, for
a particular request,


433
00:20:41,986 --> 00:20:44,096
"I don't know how
to deal with you.


434
00:20:44,096 --> 00:20:46,186
I need some credentials
for this request."


435
00:20:46,186 --> 00:20:47,576
It has nothing to do
with any other request,


436
00:20:47,576 --> 00:20:48,346
just this request.


437
00:20:48,796 --> 00:20:52,846
Then that challenge request will
come through this task delegate.


438
00:20:54,646 --> 00:20:58,196
Data delegate then
extends the task delegate.


439
00:20:58,726 --> 00:21:01,726
It's got a couple new
methods that are interesting.


440
00:21:01,726 --> 00:21:03,436
First, didReceiveResponse.


441
00:21:03,746 --> 00:21:06,046
Suppose you're downloading
a file off the network


442
00:21:06,046 --> 00:21:07,926
or downloading data off
the network, and you look


443
00:21:07,926 --> 00:21:10,176
at the content type when
you get the response back.


444
00:21:10,716 --> 00:21:13,206
The content type says
that this is a disk image.


445
00:21:13,776 --> 00:21:14,776
Well, you probably don't want


446
00:21:14,776 --> 00:21:16,156
to read the disk
image all to memory.


447
00:21:16,876 --> 00:21:21,296
The completion routine for this
delegate message allows you


448
00:21:21,296 --> 00:21:25,266
to specify that this data task
should become a download task.


449
00:21:25,266 --> 00:21:26,326
And that's exactly what happens.


450
00:21:26,816 --> 00:21:27,926
We create a download task.


451
00:21:28,036 --> 00:21:31,726
We replace your data task and we
start writing the file to disk.


452
00:21:31,886 --> 00:21:35,256
When the file is completely
written, we treat this task


453
00:21:35,256 --> 00:21:38,126
as if it were a data
task and we notify you


454
00:21:38,126 --> 00:21:39,126
of the file's location.


455
00:21:39,546 --> 00:21:43,956
The bytes that are read off the
network then are sent to you


456
00:21:43,956 --> 00:21:45,346
as didReceiveData callback,


457
00:21:45,506 --> 00:21:47,546
zero or more didReceiveData
callbacks.


458
00:21:47,636 --> 00:21:50,846
One thing to note: you don't
have to copy those datas.


459
00:21:50,846 --> 00:21:52,226
You can keep track of them.


460
00:21:52,226 --> 00:21:53,346
You can reference them.


461
00:21:53,796 --> 00:21:56,176
But you don't need to copy them.


462
00:21:56,176 --> 00:21:58,226
Each of those datas
may, under the scenes,


463
00:21:58,296 --> 00:21:59,646
be discontiguous data.


464
00:21:59,646 --> 00:22:03,456
So you should use the NSData
discontiguous data application


465
00:22:03,456 --> 00:22:06,026
APIs instead of requesting
the byte pointer


466
00:22:06,026 --> 00:22:06,796
to the start of the data.


467
00:22:06,796 --> 00:22:08,826
And that's probably
true with a lot of APIs


468
00:22:08,826 --> 00:22:10,246
that are producing data today.


469
00:22:10,846 --> 00:22:13,306
Behind the scenes, we're trying
to stitch things together


470
00:22:13,366 --> 00:22:15,056
to keep things discontiguous
in memory,


471
00:22:15,356 --> 00:22:17,006
which is a big performance win.


472
00:22:17,296 --> 00:22:21,866
Finally the download delegate
extends the task delegate.


473
00:22:21,866 --> 00:22:23,296
It doesn't receive the bytes,


474
00:22:23,296 --> 00:22:25,406
it receives notification
of the bytes.


475
00:22:25,406 --> 00:22:28,816
In the end, it receives a
delegate message that says,


476
00:22:29,196 --> 00:22:32,796
"Here is the file
location for the data


477
00:22:32,796 --> 00:22:33,676
that we just transferred."


478
00:22:33,716 --> 00:22:38,186
One quick thing that I want to
talk about is the delegate queue


479
00:22:38,186 --> 00:22:39,696
that you created
the session with.


480
00:22:40,366 --> 00:22:43,086
We treated it in iOS 7
and Mac OS X Mavericks


481
00:22:43,086 --> 00:22:43,966
as a serial queue.


482
00:22:43,966 --> 00:22:48,286
Every time a task had
something to do, it would call


483
00:22:48,286 --> 00:22:49,996
into your delegate and
wait for that to return.


484
00:22:50,556 --> 00:22:52,506
And go on to the next task
that had some work to do.


485
00:22:53,006 --> 00:22:55,366
The problem with this
approach is that,


486
00:22:55,366 --> 00:22:58,146
if any one of your delegates
stalled for some reason,


487
00:22:58,476 --> 00:23:02,846
like is happening here, then we
have to wait for that delegate


488
00:23:02,846 --> 00:23:06,506
to return before the
next task can come along.


489
00:23:06,976 --> 00:23:12,066
In Mac OS X Yosemite and
iOS 8, we're now going


490
00:23:12,066 --> 00:23:13,576
to treat your queue
as concurrent


491
00:23:13,576 --> 00:23:16,266
if it is a concurrent queue,
as wide as you have specified.


492
00:23:16,406 --> 00:23:18,666
So all of these tasks
are able to call


493
00:23:18,666 --> 00:23:20,186
in to your delegate at once.


494
00:23:20,876 --> 00:23:23,416
No matter what order
they finish, you know,


495
00:23:23,416 --> 00:23:25,756
delegates may finish
at different times.


496
00:23:26,106 --> 00:23:28,946
We're always going to be able to
enqueue work for the next task,


497
00:23:28,946 --> 00:23:30,136
and that's a good thing.


498
00:23:31,836 --> 00:23:33,796
There is a little bit of
new API that I need to talk


499
00:23:33,796 --> 00:23:34,826
about in NSURLSession.


500
00:23:35,956 --> 00:23:39,866
This revolves around
storage objects


501
00:23:39,866 --> 00:23:44,186
like the NSHTTPCookieStorage
and NSURLcredentialStorage


502
00:23:44,636 --> 00:23:47,526
and the NSURLCache as
well as NSURLProtocol.


503
00:23:48,056 --> 00:23:51,176
In each of these cases, we
found that it was insufficient


504
00:23:51,526 --> 00:23:54,146
for the accessors for
these storage objects


505
00:23:54,516 --> 00:23:55,866
to receive just the URL.


506
00:23:56,406 --> 00:23:59,496
People who were subclassing
these objects wanted access


507
00:23:59,546 --> 00:24:01,716
to the task that was
asking the question.


508
00:24:02,316 --> 00:24:05,476
So there's a new category
NSURLSessionTaskAdditions.


509
00:24:06,056 --> 00:24:10,986
If you look in the headers or on
the NSURLLibrary, you're going


510
00:24:11,686 --> 00:24:13,386
to see this category show up,


511
00:24:13,636 --> 00:24:17,656
and it provides asynchronous
gets and, presumably,


512
00:24:17,946 --> 00:24:20,546
asynchronous sets, although
that's an implementation detail.


513
00:24:21,846 --> 00:24:24,076
We'll take NSHTTPCookieStorage
for an example.


514
00:24:24,246 --> 00:24:27,626
So two new methods of
gets: storeCookies:forTask.


515
00:24:27,816 --> 00:24:29,526
Here's an array of
cookies, and I'm doing it


516
00:24:29,556 --> 00:24:31,106
because this task cares.


517
00:24:31,606 --> 00:24:34,016
You look-the implementation
will look in the task,


518
00:24:34,016 --> 00:24:36,336
look at the current
request, get the URL out of


519
00:24:36,336 --> 00:24:37,816
that and do that work.


520
00:24:38,516 --> 00:24:40,546
getCookiesForTask
works the same way.


521
00:24:41,136 --> 00:24:42,586
I would like the
cookies for this task.


522
00:24:43,136 --> 00:24:45,246
But instead of synchronously
responding,


523
00:24:45,606 --> 00:24:46,706
here is a completionHandler.


524
00:24:46,706 --> 00:24:49,686
Once you've got those cookies,
invoke the completionHandler,


525
00:24:50,296 --> 00:24:51,846
and you don't have to block me.


526
00:24:52,766 --> 00:24:56,976
These APIs are available
on NSHTTPCookieStorage,


527
00:24:57,156 --> 00:24:59,166
NSURLCredential and NSURLCache.


528
00:25:00,356 --> 00:25:06,566
As I mentioned earlier, during
the keynote there was a slide


529
00:25:06,566 --> 00:25:10,216
which had one little bit
of interesting stuff in it.


530
00:25:10,216 --> 00:25:13,196
And I'd like to ask Scott
to come on up and tell us


531
00:25:13,196 --> 00:25:14,786
about the new protocol support.


532
00:25:15,376 --> 00:25:16,046
>> Thank you, Steve.


533
00:25:16,506 --> 00:25:17,366
Hello, everyone.


534
00:25:17,366 --> 00:25:19,456
I'm Scott, and today
I'll be talking


535
00:25:19,456 --> 00:25:21,986
about new protocol support
in Foundation Networking.


536
00:25:22,886 --> 00:25:25,136
We've been working hard
to improve the performance


537
00:25:25,136 --> 00:25:28,466
of our HTTP implementation
for our developers-you guys.


538
00:25:28,916 --> 00:25:33,846
And a popular request at last
year's WWDC was to add support


539
00:25:33,846 --> 00:25:35,196
for the SPDY protocol.


540
00:25:35,736 --> 00:25:37,466
Today we're pleased to announce


541
00:25:37,536 --> 00:25:41,056
that the SPDY protocol is
now supported by NSURLSession


542
00:25:41,686 --> 00:25:43,756
on OS X Yosemite and iOS 8.


543
00:25:44,336 --> 00:25:47,296
Not only does this mean that
it's available in Safari


544
00:25:47,296 --> 00:25:49,846
for your day-to-day browsing,
but it's also available


545
00:25:49,846 --> 00:25:51,806
for direct use in your apps.


546
00:25:52,506 --> 00:25:55,866
Even if you don't use
NSURLSession directly


547
00:25:55,866 --> 00:26:00,526
in your applications, keep in
mind that SPDY's also leveraged


548
00:26:00,526 --> 00:26:02,386
through other Apple
frameworks, like UIWebView,


549
00:26:02,386 --> 00:26:04,156
which you might use
in your apps.


550
00:26:04,616 --> 00:26:07,946
For those of you who don't
know what SPDY is already,


551
00:26:08,226 --> 00:26:14,716
it's a protocol that is
designed to make the web faster.


552
00:26:14,806 --> 00:26:17,646
Essentially, what it does is
it changes the on-wire format


553
00:26:17,646 --> 00:26:19,176
of HTTP/1.1.


554
00:26:19,176 --> 00:26:22,426
But the semantics of
HTTP/1.1 stay the same.


555
00:26:22,846 --> 00:26:26,616
So you know about request
types like get, post, put.


556
00:26:26,886 --> 00:26:27,696
Those are the same.


557
00:26:27,936 --> 00:26:30,666
Response codes, like 200
OK, that's still the same.


558
00:26:31,846 --> 00:26:34,086
Caches, cookies,


559
00:26:34,086 --> 00:26:36,466
credentials-those are
also all the same.


560
00:26:37,346 --> 00:26:41,676
SPDY is also serving as the base


561
00:26:41,676 --> 00:26:44,216
for the HTTP/2.0
draft specification.


562
00:26:44,506 --> 00:26:45,576
I'm actually going to come back


563
00:26:45,576 --> 00:26:47,006
to that point a little
bit later on.


564
00:26:47,376 --> 00:26:50,636
But it's interesting to see
where technology and the sort


565
00:26:50,636 --> 00:26:52,426
of development specifications
is heading


566
00:26:52,426 --> 00:26:54,106
as a result of the SPDY work.


567
00:26:55,366 --> 00:26:58,236
Now the way SPDY works at a
very sort of high level is


568
00:26:58,236 --> 00:26:59,516
that it allows for the exchange


569
00:26:59,516 --> 00:27:01,776
of multiple HTTP
messages-both requests


570
00:27:01,776 --> 00:27:05,466
and responses-simultaneously
and potentially out of order,


571
00:27:05,796 --> 00:27:07,426
all over a single
TCP connection.


572
00:27:08,306 --> 00:27:11,676
So if you'd like to use
SPDY in your applications,


573
00:27:11,766 --> 00:27:12,776
here is what you need to know.


574
00:27:13,256 --> 00:27:18,166
As I mentioned, it's available
on both OS X Yosemite and iOS 8.


575
00:27:18,166 --> 00:27:20,476
And we support three versions


576
00:27:20,476 --> 00:27:24,676
of the SPDY protocol:
2, 3, and 3.1.


577
00:27:24,676 --> 00:27:29,306
And what we've decided to do is
make it supported transparently


578
00:27:29,306 --> 00:27:30,376
by NSURLSession.


579
00:27:30,946 --> 00:27:34,156
So this goes along the lines
of a philosophy we have.


580
00:27:34,306 --> 00:27:37,906
Which is that we will always
pick the best protocol we should


581
00:27:37,906 --> 00:27:40,026
use when communicating
with your server.


582
00:27:40,516 --> 00:27:42,696
Currently, that means we're
going to decide if it's going


583
00:27:42,696 --> 00:27:45,996
to be HTTP/1.1 or SPDY
and the version of SPDY


584
00:27:45,996 --> 00:27:46,956
that we're going to use.


585
00:27:47,276 --> 00:27:49,096
But this could also
hold true in the future


586
00:27:49,096 --> 00:27:52,206
for some other protocol.


587
00:27:52,416 --> 00:27:55,066
What this means for you is that
no source changes are needed.


588
00:27:55,576 --> 00:27:56,456
It will just work.


589
00:27:57,116 --> 00:28:02,456
If we look at a source code
example here, what you do first,


590
00:28:02,456 --> 00:28:03,776
of course, is create your URL


591
00:28:04,126 --> 00:28:06,716
for whatever resource
you'd be interested


592
00:28:06,746 --> 00:28:07,806
in fetching from your server.


593
00:28:08,576 --> 00:28:10,476
And then you'd construct
a session task.


594
00:28:10,886 --> 00:28:13,806
In this case we're using
a data task-in this case,


595
00:28:13,806 --> 00:28:17,136
also with the shared session-and
then having a completionHandler


596
00:28:17,136 --> 00:28:19,116
with the data you'd
receive, the response


597
00:28:19,116 --> 00:28:20,886
and a transmission
error if there was one.


598
00:28:22,066 --> 00:28:24,956
Of course, you then have to
resume the task to start it.


599
00:28:26,236 --> 00:28:28,546
What you'll notice about this
code sample is there's nothing


600
00:28:28,806 --> 00:28:31,026
different here because
SPDY is going to be used.


601
00:28:31,316 --> 00:28:33,346
There isn't some code
that I added, changed,


602
00:28:33,346 --> 00:28:35,426
or otherwise removed
to support SPDY.


603
00:28:35,426 --> 00:28:38,016
In fact, this example
should look very similar


604
00:28:38,016 --> 00:28:40,196
to what Steve showed you not
more than a couple minutes ago,


605
00:28:40,486 --> 00:28:41,366
and that's intentional.


606
00:28:42,726 --> 00:28:44,966
I want to dive into
some of SPDY's benefits


607
00:28:44,966 --> 00:28:48,706
so you can understand how it
will actually impact your apps.


608
00:28:49,236 --> 00:28:51,256
The way SPDY works
is it has a single,


609
00:28:51,346 --> 00:28:53,186
long-lived TCP connection


610
00:28:53,246 --> 00:28:55,166
between the client
and the server.


611
00:28:55,366 --> 00:28:58,856
This actually helps to mitigate
latency penalties often times


612
00:28:58,856 --> 00:29:01,656
that are seen when you ask
for additional resources,


613
00:29:01,986 --> 00:29:03,286
because traditionally
we may have had


614
00:29:03,286 --> 00:29:04,666
to open an additional socket


615
00:29:04,666 --> 00:29:07,226
and TCP connection
to get the data back.


616
00:29:07,826 --> 00:29:09,596
But now we have the one
connection that's open


617
00:29:09,596 --> 00:29:10,886
for a longer period of time,


618
00:29:11,146 --> 00:29:12,796
which helps to get
rid of that latency.


619
00:29:13,566 --> 00:29:15,966
It also means that since we're
only opening one connection


620
00:29:15,966 --> 00:29:19,086
to your server, that any given
app instance now should be using


621
00:29:19,086 --> 00:29:22,346
fewer resources on your server,
which is a big win for you.


622
00:29:23,366 --> 00:29:26,686
SPDY supports the
concept of multiplexing,


623
00:29:26,846 --> 00:29:29,896
which is where a request and
response can be interleaved.


624
00:29:30,376 --> 00:29:32,726
Potentially multiple requests
and responses can be interleaved


625
00:29:32,726 --> 00:29:33,876
over a single connection.


626
00:29:34,486 --> 00:29:37,476
This gets rid of what's known
as Head-of-Line Blocking.


627
00:29:38,226 --> 00:29:40,826
This is where, while
you're in the process


628
00:29:40,826 --> 00:29:42,766
of receiving the
response for one object,


629
00:29:42,766 --> 00:29:45,056
that you can't receive
responses for other objects


630
00:29:45,056 --> 00:29:45,976
on the same connection.


631
00:29:46,146 --> 00:29:48,336
For example, you might
be in the process


632
00:29:48,336 --> 00:29:51,046
of downloading a large image,
and that actually then gets


633
00:29:51,046 --> 00:29:53,686
in the way of your ability
to download say a smaller


634
00:29:53,686 --> 00:29:57,026
and more important
Javascript file or CSS file.


635
00:29:58,636 --> 00:30:02,266
Finally, SPDY supports
the notion of priorities.


636
00:30:02,266 --> 00:30:05,406
Now the order in which you
issue requests no longer has


637
00:30:05,406 --> 00:30:08,066
to dictate the order in which
responses are actually received


638
00:30:08,066 --> 00:30:08,966
by your application.


639
00:30:10,436 --> 00:30:13,016
I want to sort of show you
a diagram of how this works.


640
00:30:13,406 --> 00:30:16,086
Keep in mind that this is going
to be sort of an ideal network


641
00:30:16,086 --> 00:30:19,006
where there's no latency and
perfect bandwidth utilization.


642
00:30:19,556 --> 00:30:20,796
We're going to first
start by looking


643
00:30:20,796 --> 00:30:22,496
at how Head-of-Line
Blocking is present


644
00:30:22,496 --> 00:30:25,246
in HTTP/1.1 without pipelining.


645
00:30:27,236 --> 00:30:31,886
Imagine you issue three requests
for three resources: an image,


646
00:30:32,326 --> 00:30:34,596
a style sheet, and
some XML data.


647
00:30:35,606 --> 00:30:37,626
The first thing that will
happen of course is we'll send


648
00:30:37,626 --> 00:30:39,556
out the GET request
for the image.


649
00:30:40,536 --> 00:30:42,696
And then you'll wait a
while as all the bytes


650
00:30:42,696 --> 00:30:45,876
in the 200 OK response come back
for that image back to your app.


651
00:30:46,736 --> 00:30:48,356
Meanwhile, notice
nothing has happened


652
00:30:48,356 --> 00:30:50,016
for the style sheet
or the XML data.


653
00:30:51,246 --> 00:30:54,026
Then we can send out the
request for the style sheet,


654
00:30:54,456 --> 00:30:57,506
receive its response, and then
do the same for the XML data.


655
00:30:57,986 --> 00:31:00,236
So you can see here
that during the time


656
00:31:00,236 --> 00:31:02,566
when you are receiving the
response bytes for the image,


657
00:31:02,906 --> 00:31:05,356
we can't make any
forward progress


658
00:31:05,896 --> 00:31:08,306
with the style sheet
or the XML data.


659
00:31:09,256 --> 00:31:11,376
Now pipelining makes the
situation a little bit better,


660
00:31:11,376 --> 00:31:13,466
but it doesn't get rid of
Head-of-Line Blocking still.


661
00:31:13,586 --> 00:31:17,576
So let's see what
that looks like.


662
00:31:18,056 --> 00:31:20,936
Now, requests can get sent
out one after another.


663
00:31:21,336 --> 00:31:24,306
But responses are still blocked
by the previous response.


664
00:31:24,386 --> 00:31:26,446
And Head-of-Line Blocking
is still an issue even


665
00:31:26,446 --> 00:31:27,796
if you are using pipelining.


666
00:31:28,126 --> 00:31:30,836
So multiplexing changes
that with SPDY.


667
00:31:31,406 --> 00:31:33,696
Let's look at the same
three resources now,


668
00:31:34,436 --> 00:31:35,816
but this time with multiplexing.


669
00:31:37,456 --> 00:31:40,256
We'll start by sending
the request for the image.


670
00:31:40,256 --> 00:31:44,016
That should look no
different than before.


671
00:31:44,016 --> 00:31:46,986
Like before, with pipelining we
can actually send the request


672
00:31:46,986 --> 00:31:49,536
for the stylesheet immediately
after the request for the image.


673
00:31:50,026 --> 00:31:51,836
And of course we can
start making progress


674
00:31:51,836 --> 00:31:54,156
by receiving bytes
for the image.


675
00:31:54,666 --> 00:31:56,036
But here's where
things get different.


676
00:31:58,176 --> 00:32:02,226
Because the stylesheet is
higher priority than the image,


677
00:32:02,956 --> 00:32:05,516
the server will start
sending back response bytes


678
00:32:05,516 --> 00:32:08,216
for the stylesheet instead of
response bytes for the image.


679
00:32:08,656 --> 00:32:11,406
And then once the request
for the XML data has gone


680
00:32:11,406 --> 00:32:13,806
out because it is the
highest priority object,


681
00:32:14,356 --> 00:32:17,336
we receive its response bytes
in lieu of the image bytes


682
00:32:17,336 --> 00:32:18,606
or the stylesheet bytes.


683
00:32:20,026 --> 00:32:22,086
You'll also notice in this
diagram that the amount


684
00:32:22,086 --> 00:32:25,426
of data we're receiving for
the XML data is a larger chunk


685
00:32:25,876 --> 00:32:27,386
than that of the style
sheet or the image.


686
00:32:27,606 --> 00:32:28,556
That was intentional.


687
00:32:28,746 --> 00:32:30,406
Often times, with
SPDY implementations,


688
00:32:30,406 --> 00:32:33,136
the responses are
weighted by priority.


689
00:32:33,716 --> 00:32:36,626
So if we let this sort
progressing continue,


690
00:32:36,626 --> 00:32:39,756
what we end up seeing is that
we can receive the entire


691
00:32:39,756 --> 00:32:42,606
stylesheet and XML
data before the image,


692
00:32:42,606 --> 00:32:44,106
even though those
resources were asked


693
00:32:44,106 --> 00:32:45,956
for after we asked
for the image.


694
00:32:49,106 --> 00:32:52,616
So you might be wondering
why should I adopt SPDY?


695
00:32:52,616 --> 00:32:54,526
And the plain and
simple reason is


696
00:32:54,526 --> 00:32:56,496
that it can give a
better user experience.


697
00:32:56,496 --> 00:32:58,856
That's what we're all
after I would think.


698
00:32:59,306 --> 00:33:03,026
There's sort of two
reasons this is the case.


699
00:33:03,026 --> 00:33:06,336
The first is that, as I
mentioned, it reduces latency


700
00:33:06,336 --> 00:33:08,316
by having a single,
long-lived connection open


701
00:33:08,806 --> 00:33:09,966
between the client and server.


702
00:33:10,306 --> 00:33:13,586
What this means is that over
the lifetime of you app, as more


703
00:33:13,586 --> 00:33:16,066
and more requests are
issued, we don't have


704
00:33:16,066 --> 00:33:17,706
to continually open
new connections.


705
00:33:17,706 --> 00:33:19,566
Which helps to get
rid of that latency.


706
00:33:19,826 --> 00:33:22,646
It means that your app can have
much more interactive behavior


707
00:33:22,646 --> 00:33:24,596
even when using a
cellular connection.


708
00:33:26,136 --> 00:33:27,756
In our own performance
measurements,


709
00:33:27,756 --> 00:33:32,216
we found that SPDY could be up
to 25% faster than HTTP/1.1.


710
00:33:32,216 --> 00:33:35,766
And I'll come back to this
a little bit later on.


711
00:33:36,206 --> 00:33:39,386
There's also though some more
subtle points I want to raise


712
00:33:39,386 --> 00:33:42,146
about performance in
SPDY and its benefits.


713
00:33:43,376 --> 00:33:45,646
Because it's only opening
a single TCP connection,


714
00:33:45,646 --> 00:33:48,216
it also only has to do
a single SSL handshake.


715
00:33:48,776 --> 00:33:51,766
And that means that your
app will have less CPU use,


716
00:33:51,936 --> 00:33:54,696
and over time better
battery life on the device.


717
00:33:55,806 --> 00:33:58,296
It also means that when your
app becomes the next big app


718
00:33:58,296 --> 00:34:01,826
on the app store, and a big hit,
that you may not have to roll


719
00:34:01,826 --> 00:34:03,416
out as much server
site infrastructure


720
00:34:03,416 --> 00:34:06,076
to support the increased
number of clients,


721
00:34:06,126 --> 00:34:09,255
because each client has
fewer connections going back


722
00:34:09,255 --> 00:34:10,186
to your server, right?


723
00:34:10,186 --> 00:34:11,346
It's one instead of many.


724
00:34:11,806 --> 00:34:17,096
I already told you that
if you'd like to make use


725
00:34:17,096 --> 00:34:19,985
of SPDY you don't need any
client-side code changes.


726
00:34:20,356 --> 00:34:22,056
But there are a few
other points with respect


727
00:34:22,056 --> 00:34:24,966
to SPDY adoption I do
want to talk about.


728
00:34:24,966 --> 00:34:27,275
First, we are planning
to add API


729
00:34:27,275 --> 00:34:29,686
for setting priorities
on session tasks.


730
00:34:29,686 --> 00:34:31,076
You'll see that in
a future seed;


731
00:34:31,186 --> 00:34:32,406
it's not currently available.


732
00:34:32,976 --> 00:34:35,936
We'd also welcome any other
feedback from you during either


733
00:34:35,936 --> 00:34:38,525
of the networking lab sessions,
or through a bug report


734
00:34:38,886 --> 00:34:41,156
if you believe there's other
APIs that would be useful


735
00:34:41,156 --> 00:34:44,525
that you don't currently see.


736
00:34:44,786 --> 00:34:47,565
While you don't need to have
any client-side code changes


737
00:34:47,565 --> 00:34:50,496
to support SPDY, keep in
mind SPDY does require


738
00:34:50,496 --> 00:34:51,335
server-side support.


739
00:34:51,966 --> 00:34:54,906
This all happens when the client
is negotiating with the server,


740
00:34:54,906 --> 00:34:56,686
using the TLS handshake.


741
00:34:57,526 --> 00:35:00,306
The reason this is important
is that all of the URLs


742
00:35:00,306 --> 00:35:04,226
for requests that you issue
from your application need


743
00:35:04,226 --> 00:35:07,526
to have HTTPS and not HTTP.


744
00:35:08,016 --> 00:35:10,666
I'll just point out that
there's a fair amount


745
00:35:10,666 --> 00:35:13,616
of existing web server software
and content delivery networks


746
00:35:14,266 --> 00:35:16,156
that already support SPDY.


747
00:35:16,156 --> 00:35:18,446
So you may already have SPDY
support and have to do nothing


748
00:35:18,446 --> 00:35:20,246
at all to turn it
on, on your server.


749
00:35:22,696 --> 00:35:27,986
Finally, many of you might
have an NSURLProtocol subclass,


750
00:35:28,036 --> 00:35:30,186
or maybe perhaps multiple
in your application.


751
00:35:30,596 --> 00:35:33,516
And I do want to note that our
SPDY implementation is not going


752
00:35:33,516 --> 00:35:36,916
to interfere with your protocol
subclasses regardless of whether


753
00:35:36,916 --> 00:35:38,376
or not they're adding
support for SPDY


754
00:35:38,376 --> 00:35:40,486
or some other protocol entirely.


755
00:35:42,406 --> 00:35:46,336
I mentioned that we
found that SPDY could be


756
00:35:46,336 --> 00:35:50,336
up to 25% faster than HTTP/1.1.


757
00:35:50,906 --> 00:35:53,126
I want to go into a little
more detail about sort


758
00:35:53,126 --> 00:35:56,386
of the performance
and expectations.


759
00:35:56,386 --> 00:35:58,546
Naturally, parallel
TCP connections


760
00:35:59,006 --> 00:36:01,686
in some cases can be faster
than SPDY single connection.


761
00:36:02,366 --> 00:36:05,656
What we've found is that
whether or not SPDY is going


762
00:36:05,656 --> 00:36:06,806
to be faster is dependent


763
00:36:06,806 --> 00:36:09,056
on both network conditions
and your workload.


764
00:36:09,876 --> 00:36:12,336
In general, our guidance
is that if you are going


765
00:36:12,336 --> 00:36:15,146
to issue many requests,
particularly requests


766
00:36:15,146 --> 00:36:17,216
for small size objects,
you're going


767
00:36:17,216 --> 00:36:19,416
to see a performance
gain with SPDY.


768
00:36:19,416 --> 00:36:21,986
But if you're writing an app
that's downloading a handful


769
00:36:21,986 --> 00:36:24,976
of files, perhaps though
also downloading large files,


770
00:36:25,236 --> 00:36:27,486
such as a movie,
SPDY is not going


771
00:36:27,486 --> 00:36:28,566
to be advantageous for you.


772
00:36:29,586 --> 00:36:32,976
So keep in mind that you control
whether or not SPDY's going


773
00:36:32,976 --> 00:36:34,626
to be used based on whether


774
00:36:34,626 --> 00:36:36,186
or not it's turned
on on your server.


775
00:36:36,186 --> 00:36:41,126
I also want to note that the
SPDY specification indicates


776
00:36:41,526 --> 00:36:45,296
that HTTP headers can be
compressed to boost performance.


777
00:36:45,946 --> 00:36:47,766
But it turns out this
is actually susceptible


778
00:36:47,766 --> 00:36:50,066
to the crime vulnerability,
which you can read about online.


779
00:36:50,596 --> 00:36:52,076
So in our implementation,


780
00:36:52,526 --> 00:36:55,416
as is in many common
SPDY implementations,


781
00:36:55,816 --> 00:36:57,916
we've actually disabled
this for user privacy.


782
00:36:57,916 --> 00:36:59,506
So you're not going to
see a performance boost


783
00:36:59,506 --> 00:37:00,566
from compressed headers.


784
00:37:01,916 --> 00:37:02,946
Finally, I want to point


785
00:37:02,946 --> 00:37:05,966
out SPDY is not an
IETF-recognized standard.


786
00:37:06,506 --> 00:37:10,746
But we see it as a protocol that
is paving the way for HTTP/2.0.


787
00:37:11,106 --> 00:37:13,916
In particular it gives you,
developers, the opportunity


788
00:37:13,916 --> 00:37:16,676
to get a jump start on
using a protocol that relies


789
00:37:16,676 --> 00:37:18,866
on a single, long-lived
connection with multiplexing,


790
00:37:18,866 --> 00:37:21,586
which is the same direction
that HTTP/2.0 is heading.


791
00:37:21,626 --> 00:37:27,156
I want to wrap up and talk
about some best practices


792
00:37:27,156 --> 00:37:29,236
for working with SPDY.


793
00:37:29,236 --> 00:37:32,016
Keep in mind, these are not
necessarily hard and fast rules


794
00:37:32,016 --> 00:37:33,016
that you always have to follow,


795
00:37:33,016 --> 00:37:35,596
but these are good suggestions
just to keep in the back


796
00:37:35,596 --> 00:37:38,096
of your mind as you
work with SPDY.


797
00:37:38,336 --> 00:37:44,646
The first is, it's best if you
can issue your requests as soon


798
00:37:44,806 --> 00:37:46,646
as you want the resources.


799
00:37:46,646 --> 00:37:50,176
In other words, what I mean is
you might have previously held


800
00:37:50,176 --> 00:37:52,936
back and actually manually
scheduled requests to try


801
00:37:52,936 --> 00:37:54,436
to avoid Head-of-Line Blocking.


802
00:37:54,976 --> 00:37:56,976
But because Head-of-Line
Blocking is no longer


803
00:37:56,976 --> 00:38:01,146
of concern, we ask that you
enqueue all your requests right


804
00:38:01,146 --> 00:38:04,206
away, and let multiplexing
do what it's meant to do.


805
00:38:05,126 --> 00:38:07,776
Also, you might have
spread your content


806
00:38:07,776 --> 00:38:10,536
across multiple host names,
called hostname sharding.


807
00:38:10,956 --> 00:38:13,956
So if some resources might have
been, like, on css.apple.com,


808
00:38:13,956 --> 00:38:16,316
some would have been on
images.apple.com and so on.


809
00:38:16,386 --> 00:38:19,016
For HTTP/1.1 this made sense.


810
00:38:19,016 --> 00:38:21,266
It would cause us to open
multiple TCP connections


811
00:38:21,266 --> 00:38:22,466
which would boost performance.


812
00:38:23,286 --> 00:38:26,916
But since SPDY relies on a
single, long-live connection


813
00:38:27,176 --> 00:38:29,676
which gives us optimal
connection reuse,


814
00:38:29,676 --> 00:38:32,596
it's actually best if you
unshard and consolidate all


815
00:38:32,596 --> 00:38:35,816
of your content to a single
hostname and single port,


816
00:38:35,816 --> 00:38:37,566
so we can have that one,
long-lived connection


817
00:38:37,566 --> 00:38:39,916
to give you the best
experience possible.


818
00:38:41,056 --> 00:38:42,856
I'd like to turn
things over to Dan.


819
00:38:42,856 --> 00:38:44,046
He's going to be talking


820
00:38:44,046 --> 00:38:45,946
about Background
Networking and Extensions.


821
00:38:46,996 --> 00:38:48,416
>> Good afternoon, everyone.


822
00:38:48,796 --> 00:38:51,556
I'm Dan. And as Scott said,
I'm going to be talking


823
00:38:51,556 --> 00:38:52,636
about background networking.


824
00:38:53,266 --> 00:38:54,656
So Steve mentioned before


825
00:38:54,656 --> 00:38:56,536
that you can enable
background networking


826
00:38:56,536 --> 00:38:58,496
in your applications
using NSURLSession


827
00:38:58,496 --> 00:39:00,716
if you use the background
session configuration


828
00:39:00,716 --> 00:39:02,206
with identifier factory method.


829
00:39:03,056 --> 00:39:05,386
I'd like to give you a brief
overview of what I'm going


830
00:39:05,386 --> 00:39:06,856
to be talking about today.


831
00:39:06,856 --> 00:39:08,486
First, I'm going to
go over why you'd want


832
00:39:08,486 --> 00:39:09,936
to use background sessions


833
00:39:09,936 --> 00:39:11,906
and background networking
in your applications.


834
00:39:12,826 --> 00:39:15,696
Tying in with this, I'll talk
about using background sessions


835
00:39:15,696 --> 00:39:17,696
in app extensions,
which is a new feature


836
00:39:17,696 --> 00:39:19,546
in iOS 8 and OS X Yosemite.


837
00:39:20,086 --> 00:39:23,636
I'll then talk about
discretionary networking,


838
00:39:23,636 --> 00:39:26,846
which is a feature of background
networking that allows us


839
00:39:26,846 --> 00:39:30,196
to schedule tasks
when it's appropriate,


840
00:39:30,196 --> 00:39:31,756
given current power conditions.


841
00:39:32,866 --> 00:39:35,666
Finally, I'll talk about using
background sessions properly


842
00:39:35,666 --> 00:39:38,026
in your applications, going
over a couple use cases,


843
00:39:38,026 --> 00:39:40,956
and talking about some common
pitfalls and best practices.


844
00:39:42,856 --> 00:39:43,706
So why do you want


845
00:39:43,706 --> 00:39:45,676
to use background sessions
in your applications?


846
00:39:46,116 --> 00:39:48,256
Well, the main benefit,
particularly


847
00:39:48,256 --> 00:39:49,766
on iOS is for multitasking.


848
00:39:50,246 --> 00:39:52,436
In a background session,
file-based uploads


849
00:39:52,436 --> 00:39:54,626
and downloads can
continue out of process,


850
00:39:54,716 --> 00:39:55,956
even while your app
isn't running.


851
00:39:56,626 --> 00:39:58,756
This means that your
app can crash even.


852
00:39:58,846 --> 00:39:59,756
It can be terminated.


853
00:39:59,756 --> 00:40:03,646
Or, on iOS, it can be suspended
and those file-based uploads


854
00:40:03,646 --> 00:40:06,696
and downloads will still
continue, and will actually wake


855
00:40:06,696 --> 00:40:09,926
up your app on iOS in the
background to handle things


856
00:40:09,926 --> 00:40:12,806
like authentication
challenges and the completion


857
00:40:12,806 --> 00:40:14,116
of all the tasks
in your sessions.


858
00:40:15,026 --> 00:40:18,046
Another benefit is that
in a background session,


859
00:40:18,096 --> 00:40:21,366
we monitor the network and
power environment for you.


860
00:40:21,916 --> 00:40:24,546
This means that we cover things
like network reachability


861
00:40:24,546 --> 00:40:26,366
and connectivity for
you, so you don't have


862
00:40:26,406 --> 00:40:28,236
to use the reachability
APIs at all.


863
00:40:28,506 --> 00:40:30,876
We won't attempt to establish
a connection until we know


864
00:40:30,876 --> 00:40:31,996
that the server is reachable.


865
00:40:32,526 --> 00:40:36,946
And similarly, if the user is
performing a download and steps


866
00:40:36,946 --> 00:40:40,156
out of Wi-Fi, normally
that task would then fail


867
00:40:40,156 --> 00:40:41,196
with a transmission error.


868
00:40:41,536 --> 00:40:43,536
But, in a background session,
we'll actually recover


869
00:40:43,536 --> 00:40:46,346
from that automatically
and retry it and resume


870
00:40:46,346 --> 00:40:48,716
where we left off if the
download is resumable.


871
00:40:48,946 --> 00:40:50,106
And you won't hear
about that error.


872
00:40:51,116 --> 00:40:55,276
For discretionary tasks, we also
perform some battery monitoring


873
00:40:55,516 --> 00:40:58,036
so that we don't perform a
task if the user's really low


874
00:40:58,036 --> 00:40:59,406
on battery and not charging.


875
00:41:00,016 --> 00:41:02,156
We'll also do bandwidth
monitoring.


876
00:41:02,296 --> 00:41:04,796
What this means is
that if the user's


877
00:41:04,796 --> 00:41:07,216
on a really flaky Wi-Fi network


878
00:41:07,216 --> 00:41:09,886
and isn't making really
sufficient throughput,


879
00:41:10,056 --> 00:41:12,506
than we'll stop and
just retry automatically


880
00:41:12,506 --> 00:41:13,946
when network conditions
are better.


881
00:41:13,946 --> 00:41:18,036
I'd like to talk about
using background sessions


882
00:41:18,106 --> 00:41:20,576
in app extensions, which
as I said are a new feature


883
00:41:20,696 --> 00:41:22,396
of iOS 8 and OS X Yosemite.


884
00:41:23,106 --> 00:41:25,286
Now extensions are very
short-lived processes.


885
00:41:25,616 --> 00:41:26,646
Generally they're only going


886
00:41:26,646 --> 00:41:29,356
to be running while they're
actually active on screen,


887
00:41:29,356 --> 00:41:32,896
and that's going to be a very
short period of time usually.


888
00:41:32,896 --> 00:41:35,026
In-process networking
really isn't sufficient


889
00:41:35,026 --> 00:41:37,236
in an app extension if you
need to do any moderate-


890
00:41:37,236 --> 00:41:39,586
to large-sized upload
or download.


891
00:41:40,466 --> 00:41:42,156
But if you use a
background session,


892
00:41:42,386 --> 00:41:44,546
then that task will
actually be performed


893
00:41:44,546 --> 00:41:45,666
by our background daemon.


894
00:41:46,026 --> 00:41:50,236
So your app extension can exit
or be suspended and, on iOS,


895
00:41:50,396 --> 00:41:53,366
when that task completes or
authentication is required,


896
00:41:53,416 --> 00:41:56,316
will actually launch the app
that your extension's shipped


897
00:41:56,316 --> 00:41:57,686
with in order to
handle those events.


898
00:41:58,426 --> 00:42:00,596
So essentially, your
app extensions


899
00:42:00,596 --> 00:42:03,736
and your apps can share
background sessions.


900
00:42:03,996 --> 00:42:06,336
This leads us to a
couple constraints


901
00:42:06,686 --> 00:42:08,746
when using background
sessions in app extensions.


902
00:42:09,356 --> 00:42:11,906
The first is that in order
to use a background session


903
00:42:12,136 --> 00:42:15,406
in an app extension, you need
to use a shared data container.


904
00:42:15,856 --> 00:42:18,686
Now the reason for this
is that by default an app


905
00:42:18,686 --> 00:42:20,576
and any extensions
that it ships with are


906
00:42:20,576 --> 00:42:23,206
in different data containers
and won't have access


907
00:42:23,206 --> 00:42:24,336
to the same sets of files.


908
00:42:25,116 --> 00:42:29,226
But in Xcode you can create
an application group using the


909
00:42:29,226 --> 00:42:30,206
Capabilities tab.


910
00:42:30,656 --> 00:42:32,926
And if you create an
application group,


911
00:42:32,926 --> 00:42:35,566
you can tell us the
identifier of that app group


912
00:42:35,956 --> 00:42:36,946
of that group container,


913
00:42:36,946 --> 00:42:38,366
and will download
into that container.


914
00:42:38,366 --> 00:42:39,976
I'll show you how to
do that momentarily.


915
00:42:41,636 --> 00:42:45,306
Another caveat is that only
one process can be connected


916
00:42:45,306 --> 00:42:46,926
to the background
session at a time.


917
00:42:47,436 --> 00:42:50,266
This means that if your app
is running in the background,


918
00:42:50,386 --> 00:42:54,816
and then another app launches
and brings up your extension,


919
00:42:54,816 --> 00:42:57,156
it won't be able to use that
same background session.


920
00:42:58,226 --> 00:43:00,736
Now a background session
is essentially defined


921
00:43:00,736 --> 00:43:02,286
by the identifier that you use


922
00:43:02,286 --> 00:43:04,956
when you create your background
session configuration object.


923
00:43:05,406 --> 00:43:06,846
What we recommend here is


924
00:43:06,846 --> 00:43:09,786
that you use a different
background session identifier


925
00:43:09,786 --> 00:43:12,406
for your app and for each
extension that you ship with.


926
00:43:12,456 --> 00:43:15,176
The only time that you should
take advantage of the fact


927
00:43:15,316 --> 00:43:18,326
that your app and your
extensions can share background


928
00:43:18,326 --> 00:43:20,086
sessions is when
we launch your app


929
00:43:20,086 --> 00:43:21,526
to handle events
for that session.


930
00:43:22,126 --> 00:43:24,456
Now I mention that you need
to use a shared data container


931
00:43:24,576 --> 00:43:27,816
when using background
sessions and app extensions.


932
00:43:28,136 --> 00:43:30,986
You can specify that using the
shared container identifier


933
00:43:30,986 --> 00:43:33,096
property on
NSURLSessionConfiguration.


934
00:43:33,836 --> 00:43:36,876
What you do is you just create
a configuration object using the


935
00:43:36,876 --> 00:43:39,756
backgroundSessionConfiguration
WithIdentifier factory method


936
00:43:39,756 --> 00:43:40,916
that Steve showed you before.


937
00:43:41,406 --> 00:43:43,426
And you set the
sharedContainerIdentifier


938
00:43:43,486 --> 00:43:46,126
property to the identifier of
your shared group container.


939
00:43:47,006 --> 00:43:49,146
Then you can create
an NSURLSession


940
00:43:49,146 --> 00:43:50,416
from that configuration object


941
00:43:50,416 --> 00:43:51,776
and create tasks
in that session.


942
00:43:52,216 --> 00:43:55,526
Now I'd like to switch
gears and talk


943
00:43:55,526 --> 00:43:57,896
about discretionary
networking, which is something


944
00:43:57,896 --> 00:44:04,816
that some background tasks can
use in order to perform tasks


945
00:44:04,816 --> 00:44:06,156
at power-optimal times.


946
00:44:07,086 --> 00:44:10,396
What this means is, that we will
take into account things like,


947
00:44:10,396 --> 00:44:13,136
whether or not we're on a Wi-Fi
network or using cellular data.


948
00:44:13,136 --> 00:44:15,756
And we'll also take into account
the current battery state,


949
00:44:15,816 --> 00:44:17,156
whether or not we're charging,


950
00:44:17,466 --> 00:44:20,316
how much-what percentage
the battery is charged.


951
00:44:21,416 --> 00:44:22,706
We also take into account things


952
00:44:22,706 --> 00:44:24,686
like how often your
app is launched.


953
00:44:24,966 --> 00:44:27,486
If it's something that a user
launches really frequently,


954
00:44:27,486 --> 00:44:30,616
we'll be more likely to
treat a task more urgently,


955
00:44:30,616 --> 00:44:32,456
since the user's
more likely to notice


956
00:44:32,796 --> 00:44:34,326
when those resources
are downloaded.


957
00:44:36,156 --> 00:44:39,406
One improvement that
we've made in iOS 8


958
00:44:39,406 --> 00:44:41,976
for discretionary transfers,
is that tasks are treated


959
00:44:41,976 --> 00:44:43,606
with more urgency
as time goes on.


960
00:44:43,606 --> 00:44:46,676
In iOS 7, discretionary
transfers were limited


961
00:44:46,676 --> 00:44:47,636
to Wi-Fi only.


962
00:44:48,226 --> 00:44:51,486
Now, while we may limit
discretionary transfers


963
00:44:51,486 --> 00:44:55,456
to run while there is Wi-Fi
and plugged in at first,


964
00:44:55,766 --> 00:44:58,096
these constraints will
relax as time goes on.


965
00:44:58,436 --> 00:45:02,286
As we approach the resource
timeout that's specified


966
00:45:02,286 --> 00:45:04,556
on your configuration
object, we'll be more likely


967
00:45:04,556 --> 00:45:07,516
to relax these conditions
and allow transfers


968
00:45:07,516 --> 00:45:08,766
over battery and cellular data.


969
00:45:11,056 --> 00:45:12,906
There are a couple
different ways


970
00:45:12,906 --> 00:45:14,606
that you can use
discretionary networking


971
00:45:14,686 --> 00:45:15,776
in a background session.


972
00:45:16,636 --> 00:45:18,506
One way is by explicitly opting


973
00:45:18,506 --> 00:45:21,306
in using the discretionary
property which is just a boolean


974
00:45:21,336 --> 00:45:23,396
in an NSURLSessionConfiguration.


975
00:45:23,986 --> 00:45:25,836
This was made available on iOS 7


976
00:45:25,906 --> 00:45:27,756
and is now available
on OS X Yosemite.


977
00:45:28,946 --> 00:45:30,596
You might want to do
this for any tasks


978
00:45:30,596 --> 00:45:32,296
that aren't really
user-initiated.


979
00:45:32,766 --> 00:45:34,766
So let's say you have, you know,


980
00:45:34,766 --> 00:45:38,106
an app that lets users watch
episodes of a TV series.


981
00:45:38,236 --> 00:45:40,976
And they're watching an episode
that they've downloaded already,


982
00:45:40,976 --> 00:45:43,606
and maybe you want to pre-fetch
the next one so it's ready


983
00:45:43,636 --> 00:45:46,566
for them when they're finished
watching the current episode.


984
00:45:47,036 --> 00:45:50,356
Now, that's not something the
user explicitly requested.


985
00:45:50,646 --> 00:45:52,286
So that's something
that you might want


986
00:45:52,286 --> 00:45:53,306
to treat as discretionary.


987
00:45:54,166 --> 00:45:56,036
Similarly, if you have an app


988
00:45:56,036 --> 00:45:58,926
and the user is modifying
a document, you might want


989
00:45:58,926 --> 00:46:02,506
to upload that document
to your app servers


990
00:46:02,506 --> 00:46:04,706
so that it's accessible from
the users other devices.


991
00:46:04,706 --> 00:46:06,706
And this might also be
something that's discretionary.


992
00:46:06,796 --> 00:46:12,296
On iOS there are also times
when we will treat tasks


993
00:46:12,296 --> 00:46:13,516
as discretionary automatically.


994
00:46:13,896 --> 00:46:16,096
This happens when your app
is running in the background.


995
00:46:16,916 --> 00:46:21,686
In iOS 7, we introduced a
few new multitasking APIs.


996
00:46:21,686 --> 00:46:24,166
Most notably background
fetch updates,


997
00:46:24,466 --> 00:46:26,246
and handling silent
push notifications


998
00:46:26,246 --> 00:46:28,776
where your app gets a limited
amount of time, on the order


999
00:46:28,776 --> 00:46:31,986
of 30 to 60 seconds, to run in
the background to make updates.


1000
00:46:32,706 --> 00:46:36,166
When used in-this is really
great when used in conjunction


1001
00:46:36,166 --> 00:46:37,776
with background uploads
and downloads.


1002
00:46:38,186 --> 00:46:40,596
But because the user doesn't
know that your app is running


1003
00:46:40,596 --> 00:46:44,186
at this time, any
downloads or uploads


1004
00:46:44,186 --> 00:46:47,846
that you enqueue will be treated
as discretionary automatically


1005
00:46:48,356 --> 00:46:50,156
because this work can't
be user-initiated,


1006
00:46:50,156 --> 00:46:51,726
because the user doesn't
know that you're running.


1007
00:46:52,686 --> 00:46:56,786
One improvement that we've
made here in iOS 8 is that any


1008
00:46:56,786 --> 00:46:58,456
of these tasks that
we automatically treat


1009
00:46:58,456 --> 00:47:01,016
as discretionary will
become non-discretionary


1010
00:47:01,016 --> 00:47:03,696
if the user launches the app
and brings it to the foreground.


1011
00:47:04,936 --> 00:47:06,126
I've mentioned a couple times


1012
00:47:06,126 --> 00:47:08,756
that on iOS we will launch
your apps in the background


1013
00:47:08,756 --> 00:47:10,476
to handle events
like authentication


1014
00:47:10,686 --> 00:47:12,066
and the completion
of all your tasks.


1015
00:47:12,066 --> 00:47:13,106
I want to talk a little bit


1016
00:47:13,106 --> 00:47:14,636
about how you handle
those events.


1017
00:47:15,376 --> 00:47:19,946
In iOS 7, we introduced a new
method on UIApplicationDelegate,


1018
00:47:20,136 --> 00:47:21,006
called application:


1019
00:47:21,006 --> 00:47:23,536
handleEventsForBackground
URLSession:completionHandler.


1020
00:47:24,166 --> 00:47:27,156
When this is called, you'll be
provided with the identifier


1021
00:47:27,496 --> 00:47:29,116
of the session that
needs your attention.


1022
00:47:29,116 --> 00:47:31,446
And at this point you should
reconnect to that session


1023
00:47:31,726 --> 00:47:34,276
by creating a background
configuration object


1024
00:47:34,276 --> 00:47:36,806
with that identifier,
and then an NSURLSession


1025
00:47:36,806 --> 00:47:38,296
from that configuration object.


1026
00:47:39,056 --> 00:47:41,726
At this point you'll immediately
begin receiving the delegate


1027
00:47:41,726 --> 00:47:43,186
messages that you missed.


1028
00:47:43,186 --> 00:47:45,176
Maybe authentication challenges


1029
00:47:45,176 --> 00:47:46,926
or didCompleteWithError
callbacks.


1030
00:47:47,706 --> 00:47:50,006
And after you're finished
handling these events,


1031
00:47:50,236 --> 00:47:51,946
you'll want to call
the completionHandler


1032
00:47:51,946 --> 00:47:55,536
that was provided to your
UIApplicationDelegate.


1033
00:47:56,006 --> 00:47:59,486
This completionHandler allows
us to take a snapshot of your UI


1034
00:47:59,706 --> 00:48:01,856
to show up in the app switcher,
so that it's up-to-date


1035
00:48:01,856 --> 00:48:03,696
when the user double-clicks
the home button.


1036
00:48:04,696 --> 00:48:07,126
It also allows us
to suspend your app.


1037
00:48:07,126 --> 00:48:08,956
Now, when you're
launched to handle events


1038
00:48:08,956 --> 00:48:12,466
for background sessions, you'll
again be given a limited amount


1039
00:48:12,466 --> 00:48:13,016
of time to run


1040
00:48:13,016 --> 00:48:15,066
in the background-around
30 to 60 seconds.


1041
00:48:15,786 --> 00:48:17,606
If you don't call your
completion handler


1042
00:48:17,606 --> 00:48:19,716
within this time, your
app will be terminated,


1043
00:48:19,716 --> 00:48:21,846
meaning it won't have
an up-to-date snapshot


1044
00:48:21,846 --> 00:48:25,016
and it will be slower to launch
the next time the user wants


1045
00:48:25,016 --> 00:48:26,136
to launch your app.


1046
00:48:26,136 --> 00:48:27,926
So it's important that you
call this completionHandler


1047
00:48:27,926 --> 00:48:29,836
so your app gets suspended
and has an up-to-date UI.


1048
00:48:31,006 --> 00:48:33,746
Once you're finished receiving
all the pending events


1049
00:48:33,746 --> 00:48:34,786
from your NSURLSession,


1050
00:48:34,786 --> 00:48:37,686
we'll deliver the URLSessionDid
FinishEventsForBackground


1051
00:48:37,686 --> 00:48:40,996
URLSession message to
your NSURLSessionDelegate.


1052
00:48:41,226 --> 00:48:43,116
And this is an indication
of when it's a good time


1053
00:48:43,116 --> 00:48:46,406
to call your completionHandler
past your UIApplicationDelegate.


1054
00:48:46,856 --> 00:48:51,116
I'd also like to talk
about using data tasks


1055
00:48:51,206 --> 00:48:52,296
in background sessions.


1056
00:48:52,856 --> 00:48:55,196
Steve mentioned earlier
that data tasks,


1057
00:48:55,196 --> 00:48:56,736
instead of downloading to a file


1058
00:48:56,736 --> 00:49:01,566
or on disk will just deliver
didReceiveData callbacks


1059
00:49:01,566 --> 00:49:02,086
in memory.


1060
00:49:02,716 --> 00:49:05,316
Now data tasks were unavailable
in background sessions


1061
00:49:05,446 --> 00:49:07,396
in iOS 7 and OS X Mavericks.


1062
00:49:07,746 --> 00:49:11,216
But they're now available
in iOS 8 and OS X Yosemite


1063
00:49:11,346 --> 00:49:13,536
with one restriction, which is


1064
00:49:13,536 --> 00:49:16,236
that we will only
perform a data task


1065
00:49:16,236 --> 00:49:18,576
in the background session while
your app is actually running.


1066
00:49:19,086 --> 00:49:22,286
If your app gets suspended or is
terminated, then there is no one


1067
00:49:22,286 --> 00:49:24,746
to deliver that data to,
so it makes no sense for us


1068
00:49:24,746 --> 00:49:25,836
to continue performing it.


1069
00:49:26,866 --> 00:49:30,146
However, you can
convert it to a download


1070
00:49:30,536 --> 00:49:31,816
when you receive the response.


1071
00:49:32,056 --> 00:49:34,136
Steve eluded to this
earlier when talking


1072
00:49:34,136 --> 00:49:35,896
about the didReceiveResponse
callback.


1073
00:49:36,666 --> 00:49:39,946
That delegate message
provides a completionHandler.


1074
00:49:40,316 --> 00:49:42,546
And you can pass
NSURLSessionResponse


1075
00:49:42,546 --> 00:49:45,396
BecomeDownload to
that completionHandler


1076
00:49:45,696 --> 00:49:47,616
and then we'll start
streaming the bytes to a file


1077
00:49:47,616 --> 00:49:48,916
on disk rather than memory.


1078
00:49:49,476 --> 00:49:52,476
Once you do that, this
becomes a download


1079
00:49:52,476 --> 00:49:55,896
that can be continued even after
your app is suspended or exits.


1080
00:49:57,096 --> 00:50:00,036
Now I'd like to talk about
a couple common pitfalls


1081
00:50:00,036 --> 00:50:01,436
that we've seen from
apps in the past


1082
00:50:01,436 --> 00:50:02,656
when using background sessions.


1083
00:50:03,096 --> 00:50:06,066
One common pattern that we've
seen that we'd like developers


1084
00:50:06,066 --> 00:50:09,016
to avoid is a pattern where
they create one task at a time.


1085
00:50:09,546 --> 00:50:12,546
So you might, for instance,
be downloading a large video


1086
00:50:12,546 --> 00:50:13,576
from your server that's split


1087
00:50:13,576 --> 00:50:16,836
up into many different smaller
segments, each a separate file.


1088
00:50:17,866 --> 00:50:20,396
If you download all of
these and if you, let's say,


1089
00:50:20,626 --> 00:50:24,016
create a download task for the
first task for the first asset


1090
00:50:24,016 --> 00:50:25,736
and then create a
second download task


1091
00:50:25,736 --> 00:50:28,156
for the next asset once
the first one completes,


1092
00:50:28,496 --> 00:50:31,316
this is a really bad
pattern, particularly because,


1093
00:50:31,316 --> 00:50:35,506
if the user suspends the app
by going to the home screen


1094
00:50:35,506 --> 00:50:38,476
at any point, than you'll
actually need to be re-launched


1095
00:50:38,476 --> 00:50:42,656
in the background once the
current download finishes before


1096
00:50:42,656 --> 00:50:43,856
you can enqueue your next one.


1097
00:50:44,266 --> 00:50:45,996
This means because it's
running in the background


1098
00:50:45,996 --> 00:50:48,056
that it will automatically
be treated as discretionary,


1099
00:50:48,806 --> 00:50:51,116
which means we won't guarantee
that it will start right away.


1100
00:50:52,196 --> 00:50:53,306
In particular, even


1101
00:50:53,306 --> 00:50:56,906
if conditions are great-we're
100% charged and connected


1102
00:50:56,906 --> 00:51:00,116
to a power source
and we're connected


1103
00:51:00,116 --> 00:51:02,756
to a great Wi-Fi network,
we still make no guarantees


1104
00:51:02,756 --> 00:51:03,686
that we'll start right away.


1105
00:51:03,796 --> 00:51:05,926
In particular, the
system will take measures


1106
00:51:05,926 --> 00:51:08,086
to prevent your app from
being launched too frequently.


1107
00:51:08,516 --> 00:51:11,506
So you can't rely on launches
for background sessions


1108
00:51:11,506 --> 00:51:13,696
for any sort of regular
launch events.


1109
00:51:14,626 --> 00:51:17,836
Tying in with this, it's
much better if instead


1110
00:51:17,836 --> 00:51:20,406
of downloading lots of
small assets like this,


1111
00:51:20,406 --> 00:51:22,366
if you can zip these
up on your server


1112
00:51:22,366 --> 00:51:23,986
into one large zipped asset.


1113
00:51:23,986 --> 00:51:26,326
That's much more efficient
for a background download.


1114
00:51:27,086 --> 00:51:29,796
And finally, blocking
while waiting for transfers


1115
00:51:29,796 --> 00:51:31,756
to complete is just
a really bad idea


1116
00:51:31,756 --> 00:51:33,116
when doing any kind
of networking.


1117
00:51:33,116 --> 00:51:35,286
But it's particularly bad
in a background session


1118
00:51:35,286 --> 00:51:37,476
where we recover from
network failures automatically


1119
00:51:37,476 --> 00:51:39,656
and don't tell you
about them and, again,


1120
00:51:39,656 --> 00:51:40,836
for discretionary transfers


1121
00:51:40,836 --> 00:51:42,536
where we're not guaranteed
to start right away.


1122
00:51:43,666 --> 00:51:47,006
I'd also like to go over
a couple best practices


1123
00:51:47,006 --> 00:51:48,576
for using background sessions


1124
00:51:48,576 --> 00:51:50,326
and also NSURLSession
in general.


1125
00:51:51,276 --> 00:51:53,926
One common mistake that we
think some people have made


1126
00:51:53,926 --> 00:51:56,726
in the past is that they've
assumed that when running


1127
00:51:56,726 --> 00:51:58,536
in the background
to handle things


1128
00:51:58,536 --> 00:52:01,246
like a background fetch update
or a silent push notification,


1129
00:52:01,406 --> 00:52:03,556
that they've been required
to use background sessions.


1130
00:52:03,936 --> 00:52:06,506
Now, using background uploads
or downloads with these forms


1131
00:52:06,506 --> 00:52:09,006
of multitasking works
really well,


1132
00:52:09,386 --> 00:52:11,616
but in particular
for large downloads.


1133
00:52:12,326 --> 00:52:14,066
When you're running for
a background fetch update


1134
00:52:14,066 --> 00:52:16,796
or a silent push notification,
as I said, you'll have about 30


1135
00:52:16,796 --> 00:52:18,746
to 60 seconds to run
in the background.


1136
00:52:19,356 --> 00:52:22,266
Now if you have any
small networking tasks


1137
00:52:22,526 --> 00:52:24,636
that could finish within this
time, it's perfectly okay


1138
00:52:24,636 --> 00:52:27,746
to do them in an in-process
or default NSURLSession.


1139
00:52:28,396 --> 00:52:31,296
If you have something like a
Twitter client that's going


1140
00:52:31,296 --> 00:52:33,756
to be downloading a few tweets
for a background fetch update,


1141
00:52:33,966 --> 00:52:35,806
that's totally doable
in process.


1142
00:52:35,896 --> 00:52:38,666
On the other hand, if you
want to download, you know,


1143
00:52:38,666 --> 00:52:40,426
the next episode of a TV series,


1144
00:52:40,426 --> 00:52:43,196
that's something that's fairly
large and probably not going


1145
00:52:43,256 --> 00:52:45,526
to finish within the
60 seconds you have


1146
00:52:45,526 --> 00:52:47,926
to run-that should be done
in a background session.


1147
00:52:48,926 --> 00:52:52,836
It's also important that you
support resumable downloads


1148
00:52:52,836 --> 00:52:53,496
on your servers.


1149
00:52:53,946 --> 00:52:57,336
As I mentioned in a background
session, we retry automatically


1150
00:52:57,336 --> 00:52:59,846
after network failures
if the user goes off


1151
00:52:59,846 --> 00:53:00,976
of Wi-Fi, for instance.


1152
00:53:01,336 --> 00:53:03,576
So if you support resumable
downloads, we don't have


1153
00:53:03,656 --> 00:53:05,956
to re-download bytes
we've already received.


1154
00:53:06,286 --> 00:53:08,676
But if you don't, than we have
to start from the beginning.


1155
00:53:09,306 --> 00:53:11,546
Now supporting resumable
downloads is generally just


1156
00:53:11,546 --> 00:53:14,296
as simple as supporting Range
GET requests on your servers.


1157
00:53:14,296 --> 00:53:16,516
And most servers should
support this configuration


1158
00:53:16,516 --> 00:53:17,216
out of the box.


1159
00:53:18,316 --> 00:53:19,816
Finally, it's very important


1160
00:53:19,816 --> 00:53:21,796
that you handle launch
events properly,


1161
00:53:22,126 --> 00:53:23,456
as I talked about before.


1162
00:53:23,666 --> 00:53:26,876
This means when you get launch
to handle a background session,


1163
00:53:27,266 --> 00:53:29,396
you should reconnect to
that background session


1164
00:53:29,636 --> 00:53:31,656
and handle any messages.


1165
00:53:31,656 --> 00:53:34,346
This is particularly
important with authentication.


1166
00:53:34,346 --> 00:53:36,786
Because if you don't respond
to an authentication challenge,


1167
00:53:37,116 --> 00:53:39,096
then that task will
timeout and fail.


1168
00:53:39,096 --> 00:53:40,446
And that's not what
the user wants.


1169
00:53:40,766 --> 00:53:43,806
Finally, be sure to call the
completion handler that's past


1170
00:53:43,806 --> 00:53:45,866
your UIApplicationDelegate.


1171
00:53:46,066 --> 00:53:48,786
As I said before, this allows
your UI to be up-to-date


1172
00:53:48,786 --> 00:53:51,566
in the app switcher and makes
it so your app is suspended


1173
00:53:51,566 --> 00:53:53,356
after it's completed
instead of being terminated.


1174
00:53:55,176 --> 00:53:57,926
Before I wrap up, I'd just
like to give a brief summary


1175
00:53:58,176 --> 00:54:00,286
of what we discussed today.


1176
00:54:00,286 --> 00:54:03,456
First we talked about new APIs
and NSStream and NSNetService.


1177
00:54:04,136 --> 00:54:09,356
We gave a review of using
NSURLSession from what we talked


1178
00:54:09,356 --> 00:54:11,326
about in last year's
WWDC session.


1179
00:54:12,346 --> 00:54:15,416
We talked about SPDY and
new protocol support.


1180
00:54:16,016 --> 00:54:19,606
And went over some new
features and best use cases


1181
00:54:19,606 --> 00:54:21,276
in background networking.


1182
00:54:22,926 --> 00:54:27,166
In case you don't get the
chance to ask us any questions


1183
00:54:27,166 --> 00:54:28,706
in person this week
while you're here,


1184
00:54:28,916 --> 00:54:32,026
Paul Danbold is our
Technologies Evangelist.


1185
00:54:32,316 --> 00:54:34,356
And he's a great person
to ask for any questions


1186
00:54:34,356 --> 00:54:35,666
that you might have that
you don't get a chance


1187
00:54:35,666 --> 00:54:38,556
to ask us while you're here.


1188
00:54:38,556 --> 00:54:40,566
We also have plenty of
documentation available


1189
00:54:40,566 --> 00:54:43,636
at developer.apple.com,
including for NSURLSession.


1190
00:54:44,146 --> 00:54:46,526
The Apple developer forums
are another great place


1191
00:54:46,526 --> 00:54:48,506
to ask questions that you don't
get to ask while you're here.


1192
00:54:49,656 --> 00:54:52,376
I'd also like to point you
at a couple related sessions


1193
00:54:52,706 --> 00:54:53,646
that are going on this week.


1194
00:54:53,646 --> 00:54:55,246
In particular you
might be interested


1195
00:54:55,516 --> 00:54:57,596
in the Extensions sessions.


1196
00:54:57,596 --> 00:54:59,146
There are two of them.


1197
00:54:59,146 --> 00:55:00,936
You can learn more about
creating app extensions,


1198
00:55:00,936 --> 00:55:02,056
and we'll also talk a little bit


1199
00:55:02,056 --> 00:55:04,526
about using background
sessions and app extensions.


1200
00:55:05,536 --> 00:55:07,906
With that, I'd like to
thank you all for coming.


1201
00:55:07,906 --> 00:55:10,196
And we look forward to seeing
the amazing apps you create


1202
00:55:10,196 --> 00:55:12,576
with iOS 8 and OS X
Yosemite [applause].

