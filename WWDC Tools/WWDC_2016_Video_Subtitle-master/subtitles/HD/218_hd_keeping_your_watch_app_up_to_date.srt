1
00:00:07,516 --> 00:00:18,500
[ Music ]


2
00:00:26,516 --> 00:00:32,195
[ Applause ]


3
00:00:32,695 --> 00:00:32,976
>> Great.


4
00:00:33,526 --> 00:00:35,156
Hello, and welcome
to our session


5
00:00:35,156 --> 00:00:37,156
on keeping your Watch
App up to date.


6
00:00:37,866 --> 00:00:41,456
My name is Eric Lanz, and
with me today is Austen Green.


7
00:00:41,906 --> 00:00:44,436
We're both engineers
on the watchOS team.


8
00:00:46,456 --> 00:00:49,036
Here you see a screenshot
from our calendar app.


9
00:00:49,586 --> 00:00:52,616
When you hear the word app, this
is probably what comes to mind,


10
00:00:53,206 --> 00:00:55,216
but watchOS has many ways


11
00:00:55,286 --> 00:00:57,636
to interact beyond the
standard application.


12
00:00:58,106 --> 00:01:01,056
For example, your users
think of your notifications


13
00:01:01,156 --> 00:01:03,186
as an important part
of your app.


14
00:01:04,495 --> 00:01:07,466
If you have a complication,
your users think of that


15
00:01:07,466 --> 00:01:10,826
as an important part
of your app, too.


16
00:01:11,066 --> 00:01:14,796
In watchOS 3, we're introducing
the new application dock.


17
00:01:15,236 --> 00:01:17,786
This feature allows
users to add up to ten


18
00:01:17,786 --> 00:01:21,436
of their favorite applications
to an always accessible dock.


19
00:01:21,756 --> 00:01:23,976
They can then swipe through
the dock to get a quick look


20
00:01:23,976 --> 00:01:25,446
at their data in one place.


21
00:01:26,376 --> 00:01:28,506
This is now also
part of your app.


22
00:01:29,576 --> 00:01:32,106
People are using your
application's data


23
00:01:32,106 --> 00:01:35,306
in many different ways and
expect all of those ways to be


24
00:01:35,306 --> 00:01:37,486
in sync and up to
date all the time.


25
00:01:38,236 --> 00:01:40,306
This may sound like
an impossible task,


26
00:01:40,426 --> 00:01:41,236
but don't worry.


27
00:01:41,686 --> 00:01:43,306
We're here to help.


28
00:01:44,196 --> 00:01:46,646
Today we'll be talking
about five topics.


29
00:01:47,076 --> 00:01:50,676
First, an overview of this API
and how it works on watchOS.


30
00:01:51,496 --> 00:01:52,776
Next, a walkthrough


31
00:01:52,776 --> 00:01:55,256
of an example application
with some real code.


32
00:01:56,046 --> 00:01:57,886
Then Austen will come on stage


33
00:01:58,086 --> 00:02:00,606
and show you how scheduling
works behind the scenes.


34
00:02:01,466 --> 00:02:03,746
After that, we'll share
some best practices


35
00:02:03,746 --> 00:02:06,266
for adopting this API in
your own applications.


36
00:02:06,966 --> 00:02:10,036
To close out the session,
we'll go through a case study


37
00:02:10,036 --> 00:02:13,296
of how we adopted this API in
our own stocks application.


38
00:02:13,926 --> 00:02:18,756
Let's get started by thinking
about how we use our phones


39
00:02:18,756 --> 00:02:21,206
and our watches in different
ways throughout the day.


40
00:02:21,976 --> 00:02:25,036
In the morning, you can
start your day waiting


41
00:02:25,036 --> 00:02:26,006
in line for coffee.


42
00:02:26,256 --> 00:02:28,586
You can then browse the news on
your phone for a few minutes.


43
00:02:29,366 --> 00:02:31,566
Before you leave the shop,
you check the weather


44
00:02:31,566 --> 00:02:34,726
with the complication on your
watch face, a two-second task.


45
00:02:36,346 --> 00:02:39,496
For lunch, you use maps again
to find a great restaurant.


46
00:02:39,496 --> 00:02:41,146
After a few minutes,
you've made your choice


47
00:02:41,276 --> 00:02:42,236
and put your phone away.


48
00:02:43,506 --> 00:02:45,856
On the way to the restaurant,
you get a notification.


49
00:02:46,066 --> 00:02:48,476
A quick glance at your wrist
lets you know your friends will


50
00:02:48,476 --> 00:02:51,326
be a few minutes late,
another two-second task.


51
00:02:52,006 --> 00:02:55,046
At the end of the day,
you use maps again


52
00:02:55,046 --> 00:02:56,956
to plan your route,
maybe a detour.


53
00:02:58,226 --> 00:03:01,286
You get an iMessage asking
when you'll be home that night.


54
00:03:02,086 --> 00:03:05,496
Use the quick reply features
of watchOS 3 to send back,


55
00:03:05,496 --> 00:03:09,646
"On my way," another
two-second task.


56
00:03:10,026 --> 00:03:13,516
It simply is impossible to have
our data ready in the couple


57
00:03:13,516 --> 00:03:15,426
of seconds that users
are going to give us.


58
00:03:15,776 --> 00:03:16,866
We need more time,


59
00:03:17,276 --> 00:03:19,286
and background refresh
is the way to get it.


60
00:03:19,856 --> 00:03:23,306
This powerful new API allows
you to schedule runtime


61
00:03:23,306 --> 00:03:27,146
so you can have your data
ready before the user needs it.


62
00:03:30,196 --> 00:03:34,296
To understand what this new API
can do, let's take a closer look


63
00:03:34,376 --> 00:03:36,116
at checking the weather
on watchOS.


64
00:03:36,956 --> 00:03:39,376
Here we see the foreground
activity of looking


65
00:03:39,376 --> 00:03:40,606
at the weather complication.


66
00:03:41,196 --> 00:03:43,956
Our data would have to be
ready before this happened.


67
00:03:45,056 --> 00:03:47,856
So let's use this API to
schedule some time in advance


68
00:03:47,966 --> 00:03:52,236
to update our UI, but how can
we update our UI without data.


69
00:03:52,726 --> 00:03:55,246
We'll need more time to
get the latest weather data


70
00:03:55,246 --> 00:03:56,016
from our server.


71
00:03:56,196 --> 00:03:57,506
So let's schedule
a task for that.


72
00:03:58,546 --> 00:04:01,046
But how did we even get
started on this chain of events?


73
00:04:01,656 --> 00:04:03,526
We're going to need
a way for the system


74
00:04:03,526 --> 00:04:05,866
to wake our application
in the background.


75
00:04:06,416 --> 00:04:10,476
On watchOS, the system
wakes your application


76
00:04:10,596 --> 00:04:11,566
by giving it a task.


77
00:04:12,336 --> 00:04:14,936
The system has a limited
number of these available.


78
00:04:15,106 --> 00:04:17,106
So make the best use
of each one you get.


79
00:04:18,606 --> 00:04:20,826
When the system wants to
wake your application,


80
00:04:20,946 --> 00:04:23,636
it delivers one or more
of these task objects.


81
00:04:24,156 --> 00:04:25,666
Make sure to hold
on to this task


82
00:04:25,796 --> 00:04:27,646
until you're finished
processing your data.


83
00:04:29,136 --> 00:04:30,496
The system delivers tasks


84
00:04:30,626 --> 00:04:33,916
by calling the new handled
background task method


85
00:04:33,916 --> 00:04:35,356
on WK extension delegate.


86
00:04:36,126 --> 00:04:38,526
We'll go through an example
of this method later on today.


87
00:04:39,086 --> 00:04:42,746
When you're finished with your
background work, return the task


88
00:04:42,746 --> 00:04:44,366
to the system by completing it.


89
00:04:44,856 --> 00:04:46,516
This is the fundamental process


90
00:04:46,576 --> 00:04:49,456
by which you obtain
background runtime on watchOS.


91
00:04:49,996 --> 00:04:54,236
Now that we understand the
task system from a high level,


92
00:04:54,366 --> 00:04:57,056
let's dive in and look at
the specific types of tasks


93
00:04:57,056 --> 00:04:59,546
that the system can
create for us.


94
00:05:00,056 --> 00:05:02,196
First, this is the
application task.


95
00:05:02,756 --> 00:05:05,776
This is a generic runtime
task that you can schedule


96
00:05:05,826 --> 00:05:08,276
to have your application
woken at a future date.


97
00:05:09,436 --> 00:05:11,816
Within the application
task runtime,


98
00:05:11,866 --> 00:05:14,086
you can do any kind
of local processing.


99
00:05:14,626 --> 00:05:16,826
You may want to update
your complication timeline


100
00:05:17,246 --> 00:05:20,116
or download some data from
your server with URLSession.


101
00:05:21,306 --> 00:05:23,446
The URLSession task
is how you find


102
00:05:23,446 --> 00:05:25,336
out that your data has
finished downloading


103
00:05:25,446 --> 00:05:26,396
and ready to process.


104
00:05:27,876 --> 00:05:31,286
Since watchOS is a shared
ecosystem, it doesn't make sense


105
00:05:31,406 --> 00:05:34,296
to leave our application running
while the data downloads.


106
00:05:34,926 --> 00:05:37,406
It would be better to allow
our application to sleep,


107
00:05:37,406 --> 00:05:40,026
and let the system
do that for us.


108
00:05:40,616 --> 00:05:44,346
Snapshots are a very
important part of watchOS 3.


109
00:05:44,996 --> 00:05:46,406
They are both your launch image


110
00:05:47,086 --> 00:05:49,276
and your preview image
while running in the dock.


111
00:05:50,026 --> 00:05:51,576
If the user settles on your app,


112
00:05:51,576 --> 00:05:53,046
it will start running
live again.


113
00:05:53,226 --> 00:05:54,956
So it's critical
that your snapshot be


114
00:05:54,956 --> 00:05:56,476
up to date at all times.


115
00:05:56,886 --> 00:06:02,226
The snapshot task is how you
get runtime to prepare your UI


116
00:06:02,226 --> 00:06:04,686
in the background to be
ready for the new snapshot.


117
00:06:04,996 --> 00:06:09,716
When you complete this task,


118
00:06:09,846 --> 00:06:12,326
the system will automatically
snapshot your UI.


119
00:06:13,096 --> 00:06:14,926
Remember to always
schedule one of these


120
00:06:15,056 --> 00:06:16,726
after you finish
processing data,


121
00:06:16,796 --> 00:06:18,976
or the user won't see
the work you just did.


122
00:06:20,566 --> 00:06:23,226
When a notification arrives,
your user will see it.


123
00:06:23,446 --> 00:06:26,746
They will then expect your
complication and your snapshot


124
00:06:26,876 --> 00:06:28,776
to be updated to
reflect this data.


125
00:06:29,486 --> 00:06:32,746
Users love applications that
feel like a consistent part


126
00:06:32,746 --> 00:06:36,226
of the OS and are more likely
to put those apps in the dock.


127
00:06:36,666 --> 00:06:41,526
If the user does not interact
with your application for more


128
00:06:41,526 --> 00:06:44,926
than one hour, the system is
going to give you an opportunity


129
00:06:44,996 --> 00:06:46,606
to restore your default state.


130
00:06:47,796 --> 00:06:50,536
Default state means different
things to different apps,


131
00:06:50,536 --> 00:06:53,866
and some apps have no
concept of a default state.


132
00:06:55,876 --> 00:06:58,466
Designing great snapshots
is a huge


133
00:06:58,466 --> 00:07:00,566
and important topic
on watchOS 3.


134
00:07:00,996 --> 00:07:03,186
We recommend you check
out this other session


135
00:07:03,396 --> 00:07:04,496
for some great advice


136
00:07:04,606 --> 00:07:07,116
on designing excellent
snapshots for your users.


137
00:07:09,036 --> 00:07:11,956
The last task type is
for watch connectivity.


138
00:07:12,606 --> 00:07:15,896
On watchOS 3, we've
integrated watch connectivity


139
00:07:16,066 --> 00:07:17,936
with our background refresh API.


140
00:07:19,036 --> 00:07:22,436
This means you can now use
watch connectivity messaging


141
00:07:22,476 --> 00:07:25,286
to get data to your
application while it is running


142
00:07:25,286 --> 00:07:26,066
in the background.


143
00:07:28,556 --> 00:07:31,836
Complication push, application
context, sending a file,


144
00:07:31,836 --> 00:07:34,496
or sending user info will
all wake your application


145
00:07:34,526 --> 00:07:35,336
in the background.


146
00:07:36,096 --> 00:07:37,686
We hope that this
edition will lead


147
00:07:37,686 --> 00:07:41,486
to even richer watch
experiences for our users.


148
00:07:42,276 --> 00:07:46,086
When your application is woken
via watch connectivity tasks,


149
00:07:46,916 --> 00:07:49,256
use the standard API
to get your data.


150
00:07:49,716 --> 00:07:51,966
First, make sure the
session is active.


151
00:07:53,356 --> 00:07:54,796
Once the session reactivates,


152
00:07:54,966 --> 00:07:58,336
start monitoring the new
hasContentPending property.


153
00:07:59,026 --> 00:08:00,676
As long as this property
is true,


154
00:08:00,806 --> 00:08:02,416
you still have data to process.


155
00:08:02,916 --> 00:08:04,286
Make sure to hold onto the task


156
00:08:04,426 --> 00:08:06,296
until you're finished
processing this data.


157
00:08:06,516 --> 00:08:10,286
It is your responsibility
to return the task


158
00:08:10,326 --> 00:08:12,056
to the system by completing it.


159
00:08:12,056 --> 00:08:15,506
If you don't do this, you will
exhaust your background runtime,


160
00:08:15,596 --> 00:08:17,736
and we're going to give
you a crash report.


161
00:08:18,256 --> 00:08:21,806
Austen will talk more in the
second half of this session


162
00:08:21,916 --> 00:08:23,336
about these runtime caveats.


163
00:08:24,046 --> 00:08:27,296
Let's quickly review
the workflow


164
00:08:27,296 --> 00:08:29,596
of using our new
background refresh API.


165
00:08:30,306 --> 00:08:32,336
First, schedule a task.


166
00:08:33,806 --> 00:08:35,916
Next, receive the
task from the system.


167
00:08:36,895 --> 00:08:38,466
Now you can do your
background work.


168
00:08:38,866 --> 00:08:40,405
Make sure to hold onto the task


169
00:08:40,405 --> 00:08:41,806
until you're finished
doing this work.


170
00:08:42,846 --> 00:08:45,386
You may use this runtime
to schedule further work


171
00:08:45,566 --> 00:08:48,346
such as fetching data from
your server with URLSession.


172
00:08:49,826 --> 00:08:55,786
When finished, return the task
to the system by completing it.


173
00:08:56,766 --> 00:08:58,326
Before we continue, I want


174
00:08:58,326 --> 00:09:01,676
to stress an important
topic, being a good citizen.


175
00:09:03,196 --> 00:09:07,056
watchOS is a shared ecosystem,
and there are many applications


176
00:09:07,176 --> 00:09:10,816
and system processes competing
for CPU time and battery life.


177
00:09:11,426 --> 00:09:15,006
It is our responsibility as
developers in this ecosystem


178
00:09:15,066 --> 00:09:17,926
to do our best to use these
resources efficiently.


179
00:09:18,806 --> 00:09:22,926
Let's pretend the user launches
your app at 3:00 p.m. You want


180
00:09:22,926 --> 00:09:24,566
to make sure you have
a chance to check


181
00:09:24,566 --> 00:09:25,766
in with your server in an hour.


182
00:09:25,956 --> 00:09:29,526
So schedule a task for 4:00
p.m. Well, what happens


183
00:09:29,576 --> 00:09:31,796
if the user launches
your app at 3:50?


184
00:09:33,026 --> 00:09:35,976
We could update our data
now and again at four


185
00:09:35,976 --> 00:09:38,896
when the task runs, but that
does not sound optimal to me.


186
00:09:40,256 --> 00:09:43,366
A better approach is to
use the runtime at 3:50


187
00:09:43,456 --> 00:09:47,186
to reschedule our background
task for an hour later, 4:50.


188
00:09:48,046 --> 00:09:50,766
Every app is different, but
hopefully you can find a pattern


189
00:09:50,766 --> 00:09:53,066
like this to help us
maximize resources.


190
00:09:54,946 --> 00:09:56,696
Okay, let's start
looking at some code.


191
00:09:57,166 --> 00:10:00,146
To help frame our sample
code, we're going to walk


192
00:10:00,196 --> 00:10:02,546
through the timeline of
an example application


193
00:10:02,626 --> 00:10:05,786
and show how you can write the
code that corresponds to all


194
00:10:05,786 --> 00:10:07,966
of these life cycle events.


195
00:10:08,046 --> 00:10:09,696
Let's take a look
at a football app,


196
00:10:09,896 --> 00:10:12,886
and pretend that there's
a big game tonight from 7


197
00:10:12,966 --> 00:10:17,316
to 9:00 p.m. We know our user's
favorite team is playing,


198
00:10:17,436 --> 00:10:19,926
and we expect them to be
checking the score frequently.


199
00:10:20,656 --> 00:10:22,606
Let's settle on a
thirty-minute cadence


200
00:10:22,836 --> 00:10:24,116
for our background activity.


201
00:10:24,676 --> 00:10:28,626
The background refresh
API allows only one task


202
00:10:28,626 --> 00:10:31,556
of each type to be in
flight at any given time.


203
00:10:32,376 --> 00:10:35,976
So to start off, let's schedule
our first task for 7:30.


204
00:10:37,256 --> 00:10:40,996
At 7:30, we'll use that runtime
to schedule the next task for 8.


205
00:10:42,166 --> 00:10:44,136
At 8, we'll again
use the runtime


206
00:10:44,136 --> 00:10:46,136
to schedule our next
event for 8:30.


207
00:10:46,536 --> 00:10:49,896
It is important to always make
sure you have a future task


208
00:10:49,896 --> 00:10:51,366
scheduled, or you won't know


209
00:10:51,366 --> 00:10:53,836
when you'll next
get a chance to run.


210
00:10:55,056 --> 00:10:56,716
Here we see the code


211
00:10:56,716 --> 00:10:59,496
for scheduling an
application task on watchOS.


212
00:11:00,346 --> 00:11:03,096
First, let's set the fire date
to thirty minutes from now.


213
00:11:03,636 --> 00:11:07,186
Use the userInfo object
to store some data


214
00:11:07,186 --> 00:11:08,916
about why you made this request.


215
00:11:09,436 --> 00:11:12,336
In this example, I've put the
date at which I made the request


216
00:11:12,846 --> 00:11:15,366
and a reason string
that I can check later


217
00:11:15,426 --> 00:11:16,446
when the task comes back.


218
00:11:17,346 --> 00:11:18,646
This property is optional,


219
00:11:18,776 --> 00:11:21,936
and any secure coding compliant
data can be stored here.


220
00:11:23,916 --> 00:11:25,916
This completion blog
is how you find


221
00:11:25,916 --> 00:11:29,546
out that the system has
successfully scheduled


222
00:11:29,636 --> 00:11:30,106
your task.


223
00:11:31,016 --> 00:11:33,036
Note that just because
the error is nil here,


224
00:11:33,076 --> 00:11:34,786
it does not mean
the task will run


225
00:11:34,826 --> 00:11:36,536
at exactly the requested time.


226
00:11:37,576 --> 00:11:39,306
Austen will talk more about when


227
00:11:39,306 --> 00:11:41,596
and why the system
triggers certain tasks.


228
00:11:43,806 --> 00:11:45,366
With our application
task scheduled,


229
00:11:45,576 --> 00:11:47,326
let's zoom in on our
timeline and look


230
00:11:47,326 --> 00:11:48,746
at only a five-minute window


231
00:11:48,806 --> 00:11:50,656
in which our task
is scheduled to run.


232
00:11:51,366 --> 00:11:54,526
When the system wakes
us, our priority is


233
00:11:54,566 --> 00:11:56,786
to get the latest score
data from our server.


234
00:11:57,046 --> 00:11:58,326
So let's take a look at the code


235
00:11:58,326 --> 00:12:01,446
for starting a background
URLSession on watchOS.


236
00:12:06,126 --> 00:12:08,996
First, create a URLSession
configuration object.


237
00:12:09,666 --> 00:12:11,796
It is important that
this object be configured


238
00:12:11,796 --> 00:12:14,536
as a background session because
we're running in the background.


239
00:12:16,196 --> 00:12:17,716
Also, set an identifier


240
00:12:17,786 --> 00:12:21,486
that we'll use later
to access our data.


241
00:12:22,026 --> 00:12:25,226
Next, create a URL session
using this configuration.


242
00:12:25,316 --> 00:12:28,976
We ask the URLSession
to give us one


243
00:12:28,976 --> 00:12:32,906
or more download task
objects where we can associate


244
00:12:32,906 --> 00:12:35,406
as many download tasks as
we want with the session.


245
00:12:35,856 --> 00:12:37,886
Keep in mind the
system will only wake us


246
00:12:37,966 --> 00:12:42,706
when all associated
tasks have finished.


247
00:12:42,826 --> 00:12:47,446
Don't forget to call resume
to start downloading the data.


248
00:12:48,576 --> 00:12:49,806
Getting back to our timeline,


249
00:12:49,956 --> 00:12:51,626
we've got the URL
download in progress.


250
00:12:51,706 --> 00:12:53,516
So it is safe to
complete our task


251
00:12:53,516 --> 00:12:55,126
and allow the application
to sleep.


252
00:12:56,046 --> 00:12:58,816
The system will continue
downloading the data while we


253
00:12:58,816 --> 00:12:59,396
are suspended.


254
00:12:59,396 --> 00:13:04,396
When our data is ready,
URLSession will create a task


255
00:13:04,396 --> 00:13:06,286
and wake our application
back up.


256
00:13:06,286 --> 00:13:09,176
But what does wake our
application really mean?


257
00:13:10,746 --> 00:13:14,586
In concrete terms, waking your
application means calling the


258
00:13:14,586 --> 00:13:18,616
new handle background task
method on WKExtensionDelegate.


259
00:13:19,256 --> 00:13:21,546
In addition to this call,


260
00:13:21,646 --> 00:13:23,446
we will receive a
will activate call


261
00:13:23,446 --> 00:13:24,976
on our visible view controllers.


262
00:13:26,636 --> 00:13:30,116
The system coalesces tasks and
delivers them to us as a set.


263
00:13:30,736 --> 00:13:33,096
We need to process all
of the tasks in this set.


264
00:13:33,096 --> 00:13:35,066
So let's get started by
looping through them.


265
00:13:36,266 --> 00:13:39,966
For each task, we can use an
inline task to get an object


266
00:13:39,966 --> 00:13:41,426
of the types we care about.


267
00:13:42,776 --> 00:13:45,216
In this case, we're
processing a URLSession task.


268
00:13:45,516 --> 00:13:49,436
So we need to rejoin the session
using the identifier associated


269
00:13:49,436 --> 00:13:51,746
with the task.


270
00:13:52,186 --> 00:13:54,646
URLSession is a highly
asynchronous API.


271
00:13:55,236 --> 00:13:57,606
We need to be careful
to hold on to our tasks


272
00:13:57,606 --> 00:13:59,486
until we're finished
processing this data.


273
00:14:00,426 --> 00:14:02,896
We recommend you store
the task in a collection


274
00:14:03,106 --> 00:14:04,866
and then drain the
collection when finished,


275
00:14:04,936 --> 00:14:08,006
completing each task to
return it to the system.


276
00:14:10,486 --> 00:14:12,016
Make sure to complete task types


277
00:14:12,016 --> 00:14:13,636
that you don't specifically
handle.


278
00:14:14,166 --> 00:14:16,626
Remember, the system has a
limited number available.


279
00:14:16,726 --> 00:14:18,946
So complete each
one that you get.


280
00:14:19,776 --> 00:14:21,156
We've got our data.


281
00:14:21,386 --> 00:14:22,366
Let's update our model.


282
00:14:22,826 --> 00:14:25,856
You might consider updating
your UI as well at this point,


283
00:14:25,856 --> 00:14:29,136
but we recommend you make use
of this snapshot task runtime


284
00:14:29,196 --> 00:14:30,186
for that type of work.


285
00:14:31,266 --> 00:14:34,186
So before we complete our
URL task, let's make sure


286
00:14:34,186 --> 00:14:35,296
to schedule a snapshot.


287
00:14:37,326 --> 00:14:38,606
With our snapshot scheduled,


288
00:14:38,686 --> 00:14:40,416
it's safe to complete
the URL task


289
00:14:40,496 --> 00:14:42,466
and allow the application
to sleep again.


290
00:14:44,316 --> 00:14:46,196
Soon, the system
will wake us back


291
00:14:46,196 --> 00:14:49,176
up with the snapshot
task we just scheduled.


292
00:14:49,926 --> 00:14:51,916
Now is our chance
to update our UI,


293
00:14:51,916 --> 00:14:54,426
and get everything ready
for the new snapshot.


294
00:14:56,216 --> 00:14:59,116
Snapshots have a unique
completion handler.


295
00:14:59,326 --> 00:15:01,276
So let's take a look at
the completion handler


296
00:15:01,396 --> 00:15:02,876
for snapshots on watchOS.


297
00:15:03,596 --> 00:15:08,466
Every application must have
a snapshot at all times.


298
00:15:09,226 --> 00:15:11,786
This is because your snapshot
is both your launch image


299
00:15:12,306 --> 00:15:14,516
and your preview image
while running in the dock.


300
00:15:15,376 --> 00:15:17,836
That rule means that when
we complete a snapshot,


301
00:15:18,576 --> 00:15:21,516
we need to tell the system
how long it is valid for.


302
00:15:22,306 --> 00:15:25,186
Think about your data and
how long it will be relevant


303
00:15:25,236 --> 00:15:25,946
to your users.


304
00:15:26,946 --> 00:15:29,366
In this case, we have another
event scheduled at eight.


305
00:15:29,696 --> 00:15:34,036
So let's set our expiration
for thirty minutes from now.


306
00:15:35,196 --> 00:15:37,766
User info can optionally
store some information


307
00:15:37,766 --> 00:15:39,246
about why we made this request.


308
00:15:39,706 --> 00:15:45,556
That data will return to us
with our next snapshot task.


309
00:15:45,716 --> 00:15:48,866
WatchOS will give your
application an opportunity


310
00:15:48,866 --> 00:15:52,176
to restore its default state
after one hour of inactivity.


311
00:15:52,986 --> 00:15:55,246
You can tell the system
to skip that event


312
00:15:55,596 --> 00:15:57,966
by setting the
restoredDefaultState property


313
00:15:58,136 --> 00:15:58,596
to true.


314
00:15:59,556 --> 00:16:02,146
Doing this lets the system
know that you are already


315
00:16:02,146 --> 00:16:04,926
at your default state, and don't
need an extra task for that.


316
00:16:05,976 --> 00:16:07,426
Apps that have no concept


317
00:16:07,426 --> 00:16:10,136
of a default state should
consider always setting this


318
00:16:10,176 --> 00:16:12,666
property to true.


319
00:16:13,096 --> 00:16:14,716
Once you complete
a snapshot task,


320
00:16:14,936 --> 00:16:16,906
the system will suspend
your application.


321
00:16:17,416 --> 00:16:20,376
Your UI will then be
automatically captured and used


322
00:16:20,376 --> 00:16:21,526
as your new launch image.


323
00:16:22,316 --> 00:16:24,946
This activity will not
wake your application.


324
00:16:25,306 --> 00:16:30,196
We've made it through
an end-to-end example


325
00:16:30,326 --> 00:16:34,026
of a common background refresh
pattern and the associated code.


326
00:16:34,836 --> 00:16:36,976
In case you didn't notice,
even though we were looking


327
00:16:36,976 --> 00:16:38,996
at a whole five minutes
on our timeline,


328
00:16:39,486 --> 00:16:42,796
our application was only
active for 15 total seconds.


329
00:16:44,016 --> 00:16:45,726
By chaining tasks, we were able


330
00:16:45,726 --> 00:16:48,456
to maximize our use
of system resources.


331
00:16:50,046 --> 00:16:51,966
You now have a good
understanding


332
00:16:52,026 --> 00:16:55,806
of what this new API is,
why you should adopt it,


333
00:16:56,296 --> 00:16:58,686
and how you can go
about adopting it.


334
00:16:59,306 --> 00:17:02,336
I'd like to welcome
Austen Green to the stage


335
00:17:02,416 --> 00:17:03,956
to give you some deeper insights


336
00:17:03,956 --> 00:17:06,846
into how scheduling
works behind the scenes.


337
00:17:09,465 --> 00:17:09,945
Good luck [applause].


338
00:17:14,116 --> 00:17:14,465
>> Hi, everyone.


339
00:17:14,626 --> 00:17:15,476
I'm Austen Green.


340
00:17:15,626 --> 00:17:16,945
I'm a watchOS engineer.


341
00:17:17,286 --> 00:17:21,626
This morning, I would like to
share with you some details


342
00:17:21,746 --> 00:17:24,116
about how scheduling
works behind the scenes.


343
00:17:24,626 --> 00:17:27,455
I'd like to provide some
best practices that we picked


344
00:17:27,455 --> 00:17:30,556
up as we adopted background
refresh in our own applications.


345
00:17:31,106 --> 00:17:33,216
And, finally, I'd like to
close with a quick case study


346
00:17:33,626 --> 00:17:36,336
about specifically how we
adopted background refresh


347
00:17:36,396 --> 00:17:37,556
in our stocks application.


348
00:17:38,836 --> 00:17:39,556
So let's get started.


349
00:17:39,556 --> 00:17:45,306
So the first thing I want
to talk about is runtime.


350
00:17:46,186 --> 00:17:48,896
So while your application
is in the foreground,


351
00:17:50,016 --> 00:17:51,336
you're always scheduled to run.


352
00:17:51,896 --> 00:17:54,836
This means that your
code gets to execute


353
00:17:55,186 --> 00:17:57,876
so that you can do things
like update your model


354
00:17:58,066 --> 00:18:00,516
and draw your UI, and
any other kinds of tasks


355
00:18:00,516 --> 00:18:02,776
that your application
may need to do.


356
00:18:03,286 --> 00:18:04,836
Now when your application moves


357
00:18:04,836 --> 00:18:07,526
into the background the
system will typically suspend


358
00:18:07,526 --> 00:18:08,326
your application.


359
00:18:08,856 --> 00:18:11,016
This means that your
application doesn't get a chance


360
00:18:11,016 --> 00:18:12,386
to execute any code at all.


361
00:18:13,886 --> 00:18:15,936
Now sometimes while
your application is


362
00:18:15,936 --> 00:18:18,496
in the background, the system
may want your application


363
00:18:18,766 --> 00:18:20,306
to perform a very specific task.


364
00:18:20,746 --> 00:18:24,426
The system will wake your
application and ask you


365
00:18:24,426 --> 00:18:27,456
to perform a specific task
that it may want you to do.


366
00:18:27,956 --> 00:18:30,626
In watchOS 2, there
were several ways


367
00:18:30,626 --> 00:18:32,506
that the system could
wake your application.


368
00:18:32,726 --> 00:18:36,046
For example, to handle a
long look notification,


369
00:18:36,996 --> 00:18:39,336
or perhaps ClockKit would
ask your application


370
00:18:39,486 --> 00:18:40,896
to update its complication.


371
00:18:41,746 --> 00:18:44,986
In watchOS 3, we're adding even
more ways for your application


372
00:18:45,066 --> 00:18:45,886
to run in the background.


373
00:18:50,046 --> 00:18:53,786
Now the system is going to
apply some limits to the amount


374
00:18:53,786 --> 00:18:56,966
of time that you get to run
while in the background.


375
00:18:57,556 --> 00:19:01,826
These limits are on the order of
seconds, and the system is going


376
00:19:01,826 --> 00:19:04,986
to consider the amount of
time that you use as well


377
00:19:04,986 --> 00:19:06,676
as the amount of CPU you use.


378
00:19:06,956 --> 00:19:10,006
So it's in your best interest
to complete your work as quickly


379
00:19:10,086 --> 00:19:11,696
and as efficiently as possible.


380
00:19:13,016 --> 00:19:15,756
Now in a later seed, if
you exceed these limits,


381
00:19:16,326 --> 00:19:17,726
the system will kill
your application.


382
00:19:18,496 --> 00:19:19,536
You'll get a crash report,


383
00:19:19,656 --> 00:19:22,126
and you'll know whether
you exceeded the CPU limits


384
00:19:22,626 --> 00:19:24,056
or the time limits based


385
00:19:24,056 --> 00:19:26,496
on the exception code
in the crash report.


386
00:19:26,936 --> 00:19:32,436
Now we recognize that different
tasks may have different needs.


387
00:19:32,916 --> 00:19:34,416
So ApplicationRefresh task


388
00:19:34,826 --> 00:19:38,396
and the URLSession task have
a little bit longer limits


389
00:19:38,906 --> 00:19:41,746
than watch connectivity
and your snapshot task.


390
00:19:52,446 --> 00:19:56,546
So in watchOS 2, complications
were the primary way


391
00:19:56,546 --> 00:19:58,716
that your application got
runtime while in the background.


392
00:19:59,936 --> 00:20:02,696
In watchOS 3, we're going to
make sure that you continue


393
00:20:02,696 --> 00:20:04,156
to get multiple updates an hour


394
00:20:04,226 --> 00:20:06,616
if you're a complication
application on par


395
00:20:06,616 --> 00:20:08,516
with what you were
receiving in watchOS 2.


396
00:20:09,546 --> 00:20:13,616
However, if you were previously
asking the system for runtime


397
00:20:13,616 --> 00:20:14,876
to update your complication
data,


398
00:20:15,616 --> 00:20:18,146
you can now request
updates through WKExtension.


399
00:20:18,216 --> 00:20:19,666
I'll show you how to do
that in just a minute.


400
00:20:21,066 --> 00:20:25,296
Also, new in watchOS 3, we're
guaranteeing you fifty pushes


401
00:20:25,296 --> 00:20:28,986
from your parent iPhone if
you're using watch connectivity.


402
00:20:29,456 --> 00:20:32,586
It's really easy to take
advantage of this information


403
00:20:32,846 --> 00:20:36,166
to make sure that you have a
great complication experience


404
00:20:36,166 --> 00:20:37,846
for your users all day long.


405
00:20:38,716 --> 00:20:42,446
Let's take a look at some code.


406
00:20:42,446 --> 00:20:46,596
So let's say that you're running
an iPhone app, and you notice


407
00:20:46,596 --> 00:20:47,496
that your model changed.


408
00:20:48,656 --> 00:20:50,776
You can now query WCSession,


409
00:20:51,036 --> 00:20:53,636
remainingComplication
UserInfoTransfers to figure


410
00:20:53,636 --> 00:20:56,596
out how many high-priority
pushes you have left


411
00:20:56,846 --> 00:20:58,516
for the rest of the day.


412
00:20:58,516 --> 00:21:01,086
You can use this information


413
00:21:01,376 --> 00:21:04,246
to tailor your complication
experience and determine


414
00:21:04,246 --> 00:21:06,866
when the best time is for you
to send your complication data.


415
00:21:08,146 --> 00:21:09,936
So let's say in the
default case,


416
00:21:10,686 --> 00:21:11,936
you've got plenty of pushes.


417
00:21:12,716 --> 00:21:14,276
Go ahead and send
your data immediately.


418
00:21:14,476 --> 00:21:16,946
The user will see your
data that's most relevant


419
00:21:17,356 --> 00:21:18,346
almost immediately.


420
00:21:19,476 --> 00:21:22,576
Now let's say that you've been
pushing a lot, and you're sort


421
00:21:22,576 --> 00:21:24,336
of running low on, on transfers.


422
00:21:24,816 --> 00:21:29,156
So you might consider throttling
the data that you send


423
00:21:29,156 --> 00:21:30,116
to the watch to make sure


424
00:21:30,116 --> 00:21:34,166
that your user will have
complication data updates


425
00:21:34,226 --> 00:21:35,336
throughout the rest of the day.


426
00:21:36,376 --> 00:21:40,526
Finally, if you don't have any
high-priority transfers left,


427
00:21:40,806 --> 00:21:43,586
it's still okay to try and
send this data, however,


428
00:21:44,016 --> 00:21:46,276
the data will get sent
at a lower priority.


429
00:21:47,306 --> 00:21:51,096
Next, I'd like to
talk about some


430
00:21:51,096 --> 00:21:54,166
of the CLKComplication
DataSource methods that we'd


431
00:21:54,166 --> 00:21:56,066
like to move into WatchKit.


432
00:21:56,626 --> 00:22:00,676
If you were previously
asking the system for runtime


433
00:22:00,946 --> 00:22:02,696
with getNextRequested
UpdateDate.


434
00:22:05,576 --> 00:22:10,496
You should now expect the system
to schedule a background refresh


435
00:22:10,606 --> 00:22:12,536
with a preferred
date, the same date


436
00:22:12,536 --> 00:22:14,606
that you were telling
ClockKit previously.


437
00:22:16,116 --> 00:22:19,556
Similarly, when ClockKit
wanted your application to run,


438
00:22:19,846 --> 00:22:21,586
it would call requestedUpdate
DidBegin.


439
00:22:22,636 --> 00:22:25,406
Now we want to do that
at your application level


440
00:22:26,006 --> 00:22:28,666
with handle background refreshed
or handle backgroundTasks.


441
00:22:29,116 --> 00:22:30,986
You'll get an application task


442
00:22:31,096 --> 00:22:33,326
to handle both complication
updates


443
00:22:33,606 --> 00:22:37,736
and your application updates.


444
00:22:38,336 --> 00:22:41,186
Now, new in watchOS 3,
we've introduced the dock.


445
00:22:41,376 --> 00:22:44,246
We think it's a great way
for users to quickly get


446
00:22:44,246 --> 00:22:47,116
at their favorite applications
and have a glanceable view


447
00:22:47,116 --> 00:22:50,146
of all of the information
that they care about.


448
00:22:50,616 --> 00:22:53,236
We want your applications in
the dock to be up to date.


449
00:22:53,576 --> 00:22:55,176
So we're going to
guarantee you a minimum


450
00:22:55,176 --> 00:22:56,316
of one update per hour.


451
00:22:56,466 --> 00:23:00,366
This applies to a snapshot task
and an application refresh task.


452
00:23:01,136 --> 00:23:04,706
Now this budget is distributed
across all of the applications


453
00:23:04,856 --> 00:23:08,046
in the dock, and the user can
pick how many applications they


454
00:23:08,046 --> 00:23:08,796
want in their dock.


455
00:23:09,096 --> 00:23:12,866
Consequence of this is that if a
user has fewer apps in the dock,


456
00:23:13,296 --> 00:23:16,376
then your application can
get more opportunities to run


457
00:23:16,376 --> 00:23:18,466
in the background
during any given hour.


458
00:23:19,656 --> 00:23:22,246
Also, we keep your
applications in memory


459
00:23:22,696 --> 00:23:25,446
so that resumes are fast,
and the user can interact


460
00:23:25,446 --> 00:23:27,176
with your application
if they settle on it


461
00:23:27,386 --> 00:23:30,876
as quickly as possible.


462
00:23:30,876 --> 00:23:32,736
Also in the dock,
we have the concept


463
00:23:32,736 --> 00:23:34,416
of a most recently used app.


464
00:23:35,476 --> 00:23:37,866
This application occupies
the last slot in the dock,


465
00:23:38,356 --> 00:23:40,946
and the users are given
an opportunity to keep it


466
00:23:40,946 --> 00:23:42,936
in the dock by pressing
the button.


467
00:23:44,116 --> 00:23:46,256
Now this application
is treated exactly


468
00:23:46,256 --> 00:23:48,476
like a user's favorite
application


469
00:23:48,736 --> 00:23:50,836
that the user has explicitly
added into the dock.


470
00:23:52,026 --> 00:23:56,356
This means that this application
will receive background refresh


471
00:23:56,356 --> 00:23:57,946
tasks and snapshot tasks


472
00:23:58,206 --> 00:23:59,896
like any other application
in the dock.


473
00:24:00,166 --> 00:24:02,986
So you should always make
sure that you schedule


474
00:24:03,026 --> 00:24:04,906
with the system any application,


475
00:24:04,986 --> 00:24:08,146
any background refresh
request that you may need.


476
00:24:09,156 --> 00:24:11,876
Now home screen applications
shouldn't expect


477
00:24:11,876 --> 00:24:12,836
regular scheduling.


478
00:24:13,186 --> 00:24:15,866
So just keep that in mind.


479
00:24:17,426 --> 00:24:20,636
As Eric mentioned
earlier, the snapshots


480
00:24:20,636 --> 00:24:24,656
of your application are
critical to the experience


481
00:24:24,876 --> 00:24:27,326
of your application in
the dock on watchOS 3.


482
00:24:28,856 --> 00:24:30,756
There may be times
when the system needs


483
00:24:30,756 --> 00:24:34,376
to snapshot your application
for various reasons.


484
00:24:35,146 --> 00:24:38,076
Now if the system
asks your application


485
00:24:38,156 --> 00:24:40,496
to perform a snapshot
because we think we need one,


486
00:24:41,206 --> 00:24:42,806
these snapshots don't
count against your budget,


487
00:24:43,336 --> 00:24:46,246
and they're in addition
to the requested snapshots


488
00:24:46,376 --> 00:24:47,566
that you've asked of the system.


489
00:24:48,416 --> 00:24:51,266
There are five triggers
that can cause the system


490
00:24:51,266 --> 00:24:52,986
to ask your application
for a snapshot.


491
00:24:53,526 --> 00:24:58,606
If your complication timeline
updates, if the user interacts


492
00:24:58,606 --> 00:24:59,966
with one of your notifications,


493
00:25:00,676 --> 00:25:03,566
this means that the notification
was actively dismissed,


494
00:25:03,796 --> 00:25:06,126
and it doesn't count if it goes
in the notification center.


495
00:25:06,666 --> 00:25:09,506
When you go from the
foreground to the background,


496
00:25:10,126 --> 00:25:11,646
and then again, one hour later


497
00:25:11,646 --> 00:25:13,326
to give your application
a chance to return


498
00:25:13,326 --> 00:25:15,276
to its default state,
if appropriate.


499
00:25:16,526 --> 00:25:19,086
And, finally, in order to
get everything started,


500
00:25:19,346 --> 00:25:21,196
the system is going to
ask your application


501
00:25:21,196 --> 00:25:22,376
for a snapshot on boot.


502
00:25:23,026 --> 00:25:24,076
This is your opportunity


503
00:25:24,186 --> 00:25:26,726
to start scheduling any other
background refresh tasks


504
00:25:26,806 --> 00:25:31,626
with the system.


505
00:25:31,756 --> 00:25:34,416
Now, I'd like to take
a few minutes to share


506
00:25:34,416 --> 00:25:37,536
with you some best practices
that we picked up along the way


507
00:25:37,626 --> 00:25:40,676
as we adopt a background
refresh in our own applications.


508
00:25:43,056 --> 00:25:46,386
So, first of all, the
system wants to know


509
00:25:46,386 --> 00:25:48,476
as much information as
we can about your needs.


510
00:25:48,656 --> 00:25:50,606
So schedule as often
as you need to.


511
00:25:51,376 --> 00:25:53,486
Every time your application
gets a chance to run,


512
00:25:53,756 --> 00:25:56,206
you should consider
re-evaluating your background


513
00:25:56,206 --> 00:25:59,626
refresh needs and scheduling
with the system as appropriate.


514
00:26:00,196 --> 00:26:03,656
You should not feel
obligated to do work, however.


515
00:26:03,796 --> 00:26:05,366
If the system calls
your application back


516
00:26:05,366 --> 00:26:08,326
for a background refresh task,
and it doesn't make sense,


517
00:26:08,326 --> 00:26:10,056
maybe you just updated
your data already,


518
00:26:10,586 --> 00:26:13,336
need to do anything else,
finish as soon as possible.


519
00:26:13,386 --> 00:26:18,076
Or better yet, in the, in the
past when you've done that work,


520
00:26:18,146 --> 00:26:21,366
consider deferring
any additional work


521
00:26:21,366 --> 00:26:22,586
that you've scheduled
with the system.


522
00:26:22,586 --> 00:26:26,326
You should consider all
the runtime opportunities


523
00:26:26,546 --> 00:26:27,826
that you get to make sure


524
00:26:27,826 --> 00:26:29,366
that you keep your
application up to date.


525
00:26:29,696 --> 00:26:32,046
This means updating
your model and your UI


526
00:26:32,046 --> 00:26:34,236
and scheduling background
tasks for the system.


527
00:26:34,936 --> 00:26:37,746
So for dock and foreground
activations, notifications,


528
00:26:37,746 --> 00:26:39,636
complication updates,
background refresh.


529
00:26:39,636 --> 00:26:42,436
There's any number of reasons
why your application may get


530
00:26:42,436 --> 00:26:45,686
runtime, and you should keep
all of them in mind as you try


531
00:26:45,686 --> 00:26:48,636
and keep your application
up to date.


532
00:26:48,916 --> 00:26:54,146
So application refresh
background tasks is your entry


533
00:26:54,146 --> 00:26:57,206
point into general purpose
runtime while you're


534
00:26:57,206 --> 00:26:59,896
in the background, and we think
there's some great use cases


535
00:26:59,896 --> 00:27:00,366
for this.


536
00:27:00,756 --> 00:27:03,466
You can do things like
pull the system database.


537
00:27:04,266 --> 00:27:06,506
Maybe you need to read
the HealthKit database


538
00:27:06,506 --> 00:27:08,256
or the calendar database
periodically.


539
00:27:09,356 --> 00:27:11,516
You can use this to
schedule future URL sessions.


540
00:27:11,586 --> 00:27:13,576
This is what we do in
our stocks application.


541
00:27:13,626 --> 00:27:15,946
If you have known
time transitions,


542
00:27:16,186 --> 00:27:19,086
you can tell the system the
exact date that you think


543
00:27:19,086 --> 00:27:21,346
that it would be great
to run your application.


544
00:27:21,706 --> 00:27:23,426
For example, a calendar
application


545
00:27:23,426 --> 00:27:27,716
or an itinerary application
may have very well defined


546
00:27:27,716 --> 00:27:28,666
time transitions.


547
00:27:29,776 --> 00:27:32,586
And, finally, if you were
previously getting background


548
00:27:32,586 --> 00:27:35,356
runtime through the ClockKit
API's, we want you to move


549
00:27:35,826 --> 00:27:38,916
to the WatchKit API's to
trigger complication updates.


550
00:27:38,916 --> 00:27:45,376
Now let's talk about some best
practices for your snapshots.


551
00:27:47,276 --> 00:27:50,326
The snapshot is a
system-owned cache


552
00:27:50,446 --> 00:27:53,236
of your application's
data, and like any cache,


553
00:27:54,066 --> 00:27:55,206
that data can become stale.


554
00:27:55,206 --> 00:27:58,156
So the system wants to know
when that data is stale.


555
00:27:59,116 --> 00:28:02,126
You can tell the system
that your snapshot needs


556
00:28:02,126 --> 00:28:04,996
to be updated by scheduling a
new snapshot request for now.


557
00:28:06,316 --> 00:28:09,386
Now you should think in terms
of significant content change


558
00:28:09,606 --> 00:28:11,256
when you're trying to
invalidate your snapshot.


559
00:28:11,876 --> 00:28:12,996
You wouldn't want
to do something


560
00:28:13,396 --> 00:28:14,996
like high-frequency
invalidation.


561
00:28:15,486 --> 00:28:18,966
For example, in a timer
application that's counting


562
00:28:18,966 --> 00:28:19,996
down, you wouldn't want


563
00:28:19,996 --> 00:28:22,156
to update our snapshot
every single second.


564
00:28:22,406 --> 00:28:23,396
This doesn't make sense.


565
00:28:23,546 --> 00:28:25,516
Instead, you would
want to tell the system


566
00:28:25,516 --> 00:28:26,346
to update your snapshot


567
00:28:26,696 --> 00:28:29,366
when something significant has
happened like the timer's ended.


568
00:28:29,366 --> 00:28:33,906
Now I know this is complex,


569
00:28:34,086 --> 00:28:38,666
and I'd like to share what
I think is a great data flow


570
00:28:38,936 --> 00:28:40,296
for how to manage
this complexity.


571
00:28:41,586 --> 00:28:43,836
So let's say that you
get some external event.


572
00:28:44,276 --> 00:28:45,456
Maybe it's watch connectivity.


573
00:28:45,456 --> 00:28:46,786
Maybe it's NSURLSession.


574
00:28:47,146 --> 00:28:49,626
Maybe you just happened
to run in the foreground


575
00:28:49,626 --> 00:28:51,046
because the user
launched your application.


576
00:28:51,646 --> 00:28:55,756
Basically, anything that causes
you to update your model.


577
00:28:57,116 --> 00:28:59,586
All of the operations
that we want you to do


578
00:29:00,246 --> 00:29:03,086
for background refresh are in
response to your model changes.


579
00:29:03,476 --> 00:29:05,826
For example, updating
your complication,


580
00:29:06,096 --> 00:29:07,376
requesting a new snapshot,


581
00:29:07,966 --> 00:29:10,696
and then evaluating what your
next background refresh needs


582
00:29:10,696 --> 00:29:12,906
are, whether it's for a
background URLSession,


583
00:29:12,906 --> 00:29:14,436
or just scheduling
arbitrary runtime


584
00:29:14,436 --> 00:29:16,276
with a background refresh API.


585
00:29:22,066 --> 00:29:24,046
Now with the dock in watchOS 3,


586
00:29:24,476 --> 00:29:26,846
we think that users
are going to,


587
00:29:28,156 --> 00:29:30,406
we think that users are
going to be in and out


588
00:29:30,406 --> 00:29:32,676
of many applications
much more often


589
00:29:32,676 --> 00:29:33,886
than they were in watchOS 2.


590
00:29:34,646 --> 00:29:37,256
Now in watchOS 2, you
already had to be prepared


591
00:29:37,256 --> 00:29:40,576
to enter the foreground or enter
the background at any time,


592
00:29:40,576 --> 00:29:42,346
but we think these
transitions are going


593
00:29:42,346 --> 00:29:45,056
to happen a lot more often now.


594
00:29:45,256 --> 00:29:48,266
So you should make sure that
you finish any background task


595
00:29:48,266 --> 00:29:50,576
as soon as possible on
foreground activation.


596
00:29:51,916 --> 00:29:54,036
When your application
activates in the foreground,


597
00:29:54,236 --> 00:29:56,656
you don't want to be
doing any additional work.


598
00:29:57,036 --> 00:29:59,156
You just want to do the
work that makes sense


599
00:29:59,236 --> 00:30:01,976
for displaying your
UI to the user.


600
00:30:02,046 --> 00:30:04,996
Similarly, when you entered
background after being


601
00:30:04,996 --> 00:30:07,656
in the foreground, you should
finish any foreground work


602
00:30:07,656 --> 00:30:09,366
that you were doing
as soon as possible.


603
00:30:09,906 --> 00:30:12,846
Now we recognize that you
might need a little bit of time


604
00:30:13,216 --> 00:30:15,426
to complete any foreground
work, and you can do this


605
00:30:15,426 --> 00:30:16,936
by using NSProcessInfo.


606
00:30:16,936 --> 00:30:18,296
performExpiringActivity.


607
00:30:19,466 --> 00:30:23,576
There's a great session from
last year's WWDC, WatchKit Tips


608
00:30:23,576 --> 00:30:25,806
and Tricks that tells you
exactly how you should


609
00:30:25,806 --> 00:30:26,956
use NSProcessInfo.


610
00:30:26,956 --> 00:30:28,166
performExpiringActivity.


611
00:30:29,436 --> 00:30:32,256
Finally, one more thing I want
to mention, data protection.


612
00:30:33,176 --> 00:30:36,916
Now, typically, a user will put
their watch on in the morning


613
00:30:37,606 --> 00:30:40,496
and unlock it, and the watch
will be unlocked all day long


614
00:30:40,496 --> 00:30:42,936
until they take it off at night,
and put it back on the charger.


615
00:30:45,446 --> 00:30:46,366
Certain types of data


616
00:30:46,486 --> 00:30:49,966
on the watch are completely
inaccessible while the device


617
00:30:49,966 --> 00:30:50,466
is locked.


618
00:30:51,056 --> 00:30:54,436
For example, the most prominent
case is the HealthKit database.


619
00:30:54,906 --> 00:30:56,356
So you should just make sure


620
00:30:56,356 --> 00:30:58,686
that you consider
what your approach is


621
00:30:58,756 --> 00:31:01,436
if your data is not
available for snapshotting.


622
00:31:05,376 --> 00:31:08,246
And then I'd like to
share some testing tips.


623
00:31:09,596 --> 00:31:12,246
The simulator is going to be
great for iterative development.


624
00:31:12,606 --> 00:31:14,736
As I mentioned before,
we have some budgets,


625
00:31:15,106 --> 00:31:16,436
but in a simulator,
we're not going


626
00:31:16,436 --> 00:31:17,666
to enforce any of those budgets.


627
00:31:17,666 --> 00:31:21,636
So you should basically get
your task called at the dates


628
00:31:21,636 --> 00:31:23,166
that you want them
while in the simulator.


629
00:31:24,836 --> 00:31:26,816
Similarly, while
you're on the device,


630
00:31:27,576 --> 00:31:30,286
we may still apply some
budgets, but you're going


631
00:31:30,286 --> 00:31:32,296
to have the best experience
while you're on the charger.


632
00:31:32,736 --> 00:31:37,286
You need to make sure that
you test both the launch path


633
00:31:37,286 --> 00:31:37,936
and the resume path.


634
00:31:38,276 --> 00:31:40,516
The system is going to do its
best to keep your application


635
00:31:40,516 --> 00:31:43,756
in memory, but in the
case of bootstrapping,


636
00:31:43,806 --> 00:31:46,326
the system will have to launch
your application in order


637
00:31:46,636 --> 00:31:48,116
to request the initial snapshot.


638
00:31:48,556 --> 00:31:51,726
Verify that your tasks
are being completed.


639
00:31:52,406 --> 00:31:55,126
In a future seed, you'll get
a crash report if you fail


640
00:31:55,126 --> 00:31:56,426
to complete your tasks in time.


641
00:31:56,986 --> 00:31:59,876
And it's super important that
your application doesn't crash


642
00:31:59,876 --> 00:32:01,966
because we want your
application to be as responsive


643
00:32:01,966 --> 00:32:03,176
as possible for users.


644
00:32:03,686 --> 00:32:07,776
And, finally, once you think
you have your background refresh


645
00:32:07,776 --> 00:32:09,816
strategy implemented,
you should live on it.


646
00:32:10,326 --> 00:32:11,806
Make sure that you're
getting the experience


647
00:32:11,806 --> 00:32:13,246
that you want your
users to have.


648
00:32:14,096 --> 00:32:16,486
You should vary the number
of applications that are


649
00:32:16,486 --> 00:32:20,056
in your dock to make sure
that you test the best-


650
00:32:20,056 --> 00:32:22,506
and worst-case scenarios for
when you'll be scheduled.


651
00:32:23,236 --> 00:32:25,446
Now, I'd like to share
a quick case study


652
00:32:25,586 --> 00:32:27,306
on how we adopted
background refresh


653
00:32:27,536 --> 00:32:28,626
in our stocks application.


654
00:32:30,436 --> 00:32:33,376
So before we even got
started writing any code,


655
00:32:34,266 --> 00:32:38,156
we took a step back and thought
about the characteristics


656
00:32:38,466 --> 00:32:40,326
that are interesting
for background refresh


657
00:32:40,636 --> 00:32:41,776
for our stocks application.


658
00:32:43,416 --> 00:32:49,836
We use a URLSession to retrieve
server data, and we're going


659
00:32:49,836 --> 00:32:51,056
to have a complication.


660
00:32:51,736 --> 00:32:54,176
This means that we know
that we have multiple views


661
00:32:54,176 --> 00:32:55,566
of our data across the system.


662
00:32:55,566 --> 00:32:57,916
With our complication,
our snapshot,


663
00:32:58,586 --> 00:33:01,006
and now our live application.


664
00:33:03,716 --> 00:33:04,936
We know that we want


665
00:33:05,396 --> 00:33:08,116
to be periodic throughout
part of the day.


666
00:33:08,716 --> 00:33:11,236
We want to get regular
updates for our application,


667
00:33:12,636 --> 00:33:14,346
but then we know something
interesting about our data,


668
00:33:14,756 --> 00:33:17,896
which is that once the
markets closed, our data's good


669
00:33:17,896 --> 00:33:18,906
for the rest of the day.


670
00:33:19,276 --> 00:33:20,506
It's not going to change at all.


671
00:33:21,106 --> 00:33:23,566
Well, let's talk about how this
looks like throughout the day.


672
00:33:24,956 --> 00:33:27,456
So let's say our device boots.


673
00:33:27,766 --> 00:33:30,706
The system is going to ask our
application for a snapshot.


674
00:33:31,686 --> 00:33:33,976
So we'll load our last data,
and we'll prepare our UI,


675
00:33:34,136 --> 00:33:36,016
but before we complete
our snapshot task,


676
00:33:36,426 --> 00:33:39,856
we're going to schedule a
background at URLSession task.


677
00:33:40,336 --> 00:33:41,546
Now this is our opportunity


678
00:33:41,786 --> 00:33:45,086
to start the background
refresh cycle, and make sure


679
00:33:45,086 --> 00:33:47,946
that we can download the most
up-to-date data for our users.


680
00:33:49,016 --> 00:33:52,896
Now we're going to use an
NSURLSession DownloadTask


681
00:33:53,606 --> 00:33:56,586
so that we can give
the system information


682
00:33:56,586 --> 00:33:58,066
about what data we
want to download,


683
00:33:58,466 --> 00:34:01,226
and the system can put
our application to sleep


684
00:34:01,226 --> 00:34:02,636
and download our data
in the background.


685
00:34:04,056 --> 00:34:08,906
Now URLSession DataTask does
work on a background session,


686
00:34:09,196 --> 00:34:13,556
however, it will fail if your
background app or it will fail


687
00:34:13,886 --> 00:34:15,636
when your application
gets suspended.


688
00:34:15,966 --> 00:34:19,926
And because of the time
limits for background refresh,


689
00:34:19,926 --> 00:34:21,476
your application is likely going


690
00:34:21,476 --> 00:34:23,795
to suspend before your
data is available.


691
00:34:23,985 --> 00:34:26,966
So we could recommend
using the download task.


692
00:34:28,016 --> 00:34:30,996
So a little bit later,
the system is going


693
00:34:30,996 --> 00:34:32,045
to wake our application


694
00:34:32,045 --> 00:34:33,516
up because we finished
our download.


695
00:34:34,476 --> 00:34:36,045
So we're going to
update our model,


696
00:34:36,295 --> 00:34:37,726
and because we've
updated our model,


697
00:34:37,926 --> 00:34:39,386
we're going to do three things.


698
00:34:39,946 --> 00:34:42,126
We're going to trigger
a complication update,


699
00:34:43,206 --> 00:34:44,826
and we're also going
to tell the system


700
00:34:44,826 --> 00:34:46,916
that our snapshot
is invalid by asking


701
00:34:46,916 --> 00:34:50,436
for a new snapshot right now,
and then we're also going


702
00:34:50,436 --> 00:34:53,416
to evaluate what our next
background refresh needs are.


703
00:34:54,056 --> 00:34:56,786
So we'll figure out what the
next time we want to run is,


704
00:34:56,846 --> 00:34:59,036
and we'll tell the system that.


705
00:34:59,216 --> 00:35:02,936
Now a little bit later, we get
to run for background refresh,


706
00:35:03,316 --> 00:35:05,656
and all we're doing here
is scheduling our next


707
00:35:05,656 --> 00:35:06,786
URLSession download.


708
00:35:07,696 --> 00:35:11,596
So we complete this cycle
several times thoughout the day.


709
00:35:12,726 --> 00:35:14,356
Just keeping our
application up to date,


710
00:35:14,356 --> 00:35:16,926
the system will snapshot us, and
if the user views our snapshot


711
00:35:16,926 --> 00:35:20,286
in the dock, we'll have the
most recent data available


712
00:35:20,286 --> 00:35:20,966
in our snapshot.


713
00:35:22,616 --> 00:35:25,376
Well, let's say that the user
activates our app from the dock.


714
00:35:26,066 --> 00:35:28,666
So we go full screen,
and we want to make sure


715
00:35:28,666 --> 00:35:30,436
that our users have the
most up-to-date data.


716
00:35:30,746 --> 00:35:34,096
So we'll download the
most up-to-date data again


717
00:35:34,426 --> 00:35:35,656
because we've entered
the foreground.


718
00:35:36,216 --> 00:35:40,636
And, and once we've updated our
model, we still do three things.


719
00:35:40,846 --> 00:35:42,286
We request a complication
update,


720
00:35:42,906 --> 00:35:44,096
we request a new snapshot,


721
00:35:44,096 --> 00:35:46,976
and then we schedule a
background refresh again


722
00:35:46,976 --> 00:35:47,666
for a later time.


723
00:35:47,666 --> 00:35:49,606
Now there's two things I
want to point out here.


724
00:35:50,206 --> 00:35:51,816
First of all, we're
in the foreground,


725
00:35:51,946 --> 00:35:53,566
but we're still requesting
a new snapshot.


726
00:35:54,326 --> 00:35:57,396
This is absolutely okay, and we
really expect you to do this.


727
00:35:57,756 --> 00:35:59,766
We want you to request a
new snapshot whenever your


728
00:35:59,766 --> 00:36:00,536
model changes.


729
00:36:00,786 --> 00:36:02,186
The system is smart
enough to know


730
00:36:02,186 --> 00:36:03,516
when your application's
foreground,


731
00:36:03,986 --> 00:36:08,186
and when it's not okay for us
to send you a snapshot task.


732
00:36:08,316 --> 00:36:10,996
The second thing is because
we run in the foreground


733
00:36:11,596 --> 00:36:14,276
and updated our model,
it makes sense for us


734
00:36:14,276 --> 00:36:16,296
to evaluate our next
before refresh needs.


735
00:36:16,886 --> 00:36:18,946
If we knew that we were
probably going to run


736
00:36:18,946 --> 00:36:21,346
in the next ten minutes, but
we've just downloaded our data,


737
00:36:22,436 --> 00:36:26,076
we can defer our snap, or we
can defer our background refresh


738
00:36:26,076 --> 00:36:29,546
request with the system
to maximize the amount


739
00:36:29,546 --> 00:36:30,716
of time that we get to run.


740
00:36:31,016 --> 00:36:33,056
To maximize the number


741
00:36:33,056 --> 00:36:37,116
of opportunities
that we get to run.


742
00:36:37,206 --> 00:36:39,966
Finally, the last update
after market closes.


743
00:36:41,296 --> 00:36:42,966
We know our data stopped
changing for the day,


744
00:36:44,056 --> 00:36:45,636
but we'll complete
our update as normal.


745
00:36:45,996 --> 00:36:47,806
This means updating
our complication,


746
00:36:48,526 --> 00:36:49,786
requesting a new snapshot,


747
00:36:50,476 --> 00:36:53,416
and then evaluating our
background refresh needs.


748
00:36:54,616 --> 00:36:57,446
So because we know our data
stopped updating for the day,


749
00:36:57,856 --> 00:36:59,096
that we can't have stale data


750
00:36:59,096 --> 00:37:01,066
in our complications
or our snapshots.


751
00:37:02,396 --> 00:37:05,046
We can wait until
the next market open


752
00:37:05,196 --> 00:37:06,936
for the next background
refresh opportunity.


753
00:37:08,516 --> 00:37:12,126
This lets our application get
out of the way of the system


754
00:37:12,466 --> 00:37:14,456
and not do any unnecessary work,


755
00:37:15,046 --> 00:37:17,026
which means that there's
more refresh tasks


756
00:37:17,026 --> 00:37:21,586
for other applications
on the system.


757
00:37:21,586 --> 00:37:25,136
So to summarize,
complete your tasks.


758
00:37:25,476 --> 00:37:27,686
It's absolutely critical
to complete your tasks.


759
00:37:27,916 --> 00:37:30,366
If you don't, in a future
seed, the system is going


760
00:37:30,366 --> 00:37:31,416
to kill your application.


761
00:37:31,716 --> 00:37:33,266
If the system kills
your application,


762
00:37:33,786 --> 00:37:37,676
users won't have the quick
response times in the dock


763
00:37:37,676 --> 00:37:38,546
that they're expecting,


764
00:37:39,016 --> 00:37:42,636
and users will take your
applications out of the dock.


765
00:37:42,826 --> 00:37:45,116
Use all the runtime that
you get efficiently.


766
00:37:45,256 --> 00:37:48,776
Consider foreground activations,
notifications, ClockKit, and,


767
00:37:48,776 --> 00:37:51,556
of course, the background
refresh opportunities to run.


768
00:37:52,126 --> 00:37:53,256
Anytime you get runtime,


769
00:37:53,856 --> 00:37:56,656
make sure that you consider
keeping your model up to date


770
00:37:57,016 --> 00:38:01,246
and evaluating your background
refresh needs with the system.


771
00:38:01,356 --> 00:38:03,176
Tell the system when
your data changes.


772
00:38:04,136 --> 00:38:07,356
Your complication and your
application snapshot are both


773
00:38:07,356 --> 00:38:11,306
system-owned caches of
your application's data.


774
00:38:12,736 --> 00:38:15,886
The system needs to know when
that data is no longer valid


775
00:38:16,586 --> 00:38:18,896
so that we won't display the
wrong things for the user.


776
00:38:19,686 --> 00:38:23,646
Users expect to see consistent
data no matter how they view


777
00:38:23,646 --> 00:38:24,646
your application's data.


778
00:38:25,276 --> 00:38:27,736
And, finally, you need


779
00:38:27,736 --> 00:38:29,236
to consider your
adoption strategies


780
00:38:29,236 --> 00:38:30,586
on a case-by-case basis.


781
00:38:30,906 --> 00:38:32,526
There is no one size
fits all solution.


782
00:38:32,666 --> 00:38:35,896
You have to really consider how
users are using your application


783
00:38:36,286 --> 00:38:38,056
and interesting characteristics
about your data


784
00:38:38,496 --> 00:38:40,556
for how you plan your
background refresh strategy.


785
00:38:41,856 --> 00:38:44,536
For more information, you
can visit this website,


786
00:38:45,466 --> 00:38:49,896
and there is some great related
sessions this afternoon at 3:00,


787
00:38:49,896 --> 00:38:51,826
Architecting for
Performance on watchOS 3.


788
00:38:51,826 --> 00:38:53,736
We'll go into some more
detail about what we did


789
00:38:53,736 --> 00:38:54,786
in the stocks application.


790
00:38:55,016 --> 00:38:56,086
Thank you very much.

