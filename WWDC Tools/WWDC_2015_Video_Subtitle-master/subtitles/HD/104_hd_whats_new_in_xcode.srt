1
00:00:26,536 --> 00:00:27,056
>> Ken Orr: Good morning.


2
00:00:28,516 --> 00:00:34,616
[applause]


3
00:00:35,116 --> 00:00:38,076
>> Ken Orr: Xcode 7 is our
next major release of tools


4
00:00:38,366 --> 00:00:42,206
for building Mac, iPhone,
iPad and Apple Watch apps.


5
00:00:43,096 --> 00:00:44,826
Let's get started this
morning and take a look


6
00:00:44,826 --> 00:00:47,166
at what's new in Xcode.


7
00:00:48,896 --> 00:00:52,516
The biggest news this year
is that we've added support


8
00:00:52,836 --> 00:00:56,886
for a third platform,
Watch OS, and of course,


9
00:00:57,336 --> 00:00:59,386
you can build Apple
Watch apps right


10
00:00:59,386 --> 00:01:02,656
in the same great Xcode
tools that you already know.


11
00:01:03,616 --> 00:01:07,356
Xcode 7 also includes Swift 2,


12
00:01:08,366 --> 00:01:10,536
building on the new programming
language we introduced


13
00:01:10,536 --> 00:01:10,986
last year.


14
00:01:12,256 --> 00:01:14,926
Swift 2 is faster
across the board,


15
00:01:15,536 --> 00:01:18,156
not only will your apps run
faster when you're running


16
00:01:18,156 --> 00:01:20,776
and debugging in
Xcode, more importantly,


17
00:01:21,236 --> 00:01:23,376
they'll run faster
on customer devices.


18
00:01:23,706 --> 00:01:28,626
Swift 2 also includes a number
of new language features,


19
00:01:29,076 --> 00:01:33,156
like Error Handling which
introduces an explicit syntax


20
00:01:33,556 --> 00:01:36,476
that makes it much more natural
to deal with errors in Swift.


21
00:01:37,826 --> 00:01:40,686
Availability, Swift
now has insight


22
00:01:40,686 --> 00:01:45,496
into the minimum OS required for
particular API, making it easier


23
00:01:45,496 --> 00:01:46,726
for you to adopt new API


24
00:01:47,096 --> 00:01:50,536
and also maintaining
support for existing OSs.


25
00:01:51,996 --> 00:01:53,056
Testability.


26
00:01:53,636 --> 00:01:57,306
Test bundles can now
see internal API,


27
00:01:57,836 --> 00:02:01,276
letting you get broader
test coverage without having


28
00:02:01,276 --> 00:02:03,716
to expose anything
additional in your sources.


29
00:02:04,856 --> 00:02:09,336
Protocol Extensions lets
you add methods to any type


30
00:02:09,336 --> 00:02:11,276
that implements a
particular protocol.


31
00:02:11,876 --> 00:02:16,266
You can convert all
of your Swift code


32
00:02:16,266 --> 00:02:19,386
to Swift 2 using
Xcode 7's Migrator.


33
00:02:20,036 --> 00:02:23,766
It works great for projects
as well as playgrounds.


34
00:02:27,436 --> 00:02:29,996
We have also added a couple
of new language features


35
00:02:30,096 --> 00:02:33,886
to Objective-C to make it
work even better with Swift.


36
00:02:34,856 --> 00:02:37,926
Like Generics which let you
specify type information


37
00:02:38,406 --> 00:02:40,276
for collections.


38
00:02:40,786 --> 00:02:45,116
Also Nullability Annotations
which let you specify


39
00:02:45,116 --> 00:02:47,696
when you expect something
it to be nil or non-nil.


40
00:02:48,236 --> 00:02:51,056
In Objective-C which makes it
really seamless when you want


41
00:02:51,056 --> 00:02:54,406
to interact with options
in Swift, really nice.


42
00:02:55,106 --> 00:02:57,496
We have gone ahead, we have
adopted all these language


43
00:02:57,526 --> 00:02:58,636
features in our own SDKs.


44
00:02:58,636 --> 00:03:04,706
So you will start seeing
the benefits today.


45
00:03:04,896 --> 00:03:08,606
Now, if you want to get started
with Swift 2 or maybe some


46
00:03:08,606 --> 00:03:10,826
of those new APIs
you saw yesterday,


47
00:03:11,416 --> 00:03:14,646
well there's no better place to
do that than in the playground.


48
00:03:15,746 --> 00:03:17,686
We introduced playgrounds
last year


49
00:03:18,356 --> 00:03:20,956
and they have come a
long way since then.


50
00:03:21,756 --> 00:03:25,076
Not only can you explore
and play with code,


51
00:03:25,846 --> 00:03:29,746
but now you can explain
an idea or a concept all


52
00:03:29,746 --> 00:03:31,096
from within a playground.


53
00:03:32,586 --> 00:03:35,926
We have introduced
features like Rich Comments


54
00:03:36,066 --> 00:03:37,556
which let you explain
what's going


55
00:03:37,556 --> 00:03:41,396
on in the surrounding code
using a simple mark-up syntax.


56
00:03:42,256 --> 00:03:44,206
They have beautiful
formatting and fonts


57
00:03:44,556 --> 00:03:46,506
which really help
them stand out.


58
00:03:47,766 --> 00:03:52,006
Within these comments you can
include things like web links


59
00:03:52,176 --> 00:03:54,066
or lists or even images.


60
00:03:54,556 --> 00:03:59,456
We have also made it possible
to pull results which were shown


61
00:03:59,456 --> 00:04:02,166
in quick-look popovers,
you can pull them right


62
00:04:02,216 --> 00:04:04,436
into the source code
under the line


63
00:04:04,436 --> 00:04:05,916
of source that generated them.


64
00:04:07,236 --> 00:04:09,456
This really helps tie the cause


65
00:04:09,456 --> 00:04:11,856
and the effect much
more closely together.


66
00:04:12,356 --> 00:04:13,396
This is really nice.


67
00:04:13,846 --> 00:04:18,326
You can add almost unlimited
functionality to a playground


68
00:04:19,036 --> 00:04:22,106
by adding Swift code to the
new supporting sources folder.


69
00:04:23,146 --> 00:04:25,076
This helps you keep
your playground clean


70
00:04:25,436 --> 00:04:28,486
and focused while also
giving you a place


71
00:04:28,656 --> 00:04:30,186
to put the supporting
functionality.


72
00:04:31,426 --> 00:04:32,846
There is also a performance
one here


73
00:04:33,346 --> 00:04:36,286
because the supporting
sources, they can be compiled


74
00:04:36,286 --> 00:04:38,676
down because they're
not run interactively.


75
00:04:38,996 --> 00:04:41,376
They're only there to
support your playground


76
00:04:41,816 --> 00:04:46,056
and that helps them run
really, really fast.


77
00:04:46,056 --> 00:04:51,986
Our newest playground
feature is Pages


78
00:04:52,616 --> 00:04:57,226
which lets you create content
that progresses through a topic.


79
00:04:58,386 --> 00:05:00,886
For example, if you wanted
to author a playground


80
00:05:00,886 --> 00:05:05,416
about sorting, you could add
an introductory page that went


81
00:05:05,416 --> 00:05:07,316
into the fundamentals of sorting


82
00:05:07,316 --> 00:05:09,836
and then you could
add subsequent pages


83
00:05:10,166 --> 00:05:10,956
that covered things


84
00:05:10,956 --> 00:05:14,536
like specific sorting algorithms
quick sort, bubble sort.


85
00:05:15,646 --> 00:05:18,346
Then, when you wanted to provide
navigation through the pages,


86
00:05:18,906 --> 00:05:21,456
you can add some of the
new mark-up syntax we


87
00:05:21,456 --> 00:05:22,706
have introduced.


88
00:05:23,336 --> 00:05:26,856
Playgrounds are a
powerful way to teach.


89
00:05:28,896 --> 00:05:31,916
Last year we introduced the
guided tour as a playground.


90
00:05:32,526 --> 00:05:35,716
This year we have
updated it to use Pages.


91
00:05:38,676 --> 00:05:42,036
That's Swift 2 and
the new playgrounds.


92
00:05:43,476 --> 00:05:50,186
In addition to iOS 9 and OS 10
El Capitan we have added sport


93
00:05:50,186 --> 00:05:51,636
for Watch OS 2.


94
00:05:52,706 --> 00:05:56,776
The new WatchKit will help
make your apps more responsive,


95
00:05:57,806 --> 00:05:59,566
but it also gives
you more control


96
00:05:59,566 --> 00:06:01,006
and flexibility as a developer.


97
00:06:02,186 --> 00:06:03,896
If you haven't already,
I encourage you to check


98
00:06:03,896 --> 00:06:05,686
out What's New in Watch OS 2.


99
00:06:05,776 --> 00:06:09,086
Some really nice stuff.


100
00:06:10,696 --> 00:06:12,916
You can build your entire
watch app, of course,


101
00:06:13,346 --> 00:06:17,336
right in Xcode using storyboards
where you can quickly lay


102
00:06:17,336 --> 00:06:19,756
out how your app will flow
from screen to screen.


103
00:06:20,886 --> 00:06:23,176
You can design and
implement glances


104
00:06:24,126 --> 00:06:26,126
or even the new WatchKit
complications.


105
00:06:27,086 --> 00:06:31,476
For iOS, using things like
the new StackView it never was


106
00:06:31,476 --> 00:06:34,336
easier to create a universal
app that deals with things


107
00:06:34,336 --> 00:06:36,666
such as changing
screen orientation


108
00:06:36,666 --> 00:06:38,656
or different screen sizes.


109
00:06:39,906 --> 00:06:43,766
With the new iPad multitasking,
size classes which you define


110
00:06:43,766 --> 00:06:46,796
in interface builder, they
have never been more important.


111
00:06:47,236 --> 00:06:53,416
Along with iOS 9 we're
introducing a new crosscutting


112
00:06:53,416 --> 00:06:55,266
feature called App Thinning.


113
00:06:56,546 --> 00:07:01,256
The App Store can tailor
your app to deliver the best,


114
00:07:01,386 --> 00:07:05,646
smallest possible version to
each unique customer device.


115
00:07:07,426 --> 00:07:10,176
This will let you focus
more on building a great app


116
00:07:10,176 --> 00:07:14,136
and worry less about size
because you will know


117
00:07:14,356 --> 00:07:18,346
that customers, they'll never
download bits they won't use.


118
00:07:18,746 --> 00:07:21,356
Xcode of course has
great support


119
00:07:21,356 --> 00:07:24,486
to help you configure how
your app will be thinned.


120
00:07:25,816 --> 00:07:28,776
There are three separate
parts to App Thinning,


121
00:07:30,296 --> 00:07:31,796
starting with Bitcode.


122
00:07:32,706 --> 00:07:36,896
When you archive for submission,
Xcode compiles your app


123
00:07:36,896 --> 00:07:40,046
down into an intermediate
representation called Bitcode


124
00:07:40,456 --> 00:07:42,056
which gets sent to the store.


125
00:07:43,326 --> 00:07:47,336
The App Store can later
re-optimize your binary,


126
00:07:47,616 --> 00:07:51,876
helping you future-proof for
things like compiler updates


127
00:07:52,066 --> 00:07:54,076
or even new processer
capabilities.


128
00:07:55,156 --> 00:07:57,846
To take advantage of Bitcode
you don't actually have


129
00:07:57,846 --> 00:07:58,426
to do anything.


130
00:07:58,676 --> 00:08:02,436
Xcode will do all
the hard work here.


131
00:08:02,646 --> 00:08:04,476
The second, there is Slicing.


132
00:08:05,046 --> 00:08:08,776
When the App Store
goes to send your app


133
00:08:08,776 --> 00:08:12,996
to a customer device it will
only include artwork that's


134
00:08:12,996 --> 00:08:14,626
needed for that particular
device.


135
00:08:15,046 --> 00:08:19,486
For example, if you have both
2x and 3x artwork in your app


136
00:08:19,556 --> 00:08:24,676
for an iPhone6 and a 6+ the
iPhone6 will only get the 2x


137
00:08:24,676 --> 00:08:28,676
artwork and the iPhone6+
will only get the 3x artwork.


138
00:08:29,916 --> 00:08:32,785
To take advantage of
Slicing, all you need


139
00:08:32,785 --> 00:08:38,546
to do is use Asset
Catalogs in Xcode.


140
00:08:38,546 --> 00:08:42,916
Third, on-demand resources,
which let you control


141
00:08:43,265 --> 00:08:45,046
when assets are downloaded.


142
00:08:45,796 --> 00:08:48,386
For example, you can
start downloading level 5


143
00:08:48,386 --> 00:08:52,536
of your game just as the
user is finishing up level 4.


144
00:08:53,456 --> 00:08:55,206
It gives you a ton of control.


145
00:08:55,506 --> 00:08:56,146
Really nice.


146
00:08:57,426 --> 00:09:01,776
Here to give us a demo of Watch
OS 2 and App Thinning is Jon.


147
00:09:02,896 --> 00:09:10,476
>> Jon Hess: Good morning.


148
00:09:10,476 --> 00:09:13,776
Today I would like to show you
two of my favorite new features


149
00:09:13,776 --> 00:09:16,206
in Xcode 7; native-watch
extensions


150
00:09:16,446 --> 00:09:17,416
and application thinning.


151
00:09:21,076 --> 00:09:23,276
Let's get started with
our trivia game project.


152
00:09:24,256 --> 00:09:26,526
Now in our trivia game we
already have things set


153
00:09:26,526 --> 00:09:30,296
up for WatchKit 1,
and right now I want


154
00:09:30,296 --> 00:09:31,746
to update it to Watch OS 2.


155
00:09:32,556 --> 00:09:34,076
It looks like Xcode
has the same idea.


156
00:09:34,626 --> 00:09:37,666
Here in the navigator, I can see
a project modernization sequence


157
00:09:37,726 --> 00:09:38,656
already queued up for me.


158
00:09:38,656 --> 00:09:40,656
I going to go ahead
and select it


159
00:09:40,656 --> 00:09:43,546
and begin migrating my
project settings to Watch OS 2.


160
00:09:44,426 --> 00:09:46,976
Here in the panel, Xcode
gives me a brief overview


161
00:09:46,976 --> 00:09:49,006
of everything that's
going to happen.


162
00:09:49,166 --> 00:09:51,386
I would like to go into it
with more detail for you.


163
00:09:52,406 --> 00:09:56,316
Just like Watch OS 1, Watch
OS 2 applications are composed


164
00:09:56,316 --> 00:09:58,296
of an app extension
and application.


165
00:09:59,076 --> 00:10:00,696
Your code goes in
the app extension


166
00:10:00,696 --> 00:10:02,406
and drives the app remotely.


167
00:10:03,236 --> 00:10:05,856
New in Watch OS 2,
both the app extension


168
00:10:06,126 --> 00:10:08,356
and the app run directly
on the watch.


169
00:10:08,776 --> 00:10:09,906
This allows our applications


170
00:10:09,906 --> 00:10:12,116
to be more responsive
and independent.


171
00:10:12,866 --> 00:10:13,696
Sounds great.


172
00:10:13,696 --> 00:10:15,406
I want to perform these changes.


173
00:10:16,296 --> 00:10:17,176
What just happened?


174
00:10:17,756 --> 00:10:19,356
Xcode took care of the details


175
00:10:19,356 --> 00:10:21,916
of migrating my project
settings to Watch OS 2.


176
00:10:21,916 --> 00:10:24,216
It configured my
Watch targets to build


177
00:10:24,216 --> 00:10:26,776
against the new Watch OS SDK
that we released yesterday,


178
00:10:26,776 --> 00:10:29,646
it set their minimum
deployment target to Watch OS 2


179
00:10:29,646 --> 00:10:33,606
and it configured my Watch app
extension to be copied inside


180
00:10:33,606 --> 00:10:36,106
of my Watch app so that
when they're installed


181
00:10:36,106 --> 00:10:38,266
on the Watch itself they
both go over together.


182
00:10:38,266 --> 00:10:39,236
All right.


183
00:10:39,236 --> 00:10:41,196
That's everything with
upgrading my project settings


184
00:10:41,196 --> 00:10:42,136
to Watch OS 2.


185
00:10:43,406 --> 00:10:45,326
Our Watch application
is nice and light,


186
00:10:46,296 --> 00:10:48,976
but our iOS application
is a quite bit bigger.


187
00:10:48,976 --> 00:10:52,446
It is mostly due to all of these
images in my asset catalog.


188
00:10:53,186 --> 00:10:55,516
I want to make it
smaller but don't want


189
00:10:55,516 --> 00:10:56,626
to remove any content.


190
00:10:57,326 --> 00:10:59,906
This is where the new App
Slicing feature comes in play.


191
00:11:00,556 --> 00:11:02,566
You see every one ever
these images has a 1,


192
00:11:02,916 --> 00:11:05,196
2, 3x representation?


193
00:11:05,846 --> 00:11:08,996
Well with App Slicing, Xcode
7 and the App Store are going


194
00:11:08,996 --> 00:11:10,076
to work together to make sure


195
00:11:10,076 --> 00:11:13,266
that each device just gets this
single image that best suits it.


196
00:11:13,696 --> 00:11:16,496
This cuts 30- to 40 percent
off the size of our application


197
00:11:16,496 --> 00:11:18,956
and the best part is it's
pretty much automatic.


198
00:11:19,436 --> 00:11:22,306
All I need to do is use
Xcode 7 in an asset catalog


199
00:11:22,456 --> 00:11:23,376
which I'm already doing.


200
00:11:23,376 --> 00:11:25,616
What about the other
assets you would


201
00:11:25,616 --> 00:11:28,426
like to target for each device.


202
00:11:28,896 --> 00:11:32,116
We have extended the
asset catalog in Xcode 7


203
00:11:32,376 --> 00:11:33,706
to support arbitrary data.


204
00:11:33,806 --> 00:11:35,666
You can put whatever
you want in here.


205
00:11:36,776 --> 00:11:38,126
Down here further
in the catalog,


206
00:11:38,226 --> 00:11:39,656
I have this skylines folder.


207
00:11:40,246 --> 00:11:43,716
It's filled with 3D models of
cities from around the world.


208
00:11:43,776 --> 00:11:45,746
We present them to the
user and they guess


209
00:11:45,746 --> 00:11:48,266
which city they are looking at.


210
00:11:48,266 --> 00:11:52,596
San Francisco, I have a really
high-quality model of the city


211
00:11:52,596 --> 00:11:54,246
of San Francisco I would
like to include in our game,


212
00:11:54,606 --> 00:11:57,026
but I only want to send it
to the most high-end devices.


213
00:11:57,596 --> 00:11:58,256
No problem.


214
00:11:58,696 --> 00:12:01,846
Just like images can vary by
scale factor and size class,


215
00:12:02,156 --> 00:12:05,006
data assets can vary by device
performance characteristics,


216
00:12:05,446 --> 00:12:07,376
things like the amount
of memory on the device,


217
00:12:07,566 --> 00:12:08,916
or the GPU capabilities.


218
00:12:09,136 --> 00:12:11,826
I want to add a specialization
for machines


219
00:12:11,826 --> 00:12:12,946
with 2 gigabytes of memory.


220
00:12:13,016 --> 00:12:15,306
Then I will just
go ahead and drag


221
00:12:15,306 --> 00:12:18,336
in my high-end resource
and I'm good to go.


222
00:12:18,546 --> 00:12:21,286
Each device will get the
resource that best suits it


223
00:12:21,286 --> 00:12:22,296
without double-paying.


224
00:12:22,736 --> 00:12:23,046
All right.


225
00:12:24,196 --> 00:12:27,126
Now I would like to show
you on-demand resources.


226
00:12:28,246 --> 00:12:30,706
On-demand resources allow
us to host the content


227
00:12:30,706 --> 00:12:34,426
for application remotely
on the App Store.


228
00:12:34,626 --> 00:12:37,536
We opt our resources
in to on-demand hosting


229
00:12:37,536 --> 00:12:39,216
by tagging them with strings.


230
00:12:39,786 --> 00:12:41,556
The strings can be
anything we want.


231
00:12:42,186 --> 00:12:45,376
For example, if we're making
a game, we might tag each


232
00:12:45,376 --> 00:12:46,706
of the assets that comprise one


233
00:12:46,706 --> 00:12:48,536
of the levels by
that level's name.


234
00:12:49,186 --> 00:12:52,176
Then, at run time, we use the
new NS Bundle Resource Request


235
00:12:52,176 --> 00:12:55,256
class to fetch and pull down
whole tags worth of content


236
00:12:55,586 --> 00:12:57,566
into our game for
fast, local access.


237
00:12:58,006 --> 00:12:59,426
Let me show you how
to get started


238
00:12:59,426 --> 00:13:00,606
with on-demand resources.


239
00:13:01,826 --> 00:13:03,656
Here I've selected a
folder in the catalog.


240
00:13:03,976 --> 00:13:05,556
It represents all
of the questions


241
00:13:05,596 --> 00:13:07,016
in the world genre of the game.


242
00:13:08,056 --> 00:13:09,116
In the inspector I'm going


243
00:13:09,116 --> 00:13:11,386
to use the new on-demand
resource tag section


244
00:13:11,916 --> 00:13:15,616
and tag this content,
world questions.


245
00:13:15,766 --> 00:13:17,936
I've just opted all of it
in to on-demand hosting.


246
00:13:19,126 --> 00:13:21,136
Now, what kind of things
can you tag in a catalog?


247
00:13:21,916 --> 00:13:23,966
You can tag entire
folders like I just did.


248
00:13:24,496 --> 00:13:26,636
You can tag images and
data assets directly,


249
00:13:26,676 --> 00:13:29,526
you can also tag Sprite
Atlases in the Asset catalog.


250
00:13:29,896 --> 00:13:31,416
Sprite Atlases are
a new component


251
00:13:31,416 --> 00:13:32,916
of the Asset catalog in Xcode 7.


252
00:13:33,556 --> 00:13:35,616
By putting your Sprite
Atlases in the catalog,


253
00:13:35,686 --> 00:13:37,756
it makes them eligible
for the Splicing feature I


254
00:13:37,756 --> 00:13:38,416
mentioned earlier.


255
00:13:39,696 --> 00:13:42,566
You can also tag loose
files in your Xcode project.


256
00:13:43,926 --> 00:13:46,956
This inspector gives me
a great overview of all


257
00:13:46,956 --> 00:13:48,646
of the tags on a
particular file.


258
00:13:49,186 --> 00:13:51,846
What if I want to see
all the files in a tag,


259
00:13:51,846 --> 00:13:53,046
or just all the tags period.


260
00:13:53,676 --> 00:13:55,746
For that, I can head over
to the Project Editor,


261
00:13:56,456 --> 00:13:58,746
by selecting our
Application Target and going


262
00:13:58,746 --> 00:14:01,786
to the New Resource tag section
I can see all of my tags.


263
00:14:02,386 --> 00:14:04,776
As you see, I tagged a
lot of content earlier.


264
00:14:04,776 --> 00:14:07,396
It is a great place
to get an overview


265
00:14:07,396 --> 00:14:09,686
and make sure things are
consistent like I expect.


266
00:14:11,106 --> 00:14:13,936
For example, I see this books
tag doesn't match the format


267
00:14:13,936 --> 00:14:16,326
of the others, they all
have this question suffix.


268
00:14:17,006 --> 00:14:17,606
No problem.


269
00:14:17,606 --> 00:14:21,986
I'll edit this, and update
all the content in one go.


270
00:14:21,986 --> 00:14:27,296
Now with tag to all of our
content for on-demand resources,


271
00:14:27,486 --> 00:14:30,576
and I would like to show you how
to started using it from code.


272
00:14:30,846 --> 00:14:33,496
That's where the new NS Bundle
resource request class comes


273
00:14:33,496 --> 00:14:33,856
into play.


274
00:14:34,776 --> 00:14:37,356
Here in our game class,
we have two callbacks


275
00:14:37,356 --> 00:14:38,306
that will be perfect for this,


276
00:14:38,736 --> 00:14:40,736
start using genre
and stop using genre.


277
00:14:41,826 --> 00:14:44,366
Two reasons they are great for
using on-demand resources first,


278
00:14:44,366 --> 00:14:46,416
they are bracketed
in time, and second,


279
00:14:46,626 --> 00:14:49,036
they happen a just a bit before
the user actually initiates the


280
00:14:49,036 --> 00:14:51,056
game but as soon as when we
know what they're going to play


281
00:14:51,056 --> 00:14:53,496
in the game, It lets us
pre-fetch the on-demand content.


282
00:14:54,756 --> 00:14:56,886
I'll get started with
an instance variable


283
00:14:56,886 --> 00:14:58,896
to hold an NS Bundle
resource request.


284
00:14:59,536 --> 00:15:02,536
NS Bundle resource requests
are substantiated from tags,


285
00:15:02,536 --> 00:15:04,946
and remember, tags are
just simple strings.


286
00:15:05,576 --> 00:15:08,766
I'll use our genre's name
with batch questions appended


287
00:15:08,766 --> 00:15:09,796
to the end to form our tag.


288
00:15:11,266 --> 00:15:16,456
Then I can create the bundle
resource request from that tag.


289
00:15:16,456 --> 00:15:19,006
Finally, I can invoke
the request


290
00:15:19,426 --> 00:15:21,376
with the new begin
accessing resources


291
00:15:21,376 --> 00:15:22,586
with completion handler method.


292
00:15:23,106 --> 00:15:25,326
This is an asynchronous method
that runs in the background.


293
00:15:25,936 --> 00:15:27,626
It downloads all the
content from the store,


294
00:15:27,626 --> 00:15:30,176
and when it's done, it
fires my completion handler.


295
00:15:31,016 --> 00:15:33,926
Once my completion handler
runs, and until I say I'm done


296
00:15:33,926 --> 00:15:34,896
with the resource request,


297
00:15:34,896 --> 00:15:37,626
I have fast local access
to all the content.


298
00:15:38,166 --> 00:15:39,196
This is my favorite part.


299
00:15:39,196 --> 00:15:42,736
I get it all, that content with
the same APIs I'm already using.


300
00:15:43,016 --> 00:15:46,566
Methods like NS Bundle, Path of
Resource, UI Image, Image Name,


301
00:15:46,566 --> 00:15:48,916
Texture, Texture
Name, all continue


302
00:15:48,916 --> 00:15:50,716
to work exactly as
they did before.


303
00:15:50,716 --> 00:15:53,206
I'm not making any
changes to the rest


304
00:15:53,206 --> 00:15:55,266
of the resource lookout code
throughout my application.


305
00:15:57,056 --> 00:16:00,366
Now, I set all that content as
available until I say I'm done


306
00:16:00,366 --> 00:16:01,596
with the NS Bundle
resource request.


307
00:16:01,966 --> 00:16:02,656
How do I do that?


308
00:16:03,246 --> 00:16:05,386
In our stop using genre method,


309
00:16:05,886 --> 00:16:08,256
I'll invoke end accessing
resource


310
00:16:08,256 --> 00:16:09,716
on the NS Bundle
resource request.


311
00:16:10,366 --> 00:16:13,046
This moves all the content
that I fetched into the cache


312
00:16:13,426 --> 00:16:16,636
so it is available for future
access but it also marks it


313
00:16:16,786 --> 00:16:18,446
as available for
purging in the even


314
00:16:18,446 --> 00:16:19,956
that the system runs
out of space.


315
00:16:20,896 --> 00:16:23,106
With that, we have written
all of the code we need


316
00:16:23,106 --> 00:16:24,196
for on-demand resources.


317
00:16:24,496 --> 00:16:25,906
I want to build and
run our game.


318
00:16:26,996 --> 00:16:27,866
We'll start a new game.


319
00:16:28,836 --> 00:16:30,846
I'll show you some of the
debugging functionality


320
00:16:31,186 --> 00:16:32,586
for working with
on-demand resources.


321
00:16:33,726 --> 00:16:36,896
Here in the debug navigator, I'm
going to select the disk gage


322
00:16:37,586 --> 00:16:39,976
to bring up the disk
report to get an overview


323
00:16:39,976 --> 00:16:41,846
of all the ways the
application is using the disk.


324
00:16:42,576 --> 00:16:44,456
We've added a new
section here in Xcode 7,


325
00:16:44,636 --> 00:16:45,856
on-demand resource tags.


326
00:16:46,286 --> 00:16:49,416
You see can see my tags, their
size, and their current status.


327
00:16:50,196 --> 00:16:52,146
All that are currently
marked not downloaded,


328
00:16:52,886 --> 00:16:55,076
Xcode is mimicking the role
of the app store right now.


329
00:16:55,536 --> 00:16:58,986
All of my resources are in
Xcode, not on the simulator yet.


330
00:16:59,396 --> 00:17:01,216
But, when I click
one of these genres,


331
00:17:02,636 --> 00:17:04,796
the code that we just wrote
runs in the background,


332
00:17:05,006 --> 00:17:07,886
downloads the content and now
you see my tag is marked in use.


333
00:17:08,526 --> 00:17:10,086
If I switch to a second genre,


334
00:17:10,746 --> 00:17:12,896
you can see the first
content is moved to the cache,


335
00:17:13,175 --> 00:17:16,026
just marked downloaded, and
now engineering questions are


336
00:17:16,026 --> 00:17:16,536
in use.


337
00:17:17,156 --> 00:17:19,006
That's Slicing and
on-demand resources.


338
00:17:19,606 --> 00:17:22,756
With Application Slicing,
we're able to lower the size


339
00:17:22,756 --> 00:17:26,205
of our iPhone 6 application
from more than 140 megabytes


340
00:17:26,445 --> 00:17:27,826
to less than 100 megabytes.


341
00:17:28,516 --> 00:17:30,086
With on-demand resources
we were able


342
00:17:30,086 --> 00:17:32,166
to further lower the
initial install size


343
00:17:32,446 --> 00:17:33,896
down to just 30 megabytes.


344
00:17:34,356 --> 00:17:36,976
Now users can get started with
our game faster than ever.


345
00:17:37,406 --> 00:17:38,116
Back to you, Ken.


346
00:17:39,516 --> 00:17:45,436
[applause]


347
00:17:45,936 --> 00:17:46,976
>> Ken Orr: Thank you, Jon.


348
00:17:49,696 --> 00:17:51,766
This year we have
introduced a number


349
00:17:51,766 --> 00:17:54,046
of new features targeted
squarely


350
00:17:54,046 --> 00:17:57,266
at helping you enhance
the quality of your app.


351
00:17:58,446 --> 00:18:00,466
Let's start by talking about
debugging and profiling.


352
00:18:01,056 --> 00:18:06,796
In Xcode 7 we have brought
the energy gage to iOS apps.


353
00:18:07,536 --> 00:18:11,466
IOS 9 contracts energy
on a per process basis.


354
00:18:11,676 --> 00:18:14,126
That's reflected right
here in the energy report.


355
00:18:15,606 --> 00:18:18,186
The gages in Xcode are
a great way for you


356
00:18:18,236 --> 00:18:21,126
to match what you
expect to be happening


357
00:18:21,476 --> 00:18:24,866
against what's actually
happening.


358
00:18:24,866 --> 00:18:27,906
If you see a spike in energy
usage and you're sitting


359
00:18:27,906 --> 00:18:31,416
in your app apparently
idle, that's a first clue


360
00:18:31,416 --> 00:18:33,266
that maybe you have a problem.


361
00:18:34,006 --> 00:18:36,146
Sometimes when you have
a problem like that,


362
00:18:36,246 --> 00:18:38,316
you know exactly where to
go looking in your code.


363
00:18:38,316 --> 00:18:43,826
But when you don't, you can jump
right into Instruments from all


364
00:18:43,826 --> 00:18:45,346
of the reports in Xcode.


365
00:18:46,056 --> 00:18:48,226
From the Energy report
we can jump


366
00:18:48,226 --> 00:18:52,596
into the New Location instrument
which lets us make sure


367
00:18:52,596 --> 00:18:55,536
that we're efficiently
using core location APIs.


368
00:18:56,706 --> 00:18:59,456
We can answer questions
like are we asking


369
00:18:59,456 --> 00:19:03,276
for the user's location
too often, are we asking


370
00:19:03,276 --> 00:19:05,926
for the user's location
with too high a precision?


371
00:19:07,156 --> 00:19:09,516
Things like that are
going to cost energy


372
00:19:09,756 --> 00:19:12,346
and we can investigate
those right here.


373
00:19:12,346 --> 00:19:18,476
For iOS, this is also the new
Metal System Trace instrument


374
00:19:18,476 --> 00:19:21,626
letting you see how the
frame rate is being effected


375
00:19:21,876 --> 00:19:24,006
by things like your own code.


376
00:19:24,666 --> 00:19:29,026
The graphics driver, hardware
rendering, it gives you insight


377
00:19:29,426 --> 00:19:33,276
into the entire Graphic
Stack, really powerful.


378
00:19:34,736 --> 00:19:36,816
You may also notice
here in Instruments


379
00:19:36,926 --> 00:19:39,276
that there is a redesigned
track view.


380
00:19:40,326 --> 00:19:41,516
It has a cleaner look,


381
00:19:42,566 --> 00:19:45,726
more importantly it is
more natural to use.


382
00:19:46,326 --> 00:19:47,956
With gestures like
pinch to zoom,


383
00:19:48,236 --> 00:19:51,656
navigating through your
data is really, really easy.


384
00:19:52,156 --> 00:19:55,726
That's a quick peak at
the new Instruments.


385
00:19:57,806 --> 00:20:03,186
I'm willing to bet that every
developer in this room has been


386
00:20:03,186 --> 00:20:08,576
in a situation where a
customer reports a crash


387
00:20:08,766 --> 00:20:10,356
and you just can't reproduce it.


388
00:20:11,326 --> 00:20:11,586
All right.


389
00:20:12,416 --> 00:20:13,616
That happened once
or twice maybe?


390
00:20:15,066 --> 00:20:19,046
The new in Address
Sanitizer in Xcode 7 can help.


391
00:20:20,176 --> 00:20:25,356
Address Sanitizer compiles your
Objective-C in C code in a way


392
00:20:25,356 --> 00:20:28,116
that catch things
like buffer overflows


393
00:20:28,346 --> 00:20:32,116
and it can catch them
immediately when they happen.


394
00:20:32,576 --> 00:20:35,686
Xcode will stop you
right on the line of code


395
00:20:35,926 --> 00:20:36,956
that caused the problem.


396
00:20:37,886 --> 00:20:40,286
This is a powerful
new debugging feature.


397
00:20:40,676 --> 00:20:43,746
Here to give us a demo of
Address Sanitizer is Kate.


398
00:20:49,236 --> 00:20:49,716
>> Kate Stone: Thank you, Ken.


399
00:20:50,306 --> 00:20:53,796
Our trivia game is a great
diversion with friends


400
00:20:54,306 --> 00:20:56,806
but some are experiencing
crashes


401
00:20:56,806 --> 00:20:57,866
when they're setting up a game.


402
00:20:58,996 --> 00:21:01,216
It is unpredictable
enough that it is the kind


403
00:21:01,216 --> 00:21:04,496
of bug that's hard to reproduce
and make heads or tails of.


404
00:21:05,626 --> 00:21:07,436
I'm sure you experienced
something similar


405
00:21:07,436 --> 00:21:10,106
as I've heard anywhere
you have used pointers


406
00:21:10,136 --> 00:21:11,556
to explicitly managed memory.


407
00:21:12,126 --> 00:21:15,916
Our game is looking beautiful.


408
00:21:16,786 --> 00:21:20,576
We can dive on in, start
a new game, pick a genre,


409
00:21:21,816 --> 00:21:25,526
pick a few users to work
with and we're ready to play.


410
00:21:26,206 --> 00:21:28,886
So it seems to work
just fine -- oh.


411
00:21:30,696 --> 00:21:33,296
Being on stage is
perfect to reproduce this.


412
00:21:33,426 --> 00:21:34,516
Hard to find bugs.


413
00:21:35,986 --> 00:21:37,326
So let's have a look at this.


414
00:21:37,326 --> 00:21:39,196
It's crashed, where
is it crashed?


415
00:21:39,196 --> 00:21:40,056
What can I debug?


416
00:21:40,856 --> 00:21:43,316
It's crashed in my main class.


417
00:21:43,556 --> 00:21:46,756
So there's not even I line
of code I've written there.


418
00:21:46,996 --> 00:21:48,246
There's nothing in
the Stack Trace


419
00:21:48,276 --> 00:21:49,406
to give me a place to start.


420
00:21:49,766 --> 00:21:51,936
That's typical of
this kind of bug.


421
00:21:52,296 --> 00:21:54,356
Luckily, Address
Sanitizer can help there.


422
00:21:55,116 --> 00:21:57,376
We have a variety of
these diagnostic tools


423
00:21:57,376 --> 00:21:58,736
that you can get to from Xcode.


424
00:21:59,076 --> 00:21:59,916
All you need to do is go


425
00:21:59,916 --> 00:22:01,596
to the Scheme editor
for running your app.


426
00:22:02,136 --> 00:22:04,996
As that handy shortcut, I'll
hold down Option while I click


427
00:22:04,996 --> 00:22:06,546
on Run to get to
the Scheme Editor.


428
00:22:07,656 --> 00:22:09,816
I can configure how I
run my application here,


429
00:22:10,136 --> 00:22:11,846
including the Diagnostics tab


430
00:22:12,176 --> 00:22:14,766
which lets me select some
potentially familiar tools


431
00:22:15,006 --> 00:22:17,346
as well as the new
tool, Address Sanitizer.


432
00:22:18,066 --> 00:22:20,716
Enabling Address Sanitizer
does something different


433
00:22:20,996 --> 00:22:24,366
in that it recompiles the
application adding a bunch more


434
00:22:24,366 --> 00:22:27,526
Instrumentation showing
me not just where I failed


435
00:22:27,886 --> 00:22:29,366
but why I failed as well.


436
00:22:30,526 --> 00:22:33,616
Let's rerun that application
and see how this works.


437
00:22:34,936 --> 00:22:37,256
Now I'll find when I
select a genre and move


438
00:22:37,256 --> 00:22:40,416
to the next page it
immediately stops my application


439
00:22:40,656 --> 00:22:43,826
because this is where the memory
corruption actually occurred.


440
00:22:44,356 --> 00:22:47,306
Far before the application
finally comes


441
00:22:47,306 --> 00:22:49,656
to a screeching halt I can
find out what went wrong.


442
00:22:50,456 --> 00:22:53,376
In this case I get the exact
Stack of where it stopped


443
00:22:53,876 --> 00:22:56,406
and it turns out that it
is some Objective-C code


444
00:22:56,406 --> 00:22:57,116
that I'm calling.


445
00:22:57,866 --> 00:23:01,296
Not everybody has the luxury
of writing everything in Swift.


446
00:23:01,566 --> 00:23:04,786
In fact, in our case, we have
this C code that's been wrapped


447
00:23:04,866 --> 00:23:06,356
in an Objective-C framework.


448
00:23:06,356 --> 00:23:08,446
That's the source
of our problem.


449
00:23:09,036 --> 00:23:10,476
I'm not familiar with this code.


450
00:23:10,476 --> 00:23:13,266
I'll have a look at the
code that I'm calling it


451
00:23:13,266 --> 00:23:14,276
from written in Swift.


452
00:23:15,036 --> 00:23:17,536
Here I am calling
some logging API.


453
00:23:18,226 --> 00:23:21,526
That tells me where exactly
I'm triggering the failure


454
00:23:21,856 --> 00:23:23,416
but still not yet why.


455
00:23:24,506 --> 00:23:26,816
If I look further down the
Debug navigator though,


456
00:23:27,216 --> 00:23:30,716
I can see that in addition to
Address Sanitizer telling me


457
00:23:30,916 --> 00:23:32,886
that I'm using deallocated
memory


458
00:23:32,886 --> 00:23:35,366
and that that's the actual
source of my problem.


459
00:23:36,316 --> 00:23:39,956
I can also see in the Debug
navigator what memory that is.


460
00:23:40,306 --> 00:23:43,046
I'm accessing the first bite
in a 50-bite heat region


461
00:23:43,046 --> 00:23:44,436
that was previously allocated.


462
00:23:45,186 --> 00:23:48,796
I can go a step further, click
on and actually see the memory,


463
00:23:48,796 --> 00:23:51,796
and see it has been previously
used to store a log message.


464
00:23:52,356 --> 00:23:55,906
Because it is gray, Address
Sanitizer is telling me


465
00:23:56,136 --> 00:23:58,746
that it knows that it is
no longer valid memory,


466
00:23:58,836 --> 00:24:00,706
no longer memory I
should be accessing.


467
00:24:01,476 --> 00:24:02,796
It also gives me the call Stack,


468
00:24:02,926 --> 00:24:05,666
where that memory was originally
allocated and I can see


469
00:24:05,666 --> 00:24:09,106
that it is when I'm creating
a usage log that makes sense,


470
00:24:09,836 --> 00:24:11,316
and more importantly
in this case,


471
00:24:11,636 --> 00:24:13,646
where that memory
was deallocated.


472
00:24:14,486 --> 00:24:17,716
I can tell here that it is
when I call end logging,


473
00:24:18,356 --> 00:24:20,346
the particularly
badly designed API.


474
00:24:20,806 --> 00:24:23,906
I thought it was just to
flush the log but it turns


475
00:24:23,906 --> 00:24:26,286
out it takes down
critical resources.


476
00:24:26,916 --> 00:24:28,416
Let's solve that
problem quickly.


477
00:24:29,306 --> 00:24:30,736
I can take that line of code,


478
00:24:30,896 --> 00:24:33,106
instead of calling it
every time I log a message,


479
00:24:33,516 --> 00:24:37,386
I'm going to call it only
once during tear down.


480
00:24:37,626 --> 00:24:40,386
Now Address Sanitizer rebuilds
the application complete


481
00:24:40,386 --> 00:24:43,676
with Instrumentation, still
very snappy, still possible


482
00:24:43,676 --> 00:24:46,946
to use it interactively, and
I can get a step further.


483
00:24:47,026 --> 00:24:50,526
It all looks good until
it finds my next problem.


484
00:24:52,226 --> 00:24:56,456
Because Address Sanitizer is not
just about deallocated memory.


485
00:24:56,726 --> 00:24:57,586
In this case it is telling me


486
00:24:57,586 --> 00:25:00,646
about a heap buffer
overflow similarly telling me


487
00:25:00,646 --> 00:25:04,536
about under flows and Stack
memory that I'm overflowing


488
00:25:04,536 --> 00:25:07,746
or under flowing, it is an
extraordinarily powerful tool.


489
00:25:08,326 --> 00:25:10,326
It's the kind of
tool you should use


490
00:25:10,326 --> 00:25:11,526
on your applications right now


491
00:25:11,886 --> 00:25:14,386
to find all those
lurking memory issues.


492
00:25:15,206 --> 00:25:17,566
We tried to make that
as easy as possible


493
00:25:18,146 --> 00:25:21,626
because Address Sanitizer
cannot only run


494
00:25:21,626 --> 00:25:24,206
in this interactive
form, but you can use it


495
00:25:24,206 --> 00:25:26,726
with Xcode Servers so you
can set up a suite of tests


496
00:25:27,396 --> 00:25:30,106
with Address Sanitizer
enabled and find those problems


497
00:25:30,106 --> 00:25:32,126
when they creep in your code.


498
00:25:33,436 --> 00:25:35,866
Because you want to minimize
the number of crashes


499
00:25:35,906 --> 00:25:38,736
but let's be realistic, you
can't eliminate them entirely.


500
00:25:39,306 --> 00:25:42,046
So I'm proud to bring
up Itai to talk


501
00:25:42,046 --> 00:25:45,436
about how Xcode helps you
analyze those crash logs you


502
00:25:45,436 --> 00:25:45,856
will get.


503
00:25:47,516 --> 00:25:56,876
[applause]


504
00:25:57,376 --> 00:25:58,526
>> Itai Rom: Thanks, Kate.


505
00:25:58,526 --> 00:25:59,416
Good morning, everyone.


506
00:26:00,056 --> 00:26:02,956
As Apple developer program
members you have access


507
00:26:03,036 --> 00:26:04,556
to the new crash logs in Xcode.


508
00:26:05,386 --> 00:26:07,086
When you distribute your
app through the App Store


509
00:26:07,086 --> 00:26:11,216
or TestFlight and include symbol
information we'll collect crash


510
00:26:11,216 --> 00:26:12,176
logs from your users.


511
00:26:13,056 --> 00:26:17,286
Those crash logs will be fully
aggregated into crash reports


512
00:26:17,286 --> 00:26:19,346
and downloaded into
Xcode wher you can view


513
00:26:19,346 --> 00:26:21,946
and analyze them right
in the organizer window.


514
00:26:22,866 --> 00:26:25,456
The integration here is
seamless making it easier


515
00:26:25,456 --> 00:26:28,306
than ever before to find and
fix your most critical issues.


516
00:26:28,506 --> 00:26:33,586
I would like to show
you how to use it.


517
00:26:33,856 --> 00:26:35,406
Last year we introduced
TestFlight.


518
00:26:36,376 --> 00:26:38,086
TestFlight is a convenient
service


519
00:26:38,086 --> 00:26:41,156
for distributing beta builds
of your apps and works great


520
00:26:41,156 --> 00:26:42,646
with crash logs in Xcode.


521
00:26:43,486 --> 00:26:46,486
We just distributed a beta build
of our trivia game yesterday.


522
00:26:46,876 --> 00:26:49,306
I'll like to find and
fix some of the crashes


523
00:26:49,376 --> 00:26:50,756
that our testers reported.


524
00:26:52,196 --> 00:26:53,626
I'll launch Xcode.


525
00:26:54,066 --> 00:26:56,706
I have already entered
my Apple ID information


526
00:26:56,706 --> 00:26:59,646
into Xcode's Account Preferences
panel, so all I have to do


527
00:26:59,646 --> 00:27:02,306
to view crashes is open
the Organizer window.


528
00:27:02,886 --> 00:27:07,576
On the left side of the window,
Xcode will download information


529
00:27:07,576 --> 00:27:10,736
about all of the apps that my
development team has uploaded


530
00:27:10,856 --> 00:27:13,606
to iTunes Connect for the
App Store or TestFlight.


531
00:27:14,426 --> 00:27:15,236
I'll choose trivia.


532
00:27:15,236 --> 00:27:18,676
On the right, I can
choose which build


533
00:27:18,676 --> 00:27:19,936
of trivia I'm interested in.


534
00:27:20,536 --> 00:27:23,366
This build 55 at the top
of the list is the one


535
00:27:23,366 --> 00:27:25,306
that we distributed through
TestFlight yesterday.


536
00:27:25,356 --> 00:27:27,586
I'll click that.


537
00:27:27,766 --> 00:27:29,836
Underneath Xcode will
download information


538
00:27:29,836 --> 00:27:31,196
about all of the top crashes.


539
00:27:31,976 --> 00:27:34,966
These are sorted by frequency of
occurrence, the one at the top


540
00:27:34,966 --> 00:27:36,736
of the list is naturally the one


541
00:27:36,736 --> 00:27:38,846
that our testers
experienced the most often.


542
00:27:39,236 --> 00:27:44,016
To the right I can see the
back trace for this crash.


543
00:27:44,146 --> 00:27:46,316
Xcode helpfully highlights
one of the Stack frames


544
00:27:46,316 --> 00:27:48,256
in a beautiful orangey
salmon color,


545
00:27:49,066 --> 00:27:51,256
that tells me something
fishy is happening in my app.


546
00:27:52,946 --> 00:27:55,536
In particular that's where
my app crashed inside


547
00:27:55,536 --> 00:27:58,106
of this usage log
and log in method.


548
00:27:58,366 --> 00:28:01,276
That looks similar to the
crash that Kate just found


549
00:28:01,276 --> 00:28:02,916
and fixed using the
Address Sanitizer.


550
00:28:03,546 --> 00:28:05,206
That's my favorite type of
bug report, I don't have


551
00:28:05,246 --> 00:28:07,666
to do anything since
I watched her fix it.


552
00:28:08,366 --> 00:28:10,706
I'm going to go ahead
and mark it as resolved


553
00:28:10,706 --> 00:28:13,836
by clicking this button
on top of the window.


554
00:28:13,836 --> 00:28:17,106
I can have Xcode filter out the
crashes I have already resolved


555
00:28:17,606 --> 00:28:21,366
by clicking the filter in
the bottom of the window.


556
00:28:21,516 --> 00:28:24,026
Now I can focus on the crashes
that I still need to fix.


557
00:28:25,156 --> 00:28:26,536
We have warmed up with
a pretty easy one.


558
00:28:26,536 --> 00:28:27,876
Let's take a look
at the next crash.


559
00:28:28,656 --> 00:28:29,796
This time we're crashing inside


560
00:28:29,796 --> 00:28:31,486
of our splash screen
view controller,


561
00:28:31,826 --> 00:28:34,526
the beautiful landing page in
the app where you see a grid


562
00:28:34,526 --> 00:28:35,646
of your friends' images.


563
00:28:36,186 --> 00:28:37,906
It looks like we're
indexing into an array


564
00:28:38,006 --> 00:28:40,116
and we might have indexed
beyond the array's bounds.


565
00:28:40,116 --> 00:28:41,676
I would like to try
fixing this crash.


566
00:28:42,386 --> 00:28:44,766
I can jump right into my source
code by clicking the Open


567
00:28:44,766 --> 00:28:48,386
and Project button, selecting my
project, and then clicking Open.


568
00:28:48,916 --> 00:28:52,546
Now, Xcode has not
only opened my project,


569
00:28:52,646 --> 00:28:54,886
it has also magically
transported the crash log


570
00:28:54,886 --> 00:28:57,196
that I was just viewing
in the organizer right


571
00:28:57,196 --> 00:29:00,356
into the Debug navigator where
I can click through Stack Frames


572
00:29:00,816 --> 00:29:02,696
and navigate through
my crash log


573
00:29:02,696 --> 00:29:04,946
and source code side-by-side.


574
00:29:05,926 --> 00:29:08,626
It looks like we're crashing
into the next image method.


575
00:29:09,376 --> 00:29:12,186
This looks similar to a
crash I think Jon came


576
00:29:12,186 --> 00:29:14,066
to my office yesterday to
tell me he was hitting.


577
00:29:15,036 --> 00:29:17,886
What we're doing is indexing
through an array of images


578
00:29:17,886 --> 00:29:20,496
of our friends and
incrementing a counter as we go.


579
00:29:21,496 --> 00:29:22,776
When we get to the end
of the end of the array,


580
00:29:22,776 --> 00:29:25,256
we set the counter back to zero.


581
00:29:25,256 --> 00:29:28,086
We have an easy to miss
off by one error here.


582
00:29:28,366 --> 00:29:30,356
This should be a greater
than or equal to check.


583
00:29:30,406 --> 00:29:31,446
I'll fix that.


584
00:29:32,346 --> 00:29:34,266
It looks like you could hit
this crash really easily


585
00:29:34,266 --> 00:29:35,476
if you don't have
very many friends,


586
00:29:35,816 --> 00:29:37,556
which probably explains
why Jon found it.


587
00:29:39,796 --> 00:29:42,176
Now I can go back to the
organizer and fix more crashes.


588
00:29:43,016 --> 00:29:44,576
The new crash logs
feature in Xcode


589
00:29:44,576 --> 00:29:47,166
and TestFlight work great
together to help you find


590
00:29:47,166 --> 00:29:49,376
and fix your most critical
issues before you ship


591
00:29:49,376 --> 00:29:50,196
to your customers.


592
00:29:50,926 --> 00:29:51,806
Now back to Ken.


593
00:29:53,516 --> 00:29:59,976
[applause]


594
00:30:00,476 --> 00:30:02,056
>> Ken Orr: Thank you, Itai.


595
00:30:03,536 --> 00:30:09,046
Testing. Over the past few
years we have continually added


596
00:30:09,356 --> 00:30:11,166
to the testing support in Xcode.


597
00:30:11,536 --> 00:30:13,796
Making it possible
for you to test more


598
00:30:13,796 --> 00:30:15,936
and more parts of
your application.


599
00:30:16,776 --> 00:30:19,476
In Xcode 5 we added
a Test navigator.


600
00:30:19,846 --> 00:30:23,246
When you combine that with the
assistant editor we have a nice


601
00:30:23,246 --> 00:30:25,216
workflow for test-driven
development.


602
00:30:25,726 --> 00:30:29,166
We have introduced XC Test
our unit-testing framework,


603
00:30:30,076 --> 00:30:33,666
along with Bots which let you
automatically run the unit tests


604
00:30:34,016 --> 00:30:36,466
on Xcode Server for
continuous integration.


605
00:30:37,296 --> 00:30:40,616
In Xcode 6, we introduced
performance testing


606
00:30:40,616 --> 00:30:43,446
to quickly let you identify
performance regressions


607
00:30:43,576 --> 00:30:46,406
and added testing for
asynchronous APIs.


608
00:30:46,406 --> 00:30:52,526
In Xcode 7, we're introducing
User Interface testing.


609
00:30:53,766 --> 00:30:57,266
The UI testing lets you
test the part of the app


610
00:30:57,386 --> 00:31:00,226
that users actually
see and touch.


611
00:31:01,326 --> 00:31:02,766
The tests like this
are so important


612
00:31:03,206 --> 00:31:06,116
because they help you ensure
that your app continues


613
00:31:06,116 --> 00:31:08,676
to function the way you
originally intended.


614
00:31:09,256 --> 00:31:14,986
Even as you make changes
and enhancements over time.


615
00:31:15,396 --> 00:31:17,906
Like all the testing features
we have added to Xcode,


616
00:31:18,286 --> 00:31:20,486
UI Tests work grade
with Xcode Server.


617
00:31:21,896 --> 00:31:23,736
This is particularly
important for UI Test


618
00:31:24,116 --> 00:31:26,446
because they may take
a bit longer to run.


619
00:31:27,286 --> 00:31:29,936
Also on Xcode Server you
will oftentimes have access


620
00:31:29,936 --> 00:31:32,336
to many more devices than
you would at your desk.


621
00:31:33,196 --> 00:31:35,606
This will let you get a
broader range of coverage


622
00:31:36,316 --> 00:31:38,886
and let you get that
coverage more often.


623
00:31:39,656 --> 00:31:44,066
Speaking of coverage, to
round things out in Xcode 7,


624
00:31:44,776 --> 00:31:46,566
we have added Code
Coverage for testing.


625
00:31:47,786 --> 00:31:51,186
You can turn on Code Coverage
here in the Schemes Test action,


626
00:31:51,726 --> 00:31:54,426
and when you do, Xcode
will build your app


627
00:31:54,586 --> 00:31:58,026
with special instrumentation
that lets it track exactly


628
00:31:58,026 --> 00:32:00,096
which lines of code
are being executed.


629
00:32:00,706 --> 00:32:02,706
After you run a suite of tests,


630
00:32:03,186 --> 00:32:05,856
you will notice the New
Code Coverage bar here


631
00:32:05,856 --> 00:32:07,546
on the right side of
the source code editor.


632
00:32:08,566 --> 00:32:10,426
This gives you a quick
visual indication


633
00:32:10,426 --> 00:32:13,996
that shows you exactly which
lines of code were called,


634
00:32:13,996 --> 00:32:17,626
more importantly it shows
you which ones were not.


635
00:32:18,806 --> 00:32:22,466
Here to give us a demo of UI
testing in Xcode 7 is Joar.


636
00:32:23,516 --> 00:32:29,056
[applause]


637
00:32:29,556 --> 00:32:30,066
>> Joar Wingfors:
Thank you, Ken.


638
00:32:30,616 --> 00:32:36,806
It is really easy to get started
with UI Testing in Xcode.


639
00:32:36,956 --> 00:32:41,666
You add a new UI Testing
target, like I have done here.


640
00:32:42,366 --> 00:32:44,636
If you have used
unit testing before,


641
00:32:44,796 --> 00:32:46,726
you recognize getting
a test case sub class


642
00:32:46,726 --> 00:32:49,106
and the method created for you.


643
00:32:50,076 --> 00:32:52,466
Had this been a unit
test, you would now have


644
00:32:52,566 --> 00:32:55,236
to write the test method
using your bare hands.


645
00:32:56,126 --> 00:33:01,916
Now we can write this for you
recording the application.


646
00:33:02,426 --> 00:33:08,156
Let's take a look.


647
00:33:08,416 --> 00:33:12,146
I put my curser in the Test
Method and start recording


648
00:33:12,336 --> 00:33:18,176
by clicking the Record button
at the bottom of the window.


649
00:33:18,326 --> 00:33:20,826
While recording any
event received


650
00:33:21,106 --> 00:33:22,356
by my application will result


651
00:33:22,356 --> 00:33:24,376
in source code being
emitted into my Test Method.


652
00:33:24,956 --> 00:33:27,566
For this test I want to
configure a new game.


653
00:33:27,796 --> 00:33:30,216
I'll go ahead, tap the
Start a New Game button.


654
00:33:30,746 --> 00:33:37,076
Note that as I tap the
button, the corresponding line


655
00:33:37,076 --> 00:33:39,376
of code showed up in the
Source Editor right away.


656
00:33:40,936 --> 00:33:42,726
Here I'm asked to pick a genre,


657
00:33:42,966 --> 00:33:45,346
I'll go with sci-fi
for this test.


658
00:33:46,076 --> 00:33:53,226
Tap next. I'll invite a couple
of players, Alice, Brandon,


659
00:33:53,326 --> 00:33:54,926
I'll search for Stacy.


660
00:33:56,036 --> 00:33:57,546
There she is.


661
00:33:58,296 --> 00:34:00,056
I'll tap done.


662
00:34:00,866 --> 00:34:05,916
Tap next. Finally tap the switch
to mark the game as ready.


663
00:34:07,366 --> 00:34:10,176
With this I'm done with -- with
what I wanted to record here.


664
00:34:10,306 --> 00:34:15,436
Let's take a look with
what we ended up with.


665
00:34:15,626 --> 00:34:17,456
This first line of
code contains a query


666
00:34:17,646 --> 00:34:20,016
to find a button label
start a new game,


667
00:34:20,585 --> 00:34:23,716
and it returns what we call an
element, an element is a proxy


668
00:34:24,266 --> 00:34:26,076
of the actual button
in the application.


669
00:34:27,085 --> 00:34:29,936
Using this element I can now
access properties of the button


670
00:34:29,985 --> 00:34:33,266
and also send events,
in this case, a tap.


671
00:34:35,456 --> 00:34:38,176
These next couple of lines
contains the source code


672
00:34:38,176 --> 00:34:44,065
for selecting the sci-fi genre
and for tapping the Next button.


673
00:34:44,156 --> 00:34:46,856
We designed the UI Testing
APIs to be easy to read here,


674
00:34:47,255 --> 00:34:49,666
as you see here,
to be easy to write


675
00:34:49,666 --> 00:34:53,436
and to help you produce
robust tests.


676
00:34:54,576 --> 00:34:57,146
Now for this to be
a test it would have


677
00:34:57,146 --> 00:34:59,506
to actually test something,
and it already does.


678
00:35:00,776 --> 00:35:02,636
If I were to run
this test as-is,


679
00:35:02,916 --> 00:35:05,456
it would implicitly validate
that all the controls


680
00:35:05,886 --> 00:35:09,806
that I interacted with while
recording are still available


681
00:35:09,806 --> 00:35:12,236
to me and fail a
test if they're not.


682
00:35:14,116 --> 00:35:16,086
In addition to this
implicit validation,


683
00:35:16,086 --> 00:35:17,366
I would typically also want


684
00:35:17,366 --> 00:35:20,716
to explicitly validate other
aspects of my application state


685
00:35:21,016 --> 00:35:22,856
at different points
throughout the test.


686
00:35:24,156 --> 00:35:27,086
In this test, I selected
a specific genre


687
00:35:27,536 --> 00:35:29,436
and invited a specific
set of players.


688
00:35:30,936 --> 00:35:33,456
Let's add a couple of
assertions to the test


689
00:35:33,586 --> 00:35:40,036
to make sure that's
what we ended up with.


690
00:35:40,246 --> 00:35:44,526
These assertions validate that
there are elements in the UI


691
00:35:44,526 --> 00:35:45,966
of the last screen
of the application


692
00:35:46,326 --> 00:35:48,106
that contains the
name of the genre


693
00:35:48,336 --> 00:35:49,666
and names of these players.


694
00:35:51,076 --> 00:35:53,276
With these assertions in
place, I will be allowed


695
00:35:53,386 --> 00:35:55,916
to run the test to make sure
it performs as expected.


696
00:36:05,166 --> 00:36:05,546
No hands.


697
00:36:18,156 --> 00:36:19,626
The test passed.


698
00:36:20,516 --> 00:36:27,006
[applause]


699
00:36:27,506 --> 00:36:28,756
>> Joar Wingfors: This
is a quick overview


700
00:36:28,756 --> 00:36:30,126
of testing in Xcode 7.


701
00:36:31,616 --> 00:36:33,056
I think you should all try it.


702
00:36:33,056 --> 00:36:35,666
I think you'll love it.


703
00:36:35,666 --> 00:36:37,476
More importantly, I think
your customers will.


704
00:36:38,266 --> 00:36:38,806
Back to you, Ken.


705
00:36:39,516 --> 00:36:46,506
[applause]


706
00:36:47,006 --> 00:36:47,206
>> Ken Orr: Great.


707
00:36:47,306 --> 00:36:47,966
Thank you, Joar.


708
00:36:50,906 --> 00:36:52,446
We have looked at just a few


709
00:36:52,446 --> 00:36:54,396
of the many new features
this morning.


710
00:36:55,666 --> 00:36:57,696
I hope you're excited
by what you've seen,


711
00:36:58,116 --> 00:37:00,166
and you can see even
more throughout this week


712
00:37:00,166 --> 00:37:01,626
at the many great
sessions which will go


713
00:37:01,626 --> 00:37:03,706
into much more detail
on Xcode 7.


714
00:37:04,676 --> 00:37:05,946
If you haven't already,
I encourage you


715
00:37:05,946 --> 00:37:08,466
to download the new Xcode and
let us know what you think.


716
00:37:08,466 --> 00:37:09,836
Thank you very much.


717
00:37:10,508 --> 00:37:12,508
[applause]

