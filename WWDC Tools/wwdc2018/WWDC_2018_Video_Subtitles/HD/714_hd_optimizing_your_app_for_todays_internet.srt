1
00:00:06,516 --> 00:00:15,500
[ Music ]


2
00:00:19,516 --> 00:00:26,386
[ Applause ]


3
00:00:26,886 --> 00:00:27,716
>> Good morning, ladies and


4
00:00:27,716 --> 00:00:28,196
gentlemen.


5
00:00:28,986 --> 00:00:29,986
How many of you are here for the


6
00:00:29,986 --> 00:00:31,706
first time at WWDC?


7
00:00:33,666 --> 00:00:34,806
That's fantastic.


8
00:00:34,806 --> 00:00:36,536
It's great to see so many new


9
00:00:36,536 --> 00:00:37,336
faces every year.


10
00:00:38,046 --> 00:00:39,146
My name is Stuart Cheshire.


11
00:00:39,266 --> 00:00:40,326
And we're going to be talking


12
00:00:40,326 --> 00:00:41,166
about networking.


13
00:00:42,176 --> 00:00:44,106
I'm going to start by covering


14
00:00:44,106 --> 00:00:45,946
some topics that affect the


15
00:00:45,946 --> 00:00:47,296
performance of your app.


16
00:00:47,886 --> 00:00:48,806
There's hardly an app that


17
00:00:48,806 --> 00:00:50,776
exists today that doesn't make


18
00:00:50,776 --> 00:00:51,766
use of networking.


19
00:00:52,246 --> 00:00:54,026
And getting the best performance


20
00:00:54,026 --> 00:00:55,176
out of the network is really


21
00:00:55,176 --> 00:00:55,856
important.


22
00:00:56,386 --> 00:00:57,236
We're going to cover some


23
00:00:57,236 --> 00:00:58,806
technologies here that help you


24
00:00:58,806 --> 00:00:59,896
get the best performance.


25
00:01:00,936 --> 00:01:03,116
We're also going to cover some


26
00:01:03,226 --> 00:01:05,296
tips and tricks and guidance


27
00:01:05,716 --> 00:01:07,656
about how to make the best use


28
00:01:07,696 --> 00:01:10,176
of Apple's APIs, a little bit of


29
00:01:10,176 --> 00:01:12,346
news about new technologies on


30
00:01:12,346 --> 00:01:14,716
the horizon, and then my


31
00:01:14,716 --> 00:01:16,556
colleague Jiten will go into


32
00:01:16,556 --> 00:01:18,106
detail on URLSession.


33
00:01:21,066 --> 00:01:23,956
Let's start off with a state of


34
00:01:23,956 --> 00:01:24,796
the Internet update.


35
00:01:25,416 --> 00:01:27,666
Earlier this year, we hit a


36
00:01:27,666 --> 00:01:30,476
total of 4 billion people using


37
00:01:30,476 --> 00:01:30,966
the Internet.


38
00:01:31,256 --> 00:01:32,466
That's more than half of the


39
00:01:32,526 --> 00:01:33,626
world's population.


40
00:01:34,166 --> 00:01:35,876
And we're used to Internet usage


41
00:01:35,876 --> 00:01:36,846
doubling and doubling.


42
00:01:37,696 --> 00:01:39,286
Clearly when we passed halfway,


43
00:01:39,776 --> 00:01:40,606
the number of people on the


44
00:01:40,606 --> 00:01:42,766
Internet can't keep doubling, so


45
00:01:43,096 --> 00:01:45,316
that growth is slowing down but


46
00:01:45,316 --> 00:01:46,306
that doesn't mean Internet


47
00:01:46,396 --> 00:01:47,576
growth is slowing down.


48
00:01:48,426 --> 00:01:49,626
There's a lot of growth in


49
00:01:49,626 --> 00:01:50,426
machine-to-machine


50
00:01:50,426 --> 00:01:51,996
communications, Internet of


51
00:01:51,996 --> 00:01:53,536
Things, Smart Homes.


52
00:01:54,256 --> 00:01:55,546
There's still a lot of growth in


53
00:01:55,546 --> 00:01:57,046
places like India and China.


54
00:01:58,276 --> 00:01:59,826
And there is a lot of people who


55
00:01:59,826 --> 00:02:01,256
have never owned a desktop


56
00:02:01,296 --> 00:02:03,646
computer who may never own a


57
00:02:03,646 --> 00:02:04,596
desktop computer.


58
00:02:05,016 --> 00:02:06,926
Their primary computing and


59
00:02:06,926 --> 00:02:08,675
communication device is their


60
00:02:08,675 --> 00:02:09,356
Smartphone.


61
00:02:09,895 --> 00:02:12,356
And a lot of those Smartphones


62
00:02:12,396 --> 00:02:14,166
are still using 2G networks.


63
00:02:15,066 --> 00:02:17,486
I'm sure most of us in this room


64
00:02:17,486 --> 00:02:20,166
are fortunate enough to live in


65
00:02:20,166 --> 00:02:21,916
places and work in places where


66
00:02:21,916 --> 00:02:23,406
we build our apps where we have


67
00:02:23,406 --> 00:02:24,946
fast LTE networks.


68
00:02:25,396 --> 00:02:27,266
And that can be a handicap


69
00:02:27,736 --> 00:02:31,076
because if you build your app so


70
00:02:31,076 --> 00:02:33,896
it works well in LTE, it may


71
00:02:33,896 --> 00:02:35,996
perform very, very badly on 2G.


72
00:02:36,916 --> 00:02:37,956
One of your competitors,


73
00:02:37,956 --> 00:02:39,106
somewhere else in the world, who


74
00:02:39,106 --> 00:02:40,476
builds an app that works great


75
00:02:40,476 --> 00:02:42,716
on 2G is going to be fantastic


76
00:02:42,716 --> 00:02:43,366
on LTE.


77
00:02:43,976 --> 00:02:46,436
So we have a tool to help


78
00:02:46,436 --> 00:02:48,946
everybody mimic some of the


79
00:02:48,946 --> 00:02:50,766
properties of these slower


80
00:02:50,766 --> 00:02:52,476
networks and that's Network Link


81
00:02:52,476 --> 00:02:53,056
Conditioner.


82
00:02:54,016 --> 00:02:55,266
You should build your app


83
00:02:55,446 --> 00:02:57,026
running Network Link Conditioner


84
00:02:57,026 --> 00:02:57,946
right from the start.


85
00:02:58,206 --> 00:02:59,476
Don't think you can add in


86
00:02:59,476 --> 00:03:02,046
performance at the end because


87
00:03:02,046 --> 00:03:02,716
it's too late.


88
00:03:03,456 --> 00:03:05,176
Always, always, always run and


89
00:03:05,176 --> 00:03:06,646
test your app using Network Link


90
00:03:06,646 --> 00:03:08,266
Conditioner and that way if you


91
00:03:08,266 --> 00:03:10,266
make a programming mistake that


92
00:03:10,266 --> 00:03:11,276
has horrible performance


93
00:03:11,276 --> 00:03:12,726
implications, you see it right


94
00:03:12,726 --> 00:03:13,916
away and you can fix it right


95
00:03:13,916 --> 00:03:14,186
away.


96
00:03:15,476 --> 00:03:16,986
Use tools like Wireshark and


97
00:03:16,986 --> 00:03:19,036
tcptrace to understand the


98
00:03:19,036 --> 00:03:20,336
network performance of your app.


99
00:03:20,906 --> 00:03:21,746
It's a lot like using


100
00:03:21,746 --> 00:03:23,046
Instruments to look at memory


101
00:03:23,046 --> 00:03:24,166
and CPU usage.


102
00:03:25,056 --> 00:03:26,866
If you haven't seen tcptrace, it


103
00:03:26,866 --> 00:03:28,186
is a wonderful tool that


104
00:03:28,186 --> 00:03:29,976
produces graphs like this that


105
00:03:29,976 --> 00:03:31,476
let you see at a glance what's


106
00:03:31,476 --> 00:03:32,486
going on, on the network.


107
00:03:33,356 --> 00:03:34,566
If you want to learn more about


108
00:03:34,566 --> 00:03:35,866
that, check out the video from


109
00:03:35,866 --> 00:03:38,546
three years ago.


110
00:03:39,456 --> 00:03:41,566
IPv6 usage continues to grow.


111
00:03:42,426 --> 00:03:43,816
Why is that important?


112
00:03:43,986 --> 00:03:46,006
It's important because IPv6 is


113
00:03:46,356 --> 00:03:47,946
shown to have better performance


114
00:03:47,946 --> 00:03:48,846
than IPv4.


115
00:03:48,906 --> 00:03:50,286
And if you care about


116
00:03:50,286 --> 00:03:51,796
performance, you want to make


117
00:03:51,796 --> 00:03:53,596
sure not just your app but the


118
00:03:53,596 --> 00:03:55,236
service your app is talking to


119
00:03:55,426 --> 00:03:56,836
support Native IPv6.


120
00:03:57,716 --> 00:03:59,156
Some places in the world are


121
00:03:59,156 --> 00:04:00,546
doing better in this respect


122
00:04:00,546 --> 00:04:01,086
than others.


123
00:04:01,906 --> 00:04:04,006
In the US, we're now up to 87%


124
00:04:04,006 --> 00:04:05,686
of mobile carriers offering


125
00:04:05,686 --> 00:04:05,996
IPv6.


126
00:04:06,036 --> 00:04:08,456
Other places like India are


127
00:04:08,456 --> 00:04:09,546
doing pretty well too.


128
00:04:10,256 --> 00:04:11,416
And let's focus a bit more on


129
00:04:11,416 --> 00:04:11,696
India.


130
00:04:12,596 --> 00:04:14,596
Here is some data that the


131
00:04:14,596 --> 00:04:15,766
networking team at Apple


132
00:04:15,766 --> 00:04:18,326
gathered earlier this year about


133
00:04:18,466 --> 00:04:21,086
net TCP connection setup time


134
00:04:21,516 --> 00:04:24,566
and ongoing round-trip delay on


135
00:04:25,256 --> 00:04:26,606
cellular networks in India.


136
00:04:27,266 --> 00:04:28,756
The blue line is IPv6.


137
00:04:29,486 --> 00:04:31,416
And if we, for example, look at


138
00:04:31,416 --> 00:04:33,946
the 75th percentile, we can say


139
00:04:34,226 --> 00:04:39,316
75% of TCP connections over v6


140
00:04:39,376 --> 00:04:40,986
are set up in less than 150


141
00:04:40,986 --> 00:04:41,746
milliseconds.


142
00:04:42,446 --> 00:04:44,576
The comparable number for IPv4


143
00:04:44,576 --> 00:04:46,796
is worse than 325.


144
00:04:47,336 --> 00:04:48,636
It's more than twice as slow.


145
00:04:49,036 --> 00:04:50,976
So if you want fast, responsive


146
00:04:50,976 --> 00:04:53,526
applications for your users, get


147
00:04:53,526 --> 00:04:55,166
on IPv6 if you're not already.


148
00:04:56,926 --> 00:04:58,516
Another technology that improves


149
00:04:58,566 --> 00:05:00,526
performance by reducing packet


150
00:05:00,526 --> 00:05:02,286
loss and retransmission is


151
00:05:02,286 --> 00:05:03,266
Explicit Congestion


152
00:05:03,266 --> 00:05:04,026
Notification.


153
00:05:04,836 --> 00:05:06,056
We've had this enabled by


154
00:05:06,056 --> 00:05:08,026
default in macOS and iOS for


155
00:05:08,026 --> 00:05:09,496
some years now so you don't need


156
00:05:09,496 --> 00:05:10,306
to do anything on your


157
00:05:10,306 --> 00:05:12,376
application to take advantage of


158
00:05:12,376 --> 00:05:12,726
this.


159
00:05:13,706 --> 00:05:14,936
Do make sure your service


160
00:05:15,016 --> 00:05:16,506
supports ECN.


161
00:05:17,296 --> 00:05:20,026
In a survey we did of the Alexa


162
00:05:20,026 --> 00:05:22,076
top million websites, we found


163
00:05:22,076 --> 00:05:24,276
last month we're now up to 77%


164
00:05:24,276 --> 00:05:25,316
of the Alexa top million


165
00:05:25,316 --> 00:05:27,226
services supporting ECN, which


166
00:05:27,226 --> 00:05:28,666
is a big improvement compared to


167
00:05:28,666 --> 00:05:32,206
a few years ago.


168
00:05:32,936 --> 00:05:34,936
Another technology that helps


169
00:05:34,936 --> 00:05:36,506
improve performance and


170
00:05:36,506 --> 00:05:37,766
resilience of your connections


171
00:05:37,766 --> 00:05:39,016
is Multipath TCP.


172
00:05:39,796 --> 00:05:41,336
Quite often, the user may make a


173
00:05:41,336 --> 00:05:43,426
connection in their office on


174
00:05:43,426 --> 00:05:45,676
Wi-Fi and then they walk outside


175
00:05:46,436 --> 00:05:47,896
and they lose the Wi-Fi signal.


176
00:05:47,896 --> 00:05:49,516
Now with traditional TCP, the


177
00:05:49,516 --> 00:05:50,666
connection is broken.


178
00:05:50,666 --> 00:05:51,506
You have to reconnect.


179
00:05:51,506 --> 00:05:52,516
You have to start again.


180
00:05:53,176 --> 00:05:55,356
Multipath TCP makes its packet


181
00:05:55,356 --> 00:05:56,716
routing decisions on a per


182
00:05:56,716 --> 00:05:58,636
packet basis not per connection,


183
00:05:59,236 --> 00:06:01,976
so it can switch that connection


184
00:06:01,976 --> 00:06:03,846
live to a different interface.


185
00:06:05,876 --> 00:06:08,416
We talked last year about how to


186
00:06:08,416 --> 00:06:09,876
enable this in your application.


187
00:06:10,016 --> 00:06:11,706
And, of course, check with your


188
00:06:11,706 --> 00:06:13,076
server operators to make sure


189
00:06:13,076 --> 00:06:14,106
your servers are supporting


190
00:06:14,106 --> 00:06:14,976
Multipath too.


191
00:06:16,146 --> 00:06:18,246
We recently did a survey of the


192
00:06:18,246 --> 00:06:20,196
mobile carriers that Apple works


193
00:06:20,196 --> 00:06:22,036
with around the world and right


194
00:06:22,036 --> 00:06:25,706
now 78% of their networks work


195
00:06:26,726 --> 00:06:28,226
with Multipath TCP.


196
00:06:28,696 --> 00:06:30,496
Only 22% of carriers are still


197
00:06:30,496 --> 00:06:32,016
blocking Multipath connections.


198
00:06:32,536 --> 00:06:37,456
TCP Fast Open is a technology


199
00:06:37,706 --> 00:06:39,536
that lets you avoid the normal


200
00:06:39,536 --> 00:06:41,446
round-trip delay of the TCP


201
00:06:41,446 --> 00:06:42,426
connection set up.


202
00:06:42,906 --> 00:06:46,216
TCP Fast Open lets you put your


203
00:06:46,216 --> 00:06:48,766
initial data in with the TCP


204
00:06:48,766 --> 00:06:50,706
connection set up packets.


205
00:06:52,546 --> 00:06:53,856
You can check out more details


206
00:06:53,856 --> 00:06:55,096
of that from our video from


207
00:06:55,096 --> 00:06:55,976
three years ago.


208
00:06:56,476 --> 00:06:57,856
And check with your server


209
00:06:57,856 --> 00:06:59,286
operators to make sure that your


210
00:06:59,286 --> 00:07:03,256
servers support TCP Fast Open.


211
00:07:03,476 --> 00:07:05,586
Now moving on to some new news.


212
00:07:06,216 --> 00:07:09,176
There is a technology that many


213
00:07:09,176 --> 00:07:10,776
of you will have heard of called


214
00:07:10,836 --> 00:07:11,106
Quick.


215
00:07:11,986 --> 00:07:13,326
Quick is a new transport


216
00:07:13,326 --> 00:07:15,856
protocol, the first serious


217
00:07:15,856 --> 00:07:17,516
candidate in 30 years for a


218
00:07:17,516 --> 00:07:19,246
successor to replace TCP.


219
00:07:19,796 --> 00:07:21,576
It started off as an experiment


220
00:07:21,676 --> 00:07:23,086
by some engineers at Google.


221
00:07:23,566 --> 00:07:24,716
That experiment proved


222
00:07:24,716 --> 00:07:25,366
successful.


223
00:07:25,366 --> 00:07:27,626
It has now been adopted as an


224
00:07:27,696 --> 00:07:29,876
IETF work in group item for


225
00:07:29,876 --> 00:07:30,766
standardization.


226
00:07:31,966 --> 00:07:33,256
Apple engineers are


227
00:07:33,256 --> 00:07:34,446
participating in that.


228
00:07:34,446 --> 00:07:35,816
In fact, we have engineers right


229
00:07:35,816 --> 00:07:37,786
now at the Quick meeting taking


230
00:07:37,786 --> 00:07:38,596
place in Sweden.


231
00:07:39,996 --> 00:07:41,916
This is not yet ready for prime


232
00:07:41,916 --> 00:07:42,286
time.


233
00:07:42,286 --> 00:07:43,506
The standard is not finished,


234
00:07:44,016 --> 00:07:45,416
but Apple is working on it.


235
00:07:45,416 --> 00:07:47,146
As soon as it is ready, you can


236
00:07:47,146 --> 00:07:48,306
expect to see Apple API


237
00:07:48,436 --> 00:07:50,916
supporting that.


238
00:07:51,266 --> 00:07:52,256
Continuing in the theme of


239
00:07:52,306 --> 00:07:55,406
performance, we observed some


240
00:07:55,406 --> 00:07:56,656
behavior that's very common.


241
00:07:57,356 --> 00:07:59,336
Lots and lots of websites and


242
00:07:59,336 --> 00:08:01,036
Internet services use pretty


243
00:08:01,036 --> 00:08:03,666
short lifetimes on their DNS


244
00:08:03,666 --> 00:08:04,266
records.


245
00:08:04,666 --> 00:08:06,596
And they do this because if a


246
00:08:06,596 --> 00:08:08,736
data center goes down, they want


247
00:08:08,736 --> 00:08:10,496
to be able to update the DNS and


248
00:08:10,496 --> 00:08:12,686
very rapidly direct traffic to a


249
00:08:12,686 --> 00:08:13,666
different data center.


250
00:08:15,266 --> 00:08:16,636
The problem with this approach


251
00:08:17,076 --> 00:08:19,166
is you're paying a performance


252
00:08:19,166 --> 00:08:20,736
cost for something that almost


253
00:08:20,736 --> 00:08:21,506
never happens.


254
00:08:21,596 --> 00:08:23,816
Data centers very rarely go


255
00:08:23,816 --> 00:08:24,186
down.


256
00:08:25,066 --> 00:08:27,316
And what this means is every


257
00:08:27,316 --> 00:08:29,276
time a DNS address record is


258
00:08:29,276 --> 00:08:31,096
expired, your client has to


259
00:08:31,096 --> 00:08:32,736
spend another round-trip delay


260
00:08:33,046 --> 00:08:35,496
waiting for the response from


261
00:08:35,496 --> 00:08:37,306
the DNS server, which is the


262
00:08:37,306 --> 00:08:38,606
same as what it knew already


263
00:08:38,606 --> 00:08:39,155
last time.


264
00:08:39,756 --> 00:08:42,736
So thinking about this, we


265
00:08:42,736 --> 00:08:44,826
realized and optimization we


266
00:08:44,826 --> 00:08:45,216
could do.


267
00:08:45,866 --> 00:08:47,856
If you pass the flag to opt into


268
00:08:47,856 --> 00:08:50,866
this new behavior, then when you


269
00:08:50,866 --> 00:08:52,846
do a DNS query, if we have a


270
00:08:52,846 --> 00:08:54,446
stale, expired answer in the


271
00:08:54,446 --> 00:08:56,956
cache, we will give that to you


272
00:08:57,056 --> 00:08:59,286
immediately while in parallel,


273
00:08:59,286 --> 00:09:00,876
at the same time, doing the


274
00:09:00,876 --> 00:09:02,816
normal DNS query we would have


275
00:09:02,816 --> 00:09:03,476
done anyway.


276
00:09:04,576 --> 00:09:05,796
If the answer comes back the


277
00:09:05,796 --> 00:09:07,636
same, as we predict it will


278
00:09:07,636 --> 00:09:09,586
almost always, everything is


279
00:09:09,586 --> 00:09:11,136
fine, you just saved a


280
00:09:11,136 --> 00:09:12,516
round-trip time and got your


281
00:09:12,516 --> 00:09:13,766
connection started faster.


282
00:09:14,426 --> 00:09:15,856
If the answer comes back as a


283
00:09:15,856 --> 00:09:18,156
different address, we will then


284
00:09:18,156 --> 00:09:19,356
give another asynchronous


285
00:09:19,356 --> 00:09:21,416
notification to your client that


286
00:09:21,416 --> 00:09:22,666
there's a new address available


287
00:09:22,696 --> 00:09:23,926
which it should also try.


288
00:09:24,706 --> 00:09:26,096
And to make use of this, you


289
00:09:26,096 --> 00:09:27,446
have to use it in conjunction


290
00:09:27,446 --> 00:09:28,946
with Happy Eyeballs algorithm.


291
00:09:29,436 --> 00:09:30,996
That means your racing multiple


292
00:09:30,996 --> 00:09:32,126
connections in parallel.


293
00:09:32,996 --> 00:09:33,976
You're trying IPv4, IPv6,


294
00:09:34,006 --> 00:09:36,886
multiple addresses, multiple


295
00:09:36,886 --> 00:09:37,756
interfaces.


296
00:09:38,566 --> 00:09:39,846
If that sounds like a lot of


297
00:09:39,846 --> 00:09:41,356
work and it's hard to get right,


298
00:09:41,516 --> 00:09:42,606
you're absolutely correct.


299
00:09:42,606 --> 00:09:43,496
It is a lot of work.


300
00:09:44,096 --> 00:09:46,246
Stay after the break and we will


301
00:09:46,246 --> 00:09:48,686
tell you about some new APIs


302
00:09:48,966 --> 00:09:50,406
that let you take advantage of


303
00:09:50,406 --> 00:09:51,666
this without doing all the hard


304
00:09:51,666 --> 00:09:52,346
work yourself.


305
00:09:54,526 --> 00:09:56,056
Now moving on to some guidance.


306
00:09:56,726 --> 00:09:58,836
We have seen a common pattern


307
00:09:59,246 --> 00:10:02,296
that many developers use


308
00:10:02,446 --> 00:10:04,426
SCNetworkReachability as a


309
00:10:04,556 --> 00:10:05,326
preflight check.


310
00:10:06,396 --> 00:10:07,686
They want to predict the future.


311
00:10:07,916 --> 00:10:09,076
They want to know whether the


312
00:10:09,076 --> 00:10:10,936
next network operation they do


313
00:10:10,936 --> 00:10:12,096
will succeed or fail.


314
00:10:12,626 --> 00:10:14,956
And, unfortunately, predicting


315
00:10:14,956 --> 00:10:16,116
the future is always a hard


316
00:10:16,116 --> 00:10:16,666
thing to do.


317
00:10:17,216 --> 00:10:18,786
You may have connectivity now


318
00:10:19,476 --> 00:10:20,966
but two seconds from now the


319
00:10:21,026 --> 00:10:22,366
user has walked out of the


320
00:10:22,366 --> 00:10:23,696
building and you've lost the


321
00:10:23,696 --> 00:10:24,496
Wi-Fi signal.


322
00:10:24,886 --> 00:10:27,656
So there is no way to guarantee


323
00:10:27,656 --> 00:10:29,026
whether a future operation will


324
00:10:29,026 --> 00:10:29,566
succeed.


325
00:10:30,486 --> 00:10:32,356
And we see this pattern where


326
00:10:32,356 --> 00:10:32,826
they check.


327
00:10:33,166 --> 00:10:34,326
The preflight says yes.


328
00:10:34,406 --> 00:10:35,006
They try it.


329
00:10:35,056 --> 00:10:35,686
They fail.


330
00:10:36,126 --> 00:10:36,836
They go back.


331
00:10:36,836 --> 00:10:37,716
They check again.


332
00:10:38,526 --> 00:10:41,016
This also is a lot of work, a


333
00:10:41,016 --> 00:10:42,546
lot of [inaudible], a lot of


334
00:10:42,546 --> 00:10:44,026
difficult things to get right


335
00:10:44,606 --> 00:10:46,426
including networks with proxies.


336
00:10:47,606 --> 00:10:48,776
We can handle that for you.


337
00:10:50,506 --> 00:10:53,746
The better way to do this is


338
00:10:53,746 --> 00:10:56,006
just make a connection using the


339
00:10:56,006 --> 00:10:58,616
waitsForConnectivity option.


340
00:10:58,816 --> 00:11:00,326
You can learn more about that


341
00:11:00,326 --> 00:11:01,526
watching last year's video.


342
00:11:01,966 --> 00:11:03,956
What this means is if you want a


343
00:11:03,956 --> 00:11:05,566
connection, you tell the system


344
00:11:05,566 --> 00:11:06,566
I want a connection.


345
00:11:06,806 --> 00:11:09,006
Now if you can, later if not.


346
00:11:09,326 --> 00:11:10,976
If the device is in airplane


347
00:11:10,976 --> 00:11:12,396
mode, then when it's out of


348
00:11:12,396 --> 00:11:13,566
airplane mode your connection


349
00:11:13,566 --> 00:11:14,216
will succeed.


350
00:11:14,686 --> 00:11:16,266
That is much easier than


351
00:11:16,266 --> 00:11:17,396
building the retry loop


352
00:11:17,396 --> 00:11:17,866
yourself.


353
00:11:18,876 --> 00:11:20,466
There is one case we've seen


354
00:11:20,466 --> 00:11:22,456
with developers which does make


355
00:11:22,456 --> 00:11:24,516
sense which is if you're going


356
00:11:24,516 --> 00:11:26,046
to have the user answer a lot of


357
00:11:26,046 --> 00:11:27,876
information in a form, you may


358
00:11:27,876 --> 00:11:29,146
not want to waste the user's


359
00:11:29,146 --> 00:11:31,186
time if you have good reason to


360
00:11:31,186 --> 00:11:33,096
believe that may later fail.


361
00:11:34,126 --> 00:11:35,736
If that is the use case you care


362
00:11:35,736 --> 00:11:37,366
about, stay after the break


363
00:11:37,606 --> 00:11:39,076
because we have a new way to do


364
00:11:39,076 --> 00:11:43,166
that that's much better.


365
00:11:43,356 --> 00:11:45,436
Security remains important, as


366
00:11:45,536 --> 00:11:46,286
always.


367
00:11:47,316 --> 00:11:49,696
After ten years of using TLS


368
00:11:49,736 --> 00:11:52,256
1.2, the Internet is now ready


369
00:11:52,256 --> 00:11:53,886
to move to its successor, TLS


370
00:11:53,886 --> 00:11:54,646
1.3.


371
00:11:55,286 --> 00:11:56,406
It has a number of improved


372
00:11:56,406 --> 00:11:57,566
security features.


373
00:11:58,146 --> 00:12:00,066
It has reduced connection setup


374
00:12:00,106 --> 00:12:02,576
time, similar to TCP Fast Open.


375
00:12:03,496 --> 00:12:05,536
That standard is now final.


376
00:12:05,716 --> 00:12:07,506
The final draft was approved for


377
00:12:07,506 --> 00:12:09,286
publication by the Internet


378
00:12:09,286 --> 00:12:10,616
Engineering Steering Group


379
00:12:10,906 --> 00:12:11,726
earlier this year.


380
00:12:12,586 --> 00:12:14,766
We are waiting for the actual


381
00:12:14,766 --> 00:12:16,366
published document to come out


382
00:12:16,366 --> 00:12:17,406
of the RFC Editor.


383
00:12:17,836 --> 00:12:19,416
And when that does, we'll be


384
00:12:19,416 --> 00:12:22,246
turning on TLS 1.3 by default.


385
00:12:23,326 --> 00:12:25,026
Right now in your seed, it's not


386
00:12:25,026 --> 00:12:25,976
turned on by default.


387
00:12:27,166 --> 00:12:28,426
You can use the instructions


388
00:12:28,426 --> 00:12:32,636
here on iOS or macOS to enable


389
00:12:32,896 --> 00:12:35,726
TLS 13 in your applications.


390
00:12:36,016 --> 00:12:37,386
And we encourage you to do this


391
00:12:37,386 --> 00:12:39,696
right away because later this


392
00:12:39,696 --> 00:12:41,926
year when TLS 1.3 is turned on


393
00:12:41,926 --> 00:12:43,796
by default, you don't risk


394
00:12:43,796 --> 00:12:45,166
problems with your service not


395
00:12:45,166 --> 00:12:45,936
being compatible.


396
00:12:46,236 --> 00:12:48,346
So test them right now to make


397
00:12:48,346 --> 00:12:49,896
sure everything will go smoothly


398
00:12:50,166 --> 00:12:51,346
when the switchover happens


399
00:12:51,346 --> 00:12:51,946
later this year.


400
00:12:56,046 --> 00:12:57,446
Another element of security


401
00:12:57,446 --> 00:12:58,956
that's new is certificate


402
00:12:58,956 --> 00:12:59,676
transparency.


403
00:12:59,676 --> 00:13:02,116
You've probably heard cases


404
00:13:02,366 --> 00:13:05,666
where certificate authorities,


405
00:13:06,036 --> 00:13:07,026
either through malice or


406
00:13:07,026 --> 00:13:08,986
incompetence, issue rogue


407
00:13:08,986 --> 00:13:10,646
certificates to entities that


408
00:13:10,646 --> 00:13:11,196
they should not.


409
00:13:12,556 --> 00:13:14,046
The solution to this is


410
00:13:14,046 --> 00:13:15,546
something called certificate


411
00:13:15,546 --> 00:13:16,766
transparency logs.


412
00:13:17,556 --> 00:13:19,426
Every legitimate certificate


413
00:13:19,426 --> 00:13:22,326
authority now issues a public


414
00:13:22,926 --> 00:13:24,766
statement of every certificate


415
00:13:24,766 --> 00:13:25,516
it issues.


416
00:13:25,596 --> 00:13:27,076
And those are recorded in public


417
00:13:27,076 --> 00:13:29,296
logs for anybody to inspect.


418
00:13:30,236 --> 00:13:31,836
And this means that if a rogue


419
00:13:32,406 --> 00:13:34,436
certificate authority issues a


420
00:13:34,436 --> 00:13:36,596
bogus certificate, if it


421
00:13:36,596 --> 00:13:37,786
publishes it, they'll


422
00:13:37,786 --> 00:13:40,656
immediately get caught.


423
00:13:40,656 --> 00:13:41,856
And if they don't publish it,


424
00:13:42,186 --> 00:13:43,486
they'll be caught by the client.


425
00:13:44,966 --> 00:13:46,596
This is the setup you're


426
00:13:46,596 --> 00:13:47,966
probably familiar with.


427
00:13:48,436 --> 00:13:50,356
The new entity here is the log.


428
00:13:51,186 --> 00:13:52,736
When a certificate authority


429
00:13:52,936 --> 00:13:54,786
issues a certificate to a


430
00:13:54,786 --> 00:13:57,616
server, it also records that


431
00:13:57,616 --> 00:13:59,896
with the log and the log gives


432
00:13:59,896 --> 00:14:01,776
the server a signed affidavit


433
00:14:02,146 --> 00:14:03,656
that its certificate has been


434
00:14:03,656 --> 00:14:04,646
publicly recorded.


435
00:14:04,926 --> 00:14:06,076
And then when the client


436
00:14:06,166 --> 00:14:08,066
connects, the server can give


437
00:14:08,066 --> 00:14:09,096
all that information to the


438
00:14:09,096 --> 00:14:11,046
client and the client can verify


439
00:14:11,046 --> 00:14:12,256
that not only is this a signed


440
00:14:12,256 --> 00:14:14,236
certificate, it is a publicly


441
00:14:14,236 --> 00:14:15,786
logged signed certificate.


442
00:14:16,916 --> 00:14:18,156
Now suppose we have a rogue


443
00:14:18,156 --> 00:14:20,226
certificate authority that


444
00:14:20,326 --> 00:14:22,286
doesn't publicly expose the


445
00:14:22,286 --> 00:14:23,836
rogue certificates it's issuing.


446
00:14:24,726 --> 00:14:26,426
The client will reject that


447
00:14:26,426 --> 00:14:27,916
because it doesn't have the


448
00:14:27,916 --> 00:14:30,386
affidavit to attest to it being


449
00:14:30,476 --> 00:14:31,826
recorded in a public log.


450
00:14:33,006 --> 00:14:34,286
Starting later this year, we


451
00:14:34,596 --> 00:14:35,896
will be enforcing this.


452
00:14:37,456 --> 00:14:39,806
All newly issued TLS


453
00:14:39,806 --> 00:14:41,726
certificates must include the


454
00:14:41,726 --> 00:14:43,236
verification that they are


455
00:14:43,236 --> 00:14:44,096
publicly logged.


456
00:14:44,486 --> 00:14:46,036
And if they're not, then the


457
00:14:46,036 --> 00:14:47,056
client will reject it.


458
00:14:47,536 --> 00:14:49,686
Your apps don't need to make any


459
00:14:49,686 --> 00:14:51,926
changes, but if you have


460
00:14:51,926 --> 00:14:53,006
tailored certificates for your


461
00:14:53,006 --> 00:14:54,996
servers, make sure that your


462
00:14:54,996 --> 00:14:56,686
certificate authority is


463
00:14:56,686 --> 00:14:58,186
recording them in the public


464
00:14:58,306 --> 00:14:59,906
certificate transparency logs.


465
00:15:00,486 --> 00:15:03,686
Now we have a bit of news for


466
00:15:04,246 --> 00:15:05,286
hardware developers.


467
00:15:06,286 --> 00:15:08,396
The Bonjour Conformance Test is


468
00:15:08,396 --> 00:15:10,776
a tool that lets you verify that


469
00:15:10,776 --> 00:15:12,386
your hardware devices implement


470
00:15:12,386 --> 00:15:13,376
Bonjour correctly.


471
00:15:14,466 --> 00:15:15,946
You need to run this test if you


472
00:15:15,946 --> 00:15:17,086
want to use the Bonjour


473
00:15:17,086 --> 00:15:18,796
trademark name and logo on your


474
00:15:18,796 --> 00:15:19,376
packaging.


475
00:15:20,256 --> 00:15:21,796
You need to run this test if you


476
00:15:21,796 --> 00:15:23,826
want to bundle the Bonjour for


477
00:15:23,866 --> 00:15:26,366
Windows installer with a Windows


478
00:15:26,366 --> 00:15:27,086
application.


479
00:15:27,696 --> 00:15:28,896
And if you want to use the


480
00:15:28,896 --> 00:15:30,736
AirPrint, AirPlay, CarPlay,


481
00:15:30,736 --> 00:15:32,506
HomeKit logos on your packaging,


482
00:15:33,046 --> 00:15:34,356
passing the Bonjour Conformance


483
00:15:34,356 --> 00:15:36,136
Test is a part of the logo


484
00:15:36,136 --> 00:15:37,976
licensing process because


485
00:15:37,976 --> 00:15:39,916
reliable Bonjour is an essential


486
00:15:39,916 --> 00:15:41,006
part of those products.


487
00:15:41,926 --> 00:15:44,056
But more importantly, the value


488
00:15:44,056 --> 00:15:44,966
of running the Bonjour


489
00:15:44,966 --> 00:15:46,996
Conformance Test is it helps you


490
00:15:46,996 --> 00:15:48,136
improve the quality of your


491
00:15:48,136 --> 00:15:50,096
products and that makes them


492
00:15:50,096 --> 00:15:51,856
more reliable which makes your


493
00:15:51,856 --> 00:15:53,996
customers happy which makes your


494
00:15:53,996 --> 00:15:55,536
customers not return the product


495
00:15:55,536 --> 00:15:57,026
to the store because they can't


496
00:15:57,026 --> 00:15:57,756
make it work.


497
00:15:58,226 --> 00:15:59,926
And that's what your customers


498
00:15:59,926 --> 00:16:00,196
want.


499
00:16:00,296 --> 00:16:01,066
That's what you want.


500
00:16:01,146 --> 00:16:01,996
And that's what we want.


501
00:16:02,046 --> 00:16:04,426
We want happy customers having a


502
00:16:04,426 --> 00:16:05,606
wonderful time with products


503
00:16:05,606 --> 00:16:06,436
that work reliably.


504
00:16:06,436 --> 00:16:11,556
Now I want to cover API choices.


505
00:16:12,596 --> 00:16:15,156
Thirty years ago we had BSD


506
00:16:15,156 --> 00:16:15,776
Sockets.


507
00:16:16,396 --> 00:16:18,296
And it was a great API 30 years


508
00:16:18,296 --> 00:16:18,616
ago.


509
00:16:19,046 --> 00:16:21,616
But 30 years ago we didn't have


510
00:16:22,426 --> 00:16:24,476
mobile computers in our pockets.


511
00:16:24,546 --> 00:16:25,576
We didn't have wireless


512
00:16:25,576 --> 00:16:26,216
networking.


513
00:16:26,216 --> 00:16:29,126
We didn't have IPv6.


514
00:16:29,326 --> 00:16:31,026
We didn't have many computers


515
00:16:31,026 --> 00:16:32,066
with more than one network


516
00:16:32,066 --> 00:16:32,746
interface.


517
00:16:32,896 --> 00:16:34,936
If you had an Ethernet port on


518
00:16:34,936 --> 00:16:36,176
your computer, that was a fancy


519
00:16:36,176 --> 00:16:36,716
computer.


520
00:16:37,376 --> 00:16:40,236
Now 4 billion people around the


521
00:16:40,236 --> 00:16:42,806
world have a multi-homed IPv6


522
00:16:43,136 --> 00:16:44,566
wireless battery-powered


523
00:16:44,566 --> 00:16:46,226
computing device that does power


524
00:16:46,226 --> 00:16:47,456
management and goes to sleep to


525
00:16:47,456 --> 00:16:48,116
save energy.


526
00:16:48,496 --> 00:16:49,716
The world has become a lot more


527
00:16:49,716 --> 00:16:50,376
complicated.


528
00:16:52,056 --> 00:16:53,246
Many of you may be using


529
00:16:53,246 --> 00:16:55,326
third-party libraries which are


530
00:16:55,376 --> 00:16:56,356
built on that Sockets


531
00:16:56,356 --> 00:16:57,016
foundation.


532
00:16:57,686 --> 00:16:59,996
Many more of you may be using


533
00:16:59,996 --> 00:17:00,816
URLSession.


534
00:17:01,306 --> 00:17:03,006
And you may have assumed that


535
00:17:03,006 --> 00:17:05,626
URLSession is also just a wrap


536
00:17:05,626 --> 00:17:06,556
around Sockets.


537
00:17:07,906 --> 00:17:09,526
Well, not quite.


538
00:17:11,006 --> 00:17:13,046
URLSession is actually built


539
00:17:13,326 --> 00:17:15,445
using Apple's user space


540
00:17:15,656 --> 00:17:17,386
networking code network


541
00:17:17,386 --> 00:17:17,856
framework.


542
00:17:18,346 --> 00:17:21,306
And starting now, in iOS 12, we


543
00:17:21,306 --> 00:17:23,976
are exposing that same API that


544
00:17:23,976 --> 00:17:26,056
URLSession uses so that your


545
00:17:26,056 --> 00:17:29,316
apps can directly use that for


546
00:17:29,486 --> 00:17:31,986
making TCP connections and other


547
00:17:31,986 --> 00:17:33,266
appropriate use cases.


548
00:17:33,526 --> 00:17:35,266
If you're doing things with URLs


549
00:17:35,266 --> 00:17:37,356
and HTTP GETs, URLSession is


550
00:17:37,356 --> 00:17:38,716
still your API of choice.


551
00:17:39,056 --> 00:17:41,116
But for the things URLSession


552
00:17:41,116 --> 00:17:43,316
doesn't cover, we now expose


553
00:17:43,316 --> 00:17:45,766
network framework so your apps


554
00:17:45,766 --> 00:17:46,896
can use that directly.


555
00:17:47,876 --> 00:17:49,816
And if you're the developer of


556
00:17:49,816 --> 00:17:50,896
one of these third-party


557
00:17:50,896 --> 00:17:51,866
libraries, which are very


558
00:17:51,866 --> 00:17:54,156
popular that are built on BSD


559
00:17:54,156 --> 00:17:56,606
Sockets, we encourage you to


560
00:17:56,606 --> 00:17:58,716
look at the network framework


561
00:17:58,716 --> 00:17:59,216
APIs.


562
00:17:59,596 --> 00:18:02,016
Move your library over to these


563
00:18:02,016 --> 00:18:04,326
improved high-performance APIs,


564
00:18:04,926 --> 00:18:07,036
and give us feedback about how


565
00:18:07,036 --> 00:18:07,886
that goes for you.


566
00:18:08,866 --> 00:18:11,086
So to summarize, we really


567
00:18:11,086 --> 00:18:13,786
strongly recommend here and now


568
00:18:14,076 --> 00:18:17,646
in 2018 that you avoid using BSD


569
00:18:17,646 --> 00:18:18,296
Sockets.


570
00:18:18,686 --> 00:18:20,756
Avoid using libraries that are


571
00:18:20,756 --> 00:18:22,706
nothing but wrappers around BSD


572
00:18:22,706 --> 00:18:23,316
Sockets.


573
00:18:23,766 --> 00:18:25,146
And if you are one of the


574
00:18:25,146 --> 00:18:27,146
authors of those libraries using


575
00:18:27,146 --> 00:18:29,456
these older APIs, look at


576
00:18:29,456 --> 00:18:30,116
switching over.


577
00:18:30,116 --> 00:18:32,056
Come and meet us in the labs


578
00:18:32,106 --> 00:18:34,106
this afternoon and tomorrow and


579
00:18:34,236 --> 00:18:36,246
give us your feedback about what


580
00:18:36,246 --> 00:18:37,816
it takes to move your libraries


581
00:18:38,046 --> 00:18:39,076
to new APIs.


582
00:18:40,076 --> 00:18:41,316
And with that, I would like to


583
00:18:41,316 --> 00:18:43,106
invite my colleagues Jiten to


584
00:18:43,106 --> 00:18:44,996
come up on stage and give you


585
00:18:45,166 --> 00:18:46,816
more details about URLSession.


586
00:18:47,516 --> 00:18:51,976
[ Applause ]


587
00:18:52,476 --> 00:18:53,086
>> Thank you, Stuart.


588
00:18:53,686 --> 00:18:55,176
Good morning everyone.


589
00:18:55,726 --> 00:18:57,416
My name is Jiten Mehta.


590
00:18:57,416 --> 00:18:58,706
And I'm an engineer on the CF


591
00:18:58,706 --> 00:18:59,316
network team.


592
00:19:00,266 --> 00:19:01,326
Today I'll be talking to you


593
00:19:01,326 --> 00:19:02,666
about some networking best


594
00:19:02,666 --> 00:19:03,956
practices for your apps.


595
00:19:05,396 --> 00:19:07,076
Networking is an essential part


596
00:19:07,076 --> 00:19:08,386
of every application.


597
00:19:09,346 --> 00:19:10,616
Each year, you guys do a great


598
00:19:10,616 --> 00:19:12,276
job of adding awesome features


599
00:19:12,276 --> 00:19:12,986
to your apps.


600
00:19:13,406 --> 00:19:14,976
And today I'll be talking to you


601
00:19:15,136 --> 00:19:16,706
about some simple networking


602
00:19:16,706 --> 00:19:19,086
details, details that can help


603
00:19:19,086 --> 00:19:20,236
make your apps successful.


604
00:19:20,796 --> 00:19:24,836
Our agenda for today is going to


605
00:19:24,836 --> 00:19:27,296
cover four categories: reducing


606
00:19:27,296 --> 00:19:29,926
latency, maximizing throughput,


607
00:19:31,036 --> 00:19:33,396
increasing responsiveness, and


608
00:19:33,396 --> 00:19:34,876
making better use of system


609
00:19:34,876 --> 00:19:35,596
resources.


610
00:19:36,806 --> 00:19:38,506
Before that, let's quickly


611
00:19:38,506 --> 00:19:40,386
review URLSession, the API


612
00:19:40,386 --> 00:19:40,976
you've been using.


613
00:19:45,526 --> 00:19:47,956
URLSession is the recommended


614
00:19:48,106 --> 00:19:50,306
high-level networking API


615
00:19:50,686 --> 00:19:52,216
available on all Apple


616
00:19:52,216 --> 00:19:52,976
platforms.


617
00:19:54,426 --> 00:19:56,766
URLSession has first-class


618
00:19:56,766 --> 00:20:00,746
support for HTTP/2 and HTTP/1.1.


619
00:20:02,056 --> 00:20:04,136
If your app does not use HTTP,


620
00:20:04,136 --> 00:20:05,966
we have support for


621
00:20:06,066 --> 00:20:09,226
URLSessionStreamTask, an API


622
00:20:09,226 --> 00:20:11,056
that allows you to make secure


623
00:20:11,056 --> 00:20:12,946
TCP connections to a server over


624
00:20:13,256 --> 00:20:14,786
which you can build your


625
00:20:14,786 --> 00:20:15,796
arbitrary protocol.


626
00:20:17,136 --> 00:20:18,656
That's URLSession.


627
00:20:19,716 --> 00:20:20,866
Let's move on to our first


628
00:20:20,866 --> 00:20:23,926
agenda item: reducing latency.


629
00:20:25,296 --> 00:20:26,246
Let's suppose you and your


630
00:20:26,246 --> 00:20:28,096
friends go to a restaurant where


631
00:20:28,226 --> 00:20:29,706
the waiter walks up to you and


632
00:20:29,706 --> 00:20:31,296
you say, "Can I get a glass of


633
00:20:31,296 --> 00:20:31,866
water please?"


634
00:20:32,746 --> 00:20:34,576
The waiter say, "Sure," walks


635
00:20:34,576 --> 00:20:35,896
away, fetches you a glass of


636
00:20:35,896 --> 00:20:36,196
water.


637
00:20:37,016 --> 00:20:38,366
Your friend then says, "Can I


638
00:20:38,366 --> 00:20:39,406
get a glass of water too?"


639
00:20:40,066 --> 00:20:41,386
The waiter says, "Sure," walks


640
00:20:41,386 --> 00:20:42,886
away, and fetches your friend a


641
00:20:42,886 --> 00:20:43,876
glass of water.


642
00:20:44,526 --> 00:20:45,576
Wouldn't it be faster if the


643
00:20:45,576 --> 00:20:46,836
waiter took everyone's order at


644
00:20:46,836 --> 00:20:48,556
the same time and reduce the


645
00:20:48,556 --> 00:20:49,486
number of round trips?


646
00:20:50,816 --> 00:20:52,286
The idea to reduce latency is


647
00:20:52,286 --> 00:20:52,746
simple.


648
00:20:53,536 --> 00:20:54,966
To reduce the number of back and


649
00:20:54,966 --> 00:20:56,116
forths when you fetch a


650
00:20:56,116 --> 00:20:56,696
resource.


651
00:20:57,626 --> 00:20:59,896
Let's see how your apps can do


652
00:21:01,836 --> 00:21:01,936
this.


653
00:21:02,136 --> 00:21:03,796
First, let's look at some issues


654
00:21:03,796 --> 00:21:05,446
with HTTP/1.1.


655
00:21:06,896 --> 00:21:07,846
Your app wants to fetch a


656
00:21:07,846 --> 00:21:10,486
resource, you can create a


657
00:21:10,486 --> 00:21:13,196
URLSession task and call resume.


658
00:21:14,146 --> 00:21:16,626
URLSession will create a new


659
00:21:16,626 --> 00:21:17,976
connection for you, which


660
00:21:17,976 --> 00:21:21,136
involves DNS, TCP and TLS.


661
00:21:22,626 --> 00:21:23,826
Once the connection to the


662
00:21:23,826 --> 00:21:25,606
server is established, we will


663
00:21:25,606 --> 00:21:26,656
send out your request.


664
00:21:27,256 --> 00:21:30,046
We will then wait to get a


665
00:21:30,046 --> 00:21:32,446
response from the server.


666
00:21:32,656 --> 00:21:34,176
This is the network idle time


667
00:21:34,356 --> 00:21:35,666
when your app is not doing any


668
00:21:35,666 --> 00:21:37,096
kind of networking, waiting to


669
00:21:37,096 --> 00:21:40,486
get a response from the server.


670
00:21:40,596 --> 00:21:42,616
Once we get a response, we will


671
00:21:42,616 --> 00:21:44,376
call your completion block or


672
00:21:44,376 --> 00:21:46,156
message your delegate indicating


673
00:21:46,156 --> 00:21:47,366
that the load has finished.


674
00:21:47,946 --> 00:21:50,446
Let's suppose in the middle of


675
00:21:50,446 --> 00:21:51,676
this load your app wants to


676
00:21:51,676 --> 00:21:53,086
fetch another resource from the


677
00:21:53,086 --> 00:21:53,756
same server.


678
00:21:54,376 --> 00:21:56,346
You can create another


679
00:21:56,406 --> 00:21:58,776
URLSession task called resume


680
00:21:59,346 --> 00:22:01,766
and URLSession will create a new


681
00:22:01,766 --> 00:22:03,126
connection to fetch this


682
00:22:03,126 --> 00:22:04,726
resource since it does not have


683
00:22:04,726 --> 00:22:06,006
an idle connection in its


684
00:22:06,006 --> 00:22:06,676
connection pool.


685
00:22:08,136 --> 00:22:09,336
If your app wants to fetch yet


686
00:22:09,336 --> 00:22:10,576
another resource from the same


687
00:22:10,576 --> 00:22:12,616
server, you can create another


688
00:22:12,616 --> 00:22:14,726
URLSession task and call resume


689
00:22:15,126 --> 00:22:16,196
and we will create another


690
00:22:16,196 --> 00:22:17,236
connection to fetch the


691
00:22:17,236 --> 00:22:17,856
resource.


692
00:22:18,376 --> 00:22:21,236
In this example, I've shown you


693
00:22:21,236 --> 00:22:22,616
that we've created three


694
00:22:22,616 --> 00:22:24,236
different connections to fetch


695
00:22:24,306 --> 00:22:25,866
these resources from the same


696
00:22:25,866 --> 00:22:26,356
server.


697
00:22:27,726 --> 00:22:29,246
If you notice, we've spent a lot


698
00:22:29,246 --> 00:22:31,076
of time opening new connections.


699
00:22:31,606 --> 00:22:33,466
Let's see how this would look


700
00:22:33,466 --> 00:22:34,926
like if you used a single


701
00:22:34,926 --> 00:22:35,716
connection instead.


702
00:22:38,416 --> 00:22:39,896
This is a single connection


703
00:22:39,896 --> 00:22:40,306
case.


704
00:22:41,006 --> 00:22:42,436
We saved a lot of time by not


705
00:22:42,436 --> 00:22:44,366
opening new connections, but


706
00:22:44,366 --> 00:22:45,456
there is another problem here.


707
00:22:46,636 --> 00:22:48,406
The request number two which is


708
00:22:48,406 --> 00:22:50,416
the green request has to wait


709
00:22:50,586 --> 00:22:52,316
until response number one is


710
00:22:52,316 --> 00:22:53,056
fully received.


711
00:22:54,216 --> 00:22:55,596
The same problem applies to


712
00:22:55,596 --> 00:22:57,196
request number three which is


713
00:22:57,196 --> 00:22:59,016
the orange request which has to


714
00:22:59,016 --> 00:23:01,116
wait until response number two


715
00:23:01,356 --> 00:23:02,286
is fully received.


716
00:23:03,436 --> 00:23:05,666
This problem is known as HTTP


717
00:23:05,666 --> 00:23:06,746
head-of-line blocking.


718
00:23:08,096 --> 00:23:10,406
Consider moving to HTTP/2.


719
00:23:11,676 --> 00:23:14,126
HTTP/2 uses a single connection,


720
00:23:14,496 --> 00:23:16,166
and it also solves the HTTP


721
00:23:16,166 --> 00:23:17,866
head-of-line blocking problem.


722
00:23:18,396 --> 00:23:21,956
HTTP/2 multiplexes multiple


723
00:23:21,956 --> 00:23:24,156
streams over a single connection


724
00:23:24,696 --> 00:23:26,756
allowing you to receive parallel


725
00:23:26,756 --> 00:23:28,576
responses in an [inaudible]


726
00:23:28,576 --> 00:23:29,136
fashion.


727
00:23:29,666 --> 00:23:32,456
Let's analyze this example a


728
00:23:32,456 --> 00:23:34,966
little more to see how HTTP/2


729
00:23:35,026 --> 00:23:37,166
performs better than HTTP/1.1.


730
00:23:39,456 --> 00:23:41,406
Pay attention to the times when


731
00:23:41,406 --> 00:23:42,656
your app wants to fetch a


732
00:23:42,656 --> 00:23:44,806
resource and the time when the


733
00:23:44,806 --> 00:23:45,966
request is sent out.


734
00:23:47,206 --> 00:23:50,156
In the HTTP/1.1 case, there is a


735
00:23:50,156 --> 00:23:52,306
significant delay between the


736
00:23:52,306 --> 00:23:53,676
time when your app desires a


737
00:23:53,676 --> 00:23:55,126
resource and the time the


738
00:23:55,126 --> 00:23:56,106
request is sent out.


739
00:23:57,336 --> 00:24:00,336
HTTP/2 can significantly reduce


740
00:24:00,336 --> 00:24:02,916
this delay and allows us to send


741
00:24:02,916 --> 00:24:04,636
the request almost immediately


742
00:24:04,636 --> 00:24:06,256
when the app desires the


743
00:24:06,256 --> 00:24:06,866
resource.


744
00:24:07,306 --> 00:24:11,976
Also pay attention to these gray


745
00:24:11,976 --> 00:24:12,576
boxes.


746
00:24:13,446 --> 00:24:14,946
If you recall, this is the


747
00:24:14,946 --> 00:24:17,016
network idle time when your app


748
00:24:17,016 --> 00:24:18,546
is not doing any networking,


749
00:24:18,836 --> 00:24:20,426
waiting to get a response from


750
00:24:20,506 --> 00:24:21,476
the server.


751
00:24:22,736 --> 00:24:25,606
HTTP/2 can significantly reduce


752
00:24:25,656 --> 00:24:27,876
this network idle time allowing


753
00:24:27,876 --> 00:24:29,376
you to better utilize the


754
00:24:29,376 --> 00:24:31,936
bandwidth and load the resources


755
00:24:31,936 --> 00:24:32,596
much faster.


756
00:24:35,476 --> 00:24:37,236
We just discussed many benefits


757
00:24:37,236 --> 00:24:40,186
of using HTTP/2 over HTTP/1.1,


758
00:24:40,636 --> 00:24:41,726
but let's quickly summarize


759
00:24:41,726 --> 00:24:41,926
them.


760
00:24:43,166 --> 00:24:45,086
HTTP/2 solves the head-of-line


761
00:24:45,086 --> 00:24:46,456
blocking problem at the HTTP


762
00:24:46,456 --> 00:24:47,146
layer.


763
00:24:47,476 --> 00:24:49,696
And it also allows you to better


764
00:24:49,696 --> 00:24:50,686
utilize the bandwidth.


765
00:24:52,286 --> 00:24:54,786
If your apps use URLSession, you


766
00:24:54,786 --> 00:24:55,826
don't need to make any


767
00:24:55,826 --> 00:24:57,016
client-side changes.


768
00:24:57,926 --> 00:25:00,556
Simply enable HTTP/2 on your


769
00:25:00,556 --> 00:25:01,646
servers and you will see these


770
00:25:01,646 --> 00:25:02,246
benefits.


771
00:25:03,736 --> 00:25:06,246
By adopting HTTP/2, you can also


772
00:25:06,246 --> 00:25:07,996
get some server-side savings


773
00:25:08,466 --> 00:25:10,296
because devices running your


774
00:25:10,296 --> 00:25:12,026
apps will now make fewer


775
00:25:12,026 --> 00:25:15,066
connections to the servers.


776
00:25:15,166 --> 00:25:17,286
This year, we have something new


777
00:25:17,386 --> 00:25:19,346
in URLSession that is going to


778
00:25:19,346 --> 00:25:23,946
add to the advantages of HTTP/2.


779
00:25:24,196 --> 00:25:26,496
Introducing HTTP/2 Connection


780
00:25:26,496 --> 00:25:28,106
Coalescing for URLSession.


781
00:25:28,586 --> 00:25:32,376
HTTP/2 Connection Coalescing is


782
00:25:32,376 --> 00:25:33,846
going to increase connection to


783
00:25:33,846 --> 00:25:35,036
use even more.


784
00:25:36,556 --> 00:25:39,226
Since your apps are not going to


785
00:25:39,226 --> 00:25:40,886
be opening new connections, they


786
00:25:40,886 --> 00:25:43,656
will become more responsive to


787
00:25:43,656 --> 00:25:44,276
your users.


788
00:25:45,636 --> 00:25:46,906
Starting with the [inaudible],


789
00:25:46,906 --> 00:25:50,866
HTTP/2 Connection Coalescing is


790
00:25:50,866 --> 00:25:52,246
going to be automatically done


791
00:25:52,246 --> 00:25:54,186
on for all your apps using


792
00:25:54,186 --> 00:25:55,026
URLSession.


793
00:25:56,296 --> 00:25:57,976
Now let's see how Connection


794
00:25:57,976 --> 00:25:59,676
Coalescing decides to reuse


795
00:25:59,676 --> 00:26:00,356
connections.


796
00:26:00,886 --> 00:26:05,516
Let's suppose you have an app


797
00:26:05,516 --> 00:26:06,806
and that app wants to fetch a


798
00:26:06,806 --> 00:26:09,586
resource from menu.example.com.


799
00:26:10,746 --> 00:26:12,526
We open a connection with the


800
00:26:12,606 --> 00:26:13,836
server, and the server presents


801
00:26:13,836 --> 00:26:14,806
us with the certificate.


802
00:26:16,076 --> 00:26:17,126
If your app wants to fetch


803
00:26:17,126 --> 00:26:18,206
another resource from


804
00:26:18,446 --> 00:26:21,026
delivery.example.com, we open


805
00:26:21,026 --> 00:26:22,486
another connection and the


806
00:26:22,486 --> 00:26:23,556
server presents us with another


807
00:26:23,556 --> 00:26:24,066
certificate.


808
00:26:25,436 --> 00:26:27,526
This is the old behavior where


809
00:26:27,646 --> 00:26:29,556
URLSession would create two


810
00:26:29,556 --> 00:26:31,366
connections to fetch these


811
00:26:31,366 --> 00:26:32,896
resources from the given host


812
00:26:32,896 --> 00:26:33,236
names.


813
00:26:33,726 --> 00:26:36,836
But if you look closely, the


814
00:26:36,936 --> 00:26:39,016
first certificate presented to


815
00:26:39,016 --> 00:26:41,596
us covers all the subdomains


816
00:26:41,796 --> 00:26:44,606
under example.com which means


817
00:26:44,946 --> 00:26:48,536
delivery.example.com is covered


818
00:26:48,566 --> 00:26:50,316
by this first certificate.


819
00:26:50,356 --> 00:26:51,506
Also notice that


820
00:26:51,716 --> 00:26:54,146
delivery.example.com, it results


821
00:26:54,146 --> 00:26:55,906
to the same IP address as the


822
00:26:55,906 --> 00:26:56,886
first connection.


823
00:26:57,426 --> 00:27:00,406
At this point, it's safe for us


824
00:27:00,406 --> 00:27:01,486
to assume we're talking to the


825
00:27:01,486 --> 00:27:03,796
same endpoint and reuse the


826
00:27:03,796 --> 00:27:05,726
connection instead of opening a


827
00:27:05,726 --> 00:27:07,346
new one when we want to fetch


828
00:27:07,346 --> 00:27:08,406
the second resource.


829
00:27:09,126 --> 00:27:10,506
This saves us time by not


830
00:27:10,506 --> 00:27:11,936
opening a new connection and


831
00:27:11,936 --> 00:27:13,316
makes the load much faster.


832
00:27:13,896 --> 00:27:16,086
HTTP/2 [inaudible] HTTP/2


833
00:27:16,086 --> 00:27:20,276
Connection Coalescing new in iOS


834
00:27:20,306 --> 00:27:22,156
12 and macOS Mojave.


835
00:27:23,416 --> 00:27:26,296
Now let's see how using fewer


836
00:27:26,386 --> 00:27:28,716
URLSession objects can help


837
00:27:28,716 --> 00:27:29,826
reduce latency.


838
00:27:30,356 --> 00:27:34,656
All the benefits of connections


839
00:27:34,656 --> 00:27:36,876
we use that we just discussed in


840
00:27:36,876 --> 00:27:38,876
the previous slides are


841
00:27:38,876 --> 00:27:41,306
applicable only if you use the


842
00:27:41,306 --> 00:27:43,546
same URLSession object to create


843
00:27:43,546 --> 00:27:44,916
your tasks.


844
00:27:47,016 --> 00:27:48,876
It's also important to know that


845
00:27:48,936 --> 00:27:51,586
every URLSession object has a


846
00:27:51,586 --> 00:27:53,206
connection pool and when you


847
00:27:53,206 --> 00:27:54,506
create multiple of these


848
00:27:54,506 --> 00:27:56,106
URLSession objects, you don't


849
00:27:56,106 --> 00:27:57,606
get any benefit of connection to


850
00:27:57,606 --> 00:27:58,026
use.


851
00:27:59,066 --> 00:28:01,306
It's also important to note that


852
00:28:01,356 --> 00:28:02,726
the URLSession objects are


853
00:28:02,726 --> 00:28:04,846
fairly expensive to create and


854
00:28:04,846 --> 00:28:06,206
have a non-trivial memory


855
00:28:06,206 --> 00:28:06,676
footprint.


856
00:28:08,036 --> 00:28:09,776
As we have in the past, we


857
00:28:09,816 --> 00:28:11,726
continue to advise you to use


858
00:28:11,726 --> 00:28:13,466
fewer URLSession objects.


859
00:28:13,986 --> 00:28:17,496
Let's move on to our next topic


860
00:28:17,496 --> 00:28:19,416
for the day: maximizing


861
00:28:19,416 --> 00:28:19,796
throughput.


862
00:28:19,796 --> 00:28:22,596
Coming back to our restaurant


863
00:28:22,596 --> 00:28:23,156
example.


864
00:28:23,986 --> 00:28:25,956
The waiter checks up on you and


865
00:28:25,956 --> 00:28:27,766
you say, "Can I get an order of


866
00:28:28,196 --> 00:28:30,206
grilled chicken tossed in creamy


867
00:28:30,206 --> 00:28:32,006
tomato onion gravy made with a


868
00:28:32,006 --> 00:28:32,646
lot of butter?"


869
00:28:33,906 --> 00:28:34,846
Now that's a mouthful.


870
00:28:35,656 --> 00:28:36,596
Wouldn't it be easier if you


871
00:28:36,596 --> 00:28:38,016
just said, "Can I get butter


872
00:28:38,016 --> 00:28:38,356
chicken?"


873
00:28:39,936 --> 00:28:41,556
The idea to maximize throughput


874
00:28:41,556 --> 00:28:43,216
is the same where you reduce the


875
00:28:43,216 --> 00:28:44,296
number of bytes that you


876
00:28:44,296 --> 00:28:45,766
transmit when you want to fetch


877
00:28:45,816 --> 00:28:46,536
a resource.


878
00:28:47,306 --> 00:28:48,686
Let's see how your apps can do


879
00:28:48,686 --> 00:28:49,036
this.


880
00:28:49,116 --> 00:28:52,796
Let's look at a couple of ways


881
00:28:52,796 --> 00:28:55,086
to reduce the request size.


882
00:28:55,956 --> 00:28:58,246
Pay attention to HTTP cookies.


883
00:28:59,076 --> 00:29:01,646
They are not free and have a


884
00:29:01,646 --> 00:29:03,216
non-trivial cost in storing and


885
00:29:03,216 --> 00:29:03,846
looking them up.


886
00:29:05,256 --> 00:29:06,836
Cookies are attached to all the


887
00:29:06,836 --> 00:29:08,676
requests that match the domain


888
00:29:08,676 --> 00:29:09,946
and path attribute.


889
00:29:10,506 --> 00:29:11,856
And it can quickly increase your


890
00:29:11,856 --> 00:29:12,636
request size.


891
00:29:13,996 --> 00:29:15,946
Please use the domain and path


892
00:29:15,946 --> 00:29:17,966
attribute wisely to make sure


893
00:29:17,966 --> 00:29:19,826
cookies required by the servers


894
00:29:19,896 --> 00:29:21,306
are attached to your requests.


895
00:29:22,526 --> 00:29:23,756
Use of smaller cookies when


896
00:29:23,756 --> 00:29:25,336
possible, and delete these


897
00:29:25,336 --> 00:29:26,606
cookies when you no longer need


898
00:29:26,606 --> 00:29:26,846
them.


899
00:29:28,226 --> 00:29:29,896
Try to save some state on the


900
00:29:29,896 --> 00:29:31,686
server so you can reduce the


901
00:29:31,686 --> 00:29:33,246
number of client-side cookies.


902
00:29:33,716 --> 00:29:36,856
Also consider moving to HTTP/2


903
00:29:37,326 --> 00:29:38,766
to get benefits of header


904
00:29:38,766 --> 00:29:39,356
compression.


905
00:29:39,906 --> 00:29:42,476
Let's talk a little more about


906
00:29:42,476 --> 00:29:43,176
compression.


907
00:29:43,706 --> 00:29:48,646
HTTP compression, also known as


908
00:29:48,646 --> 00:29:51,126
content and coding, is simply


909
00:29:51,176 --> 00:29:53,026
compressing the data that is


910
00:29:53,026 --> 00:29:54,616
shuttled between the client and


911
00:29:54,726 --> 00:29:56,096
the server.


912
00:29:56,096 --> 00:29:57,666
This allows us to better utilize


913
00:29:57,696 --> 00:29:58,276
the bandwidth.


914
00:29:59,706 --> 00:30:02,046
The algorithms that URLSession


915
00:30:02,246 --> 00:30:05,196
supports and recommends are Gzip


916
00:30:05,196 --> 00:30:05,796
and Brotli.


917
00:30:07,226 --> 00:30:09,756
Gzip is widely supported and is


918
00:30:09,756 --> 00:30:10,706
relatively fast.


919
00:30:11,906 --> 00:30:13,616
Brotli support was introduced


920
00:30:13,616 --> 00:30:16,686
last year in iOS 11 and macOS


921
00:30:16,686 --> 00:30:17,356
High Sierra.


922
00:30:18,626 --> 00:30:20,076
Brotli is optimized for


923
00:30:20,076 --> 00:30:22,136
structured text and HTML.


924
00:30:22,136 --> 00:30:24,356
And it has the best compression


925
00:30:24,356 --> 00:30:26,726
ratio on short data.


926
00:30:27,416 --> 00:30:29,196
Please enable compression on


927
00:30:29,196 --> 00:30:30,726
your servers if you haven't done


928
00:30:30,726 --> 00:30:31,476
so already.


929
00:30:32,016 --> 00:30:34,986
Let's move on to our next topic


930
00:30:34,986 --> 00:30:37,096
for the day: increasing


931
00:30:37,096 --> 00:30:37,926
responsiveness.


932
00:30:39,146 --> 00:30:40,566
Coming back to our restaurant


933
00:30:40,566 --> 00:30:40,926
example.


934
00:30:40,926 --> 00:30:42,906
Here you are here in San Jose


935
00:30:42,906 --> 00:30:44,656
for WWDC, and you decide to meet


936
00:30:44,656 --> 00:30:45,986
up with some old friends.


937
00:30:46,116 --> 00:30:48,086
You and your friends are sitting


938
00:30:48,086 --> 00:30:49,056
at the restaurant table.


939
00:30:49,636 --> 00:30:51,456
Your drinks are here, but you


940
00:30:51,456 --> 00:30:52,746
would like some more time to


941
00:30:52,746 --> 00:30:53,866
catch up with your friends


942
00:30:53,966 --> 00:30:55,216
before the food comes out.


943
00:30:56,216 --> 00:30:57,346
You can simply tell the waiter,


944
00:30:58,076 --> 00:30:58,956
"Can you please bring out our


945
00:30:58,956 --> 00:30:59,926
food after some time?


946
00:30:59,926 --> 00:31:01,216
We are in no rush."


947
00:31:02,226 --> 00:31:03,646
The same concept can be applied


948
00:31:03,646 --> 00:31:05,366
to responsiveness where you mark


949
00:31:05,366 --> 00:31:06,866
your tasks with priority


950
00:31:07,096 --> 00:31:08,456
depending on the other tasks


951
00:31:08,506 --> 00:31:09,166
that you're doing.


952
00:31:10,106 --> 00:31:11,306
Let's see how your apps can


953
00:31:11,306 --> 00:31:12,186
benefit from this.


954
00:31:12,566 --> 00:31:16,936
You might be familiar with these


955
00:31:16,936 --> 00:31:19,756
five QoS classes associated with


956
00:31:19,756 --> 00:31:22,026
dispatch queues and NSOperation


957
00:31:22,026 --> 00:31:22,666
objects.


958
00:31:23,616 --> 00:31:24,976
Data [inaudible] the CPU


959
00:31:24,976 --> 00:31:26,096
scheduling policy.


960
00:31:27,656 --> 00:31:31,156
URLSession is QoS-aware which


961
00:31:31,156 --> 00:31:33,356
means it will capture the QoS


962
00:31:33,426 --> 00:31:35,176
off the queue on which you call


963
00:31:35,176 --> 00:31:36,146
task.resume.


964
00:31:37,156 --> 00:31:38,646
And all the messages that it


965
00:31:38,646 --> 00:31:40,296
sends to your delegates will


966
00:31:40,296 --> 00:31:41,086
respect this QoS.


967
00:31:41,086 --> 00:31:44,196
Let's take an example.


968
00:31:45,246 --> 00:31:46,986
If your app wants to fetch some


969
00:31:46,986 --> 00:31:48,786
data which is not time critical,


970
00:31:49,406 --> 00:31:51,476
consider resuming that task on a


971
00:31:51,476 --> 00:31:53,356
queue which has background QoS


972
00:31:54,026 --> 00:31:56,056
to make sure this task does not


973
00:31:56,056 --> 00:31:58,066
contend for CPU with other


974
00:31:58,066 --> 00:31:59,436
higher priority work that your


975
00:31:59,436 --> 00:32:04,016
app might be doing.


976
00:32:04,186 --> 00:32:06,086
Network service type is the


977
00:32:06,086 --> 00:32:08,156
property on the URLSession


978
00:32:08,226 --> 00:32:10,946
configuration object that allows


979
00:32:10,946 --> 00:32:12,916
you to classify your network


980
00:32:12,916 --> 00:32:15,596
traffic that helps the system


981
00:32:15,596 --> 00:32:17,376
prioritize the data leaving the


982
00:32:17,376 --> 00:32:17,926
device.


983
00:32:19,276 --> 00:32:21,236
This year, we have a new network


984
00:32:21,236 --> 00:32:22,276
service type, the


985
00:32:22,276 --> 00:32:23,346
responsiveData.


986
00:32:24,656 --> 00:32:26,676
ResponsiveData is slightly


987
00:32:26,676 --> 00:32:28,596
higher than the default type but


988
00:32:28,596 --> 00:32:30,416
should be used judiciously.


989
00:32:31,446 --> 00:32:32,906
An example where you might want


990
00:32:32,906 --> 00:32:35,606
to use responsiveData is if you


991
00:32:35,606 --> 00:32:37,856
have a shopping app and you are


992
00:32:37,856 --> 00:32:38,786
on the checkout page.


993
00:32:39,586 --> 00:32:40,816
You might want to mark your


994
00:32:40,886 --> 00:32:42,346
payment request with the


995
00:32:42,346 --> 00:32:44,376
responsiveData to make sure you


996
00:32:44,376 --> 00:32:45,986
get a good response from the


997
00:32:46,496 --> 00:32:46,636
server.


998
00:32:48,096 --> 00:32:49,766
Traffic marked with the network


999
00:32:49,766 --> 00:32:51,676
service type property will


1000
00:32:51,676 --> 00:32:53,986
maintain this tag across all the


1001
00:32:53,986 --> 00:32:56,386
hops when on a Cisco Fast Lane


1002
00:32:56,386 --> 00:32:56,886
network.


1003
00:32:58,026 --> 00:32:59,516
For more information on this


1004
00:32:59,516 --> 00:33:02,226
API, please view the WWDC


1005
00:33:02,226 --> 00:33:08,086
session from the year 2016.


1006
00:33:08,086 --> 00:33:09,736
Last year, we introduced the


1007
00:33:09,736 --> 00:33:11,556
URLSession Adaptable


1008
00:33:11,556 --> 00:33:12,896
Connectivity API


1009
00:33:13,376 --> 00:33:14,596
waitsForConnectivity.


1010
00:33:15,976 --> 00:33:18,106
waitsForConnectivity will simply


1011
00:33:18,106 --> 00:33:20,736
wait instead of failing the load


1012
00:33:21,176 --> 00:33:22,616
when your task does not have


1013
00:33:22,666 --> 00:33:23,246
connectivity.


1014
00:33:24,606 --> 00:33:26,006
In the past, you've been using


1015
00:33:26,006 --> 00:33:28,016
STNeworkReachability to do a


1016
00:33:28,016 --> 00:33:29,726
preflight check before you send


1017
00:33:29,726 --> 00:33:30,426
out your request.


1018
00:33:31,126 --> 00:33:32,486
But as Stuart pointed out a few


1019
00:33:32,486 --> 00:33:34,296
slides ago, there is a race


1020
00:33:34,296 --> 00:33:36,026
condition where the system might


1021
00:33:36,026 --> 00:33:37,046
tell you that you have


1022
00:33:37,046 --> 00:33:39,186
connectivity to a server but by


1023
00:33:39,186 --> 00:33:40,406
the time you create and send


1024
00:33:40,406 --> 00:33:41,946
your request, you've lost your


1025
00:33:41,946 --> 00:33:43,336
chance and you're no longer


1026
00:33:43,336 --> 00:33:45,826
connected to the server.


1027
00:33:45,826 --> 00:33:46,776
We recommend using


1028
00:33:46,776 --> 00:33:48,406
waitsForConnectivity which will


1029
00:33:48,406 --> 00:33:50,316
simply send out your request as


1030
00:33:50,316 --> 00:33:51,436
soon as a connection to the


1031
00:33:51,436 --> 00:33:52,496
server is available.


1032
00:33:53,946 --> 00:33:55,816
Optionally, you can implement


1033
00:33:56,036 --> 00:33:58,066
the taskIsWaitigForConnectivity


1034
00:33:58,066 --> 00:33:59,786
delegate method which gets


1035
00:33:59,786 --> 00:34:01,116
called when your task does not


1036
00:34:01,116 --> 00:34:01,896
have connectivity.


1037
00:34:03,286 --> 00:34:04,876
This can be helpful to present


1038
00:34:04,876 --> 00:34:06,426
the user with a different flow


1039
00:34:06,686 --> 00:34:09,016
or an offline UI for better user


1040
00:34:09,016 --> 00:34:09,766
experience.


1041
00:34:11,376 --> 00:34:13,085
For more information on this


1042
00:34:13,085 --> 00:34:15,396
API, please view the WWDC


1043
00:34:15,396 --> 00:34:16,576
session from last year where


1044
00:34:16,766 --> 00:34:18,246
this API was introduced.


1045
00:34:18,246 --> 00:34:21,716
Now let's move on to our last


1046
00:34:21,716 --> 00:34:23,676
topic for the day: making better


1047
00:34:23,676 --> 00:34:25,496
use of system resources.


1048
00:34:26,606 --> 00:34:27,596
Coming back to our restaurant


1049
00:34:27,596 --> 00:34:28,045
example.


1050
00:34:28,496 --> 00:34:30,896
You like the food at this place


1051
00:34:31,036 --> 00:34:32,505
so much that you decide to come


1052
00:34:32,505 --> 00:34:33,755
here for dinner the next day.


1053
00:34:35,025 --> 00:34:36,366
The restaurant has a delivery


1054
00:34:36,366 --> 00:34:38,255
service where you can place your


1055
00:34:38,255 --> 00:34:40,166
order today and they will


1056
00:34:40,166 --> 00:34:41,275
deliver the food to your house


1057
00:34:41,275 --> 00:34:41,896
the next day.


1058
00:34:42,735 --> 00:34:44,616
This not only saves you the time


1059
00:34:44,616 --> 00:34:46,376
and effort to go and pick up


1060
00:34:46,376 --> 00:34:48,366
your food but it also helps the


1061
00:34:48,366 --> 00:34:50,056
restaurant prioritize their work


1062
00:34:50,226 --> 00:34:51,295
based on your deadline.


1063
00:34:52,496 --> 00:34:54,366
Let's see how your apps can make


1064
00:34:54,366 --> 00:34:56,266
better use of system resources


1065
00:34:56,266 --> 00:34:57,326
to be more efficient.


1066
00:35:00,056 --> 00:35:02,206
Background sessions have upload


1067
00:35:02,206 --> 00:35:03,456
and download tasks.


1068
00:35:04,456 --> 00:35:06,156
These tasks use system


1069
00:35:06,156 --> 00:35:08,046
intelligence to decide when to


1070
00:35:08,046 --> 00:35:09,876
start and when to stop a


1071
00:35:09,876 --> 00:35:11,926
download based on various


1072
00:35:11,926 --> 00:35:14,486
factors like battery, CPU,


1073
00:35:14,716 --> 00:35:15,726
Wi-Fi, etcetera.


1074
00:35:17,616 --> 00:35:19,276
If your app wants to fetch a


1075
00:35:19,276 --> 00:35:21,416
large file, consider using


1076
00:35:21,416 --> 00:35:22,346
background sessions.


1077
00:35:23,736 --> 00:35:26,036
These tasks run out of process


1078
00:35:26,836 --> 00:35:28,276
which means your download will


1079
00:35:28,276 --> 00:35:30,676
continue even when your app is


1080
00:35:30,676 --> 00:35:31,766
in a suspended state.


1081
00:35:33,036 --> 00:35:34,476
For more information on


1082
00:35:34,476 --> 00:35:36,246
background sessions, please view


1083
00:35:36,246 --> 00:35:38,096
the WWDC session from the year


1084
00:35:38,156 --> 00:35:42,676
2014.


1085
00:35:42,796 --> 00:35:44,216
Caching is a great way of


1086
00:35:44,276 --> 00:35:46,576
reducing latency but it's


1087
00:35:46,576 --> 00:35:48,526
important to note that caching


1088
00:35:48,526 --> 00:35:50,076
might result in disk IO.


1089
00:35:51,366 --> 00:35:52,816
In the real world, we've seen


1090
00:35:52,816 --> 00:35:54,596
some apps write several


1091
00:35:54,596 --> 00:35:56,746
gigabytes of data to disk each


1092
00:35:56,746 --> 00:35:58,656
day which can cause severe flash


1093
00:35:58,656 --> 00:35:59,706
storage degradation.


1094
00:36:01,076 --> 00:36:02,286
Please don't cache unique


1095
00:36:02,286 --> 00:36:02,746
content.


1096
00:36:04,196 --> 00:36:05,166
Let's take an example.


1097
00:36:06,096 --> 00:36:08,246
Let's suppose you have an app, a


1098
00:36:08,246 --> 00:36:09,856
dating app, and you are


1099
00:36:09,856 --> 00:36:11,076
responsible for the networking


1100
00:36:11,076 --> 00:36:13,086
code of the app.


1101
00:36:13,086 --> 00:36:15,136
This app loads user profiles


1102
00:36:15,486 --> 00:36:17,356
with high-resolution images.


1103
00:36:18,516 --> 00:36:20,206
It might be wasteful to cache


1104
00:36:20,206 --> 00:36:21,826
these high-resolution images


1105
00:36:22,346 --> 00:36:23,636
because the user might swipe


1106
00:36:23,666 --> 00:36:25,286
left, move on to the next


1107
00:36:25,286 --> 00:36:27,236
profile, which means that the


1108
00:36:27,236 --> 00:36:28,786
images that you just cached are


1109
00:36:28,846 --> 00:36:30,026
probably not going to be


1110
00:36:30,026 --> 00:36:30,756
requested again.


1111
00:36:32,076 --> 00:36:33,446
Please consider making


1112
00:36:33,476 --> 00:36:35,396
client-side changes by adopting


1113
00:36:35,396 --> 00:36:37,296
the willChacheResponse delegate


1114
00:36:37,296 --> 00:36:39,596
method to decide what resources


1115
00:36:39,596 --> 00:36:40,396
should be cached.


1116
00:36:41,886 --> 00:36:43,896
If you own the servers, please


1117
00:36:43,896 --> 00:36:45,436
consider using cache control


1118
00:36:45,436 --> 00:36:48,016
headers to decide what resources


1119
00:36:48,016 --> 00:36:48,826
should be cacheable.


1120
00:36:49,346 --> 00:36:53,006
Let's quickly go over some of


1121
00:36:53,006 --> 00:36:54,246
the key points that we discussed


1122
00:36:54,246 --> 00:36:54,506
today.


1123
00:36:55,346 --> 00:36:57,286
Number one, order all your food


1124
00:36:57,286 --> 00:36:58,316
at the same time when you go to


1125
00:36:58,316 --> 00:36:58,836
a restaurant.


1126
00:36:59,166 --> 00:37:00,766
I'm just kidding.


1127
00:37:01,666 --> 00:37:03,976
Move to HTTP/2 today to get wins


1128
00:37:03,976 --> 00:37:05,326
like header compression,


1129
00:37:05,546 --> 00:37:07,116
connection coalescing and no


1130
00:37:07,116 --> 00:37:07,986
head-of-line blocking.


1131
00:37:08,506 --> 00:37:12,596
Use fewer URLSession objects to


1132
00:37:12,596 --> 00:37:14,346
reduce latency by reusing


1133
00:37:14,346 --> 00:37:15,076
connections.


1134
00:37:15,826 --> 00:37:17,816
This also reduces the memory


1135
00:37:17,816 --> 00:37:19,666
footprint so it's better use of


1136
00:37:19,666 --> 00:37:20,726
system resources.


1137
00:37:21,176 --> 00:37:23,936
Reduce the request size to


1138
00:37:24,236 --> 00:37:25,456
maximize throughput.


1139
00:37:27,316 --> 00:37:29,736
Pay attention to QoS to increase


1140
00:37:29,736 --> 00:37:31,386
the responsiveness of your apps.


1141
00:37:32,216 --> 00:37:34,146
And finally use background


1142
00:37:34,146 --> 00:37:35,896
sessions when you can to make


1143
00:37:35,896 --> 00:37:37,856
better use of system resources.


1144
00:37:39,536 --> 00:37:40,936
For more information on this


1145
00:37:40,936 --> 00:37:42,296
session, please visit this


1146
00:37:42,296 --> 00:37:42,726
website.


1147
00:37:43,766 --> 00:37:45,006
Now we'll have a short break.


1148
00:37:45,696 --> 00:37:46,796
And after the break, we'll


1149
00:37:46,796 --> 00:37:47,856
introduce you to network


1150
00:37:47,856 --> 00:37:49,856
framework, a modern alternative


1151
00:37:49,856 --> 00:37:50,556
to Sockets.


1152
00:37:51,246 --> 00:37:52,596
I would love to see you all at


1153
00:37:52,596 --> 00:37:54,426
the networking labs which are


1154
00:37:54,426 --> 00:37:55,366
going to be held today and


1155
00:37:55,366 --> 00:37:55,856
tomorrow.


1156
00:37:57,236 --> 00:37:58,546
Thank you all for being here.


1157
00:37:58,546 --> 00:38:00,326
And I hope everyone has a great


1158
00:38:00,326 --> 00:38:01,306
rest of the conference.


1159
00:38:02,508 --> 00:38:04,508
[ Applause ]

