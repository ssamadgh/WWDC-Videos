1
00:00:23,516 --> 00:00:28,136
[Applause]


2
00:00:28,636 --> 00:00:29,066
>> DAVE ADDEY: Hello.


3
00:00:29,066 --> 00:00:31,866
Welcome to Deeper into
GameplayKit with DemoBots.


4
00:00:32,906 --> 00:00:36,166
We created a new game sample
this year called DemoBots.


5
00:00:36,896 --> 00:00:38,336
If you would like to
play along at home,


6
00:00:38,596 --> 00:00:39,876
you can download
the sample today


7
00:00:40,186 --> 00:00:42,766
from
developer.apple.com/spritekit.


8
00:00:44,046 --> 00:00:46,526
This game takes advantage of
lots of the things you learned


9
00:00:46,526 --> 00:00:48,826
about in the What's New
in SpriteKit session


10
00:00:49,166 --> 00:00:50,406
and Introducing GameplayKit.


11
00:00:50,486 --> 00:00:53,216
Check it out if you couldn't.


12
00:00:53,216 --> 00:00:57,506
We couldn't make a
game called DemoBots


13
00:00:58,276 --> 00:01:00,086
without giving you a demo.


14
00:01:00,336 --> 00:01:02,036
Let's take a look and
see how the game plays.


15
00:01:07,956 --> 00:01:12,846
We start a new game, you're
PlayerBot, this guy here.


16
00:01:13,586 --> 00:01:17,226
Your job is to find and
fix all of the bad TaskBots


17
00:01:17,406 --> 00:01:19,176
on each level before
the clock runs out.


18
00:01:20,036 --> 00:01:22,476
Here we have two good TaskBots,
you can tell they're good,


19
00:01:22,476 --> 00:01:23,476
because they've got green faces.


20
00:01:24,576 --> 00:01:27,256
If I run around the corner here,
we find the first bad TaskBot.


21
00:01:27,526 --> 00:01:29,716
He's a GroundBot in this case.


22
00:01:29,716 --> 00:01:32,326
When he spots me, he will
charge toward me and attack me.


23
00:01:33,266 --> 00:01:33,956
I lose some charge.


24
00:01:34,796 --> 00:01:35,246
That's okay.


25
00:01:35,286 --> 00:01:37,106
I have a beam to zap him with.


26
00:01:37,106 --> 00:01:41,216
After I zapped him for a few
seconds he's fixed and green.


27
00:01:41,446 --> 00:01:42,086
Let's see where he's going.


28
00:01:44,106 --> 00:01:46,156
Here we have another
bad TaskBots,


29
00:01:46,236 --> 00:01:48,166
I have to fix him as well.


30
00:01:49,726 --> 00:01:51,146
There are two more on
this level that I need


31
00:01:51,146 --> 00:01:52,796
to fix before the
timer runs out.


32
00:01:53,376 --> 00:01:55,326
Unfortunately they
have a tendency


33
00:01:55,326 --> 00:01:56,516
to attack one another as well.


34
00:01:57,196 --> 00:01:58,986
They can turn each other bad.


35
00:01:59,736 --> 00:02:01,406
That's what happened there.


36
00:02:02,596 --> 00:02:09,936
Once all of them are fixed
the level is complete.


37
00:02:10,515 --> 00:02:13,356
[Applause]


38
00:02:13,856 --> 00:02:14,776
There's a level 2.


39
00:02:17,266 --> 00:02:20,096
Level 2 introduces a new
character, FlyingBot,


40
00:02:20,536 --> 00:02:23,096
here is a FlyingBot on the side
hanging out, doing his thing.


41
00:02:23,836 --> 00:02:25,426
If you find a bad FlyingBot,


42
00:02:25,486 --> 00:02:29,846
they have a different
attack.When we bump into him,


43
00:02:30,206 --> 00:02:32,316
he does a blast attack
affecting everybody


44
00:02:32,316 --> 00:02:33,236
within a certain radius.


45
00:02:34,306 --> 00:02:37,496
The good news, if you fix
one, they do a good attack


46
00:02:37,496 --> 00:02:40,096
that will cure any other
FlyingBot within range.


47
00:02:40,856 --> 00:02:41,806
Follow him over here.


48
00:02:43,096 --> 00:02:47,856
He's almost certainly going
to bump into another bad one.


49
00:02:47,856 --> 00:02:48,426
He avoided him.


50
00:02:48,556 --> 00:02:50,146
Good. I can cure
this one as well.


51
00:02:50,846 --> 00:02:53,676
He's almost certainly going to
do a really, really silly thing,


52
00:02:54,116 --> 00:02:56,366
to go all the way around
here to a great big nest


53
00:02:56,466 --> 00:02:57,506
of the things around the corner.


54
00:02:58,386 --> 00:02:59,476
This is almost a certainty.


55
00:03:01,916 --> 00:03:04,406
We can use his benevolent
blast after he's been made bad,


56
00:03:04,816 --> 00:03:14,376
he can cure one, two,
all of them in one go.


57
00:03:14,376 --> 00:03:17,986
[Laughter] One more to go.


58
00:03:18,446 --> 00:03:22,756
Oh no! [Laughter] This
is not going well.


59
00:03:25,136 --> 00:03:25,886
[Laughter] One more.


60
00:03:27,846 --> 00:03:28,596
Then the level is complete.


61
00:03:29,516 --> 00:03:34,906
[Applause]


62
00:03:35,406 --> 00:03:36,286
So that's DemoBots.


63
00:03:36,746 --> 00:03:39,056
I would like to take
a look at tools


64
00:03:39,056 --> 00:03:43,326
and technologies we have used
to make this game a reality.


65
00:03:43,326 --> 00:03:45,626
You saw our TaskBots had lots


66
00:03:45,626 --> 00:03:47,246
of animation states
they went through.


67
00:03:47,246 --> 00:03:52,756
A thing we tried to do is keep
the textures, images we needed


68
00:03:52,756 --> 00:03:55,516
for those to a minimum to
keep the app size realistic.


69
00:03:55,516 --> 00:03:59,886
We decided to keep the new
action editor in SpriteKit


70
00:04:00,276 --> 00:04:01,136
to create the actions as --


71
00:04:01,136 --> 00:04:03,056
animations as actions
rather than textures.


72
00:04:03,726 --> 00:04:07,086
The zap animation you
see, the zap beam,


73
00:04:07,746 --> 00:04:10,606
that's a reference action
we have made and applied


74
00:04:10,646 --> 00:04:12,036
to both the GroundBot
and FlyingBot.


75
00:04:12,496 --> 00:04:15,426
If we click into that action
we can see it is made of lots


76
00:04:15,426 --> 00:04:17,495
of small move actions
one after another.


77
00:04:19,296 --> 00:04:22,826
Because it is a reference
action we can create it once


78
00:04:23,086 --> 00:04:26,156
and apply it to all
TaskBots we have regardless


79
00:04:26,156 --> 00:04:27,266
of the orientation.


80
00:04:28,406 --> 00:04:31,796
Because it is a reference
action, we can create it once


81
00:04:32,166 --> 00:04:34,666
and then go and change
it, the source,


82
00:04:34,836 --> 00:04:36,836
seeing that change going
everywhere, we don't have


83
00:04:36,836 --> 00:04:38,706
to change it in multiple places.


84
00:04:40,826 --> 00:04:43,946
We use the action editor to
create the beam animation.


85
00:04:44,476 --> 00:04:47,556
It is only fired for so many
seconds, we want that beam


86
00:04:47,636 --> 00:04:51,306
to decay over time and we
create that actions editor too


87
00:04:51,306 --> 00:04:56,066
so that we can see it visually
and use it in the game.


88
00:04:56,066 --> 00:04:58,276
All of the assets in the
game have been created


89
00:04:58,276 --> 00:05:00,056
in asset catalogs and out


90
00:05:00,056 --> 00:05:03,136
of Xcode 7 these asset
catalogs are converted


91
00:05:03,136 --> 00:05:04,616
to texture atlases for us.


92
00:05:05,336 --> 00:05:07,906
That means that we get the
best possible draw performance


93
00:05:07,906 --> 00:05:09,876
when used in a game.


94
00:05:09,876 --> 00:05:11,086
We have a lot of these images.


95
00:05:11,426 --> 00:05:14,456
It also gives us a way to
specify the right images to use


96
00:05:14,806 --> 00:05:15,696
for different devices.


97
00:05:16,926 --> 00:05:18,456
This helps us to
optimize the size further.


98
00:05:19,886 --> 00:05:22,596
When we were designing our
levels we used a reference


99
00:05:22,596 --> 00:05:26,736
height of 768 points, the yellow
box there, that's our reference


100
00:05:26,736 --> 00:05:29,346
for how much level we wanted
to be visible onscreen.


101
00:05:30,166 --> 00:05:35,106
At that size our PlayerBot is
120 points, and now if we use


102
00:05:35,106 --> 00:05:39,826
that level on an iPad, the
iPad is also 768 points,


103
00:05:40,086 --> 00:05:41,356
so we'll know the size of
the PlayerBot on screen,


104
00:05:41,356 --> 00:05:43,676
and he's going to be 120
points and we can work


105
00:05:43,676 --> 00:05:45,796
out the image size we need


106
00:05:45,796 --> 00:05:47,416
to get a sharp image
of him onscreen.


107
00:05:48,726 --> 00:05:52,906
If we scale that level down
to an iPhone with, say,


108
00:05:52,906 --> 00:05:55,956
a 320 point height, he
actually is a bit smaller,


109
00:05:56,126 --> 00:05:57,116
he'll be 50 points high.


110
00:05:58,246 --> 00:06:00,376
We don't need such a
high resolution texture


111
00:06:00,376 --> 00:06:02,526
as on the iPad and
we can save space.


112
00:06:04,006 --> 00:06:08,186
If we look at all of the devices
that we support with DemoBots,


113
00:06:08,186 --> 00:06:12,846
iPad, iPhone and Mac, as that
Scene height scales we can work


114
00:06:12,846 --> 00:06:14,446
out the corresponding
player height.


115
00:06:15,086 --> 00:06:20,876
The iPhone 6 is slightly bigger
than the 4S through the 5S,


116
00:06:21,046 --> 00:06:24,226
we used the same assets, it
is so small, you don't notice.


117
00:06:26,126 --> 00:06:31,186
This then means you work out
the 1X, 2X, 3X assets we need


118
00:06:31,566 --> 00:06:34,146
to make them look sharp
without using any more pixels


119
00:06:34,146 --> 00:06:35,176
than we needed to.


120
00:06:35,176 --> 00:06:38,326
We rounded the iPhone 6
Plus down to 180 pixels just


121
00:06:38,326 --> 00:06:41,276
to keep things simple.


122
00:06:41,276 --> 00:06:43,976
We can set up the assets
we want for each device.


123
00:06:44,756 --> 00:06:46,216
We have a lot of
these in the game.


124
00:06:46,706 --> 00:06:48,886
I really, really do
mean a lot of them.


125
00:06:48,956 --> 00:06:49,526
There are thousands.


126
00:06:51,396 --> 00:06:54,196
All of these character
assets are actually generated


127
00:06:54,196 --> 00:06:56,276
from a 3D rendering output.


128
00:06:56,916 --> 00:06:57,686
Which we can also connect.


129
00:06:58,596 --> 00:07:02,186
We automated that creation
of the asset catalogs too.


130
00:07:02,836 --> 00:07:05,476
The JSON file here,
the one frame


131
00:07:05,476 --> 00:07:07,576
of the PlayerBot's
walk animation,


132
00:07:08,336 --> 00:07:09,886
and we can create
these automatically,


133
00:07:09,886 --> 00:07:12,746
this is what Xcode creates
with the asset catalogs


134
00:07:13,426 --> 00:07:16,226
and we can automate the process
of picking the right images


135
00:07:16,226 --> 00:07:20,406
for the right device and we'll
release the Asset Catalog format


136
00:07:20,406 --> 00:07:24,676
reference in a future seed
to make it easier for you


137
00:07:25,096 --> 00:07:27,516
to create these yourself
as well.


138
00:07:27,516 --> 00:07:29,036
Another SpriteKit
feature that we used


139
00:07:29,036 --> 00:07:33,546
in the game was SKCameraNode,
before that, if we wanted


140
00:07:34,066 --> 00:07:37,026
to move the view around
the level, we actually had


141
00:07:37,026 --> 00:07:37,966
to move the world, we had


142
00:07:37,966 --> 00:07:39,756
to move the level
itself beneath the view.


143
00:07:41,816 --> 00:07:44,406
with SKCameraNode
things are much simpler,


144
00:07:45,086 --> 00:07:46,666
the camera is a node
in the scene.


145
00:07:46,666 --> 00:07:47,496
It has a position.


146
00:07:48,186 --> 00:07:50,796
Because it has a position,
we can move it around just


147
00:07:50,796 --> 00:07:51,716
by changing that position.


148
00:07:51,886 --> 00:07:52,756
Same as any other node.


149
00:07:52,756 --> 00:07:55,636
It is easier to change where
the view is currently looking.


150
00:07:57,976 --> 00:08:01,046
Because it is a node we can
do node-like things with it.


151
00:08:01,516 --> 00:08:03,536
We can apply constraints
to that node for example.


152
00:08:04,096 --> 00:08:06,826
We can use this to constrain
the node's Camera position


153
00:08:07,106 --> 00:08:12,476
to a PlayerBot position,
when he runs to the corner


154
00:08:12,476 --> 00:08:16,986
of the screen, we have a lot
of black space around him,


155
00:08:16,986 --> 00:08:21,106
not as much level as we
would like on the screen.


156
00:08:21,106 --> 00:08:23,966
We can make it better to
use a second restraint


157
00:08:24,726 --> 00:08:27,756
to make sure we're never too
near the edge of the level.


158
00:08:28,126 --> 00:08:29,026
That's how that looks.


159
00:08:30,206 --> 00:08:32,525
We follow the PlayerBot
generally speaking


160
00:08:33,155 --> 00:08:35,746
but if he's near we
stop following him


161
00:08:35,806 --> 00:08:36,986
and keep more level onscreen.


162
00:08:37,686 --> 00:08:41,926
This is easier to see when
the enemy bots attack you.


163
00:08:43,756 --> 00:08:45,256
How do we do that?


164
00:08:45,676 --> 00:08:48,276
We start by working out
the banding rectangle


165
00:08:48,476 --> 00:08:49,386
of the entire level.


166
00:08:50,506 --> 00:08:53,776
We then make a smaller
rectangle in set from that based


167
00:08:53,776 --> 00:08:55,246
on the screens width and height


168
00:08:55,246 --> 00:08:56,286
that they're viewing
the game on.


169
00:08:57,166 --> 00:09:00,716
We make sure that the Camera can
never move outside of that box.


170
00:09:00,716 --> 00:09:02,206
We constrain it to
that rectangle.


171
00:09:03,216 --> 00:09:04,676
Then when the Camera moves


172
00:09:04,676 --> 00:09:07,106
around following the player
it never gets too near


173
00:09:07,326 --> 00:09:11,206
to the edge of the level.


174
00:09:11,206 --> 00:09:15,576
Because the Camera is a node we
can also add child nodes to it,


175
00:09:15,626 --> 00:09:17,516
which is good for
heads-up displays


176
00:09:17,516 --> 00:09:19,326
like our timer label
we have in the game.


177
00:09:20,706 --> 00:09:21,876
We don't want this
label to move,


178
00:09:21,876 --> 00:09:23,206
we want it to stay
top and center.


179
00:09:23,896 --> 00:09:26,536
So we add it as a child of the
Camera rather than had a child


180
00:09:26,536 --> 00:09:28,676
of the Scene, that way,
as the Camera moves


181
00:09:28,676 --> 00:09:31,826
around the label moves
with it and it is easier


182
00:09:31,826 --> 00:09:34,206
to keep the permanent features
onscreen in the right place.


183
00:09:37,316 --> 00:09:39,426
Those are some of the
SpriteKit features


184
00:09:39,426 --> 00:09:40,456
that we have used in the game.


185
00:09:41,036 --> 00:09:43,106
Let's look at some if of the
GameplayKit ones we used.


186
00:09:43,916 --> 00:09:46,896
the first is GKStateMachine,
you would have seen


187
00:09:46,896 --> 00:09:49,656
from the GameplayKit talk how
you can use state machines


188
00:09:49,656 --> 00:09:52,806
to track what's going on
with characters and levels


189
00:09:52,976 --> 00:09:54,086
and other elements of your game.


190
00:09:55,116 --> 00:09:57,286
We use this amongst other
things for the PlayerBot,


191
00:09:57,896 --> 00:09:58,936
this is the states he has.


192
00:09:59,336 --> 00:10:00,936
He starts in his Appear state


193
00:10:01,006 --> 00:10:03,316
where he teleports
into the game.


194
00:10:03,926 --> 00:10:07,606
The nice thing about using
custom states for this is


195
00:10:07,606 --> 00:10:10,256
that they can make sure that
the right thing happens.


196
00:10:10,256 --> 00:10:15,026
They start and it starts a
timer, after the right amount


197
00:10:15,606 --> 00:10:18,426
of time passes, it
moves straight


198
00:10:18,586 --> 00:10:21,236
to the player control state
and turns on the input use


199
00:10:21,236 --> 00:10:22,756
so you can control it.


200
00:10:24,376 --> 00:10:29,096
If he's hit we move into the
Hit state, when we have this,


201
00:10:29,096 --> 00:10:32,346
we enter a different
animation, the jump animation


202
00:10:32,346 --> 00:10:35,896
and the player can't
be controlled when hit


203
00:10:35,986 --> 00:10:39,306
and it turns off
input, tracks the state,


204
00:10:39,726 --> 00:10:41,616
when the time has
passed, move him back


205
00:10:41,736 --> 00:10:44,376
to the player control state.


206
00:10:44,376 --> 00:10:47,756
If we get hit enough
times we have to recharge


207
00:10:47,796 --> 00:10:50,786
and instead the Hit state
moves to the Recharging state.


208
00:10:51,616 --> 00:10:53,446
That tracks how long we
have been recharging for.


209
00:10:53,926 --> 00:10:55,266
The state actually does the job


210
00:10:55,476 --> 00:10:57,106
of adding more charge
back on to the player.


211
00:10:57,866 --> 00:11:00,276
Eventually when recharged,
it goes back


212
00:11:00,336 --> 00:11:01,336
to the PlayerControlled state.


213
00:11:01,336 --> 00:11:05,576
That's a reasonably
complex set of behaviors


214
00:11:05,576 --> 00:11:06,426
that the player can have.


215
00:11:07,216 --> 00:11:11,026
By using a state machine to
not only codify the states,


216
00:11:11,026 --> 00:11:13,826
make them happen, define the
right things to happen moving


217
00:11:14,096 --> 00:11:17,386
from state to state it
is easier to make sure


218
00:11:17,386 --> 00:11:19,016
that only the right thing
could happen in game.


219
00:11:19,016 --> 00:11:23,786
Our player Bot can't do
something we don't want him to.


220
00:11:23,786 --> 00:11:27,456
We use this also
for the game itself.


221
00:11:28,346 --> 00:11:30,646
We have an active state
when you play a level,


222
00:11:31,526 --> 00:11:33,706
if we hit pause we go
into a pause state.


223
00:11:34,126 --> 00:11:37,186
This handles overlay,
by removing that overlay


224
00:11:37,446 --> 00:11:38,596
when you move out
of the pause state.


225
00:11:39,566 --> 00:11:41,976
If I complete the level,
we have a success state.


226
00:11:42,486 --> 00:11:45,406
Again, this handles all of the
tasks of showing the buttons


227
00:11:45,586 --> 00:11:47,266
and overlay for when
we succeeded.


228
00:11:47,526 --> 00:11:49,526
The state knows the right things
to do in these situations.


229
00:11:50,826 --> 00:11:55,036
Another aspect of GameplayKit
we have used is entities


230
00:11:55,226 --> 00:11:55,906
and components.


231
00:11:56,776 --> 00:11:59,406
Now components are a
really good way to package


232
00:11:59,406 --> 00:12:01,306
up self-contained
pieces of functionality


233
00:12:01,306 --> 00:12:03,886
that are shared amongst
different entities in the game.


234
00:12:04,586 --> 00:12:06,786
We have three entities,
we have PlayerBot,


235
00:12:07,456 --> 00:12:09,016
GroundBot and FlyingBot.


236
00:12:10,356 --> 00:12:11,656
They have some things in common.


237
00:12:12,416 --> 00:12:14,036
They all need to be
rendered into the Scene


238
00:12:14,036 --> 00:12:15,266
and they all need a shadow.


239
00:12:15,656 --> 00:12:17,126
So we have a render component


240
00:12:17,126 --> 00:12:18,546
and a shadow component
to do these things.


241
00:12:19,506 --> 00:12:22,896
They also all have animation,
physics and intelligence,


242
00:12:22,896 --> 00:12:25,006
which is the name we've given
to the state machine tracking .


243
00:12:26,086 --> 00:12:29,406
At this point you may think
they look very similar.


244
00:12:30,156 --> 00:12:33,356
Why not have a base
Bot class providing all


245
00:12:33,356 --> 00:12:34,886
of the functionality
to all three?


246
00:12:36,476 --> 00:12:38,266
They're not actually
that similar after all.


247
00:12:39,176 --> 00:12:42,446
The PlayerBot needs
input and we can control


248
00:12:42,446 --> 00:12:46,506
that from a game controller or
keyboard or from touch control.


249
00:12:47,586 --> 00:12:49,186
The GroundBot and
FlyingBot don't need that,


250
00:12:49,286 --> 00:12:50,656
you never control
those characters.


251
00:12:51,096 --> 00:12:53,186
They're driven instead
by an agent.


252
00:12:53,186 --> 00:12:55,526
You will see later
how we use agents


253
00:12:55,526 --> 00:12:56,906
to drive the characters
around the level.


254
00:12:57,736 --> 00:12:58,976
Player Bot doesn't
need an agent,


255
00:12:59,186 --> 00:13:00,576
he's powered by your input.


256
00:13:01,866 --> 00:13:03,006
Likewise, GroundBot


257
00:13:03,066 --> 00:13:05,816
and FlyingBot have rules
telling the what they should do


258
00:13:05,816 --> 00:13:08,486
in a given situation and we'll
look at those later on as well.


259
00:13:09,436 --> 00:13:13,046
Player Bot doesn't, you
tell him what to do.


260
00:13:13,046 --> 00:13:15,876
PlayerBot and GroundBot do
have one thing in common,


261
00:13:16,516 --> 00:13:18,586
they both have a
movement component.


262
00:13:19,636 --> 00:13:22,746
This component's job is to
say if I'm here and I need


263
00:13:22,746 --> 00:13:25,326
to move this distance
at a certain angle make


264
00:13:25,326 --> 00:13:26,556
that happen within the Scene.


265
00:13:27,206 --> 00:13:30,276
Player Bot uses that
input to render it


266
00:13:30,276 --> 00:13:31,516
in the Scene, move him around.


267
00:13:32,366 --> 00:13:35,036
GroundBot uses it for a
charge forward attack,


268
00:13:35,036 --> 00:13:36,576
he moves from here
to charge forward.


269
00:13:37,956 --> 00:13:39,566
FlyingBot doesn't
need that capability.


270
00:13:39,766 --> 00:13:42,636
He doesn't move so he
doesn't have that component.


271
00:13:43,746 --> 00:13:46,666
These components, it is a
good way to break up bits


272
00:13:46,666 --> 00:13:48,716
of functionality
and assign them only


273
00:13:48,716 --> 00:13:50,116
to the entities that need them.


274
00:13:51,976 --> 00:13:54,506
So these are some of the
ways we have used GameplayKit


275
00:13:54,506 --> 00:13:55,866
functionality in the game.


276
00:13:55,866 --> 00:13:59,836
I would like to invite Dave
on stage to tell you more


277
00:13:59,836 --> 00:14:01,126
about how we have
used GameplayKit


278
00:14:01,516 --> 00:14:04,566
to create our games
Logic and Gameplay.


279
00:14:05,516 --> 00:14:09,306
[Applause]


280
00:14:09,806 --> 00:14:10,236
>> DAVE SCHAEFGEN:
Thank you, Dave.


281
00:14:10,976 --> 00:14:14,016
So when we think about
Logic in Gameplay,


282
00:14:14,336 --> 00:14:16,806
one of the most immediate
things that jump to my mind


283
00:14:16,806 --> 00:14:17,566
when I think about logic


284
00:14:17,566 --> 00:14:20,926
in gameplay is the actual
intelligence of my adversaries.


285
00:14:22,326 --> 00:14:26,386
a big piece of that
intelligence is going


286
00:14:26,386 --> 00:14:30,876
to be what I can
actually do in that space?


287
00:14:31,876 --> 00:14:34,866
As we saw earlier in the demo,
if I'm a good Bot I'm moving


288
00:14:34,866 --> 00:14:36,866
around the level,
patrolling circuits,


289
00:14:36,906 --> 00:14:37,936
keepings things moving.


290
00:14:38,986 --> 00:14:42,556
If I'm bad, I may want
to attack the PlayerBot.


291
00:14:42,786 --> 00:14:45,096
Got him that time.


292
00:14:46,766 --> 00:14:51,016
I may also wasn't to turn other
TaskBots bad so I have help


293
00:14:51,636 --> 00:14:53,026
when it comes to
getting the player Bot.


294
00:14:53,526 --> 00:14:54,296
Got that one too.


295
00:14:55,816 --> 00:15:01,956
Finally, I may move around the
level opposite direction messing


296
00:15:01,956 --> 00:15:05,586
with induction, currents in
the circuits, causing problems.


297
00:15:06,926 --> 00:15:09,056
Not as interesting, but now


298
00:15:09,466 --> 00:15:13,986
that we know what we can do
the question becomes how do we


299
00:15:13,986 --> 00:15:16,746
decide what we are going to do.


300
00:15:17,826 --> 00:15:19,576
In DemoBots we chose


301
00:15:19,576 --> 00:15:24,826
to implement a fuzzy logic
system with GKRuleSystem.


302
00:15:25,026 --> 00:15:29,466
The advantages of this were
we could still take in a lot


303
00:15:29,466 --> 00:15:31,556
of information about the
current state of the level,


304
00:15:32,036 --> 00:15:35,686
what was going on, and
have our characters react


305
00:15:35,686 --> 00:15:36,616
to that information.


306
00:15:37,466 --> 00:15:41,076
We could do that without
having if else trees that went


307
00:15:41,076 --> 00:15:42,946
on for hundreds of
lines of code.


308
00:15:43,276 --> 00:15:47,516
We have simple rules and rely
on the simple rules to interact


309
00:15:47,516 --> 00:15:49,426
with each other and
allow complex


310
00:15:49,426 --> 00:15:51,276
and interesting behaviors
to emerge.


311
00:15:52,466 --> 00:15:57,496
So if you're unfamiliar with
fuzzy Logic, I'll give you a bit


312
00:15:57,496 --> 00:15:59,716
of an idea of what we're
talking about here.


313
00:16:00,246 --> 00:16:04,386
The fuzzy that we're referring
to is actually the fact


314
00:16:04,386 --> 00:16:07,866
that everything is not black
and white, true and false.


315
00:16:08,246 --> 00:16:10,346
Our rules aren't
mutually exclusive.


316
00:16:11,016 --> 00:16:17,286
We modeled our rules on natural
concepts and tried to think


317
00:16:17,286 --> 00:16:20,216
of them like sentences that
you would say to a colleague.


318
00:16:20,766 --> 00:16:22,486
The PlayerBot is nearby.


319
00:16:23,926 --> 00:16:28,176
. These are implemented in
the fuzzy TaskBots rule class.


320
00:16:29,086 --> 00:16:30,696
It is a subclass of GKRule.


321
00:16:30,696 --> 00:16:37,156
We have actually tied the fact
of the rule to the grade here.


322
00:16:38,176 --> 00:16:41,266
Only we assert the fact if the
grade is greater than zero.


323
00:16:42,886 --> 00:16:46,286
This is interesting because
we made grade a function


324
00:16:46,286 --> 00:16:51,766
of the actual state information
available in the level rather


325
00:16:51,766 --> 00:16:53,946
than it being something that
you set up at the moment


326
00:16:53,946 --> 00:16:56,866
that you create the GKRule.


327
00:16:56,866 --> 00:17:04,396
Let's look at what those -- what
that proximity rule looks like.


328
00:17:04,636 --> 00:17:07,836
Thinking about being
near or far,


329
00:17:08,415 --> 00:17:11,526
and let's actually use a
graph to take a look at this


330
00:17:11,665 --> 00:17:13,256
and see how these
functions work.


331
00:17:14,006 --> 00:17:17,445
Up here near the origin you can
see that we have a PlayerBot


332
00:17:18,016 --> 00:17:19,306
and out about as far away


333
00:17:19,306 --> 00:17:21,215
as we can get them
you have the TaskBot,


334
00:17:21,806 --> 00:17:24,516
if I bring in a graphical
representation


335
00:17:24,646 --> 00:17:29,796
of the far rule it is pretty
simple to see that the grade


336
00:17:29,836 --> 00:17:31,936
for the far rule is going
to be one in this case.


337
00:17:32,486 --> 00:17:35,476
If I pull in the
medium and near rules,


338
00:17:35,846 --> 00:17:37,266
it is clear that they're going


339
00:17:37,266 --> 00:17:39,806
to have a zero grade
in this situation.


340
00:17:40,486 --> 00:17:43,546
Now that doesn't lineup
seeming all that interesting,


341
00:17:43,546 --> 00:17:47,606
it does kindof seem black and
white and a bit true/false.


342
00:17:47,606 --> 00:17:54,466
If we move our task Bot closer
you can see what I'm talking


343
00:17:54,466 --> 00:17:55,616
about clearly.


344
00:17:55,866 --> 00:17:58,226
Here the grade for
the far rule is.


345
00:17:58,226 --> 00:18:02,656
75 and for the medium
rule, about.


346
00:18:02,656 --> 00:18:08,186
25. If we move him still
closer, things switch


347
00:18:08,256 --> 00:18:11,476
and we have membership in both
the near and medium rules.


348
00:18:11,476 --> 00:18:16,136
>> Now that you have
seen how the functions


349
00:18:16,356 --> 00:18:18,696
that we have calculate
our grades,


350
00:18:19,966 --> 00:18:24,496
let's look at how we actually
make decisions once we have


351
00:18:24,496 --> 00:18:27,416
calculated those grades
for each of our rules.


352
00:18:27,856 --> 00:18:30,886
So here are the rules that
we actually have in DemoBots.


353
00:18:31,716 --> 00:18:34,826
Our first step, like I
said, is to go ahead,


354
00:18:34,886 --> 00:18:36,996
evaluate them, calculate
the values.


355
00:18:37,976 --> 00:18:41,936
The next thing we're going to
do is combine a few of them


356
00:18:42,686 --> 00:18:48,246
to decide these are contributing
factors that we would want


357
00:18:48,246 --> 00:18:50,996
to pay attention to when
hunting the PlayerBot.


358
00:18:51,666 --> 00:18:54,836
Read like a sentence, you
can tell how this is working


359
00:18:54,836 --> 00:18:56,556
like a telling of a story.


360
00:18:57,496 --> 00:19:00,246
If a percentage of
bad TaskBots is high


361
00:19:00,866 --> 00:19:03,376
and the PlayerBot is
a medium distance away


362
00:19:04,056 --> 00:19:07,616
and the good TaskBot is
also a medium distance away,


363
00:19:07,746 --> 00:19:11,456
I want to hunt the PlayerBot.


364
00:19:12,586 --> 00:19:14,726
The reason I would want
to do that in this case,


365
00:19:14,916 --> 00:19:18,746
the way I think about it,
is there already are a lot


366
00:19:18,746 --> 00:19:22,166
of bad TaskBots on this level,
I don't need to turn them,


367
00:19:22,466 --> 00:19:24,086
I may as well hunt the player


368
00:19:24,086 --> 00:19:30,306
at this point.The trouble I have
is I have 3 different grades


369
00:19:30,686 --> 00:19:34,726
to represent this idea of
hunting the PlayerBot now.


370
00:19:35,066 --> 00:19:39,176
So we're going to use
GKRuleSystems minimum grade


371
00:19:39,176 --> 00:19:44,906
for facts to grab the minimum
grade for each of the facts


372
00:19:44,906 --> 00:19:47,236
that we want to combine.


373
00:19:47,356 --> 00:19:53,026
Now, the reason why we pick
the minimum is our mandate


374
00:19:53,346 --> 00:19:56,596
for hunting the PlayerBot based
on that information is only


375
00:19:56,596 --> 00:20:02,496
as strong as the weakest
fact contributing to it.


376
00:20:02,666 --> 00:20:06,806
We could combine those
rules in any number of ways


377
00:20:06,896 --> 00:20:10,866
and get several different
indicators saying


378
00:20:10,866 --> 00:20:13,786
to hunt the PlayerBot
or to hunt TaskBots.


379
00:20:14,826 --> 00:20:17,746
This is the stage
where we get to needing


380
00:20:17,746 --> 00:20:22,886
to actually defuzz-ify the
rules to get one simple number


381
00:20:23,286 --> 00:20:26,646
to really represent the idea
of hunting the PlayerBot.


382
00:20:27,716 --> 00:20:30,126
In this case we just
take our facts,


383
00:20:30,816 --> 00:20:32,806
we use the reduce
function in Swift


384
00:20:33,006 --> 00:20:36,036
and the max function
to combine things.


385
00:20:36,426 --> 00:20:40,436
In this case we actually --
we want hunting the PlayerBot


386
00:20:40,436 --> 00:20:42,326
or hunting the TaskBots
to be represented


387
00:20:42,326 --> 00:20:46,396
by the strongest grade
available of the ones we have.


388
00:20:47,166 --> 00:20:48,276
Looking at these numbers,


389
00:20:48,276 --> 00:20:50,866
it is pretty obvious
we'll hunt the PlayerBot.


390
00:20:50,866 --> 00:21:02,896
Now that we know we want to hunt
the PlayerBot the first problem


391
00:21:02,896 --> 00:21:07,756
we've got is how do I
actually get to the PlayerBot.


392
00:21:08,216 --> 00:21:10,036
Often that's pretty
straightforward,


393
00:21:11,196 --> 00:21:16,006
just move in a straight line
and you'll eventually get there.


394
00:21:16,366 --> 00:21:18,596
Obstacles present a challenge,


395
00:21:18,736 --> 00:21:21,816
here you see the FlyingBot
getting hung up there.


396
00:21:21,946 --> 00:21:26,396
You remember from a sample from
a couple years ago, Adventure,


397
00:21:26,766 --> 00:21:31,016
the goblins in that sample, were
really fond of this behavior.


398
00:21:32,306 --> 00:21:34,956
We decided to do
something about that,


399
00:21:34,956 --> 00:21:39,616
and in GameplayKit we have
made it really easy for you


400
00:21:39,616 --> 00:21:43,906
to take advantage of pathfinding
in a world and get your Bots


401
00:21:44,416 --> 00:21:47,296
or your enemies moving
easily like this.


402
00:21:47,676 --> 00:21:50,496
It has great conveniences
for working with things


403
00:21:50,616 --> 00:21:54,376
when you're using SpriteKit for
a game and it is really easy


404
00:21:54,816 --> 00:21:56,166
to get things up and running.


405
00:21:56,956 --> 00:21:58,826
Only a few lines of code.


406
00:21:59,006 --> 00:22:02,146
Let's take a look at what
those lines look like.


407
00:22:04,136 --> 00:22:05,516
So the first thing you're going


408
00:22:05,516 --> 00:22:11,096
to do is actually get the
polygon obstacles making


409
00:22:11,096 --> 00:22:11,796
up the level.


410
00:22:12,106 --> 00:22:18,256
In our case we'll first search
for our nodes within our Scene.


411
00:22:18,306 --> 00:22:20,086
They have all been
named obstacles.


412
00:22:20,176 --> 00:22:23,236
When we have an array of
those nodes we'll pass it


413
00:22:23,436 --> 00:22:27,336
to a convenience function
that SKNodes has in iOS 9,


414
00:22:27,786 --> 00:22:29,516
obstacles for node
physics bodies


415
00:22:30,416 --> 00:22:34,796
to take the actual physics
body you defined to use


416
00:22:34,796 --> 00:22:37,156
that to define the obstacle.


417
00:22:38,076 --> 00:22:42,016
When those obstacles, when we
have the obstacles we're going


418
00:22:42,016 --> 00:22:45,396
to construct an obstacle
graph using them,


419
00:22:45,856 --> 00:22:47,996
and also a buffer
radius parameter.


420
00:22:48,596 --> 00:22:52,936
This parameter is a
little bit of extra spacing


421
00:22:53,296 --> 00:22:55,166
around the actual obstacle.


422
00:22:55,886 --> 00:22:58,286
A good way for you to
think about it might be


423
00:22:58,866 --> 00:23:01,716
as you're walking towards a
doorway and you're walking


424
00:23:01,716 --> 00:23:04,346
through the doorway you're
not actually going to walk


425
00:23:04,346 --> 00:23:06,696
at one corner or the
other of the door frame.


426
00:23:07,226 --> 00:23:10,166
You're going to aim for a point
in the middle of the doorway


427
00:23:10,416 --> 00:23:12,086
where no part of your
body is actually going


428
00:23:12,086 --> 00:23:14,496
to contact the door when
you walk through it.


429
00:23:14,726 --> 00:23:19,466
This radius helps set that
spacing around the obstacles.


430
00:23:20,266 --> 00:23:26,176
Next we'll take the TaskBot
and PlayerBot positions


431
00:23:26,686 --> 00:23:28,236
and connect them to the graph.


432
00:23:29,516 --> 00:23:35,146
Finally we will ask the
graph to give us a path


433
00:23:35,886 --> 00:23:37,486
from the start node
to the end node.


434
00:23:38,126 --> 00:23:40,896
We'll get back in array
of the individual nodes


435
00:23:41,306 --> 00:23:44,646
that are necessary to get
from point A to point B


436
00:23:45,396 --> 00:23:49,326
and it really is that simple
to turn things from walking


437
00:23:49,326 --> 00:23:53,836
into memory chips and along them
to actually walking around them.


438
00:23:55,126 --> 00:23:57,716
We have a path, we have points,


439
00:23:58,066 --> 00:23:59,806
but how am I actually
going to get there?


440
00:24:00,276 --> 00:24:03,096
How do I actually get there
and make it look nice?


441
00:24:04,076 --> 00:24:07,976
Well, GameplayKit has
an answer for us again.


442
00:24:07,976 --> 00:24:11,396
This time it is GKAgent 2D.


443
00:24:11,676 --> 00:24:15,696
This is one of my favorite
classes in GameplayKit.


444
00:24:16,576 --> 00:24:20,066
This is a GKComponent,
so it works very nicely


445
00:24:20,066 --> 00:24:22,836
with the Entity/Component system
that Dave talked about earlier.


446
00:24:24,326 --> 00:24:27,666
It is very easy to
get things set up.


447
00:24:28,276 --> 00:24:30,676
You have a GKBehavior
that describes what it is


448
00:24:30,676 --> 00:24:32,116
that you want this agent to do,


449
00:24:32,246 --> 00:24:35,316
it is kind of a container
for GKGoals.


450
00:24:35,986 --> 00:24:40,806
GKGoal, lucky for us in this
case actually has a couple


451
00:24:40,806 --> 00:24:46,566
of different constructions that
allow us to work with paths.


452
00:24:47,016 --> 00:24:49,006
Because the agent
world and the world


453
00:24:49,006 --> 00:24:50,906
of GameplayKit is
different from the world


454
00:24:50,906 --> 00:24:55,746
of SpriteKit the delegate
here makes it very simple


455
00:24:56,036 --> 00:24:58,926
to integrate the two of them.


456
00:24:59,206 --> 00:25:01,536
Let's take a look at
what it actually --


457
00:25:01,536 --> 00:25:03,206
you know, what the
code looks like.


458
00:25:04,286 --> 00:25:11,286
We'll take that array of path
nodes that we had from before.


459
00:25:11,286 --> 00:25:13,046
We're going to initialize them.


460
00:25:13,046 --> 00:25:19,006
We're going to pass them to an
initializer to create our path.


461
00:25:19,866 --> 00:25:22,836
There is another parameter
here and that is the radius.


462
00:25:22,836 --> 00:25:23,556
What I want you to think


463
00:25:23,556 --> 00:25:26,946
about here is how do
you want this path


464
00:25:26,976 --> 00:25:28,546
to be defined for your agent.


465
00:25:28,906 --> 00:25:30,716
Very small values will result


466
00:25:30,716 --> 00:25:33,356
in your agent treating your
path like a tight rope.


467
00:25:34,096 --> 00:25:38,036
Larger values, you know,
could have them treating it


468
00:25:38,036 --> 00:25:40,776
like an 8-lane highway,
moving all over the place.


469
00:25:41,276 --> 00:25:42,516
You'll want to fine tune


470
00:25:42,516 --> 00:25:44,396
that for what works
best for your game.


471
00:25:46,376 --> 00:25:47,966
Next we'll create a behavior.


472
00:25:48,546 --> 00:25:50,346
Here it is just an
empty behavior,


473
00:25:50,346 --> 00:25:53,066
nothing really going on yet.


474
00:25:53,066 --> 00:25:55,956
Then we'll add goals to it.


475
00:25:55,956 --> 00:25:58,276
These are the two
path-related goals I was talking


476
00:25:58,276 --> 00:25:59,076
about from before.


477
00:25:59,716 --> 00:26:05,546
The first one on the screen,
our goal to follow path is going


478
00:26:05,546 --> 00:26:09,136
to establish the direction in
which we'll travel our array.


479
00:26:09,526 --> 00:26:11,566
In this case we'll move
forward in a forward direction


480
00:26:11,726 --> 00:26:16,006
from the start position, our
TaskBots to the end position,


481
00:26:16,166 --> 00:26:17,086
which was our PlayerBot.


482
00:26:18,106 --> 00:26:23,646
The stay on path goal is
there to motivate our agent,


483
00:26:23,976 --> 00:26:28,866
to actually remain within
the bounds of the path


484
00:26:29,146 --> 00:26:30,626
that we defined earlier.


485
00:26:31,186 --> 00:26:35,756
Now that we have a working
behavior we assign it


486
00:26:35,756 --> 00:26:39,366
to our agent to get him moving.


487
00:26:39,726 --> 00:26:43,946
the agent works like many


488
00:26:43,946 --> 00:26:46,716
of the other components
within GameplayKit.


489
00:26:46,716 --> 00:26:48,756
It is updated on a cycle.


490
00:26:49,416 --> 00:26:55,756
When you've added it into your
update loop it will notify you


491
00:26:55,756 --> 00:26:57,816
before and after changes,


492
00:26:57,866 --> 00:27:00,216
and this delegate
notification before


493
00:27:00,216 --> 00:27:02,226
and after changes
is the ideal place


494
00:27:02,226 --> 00:27:07,406
to actually get things working
and hooked up with SpriteKit.


495
00:27:07,876 --> 00:27:12,306
In WillUpdate, this is
a position that you want


496
00:27:12,306 --> 00:27:17,556
to take the information
from your SpriteKit node


497
00:27:17,726 --> 00:27:21,326
that represents your
agent in Scene and pull


498
00:27:21,326 --> 00:27:24,296
that information back
over and update the agent


499
00:27:25,266 --> 00:27:27,496
because we're doing
this at the front


500
00:27:28,226 --> 00:27:31,546
of the SpriteKit
update loop and the end


501
00:27:31,906 --> 00:27:34,786
of the last SpriteKit update
loop would have involved


502
00:27:35,026 --> 00:27:38,626
simulating physics, applying
constraints to your node


503
00:27:38,866 --> 00:27:40,866
which may have caused
its position to move


504
00:27:40,966 --> 00:27:44,056
from where the agent thought it
was at the last time through.


505
00:27:44,676 --> 00:27:50,306
In AgentDidUpdate, we'll take
the information from the agent,


506
00:27:51,296 --> 00:27:54,146
its position, its rotation,
things of that nature


507
00:27:54,996 --> 00:27:58,636
and pull those back over into
the SpriteKit world updating our


508
00:27:58,636 --> 00:28:01,946
node before it goes
into physics simulation


509
00:28:02,336 --> 00:28:08,036
and constraint application
this time around.


510
00:28:08,036 --> 00:28:14,396
Really, that is what got us
to this point with DemoBots


511
00:28:15,116 --> 00:28:18,256
and an intelligence that
works nicely, moving readily


512
00:28:18,256 --> 00:28:23,746
around the screen, smoothly
interacting with you.


513
00:28:23,746 --> 00:28:27,256
This is something extra I
guess, we left debug drawing


514
00:28:27,956 --> 00:28:30,196
in the sample that
you can download.


515
00:28:30,996 --> 00:28:33,936
You can enable it by
hitting the slash key.


516
00:28:35,076 --> 00:28:38,466
The nice thing about this,
it helps you visualize some


517
00:28:38,466 --> 00:28:40,066
of the parameters we
talked about earlier.


518
00:28:40,406 --> 00:28:44,896
The orange boxes are buffer
radius around the obstacles


519
00:28:46,386 --> 00:28:51,786
and the thick lines that you can
see emanating from the player,


520
00:28:51,786 --> 00:28:56,616
the task Bots are a
representation of that path


521
00:28:57,536 --> 00:29:01,506
that we talked about, the
path radius that was there.


522
00:29:01,506 --> 00:29:04,326
Now that we have a game, I would


523
00:29:04,326 --> 00:29:07,056
like to invite my colleague
Michael up on stage.


524
00:29:07,426 --> 00:29:09,506
He's going to discuss
with you how


525
00:29:09,506 --> 00:29:12,466
to get your users playing
your game that much faster.


526
00:29:13,086 --> 00:29:13,346
Michael.


527
00:29:14,516 --> 00:29:18,846
[Applause]


528
00:29:19,346 --> 00:29:20,056
>> MICHAEL DEWITT:
Thank you very much.


529
00:29:20,056 --> 00:29:23,826
We'll talk about
taking a fun game


530
00:29:23,826 --> 00:29:27,336
and making a great overall
experience for your users.


531
00:29:27,336 --> 00:29:29,896
I'll boil it down to
one phrase and that is,


532
00:29:29,896 --> 00:29:31,466
of course, time to fun.


533
00:29:31,846 --> 00:29:33,836
How long does it
take for your users


534
00:29:33,836 --> 00:29:35,456
to start really enjoying
your game?


535
00:29:36,386 --> 00:29:39,566
The first barrier to entry there
is really the initial download.


536
00:29:40,026 --> 00:29:44,036
If you're shipping an app that's
too big some users won't be able


537
00:29:44,036 --> 00:29:45,746
to download it over
cellular connection


538
00:29:46,096 --> 00:29:47,796
and it can take a
while even on Wi-Fi.


539
00:29:48,646 --> 00:29:50,616
This is the biggest latency


540
00:29:50,926 --> 00:29:53,256
between your user finding
the app on the App Store


541
00:29:53,346 --> 00:29:56,426
and deciding to get into it.


542
00:29:56,426 --> 00:30:00,056
But we know this 100 mega
download limit is hard


543
00:30:00,056 --> 00:30:01,356
for games to stay under.


544
00:30:01,736 --> 00:30:03,906
We'll go back to DemoBots
and see how we handle this.


545
00:30:04,486 --> 00:30:09,126
If you focus on the PlayerBot
you notice we're not looking


546
00:30:09,126 --> 00:30:10,776
strictly top-down
on the character.


547
00:30:11,386 --> 00:30:14,276
It is not a 2D game but
an isometric feel here.


548
00:30:14,936 --> 00:30:17,406
We pulled that off by
giving this character


549
00:30:17,406 --> 00:30:18,836
multiple orientations.


550
00:30:19,566 --> 00:30:22,256
As you move the character
around the map,


551
00:30:22,786 --> 00:30:25,486
we'll swap out the texture
representing the character


552
00:30:25,716 --> 00:30:27,426
to get this perspective.


553
00:30:28,316 --> 00:30:32,446
When you add all of the extra
frames in there, it takes space.


554
00:30:32,506 --> 00:30:34,976
It is only 6 megabytes,
that's small for a game.


555
00:30:34,976 --> 00:30:38,146
When you consider it is 6
megabytes times the three bots


556
00:30:38,146 --> 00:30:41,586
we have times the different
actions they can perform,


557
00:30:41,886 --> 00:30:45,476
we need the orientation frames
for the Player Bot when idling,


558
00:30:45,476 --> 00:30:50,216
hit, walking around, so
this starts to add up.


559
00:30:50,436 --> 00:30:54,226
Traditionally, that means that
all of the assets plus the 1X,


560
00:30:54,226 --> 00:30:58,136
2X, 3X versions, they're
bundled in the app.


561
00:30:58,386 --> 00:31:00,306
We have a better
story for this now.


562
00:31:00,686 --> 00:31:02,196
You may have heard about
it earlier this week.


563
00:31:02,746 --> 00:31:06,456
If you use asset catalogs
you will take advantage


564
00:31:06,456 --> 00:31:07,916
of a new feature
called app slicing.


565
00:31:08,386 --> 00:31:12,296
What app slicing will do
is breakdown the 1X, 2X,


566
00:31:12,336 --> 00:31:16,486
3X for the actual device
that they're used on.


567
00:31:17,226 --> 00:31:20,436
This is going to save us a ton
of space right off the bat just


568
00:31:20,436 --> 00:31:21,896
by using the asset catalogs


569
00:31:21,946 --> 00:31:24,076
and letting the App
Store slice it for us.


570
00:31:24,296 --> 00:31:26,776
It is not only that we
now save a bunch of space,


571
00:31:26,776 --> 00:31:29,006
it is what can we do with
the extra room on our app.


572
00:31:29,006 --> 00:31:30,926
I'm looking at the
graph and it is empty.


573
00:31:31,446 --> 00:31:34,966
In DemoBots, it has
practical implications.


574
00:31:36,586 --> 00:31:40,306
We started with 8 orientations
and I'll show you a video here.


575
00:31:40,306 --> 00:31:41,156
Watch closely.


576
00:31:41,156 --> 00:31:44,096
The PlayerBot, it looks like
it is facing directly forward,


577
00:31:44,096 --> 00:31:46,646
you will notice, watch
the movement closely,


578
00:31:46,646 --> 00:31:58,696
see if you notice something.


579
00:31:58,796 --> 00:32:01,526
So especially when the character
is moving back towards the top


580
00:32:01,526 --> 00:32:04,596
of the map there, we
term that skating.


581
00:32:05,026 --> 00:32:07,096
While we only have
the eight orientations


582
00:32:07,096 --> 00:32:08,866
to represent the
characters movement,


583
00:32:09,016 --> 00:32:13,236
the player is supplying 360°
of input, we can be slightly off


584
00:32:13,306 --> 00:32:17,256
of that orientation while
not triggering the next


585
00:32:17,256 --> 00:32:19,136
and you get the strafing
behavior.


586
00:32:19,976 --> 00:32:24,146
More frustrating than that
though was using the eight


587
00:32:24,146 --> 00:32:27,176
orientations means you could
end up in a situation like this


588
00:32:27,336 --> 00:32:29,496
where the PlayerBot is
facing directly forward,


589
00:32:29,706 --> 00:32:33,076
looks like it should be easily
hitting that TaskBot but isn't


590
00:32:33,076 --> 00:32:36,516
because of the debug drawing,
you see the player is aiming


591
00:32:36,596 --> 00:32:39,546
to the side and the user
has no way to see this.


592
00:32:40,236 --> 00:32:42,026
With that extra space we got


593
00:32:42,026 --> 00:32:43,736
from app slicing we
bumped it up a notch.


594
00:32:44,196 --> 00:32:46,016
We went to 16 orientations,


595
00:32:46,496 --> 00:32:49,616
that makes movement feel a lot
smoother throughout the game


596
00:32:50,636 --> 00:32:53,776
so you can see we have many
more animation frames here


597
00:32:53,776 --> 00:32:55,146
to represent that.


598
00:32:56,456 --> 00:33:00,186
Then when it comes to aiming,
now it is much more granular.


599
00:33:00,396 --> 00:33:02,766
The direction where the
character faces almost


600
00:33:02,766 --> 00:33:05,036
corresponds exactly with
where the beam's going to hit.


601
00:33:05,036 --> 00:33:09,786
You click through there,
it is easier for the user


602
00:33:09,786 --> 00:33:12,526
to know what's going
on with the game.


603
00:33:12,716 --> 00:33:15,556
That's app slicing, we use
that in DemoBots simply


604
00:33:15,556 --> 00:33:18,246
by putting our texture
atlases within Asset Catalogs,


605
00:33:18,636 --> 00:33:21,566
it helps us to greatly decrease
the size of the app overall,


606
00:33:21,566 --> 00:33:23,146
but it's more than that,


607
00:33:23,216 --> 00:33:25,436
we can actually improve
the gameplay now


608
00:33:25,436 --> 00:33:28,276
because we have the extra space.


609
00:33:28,276 --> 00:33:30,826
This feature works super
well for assets that you need


610
00:33:30,826 --> 00:33:32,606
in your game all the time.


611
00:33:32,666 --> 00:33:34,786
DemoBots is not much of
a game unless we keep the


612
00:33:34,786 --> 00:33:35,746
PlayerBot around.


613
00:33:36,686 --> 00:33:39,926
But there are other assets
we don't necessarily need all


614
00:33:39,926 --> 00:33:40,426
the time.


615
00:33:40,516 --> 00:33:42,636
For that we have
another technology


616
00:33:42,636 --> 00:33:43,246
that you may have heard


617
00:33:43,246 --> 00:33:45,746
about earlier this week,
on demand resources.


618
00:33:46,176 --> 00:33:49,376
The mild overview of this, it
lets you tag resources just


619
00:33:49,376 --> 00:33:51,516
with a simple string
for download later on.


620
00:33:51,516 --> 00:33:54,116
I'll talk about how we
use this in DemoBots.


621
00:33:54,556 --> 00:33:56,236
The first place,
maybe it is obvious,


622
00:33:56,236 --> 00:33:59,396
we have multiple levels.We
can tag those level 1,


623
00:33:59,396 --> 00:34:00,696
level 2, and level 3 .


624
00:34:01,236 --> 00:34:04,536
The advantage here, it is
now that we have tagged these


625
00:34:04,536 --> 00:34:06,936
with ODR we can actually say


626
00:34:06,936 --> 00:34:09,966
if the user initially downloads
the game, we know they'll go


627
00:34:09,966 --> 00:34:11,996
to level 1, there is no reason


628
00:34:11,996 --> 00:34:13,585
to include the other
two levels there.


629
00:34:14,826 --> 00:34:18,156
It gets even more interesting
as the game progresses,


630
00:34:18,696 --> 00:34:21,726
because we can predict
with this linear flow


631
00:34:21,726 --> 00:34:24,076
that the user will
proceed on to level 3


632
00:34:24,426 --> 00:34:28,196
so we'll start downloading that
level early and it is unlikely


633
00:34:28,196 --> 00:34:30,106
that they'll replay level 1


634
00:34:30,466 --> 00:34:32,545
to we can recycle some
of those resources.


635
00:34:32,946 --> 00:34:35,676
Let's take it a step further.


636
00:34:36,315 --> 00:34:40,176
If we look closely at
level 2 and you will notice


637
00:34:40,176 --> 00:34:42,335
from the demo and from
this small picture


638
00:34:42,335 --> 00:34:44,896
that only the FlyingBot
shows up in this level


639
00:34:45,045 --> 00:34:46,556
and shows up again in level 3.


640
00:34:47,275 --> 00:34:51,416
Contrast that with a GroundBot
who is in levels 1 and 3.


641
00:34:52,726 --> 00:34:55,536
When we tag the characters
individually it allows us


642
00:34:55,536 --> 00:34:57,636
to breakdown our
resources even further.


643
00:34:57,756 --> 00:34:59,616
If we know the user
is downloading the app


644
00:34:59,616 --> 00:35:02,816
for the first time we only ship
with the GroundBot in level 1


645
00:35:02,996 --> 00:35:04,876
and we can do the
FlyingBot later on.


646
00:35:05,606 --> 00:35:07,586
And if you're on a device
that's tight for storage,


647
00:35:07,586 --> 00:35:10,206
maybe when the user's playing
level 2 you can purge the


648
00:35:10,206 --> 00:35:13,166
GroundBot and then bring
them both back for level 3.


649
00:35:14,036 --> 00:35:16,116
You can see how we
laid out the tags


650
00:35:16,456 --> 00:35:19,466
in the Project Navigator
under resource tags.


651
00:35:20,296 --> 00:35:22,996
You will see that the assets
for level 1 are tagged


652
00:35:22,996 --> 00:35:25,756
as prefetched, those
are coming down shortly


653
00:35:25,756 --> 00:35:28,616
after the app has been
installed, but not included


654
00:35:28,616 --> 00:35:31,826
in the bundle size, whereas the
other resources can be tagged


655
00:35:31,826 --> 00:35:33,356
for download when
we request them.


656
00:35:34,636 --> 00:35:36,606
That's on-demand resources.


657
00:35:36,836 --> 00:35:40,626
We used it in DemoBots to tag
the resources for later download


658
00:35:40,726 --> 00:35:43,156
which gives us a faster
initial download time.


659
00:35:43,156 --> 00:35:45,606
We can cut a bunch of stuff out
that we don't need immediately.


660
00:35:46,186 --> 00:35:49,096
Overall it helps us keep the
storage footprint small too.


661
00:35:49,356 --> 00:35:50,676
That's the bigger message here.


662
00:35:50,676 --> 00:35:54,536
You can make a more rich game
and have many more assets


663
00:35:54,856 --> 00:35:57,276
because you are still keeping
the same footprint on device


664
00:35:57,496 --> 00:36:01,436
but accessing everything
else on demand.


665
00:36:01,706 --> 00:36:04,186
We recognize this
does add complication.


666
00:36:05,006 --> 00:36:09,066
When you talk about presenting
the next Scene traditionally you


667
00:36:09,066 --> 00:36:12,316
know it is in local storage,
you can prepare those resources,


668
00:36:12,316 --> 00:36:14,246
and when the user requests
it, you can present.


669
00:36:15,326 --> 00:36:17,236
Now we're adding an
extra complication.


670
00:36:17,236 --> 00:36:20,556
Maybe you need to download
those resources, and of course


671
00:36:20,556 --> 00:36:23,446
with network connection
that download can fail.


672
00:36:24,556 --> 00:36:26,496
If you want to get the
space savings, you will have


673
00:36:26,496 --> 00:36:29,606
to purge the resources
at some point and rinse


674
00:36:29,606 --> 00:36:30,676
and repeat that whole cycle.


675
00:36:31,566 --> 00:36:35,166
This can get complicated
and I want to focus


676
00:36:35,166 --> 00:36:36,726
on how we solved it in DemoBots.


677
00:36:37,156 --> 00:36:39,916
Specifically going back to a
technology that Dave mentioned


678
00:36:39,916 --> 00:36:42,176
at the top of the talk,
the GKStateMachine.


679
00:36:42,966 --> 00:36:46,906
If we use that to model this,
we call it our SceneLoader


680
00:36:46,906 --> 00:36:48,856
and it has six associated
states.


681
00:36:49,516 --> 00:36:51,116
You will notice that
only two of the states,


682
00:36:51,116 --> 00:36:53,436
the downloading resources
and download failed state,


683
00:36:53,436 --> 00:36:55,116
they're actually
associated with ODR


684
00:36:55,206 --> 00:36:58,126
because this is a full pipeline
to model bringing your resources


685
00:36:58,126 --> 00:37:00,976
into memory whether they're
from local storage or need


686
00:37:00,976 --> 00:37:02,156
to be downloaded first.


687
00:37:02,926 --> 00:37:04,486
the real advantage we're getting


688
00:37:04,486 --> 00:37:07,576
from using the state machine
is how we model the transition


689
00:37:07,576 --> 00:37:08,436
from states.


690
00:37:08,646 --> 00:37:09,646
If we look closely


691
00:37:09,646 --> 00:37:14,646
at the preparing resources state
we can enforce what are the


692
00:37:14,646 --> 00:37:18,276
valid next states by
overriding IsValidNextState


693
00:37:18,276 --> 00:37:20,316
in our GKState subclass


694
00:37:21,186 --> 00:37:24,226
and we can say the state
machine can only move


695
00:37:24,226 --> 00:37:27,416
on to the ready state if
the Scene is indeed loaded,


696
00:37:28,266 --> 00:37:30,296
or we can move back
to the available state


697
00:37:30,296 --> 00:37:32,036
if the user's canceled
this request.


698
00:37:32,336 --> 00:37:34,466
We're not going to go back
to downloading while trying


699
00:37:34,466 --> 00:37:37,356
to prepare our resources
because we're able to enforce it


700
00:37:37,356 --> 00:37:39,406
with this IsValidNextState
and so it leads


701
00:37:39,406 --> 00:37:41,086
to much more determininistic
behavior.


702
00:37:42,716 --> 00:37:44,256
Alright, so to wrap things up,


703
00:37:44,256 --> 00:37:48,316
I'll share a final few tips we
learned developing this game.


704
00:37:48,876 --> 00:37:51,196
the first, if you're
using on-demand resources,


705
00:37:51,196 --> 00:37:53,296
put that download
request in early.


706
00:37:53,636 --> 00:37:56,396
If you have a predictable
progression in the game,


707
00:37:56,626 --> 00:37:58,456
you can start downloading
level 2 as soon


708
00:37:58,456 --> 00:38:01,036
as the player begins level 1.


709
00:38:02,516 --> 00:38:06,196
Don't forget about the tools
for ODR that are within Xcode.


710
00:38:06,506 --> 00:38:09,826
You can look at the disk
report tool and specifically


711
00:38:09,826 --> 00:38:11,296
under the on-demand
resources see


712
00:38:11,296 --> 00:38:14,186
if your tags have been
downloaded or are currently


713
00:38:14,186 --> 00:38:16,206
in use or have already
been purged.


714
00:38:16,206 --> 00:38:17,086
This is really useful.


715
00:38:18,896 --> 00:38:21,856
Additionally, if the player
is coming up to a junction


716
00:38:22,406 --> 00:38:24,446
when they'll need
additional resources


717
00:38:24,446 --> 00:38:26,346
and you haven't downloaded
to prepare them yet.


718
00:38:26,616 --> 00:38:28,736
You can modify the
priority of your request.


719
00:38:29,446 --> 00:38:31,606
This means that you can
bump up the loading priority


720
00:38:31,606 --> 00:38:35,346
on the bundle resource request,
it is a scale between 0 and 1


721
00:38:35,346 --> 00:38:38,476
and there is even a constant for
urgent if the user is blocked


722
00:38:38,476 --> 00:38:39,626
and you're trying to download.


723
00:38:40,246 --> 00:38:44,076
We modeled preparing with an
NSOperation queue you can bump


724
00:38:44,076 --> 00:38:48,116
up quality of service there.


725
00:38:48,366 --> 00:38:51,986
Overall in DemoBots we
wanted to do a ton of things,


726
00:38:51,986 --> 00:38:55,276
we really wanted to ship a
sample that showcased a bunch


727
00:38:55,276 --> 00:38:57,296
of different aspects
of developing games


728
00:38:57,296 --> 00:38:58,906
that we thought you would
all be interested in.


729
00:38:59,316 --> 00:39:02,946
So Dave spoke to you initially
about fine tuning your assets


730
00:39:02,946 --> 00:39:06,696
for every device, including
special assets for the Mac.


731
00:39:06,696 --> 00:39:08,576
We talked about elegant
character navigation,


732
00:39:08,576 --> 00:39:10,796
without having to write a
ton of movement code yourself


733
00:39:11,236 --> 00:39:14,976
and finally adding additional
assets to improve gameplay


734
00:39:14,976 --> 00:39:17,776
because now we're
slimming down our app.


735
00:39:17,776 --> 00:39:21,156
I'm excited to say GamePlayKit
has ton of great features


736
00:39:21,156 --> 00:39:23,626
and iOS 9 in general to
help you do these things.


737
00:39:24,526 --> 00:39:25,686
To check out how they're used,


738
00:39:26,046 --> 00:39:29,856
you can download the sample
right now from this link,


739
00:39:29,856 --> 00:39:31,336
I encourage you to do so.


740
00:39:32,676 --> 00:39:35,666
Here are additional
links for documentation,


741
00:39:35,666 --> 00:39:37,476
you can contact our
evangelist Allan.


742
00:39:38,076 --> 00:39:42,076
The related sessions we
mentioned throughout this talk,


743
00:39:42,076 --> 00:39:44,856
they have already happened,
you can catch them online.


744
00:39:46,876 --> 00:39:47,666
Thank you all so much.


745
00:39:48,516 --> 00:39:51,500
[Applause]

