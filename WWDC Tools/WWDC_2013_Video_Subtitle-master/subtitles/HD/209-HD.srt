1
00:00:00,506 --> 00:00:09,516
[ Silence ]


2
00:00:10,016 --> 00:00:12,000
[ Music ]


3
00:00:12,756 --> 00:00:13,396
>> Good morning.


4
00:00:15,386 --> 00:00:17,946
Welcome to "Improving Power
Efficiency with AppNap."


5
00:00:18,346 --> 00:00:20,366
My name is Tony Parker and
I'm a software engineer


6
00:00:20,366 --> 00:00:21,866
on the Cocoa Frameworks
Team at Apple.


7
00:00:22,036 --> 00:00:25,906
So today we're going to
go over three topics.


8
00:00:26,196 --> 00:00:27,606
First, what is AppNap?


9
00:00:28,296 --> 00:00:29,106
Then we're going
to go into a lot


10
00:00:29,106 --> 00:00:31,036
of detail on how AppNap works.


11
00:00:31,686 --> 00:00:33,896
And finally we're going to
cover AppNap and other power


12
00:00:33,896 --> 00:00:35,996
and energy related API.


13
00:00:36,516 --> 00:00:38,686
So first let's talk
about what AppNap is.


14
00:00:39,386 --> 00:00:42,656
So we live in a world
today on OS X


15
00:00:43,016 --> 00:00:45,266
where users expect
both long battery life


16
00:00:45,266 --> 00:00:47,886
and at the same time
high performance


17
00:00:47,886 --> 00:00:49,286
responsive applications.


18
00:00:49,906 --> 00:00:51,606
However, because
it's a multitasking,


19
00:00:51,606 --> 00:00:54,486
multi user operating system,
all apps actually have


20
00:00:54,556 --> 00:00:59,466
about equal access to limited
resources like CPU time, disk IO


21
00:00:59,466 --> 00:01:01,666
and most importantly
for this talk, energy.


22
00:01:02,246 --> 00:01:06,656
So in designing this feature, we
wanted to focus system resources


23
00:01:06,656 --> 00:01:08,716
on the most important user work.


24
00:01:09,406 --> 00:01:12,026
And the benefit of that is going
to be increased battery life


25
00:01:12,366 --> 00:01:14,116
and improved responsiveness.


26
00:01:14,646 --> 00:01:18,536
Now the tricky part of
course is deciding what


27
00:01:18,536 --> 00:01:22,026
that important work is and we do
that with a set of heuristics.


28
00:01:22,476 --> 00:01:24,756
So for example, we look at
whether an application is


29
00:01:24,756 --> 00:01:26,306
in the foreground
- typically the one


30
00:01:26,306 --> 00:01:28,216
with the menu bar -
or the background.


31
00:01:28,956 --> 00:01:31,066
Typically a foreground
application is doing more


32
00:01:31,066 --> 00:01:32,096
important user work.


33
00:01:32,096 --> 00:01:36,406
We also look at the
application type.


34
00:01:36,776 --> 00:01:38,496
So a system daemon


35
00:01:38,496 --> 00:01:41,156
or a background agent is
typically doing less important


36
00:01:41,156 --> 00:01:43,686
work than an application that
the user can actually sort


37
00:01:43,686 --> 00:01:45,916
of see and interact with
on the doc for example.


38
00:01:46,436 --> 00:01:50,516
We can also take into
account the visibility


39
00:01:50,676 --> 00:01:52,956
of your application's
windows on screen.


40
00:01:53,296 --> 00:01:55,966
So an application that has a
window that's completely hidden


41
00:01:55,966 --> 00:02:00,316
by other windows or on another
space that's been moved away is


42
00:02:00,316 --> 00:02:02,196
typically doing less
important work to the user


43
00:02:02,196 --> 00:02:05,506
than the ones it can see
right in front of them.


44
00:02:05,606 --> 00:02:07,356
And also we look at
drawing activity.


45
00:02:07,446 --> 00:02:09,096
So an application
that can update it --


46
00:02:09,096 --> 00:02:11,376
it's updating itself and
displaying new content


47
00:02:11,376 --> 00:02:12,886
to the user, that
might be something


48
00:02:12,886 --> 00:02:14,886
that the user is looking
at and actively watching.


49
00:02:15,116 --> 00:02:17,546
And that would indicate
more important work.


50
00:02:18,936 --> 00:02:20,796
Now even if an application
is completely hidden,


51
00:02:20,796 --> 00:02:23,896
if it's playing audio, that's
obviously also perceptible


52
00:02:23,896 --> 00:02:25,706
to the user so we
count that as well.


53
00:02:25,706 --> 00:02:28,496
And of course, event processing.


54
00:02:28,496 --> 00:02:31,686
User events and events like
hot keys are also considered.


55
00:02:32,296 --> 00:02:36,406
We can also use the existing
I/O Kit Power Searching API.


56
00:02:36,926 --> 00:02:37,876
You might be familiar with this.


57
00:02:37,876 --> 00:02:39,206
It's been on OS X for a while


58
00:02:39,376 --> 00:02:41,146
and it lets you tell
the system you know,


59
00:02:41,146 --> 00:02:43,426
"Don't put the system -- don't
allow the system to idle sleep


60
00:02:43,586 --> 00:02:45,376
because I'm doing something
that I need to finish."


61
00:02:46,396 --> 00:02:49,066
And finally we have a
new set of AppNap APIs


62
00:02:49,856 --> 00:02:52,726
which let you help improve these
heuristics by telling the system


63
00:02:52,726 --> 00:02:54,386
about the kinds of
activities you're doing.


64
00:02:54,386 --> 00:02:58,396
So I want to show you a quick
demo of AppNap in action.


65
00:02:59,446 --> 00:03:01,276
Okay, so here we go.


66
00:03:01,276 --> 00:03:03,476
If you've ever been to a
presentation like this one


67
00:03:03,816 --> 00:03:06,196
and had trouble following what
a presenter like me is doing,


68
00:03:06,536 --> 00:03:07,946
I've got the App here for you.


69
00:03:08,076 --> 00:03:10,276
And it may also be familiar
to some of you old timers.


70
00:03:10,906 --> 00:03:12,716
As you can see, these apps --


71
00:03:12,716 --> 00:03:14,196
they're 2 copies
of the same app.


72
00:03:14,516 --> 00:03:16,626
It's following my mouse as I
move it around the screen here.


73
00:03:17,176 --> 00:03:21,226
And I also have Activity
Monitor open.


74
00:03:21,286 --> 00:03:22,896
And I want to show you a
couple new things we've added


75
00:03:22,896 --> 00:03:26,086
to Activity Monitor that can
really help users understand


76
00:03:26,236 --> 00:03:27,566
where their energy is going.


77
00:03:27,566 --> 00:03:28,626
So there are 2 columns


78
00:03:28,626 --> 00:03:30,096
in particular I want
to focus on here.


79
00:03:30,446 --> 00:03:31,736
First, the AppNap column.


80
00:03:32,026 --> 00:03:32,756
Now you can see that both


81
00:03:32,756 --> 00:03:35,786
of these applications are
-- say "No" right now.


82
00:03:36,236 --> 00:03:37,996
In fact, one of these
applications is completely


83
00:03:37,996 --> 00:03:40,466
unmodified and the other
one I've explicitly modified


84
00:03:40,466 --> 00:03:41,566
to prevent AppNap.


85
00:03:42,166 --> 00:03:44,536
The other column is
the energy impact.


86
00:03:44,896 --> 00:03:47,176
Now you notice that this
column is unitless and that's


87
00:03:47,176 --> 00:03:50,086
because it's really sort of an
aggregate score of the kinds


88
00:03:50,086 --> 00:03:53,286
of things an application can do
that can cause battery drain.


89
00:03:53,886 --> 00:03:56,866
So I mentioned that visibility
is one of the heuristics


90
00:03:56,866 --> 00:03:59,366
that we use for determining
eligibility for AppNap.


91
00:03:59,696 --> 00:04:02,096
So what I'm going to do is
move my Activity Monitor window


92
00:04:02,096 --> 00:04:06,136
in front of these other
two windows and we'll see


93
00:04:06,136 --> 00:04:09,306
after a few seconds the
system will decide that one


94
00:04:09,306 --> 00:04:11,436
of these apps - the one
that was unmodified -


95
00:04:11,856 --> 00:04:13,996
can go into that AppNap state.


96
00:04:13,996 --> 00:04:16,146
And that's going to
reduce its energy impact


97
00:04:16,716 --> 00:04:18,685
to a much lower level.


98
00:04:18,685 --> 00:04:20,616
In fact here you
see it's at zero.


99
00:04:21,546 --> 00:04:23,356
However, if I just - you
know - move my window


100
00:04:23,356 --> 00:04:25,676
out of the way a little
bit, you see both windows --


101
00:04:25,676 --> 00:04:28,226
or both applications still
appear responsive to the user.


102
00:04:29,036 --> 00:04:32,146
And so the idea here is to
not interrupt user's work


103
00:04:32,186 --> 00:04:34,926
but instead focus in this
case the battery life


104
00:04:34,926 --> 00:04:37,406
on the applications that
are doing important work.


105
00:04:37,786 --> 00:04:39,716
And we'll see what a difference
this makes in a little bit.


106
00:04:39,716 --> 00:04:42,676
Now let's go back to our slides.


107
00:04:42,676 --> 00:04:45,256
So let's go into some
detail on how all


108
00:04:45,256 --> 00:04:46,686
of this AppNap is working.


109
00:04:47,266 --> 00:04:50,326
So first I want to define
a couple terms that we sort


110
00:04:50,626 --> 00:04:52,176
of tend to throw around
a little bit loosely.


111
00:04:52,536 --> 00:04:56,116
Power: so power is actually
a rate and it's the rate


112
00:04:56,116 --> 00:04:57,356
at which energy is consumed.


113
00:04:57,616 --> 00:04:59,526
One way to measure
that would be in watts.


114
00:04:59,526 --> 00:05:03,836
Energy on the other hand is the
stored potential to do work.


115
00:05:04,096 --> 00:05:06,576
And one way to measure that
might be in watt hours.


116
00:05:06,946 --> 00:05:09,706
So for example let's say I
have a 50 watt hour battery


117
00:05:10,026 --> 00:05:12,706
and I want a 7 hour battery
life from that battery.


118
00:05:13,056 --> 00:05:16,466
Well I can do some simple
division: 50 watt hours divided


119
00:05:16,466 --> 00:05:20,336
by 7 hours and that gives me
a rate of about 7.1 watts.


120
00:05:20,796 --> 00:05:24,226
So what that means is that if
I'm using more than 7.1 watts,


121
00:05:24,516 --> 00:05:26,746
my battery life will
be less than 7 hours.


122
00:05:27,026 --> 00:05:29,526
And if I use less
than 7.1 watts,


123
00:05:29,736 --> 00:05:32,366
I will get a longer battery
life of above 7 hours.


124
00:05:33,266 --> 00:05:36,706
Now this 7.1 watts has to power
the entire system on a laptop.


125
00:05:36,936 --> 00:05:40,386
That includes the screen and
the backlight, the GPU, network,


126
00:05:40,386 --> 00:05:42,906
storage, memory and finally CPU.


127
00:05:43,786 --> 00:05:45,236
Now you may look at
this list and think,


128
00:05:45,236 --> 00:05:46,796
"There's some big
ticket items on there


129
00:05:47,086 --> 00:05:48,746
like the screen and the GPU."


130
00:05:49,056 --> 00:05:49,906
And you'd be right.


131
00:05:50,056 --> 00:05:51,926
Those do use a significant
amount of power.


132
00:05:52,276 --> 00:05:54,956
However today we're going
to focus instead on the CPU.


133
00:05:55,246 --> 00:05:56,176
And that's for two reasons.


134
00:05:56,526 --> 00:05:59,026
First, as software engineers,
this is the thing we're going


135
00:05:59,026 --> 00:06:00,356
to have the most impact on.


136
00:06:00,776 --> 00:06:02,146
But second and most importantly,


137
00:06:02,146 --> 00:06:04,926
the CPU actually has the
highest dynamic range


138
00:06:05,036 --> 00:06:06,316
out of all of these components.


139
00:06:06,786 --> 00:06:08,726
So let me show you
what I mean by that.


140
00:06:09,736 --> 00:06:12,736
If we look at the power
usage of a modern Intel chip,


141
00:06:13,336 --> 00:06:15,536
you can see at its most
idle state we can use


142
00:06:15,536 --> 00:06:17,296
as little as 0.4 watts.


143
00:06:18,316 --> 00:06:20,286
However, if we're
executing any code at all


144
00:06:20,286 --> 00:06:21,756
at the nominal frequency
of the chip,


145
00:06:22,256 --> 00:06:24,476
we're going to go all
the way up to 15 watts.


146
00:06:24,936 --> 00:06:26,686
Now this is just for the CPU.


147
00:06:27,066 --> 00:06:29,946
So here you can see, if
we had a budget of 7 watts


148
00:06:30,076 --> 00:06:32,776
and we're running a 15
watt CPU, we're not going


149
00:06:32,776 --> 00:06:34,836
to get the battery life
of 7 hours that we wanted.


150
00:06:35,336 --> 00:06:37,556
And furthermore, if we're
running at turbo frequencies,


151
00:06:37,836 --> 00:06:40,046
then it goes all the
way up to 25 watts.


152
00:06:40,916 --> 00:06:44,386
So there's a gigantic difference
between the low power idle state


153
00:06:44,656 --> 00:06:47,416
and the high power executing
code or turbo states.


154
00:06:47,896 --> 00:06:49,666
And so that leads us
into the three key rules


155
00:06:49,666 --> 00:06:50,836
of extending battery life.


156
00:06:51,276 --> 00:06:52,606
The first is that
we need to stay


157
00:06:52,606 --> 00:06:56,276
at that low power 0.4 watt
idle state as long as possible.


158
00:06:56,916 --> 00:07:00,366
And to do that - Number 2 - we
need to avoid unnecessary work


159
00:07:00,726 --> 00:07:02,546
like drawing a pair of
eyes in the background


160
00:07:02,546 --> 00:07:03,506
when you can't even see them.


161
00:07:04,066 --> 00:07:07,436
And third, when we do work
which is okay from time to time


162
00:07:07,436 --> 00:07:09,986
if the user's asked us to
do it, we need to return


163
00:07:09,986 --> 00:07:12,996
to that idle state as quickly as
possible so that we can remain


164
00:07:12,996 --> 00:07:14,606
in that 0.4 watt idle state.


165
00:07:15,146 --> 00:07:18,206
Now you might be surprised


166
00:07:18,206 --> 00:07:20,536
at how quickly we can actually
switch between these states.


167
00:07:20,766 --> 00:07:21,906
So here I've got a use case


168
00:07:21,906 --> 00:07:25,936
of visiting the www.Apple.com
website in Safari on Wi-Fi


169
00:07:25,936 --> 00:07:28,036
on my demo machine, and
what I've graphed here


170
00:07:28,036 --> 00:07:30,666
on the vertical axis
is CPU activity.


171
00:07:30,906 --> 00:07:32,486
This is not the same
as CPU time.


172
00:07:32,716 --> 00:07:36,236
For one thing, it's the whole
CPU: not just one process.


173
00:07:36,236 --> 00:07:38,116
And also, it's more
a measurement


174
00:07:38,116 --> 00:07:40,576
of how long we could stay
in that idle state instead


175
00:07:40,576 --> 00:07:42,436
of how much time
we were executing.


176
00:07:42,876 --> 00:07:44,456
So at the bottom
at zero percent,


177
00:07:44,726 --> 00:07:47,066
that's our most idle state
for the entire sample period:


178
00:07:47,066 --> 00:07:48,116
that's the lowest power.


179
00:07:48,466 --> 00:07:51,346
And at the top, 100 percent
would be the least idle,


180
00:07:51,446 --> 00:07:53,626
executing all the time
during the sample interval.


181
00:07:54,206 --> 00:07:58,216
So here's what it looked like.


182
00:07:59,016 --> 00:08:02,236
At the beginning, I was typing
Apple.com into the address bar


183
00:08:02,336 --> 00:08:04,596
and so that's not just the key
presses that we need to handle:


184
00:08:04,596 --> 00:08:07,736
that also includes Auto Complete
or looking up bookmarks,


185
00:08:08,036 --> 00:08:10,656
drawing the actual menu
on screen and so forth.


186
00:08:11,606 --> 00:08:13,866
This vertical spike here
is where I've hit Enter


187
00:08:13,866 --> 00:08:15,636
and we began downloading
the webpage


188
00:08:15,736 --> 00:08:16,896
and rendering the content.


189
00:08:17,366 --> 00:08:19,036
Now what's interesting
about this, is if you look


190
00:08:19,036 --> 00:08:21,706
at the number there, we're
still at this time at the peak


191
00:08:21,706 --> 00:08:23,296
of the activity of
this use case.


192
00:08:23,776 --> 00:08:25,826
Over 50 percent of
the time is spent


193
00:08:25,826 --> 00:08:27,806
at our most idle
state in the CPU.


194
00:08:27,936 --> 00:08:30,396
So that indicates just how
quickly we can transition.


195
00:08:31,326 --> 00:08:32,556
And finally near the end here is


196
00:08:32,556 --> 00:08:35,246
when the data has finished
coming in - asynchronously


197
00:08:35,246 --> 00:08:37,366
of course - and the
rendering has been finished.


198
00:08:37,576 --> 00:08:39,986
And we've tried to move as
close to as much as idle


199
00:08:39,986 --> 00:08:41,645
as possible when that's done.


200
00:08:42,456 --> 00:08:46,256
Now let's compare this with
our Eyes Demo Application


201
00:08:46,846 --> 00:08:47,556
that we just saw.


202
00:08:48,296 --> 00:08:51,416
So you can see here, the Eyes
Application only lets the CPU


203
00:08:51,416 --> 00:08:54,376
stay in its most idle state
about 75 percent of the time.


204
00:08:54,816 --> 00:08:58,106
So that application - while
hidden behind another window -


205
00:08:58,436 --> 00:09:01,976
is using significantly
more energy than Safari,


206
00:09:01,976 --> 00:09:03,496
rendering an entire webpage.


207
00:09:04,076 --> 00:09:06,886
So even small applications
can have a large impact


208
00:09:06,986 --> 00:09:08,476
on battery life and energy.


209
00:09:09,016 --> 00:09:13,386
And you know, this is what
it was doing: polling.


210
00:09:14,056 --> 00:09:16,986
The whole time, just polling,
checking where the mouse was,


211
00:09:17,076 --> 00:09:19,546
redrawing where the eyes
needed to be and so forth.


212
00:09:20,036 --> 00:09:22,866
And we can actually
do better than this.


213
00:09:23,076 --> 00:09:26,846
So why would we exit the idle
state when there's work to do?


214
00:09:26,936 --> 00:09:28,976
Well so for Safari, when
it was receiving data,


215
00:09:28,976 --> 00:09:30,026
that's network activity.


216
00:09:30,026 --> 00:09:31,786
That's a good reason to
wake up and do something.


217
00:09:32,276 --> 00:09:35,386
Or when I was typing
Apple.com into the address bar,


218
00:09:35,686 --> 00:09:37,566
that's another reason that
we might be doing some work.


219
00:09:38,136 --> 00:09:41,466
We can actually transition
pretty fast between these states


220
00:09:41,466 --> 00:09:45,406
such that disk I/O is a good
opportunity to save some energy.


221
00:09:46,696 --> 00:09:48,136
And finally and most
importantly,


222
00:09:48,396 --> 00:09:50,316
we exit idle because of timers.


223
00:09:50,396 --> 00:09:52,276
And when we were
investigating this feature,


224
00:09:52,276 --> 00:09:56,306
we found out that timers were
by far the Number 1 reason


225
00:09:56,306 --> 00:09:57,486
to exit the idle state.


226
00:09:58,296 --> 00:10:00,116
And that's because
there's so much API


227
00:10:00,116 --> 00:10:01,586
that actually involves timers.


228
00:10:02,046 --> 00:10:03,236
That's everything
with a relative


229
00:10:03,236 --> 00:10:04,396
or an absolute deadline.


230
00:10:05,506 --> 00:10:08,056
So for example, NSTimer,
CF run loop timer,


231
00:10:08,206 --> 00:10:09,616
dispatch source type timer.


232
00:10:09,876 --> 00:10:13,176
These timers are both -- can
be both relative or absolute.


233
00:10:13,686 --> 00:10:18,216
An API like sleep: let's
say we sleep for 1 second.


234
00:10:18,216 --> 00:10:21,426
Well that means in 1 second, the
CPU has to exit the idle state,


235
00:10:21,466 --> 00:10:23,446
wake up and continue
executing code.


236
00:10:24,016 --> 00:10:27,656
It also includes
APIs with time outs


237
00:10:27,746 --> 00:10:30,096
like pthread-cond-timedwait
and so forth.


238
00:10:31,346 --> 00:10:34,396
And APIs built on top of
these like Perform Selector


239
00:10:34,396 --> 00:10:37,656
with object after delay or
NS Run Loop run until date.


240
00:10:37,916 --> 00:10:38,876
That last one?


241
00:10:39,076 --> 00:10:40,456
Sometimes you see a
pattern of putting


242
00:10:40,456 --> 00:10:42,436
that with a short timeout
inside of a wild loop.


243
00:10:42,776 --> 00:10:44,296
So that would indicate
a lot of timers.


244
00:10:46,186 --> 00:10:47,306
And many more.


245
00:10:49,506 --> 00:10:52,456
So when developing AppNap,
we realized that in order


246
00:10:52,456 --> 00:10:55,166
to effectively extend the
battery life of our laptops,


247
00:10:55,546 --> 00:10:57,466
we needed to reduce
the impact of timers.


248
00:10:57,736 --> 00:10:59,276
And we've done that
with two approaches.


249
00:10:59,566 --> 00:11:01,206
The first is timer coalescing


250
00:11:01,276 --> 00:11:03,356
and the second is
timer rate limiting.


251
00:11:03,826 --> 00:11:05,346
Let's talk about
coalescing first.


252
00:11:05,346 --> 00:11:07,086
So here I have another
graph for you.


253
00:11:07,426 --> 00:11:09,456
On the vertical axis,
I'm graphing power.


254
00:11:09,456 --> 00:11:11,416
So the idle state of the CPU.


255
00:11:11,656 --> 00:11:14,516
And then on the horizontal
axis, we've got time.


256
00:11:14,516 --> 00:11:16,476
And here you see the time
scale's pretty short:


257
00:11:16,796 --> 00:11:18,456
about 150 milliseconds.


258
00:11:18,976 --> 00:11:22,026
Now I've set up 4
timers and T1 through T4.


259
00:11:22,026 --> 00:11:25,076
The width of that line
represents the time I spent


260
00:11:25,286 --> 00:11:25,926
doing work.


261
00:11:26,106 --> 00:11:28,816
Because of that timer fired,
we needed to do something.


262
00:11:29,416 --> 00:11:31,076
Now I said earlier that
we could transition


263
00:11:31,076 --> 00:11:33,026
between that 0.4 watt idle state


264
00:11:33,286 --> 00:11:35,976
and the high power executing
code state very rapidly.


265
00:11:36,246 --> 00:11:38,976
And that's true but
it's not instantaneous.


266
00:11:39,286 --> 00:11:41,556
There's actually a ramp
up and a ramp down time


267
00:11:41,956 --> 00:11:44,336
between the idle state
and the high power state.


268
00:11:45,406 --> 00:11:47,746
And while we're doing
that ramp up or ramp down,


269
00:11:47,746 --> 00:11:50,426
we're doing absolutely zero
useful work for the user.


270
00:11:50,796 --> 00:11:52,176
So that's overhead.


271
00:11:52,256 --> 00:11:55,446
And in fact, because there's a
time, you can see from the slope


272
00:11:55,446 --> 00:11:58,776
of the line between T1 and
T2, there's not enough time


273
00:11:58,776 --> 00:12:02,816
between that deadline to go
to our lowest power state.


274
00:12:02,996 --> 00:12:05,516
So instead, we choose
something a little bit less.


275
00:12:05,766 --> 00:12:09,646
And the same thing
happens between T2 and T3.


276
00:12:10,026 --> 00:12:12,976
However, if we look at
the T3 and T4 timers,


277
00:12:13,226 --> 00:12:14,676
you can see they're right
up next to each other.


278
00:12:14,676 --> 00:12:16,846
And that's something that
we can take advantage of.


279
00:12:17,296 --> 00:12:20,036
So what we've done with timer
coalescing is apply a small


280
00:12:20,036 --> 00:12:23,336
delay to timers to sort
of push them together.


281
00:12:23,336 --> 00:12:27,146
And the result is that we can
ramp up once and ramp down once.


282
00:12:27,436 --> 00:12:30,186
And according to our rules
of extending battery life,


283
00:12:30,476 --> 00:12:32,856
we can stay in the
idle state much longer.


284
00:12:33,216 --> 00:12:35,216
And if we compare it to
our previous graph here,


285
00:12:35,616 --> 00:12:38,076
you can see that these areas
represent saved energy.


286
00:12:38,366 --> 00:12:40,806
That was work that we just
didn't have to do transitioning


287
00:12:40,806 --> 00:12:42,276
between states because
again remember,


288
00:12:42,276 --> 00:12:43,826
we're not doing any
useful work there.


289
00:12:43,826 --> 00:12:47,446
Now I said that the width


290
00:12:47,446 --> 00:12:50,506
of that line represented
the work that the timer did.


291
00:12:50,766 --> 00:12:52,376
And we call that a
Second Order Effect.


292
00:12:52,376 --> 00:12:54,226
So what happens after
the timer fires?


293
00:12:54,536 --> 00:12:56,796
So that you might do -
this one seems obvious -


294
00:12:56,796 --> 00:13:00,496
you might use the CPU but you
could also turn on the screen


295
00:13:00,956 --> 00:13:03,296
or do some drawing
like the Eyes App does.


296
00:13:03,296 --> 00:13:05,006
That involves the GPU
which means we have


297
00:13:05,006 --> 00:13:06,246
to power that up as well.


298
00:13:07,666 --> 00:13:10,906
Sending data over Wi-Fi means we
have to power up Wi-Fi radios.


299
00:13:11,316 --> 00:13:13,136
Writing to disk or
writing to memory,


300
00:13:13,396 --> 00:13:15,076
all of these have energy costs.


301
00:13:15,616 --> 00:13:17,916
So in addition to
the coalescing,


302
00:13:17,916 --> 00:13:21,026
we wanted to reduce the impact
of second order effects as well.


303
00:13:21,526 --> 00:13:23,946
And to do that, we're
doing timer rate limiting.


304
00:13:24,936 --> 00:13:27,536
So here is a similar graphic
except that I've zoomed way out.


305
00:13:27,536 --> 00:13:29,976
So you see here that the
horizontal scale is on the order


306
00:13:29,976 --> 00:13:31,306
of seconds at this time.


307
00:13:31,626 --> 00:13:33,886
And what I have here is a
1 second repeating timer


308
00:13:34,116 --> 00:13:37,086
and the width of each of these
bumps represents the second


309
00:13:37,086 --> 00:13:39,306
order effect of the work
that's being done every time


310
00:13:39,306 --> 00:13:40,206
that timer fires.


311
00:13:40,636 --> 00:13:42,256
This is a very similar
pattern to what we see


312
00:13:42,256 --> 00:13:44,536
in the Eyes Demo app except
there it's actually much


313
00:13:44,536 --> 00:13:45,176
more frequent.


314
00:13:45,546 --> 00:13:48,066
So timer rate limiting
pushes out the frequency --


315
00:13:48,066 --> 00:13:51,586
excuse me -- reduces the
frequency of this timer firing.


316
00:13:52,186 --> 00:13:56,626
And what that does is -- I mean
the timer's still going to fire,


317
00:13:56,626 --> 00:13:58,076
but we're just going
to fire it less often.


318
00:13:58,216 --> 00:14:02,786
And what that does is you
see here reduce the impact


319
00:14:02,786 --> 00:14:03,856
of the second order effect.


320
00:14:03,856 --> 00:14:06,176
So all that area is
also saved energy.


321
00:14:06,536 --> 00:14:08,526
And this can have a really
big impact over time.


322
00:14:09,186 --> 00:14:12,026
A couple more details.


323
00:14:12,026 --> 00:14:14,286
The coalescing delay
again is on the order


324
00:14:14,286 --> 00:14:15,526
of about a hundred milliseconds.


325
00:14:15,766 --> 00:14:17,736
And this is actually about
the same as delay due


326
00:14:17,736 --> 00:14:18,826
to normal system load.


327
00:14:19,046 --> 00:14:21,576
So in all previous
releases of OS X,


328
00:14:21,576 --> 00:14:23,196
even if you thought
your timer fired exactly


329
00:14:23,196 --> 00:14:26,156
when you asked it to, in fact if
there was a high priority thread


330
00:14:26,436 --> 00:14:27,946
or some other work
on the run loop,


331
00:14:28,096 --> 00:14:30,266
it could have been the case
that you actually fired later


332
00:14:30,266 --> 00:14:31,956
than you did -- you
thought you did anyway.


333
00:14:32,426 --> 00:14:34,396
Now we've designed this
based on heuristics


334
00:14:34,396 --> 00:14:35,886
to be undetectable to the user.


335
00:14:36,216 --> 00:14:38,966
The rate limiting delay
on the other hand is


336
00:14:38,966 --> 00:14:40,126
on the order of seconds.


337
00:14:40,896 --> 00:14:41,836
Now in both cases though,


338
00:14:41,836 --> 00:14:44,436
we do not fire timers
early: we only delay them.


339
00:14:45,286 --> 00:14:47,826
And the exact delays are going
to depend on the heuristics


340
00:14:47,826 --> 00:14:50,846
so that we can provide a
consistent user experience.


341
00:14:51,346 --> 00:14:54,206
And finally, some of these
behaviors are configurable.


342
00:14:54,406 --> 00:14:56,616
And I'll show you how to
do that a little bit later.


343
00:14:57,616 --> 00:15:00,886
But first I want to talk
about why: what's the result?


344
00:15:00,886 --> 00:15:04,846
The end game in doing all of
this changing around timers?


345
00:15:05,286 --> 00:15:07,966
So let's look again at this
graph for our Eyes Demo.


346
00:15:07,966 --> 00:15:09,436
Again, this is CPU activity.


347
00:15:09,936 --> 00:15:13,706
So here at about 25 percent
again is the Eyes app hidden


348
00:15:13,706 --> 00:15:17,126
behind my activity monitor, but
with AppNap explicitly disabled.


349
00:15:17,816 --> 00:15:19,436
And here is the same app,


350
00:15:19,656 --> 00:15:22,256
hidden behind Activity
Monitor, with AppNap enabled.


351
00:15:23,146 --> 00:15:24,976
And you can see that
these vertical bumps here


352
00:15:24,976 --> 00:15:27,336
in the bottom line represent
the timer rate limiting.


353
00:15:27,336 --> 00:15:30,236
That's where we allow the app
to continue to do some work.


354
00:15:30,896 --> 00:15:32,346
Now looking at this
graph you might think


355
00:15:32,666 --> 00:15:35,306
that that doesn't seem like
much of a difference, right?


356
00:15:35,306 --> 00:15:37,126
We're both -- that's
only 25 percent.


357
00:15:37,126 --> 00:15:38,106
That's not a huge number.


358
00:15:38,616 --> 00:15:42,136
But if I were a user using on
my demo machine here the iZap


359
00:15:42,136 --> 00:15:43,246
in the way I just described,


360
00:15:43,976 --> 00:15:45,866
running it behind another
window is actually going


361
00:15:45,866 --> 00:15:47,956
to cost me 1 hour
of battery life.


362
00:15:48,446 --> 00:15:52,706
So the timer rate limiting
and timer coalescing


363
00:15:52,706 --> 00:15:56,296
and other activities that AppNap
does can make a really big


364
00:15:56,296 --> 00:15:57,976
difference for even the
smallest kinds of applications.


365
00:16:03,336 --> 00:16:05,416
So one way to actually
improve this even further is


366
00:16:05,416 --> 00:16:07,376
if in your applications
you think about switching


367
00:16:07,376 --> 00:16:10,846
from timer based APIs
to event based APIs.


368
00:16:11,406 --> 00:16:13,866
So instead of polling
key presses


369
00:16:13,866 --> 00:16:16,236
or mouse locations, use events.


370
00:16:17,086 --> 00:16:19,466
And instead of repeatedly
checking file content,


371
00:16:19,736 --> 00:16:21,496
sometimes we see this as a form


372
00:16:21,496 --> 00:16:24,666
of making sure an application
is updated or a form


373
00:16:24,666 --> 00:16:26,326
of communicating
between applications.


374
00:16:26,736 --> 00:16:29,836
So instead of doing that, you
use FS Events dispatch sources


375
00:16:29,836 --> 00:16:33,746
which can tell you about files
changing or real IPC mechanisms


376
00:16:33,746 --> 00:16:35,106
like NSXPC Connection.


377
00:16:35,516 --> 00:16:37,256
Or if you're a - you
know - Cocoa level app,


378
00:16:37,256 --> 00:16:38,826
you can use File
Coordination as well.


379
00:16:39,376 --> 00:16:43,136
And finally, instead of
timer based synchronization,


380
00:16:43,206 --> 00:16:44,716
use Semaphores or other locks.


381
00:16:45,066 --> 00:16:47,066
So another pattern that
we've seen is an application


382
00:16:47,066 --> 00:16:47,816
with 2 threads.


383
00:16:48,146 --> 00:16:50,986
One thread does some work and
then sets a global Boolean flag


384
00:16:50,986 --> 00:16:53,246
and the second thread
does a sweep


385
00:16:53,296 --> 00:16:54,626
and checks the flag repeatedly.


386
00:16:54,976 --> 00:16:56,496
And that's energy inefficient.


387
00:16:56,496 --> 00:17:00,146
So we actually have an
entire talk about these kinds


388
00:17:00,146 --> 00:17:02,056
of patterns and ways
that you can do better.


389
00:17:02,346 --> 00:17:06,776
That is tomorrow at 10:15 in
Marina, "Energy Best Practices."


390
00:17:07,296 --> 00:17:09,746
But first, I want to show you
an example of the first thing.


391
00:17:09,746 --> 00:17:12,796
So instead of polling mouse
locations using events.


392
00:17:12,796 --> 00:17:13,776
So we're going to go ahead


393
00:17:13,776 --> 00:17:15,665
and prove the Eyes
application to do this.


394
00:17:16,675 --> 00:17:18,766
Alright, so here I
have the source code


395
00:17:18,766 --> 00:17:20,776
that you've all been waiting
for, for the Eyes application.


396
00:17:21,076 --> 00:17:22,726
Today though, we're
going to focus


397
00:17:22,726 --> 00:17:23,836
on the application Delegate.


398
00:17:24,346 --> 00:17:25,326
And let's start here


399
00:17:25,326 --> 00:17:27,236
in the application did
finish launching method.


400
00:17:28,445 --> 00:17:32,726
Now what you can see here is
that we are setting up a timer


401
00:17:33,276 --> 00:17:35,316
with a timer interval
of 60 hertz.


402
00:17:35,956 --> 00:17:38,676
And when that timer
fires, we are going


403
00:17:38,676 --> 00:17:40,336
to call the Timer Fired Method


404
00:17:40,626 --> 00:17:42,046
and of course it's
a repeating timer.


405
00:17:42,456 --> 00:17:43,936
Now maybe I picked 60 hertz


406
00:17:43,936 --> 00:17:46,616
because I wanted a smooth 60
frames per second animation


407
00:17:46,996 --> 00:17:48,876
but anyway, that's a
pretty frequent timer.


408
00:17:49,766 --> 00:17:50,786
And of course I add this timer


409
00:17:50,786 --> 00:17:53,826
to my main run loop
so that it fires.


410
00:17:54,466 --> 00:17:56,856
Now when it fires we call
this method Timer Fired


411
00:17:57,196 --> 00:17:58,926
and you can see it
calls another method


412
00:17:58,926 --> 00:18:00,526
which is Update Mouse Locations.


413
00:18:00,956 --> 00:18:05,106
And here what we do is you
grab the current mouse location


414
00:18:05,106 --> 00:18:07,966
from NS Event and
we set up that --


415
00:18:07,966 --> 00:18:11,256
we pass that information
along to our 2 views that are


416
00:18:11,256 --> 00:18:12,826
in the application:
one for each eye.


417
00:18:13,466 --> 00:18:19,756
So I'm going to go ahead and run
this again and we can see Eyes


418
00:18:19,756 --> 00:18:20,606
over here in the corner.


419
00:18:20,706 --> 00:18:23,316
We'll leave it there so we
can watch it watching us


420
00:18:23,546 --> 00:18:24,096
through the demo.


421
00:18:24,096 --> 00:18:27,886
And I want to show you a new
feature in Xcode as well.


422
00:18:27,886 --> 00:18:30,006
So here is our new energy gauge.


423
00:18:30,306 --> 00:18:32,536
And this is going to be
a really critical tool


424
00:18:32,536 --> 00:18:35,096
for understanding the energy
impact of your application.


425
00:18:35,776 --> 00:18:38,316
So you can see up
here in the CPU area,


426
00:18:38,676 --> 00:18:41,336
we're in the single digit
percentage for CPU usage,


427
00:18:41,516 --> 00:18:44,646
but the energy impact of this
application is actually very


428
00:18:44,646 --> 00:18:45,566
high or high.


429
00:18:46,876 --> 00:18:47,976
So this number up here


430
00:18:47,976 --> 00:18:49,946
in the upper right corner
represents the number


431
00:18:49,946 --> 00:18:51,256
of wakes in the last second.


432
00:18:51,656 --> 00:18:54,296
So that means that's the number
of times the CPU had to move


433
00:18:54,296 --> 00:18:55,766
from that lower power idle state


434
00:18:56,076 --> 00:18:59,806
to the high power executing
code state just for this app.


435
00:19:01,696 --> 00:19:04,696
In the middle we see a graph
representing energy impact.


436
00:19:05,716 --> 00:19:07,946
The blue area is what I
was referring to earlier


437
00:19:07,946 --> 00:19:09,136
as a second order effect.


438
00:19:09,136 --> 00:19:11,676
So that's the work that
Eyes was actually doing


439
00:19:12,486 --> 00:19:13,496
when the timer fired.


440
00:19:13,826 --> 00:19:15,886
In this case, this app is
actually pretty inefficient


441
00:19:16,166 --> 00:19:19,136
so that second order effect
is dwarfing everything else.


442
00:19:19,466 --> 00:19:21,836
But that little red
area at the top


443
00:19:21,836 --> 00:19:24,686
that you might see is what we
call the CPU Wake Overhead.


444
00:19:24,906 --> 00:19:28,536
And that represents the overhead
of just having a timer at all.


445
00:19:29,066 --> 00:19:31,076
So let's see how we can
improve the Eyes application


446
00:19:31,356 --> 00:19:34,596
to reduce some of this impact
because as you can see here,


447
00:19:34,596 --> 00:19:36,096
I'm not moving my mouse at all,


448
00:19:36,096 --> 00:19:37,886
and yet we're still
using plenty of energy.


449
00:19:42,056 --> 00:19:43,926
So I have a branch
ready to show you that.


450
00:19:53,166 --> 00:19:54,306
So let's scroll down again


451
00:19:54,306 --> 00:19:56,166
to our Application Did
Finish Launching method


452
00:19:56,406 --> 00:19:58,286
and now you notice it's
much shorter and that's


453
00:19:58,286 --> 00:19:59,286
because I deleted the timer.


454
00:19:59,286 --> 00:20:01,906
In its place, I'm
using Event Monitor.


455
00:20:02,256 --> 00:20:05,156
Now this is an API that
was added all the way back


456
00:20:05,206 --> 00:20:08,526
when we used cats for code
names and - Snow Leopard


457
00:20:08,526 --> 00:20:12,316
in particular - and it's
called A Global Event Monitor


458
00:20:12,316 --> 00:20:13,346
and A Local Event Monitor.


459
00:20:13,516 --> 00:20:14,576
So we have one of each.


460
00:20:14,576 --> 00:20:17,106
The Global Event
Monitor tells us


461
00:20:17,456 --> 00:20:20,956
when an event happens
anywhere on the system


462
00:20:21,246 --> 00:20:22,976
and the local one is
for events in our app.


463
00:20:23,366 --> 00:20:25,406
So for this particular
app, I wanted to use both.


464
00:20:25,466 --> 00:20:27,846
And you can see, I've
registered for notifications


465
00:20:27,846 --> 00:20:29,956
about pretty much every kind
of mouse event there is.


466
00:20:30,376 --> 00:20:33,676
But in any case, I
do the same thing


467
00:20:33,676 --> 00:20:35,976
which is called the same
Update Mouse Locations Method


468
00:20:35,976 --> 00:20:36,856
that we saw earlier.


469
00:20:37,456 --> 00:20:38,626
And that's the only
change I've made.


470
00:20:38,626 --> 00:20:40,166
Let's go ahead and
run this again.


471
00:20:40,796 --> 00:20:44,346
And I'll bring up
my energy gauge.


472
00:20:45,256 --> 00:20:47,756
And you'll see if I move
my mouse around some more -


473
00:20:47,806 --> 00:20:51,886
and Eyes is following it here -
we still see our energy impact.


474
00:20:52,156 --> 00:20:53,896
But look at the difference
up here in the right corner


475
00:20:53,896 --> 00:20:55,256
with the wakes in
the last second.


476
00:20:55,746 --> 00:20:58,136
So if the CPU is already awake
processing the mouse moved


477
00:20:58,136 --> 00:21:02,046
event, that means a lot less
overhead transition time


478
00:21:02,046 --> 00:21:04,506
because now we're just doing
the work along with that.


479
00:21:05,566 --> 00:21:07,526
And better still,
if I stop moving,


480
00:21:08,916 --> 00:21:11,396
in general this app is going
to go to a steady state


481
00:21:11,396 --> 00:21:13,446
of about zero wakes
in the last second.


482
00:21:13,776 --> 00:21:16,796
You might see a few bumps or
blips in this graph and that's


483
00:21:16,796 --> 00:21:19,176
because libraries or system
frameworks may be doing things


484
00:21:19,176 --> 00:21:22,366
on your behalf that aren't
specifically in the application.


485
00:21:22,366 --> 00:21:23,136
So those are normal.


486
00:21:23,596 --> 00:21:26,386
But ultimately what we
want to see is zero wakes


487
00:21:26,386 --> 00:21:28,656
in the last second,
zero CPU usage.


488
00:21:28,976 --> 00:21:31,196
A steady state of zero is
the best state for energy.


489
00:21:31,726 --> 00:21:35,246
But if I keep moving
my mouse again here,


490
00:21:35,736 --> 00:21:38,086
you see that Eyes became
responsive right away.


491
00:21:38,986 --> 00:21:40,686
So we didn't lose any
functionality in this app


492
00:21:40,686 --> 00:21:42,906
but it's significantly
better for energy.


493
00:21:43,206 --> 00:21:44,476
I want to show you
one more thing though.


494
00:21:44,476 --> 00:21:47,266
I'm just going to go ahead
and drag my [inaudible] window


495
00:21:47,266 --> 00:21:49,536
over here to hide the
Eyes app and I'm going


496
00:21:49,536 --> 00:21:50,556
to move my mouse around.


497
00:21:51,596 --> 00:21:52,806
Now what you can see here is


498
00:21:52,806 --> 00:21:54,586
that we still actually
have an energy impact.


499
00:21:55,016 --> 00:21:57,276
And that's because Eyes is
still receiving those events


500
00:21:57,276 --> 00:21:59,536
in the background, even
though we can't see it.


501
00:21:59,726 --> 00:22:01,986
So this is something that we
can actually improve with some


502
00:22:01,986 --> 00:22:03,316
of the new API that we've added.


503
00:22:03,316 --> 00:22:04,886
So let's go back to our slides


504
00:22:04,886 --> 00:22:07,126
and we'll talk about
how to do that.


505
00:22:09,796 --> 00:22:11,006
So before I move on though,


506
00:22:11,006 --> 00:22:12,796
I want to say a few words
about responsiveness.


507
00:22:13,106 --> 00:22:16,546
I promised earlier at the talk
that AppNap is about both energy


508
00:22:16,656 --> 00:22:18,276
or battery life and
responsiveness.


509
00:22:18,726 --> 00:22:19,966
The idea behind this is


510
00:22:19,966 --> 00:22:22,466
that important work should
have higher priority.


511
00:22:22,806 --> 00:22:24,746
And we can use some of the same
heuristics that we've talked


512
00:22:24,746 --> 00:22:28,546
about to decide which
work that is.


513
00:22:29,106 --> 00:22:34,356
So what we can do is allow apps
or excuse me, put apps that are


514
00:22:34,356 --> 00:22:38,096
in AppNap into a lower
priority for both I/O and NCPU.


515
00:22:38,436 --> 00:22:40,566
So for example, let's say that
I'm editing my presentation


516
00:22:40,566 --> 00:22:42,656
in keynote and an
AutoSave begins.


517
00:22:43,056 --> 00:22:44,356
Well that's the foreground app:


518
00:22:44,506 --> 00:22:46,056
the one I'm currently
interacting with.


519
00:22:46,506 --> 00:22:48,396
I think we'd all agree that --


520
00:22:48,516 --> 00:22:51,756
AutoSave's I/O should happen
first before any other kind


521
00:22:51,756 --> 00:22:54,686
of like background work
like Logging to Disk


522
00:22:54,686 --> 00:22:57,086
or some other kind of thing that
I can't even tell is going on.


523
00:22:57,156 --> 00:22:59,396
So that's the idea
behind I/O prioritization.


524
00:22:59,886 --> 00:23:02,216
For CPU, we're going to
lower the priority of apps


525
00:23:02,216 --> 00:23:05,696
in AppNap lower than other
apps but still higher


526
00:23:05,696 --> 00:23:07,276
than system daemons or agents.


527
00:23:10,166 --> 00:23:12,196
Really though, responsiveness is


528
00:23:12,196 --> 00:23:14,676
about improving the general
performance of your application.


529
00:23:14,966 --> 00:23:17,236
And that includes
reducing memory usage,


530
00:23:17,356 --> 00:23:20,506
choosing better algorithms
and improving CPU efficiency.


531
00:23:20,896 --> 00:23:23,916
And that's techniques that we've
been talking about for a while.


532
00:23:23,916 --> 00:23:26,766
So we actually have an
entire talk about that.


533
00:23:26,766 --> 00:23:29,216
It's called, "Building
Efficient OS X Apps."


534
00:23:29,466 --> 00:23:31,066
It was yesterday so
if you missed it,


535
00:23:31,066 --> 00:23:32,416
definitely catch
that one on video.


536
00:23:32,826 --> 00:23:34,406
And remember that
improving performance


537
00:23:34,406 --> 00:23:37,466
in that way also has a big
impact on energy efficiency.


538
00:23:38,026 --> 00:23:43,286
So let's move on and talk
about some AppNap API.


539
00:23:44,316 --> 00:23:47,166
So we have three new
categories of API.


540
00:23:47,676 --> 00:23:48,896
The first is as I mentioned,


541
00:23:48,896 --> 00:23:50,996
we can find out when you
application is visible


542
00:23:50,996 --> 00:23:51,636
or a window.


543
00:23:52,536 --> 00:23:55,026
We allow you now to add an
additional tolerance to timers.


544
00:23:55,116 --> 00:23:57,326
That helps with the coalescing
that we've been talking about.


545
00:23:57,916 --> 00:23:59,786
And finally, we also
let you tell the system


546
00:23:59,786 --> 00:24:01,556
about what you're
doing as an application


547
00:24:01,556 --> 00:24:02,726
on behalf of the user.


548
00:24:03,016 --> 00:24:05,456
And that will help us
improve our AppNap heuristics.


549
00:24:05,456 --> 00:24:10,216
So first let's talk
about visibility.


550
00:24:10,676 --> 00:24:13,326
This new API lets you find out
when either an individual window


551
00:24:13,566 --> 00:24:15,546
or your entire application
is occluded.


552
00:24:15,706 --> 00:24:18,416
So by occluded I mean
not visible to the user.


553
00:24:18,946 --> 00:24:21,996
An example of when a window may
be occluded would be if it's


554
00:24:21,996 --> 00:24:24,316
on another space and that
space is not visible,


555
00:24:24,316 --> 00:24:27,406
if another application has a
window in front of your window


556
00:24:27,476 --> 00:24:30,116
and your window is a hundred
percent occluded behind it,


557
00:24:30,646 --> 00:24:32,846
or if some higher level
window just covers everybody


558
00:24:32,846 --> 00:24:35,986
like the screensaver or if
you fast user switched away


559
00:24:35,986 --> 00:24:37,666
from the user session.


560
00:24:38,306 --> 00:24:42,026
So one example of when you
might want to use this is


561
00:24:42,026 --> 00:24:44,266
to halt expensive
work when occluded.


562
00:24:44,586 --> 00:24:47,356
So for example, the Eyes
application, it does not need


563
00:24:47,356 --> 00:24:49,866
to listen for mouse events
if you can't see the eyes.


564
00:24:50,046 --> 00:24:52,376
So that would be a big
improvement to make for that.


565
00:24:52,506 --> 00:24:56,136
You can also use it to refresh
content when becoming visible.


566
00:24:56,376 --> 00:24:59,036
So let's imagine we have a
stock ticker application.


567
00:24:59,336 --> 00:25:03,396
Now stock data is pretty rapidly
out of date so it's a real waste


568
00:25:03,396 --> 00:25:07,006
if the user can't even see the
window if we not only redraw it


569
00:25:07,006 --> 00:25:11,026
on the screen but also
spend power using the Wi-Fi


570
00:25:11,146 --> 00:25:15,176
to retrieve that data, the
user's bandwidth especially


571
00:25:15,176 --> 00:25:17,436
if they're mobile, and
your server bandwidth


572
00:25:17,436 --> 00:25:19,046
to retrieve the data
in the first place.


573
00:25:19,136 --> 00:25:22,966
So using this API can be a
big win for the entire stack.


574
00:25:24,266 --> 00:25:25,356
So here's how that works.


575
00:25:25,596 --> 00:25:27,146
Let's say I have my Eyes window.


576
00:25:27,146 --> 00:25:30,326
Here it's visible right in
front of another window.


577
00:25:30,916 --> 00:25:33,526
So partial visibility
like you see here,


578
00:25:33,786 --> 00:25:35,396
we still count that
as visibility.


579
00:25:35,666 --> 00:25:36,926
And in fact, it doesn't
matter how much


580
00:25:36,926 --> 00:25:37,956
of your window is showing.


581
00:25:37,956 --> 00:25:38,896
So maybe you would say,


582
00:25:38,896 --> 00:25:40,876
"But I just have a
sliver of my app showing."


583
00:25:40,976 --> 00:25:43,026
Well, we still consider
that to be visible.


584
00:25:43,316 --> 00:25:46,446
And we also don't care which
part of the window is showing.


585
00:25:46,446 --> 00:25:47,746
So maybe it's just a title bar.


586
00:25:48,166 --> 00:25:49,316
That's still visible.


587
00:25:49,616 --> 00:25:51,906
But if I finally move that
guy behind another window,


588
00:25:52,156 --> 00:25:54,186
then we consider that
window to be occluded.


589
00:25:54,336 --> 00:25:58,676
As far as minimized windows
go, if you minimize the window


590
00:25:58,676 --> 00:26:01,086
to the dock, we consider
that to be occluded.


591
00:26:01,086 --> 00:26:04,876
And for application
occlusion, it's the union


592
00:26:04,876 --> 00:26:06,136
of all application windows.


593
00:26:06,196 --> 00:26:08,736
So what I mean by that
is if even a little bit


594
00:26:08,736 --> 00:26:10,006
of any window is showing,


595
00:26:10,406 --> 00:26:13,066
then your application
is considered visible.


596
00:26:13,446 --> 00:26:15,006
So all windows have
to be occluded


597
00:26:15,006 --> 00:26:16,476
for your application
to be occluded.


598
00:26:16,746 --> 00:26:19,016
The exception is
the menu bar except


599
00:26:19,016 --> 00:26:20,966
if you have a status
item like this.


600
00:26:21,466 --> 00:26:24,296
I don't know why Eyes would
have status item but if it did,


601
00:26:24,296 --> 00:26:25,976
it would certainly
be that MOG icon.


602
00:26:26,846 --> 00:26:29,806
So if that status item is
showing, then that counts


603
00:26:29,806 --> 00:26:31,156
as a window for your
application.


604
00:26:31,686 --> 00:26:32,856
So if the menu bar hides,


605
00:26:32,856 --> 00:26:33,976
then that window would
also be occluded.


606
00:26:37,476 --> 00:26:38,546
Here's what the API looks like.


607
00:26:38,546 --> 00:26:39,756
We have two forms.


608
00:26:39,886 --> 00:26:43,326
On NS Application Delegate
there's application did change


609
00:26:43,326 --> 00:26:46,556
occlusion state and there's also
an NS notification if you prefer


610
00:26:46,556 --> 00:26:47,466
to listen to it that way.


611
00:26:47,806 --> 00:26:49,706
But either way, when you
receive that delegate message


612
00:26:49,706 --> 00:26:52,856
or that notification, you can
query the current application


613
00:26:52,856 --> 00:26:56,276
occlusion state by using the
NS Application Method Occlusion


614
00:26:56,276 --> 00:26:58,906
State and it returns
a bit field.


615
00:26:59,216 --> 00:27:02,716
So we only have 1 bit set right
-- or 1 bit defined right now.


616
00:27:03,126 --> 00:27:05,586
That's NS Application
Occlusion Stayed Visible.


617
00:27:06,266 --> 00:27:09,086
So if your application is
visible, that bit is set.


618
00:27:09,166 --> 00:27:12,066
If your application is
occluded or not visible


619
00:27:12,066 --> 00:27:14,196
to the user, that
bit is not set.


620
00:27:15,096 --> 00:27:17,586
The window API is almost
exactly the same except it's


621
00:27:17,586 --> 00:27:18,346
on NS Window.


622
00:27:18,466 --> 00:27:20,276
So Window Did Change
Occlusion State


623
00:27:20,626 --> 00:27:23,206
and NS Window Occlusion
State Visible.


624
00:27:23,886 --> 00:27:26,016
So for example, in
the Eyes Application,


625
00:27:26,386 --> 00:27:27,566
we can set up this method


626
00:27:27,696 --> 00:27:29,816
to check the current
occlusion state.


627
00:27:29,816 --> 00:27:31,416
And you notice I've
used a bit wise


628
00:27:31,636 --> 00:27:33,526
and operator here not equality.


629
00:27:33,646 --> 00:27:34,716
That's because it's a bit field.


630
00:27:35,206 --> 00:27:37,766
So anyway, if the
application is visible,


631
00:27:38,096 --> 00:27:39,596
then I can install
my event monitors.


632
00:27:39,936 --> 00:27:41,876
And if it's occluded,
then I can remove them.


633
00:27:45,236 --> 00:27:46,976
So let's move on to
talking about timers.


634
00:27:47,726 --> 00:27:49,426
So we found when
developing this feature


635
00:27:49,426 --> 00:27:52,366
that most timers actually do
not need to be hyper accurate.


636
00:27:52,666 --> 00:27:54,896
And by that I mean
you know 1 millisecond


637
00:27:54,896 --> 00:27:56,196
or less kind of accuracy.


638
00:27:56,576 --> 00:27:57,556
So again, what we've done


639
00:27:57,556 --> 00:28:00,546
with timer coalescing is apply
basically a default tolerance


640
00:28:00,546 --> 00:28:01,386
to all timers.


641
00:28:01,886 --> 00:28:06,446
This new API allows you to
increase that default tolerance


642
00:28:06,666 --> 00:28:09,936
and that allows the system to
fire your timer at the best time


643
00:28:09,986 --> 00:28:11,476
in the window that you specify.


644
00:28:12,126 --> 00:28:15,076
So for example, here
I have a timer.


645
00:28:15,076 --> 00:28:19,046
It's set to have a start
date of 5 seconds from now,


646
00:28:20,226 --> 00:28:24,526
a repeat interval of 7 seconds
and a tolerance of 3 seconds.


647
00:28:24,896 --> 00:28:27,686
So what that means is this
timer can fire anytime between 5


648
00:28:27,686 --> 00:28:30,636
and 8 seconds, 12 and 15
seconds, and so forth.


649
00:28:31,196 --> 00:28:34,636
The system will decide
what the best time is.


650
00:28:35,046 --> 00:28:36,756
So it maybe in the
middle of the window.


651
00:28:36,756 --> 00:28:38,556
It could be right at the
beginning of the window


652
00:28:38,826 --> 00:28:40,546
or it could be all the way
at the end of the window.


653
00:28:41,096 --> 00:28:43,756
Now don't be surprised
if you see a lot


654
00:28:43,756 --> 00:28:46,336
of timers firing near the
beginning of their windows


655
00:28:46,336 --> 00:28:48,836
for now and that's
because we need more timers


656
00:28:48,836 --> 00:28:51,306
on a system including your
applications to adopt this API.


657
00:28:51,976 --> 00:28:53,376
And the more timers we have,


658
00:28:53,736 --> 00:28:55,876
the better flexibility the
system has -- excuse me.


659
00:28:55,876 --> 00:28:57,226
The more timers we
have with tolerance,


660
00:28:57,496 --> 00:29:00,296
the better flexibility the
system has in aligning them


661
00:29:00,296 --> 00:29:01,466
to save the most energy.


662
00:29:01,956 --> 00:29:03,766
Here's the API.


663
00:29:03,766 --> 00:29:06,096
It's on NS Timer and
hopefully it should --


664
00:29:06,176 --> 00:29:07,016
it's not surprising.


665
00:29:07,016 --> 00:29:08,186
It's called Set Tolerance.


666
00:29:08,416 --> 00:29:09,636
And there's a getter as well.


667
00:29:09,966 --> 00:29:12,876
And we also have similar API
on CF Run Loop Timer as well.


668
00:29:12,876 --> 00:29:17,646
So what I'll do here
is create my timer.


669
00:29:17,726 --> 00:29:19,876
Again, it has a time
interval of 7 seconds


670
00:29:20,396 --> 00:29:23,506
and it fires my Timer Fired
Method and it's set to repeat.


671
00:29:23,846 --> 00:29:25,956
The fire date is
5 seconds from now


672
00:29:26,026 --> 00:29:28,156
and it has a tolerance
of 3 seconds.


673
00:29:28,586 --> 00:29:30,206
And then finally I
add it to my run loop.


674
00:29:30,756 --> 00:29:33,186
We also have a similar
API on Dispatch Timers.


675
00:29:33,186 --> 00:29:34,926
So if you haven't used
Dispatch Timers before,


676
00:29:34,926 --> 00:29:36,406
they're a kind of
dispatch source.


677
00:29:36,406 --> 00:29:38,906
This one is a dispatch
source type timer.


678
00:29:39,296 --> 00:29:40,856
The queue there is
the queue upon


679
00:29:40,856 --> 00:29:43,646
which my event handler will be
invoked when the timer fires.


680
00:29:44,076 --> 00:29:47,176
And then I use the Dispatch
Source Set Timer API


681
00:29:47,826 --> 00:29:51,356
to specify the start time, the
interval and the tolerance.


682
00:29:51,696 --> 00:29:53,386
And finally, don't forget
to resume your timer


683
00:29:53,386 --> 00:29:55,736
if you actually want it to fire.


684
00:29:55,736 --> 00:29:58,316
This API has actually been
around since we introduced it.


685
00:29:58,486 --> 00:30:00,266
The last parameter
before though was ignored.


686
00:30:00,466 --> 00:30:03,046
So now starting in
Mavericks, we are going


687
00:30:03,046 --> 00:30:05,016
to start obeying that value.


688
00:30:05,016 --> 00:30:06,326
And that will contribute


689
00:30:06,326 --> 00:30:07,966
to the overall efficiency
of the system.


690
00:30:11,346 --> 00:30:14,556
I said earlier that the timer
rate limiting can be configured


691
00:30:14,846 --> 00:30:15,956
and this is how.


692
00:30:16,256 --> 00:30:19,006
So if you have 1 timer
that needs to be exempt


693
00:30:19,006 --> 00:30:21,986
from rate limiting, then
you can set this flag:


694
00:30:22,096 --> 00:30:23,536
Dispatch Timer Strict.


695
00:30:24,636 --> 00:30:27,656
Now, I really recommend
caution when using this.


696
00:30:27,986 --> 00:30:29,496
As we saw from the Eyes Demo,


697
00:30:29,676 --> 00:30:31,206
the rate limiting
had a huge effect


698
00:30:31,206 --> 00:30:32,846
on energy efficiency
of the system.


699
00:30:33,356 --> 00:30:35,826
So we imagine that this is
only for the kinds of cases


700
00:30:35,826 --> 00:30:39,006
where you have very strict
requirements like interaction


701
00:30:39,006 --> 00:30:42,886
with hardware or perhaps some
kind of networking restriction.


702
00:30:42,886 --> 00:30:45,306
So please be very
careful when using this.


703
00:30:45,706 --> 00:30:47,576
In any case, if you use this,


704
00:30:47,836 --> 00:30:49,886
you still always should
specify tolerance.


705
00:30:50,016 --> 00:30:52,266
Here I've specified a
value of 700 milliseconds


706
00:30:52,266 --> 00:30:55,026
or about 10 percent and that's
because even a small amount


707
00:30:55,026 --> 00:30:56,346
of tolerance will
allow the system


708
00:30:56,346 --> 00:30:58,456
to get much better
energy efficiency.


709
00:30:58,456 --> 00:31:00,906
So please never pass zero
in for that argument.


710
00:31:01,406 --> 00:31:06,636
So again we suggest
about 10 percent


711
00:31:06,776 --> 00:31:08,286
of your interval as a tolerance.


712
00:31:08,696 --> 00:31:11,316
Exact value is the -- going
to be application specific.


713
00:31:11,636 --> 00:31:13,286
Maybe it's more or
it could be less.


714
00:31:13,286 --> 00:31:16,476
And so we leave it up to you.


715
00:31:16,476 --> 00:31:18,076
So this is an important note.


716
00:31:18,386 --> 00:31:20,466
This tolerance is used
regardless of AppNap.


717
00:31:20,466 --> 00:31:23,486
So that allows us to make timers
more efficient even in apps


718
00:31:23,486 --> 00:31:25,706
that are foreground or
are actively drawing.


719
00:31:25,706 --> 00:31:28,626
So we can get even
better energy efficiency


720
00:31:28,626 --> 00:31:29,796
by adopting tolerance.


721
00:31:30,626 --> 00:31:32,806
Again, the strict
timer should be rare.


722
00:31:33,216 --> 00:31:34,676
It disables the timer
rate limiting.


723
00:31:34,956 --> 00:31:36,066
But even if you do that,


724
00:31:36,066 --> 00:31:37,746
you should still
specify a tolerance.


725
00:31:38,296 --> 00:31:40,386
And finally as I mentioned,


726
00:31:40,656 --> 00:31:42,956
we'd really like all
timers to have tolerances.


727
00:31:43,056 --> 00:31:44,376
And that's because
the more timers


728
00:31:44,376 --> 00:31:46,666
that have a window
associated with them,


729
00:31:47,016 --> 00:31:48,716
the better we can align
them across the system.


730
00:31:52,456 --> 00:31:54,406
Next let's talk about
user activities.


731
00:31:54,946 --> 00:31:55,866
So this is our new API


732
00:31:55,946 --> 00:31:58,546
to improve the accuracy
of AppNap heuristics.


733
00:31:59,186 --> 00:32:01,556
It's used for long running
or asynchronous work


734
00:32:02,976 --> 00:32:05,966
and it's a Cocoa -- it's
a new Cocoa level API


735
00:32:06,036 --> 00:32:07,396
to prevent idle system sleep.


736
00:32:07,396 --> 00:32:10,606
So if you've used the I/O Kit
Power Searching API in the past,


737
00:32:10,956 --> 00:32:12,966
now we have a Cocoa API
for you to use as well.


738
00:32:13,586 --> 00:32:17,366
And it also has a new
interface to automatic


739
00:32:17,366 --> 00:32:18,406
and sudden termination.


740
00:32:18,956 --> 00:32:20,466
So here's he API.


741
00:32:20,536 --> 00:32:21,556
It comes in two forms.


742
00:32:21,856 --> 00:32:23,716
The first is called
Perform Activity


743
00:32:23,716 --> 00:32:25,146
with Options Reason Block.


744
00:32:25,716 --> 00:32:27,796
The first argument
describes the kind of activity


745
00:32:27,796 --> 00:32:28,796
that you're going to do.


746
00:32:28,796 --> 00:32:30,136
And we'll see what
those are in a minute.


747
00:32:30,596 --> 00:32:32,496
The second argument
is a reason string.


748
00:32:32,576 --> 00:32:34,006
And I strongly encourage you


749
00:32:34,006 --> 00:32:37,896
to always specify a
useful reason string here.


750
00:32:37,896 --> 00:32:39,346
And that's because it
will show up in some


751
00:32:39,346 --> 00:32:40,356
of our debugging tools.


752
00:32:40,636 --> 00:32:42,186
And I'll show you that
in a minute as well.


753
00:32:42,186 --> 00:32:43,856
For this form of the API,


754
00:32:44,346 --> 00:32:45,856
the block is performed
synchronously.


755
00:32:45,936 --> 00:32:46,876
So that means you
don't have to worry


756
00:32:46,876 --> 00:32:49,426
about ending the activity
when you're finished.


757
00:32:49,656 --> 00:32:51,336
You can just do it
all in one chunk.


758
00:32:51,336 --> 00:32:52,986
And the system takes
care of the rest.


759
00:32:53,426 --> 00:32:55,756
If however you want to do it
asynchronously, that's fine.


760
00:32:55,756 --> 00:32:57,016
That's the second
form of the API.


761
00:32:57,556 --> 00:32:59,996
It's called The End
Activity with Options Reason.


762
00:33:00,296 --> 00:33:02,616
Those two parameters
are the same as before


763
00:33:02,616 --> 00:33:04,206
but this one returns an object.


764
00:33:04,366 --> 00:33:07,646
And you can either store that
object in an IVAR or put it


765
00:33:07,646 --> 00:33:09,096
in a collection or
whatever you want.


766
00:33:09,406 --> 00:33:11,446
The important part is to
remember that when you're done,


767
00:33:11,796 --> 00:33:14,596
call end activity and
passing that object again.


768
00:33:14,596 --> 00:33:20,436
So here are the kind of
activities that you can specify:


769
00:33:21,106 --> 00:33:23,686
if you're doing something
that's explicitly user initiated


770
00:33:23,686 --> 00:33:28,326
like exporting a file or
recording or processing.


771
00:33:28,516 --> 00:33:31,806
For example, anything the user
might choose from the menu item


772
00:33:31,806 --> 00:33:34,746
and then you know actually pick
or click on a button and do.


773
00:33:35,356 --> 00:33:38,196
You use the NS Activity
User Initiated Constant.


774
00:33:39,286 --> 00:33:40,476
Now when developing
this feature,


775
00:33:40,476 --> 00:33:43,466
we found that many
applications hadn't


776
00:33:43,466 --> 00:33:47,746
yet considered what the behavior
of their application should be


777
00:33:48,116 --> 00:33:50,476
with respect to the system
falling into idle sleep.


778
00:33:50,866 --> 00:33:53,446
So maybe my export
takes 30 minutes


779
00:33:53,716 --> 00:33:56,276
but the user has asked the
system to idle sleep after 15.


780
00:33:56,776 --> 00:33:58,706
So is that something
that the user expected


781
00:33:58,706 --> 00:34:01,676
to finish beforehand and then
let the system sleep or not?


782
00:34:02,086 --> 00:34:04,716
And that's sort of really up
to you in your application


783
00:34:04,716 --> 00:34:06,026
and your specific use case.


784
00:34:06,436 --> 00:34:08,676
So when you're using this
API, we really want you to sit


785
00:34:08,676 --> 00:34:10,496
down and think about it.


786
00:34:10,496 --> 00:34:11,985
Which of those behaviors
should it be?


787
00:34:12,456 --> 00:34:15,436
So the NS Activity User
Initiated Constant actually


788
00:34:15,436 --> 00:34:17,606
includes a no idle
system sleep assertion.


789
00:34:17,735 --> 00:34:19,496
So that means while
your activity


790
00:34:19,496 --> 00:34:21,255
with this option is active,


791
00:34:21,556 --> 00:34:23,696
the system will not be
allowed to idle system sleep.


792
00:34:24,846 --> 00:34:26,726
And we think that's the
right choice for activities


793
00:34:26,726 --> 00:34:28,315
that are explicitly
done by the user.


794
00:34:28,916 --> 00:34:30,616
If however you think
that it should be allowed


795
00:34:30,616 --> 00:34:33,396
to idle system sleep, then
the next constant is the one


796
00:34:33,396 --> 00:34:33,746
for you.


797
00:34:34,396 --> 00:34:37,235
If you're doing some
kind of maintenance


798
00:34:37,235 --> 00:34:38,246
or other background work,


799
00:34:38,246 --> 00:34:40,606
you can use the NS
Activity Background Option.


800
00:34:42,045 --> 00:34:43,786
And finally, if you're doing
something that's latency


801
00:34:43,786 --> 00:34:46,996
sensitive like strict timers,
we think this is pretty rare,


802
00:34:47,436 --> 00:34:50,996
you can bit wise or NS Activity
Latency Critical with any


803
00:34:50,996 --> 00:34:52,726
of the previous flags to get --


804
00:34:53,056 --> 00:34:54,826
to indicate that
kind of requirement.


805
00:34:55,366 --> 00:35:00,436
So I said earlier, this
is a new API to interface


806
00:35:00,436 --> 00:35:03,336
with I/O K Power Assertions and
this is how you would do it.


807
00:35:03,636 --> 00:35:05,496
You can begin an
activity with the option


808
00:35:05,496 --> 00:35:07,866
of NS Activity Idle
System Sleep Disable.


809
00:35:08,206 --> 00:35:10,026
And while that activity
is active,


810
00:35:10,406 --> 00:35:12,756
again the system will not be
allowed to idle system sleep.


811
00:35:12,756 --> 00:35:15,096
And we have a constant for
displaced sleep as well.


812
00:35:15,956 --> 00:35:18,316
And finally, you can also use
this for sudden termination


813
00:35:18,316 --> 00:35:19,366
and automatic termination.


814
00:35:19,366 --> 00:35:21,166
So this is a little
bit different


815
00:35:21,166 --> 00:35:24,806
than the existing count API on
NS Process Info and Foundation.


816
00:35:25,156 --> 00:35:26,836
So you can use either
one that you like.


817
00:35:27,156 --> 00:35:28,176
The idea behind this one is


818
00:35:28,176 --> 00:35:30,066
that with the synchronous method
you don't have to remember


819
00:35:30,066 --> 00:35:32,016
to decrement your
counter afterwards


820
00:35:32,016 --> 00:35:33,066
so call in the End Method.


821
00:35:33,536 --> 00:35:36,546
And with the object based API,
it might be a little bit easier


822
00:35:36,546 --> 00:35:38,646
to track the assertion
that you're holding


823
00:35:38,646 --> 00:35:42,066
so you can keep it in IVAR
like I said or if you lose it,


824
00:35:42,066 --> 00:35:44,176
you can track it with
leaks and instruments.


825
00:35:44,656 --> 00:35:48,546
Here's an example of
how you might use this.


826
00:35:49,066 --> 00:35:52,006
I'm going to have an
NS Operation Queue


827
00:35:52,006 --> 00:35:54,136
that has long running
asynchronous user work


828
00:35:54,576 --> 00:35:57,896
and I will begin when the user
has chosen my you know Record


829
00:35:57,896 --> 00:35:59,136
Option from the File menu.


830
00:35:59,556 --> 00:36:02,056
Then I'm going to begin -- or
excuse me, Batch Process Option.


831
00:36:02,396 --> 00:36:04,206
Then I'm going to begin
activity with options.


832
00:36:04,546 --> 00:36:06,436
Here it seems like something
that should keep the system


833
00:36:06,436 --> 00:36:08,016
from falling into
idle system sleep


834
00:36:08,376 --> 00:36:10,816
so I chose NS Activity
User Initiated.


835
00:36:10,996 --> 00:36:13,456
And the reason is because
I'm batch processing files.


836
00:36:14,636 --> 00:36:16,406
Then I add my work to the queue.


837
00:36:16,576 --> 00:36:20,046
And when that work is done, then
I remember to call End Activity


838
00:36:20,286 --> 00:36:22,866
with the token that I got back
from the previous API call.


839
00:36:22,996 --> 00:36:27,936
So you can actually have many


840
00:36:27,936 --> 00:36:29,316
of these activities
at the same time.


841
00:36:29,626 --> 00:36:31,416
The system will do the right
thing with all of them.


842
00:36:31,646 --> 00:36:33,076
So for example, let's
say that you have a piece


843
00:36:33,076 --> 00:36:35,656
of your application that's doing
some kind of background work.


844
00:36:35,946 --> 00:36:38,266
It can use the NS Activity
Background Constant.


845
00:36:38,646 --> 00:36:42,516
But then simultaneously the
user chooses a menu item


846
00:36:42,516 --> 00:36:43,366
from the File menu.


847
00:36:43,716 --> 00:36:47,466
Then that could be an NS
Activity User Initiated activity


848
00:36:47,906 --> 00:36:50,756
and will do the right thing.


849
00:36:50,976 --> 00:36:52,436
You should avoid
rapidly starting


850
00:36:52,436 --> 00:36:53,706
and ending these activities.


851
00:36:53,776 --> 00:36:56,406
Again, they're for long running
work or asynchronous work.


852
00:36:56,806 --> 00:36:59,826
We automatically handle this
for you for event call outs


853
00:36:59,826 --> 00:37:01,166
on the main thread for example.


854
00:37:01,736 --> 00:37:06,486
And finally, please remember
the idle system sleep assertions


855
00:37:06,486 --> 00:37:07,866
should really be used with care.


856
00:37:08,196 --> 00:37:10,156
Don't prevent idle
system sleep forever.


857
00:37:10,676 --> 00:37:12,406
So we've been talking
about efficiencies gained


858
00:37:12,406 --> 00:37:16,446
by moving timers by a little bit
but nothing's worse for the user


859
00:37:16,446 --> 00:37:19,246
than leaving their laptop
doing some work at night


860
00:37:19,546 --> 00:37:20,966
and they come back in
the morning and it's


861
00:37:20,966 --> 00:37:24,416
at zero percent battery because
some application just kept the


862
00:37:24,416 --> 00:37:25,886
system from sleeping
appropriately.


863
00:37:26,276 --> 00:37:28,226
So please verify
in your application


864
00:37:28,226 --> 00:37:29,606
that the power assertions
are dropped


865
00:37:29,966 --> 00:37:31,186
when you're doing that work.


866
00:37:32,426 --> 00:37:33,556
Here's how you can do it.


867
00:37:33,736 --> 00:37:35,446
Use the PM set, Command
Line tool.


868
00:37:36,466 --> 00:37:38,566
[Inaudible] -g assertions and
it gives you a great output


869
00:37:38,566 --> 00:37:40,226
that tells you which
applications


870
00:37:40,226 --> 00:37:42,306
on the system have taken
which kinds of assertions.


871
00:37:42,646 --> 00:37:47,046
So here I've modified Eyes
inappropriately of course


872
00:37:47,046 --> 00:37:48,816
to keep the user's
computer awake.


873
00:37:49,226 --> 00:37:50,436
So we can see there,
it's been doing it


874
00:37:50,436 --> 00:37:51,966
for 3 minutes and 36 seconds.


875
00:37:52,306 --> 00:37:54,506
And the reason string is the one


876
00:37:54,506 --> 00:37:55,956
that we passed into
our API earlier.


877
00:37:56,036 --> 00:37:57,006
So this is a great example


878
00:37:57,006 --> 00:37:59,946
of why passing a real
reason string can be useful


879
00:37:59,946 --> 00:38:00,726
to help you debug.


880
00:38:01,116 --> 00:38:03,556
So use this tool to verify
that you have an assertion


881
00:38:03,556 --> 00:38:05,296
when you expect and
that when you're done,


882
00:38:05,386 --> 00:38:06,806
it's actually not
listed here at all.


883
00:38:07,426 --> 00:38:11,266
So let's go back to our
demo and show you --


884
00:38:11,266 --> 00:38:13,566
I want to show you how we can
improve the Eyes application


885
00:38:13,566 --> 00:38:15,886
with some of the API
that we talked about.


886
00:38:16,536 --> 00:38:18,566
So when we left off,
I was running the Eyes


887
00:38:18,566 --> 00:38:20,086
and I hid it behind X Code


888
00:38:20,326 --> 00:38:23,046
but it was still using
energy even though it was


889
00:38:23,046 --> 00:38:23,866
completely occluded.


890
00:38:24,226 --> 00:38:28,176
So we can use the new
occlusion API to improve that.


891
00:38:28,226 --> 00:38:29,976
So I have a branch
ready for that as well.


892
00:38:30,516 --> 00:38:38,166
[ Pause ]


893
00:38:38,666 --> 00:38:42,176
And what I did is added our
Application Did Change Occlusion


894
00:38:42,176 --> 00:38:42,726
State Method.


895
00:38:43,096 --> 00:38:45,536
And you can see here, that
when that's called I query the


896
00:38:45,536 --> 00:38:47,596
occlusion state again
using the bit wise and,


897
00:38:47,986 --> 00:38:51,686
and if we're visible I install
the event monitors and if not,


898
00:38:51,686 --> 00:38:53,286
I remove the event monitors.


899
00:38:53,446 --> 00:38:54,406
It's pretty straightforward.


900
00:38:54,646 --> 00:38:57,976
So I added this Remove Event
Monitors Method as well


901
00:38:58,206 --> 00:39:01,086
and this uses the NS Event API
that we talked about earlier


902
00:39:01,346 --> 00:39:03,636
to remove the event monitors
that we had installed.


903
00:39:04,066 --> 00:39:06,586
So let's go ahead and run
our application again.


904
00:39:07,276 --> 00:39:12,666
And we'll hide it and
bring up our energy gauge.


905
00:39:13,246 --> 00:39:15,716
And again, there might be
some activity that you see


906
00:39:15,716 --> 00:39:18,046
on the graph here
as system frameworks


907
00:39:18,046 --> 00:39:20,336
and libraries do a little
bit of work on your behalf.


908
00:39:20,756 --> 00:39:22,836
But in general, when
I move my mouse,


909
00:39:22,926 --> 00:39:26,246
we stay at about zero
wakes and zero impact.


910
00:39:26,246 --> 00:39:29,966
So this is going to
be a much better story


911
00:39:29,966 --> 00:39:31,976
for energy efficiency than
even the last version of Eyes.


912
00:39:32,516 --> 00:39:35,616
[ Pause ]


913
00:39:36,116 --> 00:39:36,426
Here we go.


914
00:39:36,746 --> 00:39:38,816
Zero wakes and zero activity.


915
00:39:39,306 --> 00:39:43,696
Alright, I want to show
you one more thing.


916
00:39:44,536 --> 00:39:47,286
I've added a new feature to Eyes


917
00:39:47,286 --> 00:39:48,246
which I think you'll
really like.


918
00:39:55,476 --> 00:39:56,536
Let's go ahead and run it.


919
00:39:57,016 --> 00:39:59,486
Now if I go up to the File
menu and choose Record,


920
00:39:59,486 --> 00:40:02,636
you can see here in the
corner that Eyes is telling us


921
00:40:02,676 --> 00:40:05,496
that it's currently
recording our mouse movements.


922
00:40:05,496 --> 00:40:08,066
And if I move my mouse
around here for a while,


923
00:40:10,226 --> 00:40:12,826
and I stop recording, it
tells me I travelled 7


924
00:40:12,946 --> 00:40:13,976
thousand points.


925
00:40:15,156 --> 00:40:16,486
That's a pretty good score


926
00:40:16,486 --> 00:40:19,886
but I've actually done
better in the past.


927
00:40:20,686 --> 00:40:22,466
So anyway, let's go back
to our source code here


928
00:40:22,466 --> 00:40:23,456
and see how that works.


929
00:40:23,806 --> 00:40:26,516
I added a new method
called Toggle Recording.


930
00:40:27,576 --> 00:40:31,036
And recording since I choose
it from the File menu seems


931
00:40:31,036 --> 00:40:32,476
like a user initiated action.


932
00:40:32,936 --> 00:40:35,376
So what I do is if I'm
not already recording,


933
00:40:36,136 --> 00:40:39,516
I tell the system that by saying
Begin Activity with Options,


934
00:40:39,826 --> 00:40:42,886
NS Activity User Initiated
Allowing Idle System Sleep.


935
00:40:43,076 --> 00:40:44,326
And I give it a reason as well.


936
00:40:45,576 --> 00:40:47,306
Now I said earlier that
when you use this API,


937
00:40:47,306 --> 00:40:49,676
I want you to think
about what kind


938
00:40:49,676 --> 00:40:50,986
of options you should choose.


939
00:40:51,366 --> 00:40:52,746
So in this case I said, "Well,


940
00:40:53,066 --> 00:40:54,516
if the user's not
moving their mouse,


941
00:40:54,516 --> 00:40:57,126
well then there's really
nothing for Eyes to do.


942
00:40:57,286 --> 00:41:00,156
So there's no reason for Eyes
to keep the system from falling


943
00:41:00,156 --> 00:41:01,206
into idle system sleep."


944
00:41:01,676 --> 00:41:04,526
And so that's why I chose the
Allowing Idle System Sleep


945
00:41:04,526 --> 00:41:07,826
version of the options here.


946
00:41:08,126 --> 00:41:10,296
And I want you again to think
about that when you look


947
00:41:10,296 --> 00:41:11,266
through your use cases.


948
00:41:12,656 --> 00:41:15,946
Finally I set up some
iBars and the UI and then


949
00:41:15,946 --> 00:41:20,716
when the user chooses that menu
item again, we end the activity


950
00:41:20,716 --> 00:41:22,456
by calling NS Processing.


951
00:41:22,456 --> 00:41:25,066
So it's End Activity with
the User Activity Token.


952
00:41:25,416 --> 00:41:28,476
So we make sure that we
balance our begin with an end.


953
00:41:31,176 --> 00:41:33,876
The only other change I really
made here was you know a set


954
00:41:33,876 --> 00:41:36,766
up method, I need to look
at both the occlusion state


955
00:41:36,966 --> 00:41:39,506
and our recording state so
I know when it's appropriate


956
00:41:39,506 --> 00:41:40,926
to have the event that
monitors installed.


957
00:41:41,606 --> 00:41:46,646
So the result is that if I bring
up Activity Monitor again here


958
00:41:47,466 --> 00:41:53,886
and begin recording with
Eyes, and we'll go ahead


959
00:41:53,886 --> 00:41:55,256
and occlude it, we'll notice


960
00:41:55,256 --> 00:41:58,246
that this time the AppNap column
- I'll zoom in for you here -


961
00:41:58,866 --> 00:42:00,386
the AppNap column remains at No.


962
00:42:00,836 --> 00:42:04,496
And that's because using the
NS Activity Options API we've


963
00:42:04,496 --> 00:42:07,646
helped tell the system what
the user is actually interested


964
00:42:07,646 --> 00:42:08,066
in doing.


965
00:42:08,156 --> 00:42:10,416
In this case it was
recording the mouse location.


966
00:42:10,946 --> 00:42:13,656
And so we can factor
that into our heuristics


967
00:42:13,656 --> 00:42:14,746
about whether it's appropriate


968
00:42:14,746 --> 00:42:17,186
to put the app into
AppNap or not.


969
00:42:18,016 --> 00:42:22,636
Now if I go back to Eyes
here and stop recording


970
00:42:23,246 --> 00:42:26,066
and occlude it once more,


971
00:42:26,486 --> 00:42:28,366
we'll see that because we told
the system that we're done


972
00:42:28,366 --> 00:42:31,596
with that activity, that
allows it to incorporate


973
00:42:31,596 --> 00:42:34,626
that into our heuristics and
we'll that it now is allowed


974
00:42:34,626 --> 00:42:36,036
to go back into AppNap.


975
00:42:36,036 --> 00:42:37,976
Let's go back to our slides.


976
00:42:38,516 --> 00:42:42,016
[ Pause ]


977
00:42:42,516 --> 00:42:43,736
So let's do a quick summary.


978
00:42:43,926 --> 00:42:48,046
I want you to remember
what an impact software has


979
00:42:48,046 --> 00:42:49,046
on energy efficiency.


980
00:42:49,166 --> 00:42:51,636
It's easy to think that
it's just a responsibility


981
00:42:51,636 --> 00:42:54,136
of you know this backlight
or the screen or the GPU,


982
00:42:54,636 --> 00:42:57,196
but the CPU is where
we do our work


983
00:42:57,346 --> 00:42:59,436
and that is what drives
the rest of the system.


984
00:42:59,436 --> 00:43:01,956
And the CPU has that
high dynamic range.


985
00:43:01,996 --> 00:43:03,976
So what we're doing
in our applications


986
00:43:03,976 --> 00:43:06,106
and in our system can
make a real big difference


987
00:43:06,106 --> 00:43:07,296
on the user's battery life.


988
00:43:08,666 --> 00:43:11,016
Remember the three key rules
of extending battery life.


989
00:43:11,296 --> 00:43:13,516
First, we need to stay
at idle, that low power,


990
00:43:13,516 --> 00:43:16,006
0.4 watt idle state
as long as possible.


991
00:43:16,556 --> 00:43:18,886
Second, we need to
avoid unnecessary work


992
00:43:19,266 --> 00:43:21,506
like redrawing a pair
of eyes behind a window


993
00:43:21,506 --> 00:43:22,506
when you can't even see them.


994
00:43:22,986 --> 00:43:24,766
And third, when we're
doing work,


995
00:43:24,766 --> 00:43:26,136
we need to race back to idle.


996
00:43:26,136 --> 00:43:28,966
That is return to that idle
state as quickly as possible


997
00:43:29,136 --> 00:43:31,726
because the longer we spend
in our 0.4 watt idle state,


998
00:43:32,086 --> 00:43:33,996
the longer the battery
life is going to be.


999
00:43:36,336 --> 00:43:37,416
And also please remember


1000
00:43:37,416 --> 00:43:40,406
that avoiding timers
allows for longer idle time.


1001
00:43:41,286 --> 00:43:46,236
If you can, instead use event
based API like the Event Monitor


1002
00:43:46,236 --> 00:43:48,086
that we used for the
Eyes application.


1003
00:43:49,216 --> 00:43:53,156
And finally, if you must use
timers, please add tolerance.


1004
00:43:53,486 --> 00:43:56,806
And actually also,
use the Activity API


1005
00:43:57,296 --> 00:43:59,806
to inform the system
of important user work


1006
00:43:59,806 --> 00:44:02,656
like recording, batch
processing, and so forth.


1007
00:44:03,006 --> 00:44:04,566
And please remember
to take into account


1008
00:44:04,766 --> 00:44:06,876
that idle system sleep
assertion and verify


1009
00:44:06,876 --> 00:44:09,066
that you are taking them
and dropping them correctly.


1010
00:44:09,066 --> 00:44:13,526
We've had a bunch of
related sessions this week.


1011
00:44:13,526 --> 00:44:15,656
Most of them have already
happened so if you missed them,


1012
00:44:15,656 --> 00:44:17,496
these are great sessions
to catch on video:


1013
00:44:17,796 --> 00:44:21,796
especially the first one where
we had a great talk about -


1014
00:44:21,796 --> 00:44:24,316
in depth - the new features
of some of our new --


1015
00:44:24,316 --> 00:44:26,056
the new Intel processors and how


1016
00:44:26,056 --> 00:44:27,716
that has an impact
on battery life.


1017
00:44:28,276 --> 00:44:31,436
Building efficient OS
X apps: talked a lot


1018
00:44:31,436 --> 00:44:32,896
about improving the
responsiveness


1019
00:44:32,896 --> 00:44:33,796
of your application.


1020
00:44:34,446 --> 00:44:36,836
The next session which
was just this morning --


1021
00:44:37,506 --> 00:44:38,916
so a lot of the features
we've been talking


1022
00:44:38,916 --> 00:44:42,086
about today also apply
to web pages via Safari.


1023
00:44:42,366 --> 00:44:45,776
So if you're a web developer,
then please check out that video


1024
00:44:46,016 --> 00:44:48,216
to understand how
it impacts you.


1025
00:44:48,796 --> 00:44:50,516
And finally tomorrow
we have another session


1026
00:44:50,516 --> 00:44:52,856
on Energy Best Practices.


1027
00:44:52,856 --> 00:44:55,476
So that's going to talk a lot
about moving away from timers


1028
00:44:55,816 --> 00:44:59,296
and towards more event based API
for maximum energy efficiency.


1029
00:44:59,326 --> 00:45:01,996
If you're not here at the
conference, then please get


1030
00:45:01,996 --> 00:45:05,056
in contact with our
Evangelism Team or talk to us


1031
00:45:05,056 --> 00:45:05,986
on the Developer Forums.


1032
00:45:05,986 --> 00:45:08,816
I browse that and try to
answer questions if I can along


1033
00:45:08,816 --> 00:45:10,516
with many other members
of the Cocoa team.


1034
00:45:11,966 --> 00:45:13,356
So with that, I want
to thank you for coming


1035
00:45:13,356 --> 00:45:14,356
and learning about AppNap.


1036
00:45:15,516 --> 00:45:20,810
[ Applause ]

