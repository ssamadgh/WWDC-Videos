1
00:00:10,066 --> 00:00:11,306
>> Alright, good
morning everyone.


2
00:00:12,116 --> 00:00:13,926
I'm Doug Davidson, and
I'm here to talk to you


3
00:00:13,926 --> 00:00:15,646
about making your
app world ready.


4
00:00:18,236 --> 00:00:20,816
So, the app store
is available in more


5
00:00:20,816 --> 00:00:23,026
than 150 countries worldwide,


6
00:00:23,486 --> 00:00:26,906
and if your application is
only targeted at one of them;


7
00:00:27,196 --> 00:00:29,566
not only are you missing
out, but also a lot


8
00:00:29,566 --> 00:00:31,936
of your potential users
are being deprived as well.


9
00:00:32,366 --> 00:00:36,566
So, we're going to tell you how
with a little additional effort,


10
00:00:37,066 --> 00:00:39,236
you can make your app ready
for international use.


11
00:00:40,106 --> 00:00:42,556
The steps to go through
are fairly simple.


12
00:00:42,696 --> 00:00:45,476
In many cases, we find
that what you have to watch


13
00:00:45,476 --> 00:00:48,416
out for is assumptions
that you may be making;


14
00:00:48,526 --> 00:00:49,836
maybe even unconsciously,


15
00:00:50,186 --> 00:00:52,406
that just don't hold
everywhere in the world.


16
00:00:53,086 --> 00:00:55,466
And, so we'll be
talking a lot about that.


17
00:00:55,506 --> 00:00:58,186
Often, it's not things you don't
know that will hurt so much,


18
00:00:58,186 --> 00:01:00,266
as the things you do
know that just aren't so.


19
00:01:02,146 --> 00:01:05,476
Now, there are some
genuine challenges here.


20
00:01:05,476 --> 00:01:09,706
Our customers around the world
use many different languages,


21
00:01:09,756 --> 00:01:11,276
many different writing systems,


22
00:01:11,696 --> 00:01:13,866
and they have often
significantly different


23
00:01:13,866 --> 00:01:18,246
expectations after the
presentation of items like dates


24
00:01:18,246 --> 00:01:19,616
and times and numbers.


25
00:01:20,046 --> 00:01:23,916
But, fortunately, the frameworks
are designed to handle this,


26
00:01:23,916 --> 00:01:24,756
if you work with them.


27
00:01:25,396 --> 00:01:28,216
Now, I say frameworks,
it's important to note


28
00:01:28,476 --> 00:01:30,366
that almost everything
we're going talk


29
00:01:30,366 --> 00:01:34,226
about here today applies
to both iOS and OS X.


30
00:01:34,226 --> 00:01:37,546
Now, we're going to do
this in three parts.


31
00:01:37,826 --> 00:01:39,596
The first is about localization.


32
00:01:40,006 --> 00:01:42,996
Localization refers
to the language


33
00:01:43,446 --> 00:01:45,906
in which you application's
user interface is presented.


34
00:01:47,116 --> 00:01:50,266
Your job as a developer
is to make sure


35
00:01:50,266 --> 00:01:53,566
that your application is
localizable, so that you can go


36
00:01:53,566 --> 00:01:56,776
to the localizer, who
will translate the text


37
00:01:56,776 --> 00:01:59,786
in your user interface into
any particular language,


38
00:02:00,326 --> 00:02:03,526
then all you have to do is
decide how many languages you


39
00:02:03,526 --> 00:02:04,406
want to do this for.


40
00:02:05,536 --> 00:02:08,716
Second, we'll talk about
locale data, and that refers


41
00:02:08,716 --> 00:02:11,856
to presenting things like
dates and times and numbers


42
00:02:11,856 --> 00:02:13,646
in a way that's intelligible
to people


43
00:02:13,646 --> 00:02:15,066
in that particular region.


44
00:02:16,026 --> 00:02:18,366
And, finally, we'll talk
about handling texts


45
00:02:18,446 --> 00:02:20,956
and all the different writing
systems used around the world.


46
00:02:20,956 --> 00:02:26,336
There are two main settings
that are involved here,


47
00:02:26,536 --> 00:02:28,506
and this is what they
look like on iOS.


48
00:02:29,106 --> 00:02:31,796
The first is the user's
language preference,


49
00:02:31,936 --> 00:02:33,016
and that's what determines


50
00:02:33,016 --> 00:02:35,546
which localization
your app will run in,


51
00:02:36,616 --> 00:02:39,696
and the second is the
user's region preference,


52
00:02:40,166 --> 00:02:43,966
which determines what their
locale settings will be.


53
00:02:44,516 --> 00:02:49,806
On OS X Mavericks, we have
an entirely new pref pane


54
00:02:49,856 --> 00:02:50,866
for handling this.


55
00:02:50,866 --> 00:02:52,766
It's designed to streamline it,


56
00:02:52,766 --> 00:02:55,336
and make changing
the settings simple,


57
00:02:55,336 --> 00:02:56,556
and make it all more logical.


58
00:02:56,796 --> 00:02:57,556
It's very similar.


59
00:02:57,626 --> 00:03:00,136
You have the user's
language preference again


60
00:03:00,136 --> 00:03:02,416
that determines what
localizations will be used,


61
00:03:03,006 --> 00:03:04,376
and the user region preference


62
00:03:04,486 --> 00:03:06,136
that determines the
locale settings.


63
00:03:06,556 --> 00:03:10,896
Additionally, on OS X,
there is an advanced sheet


64
00:03:10,956 --> 00:03:14,106
that allows the user to
customize in great detail,


65
00:03:14,106 --> 00:03:17,866
if they want to, any of the
various settings that are part


66
00:03:17,866 --> 00:03:19,096
of their locale preferences.


67
00:03:20,126 --> 00:03:23,706
So, to start off with, we'll
talk about localization.


68
00:03:23,706 --> 00:03:26,756
I'll bring up my colleague,
Albert Lund to talk about that.


69
00:03:27,516 --> 00:03:31,896
[ Applause ]


70
00:03:32,396 --> 00:03:34,616
>> Hello, I'm going to be
talking about localization,


71
00:03:34,926 --> 00:03:36,826
and what localization is,


72
00:03:36,826 --> 00:03:38,966
is that it translates
your application


73
00:03:38,966 --> 00:03:41,536
from its current language
to another language,


74
00:03:41,876 --> 00:03:45,296
so your app can provide much
more exposure and visibility


75
00:03:45,296 --> 00:03:47,106
to other markets
around the world,


76
00:03:47,106 --> 00:03:49,676
leading to more downloads
for your app.


77
00:03:49,676 --> 00:03:53,526
It's also about adapting your
application to cultural norms


78
00:03:53,526 --> 00:03:56,756
in those regions, so you
can provide the same level


79
00:03:56,756 --> 00:04:01,056
of user experience for
all users of your app.


80
00:04:01,696 --> 00:04:03,626
Now, today, I'm going
to be talking about how


81
00:04:03,626 --> 00:04:07,026
to use our tools and X codes
to localize your application,


82
00:04:07,426 --> 00:04:09,376
as well as some common
mistakes and issues


83
00:04:09,376 --> 00:04:11,676
that may occur when localizing.


84
00:04:13,186 --> 00:04:17,286
So, here's your project is
structured for localization.


85
00:04:17,576 --> 00:04:21,156
You have your single binary,
which is your header files,


86
00:04:21,156 --> 00:04:23,446
your implementation files,
and libraries you call,


87
00:04:23,666 --> 00:04:26,006
and you only have one
set of these files.


88
00:04:27,386 --> 00:04:31,486
You also have localization
folders alongside your binary,


89
00:04:31,666 --> 00:04:34,236
and these are folders
called L proj folders,


90
00:04:34,236 --> 00:04:36,476
or your language
specific project folders.


91
00:04:37,116 --> 00:04:40,986
Each localization is placed
into one of these folders,


92
00:04:40,986 --> 00:04:45,596
and it's abbreviated
by the language.


93
00:04:45,596 --> 00:04:49,416
So, for example, the English
location is EN, French is FR,


94
00:04:49,666 --> 00:04:51,346
Spanish is ES and so on.


95
00:04:52,166 --> 00:04:54,216
All of these localizations
are then placed


96
00:04:54,216 --> 00:04:55,846
into your single app bundle,


97
00:04:56,196 --> 00:04:58,226
and one of these will
get loaded at runtime.


98
00:04:59,056 --> 00:05:01,476
Whichever one gets loaded
at run time is determined


99
00:05:01,476 --> 00:05:03,916
by what the user selected
system language is.


100
00:05:03,916 --> 00:05:05,706
So, if the user's
language is Spanish,


101
00:05:05,706 --> 00:05:07,086
the Spanish localization
gets loaded.


102
00:05:07,086 --> 00:05:10,496
So, here's how your
project is structured.


103
00:05:10,496 --> 00:05:13,416
You can see that the L proj
folders are alongside your


104
00:05:13,416 --> 00:05:15,906
implication files
and your localizers


105
00:05:15,906 --> 00:05:18,836
or your translators just have
to modify these folders only;


106
00:05:18,836 --> 00:05:20,196
they don't need to
touch anything else.


107
00:05:21,496 --> 00:05:24,736
These folders contain things
such as your strings files,


108
00:05:24,736 --> 00:05:27,496
which contains things such
as your user visible text,


109
00:05:27,896 --> 00:05:30,486
as well as any resource
files, such as images


110
00:05:30,486 --> 00:05:32,886
and anything else you might
want to use for localization.


111
00:05:32,886 --> 00:05:36,776
So, let's get started on
how to localize things


112
00:05:36,776 --> 00:05:39,776
such as your interface files or
your nib files or storyboards.


113
00:05:40,546 --> 00:05:43,206
The old way to do this, and
you can still do this today,


114
00:05:43,206 --> 00:05:46,196
is to make a copy of
every single nib file


115
00:05:46,196 --> 00:05:47,956
for every single
localization you have.


116
00:05:48,626 --> 00:05:50,116
Your localizers then just open


117
00:05:50,116 --> 00:05:52,746
and modify the specific
interface file


118
00:05:52,746 --> 00:05:55,486
for that specific
localization, modify the text


119
00:05:55,486 --> 00:05:57,456
so it's localized, and make sure


120
00:05:57,456 --> 00:05:59,016
that everything surrounding
it looks good


121
00:05:59,016 --> 00:06:00,386
and works for this interface.


122
00:06:01,466 --> 00:06:03,166
Like I said, while
these work today,


123
00:06:03,166 --> 00:06:04,326
if you want to localize
this way,


124
00:06:04,326 --> 00:06:06,666
you can see this
gets very cumbersome,


125
00:06:06,666 --> 00:06:10,666
and can be very time consuming
for you and your localizers,


126
00:06:10,886 --> 00:06:13,076
so we highly recommend
you use this method called


127
00:06:13,156 --> 00:06:14,366
base internationalization.


128
00:06:15,386 --> 00:06:19,116
With base internationalization,
you only need to modify one set


129
00:06:19,216 --> 00:06:21,406
of storyboards and nib files,
so you don't have to worry


130
00:06:21,406 --> 00:06:23,686
about localization when it
comes to your interface.


131
00:06:24,556 --> 00:06:26,906
Every single time you
create a new localization,


132
00:06:27,506 --> 00:06:29,676
a strings file, which
basically takes all


133
00:06:29,676 --> 00:06:34,286
of the user visible text out of
your nib file, is then placed


134
00:06:34,286 --> 00:06:36,166
into those specific
language folders,


135
00:06:36,546 --> 00:06:40,026
and your localizer just has to
modify those, the text only.


136
00:06:40,076 --> 00:06:41,446
They don't need to touch
your interface at all.


137
00:06:42,556 --> 00:06:45,446
Now, it's highly recommended
that you should use auto layout


138
00:06:45,446 --> 00:06:46,846
for base internationalization,


139
00:06:46,846 --> 00:06:48,896
and I'll explain what auto
layout is in a moment.


140
00:06:49,406 --> 00:06:52,926
But, here's an example how base
internationalization works.


141
00:06:53,026 --> 00:06:54,506
I have my one nib file here,


142
00:06:54,886 --> 00:06:58,136
and this is my base
internationalization file.


143
00:06:58,816 --> 00:07:01,666
As a developer, I only need
to modify this one file,


144
00:07:02,056 --> 00:07:04,456
and every single time I
create a new localization,


145
00:07:04,496 --> 00:07:06,646
a strings file is then
generated for every single one.


146
00:07:07,486 --> 00:07:11,256
From there on, my localizers
then do not touch anything


147
00:07:11,256 --> 00:07:12,146
involving my interface.


148
00:07:12,206 --> 00:07:13,756
They only need to
modify the strings,


149
00:07:13,756 --> 00:07:16,526
and that's really convenient.


150
00:07:17,816 --> 00:07:19,506
So, what's auto layout.


151
00:07:20,126 --> 00:07:23,826
Auto layout is a way to define
the constraints between text


152
00:07:23,826 --> 00:07:26,766
and anything surrounding your
text, such as text views,


153
00:07:26,766 --> 00:07:28,596
UI image views, and
pretty much anything


154
00:07:28,886 --> 00:07:29,816
that surrounds the text.


155
00:07:30,526 --> 00:07:33,806
It is a way to appropriately
resize everything depending


156
00:07:33,806 --> 00:07:36,486
on the length of the text, which
is crucial for localization;


157
00:07:37,066 --> 00:07:39,476
the reason being is that when
you translate your application


158
00:07:39,476 --> 00:07:40,886
from one language to another,


159
00:07:41,356 --> 00:07:44,306
some translated strings may be
significantly longer or shorter,


160
00:07:44,306 --> 00:07:46,826
and you want to be able to
dynamically adjust these,


161
00:07:46,826 --> 00:07:49,266
so your interface looks good.


162
00:07:50,076 --> 00:07:51,906
And, to learn more
about auto layout,


163
00:07:52,006 --> 00:07:54,906
I highly recommend you check out
the video for "Taking Control


164
00:07:54,906 --> 00:07:56,316
of Auto Layout in X Code 5".


165
00:07:56,316 --> 00:07:57,176
That was held yesterday.


166
00:07:58,716 --> 00:08:02,766
So, let's get started on how to
use base internationalization.


167
00:08:02,966 --> 00:08:05,066
So in my project
window for X code,


168
00:08:05,066 --> 00:08:08,236
I have this checkbox here called
used space internationalization.


169
00:08:09,106 --> 00:08:12,836
I check this box, and then
X code will then ask me


170
00:08:13,276 --> 00:08:17,096
which files do I want to use for
my base internationalization.


171
00:08:17,096 --> 00:08:19,976
It will then move all
of these interface files


172
00:08:19,976 --> 00:08:22,876
and any file I want into
the base.Lproj folder,


173
00:08:23,336 --> 00:08:25,596
and anytime I want to
create a new localization,


174
00:08:25,596 --> 00:08:27,046
I then push this
plus button here.


175
00:08:28,556 --> 00:08:30,496
Any interface files
then that are placed


176
00:08:30,616 --> 00:08:33,376
in the base.Lproj folder
will then generate their own


177
00:08:33,376 --> 00:08:34,135
strings files.


178
00:08:34,916 --> 00:08:37,596
And, then again, my
localizer just has to go


179
00:08:37,596 --> 00:08:40,466
into these strings file
only, and have nothing to do


180
00:08:40,466 --> 00:08:46,096
with the interface,
which is great.


181
00:08:46,296 --> 00:08:49,396
Now, when you make an update to
your interface, you also want


182
00:08:49,396 --> 00:08:52,026
to make sure that your interface
is also localized as well.


183
00:08:52,336 --> 00:08:56,736
And, we have a command line
tool in OS X; we call it IB12,


184
00:08:56,736 --> 00:08:59,346
which will generate a
strings file for you.


185
00:08:59,986 --> 00:09:04,726
So, in this example here
in my base.Lproj folder,


186
00:09:04,726 --> 00:09:08,496
I just pass in the nib file that
I have changed, and run IB12


187
00:09:08,666 --> 00:09:12,656
on it, and it will generate a
new strings file containing all


188
00:09:12,656 --> 00:09:14,436
of the strings that
were originally


189
00:09:14,436 --> 00:09:15,436
in this interface file.


190
00:09:16,536 --> 00:09:20,256
I then go in and open
this new strings file,


191
00:09:21,176 --> 00:09:23,196
copy and paste everything
that has changed,


192
00:09:23,196 --> 00:09:25,636
or anything that I have
updated or added, and paste it


193
00:09:25,636 --> 00:09:27,176
into every single strings file


194
00:09:27,516 --> 00:09:30,236
that has this interface
file here,


195
00:09:30,236 --> 00:09:34,746
so it's very good to update.


196
00:09:35,346 --> 00:09:37,686
Now, some issues that can come
up with using auto layout,


197
00:09:37,686 --> 00:09:40,556
is that you may use the
fixed width for auto layout.


198
00:09:40,926 --> 00:09:43,016
This entirely defeats the
purpose of auto layout,


199
00:09:43,016 --> 00:09:45,086
since you want to make sure


200
00:09:45,086 --> 00:09:47,086
that all text is
resized automatically,


201
00:09:47,086 --> 00:09:49,516
and you don't want your
interface to look bad


202
00:09:49,516 --> 00:09:51,386
on certain localization
because you decided


203
00:09:51,446 --> 00:09:54,136
to have a fixed width
between text


204
00:09:54,136 --> 00:09:56,076
and UI text view or something.


205
00:09:56,656 --> 00:09:59,406
And, as always, it's good


206
00:09:59,406 --> 00:10:02,946
to prefer an intrinsic content
size instead and as always


207
00:10:02,946 --> 00:10:07,366
if you, you should always
try out your layouts


208
00:10:07,366 --> 00:10:08,876
in every single localization
and test,


209
00:10:08,876 --> 00:10:10,366
so your app in those
localizations.


210
00:10:10,876 --> 00:10:13,186
Because what's works
in one language,


211
00:10:13,186 --> 00:10:15,196
and what constraints may
work in one language,


212
00:10:15,196 --> 00:10:16,616
may not necessarily
work in another.


213
00:10:18,336 --> 00:10:20,546
So, let's talk about
the strings file.


214
00:10:20,896 --> 00:10:23,486
The strings file contains
the user visible text


215
00:10:23,486 --> 00:10:28,006
that will get localized
and displayed in your app.


216
00:10:28,116 --> 00:10:31,386
The strings file is placed
into a key value table,


217
00:10:31,386 --> 00:10:33,296
and what happens is,
is that the left side


218
00:10:33,296 --> 00:10:34,696
of the table is your key.


219
00:10:35,186 --> 00:10:37,316
The key is what the application
is going to be looking


220
00:10:37,316 --> 00:10:40,696
for to display what localized
text should be displayed


221
00:10:40,696 --> 00:10:41,146
to the user.


222
00:10:41,896 --> 00:10:46,156
So, in this example here, I have
three localized strings files


223
00:10:46,156 --> 00:10:48,006
that are placed in three
separate localizations;


224
00:10:48,096 --> 00:10:50,946
the English, simplified
Chinese, and Spanish.


225
00:10:51,716 --> 00:10:54,996
At run time, depending on what
localization my user is in,


226
00:10:55,286 --> 00:10:56,546
one of these will get loaded,


227
00:10:56,546 --> 00:10:57,896
and one of these
will get displayed.


228
00:10:58,196 --> 00:11:03,156
So, if my application is looking
for a name key, it will look


229
00:11:03,156 --> 00:11:05,756
in the name field for that
specific localization,


230
00:11:05,816 --> 00:11:08,086
and display whatever is
in the user visible text.


231
00:11:08,646 --> 00:11:12,626
Now, you will also have
some strings in your code


232
00:11:12,866 --> 00:11:14,586
or some user visible
text in your code


233
00:11:14,586 --> 00:11:15,786
that you want localized as well.


234
00:11:16,496 --> 00:11:18,736
To do this, you should
use NSLocalizedString


235
00:11:18,736 --> 00:11:20,396
and use NSLocalizedString
everywhere


236
00:11:20,396 --> 00:11:22,076
where you have user
visible text,


237
00:11:22,436 --> 00:11:24,746
and NSLocalizedString
has many variants


238
00:11:24,746 --> 00:11:27,256
that pretty much can do
what you want it to do,


239
00:11:27,256 --> 00:11:28,946
so check out more details


240
00:11:28,946 --> 00:11:30,746
for NSLocalizedString
in the release notes.


241
00:11:31,266 --> 00:11:34,676
Here's an example of
NSLocalizedString used


242
00:11:34,676 --> 00:11:36,116
in its most common case.


243
00:11:36,116 --> 00:11:38,776
It takes in two parameters;
one is a key,


244
00:11:38,776 --> 00:11:41,826
which what will get mapped
to the localized text


245
00:11:41,826 --> 00:11:44,236
that you want, as well as
a comment to the localizer,


246
00:11:44,236 --> 00:11:47,516
which I'll talk about later.


247
00:11:47,746 --> 00:11:50,296
Once you localize your
strings in your code,


248
00:11:50,356 --> 00:11:52,726
you want to make sure that
you create a strings file


249
00:11:52,726 --> 00:11:55,896
that will have all these
NSLocalizedStrings in one place.


250
00:11:56,606 --> 00:11:58,886
You can do this manually,
but there is a script


251
00:11:59,116 --> 00:12:03,236
that will do this for you, and
it's highly recommended you use.


252
00:12:03,516 --> 00:12:05,496
It's called gen strings,


253
00:12:06,116 --> 00:12:09,806
and it's highly scriptable
and customizable.


254
00:12:09,806 --> 00:12:11,926
You can add it to all of
your X code billing phases,


255
00:12:11,926 --> 00:12:13,786
and to learn about gen strings,


256
00:12:13,786 --> 00:12:14,956
you just check out
the amend page.


257
00:12:15,546 --> 00:12:18,446
So, here's an example of
how gen strings is invoked.


258
00:12:18,976 --> 00:12:21,726
What happens here is that I
look in the local directory


259
00:12:21,726 --> 00:12:25,436
for all files that end in
.m, and run gen streams


260
00:12:25,436 --> 00:12:27,656
of every single one;
meaning that it will go


261
00:12:27,656 --> 00:12:30,526
into all .m files, search
for NSLocalizedString,


262
00:12:31,056 --> 00:12:34,326
and place a localizable
.strings file


263
00:12:34,446 --> 00:12:37,126
into the English localization
folder in this case.


264
00:12:38,536 --> 00:12:41,506
So, I have a case here
when I've run gen streams


265
00:12:41,506 --> 00:12:42,856
on two separate localization,


266
00:12:43,226 --> 00:12:46,156
my .m file contained this
one NSLocalizedString,


267
00:12:46,156 --> 00:12:49,096
and I placed the strings file
in the English localization


268
00:12:49,096 --> 00:12:50,456
and the Japanese localization.


269
00:12:51,106 --> 00:12:53,526
You can see that the comments
and the key have been placed


270
00:12:53,526 --> 00:12:56,316
in the appropriate
positions, and now my localizer


271
00:12:56,316 --> 00:12:58,976
or my translators just have
to modify the right side


272
00:12:58,976 --> 00:13:01,116
of the table to localize
it to whatever language


273
00:13:01,116 --> 00:13:07,646
that this is in, and
this is done right here.


274
00:13:07,826 --> 00:13:10,666
Some issues that can come up
with using NSLocalizedString is


275
00:13:10,666 --> 00:13:13,546
that you overload your keys,
meaning you have one key


276
00:13:13,546 --> 00:13:14,966
that maps to many
different places.


277
00:13:15,876 --> 00:13:18,236
Let's say in your application,
you ask the user if they want


278
00:13:18,236 --> 00:13:19,886
to save, and you
have two buttons;


279
00:13:20,076 --> 00:13:21,546
one for yes and one for no.


280
00:13:22,716 --> 00:13:25,366
You also have another button
asking if they want to subscribe


281
00:13:25,366 --> 00:13:28,166
to the super popular
catfacts, with a button


282
00:13:28,166 --> 00:13:29,586
for yes and a button for no.


283
00:13:30,336 --> 00:13:33,236
You have one NSLocalizedString
that maps to both of these,


284
00:13:33,596 --> 00:13:36,186
and this seems to work perfectly
fine for your application.


285
00:13:37,476 --> 00:13:39,706
However, later on in
your development process,


286
00:13:39,706 --> 00:13:42,686
you start to realize that
yes and no aren't very clear,


287
00:13:43,066 --> 00:13:46,356
and should be possibly save
and cancel, but in doing so,


288
00:13:46,356 --> 00:13:49,236
you replace the string and you
inherently break the other part


289
00:13:49,236 --> 00:13:50,466
of your application, and save


290
00:13:50,466 --> 00:13:52,066
and cancel doesn't
really make any sense.


291
00:13:52,816 --> 00:13:55,446
So, it's very important
that you make sure


292
00:13:55,446 --> 00:13:59,176
that all user visible text
has its own unique key,


293
00:13:59,486 --> 00:14:01,636
so you don't run into
this issue where one part


294
00:14:01,636 --> 00:14:03,436
of your application
inherently breaks another.


295
00:14:04,416 --> 00:14:06,846
Also notice here that
when I made the change


296
00:14:06,916 --> 00:14:07,886
to NSLocalizedString,


297
00:14:08,216 --> 00:14:10,026
the comments were also
updated appropriately


298
00:14:10,026 --> 00:14:11,376
to reflect what was going on,


299
00:14:12,126 --> 00:14:13,476
which leads me to
the second issue.


300
00:14:13,846 --> 00:14:16,726
You provide no comments
to the localizer


301
00:14:16,726 --> 00:14:18,066
or insufficient comments,


302
00:14:19,096 --> 00:14:22,156
it is your localizer's worst
nightmare, and possibly


303
00:14:22,156 --> 00:14:25,046
like will hate you for this,
if you add no comment provided,


304
00:14:25,406 --> 00:14:27,606
and yes equals yes,
or not enough context.


305
00:14:28,266 --> 00:14:29,636
While in English, for example,


306
00:14:29,946 --> 00:14:32,796
yes can mean many different
things, in some languages,


307
00:14:32,796 --> 00:14:36,206
such as Chinese, the word yes
has many different possible


308
00:14:36,206 --> 00:14:38,056
translations, and
without any context


309
00:14:38,056 --> 00:14:40,546
or knowing exactly what's
going on in your application,


310
00:14:40,856 --> 00:14:43,716
your localizer will
pretty much be able


311
00:14:43,716 --> 00:14:46,226
to translate this
part of your app.


312
00:14:46,796 --> 00:14:49,636
So, it's very important that
you provide enough context


313
00:14:49,636 --> 00:14:52,166
to the translators, so
they know exactly how


314
00:14:52,346 --> 00:14:54,226
to translate your
application properly.


315
00:14:54,756 --> 00:14:58,736
The third issue is
composing phrases together,


316
00:14:58,736 --> 00:15:01,126
which is something we as
engineers do quite often;


317
00:15:02,306 --> 00:15:04,976
the reason being is that if
you compose phases together,


318
00:15:04,976 --> 00:15:07,366
some languages have
these conjugation rules


319
00:15:07,796 --> 00:15:11,706
and some grammatical rules
that depend on other parts


320
00:15:11,706 --> 00:15:13,046
of a phrase or sentence,


321
00:15:13,046 --> 00:15:15,756
and without knowing the
previous parts of your sentence,


322
00:15:15,806 --> 00:15:17,456
it will be grammatically
incorrect.


323
00:15:18,406 --> 00:15:20,716
So, for example here, I
have three strings here,


324
00:15:20,856 --> 00:15:24,436
one for go to next blank,
chapter, and then page.


325
00:15:25,506 --> 00:15:27,226
In English, this seems
to work perfectly fine,


326
00:15:27,226 --> 00:15:29,586
since go to next chapter and
go to next page are valid


327
00:15:29,586 --> 00:15:30,596
and grammatically correct.


328
00:15:31,526 --> 00:15:33,316
However, if I'm a
Spanish localizer,


329
00:15:33,316 --> 00:15:37,656
and I try to translate this, I
see go to next and then chapter.


330
00:15:37,956 --> 00:15:40,046
Since chapter is
a masculine noun,


331
00:15:40,286 --> 00:15:44,076
and I must have a masculine
article in order to agree


332
00:15:44,076 --> 00:15:46,656
with chapter, this is going
to work perfectly fine.


333
00:15:47,566 --> 00:15:50,116
When it comes to page, since
page is a feminine noun,


334
00:15:50,476 --> 00:15:51,916
the article must be feminine,


335
00:15:51,916 --> 00:15:53,476
but if I've already
made it masculine,


336
00:15:53,476 --> 00:15:55,206
then this is inherently broken,


337
00:15:55,206 --> 00:15:57,106
and this localization
is broken for Spanish.


338
00:15:57,906 --> 00:16:00,356
So, it's very important
to make sure again


339
00:16:00,356 --> 00:16:04,236
that your user visible text
each has their own unique key,


340
00:16:04,576 --> 00:16:07,876
and you compose things in
a sentence wise, or else,


341
00:16:07,876 --> 00:16:09,426
you're going to run
into grammatical issues.


342
00:16:11,016 --> 00:16:12,956
There are going to be
some cases, however,


343
00:16:12,956 --> 00:16:16,676
when you are going to have to
dynamically create strings,


344
00:16:16,676 --> 00:16:19,246
such as when it comes to
the case of pluralization.


345
00:16:19,916 --> 00:16:23,116
This is cases where if I want
to display to the user I have 0


346
00:16:23,116 --> 00:16:25,626
of something remaining, one
of something, or more than one


347
00:16:25,626 --> 00:16:27,816
of something, and
in some languages,


348
00:16:27,816 --> 00:16:31,056
this can get very complicated,
where there's a different string


349
00:16:31,056 --> 00:16:34,326
for two to five of something or
10-14 of something and so on.


350
00:16:35,316 --> 00:16:37,396
There is a new feature
in OS X Mavericks


351
00:16:37,396 --> 00:16:41,846
and iOS 7 called strings
dict, which a localized P list


352
00:16:41,846 --> 00:16:44,406
that essentially
handles all these cases


353
00:16:44,406 --> 00:16:45,756
of pluralization for you.


354
00:16:46,496 --> 00:16:49,026
You as a developer do not
need to call any new API's,


355
00:16:49,256 --> 00:16:51,476
since strings dict will
be called automatically,


356
00:16:51,476 --> 00:16:54,406
if it's available, and your
localizers then just have


357
00:16:54,406 --> 00:16:55,396
to fill out this P list,


358
00:16:55,396 --> 00:16:57,506
and will handle all
these cases for you.


359
00:16:58,556 --> 00:17:00,976
To learn more about this in
complete technical detail,


360
00:17:01,036 --> 00:17:03,466
check out the foundation
release notes, but if you want


361
00:17:03,466 --> 00:17:06,246
to learn how to get the setup
and have a brief tutorial


362
00:17:06,246 --> 00:17:09,026
about this, check out the
"What's New in Cocoa Video"


363
00:17:09,026 --> 00:17:10,996
for the session that
was held two days ago.


364
00:17:12,516 --> 00:17:14,906
So, here's an example
of strings dict


365
00:17:14,906 --> 00:17:16,665
on two separate localizations;


366
00:17:16,816 --> 00:17:18,526
one for English and
one for Russian.


367
00:17:19,246 --> 00:17:22,846
You can see that the English
localization has very simple


368
00:17:22,846 --> 00:17:25,256
case with one and
anything but one,


369
00:17:25,386 --> 00:17:27,636
and the Russian case can
get very, very complicated.


370
00:17:29,976 --> 00:17:34,906
Now, aside from text, which
is the most localizing you'll


371
00:17:34,906 --> 00:17:37,676
probably be doing, you can
localize other things as well,


372
00:17:37,676 --> 00:17:40,026
such as your images,
your sound files,


373
00:17:40,026 --> 00:17:41,946
and pretty much anything
can be localized.


374
00:17:42,756 --> 00:17:46,946
To do this, you create a
localized version of this file,


375
00:17:46,946 --> 00:17:49,556
and place it into the
respective localization folder


376
00:17:49,856 --> 00:17:53,086
that you wish to load for
this specific localization.


377
00:17:53,976 --> 00:17:55,516
The API's you called to call


378
00:17:55,516 --> 00:17:58,226
for these specific files
will automatically call the


379
00:17:58,226 --> 00:17:59,086
localized version.


380
00:17:59,466 --> 00:18:01,746
So, there is no need
for any extra code


381
00:18:01,746 --> 00:18:03,396
to handle for localization.


382
00:18:05,136 --> 00:18:08,876
So, let's say I have an image
here that I want to localize.


383
00:18:09,206 --> 00:18:12,816
I push this localize
button here, right there,


384
00:18:12,816 --> 00:18:16,606
and X code will then
ask me where do I want


385
00:18:16,606 --> 00:18:18,896
to place this localization file.


386
00:18:19,806 --> 00:18:21,896
In this case, I want
to move this image file


387
00:18:21,896 --> 00:18:24,516
to the English localization,
so this file will get loaded


388
00:18:24,516 --> 00:18:25,666
for the English localization.


389
00:18:26,476 --> 00:18:29,266
Any single time I want to
create a new localized file


390
00:18:29,266 --> 00:18:33,156
for this specific image here,
I just have to create a file


391
00:18:33,156 --> 00:18:34,676
with the same name,
and just place it


392
00:18:34,676 --> 00:18:37,756
into the specific
localized folder that I want,


393
00:18:38,486 --> 00:18:41,606
so for example here, I have an
RTF file that has been localized


394
00:18:41,606 --> 00:18:43,276
to several different languages,


395
00:18:43,586 --> 00:18:46,416
and all of these
RTF files are placed


396
00:18:46,416 --> 00:18:48,276
into their respective
L.proj folders.


397
00:18:50,596 --> 00:18:52,766
Now some issues that
can come up is


398
00:18:52,766 --> 00:18:54,486
that you have some
text in your image.


399
00:18:55,006 --> 00:18:56,746
While it's okay to have
text in your image,


400
00:18:56,806 --> 00:19:00,426
be aware that your localizers
will have trouble translating


401
00:19:00,426 --> 00:19:03,086
text in your image, as opposed
to just translating text itself,


402
00:19:03,086 --> 00:19:04,536
since it requires
a bit more effort


403
00:19:04,536 --> 00:19:05,906
to translate text in your image.


404
00:19:06,906 --> 00:19:09,306
The other issue is having
an image or something


405
00:19:09,306 --> 00:19:10,726
to convey a meaning to the user,


406
00:19:10,726 --> 00:19:13,696
since some images may
not necessarily work


407
00:19:14,046 --> 00:19:15,056
in other languages.


408
00:19:15,836 --> 00:19:19,626
So, for example I have a
keyword search, and I use a key


409
00:19:19,626 --> 00:19:20,886
to denote a keyword search.


410
00:19:21,516 --> 00:19:23,286
In English, this seems
to work perfectly fine,


411
00:19:23,286 --> 00:19:25,836
since I see a key, I can think
of keyword, since, you know,


412
00:19:25,836 --> 00:19:28,666
there's the same word,
but in other languages,


413
00:19:28,996 --> 00:19:32,536
the word keyword doesn't
necessarily translate to a key


414
00:19:32,536 --> 00:19:35,436
at all, since you'd come out
to head word or focus word


415
00:19:35,436 --> 00:19:38,276
or indicative word, and your
users will pretty much have no


416
00:19:38,276 --> 00:19:40,116
idea why you have
a key for keyword,


417
00:19:40,116 --> 00:19:42,106
so the idea is completely
lost in translation.


418
00:19:43,776 --> 00:19:46,136
Another issue is having
a cultural reference,


419
00:19:46,136 --> 00:19:48,646
or something that's specific
to a specific culture,


420
00:19:48,646 --> 00:19:51,776
and this may run
into some issues.


421
00:19:52,276 --> 00:19:55,576
So, for example, in Japan,
this image here is placed


422
00:19:55,576 --> 00:19:59,356
onto the back of all cars for
anyone who is inexperienced


423
00:19:59,356 --> 00:20:00,956
or a beginner driver
to alert other drivers


424
00:20:00,956 --> 00:20:01,926
that she should probably
get out of the way.


425
00:20:02,306 --> 00:20:08,576
Some Japanese developers
sometimes use this to show


426
00:20:08,576 --> 00:20:11,366
that this is a tutorial or a
beginner's guide to something,


427
00:20:11,366 --> 00:20:15,066
and if someone isn't well
versed in the Japanese culture,


428
00:20:15,066 --> 00:20:16,536
or doesn't know anything
about Japan,


429
00:20:16,536 --> 00:20:18,606
they pretty much have no
idea what this icon is,


430
00:20:18,606 --> 00:20:20,546
and they'll get lost
in your application.


431
00:20:21,356 --> 00:20:23,526
So, make sure that any
images that you have


432
00:20:23,596 --> 00:20:26,726
that display a meaning or try
to convey a meaning to the user,


433
00:20:27,166 --> 00:20:29,606
is workable for all the
localizations you want


434
00:20:29,606 --> 00:20:30,136
to support.


435
00:20:31,636 --> 00:20:33,516
Now once you've localized
your application,


436
00:20:33,516 --> 00:20:36,246
you'll want to test this out,
and the most accurate way


437
00:20:36,246 --> 00:20:39,136
to do this, and to see exactly
what your user is going to see,


438
00:20:39,516 --> 00:20:42,166
is to change the system
language inside of your system


439
00:20:42,166 --> 00:20:43,176
to the language you want.


440
00:20:43,876 --> 00:20:45,106
Also, the other reason is,


441
00:20:45,106 --> 00:20:49,326
is that some system services may
not work in that localization


442
00:20:49,366 --> 00:20:52,036
until you explicitly send the
language to that localization.


443
00:20:53,066 --> 00:20:54,896
However, if you want to
quickly check whether


444
00:20:54,896 --> 00:20:57,306
or not a string has
been localized


445
00:20:57,306 --> 00:21:00,986
or a file loads correctly,
you can run your application


446
00:21:00,986 --> 00:21:03,566
in X code using the dash
Apple language as argument.


447
00:21:04,016 --> 00:21:05,256
And, in this example here,


448
00:21:05,296 --> 00:21:07,746
no matter what language my
system is in, it's going to run


449
00:21:07,746 --> 00:21:09,546
in the Korean localization.


450
00:21:10,976 --> 00:21:13,786
A really cool way to
check whether or not


451
00:21:13,786 --> 00:21:16,046
if your application
has been localized,


452
00:21:16,046 --> 00:21:18,316
and to test out whether
your interface will work


453
00:21:18,316 --> 00:21:20,996
for longer strings,
longer strings,


454
00:21:20,996 --> 00:21:22,476
is to use pseudo localization.


455
00:21:23,396 --> 00:21:24,796
So, what's pseudo localization?


456
00:21:25,426 --> 00:21:28,516
Pseudo localization
is a way, well,


457
00:21:28,516 --> 00:21:31,396
if you have your strings
files, you can run a script


458
00:21:31,546 --> 00:21:34,736
through the user visible text
in your string to modify it


459
00:21:34,736 --> 00:21:36,636
and distort it, such
that it is longer


460
00:21:36,636 --> 00:21:39,246
than what's originally there,
and will distort it to the point


461
00:21:39,246 --> 00:21:41,076
where if you were looking
in your application


462
00:21:41,076 --> 00:21:43,896
to check whether or not some
strings have been localized,


463
00:21:44,226 --> 00:21:46,626
you can obviously tell whether
you're missing some parts


464
00:21:46,626 --> 00:21:47,986
or you forget to
localize something.


465
00:21:48,886 --> 00:21:50,676
And, with that, I'd
like to bring back Doug


466
00:21:50,676 --> 00:21:51,976
up to show us a demo on
how localization works.


467
00:21:52,516 --> 00:21:55,656
[ Applause ]


468
00:21:56,156 --> 00:21:58,896
>> Thanks Albert so in
order to demo this out,


469
00:21:59,656 --> 00:22:04,756
we wrote a tiny little
application.


470
00:22:04,756 --> 00:22:09,966
So, what this application
does is it lets me type


471
00:22:10,016 --> 00:22:18,556
in some brief little notes,
and then it shows them


472
00:22:18,556 --> 00:22:20,276
in a scrolling list,
really simple.


473
00:22:25,006 --> 00:22:30,186
And, so the first version
of this application


474
00:22:30,186 --> 00:22:32,906
that we have here is
not localized at all.


475
00:22:33,336 --> 00:22:35,686
Notice, it's not using
base internationalization;


476
00:22:35,686 --> 00:22:36,686
that's turned off.


477
00:22:37,016 --> 00:22:43,426
The only localization that's
there is English, and if I look


478
00:22:43,426 --> 00:22:46,756
at my nib file, it's all in
English, and if I take a look


479
00:22:46,756 --> 00:22:51,186
at my code, I notice that there
are some user visible strings


480
00:22:51,186 --> 00:22:53,036
in here; for example when
I'm creating an alert,


481
00:22:54,116 --> 00:22:56,206
they're just static
explicit strings,


482
00:22:56,786 --> 00:22:59,926
and for setting the title of
the window to reflect the number


483
00:23:00,006 --> 00:23:05,656
of notes, I have
switched between one note


484
00:23:05,656 --> 00:23:08,246
or multiple notes, so
it's all in English.


485
00:23:08,786 --> 00:23:15,706
So, what that means is that if
I go in and change my system


486
00:23:15,876 --> 00:23:20,136
into say German, and then run
the app again, nothing changes


487
00:23:20,136 --> 00:23:21,626
at all, it's not localized.


488
00:23:22,266 --> 00:23:31,616
So, the next thing to do
is to create a new version


489
00:23:31,616 --> 00:23:34,826
of this application,
and we turned


490
00:23:34,826 --> 00:23:36,806
on base internationalization.


491
00:23:37,976 --> 00:23:40,526
What that does is create
a base localization,


492
00:23:40,526 --> 00:23:42,856
and that's where
our nib file goes,


493
00:23:42,856 --> 00:23:46,956
and then we added an additional
German localization to this app.


494
00:23:48,066 --> 00:23:51,146
So, if we take a look at our nib
file, it has not changed at all.


495
00:23:51,146 --> 00:23:53,156
The only thing that happened
to it is that it moved


496
00:23:53,156 --> 00:23:58,616
from the English localization
into the base, and in addition,


497
00:23:59,176 --> 00:24:03,076
we get a strings file
associated with it


498
00:24:03,766 --> 00:24:07,266
that contains the
translations; we added a rough


499
00:24:07,266 --> 00:24:10,076
and ready German translation
here, to the various strings


500
00:24:10,076 --> 00:24:15,506
that appear in that nib
file, and then we run the app


501
00:24:15,506 --> 00:24:18,656
in German, these will
automatically be substituted


502
00:24:18,656 --> 00:24:21,756
into that nib, in
place of all the places


503
00:24:21,756 --> 00:24:23,736
where the English text appears.


504
00:24:24,336 --> 00:24:29,886
In addition in code, we
took these explicit strings,


505
00:24:29,886 --> 00:24:32,466
and replaced them calls
to NSLocalizedString


506
00:24:32,536 --> 00:24:36,456
with suitable keys and suitable
comments for the localizer,


507
00:24:37,546 --> 00:24:40,336
and then for the title that
reflects the number of notes,


508
00:24:40,336 --> 00:24:41,666
we're going to use
a string sticks,


509
00:24:42,256 --> 00:24:46,416
to get appropriate
localization of plurals


510
00:24:46,986 --> 00:24:49,156
in whatever language we're
translating this into.


511
00:24:49,996 --> 00:24:53,216
So, we ran gen strings on
this, and the result is


512
00:24:53,216 --> 00:24:56,066
that we have localizable
string files for English,


513
00:24:57,396 --> 00:25:01,286
and then for German, where we
put in appropriate translations


514
00:25:01,656 --> 00:25:06,606
for each of the keys that
appear in our NSLocalizedString,


515
00:25:07,096 --> 00:25:10,266
and created string
sticks for details


516
00:25:10,616 --> 00:25:13,556
on the format string
sticked file.


517
00:25:13,556 --> 00:25:15,886
You can again, take a look at
the foundation of these styles.


518
00:25:15,886 --> 00:25:19,476
If explains it all in detail,
but the business part of it,


519
00:25:20,426 --> 00:25:23,046
has these lines that
describe what to do for,


520
00:25:23,116 --> 00:25:25,666
when the number is
one, and what to do


521
00:25:25,666 --> 00:25:26,866
when the number is
other than one.


522
00:25:26,866 --> 00:25:29,906
So, for English, we chose
a very simple set of rules.


523
00:25:30,536 --> 00:25:33,096
For German, it got a
little more complicated.


524
00:25:33,136 --> 00:25:36,606
We have rules for 0,
one or anything else.


525
00:25:38,496 --> 00:25:40,896
And, let's see what
happens when this ends


526
00:25:40,896 --> 00:25:43,556
up in our built application.


527
00:25:43,556 --> 00:25:45,656
So, here we're taking a
look inside the app bundle.


528
00:25:46,196 --> 00:25:48,306
In the resources we
have a base L.proj


529
00:25:48,476 --> 00:25:52,446
that contains our nib file, so
there's only one copy of that,


530
00:25:52,446 --> 00:25:57,846
and then in German L.proj, we
have just the strings file,


531
00:25:57,846 --> 00:26:00,926
the strings dict, and that
credits file that X code wants


532
00:26:00,926 --> 00:26:04,736
to create for us,
and when we run this,


533
00:26:05,866 --> 00:26:11,096
then the main menu.strings
contents should be automatically


534
00:26:11,096 --> 00:26:12,556
substituted into our nib.


535
00:26:13,686 --> 00:26:17,626
So, let's try that out.


536
00:26:17,906 --> 00:26:22,426
And, we see one right now, the
whole interface is in German.


537
00:26:23,496 --> 00:26:27,066
We got our strings sticks
has given us a proper title


538
00:26:27,066 --> 00:26:32,286
for 0 items, and even
our menus are localized.


539
00:26:32,756 --> 00:26:35,886
Even the Apple menu stuff, this
comes from outside our app,


540
00:26:36,366 --> 00:26:43,886
all localized properly, and
our localized strings show


541
00:26:43,886 --> 00:26:44,596
up in the alert.


542
00:26:45,946 --> 00:26:49,316
So, that is the basic
process of localizing an app.


543
00:26:50,226 --> 00:26:52,336
Let me go back to the slides.


544
00:26:53,956 --> 00:26:56,276
And next, I want to bring
up my colleague, Nat,


545
00:26:56,426 --> 00:26:57,976
to talk about dealing
with locale data.


546
00:26:58,516 --> 00:27:00,946
[ Applause ]


547
00:27:01,446 --> 00:27:02,506
>> Okay, hello, hello.


548
00:27:02,776 --> 00:27:03,346
Thank you, Doug.


549
00:27:03,486 --> 00:27:05,836
So, my name is Nat Hillard,
and for this section,


550
00:27:05,836 --> 00:27:07,866
we will be going
over locale data.


551
00:27:08,516 --> 00:27:12,486
So, another critical aspect of
making your app world ready,


552
00:27:12,706 --> 00:27:16,296
is presenting numbers, dates,
times, and symbols in a manner


553
00:27:16,296 --> 00:27:17,786
that is appropriate
for your users.


554
00:27:18,306 --> 00:27:20,726
Now, to do this isn't
just a stylistic issue.


555
00:27:20,726 --> 00:27:23,546
It can have practical usability
complications and implications


556
00:27:23,546 --> 00:27:26,976
as well, and ultimately, you
can conceive of this process


557
00:27:26,976 --> 00:27:29,586
as translating between
machine readable data


558
00:27:29,826 --> 00:27:31,196
and user readable strengths.


559
00:27:31,656 --> 00:27:35,056
Now, interestingly, this is
not a one to one mapping.


560
00:27:35,056 --> 00:27:36,326
Things can get pretty
complicated.


561
00:27:36,796 --> 00:27:39,766
Now, luckily, we provided a set
of API's for you that do a lot


562
00:27:39,766 --> 00:27:40,956
of the heavy lifting for you.


563
00:27:41,466 --> 00:27:43,746
So, in this section, I'll
be going over the first five


564
00:27:43,746 --> 00:27:45,556
in this table, and Doug
will cover NS string


565
00:27:45,556 --> 00:27:46,786
in more detail in the next.


566
00:27:47,366 --> 00:27:49,406
So, first of all,
what is a locale?


567
00:27:50,256 --> 00:27:53,226
In an abstract sense, it's a
collection of user preferences


568
00:27:53,226 --> 00:27:54,336
with regard to formatting.


569
00:27:54,746 --> 00:27:56,446
The users will set
this, as Doug mentioned,


570
00:27:56,446 --> 00:27:59,816
in the region format
preference on iOS or on OS X


571
00:27:59,926 --> 00:28:01,936
in the languages and
format preference pane.


572
00:28:02,396 --> 00:28:05,516
In a concrete sense, it
is represented in Cocoa


573
00:28:05,836 --> 00:28:09,106
with the NS locale API.


574
00:28:10,156 --> 00:28:12,156
Usually as a programmer,
you will not be dealing


575
00:28:12,156 --> 00:28:14,096
with the NS locale
object directly.


576
00:28:14,186 --> 00:28:17,246
Instead, interacting with it at
the class level or passing it


577
00:28:17,246 --> 00:28:19,506
in as argument to other API's.


578
00:28:20,886 --> 00:28:23,526
So, important to keep in mind,
however, is the distinction


579
00:28:23,526 --> 00:28:25,496
between a local and
a localization.


580
00:28:25,896 --> 00:28:28,956
Locale represents the formatting
standards for a particular user.


581
00:28:29,206 --> 00:28:30,816
These are informed
by their region,


582
00:28:30,996 --> 00:28:32,446
their language, and
their script.


583
00:28:32,956 --> 00:28:35,226
On the other hand, localization
refers to the language


584
00:28:35,226 --> 00:28:36,386
of the user interface.


585
00:28:36,786 --> 00:28:38,696
Now, these can often
be the same,


586
00:28:38,696 --> 00:28:40,486
but for a given user,
they may differ.


587
00:28:41,606 --> 00:28:45,166
As an example of using locale
information to present,


588
00:28:45,366 --> 00:28:47,736
or locale data to present
information to your users,


589
00:28:47,736 --> 00:28:49,256
let's take a look
at formatting dates.


590
00:28:49,756 --> 00:28:52,746
So, for this, we've provided
the NS date formatter.


591
00:28:53,096 --> 00:28:56,906
This converts between NS
date machine readable data


592
00:28:57,016 --> 00:28:59,626
and a string representation
for a particular user.


593
00:29:00,986 --> 00:29:03,576
Often, you'll be working with
this and explicitly attaching it


594
00:29:03,606 --> 00:29:05,976
to a text field within
your nib file.


595
00:29:06,486 --> 00:29:08,266
On the other hand, if you
need to use it in code,


596
00:29:08,266 --> 00:29:10,196
you can call localized
string from date;


597
00:29:10,456 --> 00:29:12,236
passing in your NS date, as well


598
00:29:12,236 --> 00:29:14,086
as a date style and
a time style.


599
00:29:15,176 --> 00:29:17,336
So, what do these date
and time styles look like?


600
00:29:17,826 --> 00:29:19,096
Well, they differ in the amount


601
00:29:19,096 --> 00:29:20,826
of information they're
presenting to the user


602
00:29:20,826 --> 00:29:22,136
about your NS date object.


603
00:29:22,796 --> 00:29:25,006
Here, they can vary
from anything as short


604
00:29:25,006 --> 00:29:27,316
as a short style, where you're
simply presenting numbers,


605
00:29:27,726 --> 00:29:29,716
to the full style where
you spell everything out.


606
00:29:30,166 --> 00:29:31,936
As well, as if you need
to suppress either one


607
00:29:31,936 --> 00:29:33,486
of these, you can use no style.


608
00:29:34,936 --> 00:29:38,996
So, to see what this looks
like, we call localized string


609
00:29:38,996 --> 00:29:41,176
from date on the NS
date formatter class.


610
00:29:41,526 --> 00:29:44,386
We pass in our date, and we
pass in medium style for date


611
00:29:44,636 --> 00:29:45,956
and short style for time.


612
00:29:46,736 --> 00:29:50,216
Now, keep in mind this will
do the heavy lifting for us,


613
00:29:50,416 --> 00:29:51,646
and present this information


614
00:29:51,646 --> 00:29:53,786
in a locale appropriate
manner for our given user.


615
00:29:54,436 --> 00:29:57,246
So, here we have three locales,
English as used in the US,


616
00:29:57,506 --> 00:30:01,266
French as used in France,
and Chinese as used in China.


617
00:30:01,266 --> 00:30:04,106
Here we have the out of
the box representation


618
00:30:04,106 --> 00:30:06,166
of a single NS date object.


619
00:30:06,866 --> 00:30:09,526
Here we have June 6, 2013,


620
00:30:09,526 --> 00:30:11,226
a presentation familiar
in US English.


621
00:30:12,536 --> 00:30:15,666
On the other hand in France,
this API has done the work


622
00:30:15,666 --> 00:30:18,756
of presenting first the day
number, followed by the month,


623
00:30:18,756 --> 00:30:20,476
followed by the year,
and without a coma.


624
00:30:21,126 --> 00:30:23,786
Also, in Chinese, we presented
the year number first,


625
00:30:23,976 --> 00:30:25,306
followed by the character
for year,


626
00:30:25,526 --> 00:30:27,816
followed by the month
number, character for month,


627
00:30:27,816 --> 00:30:29,896
and day number, followed
by character for day.


628
00:30:30,516 --> 00:30:33,846
Likewise with times, we
present AM in the United States.


629
00:30:34,216 --> 00:30:37,436
We don't provide either
AM or PM for France,


630
00:30:37,436 --> 00:30:40,326
which traditionally uses
24 hour time, and in China,


631
00:30:40,326 --> 00:30:42,756
we present the characters
for morning,


632
00:30:43,076 --> 00:30:45,706
followed by our single
time object.


633
00:30:46,326 --> 00:30:48,706
So, this is the preferred
way to work with NS date.


634
00:30:49,016 --> 00:30:51,476
Out of the box, calling a
class method, localized string


635
00:30:51,476 --> 00:30:53,926
from date, you've gotten three
very different representations


636
00:30:53,926 --> 00:30:54,926
from the same object.


637
00:30:55,116 --> 00:30:59,276
If on the other hand, you
want to present a custom view


638
00:30:59,276 --> 00:31:00,706
of this same NS date object,


639
00:31:00,706 --> 00:31:04,886
you have to go beyond the
certain present packaged styles.


640
00:31:05,256 --> 00:31:09,046
Keep in mind that the medium
style will always present the


641
00:31:09,046 --> 00:31:11,226
month, the day, and the year.


642
00:31:11,626 --> 00:31:13,076
Let's say for instance
though that you wanted


643
00:31:13,076 --> 00:31:15,036
to only present the
month and the day.


644
00:31:15,406 --> 00:31:17,566
So, when the default styles
don't meet your needs,


645
00:31:17,966 --> 00:31:20,576
you create an instance of
the NS day formatter class.


646
00:31:21,476 --> 00:31:24,166
From there, you create
a format string.


647
00:31:24,466 --> 00:31:27,546
This is done with date format
from template, a class method


648
00:31:27,546 --> 00:31:28,556
on interstate formatter.


649
00:31:29,206 --> 00:31:31,276
To this, you pass
a format string.


650
00:31:31,666 --> 00:31:32,826
Now, for more information
on this,


651
00:31:32,826 --> 00:31:35,636
you can check Unicode
standard 35, which has a lot


652
00:31:35,636 --> 00:31:36,526
of information on this.


653
00:31:36,886 --> 00:31:38,346
Suffice it to say,
we've said here


654
00:31:38,346 --> 00:31:39,536
that we want the day number,


655
00:31:39,536 --> 00:31:41,666
followed by an abbreviated
form of the month.


656
00:31:41,726 --> 00:31:43,716
This can go into
a lot of detail.


657
00:31:43,716 --> 00:31:47,976
These format strings can present
everything from given variance


658
00:31:47,976 --> 00:31:50,316
of abbreviations, as
well as fully spelled


659
00:31:50,316 --> 00:31:51,876
out or number variance.


660
00:31:52,566 --> 00:31:55,106
Also critically, we
pass here the locale,


661
00:31:55,326 --> 00:31:56,666
NS locale, current locale.


662
00:31:57,966 --> 00:32:01,596
So, this is the correct to do
it, but, there is, oh, sorry,


663
00:32:01,756 --> 00:32:06,326
finally, we set the date format
on our date formatter instance.


664
00:32:06,596 --> 00:32:08,776
Now, this is the
correct way to do it.


665
00:32:08,776 --> 00:32:11,246
However, there is an incorrect
and naive way to do it.


666
00:32:11,696 --> 00:32:13,606
Let's say you've read
Unicode standard 35,


667
00:32:13,936 --> 00:32:16,676
and you've explicitly set
date format to a string


668
00:32:16,676 --> 00:32:17,426
that you've read about here.


669
00:32:17,426 --> 00:32:19,806
You want the month, followed by
the day, followed by the year.


670
00:32:20,136 --> 00:32:22,606
Notice though that we haven't
got through the template object.


671
00:32:23,256 --> 00:32:24,696
The template does
the work for us


672
00:32:24,696 --> 00:32:26,176
of rearranging the components,


673
00:32:26,176 --> 00:32:27,716
so they're appropriate
for a given locale.


674
00:32:28,466 --> 00:32:30,666
Consequently though, when we
call from string from date,


675
00:32:30,666 --> 00:32:33,216
we get a representation that
is the same for all three


676
00:32:33,216 --> 00:32:34,786
of these very different locales.


677
00:32:35,756 --> 00:32:37,426
So, this is not the
correct way to do this.


678
00:32:37,476 --> 00:32:40,616
Instead, going through the
intermediary of date format


679
00:32:40,616 --> 00:32:42,966
from template, it will do
the rearranging for us.


680
00:32:43,406 --> 00:32:46,546
Consequently, if we pass in
lower case d, capital MMM,


681
00:32:46,606 --> 00:32:50,866
day and number, basically
indicating that we wish


682
00:32:50,866 --> 00:32:55,646
to convey day number and
month, and then call a string


683
00:32:55,646 --> 00:32:58,116
from date, we get the
appropriate representation


684
00:32:58,116 --> 00:32:58,946
for a given locale.


685
00:32:59,326 --> 00:33:01,446
We have the month name
followed by number in the US,


686
00:33:01,846 --> 00:33:05,526
the vice versa in France, and
in China, we have month number,


687
00:33:05,526 --> 00:33:09,156
followed by month
character, day, day character.


688
00:33:10,086 --> 00:33:12,366
Likewise though, with NS dates,


689
00:33:12,366 --> 00:33:14,086
let's take a look at
number formatting.


690
00:33:14,116 --> 00:33:16,086
This is another area in
which there's a great degree


691
00:33:16,086 --> 00:33:17,256
of variation around the world.


692
00:33:18,166 --> 00:33:21,146
To help you with this, we
have NS number formatter,


693
00:33:21,426 --> 00:33:23,426
which is meant to mirror
an estate formatter.


694
00:33:24,476 --> 00:33:27,506
As an example of the type of
variation you may come across,


695
00:33:27,726 --> 00:33:29,256
you'll have everything
from the separator


696
00:33:29,256 --> 00:33:31,846
between the thousands digit
and the decimal digit.


697
00:33:32,286 --> 00:33:34,686
Likewise, even the
digits themselves,


698
00:33:34,686 --> 00:33:36,446
something we may take
for granted, can vary.


699
00:33:36,736 --> 00:33:39,186
On the right, we have an
aerobic Egyptian representation


700
00:33:39,186 --> 00:33:40,316
of this same digit number.


701
00:33:41,066 --> 00:33:42,696
Currency can differ
in the symbol,


702
00:33:42,696 --> 00:33:43,756
as well as the separators.


703
00:33:44,146 --> 00:33:46,446
Percentage size itself
can differ, as well again,


704
00:33:46,446 --> 00:33:48,986
we see the digits
differing, and even numbers


705
00:33:48,986 --> 00:33:51,286
that are not numbers,
so not a number can come


706
00:33:51,286 --> 00:33:53,666
up differently in
different locales.


707
00:33:54,596 --> 00:33:59,006
Again though one thing to avoid
is providing explicit format


708
00:33:59,006 --> 00:34:01,656
strings, so those of you coming
from C world will be familiar


709
00:34:01,656 --> 00:34:04,546
with the print F style
C format strings.


710
00:34:05,076 --> 00:34:07,946
Here we call string from
format on NS String,


711
00:34:08,386 --> 00:34:11,755
saying that we want a floating
point number with three digits.


712
00:34:11,755 --> 00:34:14,746
Consequently though, we get
the same number for all three


713
00:34:14,746 --> 00:34:15,946
of these very different locales.


714
00:34:16,735 --> 00:34:18,426
This is not the correct
way to do it.


715
00:34:19,045 --> 00:34:23,016
So, one way to do a very
simple in place fix,


716
00:34:23,016 --> 00:34:25,186
is to instead called
localized string


717
00:34:25,186 --> 00:34:26,676
of format on your NS String.


718
00:34:27,065 --> 00:34:28,826
This is only for a code
that exists already,


719
00:34:28,826 --> 00:34:30,306
and is a simple in place fix.


720
00:34:30,786 --> 00:34:34,255
However, if you're making code
that will be used going forward,


721
00:34:34,255 --> 00:34:36,226
we prefer using the
NS number formatter.


722
00:34:36,735 --> 00:34:38,476
Here you call localized
string with number,


723
00:34:38,636 --> 00:34:41,246
pass in your NS number,
and pass in again,


724
00:34:41,246 --> 00:34:43,036
an explicit format string.


725
00:34:43,976 --> 00:34:46,985
And, this will do the
heavy lifting for you


726
00:34:46,985 --> 00:34:47,956
in presenting a number


727
00:34:47,956 --> 00:34:50,346
in a locale appropriate
manner for a given user.


728
00:34:52,016 --> 00:34:55,766
So, like NS day formatter, we
have explicit preset styles.


729
00:34:56,136 --> 00:34:57,246
Here's what these look like.


730
00:34:57,526 --> 00:35:00,186
Let's start with an NS number
literal, denoted by the at sign,


731
00:35:00,186 --> 00:35:03,846
followed by the number, 1234.56,


732
00:35:04,446 --> 00:35:06,786
decimal style will
do the correct thing.


733
00:35:06,786 --> 00:35:10,936
Here on this table we have,
the left column is US English,


734
00:35:10,936 --> 00:35:12,626
and on the right are
variants you may encounter


735
00:35:12,626 --> 00:35:13,146
around the world.


736
00:35:13,946 --> 00:35:16,746
Again, see in Italy,
we have the period


737
00:35:16,746 --> 00:35:17,676
and the coma have flipped.


738
00:35:18,146 --> 00:35:19,736
Currency style is
different in China.


739
00:35:20,216 --> 00:35:23,406
Percentage style differs
in these two aspects again,


740
00:35:23,406 --> 00:35:25,916
and even scientific style can
differ in that it uses the comma


741
00:35:25,916 --> 00:35:27,596
to separate out the
significant digits.


742
00:35:28,736 --> 00:35:31,076
Finally, the spell out style
itself can be dramatically


743
00:35:31,076 --> 00:35:32,526
different between both locales.


744
00:35:32,806 --> 00:35:37,226
So, let's go into more detail


745
00:35:37,226 --> 00:35:39,106
about the NS locale
object itself.


746
00:35:40,036 --> 00:35:43,156
Traditionally, the
standard API's will do,


747
00:35:43,156 --> 00:35:45,176
take into account this
information for you.


748
00:35:45,176 --> 00:35:49,526
To give it as an information,
sorry, to give it as an argument


749
00:35:49,526 --> 00:35:51,656
to an NS number formatter
and NS date formatter,


750
00:35:51,966 --> 00:35:54,966
you can call current
locale the class method


751
00:35:54,966 --> 00:35:57,896
or auto updating current
locale, which will listen


752
00:35:57,896 --> 00:35:59,476
for notification that indicates


753
00:35:59,476 --> 00:36:02,626
that the user has changed your
locale as your app is running.


754
00:36:03,736 --> 00:36:06,776
From there, if you
want even more detail,


755
00:36:06,836 --> 00:36:09,176
you can create an instance
of the NS locale class.


756
00:36:09,596 --> 00:36:13,566
From there, you can call object
for key with various keys


757
00:36:13,566 --> 00:36:14,536
to get more information.


758
00:36:15,276 --> 00:36:17,266
For instance, let's
say you want to see


759
00:36:17,266 --> 00:36:19,096
if a given user uses
the metric system.


760
00:36:19,576 --> 00:36:22,586
This information is stored in an
instance of the NS locale class.


761
00:36:22,996 --> 00:36:25,656
You call object for key
with uses metric system.


762
00:36:26,446 --> 00:36:28,446
Likewise, you can get
the currency symbol,


763
00:36:28,826 --> 00:36:30,336
or for a slightly
more detailed example,


764
00:36:30,336 --> 00:36:31,346
you can get the beginning


765
00:36:31,346 --> 00:36:33,306
and end quotation marks
for a given locale.


766
00:36:33,936 --> 00:36:36,856
All this is available from an
instance of NS locale class.


767
00:36:38,006 --> 00:36:41,736
So, here, let's see what this
looks like in a real example,


768
00:36:41,736 --> 00:36:43,006
where you call a
string from format,


769
00:36:43,006 --> 00:36:46,916
and pass in our previously
obtained beginning quote string


770
00:36:46,916 --> 00:36:47,456
and end quote.


771
00:36:47,766 --> 00:36:50,476
As a result, we have the
appropriate quotation marks


772
00:36:50,476 --> 00:36:52,516
for China, France, and Japan.


773
00:36:52,606 --> 00:36:54,646
We have the angle
brackets for France


774
00:36:54,646 --> 00:36:56,076
and the square brackets
for Japan.


775
00:36:56,576 --> 00:37:00,766
Keep in mind though,
the distinction


776
00:37:00,766 --> 00:37:02,686
between a locale
and a localization.


777
00:37:04,076 --> 00:37:07,106
To get a given user's
localization, that is to say,


778
00:37:07,316 --> 00:37:08,776
the user interface language


779
00:37:08,776 --> 00:37:10,716
that the user is
running your app within,


780
00:37:10,956 --> 00:37:13,416
you call preferred
localizations on an instance


781
00:37:13,416 --> 00:37:14,616
of the NS bundle class.


782
00:37:15,036 --> 00:37:17,946
On the other hand, to get the
locale you call current locale


783
00:37:17,946 --> 00:37:18,976
on the locale object.


784
00:37:19,396 --> 00:37:21,606
This is what you'll be passing
into the formatting objects


785
00:37:21,976 --> 00:37:24,466
in order to obtain the
appropriate representation.


786
00:37:26,196 --> 00:37:28,846
So, one final area in which
you'll see a lot of variation


787
00:37:28,846 --> 00:37:32,686
around the world is in the
presentation of calendars.


788
00:37:32,746 --> 00:37:35,516
We may take for granted
that this is the year 2013,


789
00:37:35,756 --> 00:37:38,766
or year 2011, and you
can see that in fact,


790
00:37:38,816 --> 00:37:45,676
this is simultaneously also
the year 1432, 2554, 5771.


791
00:37:45,676 --> 00:37:48,756
Likewise, this era
is AD or CE here,


792
00:37:48,756 --> 00:37:50,666
but in Japan, it's
the Hassay era.


793
00:37:50,666 --> 00:37:53,256
The number of months per
year, length of the months,


794
00:37:53,256 --> 00:37:54,756
the day of the week
itself can vary,


795
00:37:55,156 --> 00:37:56,906
and even the transition
of years.


796
00:37:57,246 --> 00:37:59,536
Now, here we have a transition
between the Showa period


797
00:37:59,536 --> 00:38:00,956
and the Hassay period in Japan,


798
00:38:01,276 --> 00:38:03,296
which happened as
recently as 1989.


799
00:38:03,886 --> 00:38:08,746
So, to interact with calendars,
we use the NS calendar object.


800
00:38:09,096 --> 00:38:10,576
This allows us to
do calculations


801
00:38:10,576 --> 00:38:11,506
in a more intelligent way.


802
00:38:12,466 --> 00:38:14,506
It also, it allows us to
obtain the information we saw


803
00:38:14,506 --> 00:38:16,346
in the previous table, the
number of days in the month,


804
00:38:16,346 --> 00:38:19,496
weeks in the year, etc. It also
allows us to get components


805
00:38:19,496 --> 00:38:20,766
from the date, that
then we can add


806
00:38:20,766 --> 00:38:24,236
on to additional NS date objects
to get dates in the future.


807
00:38:25,516 --> 00:38:28,206
Likewise, as I said, you
can do delta computations


808
00:38:28,206 --> 00:38:30,016
between two NS date objects.


809
00:38:31,036 --> 00:38:34,936
So, keep in mind though that NS
date itself is an abstract point


810
00:38:34,936 --> 00:38:35,516
in time.


811
00:38:36,266 --> 00:38:39,236
You must interpret this NS
date object through the lens


812
00:38:39,236 --> 00:38:41,796
of an NS calendar if you're
presenting it to the user.


813
00:38:42,476 --> 00:38:43,766
If you're using a
code internally,


814
00:38:43,766 --> 00:38:45,946
of course it's still fine
to use the NS date object.


815
00:38:46,016 --> 00:38:51,066
So, let's see an example of
getting the components of a date


816
00:38:51,066 --> 00:38:52,056
that may be of interest to you.


817
00:38:52,596 --> 00:38:55,476
We here, call components
from date,


818
00:38:55,476 --> 00:38:57,106
passing in our NS date object,


819
00:38:57,526 --> 00:39:00,106
and passing in the individual
units that we wish to obtain.


820
00:39:00,676 --> 00:39:03,796
Keep in mind here, you'll
only obtain these units


821
00:39:03,796 --> 00:39:06,496
that you explicitly specify
that are returned in the form


822
00:39:06,496 --> 00:39:08,236
of an NS date components object.


823
00:39:09,326 --> 00:39:11,746
From there, you can
call day, month, year,


824
00:39:11,746 --> 00:39:13,616
and era to get this
information out of the object


825
00:39:13,616 --> 00:39:14,416
that you've just created.


826
00:39:15,046 --> 00:39:17,366
You can then this NS
date components object


827
00:39:17,616 --> 00:39:23,216
onto an additional NS calendar
method to add these components


828
00:39:23,246 --> 00:39:25,966
to an existing NS date, and
obtain a date in the future.


829
00:39:26,836 --> 00:39:30,526
Now, this is important because
calendar computations can


830
00:39:30,526 --> 00:39:31,576
be complicated.


831
00:39:32,696 --> 00:39:34,766
The common thing to
keep in mind is that,


832
00:39:34,766 --> 00:39:37,236
let's say we do some simple
arithmetic and we say,


833
00:39:37,446 --> 00:39:40,436
well a day is 60
x 60 x 24 seconds.


834
00:39:40,686 --> 00:39:43,506
So, if I go 86,400
seconds into the future,


835
00:39:43,726 --> 00:39:45,226
I will be at this time tomorrow.


836
00:39:45,596 --> 00:39:48,726
However, keep in mind
that on the border


837
00:39:48,726 --> 00:39:50,416
between daylight savings time


838
00:39:50,416 --> 00:39:52,596
and non-daylight savings
time, this is not the case.


839
00:39:53,416 --> 00:39:55,936
Likewise, one month is not
always 30 days in the future.


840
00:39:56,216 --> 00:39:59,426
One year is not always
525,600 minutes,


841
00:39:59,426 --> 00:40:01,286
despite what the song may say.


842
00:40:01,496 --> 00:40:03,206
So, for more information
on this,


843
00:40:03,206 --> 00:40:04,566
you can see tomorrow's
presentation,


844
00:40:04,566 --> 00:40:05,836
date and time challenges.


845
00:40:06,676 --> 00:40:08,546
I assure you its quite
complicated, but they'll go


846
00:40:08,546 --> 00:40:09,916
into a lot of information
about this.


847
00:40:10,866 --> 00:40:13,726
So, with that, I'll pack to
Doug, and we'll do a demo


848
00:40:13,756 --> 00:40:14,776
of seeing this in real life.


849
00:40:15,266 --> 00:40:17,266
[ Applause ]


850
00:40:17,516 --> 00:40:18,006
>> Thanks, Nat.


851
00:40:18,946 --> 00:40:21,466
Alright. So, let me go back


852
00:40:21,536 --> 00:40:24,506
to my first crude
unlocalized application,


853
00:40:25,206 --> 00:40:31,236
and notice that it prints a
little header in front of each


854
00:40:31,236 --> 00:40:35,136
of my notes that shows an
index number; I've started


855
00:40:35,136 --> 00:40:37,936
with a thousand, just so I
can illustrate some things,


856
00:40:38,286 --> 00:40:39,436
and a date.


857
00:40:40,046 --> 00:40:43,476
Unfortunately, the format I've
chosen for this is pretty crude.


858
00:40:44,086 --> 00:40:45,866
Let's see what that
looks like in code.


859
00:40:47,476 --> 00:40:51,006
So, I'm just creating
using string with format


860
00:40:51,576 --> 00:40:55,426
from the NS number and NS date
attached to my note object.


861
00:40:55,876 --> 00:40:57,866
Now, that's the sort of thing
that I might want to use


862
00:40:57,946 --> 00:41:01,226
for an internal machinery
for full representation,


863
00:41:01,226 --> 00:41:03,686
but it's not the sort of thing
I want to present to my users.


864
00:41:03,686 --> 00:41:06,996
I really want to give them
locale appropriate presentations


865
00:41:06,996 --> 00:41:08,236
of the number and the date.


866
00:41:09,286 --> 00:41:13,866
So, let me go and see what
that looks like in my updated,


867
00:41:14,096 --> 00:41:15,656
properly localized application.


868
00:41:16,956 --> 00:41:19,006
So, what I've chosen
to do here is


869
00:41:19,006 --> 00:41:22,436
to create an NS date formatter
and an NS number formatter


870
00:41:22,436 --> 00:41:23,876
to format these two objects.


871
00:41:24,566 --> 00:41:28,056
Once I have those, it's
just a simple matter


872
00:41:28,056 --> 00:41:33,946
of replacing the index
number and date in my string


873
00:41:33,946 --> 00:41:37,256
with format with the
properly formatted results


874
00:41:37,256 --> 00:41:39,116
of calling string
from number and string


875
00:41:39,116 --> 00:41:41,336
from date using my
number formatter


876
00:41:41,336 --> 00:41:42,716
and date formatter objects.


877
00:41:43,266 --> 00:41:46,306
So, to do that, I have to
create the date formatter


878
00:41:46,306 --> 00:41:48,546
and the number formatter,
which is pretty simple.


879
00:41:49,356 --> 00:41:53,046
I've chosen to use a custom
format for my date formatter,


880
00:41:53,046 --> 00:41:55,206
so I create a date
format from template,


881
00:41:55,596 --> 00:41:59,236
with a simple template,
month, day, hour and minute,


882
00:41:59,916 --> 00:42:03,946
and then I set that date format
that I got on my date formatter,


883
00:42:03,946 --> 00:42:06,656
and it's ready to go
for my number formatter.


884
00:42:06,816 --> 00:42:11,316
I just create it, and I set
an appropriate style on it.


885
00:42:11,316 --> 00:42:15,096
There are also, if you want to
customize your number formatter,


886
00:42:15,096 --> 00:42:16,546
there are many, many
different options,


887
00:42:16,546 --> 00:42:18,656
so you can control
all the various pieces


888
00:42:18,656 --> 00:42:19,466
of number formatting.


889
00:42:19,986 --> 00:42:23,376
The only thing I'm doing here
is saying I don't want floats.


890
00:42:24,416 --> 00:42:26,866
So, I set that up at the
beginning of my application,


891
00:42:27,506 --> 00:42:30,766
and then I have my date
formatter and number formatter


892
00:42:30,766 --> 00:42:33,986
that I can use whenever I have
to format one of these headers.


893
00:42:34,816 --> 00:42:37,426
Now, one thing I did
want to keep in mind is


894
00:42:37,426 --> 00:42:40,206
that the user might change their
locale while my app is running,


895
00:42:40,946 --> 00:42:43,956
and if they do that, then I'm
stuck with this number formatter


896
00:42:43,956 --> 00:42:46,106
or date formatter that I
created for the old locale.


897
00:42:46,146 --> 00:42:48,996
So, I want to listen
to a notification,


898
00:42:49,946 --> 00:42:55,046
a little further down, I'm going
to add myself as an observer


899
00:42:55,046 --> 00:42:59,326
to the locale that changed
notification, and when I get


900
00:42:59,326 --> 00:43:01,786
that notification, I'm just
going to recreate my formatters


901
00:43:01,836 --> 00:43:03,256
with whatever the new locale is.


902
00:43:04,396 --> 00:43:06,736
So, now my app should be ready.


903
00:43:07,556 --> 00:43:09,506
Let's try running it in English,


904
00:43:13,846 --> 00:43:17,306
and I see that I got
properly formatted numbers


905
00:43:17,346 --> 00:43:18,796
and dates for English.


906
00:43:19,166 --> 00:43:24,346
I also note that my title of the
window is changing appropriately


907
00:43:25,996 --> 00:43:31,776
with my using string stick to
give appropriate representations


908
00:43:32,006 --> 00:43:34,206
for the proper pluralization,


909
00:43:35,256 --> 00:43:40,186
and so my numbers are formatted
using the appropriate thousand


910
00:43:40,186 --> 00:43:45,716
separator for English, and
I get a suitable date format


911
00:43:45,716 --> 00:43:50,106
and number format for English
showing first the month name


912
00:43:50,256 --> 00:43:58,436
and day, followed by the
time in 12 hour format.


913
00:43:58,576 --> 00:44:01,946
So, now if I go into
the system preferences,


914
00:44:01,946 --> 00:44:05,686
I change my primary language
to English, and my region


915
00:44:06,036 --> 00:44:13,846
from English to German, and my
region format also to Germany.


916
00:44:16,296 --> 00:44:19,116
Let's try running the
app again in German.


917
00:44:19,116 --> 00:44:24,876
Of course, the interface is
localized to German, let's see,


918
00:44:25,926 --> 00:44:34,096
and now we can see that I
get appropriately formatted


919
00:44:34,206 --> 00:44:37,276
for German with the
right thousand separator,


920
00:44:37,336 --> 00:44:40,916
rather than a comma, and
appropriately formatted dates


921
00:44:41,516 --> 00:44:45,486
with a day number, month name,


922
00:44:45,816 --> 00:44:49,826
and using 24 hour
format for the hours.


923
00:44:50,586 --> 00:44:56,226
And, we can see also that
are string stick is giving us


924
00:44:56,286 --> 00:45:07,406
appropriately pluralized titles
as the number of notes changes.


925
00:45:08,266 --> 00:45:11,996
So, that's using date
and number formatters


926
00:45:12,736 --> 00:45:16,496
to get properly formatted
user representations


927
00:45:16,846 --> 00:45:18,496
of dates and numbers.


928
00:45:18,986 --> 00:45:20,296
Now, let me go back
to the slides,


929
00:45:21,746 --> 00:45:23,756
and let me talk about text.


930
00:45:24,536 --> 00:45:26,986
Now, there are many
applications that deal with text


931
00:45:27,206 --> 00:45:28,476
in one form or another.


932
00:45:28,866 --> 00:45:32,086
Maybe your app is representing
text to the user that it got


933
00:45:32,086 --> 00:45:34,686
from some external source, or
maybe you're dealing with text


934
00:45:34,746 --> 00:45:37,966
that the user entered
themselves, but in either case,


935
00:45:38,116 --> 00:45:40,846
you need to deal with all
the kinds of writing systems


936
00:45:40,846 --> 00:45:42,656
that the users are
going to want to see.


937
00:45:43,166 --> 00:45:45,276
I have some examples here.


938
00:45:45,276 --> 00:45:49,576
These are all writing
systems for which we have font


939
00:45:49,576 --> 00:45:52,046
and input method support
on both iOS and OS X.


940
00:45:52,546 --> 00:45:53,926
You want to be able
to handle them all.


941
00:45:54,906 --> 00:45:56,956
Well, here's some simple
rules for doing that.


942
00:45:56,956 --> 00:46:01,456
The first one is, use
Unicode and in particular,


943
00:46:01,626 --> 00:46:04,676
the NS string class, which is
our standard representation


944
00:46:04,736 --> 00:46:07,576
of the Unicode string
for representing text.


945
00:46:08,556 --> 00:46:13,186
A second one is that when you
want to analyze this text,


946
00:46:13,346 --> 00:46:15,516
going into or do something
to it, iterate through it,


947
00:46:15,516 --> 00:46:17,476
search for a substring,
sort it, etc.,


948
00:46:17,846 --> 00:46:20,026
use some of the standard
NS string API's,


949
00:46:20,836 --> 00:46:24,216
which are all Unicode savvy,
and will deal with text in many


950
00:46:24,216 --> 00:46:25,406
in many different
writing systems,


951
00:46:25,866 --> 00:46:28,816
and as much as possible, use
the standard system views


952
00:46:28,816 --> 00:46:32,726
and controls for displaying that
text or for accepting input.


953
00:46:32,726 --> 00:46:35,146
Let me go into that
in some more detail.


954
00:46:35,736 --> 00:46:39,366
So, Unicode is a
standard that allows us


955
00:46:39,366 --> 00:46:43,476
to encode essentially all of the
world's living writing systems,


956
00:46:43,596 --> 00:46:45,696
most of its date blocks
in a single strength,


957
00:46:46,926 --> 00:46:52,136
we use NS string as our standard
Unicode containing object,


958
00:46:53,166 --> 00:46:57,506
and it exposes the
contents using the UTF 16


959
00:46:57,506 --> 00:46:58,536
and coding format.


960
00:46:59,736 --> 00:47:02,796
The thing I want you to
remember about using Unicode


961
00:47:02,796 --> 00:47:08,396
to represent text, is that you
cannot treat what the user sees


962
00:47:08,396 --> 00:47:10,466
as a character as
being something


963
00:47:10,466 --> 00:47:12,646
that is fixed length in memory.


964
00:47:13,366 --> 00:47:16,206
That's true no matter what
encoding form you're using


965
00:47:16,206 --> 00:47:17,716
or what normalization
form you're using.


966
00:47:17,716 --> 00:47:19,936
It's just a fundamental
property of Unicode.


967
00:47:20,446 --> 00:47:22,776
So, what we recommend
that you do is not deal


968
00:47:22,776 --> 00:47:24,826
with individual characters
in a string.


969
00:47:25,216 --> 00:47:28,306
Instead, work with ranges
of characters in a string


970
00:47:28,306 --> 00:47:29,556
or substrings of a string.


971
00:47:31,376 --> 00:47:32,456
Let me give you some examples.


972
00:47:32,456 --> 00:47:36,186
So, here I have a Chinese
character, a Korean syllable,


973
00:47:36,186 --> 00:47:37,376
and a couple of emogies.


974
00:47:37,946 --> 00:47:42,896
And their representations
numerically in UTF 16 or UTF 32,


975
00:47:42,896 --> 00:47:46,446
you can see that they all have
different lengths no matter what


976
00:47:46,446 --> 00:47:47,696
encoding formats you've used.


977
00:47:48,896 --> 00:47:51,726
So, to avoid dealing
with all this complexity,


978
00:47:51,726 --> 00:47:52,976
you can use standard API's,


979
00:47:53,956 --> 00:47:56,866
like range of composed
character sequence at index,


980
00:47:57,246 --> 00:47:59,836
so this will give you
the range within a string


981
00:48:00,336 --> 00:48:03,856
of what is effectively
user visible character,


982
00:48:03,856 --> 00:48:06,166
what we call a composed
character sequence


983
00:48:06,236 --> 00:48:08,726
or sometimes a character
cluster for short.


984
00:48:09,706 --> 00:48:13,156
So we use this API, it will give
you the range that corresponds


985
00:48:13,156 --> 00:48:15,676
to what the user is seeing
as a character and respect


986
00:48:15,736 --> 00:48:18,156
that range, so you don't
split these things up,


987
00:48:18,156 --> 00:48:20,466
and end up with broken text.


988
00:48:21,876 --> 00:48:25,366
If you need to go through
a string; maybe you need


989
00:48:25,366 --> 00:48:27,746
to through it by
character cluster or by word


990
00:48:27,746 --> 00:48:30,566
or by sentence or by paragraph,
we have a standard API for that.


991
00:48:30,986 --> 00:48:33,876
Innumerate substrings and
range options using block.


992
00:48:34,476 --> 00:48:37,546
Depending on what options you
pass in, you can through it


993
00:48:37,906 --> 00:48:40,446
by character cluster,
by word sentence, etc.,


994
00:48:41,306 --> 00:48:44,206
and then you give it a block,
and your block gets called


995
00:48:44,206 --> 00:48:46,256
with the range of each
individual component.


996
00:48:46,256 --> 00:48:47,716
For example, if you're
going through it


997
00:48:47,716 --> 00:48:51,496
by user visible characters,
character clusters,


998
00:48:52,496 --> 00:48:54,016
you use the NS string
enumeration


999
00:48:54,016 --> 00:48:56,046
by composed character
sequences options,


1000
00:48:56,046 --> 00:48:59,266
and then your block will
be called successively


1001
00:48:59,516 --> 00:49:03,256
with the range and the string
corresponding to this character,


1002
00:49:03,256 --> 00:49:08,086
whatever it may be,
whether it's short or long.


1003
00:49:08,276 --> 00:49:10,016
Likewise, if you're going
through it by words,


1004
00:49:10,016 --> 00:49:11,776
use NS string enumeration
by words,


1005
00:49:11,826 --> 00:49:15,566
and your block will be called
successfully with the range


1006
00:49:15,626 --> 00:49:17,706
of each word and the text notice


1007
00:49:17,806 --> 00:49:20,156
that words are not necessarily
going to be separated


1008
00:49:20,276 --> 00:49:22,316
by punctuation or white space.


1009
00:49:22,896 --> 00:49:26,856
If you need to search for a
substring within a string,


1010
00:49:27,046 --> 00:49:28,666
there's a standard
API for that too.


1011
00:49:29,176 --> 00:49:31,526
Range of string options,
range locale.


1012
00:49:31,986 --> 00:49:35,396
There are a number of different
options you can pass in for case


1013
00:49:35,396 --> 00:49:36,976
and sensitive searching,
die printing


1014
00:49:36,976 --> 00:49:38,886
and sensitive searching,
if you're searching


1015
00:49:38,886 --> 00:49:40,096
for something user provider,


1016
00:49:40,576 --> 00:49:42,726
there's a good change you may
want to use both of those.


1017
00:49:43,476 --> 00:49:45,346
You can search forwards
or backwards.


1018
00:49:46,006 --> 00:49:48,336
There's the also the
anchored search option.


1019
00:49:48,336 --> 00:49:51,826
If you pass that in, you're not
looking for the next instance


1020
00:49:51,926 --> 00:49:55,406
of the substring, you're looking
to see whether it's present


1021
00:49:55,406 --> 00:49:58,016
or not at the given
location you start at,


1022
00:49:58,996 --> 00:49:59,976
which is often useful too.


1023
00:50:01,396 --> 00:50:04,856
And, sorting.


1024
00:50:05,546 --> 00:50:09,526
If you need to sort strings in
such a way as to present them


1025
00:50:09,526 --> 00:50:13,516
to the user in sorted order,
you have to keep in mind


1026
00:50:13,726 --> 00:50:17,426
that each different
language; not just language,


1027
00:50:17,506 --> 00:50:21,676
but each country or region,
may have a different standard,


1028
00:50:21,836 --> 00:50:25,326
sort order, in which they
like to see strings presented.


1029
00:50:26,046 --> 00:50:29,676
Some die critics are sensitive,
important, sometimes not,


1030
00:50:30,316 --> 00:50:33,096
even what constitutes a
letter for sorting may change,


1031
00:50:33,446 --> 00:50:35,336
and if you don't put
things in the right order,


1032
00:50:35,336 --> 00:50:36,216
people are not going to be able


1033
00:50:36,216 --> 00:50:37,316
to find what they're
looking for.


1034
00:50:38,136 --> 00:50:42,246
Now, there are a couple of API's
that you might look at for this.


1035
00:50:42,246 --> 00:50:43,916
NS string has a standard
compare method


1036
00:50:43,916 --> 00:50:46,656
and a localized standard
compare, so the difference is


1037
00:50:46,956 --> 00:50:50,446
that the compare method
is that locale and variant


1038
00:50:50,696 --> 00:50:54,566
for internal machinery
purposes for sorting.


1039
00:50:55,946 --> 00:50:58,786
That's not what you want to use
for user presentation of text.


1040
00:50:59,046 --> 00:51:01,806
For user presentation of text,
use localized standard compare.


1041
00:51:02,256 --> 00:51:03,616
That will be locale sensitive.


1042
00:51:03,616 --> 00:51:06,636
It will give you the
order that users expect.


1043
00:51:07,436 --> 00:51:10,536
It will match, for
example, the order of files


1044
00:51:10,536 --> 00:51:12,276
that are sorted in the finder.


1045
00:51:13,706 --> 00:51:14,936
So, let me give you
a few examples.


1046
00:51:15,506 --> 00:51:16,676
Here is a set of strings.


1047
00:51:16,776 --> 00:51:18,596
Here's the order that
you would get them


1048
00:51:18,596 --> 00:51:19,646
if you sorted them according


1049
00:51:19,646 --> 00:51:23,056
to the locale independent
internal compare method.


1050
00:51:24,166 --> 00:51:29,616
If we change this to localized
standard compare for let us say,


1051
00:51:29,616 --> 00:51:30,606
the US English locale,


1052
00:51:31,066 --> 00:51:33,576
you notice that the
order changes a fair bit.


1053
00:51:34,626 --> 00:51:37,156
If we were using
Danish sort order,


1054
00:51:37,566 --> 00:51:38,926
it changes even still further,


1055
00:51:39,146 --> 00:51:41,106
or we're using a
Chinese sort order,


1056
00:51:41,406 --> 00:51:42,696
it changes quite a bit again.


1057
00:51:43,406 --> 00:51:44,356
So, use the standard API,


1058
00:51:44,356 --> 00:51:47,046
and you'll get the sort
order users expect;


1059
00:51:47,126 --> 00:51:48,466
whatever it may happen to be.


1060
00:51:50,486 --> 00:51:56,256
For displaying text, keep
in mind that the characters


1061
00:51:56,536 --> 00:51:59,756
as they appear in the string
are not necessarily directly


1062
00:51:59,756 --> 00:52:03,586
correlated with what
gets shown on the screen.


1063
00:52:04,006 --> 00:52:06,746
So, what gets shown on the
screen is a sequence of glifs.


1064
00:52:06,746 --> 00:52:10,916
A glif is the smallest unit from
a font that can be displayed.


1065
00:52:10,916 --> 00:52:13,376
It may represent one character
or more than one character


1066
00:52:13,826 --> 00:52:15,036
or a part of a character.


1067
00:52:15,946 --> 00:52:18,206
The mapping between the
characters in memory


1068
00:52:18,206 --> 00:52:21,106
and the glifs that are shown
is not necessarily simple


1069
00:52:21,106 --> 00:52:25,806
and general, it can mean many
to many, and even the ordering


1070
00:52:26,036 --> 00:52:28,256
of glifs within a line
can become complex.


1071
00:52:29,096 --> 00:52:33,336
Now, our standard views and
controls use the text system


1072
00:52:33,946 --> 00:52:37,596
to get proper Unicode
layout and display,


1073
00:52:37,596 --> 00:52:38,726
so use them as much as possible.


1074
00:52:38,726 --> 00:52:40,486
If you need to go beyond that


1075
00:52:40,486 --> 00:52:44,446
and do custom display,
use text API's.


1076
00:52:45,006 --> 00:52:48,996
Now it used to be, this was more
difficult on iOS than on OS X,


1077
00:52:49,596 --> 00:52:51,346
because on iOS, you had
to go down all the way


1078
00:52:51,346 --> 00:52:53,126
to the core text level to do it.


1079
00:52:53,256 --> 00:52:55,366
Not anymore.


1080
00:52:55,936 --> 00:52:58,966
With the iOS 7, we
have text kit API's,


1081
00:52:58,966 --> 00:53:01,806
and there are some
excellent sessions on this.


1082
00:53:01,846 --> 00:53:03,676
There was an introductory
session yesterday.


1083
00:53:04,116 --> 00:53:06,636
There is a more advanced
session this afternoon


1084
00:53:06,636 --> 00:53:09,686
that will tell you exactly how
they keep track of the mapping


1085
00:53:09,686 --> 00:53:15,116
between the characters and
the glifs that display them.


1086
00:53:15,416 --> 00:53:19,506
Here's an example; I got
this from a developer.


1087
00:53:19,676 --> 00:53:22,796
This is some English text with
some Hebrew in the middle.


1088
00:53:22,796 --> 00:53:24,696
So, English goes left to right.


1089
00:53:25,166 --> 00:53:26,336
Hebrew goes right to left.


1090
00:53:26,336 --> 00:53:29,016
You put them together, you
have bidirectional text.


1091
00:53:29,686 --> 00:53:32,126
This is the proper order
for displaying the text,


1092
00:53:33,136 --> 00:53:35,286
but the way it shows up in
memory is very different.


1093
00:53:35,406 --> 00:53:38,616
It starts off with the English
on the left, flowing from left


1094
00:53:38,616 --> 00:53:41,386
to right, then the Hebrew
in logical order flows


1095
00:53:41,976 --> 00:53:44,446
for the first character,


1096
00:53:44,446 --> 00:53:47,186
which shows up as the
right-most one and so on.


1097
00:53:48,046 --> 00:53:49,396
Then this exclamation point;


1098
00:53:50,206 --> 00:53:53,236
it's a bit ambiguous whether
the explanation point goes


1099
00:53:53,236 --> 00:53:54,976
with the Hebrew or the English.


1100
00:53:54,976 --> 00:53:56,066
Here it goes with Hebrew.


1101
00:53:56,406 --> 00:53:58,776
In order to specify that,


1102
00:53:58,856 --> 00:54:01,466
there are some Unicode control
characters that are included


1103
00:54:01,466 --> 00:54:04,756
in this text and these
are things that may show


1104
00:54:04,756 --> 00:54:05,646
up in text that you get.


1105
00:54:05,646 --> 00:54:08,496
Text that you get from
an external source


1106
00:54:08,496 --> 00:54:12,036
or from your localizers, or
sometimes text from formatters


1107
00:54:12,176 --> 00:54:14,816
in bidirectional text languages.


1108
00:54:14,906 --> 00:54:18,446
It may include these to
specify certain cases


1109
00:54:18,446 --> 00:54:19,766
that are otherwise ambiguous.


1110
00:54:20,196 --> 00:54:25,096
And again, the text API's and
the standard system controls


1111
00:54:25,096 --> 00:54:26,886
and fields will handle
this properly,


1112
00:54:27,186 --> 00:54:30,936
and give you the appropriate
Unicode sensitive bidirectional


1113
00:54:31,166 --> 00:54:32,766
layout of this text.


1114
00:54:33,986 --> 00:54:36,166
Text input; it's
important to keep in mind


1115
00:54:36,306 --> 00:54:41,036
that it's not always a
matter of pressing a key


1116
00:54:41,456 --> 00:54:43,996
and getting a letter
in the text.


1117
00:54:44,566 --> 00:54:48,216
For languages that use complex
input methods like Chinese


1118
00:54:48,216 --> 00:54:50,426
and Japanese, usually
what will happen is


1119
00:54:50,426 --> 00:54:52,986
that the user types
a representation;


1120
00:54:52,986 --> 00:54:55,566
a phonetic representation
perhaps of the text they want,


1121
00:54:55,966 --> 00:54:58,336
that gets preliminarily
inserted into the text.


1122
00:54:59,176 --> 00:55:02,086
Then the system shows them
some options of choices,


1123
00:55:02,086 --> 00:55:03,766
and they pick the one
they actually want,


1124
00:55:03,766 --> 00:55:04,966
and after that gets confirmed,


1125
00:55:04,966 --> 00:55:06,646
and that's the final
text that goes in.


1126
00:55:07,056 --> 00:55:10,876
So, in this case, the text on
the left has been confirmed.


1127
00:55:11,046 --> 00:55:13,286
The underlying text;
it's called marked text,


1128
00:55:13,286 --> 00:55:17,386
is preliminary only, and then
they'll pick one, and again,


1129
00:55:17,386 --> 00:55:18,626
this is what it looks like OS X.


1130
00:55:18,626 --> 00:55:21,886
This is what is looks like
on iOS; the same text.


1131
00:55:22,356 --> 00:55:24,216
It's not just for
Chinese and Japanese too.


1132
00:55:24,506 --> 00:55:29,116
On OS X, if you press and hold
to get accenting characters,


1133
00:55:29,116 --> 00:55:31,706
it's the same, your preliminary
character gets insert,


1134
00:55:31,706 --> 00:55:33,276
then the user picks
the final one.


1135
00:55:34,136 --> 00:55:37,276
So, if you're dealing with text
as its input, keep in mind,


1136
00:55:37,696 --> 00:55:40,226
it's not just a simple matter of
being inserted letter by letter,


1137
00:55:40,276 --> 00:55:44,006
there may be this preliminary
marked test that shows


1138
00:55:44,006 --> 00:55:46,146
up in your text view first.


1139
00:55:47,176 --> 00:55:51,476
If you're dealing with text as
it changes, deal with it change


1140
00:55:51,476 --> 00:55:54,966
by change, not keystroke by
keystroke, and you probably want


1141
00:55:54,966 --> 00:55:56,836
to notice that text
views will tell you


1142
00:55:56,836 --> 00:55:58,406
if there's marked
text from where it is.


1143
00:55:58,906 --> 00:56:00,376
You probably don't want
to operate on that,


1144
00:56:00,376 --> 00:56:03,906
because it's only preliminary,
it's not the final text.


1145
00:56:04,336 --> 00:56:06,886
One last thing to mention
is that names, addresses,


1146
00:56:06,886 --> 00:56:09,646
and phone numbers vary quite
a bit around the world.


1147
00:56:10,266 --> 00:56:12,526
Names use many different
writing systems;


1148
00:56:12,586 --> 00:56:17,266
sometimes a user will have
their family name first,


1149
00:56:17,266 --> 00:56:18,216
and first name last.


1150
00:56:18,396 --> 00:56:19,946
Sometimes they may
not have a family name


1151
00:56:19,946 --> 00:56:21,036
or not have a personal name.


1152
00:56:22,516 --> 00:56:25,586
Phone number formats
differ widely.


1153
00:56:25,926 --> 00:56:29,196
The number of digits used
and the punctuation that goes


1154
00:56:29,226 --> 00:56:32,596
between them, and there are
many different address formats


1155
00:56:32,596 --> 00:56:33,116
around the world.


1156
00:56:33,516 --> 00:56:35,126
So, try as much as possible


1157
00:56:35,126 --> 00:56:37,976
to avoid making assumptions
about these formats.


1158
00:56:38,176 --> 00:56:42,026
Do it only as your app needs
to for its own purposes.


1159
00:56:42,456 --> 00:56:44,956
One thing that can help
sometimes is data detectors,


1160
00:56:45,196 --> 00:56:49,536
which can detect phone
numbers and addresses


1161
00:56:49,536 --> 00:56:52,986
in many different international
formats, so you can add this


1162
00:56:53,186 --> 00:56:56,276
to some views, and it
will detect these things,


1163
00:56:56,276 --> 00:56:58,286
and even make them into links.


1164
00:56:58,756 --> 00:57:01,206
There is also NS data detector
at the foundation level


1165
00:57:01,206 --> 00:57:02,286
for doing this protomatically
[assumed spelling].


1166
00:57:04,866 --> 00:57:07,836
So, we have a lot of
documentation for all this stuff


1167
00:57:07,836 --> 00:57:11,566
on line, both conceptual
documentation, tutorials,


1168
00:57:13,386 --> 00:57:15,516
and there are a number
of relevant sessions


1169
00:57:15,766 --> 00:57:18,966
that you might be interested
in, including sessions


1170
00:57:18,966 --> 00:57:22,186
about auto layout, many
sessions about text kit


1171
00:57:22,186 --> 00:57:23,136
and text handling,


1172
00:57:23,576 --> 00:57:27,126
and tomorrow's very interesting
session on date and time.


1173
00:57:27,976 --> 00:57:32,146
So, the most important things
to take away; for localization,


1174
00:57:32,686 --> 00:57:34,806
you job is to make your
interfaces localizable,


1175
00:57:35,676 --> 00:57:38,476
preferably by using base
localization with auto layout,


1176
00:57:39,176 --> 00:57:40,906
and for your strings and code,


1177
00:57:41,686 --> 00:57:43,836
use NSLocalizedString
and gen strings.


1178
00:57:44,806 --> 00:57:47,676
For locale data, be sure to
use formatters; date formatters


1179
00:57:47,676 --> 00:57:48,596
and number formatters


1180
00:57:48,596 --> 00:57:50,556
when you're presenting
these things to the user.


1181
00:57:51,346 --> 00:57:57,266
With the constants or templates,
if necessary, customize them,


1182
00:57:57,326 --> 00:57:59,536
and then as calendar for
calendrical calculations.


1183
00:58:00,776 --> 00:58:04,446
For text, use Unicode and NS
string, and the NS string API's


1184
00:58:04,886 --> 00:58:07,026
for iteration, searching,
sorting, and so forth,


1185
00:58:07,616 --> 00:58:10,256
and as much as possible, use
the standard views and controls


1186
00:58:10,256 --> 00:58:11,386
for input and display.


1187
00:58:11,986 --> 00:58:15,116
If you have to go beyond those,
use the text system API's


1188
00:58:15,116 --> 00:58:19,196
to do so, and get proper Unicode
aware layout and display.


1189
00:58:21,616 --> 00:58:23,906
Thanks everyone, have
a great conference.


1190
00:58:24,516 --> 00:58:29,270
[ Applause ]

