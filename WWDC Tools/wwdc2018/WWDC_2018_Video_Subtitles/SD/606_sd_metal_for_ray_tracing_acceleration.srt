1
00:00:07,516 --> 00:00:15,500
[ Music ]


2
00:00:17,516 --> 00:00:22,500
[ Applause ]


3
00:00:23,526 --> 00:00:24,226
>> Hi, everybody.


4
00:00:25,096 --> 00:00:26,716
My name is Sean James and I'm a


5
00:00:26,716 --> 00:00:27,806
GPU Software Engineer.


6
00:00:28,696 --> 00:00:30,096
Today, I'm going to talk about


7
00:00:30,096 --> 00:00:30,766
Ray Tracing.


8
00:00:31,076 --> 00:00:32,426
So, you may have seen our Ray


9
00:00:32,426 --> 00:00:33,966
Tracing demo in the State of the


10
00:00:33,966 --> 00:00:35,636
Union and want to learn more.


11
00:00:36,666 --> 00:00:37,706
Or you may be interested in


12
00:00:37,706 --> 00:00:38,956
using Ray Tracing in your own


13
00:00:38,956 --> 00:00:39,376
apps.


14
00:00:40,006 --> 00:00:41,746
Today, I'll talk about how you


15
00:00:41,746 --> 00:00:43,026
can use Ray Tracing in your


16
00:00:43,026 --> 00:00:44,816
applications and how you can


17
00:00:44,816 --> 00:00:47,036
accelerate it on the GPU using


18
00:00:47,036 --> 00:00:47,386
METAL.


19
00:00:48,576 --> 00:00:50,116
Specifically, using METAL


20
00:00:50,116 --> 00:00:51,036
Performance Shaders.


21
00:00:51,906 --> 00:00:53,956
METAL Performance Shaders is a


22
00:00:53,956 --> 00:00:55,546
collection of GPU Compute


23
00:00:55,546 --> 00:00:57,476
Primitives optimized for all of


24
00:00:57,476 --> 00:00:59,546
our iOS and macOS devices.


25
00:01:00,996 --> 00:01:02,536
MPS includes support for image


26
00:01:02,536 --> 00:01:04,855
processing, linear algebra, and


27
00:01:04,855 --> 00:01:05,586
machine learning.


28
00:01:06,796 --> 00:01:08,036
We've talk extensively about


29
00:01:08,036 --> 00:01:09,676
these topics in previous


30
00:01:09,676 --> 00:01:10,156
sessions.


31
00:01:11,316 --> 00:01:12,666
This year, we've also added


32
00:01:12,666 --> 00:01:14,136
support for training.


33
00:01:14,626 --> 00:01:16,066
And there's an entire session


34
00:01:16,066 --> 00:01:17,306
about this topic tomorrow.


35
00:01:17,796 --> 00:01:19,966
For today, I'll talk about the


36
00:01:19,966 --> 00:01:21,576
new support we've added this


37
00:01:21,576 --> 00:01:22,786
year for Ray Tracing.


38
00:01:23,796 --> 00:01:25,856
So first, what is Ray Tracing?


39
00:01:27,856 --> 00:01:29,286
Ray Tracing applications are


40
00:01:29,286 --> 00:01:30,966
based on following the paths


41
00:01:30,966 --> 00:01:32,846
that Rays take as they interact


42
00:01:32,846 --> 00:01:33,456
with the scene.


43
00:01:34,596 --> 00:01:36,776
Rays can model light, sound, or


44
00:01:36,776 --> 00:01:37,746
other forms of energy.


45
00:01:38,576 --> 00:01:40,166
So, Ray Tracing has applications


46
00:01:40,546 --> 00:01:43,036
in rendering, audio, and physics


47
00:01:43,036 --> 00:01:43,546
simulation.


48
00:01:44,586 --> 00:01:46,196
But rays can, also, represent


49
00:01:46,196 --> 00:01:48,136
more abstract concepts, like


50
00:01:48,136 --> 00:01:49,356
whether or not one point is


51
00:01:49,356 --> 00:01:50,266
visible from another.


52
00:01:51,326 --> 00:01:52,366
So, Ray Tracing also has


53
00:01:52,366 --> 00:01:53,506
applications in collision


54
00:01:53,506 --> 00:01:54,786
detection, artificial


55
00:01:54,786 --> 00:01:56,696
intelligence, and pathfinding.


56
00:01:57,606 --> 00:01:59,396
For today, though, I'll focus on


57
00:01:59,396 --> 00:02:01,006
rendering as an example of how


58
00:02:01,006 --> 00:02:02,266
you can use Ray Tracing in your


59
00:02:02,266 --> 00:02:02,956
applications.


60
00:02:04,476 --> 00:02:06,206
So, you may be familiar with the


61
00:02:06,206 --> 00:02:07,496
rasterization pipeline.


62
00:02:08,216 --> 00:02:09,895
The rasterizer works by


63
00:02:09,895 --> 00:02:11,216
projecting one triangle at a


64
00:02:11,216 --> 00:02:13,686
time onto the screen and shading


65
00:02:13,686 --> 00:02:14,796
the corresponding pixels.


66
00:02:15,726 --> 00:02:16,876
This can be implemented very


67
00:02:16,876 --> 00:02:19,066
quickly in GPU hardware, which


68
00:02:19,066 --> 00:02:20,296
makes this the method of choice


69
00:02:20,296 --> 00:02:21,756
for games and other real time


70
00:02:21,756 --> 00:02:22,446
applications.


71
00:02:23,476 --> 00:02:25,626
But the rasterization model


72
00:02:25,996 --> 00:02:27,356
makes it difficult to simulate


73
00:02:27,356 --> 00:02:28,646
certain physical behaviors of


74
00:02:28,646 --> 00:02:28,946
light.


75
00:02:30,746 --> 00:02:32,176
One example is reflections.


76
00:02:33,076 --> 00:02:34,806
With the rasterizer, reflections


77
00:02:34,806 --> 00:02:35,886
are, typically, implemented


78
00:02:35,946 --> 00:02:37,566
using approximations, such as


79
00:02:37,566 --> 00:02:38,956
cube maps and screen space


80
00:02:38,956 --> 00:02:39,536
reflections.


81
00:02:40,136 --> 00:02:41,956
But with the Ray Tracer we can


82
00:02:41,956 --> 00:02:43,636
compute accurate reflections,


83
00:02:43,636 --> 00:02:44,176
directly.


84
00:02:45,926 --> 00:02:47,316
Another example is shadows.


85
00:02:48,186 --> 00:02:49,816
With the rasterizer, shadows are


86
00:02:49,816 --> 00:02:51,046
typically implemented using


87
00:02:51,046 --> 00:02:51,826
shadow maps.


88
00:02:52,516 --> 00:02:53,456
But these can be tricky to


89
00:02:53,456 --> 00:02:55,066
implement without suffering from


90
00:02:55,066 --> 00:02:56,786
aliasing and resolution issues.


91
00:02:57,756 --> 00:02:59,746
Furthermore, soft shadow mapping


92
00:02:59,746 --> 00:03:00,956
techniques tend to produce


93
00:03:00,956 --> 00:03:02,346
uniformly soft shadows.


94
00:03:03,286 --> 00:03:05,376
With the Ray Tracer we can


95
00:03:05,376 --> 00:03:06,646
directly compute whether or not


96
00:03:06,646 --> 00:03:08,306
a point if in shadow.


97
00:03:08,856 --> 00:03:09,766
So, we can produce clean


98
00:03:09,766 --> 00:03:11,756
shadows, including realistic


99
00:03:11,756 --> 00:03:13,246
transitions from hard to soft


100
00:03:13,246 --> 00:03:14,996
shadows as the distance between


101
00:03:14,996 --> 00:03:15,946
objects increases.


102
00:03:16,506 --> 00:03:19,546
One final example is global


103
00:03:19,546 --> 00:03:20,736
elimination.


104
00:03:22,216 --> 00:03:23,526
This simulates light bouncing of


105
00:03:23,526 --> 00:03:24,806
off surfaces in the scene.


106
00:03:25,606 --> 00:03:27,526
Global elimination can be very


107
00:03:27,526 --> 00:03:28,586
difficult to model with the


108
00:03:28,586 --> 00:03:29,256
rasterizer.


109
00:03:29,536 --> 00:03:30,946
But it's actually modeled quite


110
00:03:30,946 --> 00:03:32,306
naturally with the Ray Tracer.


111
00:03:33,026 --> 00:03:34,716
In fact, many games and real


112
00:03:34,716 --> 00:03:36,146
time applications that include a


113
00:03:36,146 --> 00:03:37,566
global elimination component,


114
00:03:38,026 --> 00:03:39,596
actually, precompute it using a


115
00:03:39,596 --> 00:03:41,446
Ray Tracer and store the result


116
00:03:41,446 --> 00:03:42,306
into textures.


117
00:03:42,606 --> 00:03:43,816
Which are then mapped back onto


118
00:03:43,856 --> 00:03:45,076
the geometry at run time.


119
00:03:45,656 --> 00:03:48,746
Of course, there are many other


120
00:03:48,746 --> 00:03:49,796
effects that we can simulate


121
00:03:49,796 --> 00:03:51,216
with the Ray Tracer, such as


122
00:03:51,216 --> 00:03:53,176
ambient occlusion, refraction,


123
00:03:53,316 --> 00:03:54,576
and area light sources.


124
00:03:54,956 --> 00:03:56,576
As well as camera effects, such


125
00:03:56,576 --> 00:03:57,836
as depth of field and motion


126
00:03:57,836 --> 00:03:58,076
blur.


127
00:03:59,606 --> 00:04:00,616
This makes Ray Tracing the


128
00:04:00,616 --> 00:04:01,586
method of choice for


129
00:04:01,586 --> 00:04:03,596
photorealistic offline rendering


130
00:04:03,596 --> 00:04:04,346
applications.


131
00:04:05,886 --> 00:04:07,366
The tradeoff is that Ray Tracing


132
00:04:07,366 --> 00:04:08,376
is significantly more


133
00:04:08,376 --> 00:04:09,766
computationally expensive than


134
00:04:09,766 --> 00:04:11,476
rasterization because we're


135
00:04:11,476 --> 00:04:12,506
doing so much more work to


136
00:04:12,506 --> 00:04:13,526
simulate these effects.


137
00:04:14,856 --> 00:04:16,226
So, let's first take a closer


138
00:04:16,226 --> 00:04:17,606
look at how rendering works with


139
00:04:17,606 --> 00:04:18,956
the Ray Tracer, and then we'll


140
00:04:18,956 --> 00:04:20,245
see how we can accelerate is


141
00:04:20,245 --> 00:04:20,786
with METAL.


142
00:04:21,386 --> 00:04:24,606
So, we use an algorithm called


143
00:04:24,636 --> 00:04:25,436
Path Tracing.


144
00:04:26,516 --> 00:04:27,856
In the real world, photons are


145
00:04:27,856 --> 00:04:29,696
emitted from light sources and


146
00:04:29,696 --> 00:04:30,886
they bounce around until they


147
00:04:30,886 --> 00:04:32,586
enter the camera or your eye.


148
00:04:33,316 --> 00:04:35,176
But most of those photons


149
00:04:35,416 --> 00:04:36,486
actually never make it to the


150
00:04:36,486 --> 00:04:36,866
camera.


151
00:04:37,406 --> 00:04:38,326
So, this would be very


152
00:04:38,326 --> 00:04:39,466
inefficient to simulate.


153
00:04:39,956 --> 00:04:42,516
Fortunately, due to properties


154
00:04:42,516 --> 00:04:44,116
of light we can, actually, work


155
00:04:44,176 --> 00:04:45,476
backwards, starting from the


156
00:04:45,476 --> 00:04:45,866
camera.


157
00:04:47,206 --> 00:04:49,536
We start by casting primary rays


158
00:04:49,776 --> 00:04:51,816
from the camera into the scene.


159
00:04:53,446 --> 00:04:54,886
We then compute shading at the


160
00:04:54,886 --> 00:04:55,776
intersection points.


161
00:04:56,836 --> 00:04:58,256
Shading consists of figuring out


162
00:04:58,296 --> 00:04:59,896
how much light is arriving at


163
00:04:59,896 --> 00:05:01,556
the shading point and what


164
00:05:01,556 --> 00:05:02,696
fraction of that light is


165
00:05:02,696 --> 00:05:04,146
reflected back towards the


166
00:05:04,146 --> 00:05:04,496
camera.


167
00:05:05,516 --> 00:05:06,826
There are, actually, two sources


168
00:05:06,826 --> 00:05:08,086
of light, which we'll handle


169
00:05:08,086 --> 00:05:08,656
separately.


170
00:05:10,176 --> 00:05:12,186
The first source is direct


171
00:05:12,186 --> 00:05:12,466
light.


172
00:05:13,246 --> 00:05:14,406
This is light that arrives


173
00:05:14,646 --> 00:05:15,946
directly at the shading point


174
00:05:15,946 --> 00:05:16,936
from the light source.


175
00:05:18,236 --> 00:05:19,946
We can easily compute how much


176
00:05:19,946 --> 00:05:21,716
light is arriving directly and


177
00:05:21,716 --> 00:05:22,946
what fraction of that light is


178
00:05:22,946 --> 00:05:23,966
reflected back towards the


179
00:05:23,966 --> 00:05:24,306
camera.


180
00:05:25,186 --> 00:05:26,836
All we need to do is check that


181
00:05:26,836 --> 00:05:27,866
the shading point is not,


182
00:05:27,866 --> 00:05:29,656
actually, in shadow, before


183
00:05:29,656 --> 00:05:30,486
adding the lighting to the


184
00:05:30,486 --> 00:05:30,916
image.


185
00:05:32,106 --> 00:05:34,146
To do this, we can cast


186
00:05:34,146 --> 00:05:35,836
additional shadow rays from the


187
00:05:35,836 --> 00:05:37,046
shading point towards the light


188
00:05:37,046 --> 00:05:37,536
source.


189
00:05:38,386 --> 00:05:40,266
If the shadow ray doesn't make


190
00:05:40,266 --> 00:05:41,126
it all the way to the light


191
00:05:41,126 --> 00:05:42,436
source, then the original


192
00:05:42,436 --> 00:05:43,776
shading point was in shadow.


193
00:05:44,316 --> 00:05:45,196
So, we shouldn't add the


194
00:05:45,196 --> 00:05:48,646
lighting to the image.


195
00:05:48,936 --> 00:05:50,386
The other source of light is


196
00:05:50,386 --> 00:05:51,126
indirect light.


197
00:05:52,116 --> 00:05:53,516
This is light that bounces off


198
00:05:53,516 --> 00:05:55,016
of other surfaces in the scene


199
00:05:55,276 --> 00:05:56,446
before reaching the shading


200
00:05:56,446 --> 00:05:56,786
point.


201
00:05:57,386 --> 00:05:59,696
To collect indirect light, we


202
00:05:59,696 --> 00:06:01,486
can cast secondary rays in


203
00:06:01,486 --> 00:06:02,596
random directions from the


204
00:06:02,596 --> 00:06:03,256
shading point.


205
00:06:04,686 --> 00:06:05,786
We then, repeat the shading


206
00:06:05,786 --> 00:06:07,126
process at the secondary


207
00:06:07,126 --> 00:06:08,106
intersection points.


208
00:06:09,896 --> 00:06:11,046
We'll first compute how much


209
00:06:11,046 --> 00:06:13,176
light is arriving directly at


210
00:06:13,176 --> 00:06:14,596
the second intersection point


211
00:06:15,066 --> 00:06:16,366
and what fraction of that light


212
00:06:16,636 --> 00:06:17,876
is reflected back towards the


213
00:06:17,876 --> 00:06:19,236
previous intersection point.


214
00:06:19,236 --> 00:06:21,186
And, ultimately, back into the


215
00:06:21,186 --> 00:06:21,616
camera.


216
00:06:22,566 --> 00:06:24,186
We'll also need to cast another


217
00:06:24,186 --> 00:06:25,806
shadow ray from the secondary


218
00:06:25,806 --> 00:06:26,706
intersection point.


219
00:06:26,706 --> 00:06:30,346
And we can repeat this process


220
00:06:30,346 --> 00:06:31,946
however many times we'd like to


221
00:06:31,946 --> 00:06:33,836
simulate light bouncing around


222
00:06:34,356 --> 00:06:36,336
the scene.


223
00:06:37,006 --> 00:06:38,446
Now, in order to get these nice


224
00:06:38,446 --> 00:06:39,906
soft shadow and bounced lighting


225
00:06:39,906 --> 00:06:41,746
effects we, actually, need to


226
00:06:41,746 --> 00:06:43,256
cast many shadow and secondary


227
00:06:43,256 --> 00:06:46,326
rays per point along the path.


228
00:06:46,546 --> 00:06:47,516
This means that the number of


229
00:06:47,516 --> 00:06:48,916
rays, actually, grows


230
00:06:48,916 --> 00:06:50,206
exponentially with the number of


231
00:06:50,206 --> 00:06:50,716
bounces.


232
00:06:51,946 --> 00:06:53,436
To avoid this exponential growth


233
00:06:54,346 --> 00:06:55,666
we'll, instead, choose just one


234
00:06:55,666 --> 00:06:57,446
shadow ray and one secondary ray


235
00:06:57,446 --> 00:06:58,636
direction at each bounce.


236
00:07:00,106 --> 00:07:01,396
This will result in a noisy


237
00:07:01,396 --> 00:07:03,366
image but we can average the


238
00:07:03,366 --> 00:07:04,826
results together over multiple


239
00:07:04,826 --> 00:07:05,316
frames.


240
00:07:06,256 --> 00:07:07,446
Each frame will, also, generate


241
00:07:07,446 --> 00:07:09,386
its own set of primary rays, so


242
00:07:09,386 --> 00:07:10,616
this, also, gives us the


243
00:07:10,616 --> 00:07:12,046
opportunity to implement camera


244
00:07:12,046 --> 00:07:13,446
effects such as depth of field


245
00:07:13,446 --> 00:07:14,176
and motion blur.


246
00:07:14,686 --> 00:07:17,536
So, let's translate this all


247
00:07:17,536 --> 00:07:18,346
into a diagram.


248
00:07:19,446 --> 00:07:21,286
First, we'll generate primary


249
00:07:21,286 --> 00:07:21,616
rays.


250
00:07:22,346 --> 00:07:23,476
Then, we'll find the


251
00:07:23,476 --> 00:07:24,686
intersections with the scene.


252
00:07:25,316 --> 00:07:27,606
Then, we'll compute shading at


253
00:07:27,606 --> 00:07:28,676
the intersection points.


254
00:07:28,946 --> 00:07:30,086
And remember, that this is an


255
00:07:30,086 --> 00:07:31,546
iterative process, which will


256
00:07:31,546 --> 00:07:33,046
generate additional shadow and


257
00:07:33,046 --> 00:07:34,616
secondary rays, which will be


258
00:07:34,616 --> 00:07:35,566
intersected with the scene,


259
00:07:35,566 --> 00:07:36,006
again.


260
00:07:36,036 --> 00:07:37,946
And finally, we'll write the


261
00:07:37,946 --> 00:07:39,366
shaded color into our image.


262
00:07:40,986 --> 00:07:42,036
So, this is describing a


263
00:07:42,066 --> 00:07:43,126
rendering application.


264
00:07:43,456 --> 00:07:44,746
But a significant fraction of


265
00:07:44,746 --> 00:07:46,526
the time is, actually, spent on


266
00:07:46,526 --> 00:07:47,606
ray triangle intersection


267
00:07:47,606 --> 00:07:48,126
testing.


268
00:07:49,446 --> 00:07:50,556
This means that the performance


269
00:07:50,556 --> 00:07:52,306
of the intersector has a huge


270
00:07:52,306 --> 00:07:53,826
impact on the overall rendering


271
00:07:53,826 --> 00:07:55,246
performance, even though, it has


272
00:07:55,246 --> 00:07:56,376
nothing to do with the actual


273
00:07:56,376 --> 00:07:57,336
lighting and shading.


274
00:07:58,496 --> 00:08:00,066
This core intersection problem


275
00:08:00,386 --> 00:08:01,716
is, also, common to all Ray


276
00:08:01,716 --> 00:08:02,766
Tracing applications.


277
00:08:04,836 --> 00:08:06,026
So, we decided to solve this


278
00:08:06,026 --> 00:08:07,456
core intersection problem for


279
00:08:07,456 --> 00:08:09,176
you, so that you can start with


280
00:08:09,176 --> 00:08:10,766
a high performance intersector


281
00:08:11,126 --> 00:08:12,556
and just focus on the details of


282
00:08:12,556 --> 00:08:12,996
you app.


283
00:08:14,206 --> 00:08:16,576
So, this year, we're introducing


284
00:08:16,576 --> 00:08:18,276
the MPSRayIntersector API.


285
00:08:19,676 --> 00:08:21,306
This is an API which accelerates


286
00:08:21,306 --> 00:08:22,386
ray triangle intersection


287
00:08:22,386 --> 00:08:25,136
testing on the GPU on all of our


288
00:08:25,136 --> 00:08:26,786
macOS and iOS devices.


289
00:08:28,116 --> 00:08:29,626
We wanted to make it easy to


290
00:08:29,626 --> 00:08:30,806
integrate his into existing


291
00:08:30,806 --> 00:08:32,676
apps, so we simply take in rays


292
00:08:32,726 --> 00:08:33,606
through a METAL buffer.


293
00:08:34,666 --> 00:08:35,966
MPS will find the closest


294
00:08:35,966 --> 00:08:38,035
intersection along each ray and


295
00:08:38,035 --> 00:08:39,166
return the results in another


296
00:08:39,166 --> 00:08:39,796
METAL buffer.


297
00:08:40,686 --> 00:08:42,885
All you need to do is provide a


298
00:08:42,885 --> 00:08:44,326
METAL command buffer at the


299
00:08:44,326 --> 00:08:45,566
point in your application where


300
00:08:45,566 --> 00:08:46,436
you'd like to perform


301
00:08:46,436 --> 00:08:47,426
intersection testing.


302
00:08:47,826 --> 00:08:49,016
And we'll encode all of the


303
00:08:49,016 --> 00:08:50,096
intersection work into the


304
00:08:50,096 --> 00:08:51,126
command buffer for you.


305
00:08:52,346 --> 00:08:53,936
So, let's take a closer look at


306
00:08:53,936 --> 00:08:54,796
the problem that we're trying to


307
00:08:54,796 --> 00:08:55,156
solve.


308
00:08:55,816 --> 00:09:02,916
Oh. Okay. So, 3D models are,


309
00:09:02,916 --> 00:09:04,276
usually, represented as arrays


310
00:09:04,276 --> 00:09:04,916
of triangles.


311
00:09:05,966 --> 00:09:07,756
What we need to do is search


312
00:09:07,756 --> 00:09:09,306
through those triangles and


313
00:09:09,306 --> 00:09:10,986
figure out which ones intersect


314
00:09:10,986 --> 00:09:11,486
each ray.


315
00:09:11,576 --> 00:09:13,926
And furthermore, we need to


316
00:09:13,926 --> 00:09:15,526
figure out which intersection


317
00:09:15,526 --> 00:09:16,956
point is closest to the ray's


318
00:09:16,956 --> 00:09:17,346
origin.


319
00:09:17,586 --> 00:09:20,516
And the simplest way to do this


320
00:09:20,996 --> 00:09:22,116
would be to just loop through


321
00:09:22,116 --> 00:09:23,506
all the triangles and check for


322
00:09:23,506 --> 00:09:24,506
intersection with the ray.


323
00:09:25,376 --> 00:09:26,226
But for anything but the


324
00:09:26,226 --> 00:09:27,776
smallest scenes, this would be


325
00:09:27,776 --> 00:09:28,646
far too slow.


326
00:09:29,666 --> 00:09:31,416
So instead, we built a data


327
00:09:31,416 --> 00:09:32,516
structure that we call an


328
00:09:32,516 --> 00:09:33,606
Acceleration Structure.


329
00:09:34,156 --> 00:09:36,056
The acceleration structure works


330
00:09:36,096 --> 00:09:37,336
by recursively dividing the


331
00:09:37,336 --> 00:09:39,186
scene into groups of triangles


332
00:09:39,216 --> 00:09:40,426
that are located nearby in


333
00:09:40,426 --> 00:09:40,826
space.


334
00:09:42,496 --> 00:09:43,696
When you want to intersect a ray


335
00:09:43,696 --> 00:09:45,796
with a scene, we intersect the


336
00:09:45,796 --> 00:09:47,086
ray with the bounding boxes in


337
00:09:47,086 --> 00:09:47,486
the tree.


338
00:09:48,386 --> 00:09:50,016
If a ray misses a bounding box,


339
00:09:50,136 --> 00:09:51,276
then we can skip the entire


340
00:09:51,276 --> 00:09:51,806
subtree.


341
00:09:53,136 --> 00:09:54,226
In the end, we're left with just


342
00:09:54,226 --> 00:09:55,456
a fraction of the triangles that


343
00:09:55,456 --> 00:09:56,636
we actually need to check for


344
00:09:56,636 --> 00:09:57,586
intersection with the ray.


345
00:09:58,746 --> 00:10:00,356
So, this is the main way that we


346
00:10:00,356 --> 00:10:01,346
speed up ray triangle


347
00:10:01,346 --> 00:10:01,996
intersection.


348
00:10:03,336 --> 00:10:04,876
Of course, this is a simplified


349
00:10:04,876 --> 00:10:05,386
example.


350
00:10:06,156 --> 00:10:07,846
In a real scene the acceleration


351
00:10:07,846 --> 00:10:08,906
structure can be quite a bit


352
00:10:08,906 --> 00:10:09,646
more complicated.


353
00:10:09,646 --> 00:10:12,236
We can see from this


354
00:10:12,236 --> 00:10:13,566
visualization that the


355
00:10:13,566 --> 00:10:14,756
acceleration structure is


356
00:10:14,756 --> 00:10:16,176
adapting to the complexity of


357
00:10:16,176 --> 00:10:16,866
the geometry.


358
00:10:17,236 --> 00:10:19,106
This means that we spend most of


359
00:10:19,106 --> 00:10:20,356
our time searching for


360
00:10:20,356 --> 00:10:22,226
intersections only in areas of


361
00:10:22,226 --> 00:10:24,226
high geometric complexity, which


362
00:10:24,226 --> 00:10:24,926
is what we want.


363
00:10:26,156 --> 00:10:27,586
Now, I'm describing this to give


364
00:10:27,586 --> 00:10:29,486
you an intuition for what the


365
00:10:29,486 --> 00:10:31,086
acceleration structure is and


366
00:10:31,086 --> 00:10:31,816
how it works.


367
00:10:32,516 --> 00:10:33,436
But you, actually, don't need to


368
00:10:33,436 --> 00:10:34,546
worry about this, too much,


369
00:10:35,026 --> 00:10:36,116
because MPS will take care of


370
00:10:36,116 --> 00:10:36,806
all of this for you.


371
00:10:36,806 --> 00:10:39,976
Remember that we'll model our


372
00:10:39,976 --> 00:10:41,316
scene using triangles.


373
00:10:41,686 --> 00:10:42,756
And those triangles will


374
00:10:42,756 --> 00:10:43,986
themselves be represented by


375
00:10:43,986 --> 00:10:45,656
vertices in a vertex buffer.


376
00:10:46,736 --> 00:10:48,616
All you need to do is call MPS


377
00:10:48,616 --> 00:10:50,416
to build an acceleration


378
00:10:50,416 --> 00:10:51,506
structure from your vertex


379
00:10:51,536 --> 00:10:51,896
buffer.


380
00:10:52,576 --> 00:10:54,286
When you're ready to search for


381
00:10:54,286 --> 00:10:55,666
intersections, you simply


382
00:10:55,666 --> 00:10:56,786
provide this acceleration


383
00:10:56,786 --> 00:10:57,626
structure back to the


384
00:10:57,626 --> 00:10:58,256
intersector.


385
00:10:59,276 --> 00:11:00,646
So, let's see how we can use


386
00:11:00,646 --> 00:11:01,486
this to build a real


387
00:11:01,486 --> 00:11:02,026
application.


388
00:11:03,426 --> 00:11:04,736
We'll break this app into three


389
00:11:04,736 --> 00:11:05,286
stages.


390
00:11:05,656 --> 00:11:07,396
First, we'll generate primary


391
00:11:07,396 --> 00:11:09,186
rays, find the intersections


392
00:11:09,186 --> 00:11:10,556
with the scene, and compute


393
00:11:10,556 --> 00:11:11,126
shading.


394
00:11:11,996 --> 00:11:13,006
This will be equivalent to what


395
00:11:13,006 --> 00:11:13,836
we could have done with the


396
00:11:13,836 --> 00:11:15,626
rasterizer, but we'll take it


397
00:11:15,626 --> 00:11:16,616
further in the next steps.


398
00:11:17,336 --> 00:11:19,426
So next, we'll add shadows.


399
00:11:20,046 --> 00:11:21,436
MPS has special support for


400
00:11:21,436 --> 00:11:23,156
shadow rays, which can make this


401
00:11:23,156 --> 00:11:24,426
application even faster.


402
00:11:24,576 --> 00:11:27,626
And finally, we'll simulate


403
00:11:27,626 --> 00:11:29,076
light bouncing around the scene


404
00:11:29,306 --> 00:11:30,406
using secondary rays.


405
00:11:31,426 --> 00:11:32,616
This would be very difficult to


406
00:11:32,616 --> 00:11:33,806
do with the rasterizer, but


407
00:11:33,806 --> 00:11:34,916
we'll see that it's, actually, a


408
00:11:34,916 --> 00:11:36,036
straightforward extension with


409
00:11:36,036 --> 00:11:36,476
Ray Tracing.


410
00:11:37,226 --> 00:11:39,906
So, let's start with primary


411
00:11:41,276 --> 00:11:41,396
rays.


412
00:11:41,686 --> 00:11:42,706
There are five things that we


413
00:11:42,706 --> 00:11:43,186
need to do.


414
00:11:44,156 --> 00:11:45,726
First, we'll create a ray


415
00:11:45,726 --> 00:11:46,756
triangle intersector.


416
00:11:48,076 --> 00:11:49,096
Then, we'll create an


417
00:11:49,096 --> 00:11:50,376
acceleration structure from our


418
00:11:50,376 --> 00:11:51,186
vertex buffer.


419
00:11:51,646 --> 00:11:54,766
Next, we'll generate primary


420
00:11:54,766 --> 00:11:56,276
rays and write them into our ray


421
00:11:56,276 --> 00:11:56,716
buffer.


422
00:11:58,706 --> 00:11:59,406
We'll then, find the


423
00:11:59,406 --> 00:12:01,156
intersections between those rays


424
00:12:01,156 --> 00:12:02,276
and the scene, using the


425
00:12:02,276 --> 00:12:02,966
intersector.


426
00:12:03,256 --> 00:12:05,506
And finally, we'll use the


427
00:12:05,506 --> 00:12:07,136
intersection results to compute


428
00:12:07,136 --> 00:12:07,656
shading.


429
00:12:08,766 --> 00:12:09,876
So, let's start with the


430
00:12:09,876 --> 00:12:10,506
intersector.


431
00:12:11,136 --> 00:12:14,556
The MPSRayIntersector class


432
00:12:14,786 --> 00:12:15,806
coordinates all of the ray


433
00:12:15,806 --> 00:12:17,186
triangle intersection testing.


434
00:12:18,256 --> 00:12:19,736
All we need to do to create one


435
00:12:19,826 --> 00:12:21,136
is provide the METAL device that


436
00:12:21,136 --> 00:12:22,436
we want to use for intersection


437
00:12:22,436 --> 00:12:22,806
testing.


438
00:12:23,426 --> 00:12:26,106
Next, we'll create the


439
00:12:26,106 --> 00:12:27,156
acceleration structure.


440
00:12:28,416 --> 00:12:30,416
This is represented by the


441
00:12:30,416 --> 00:12:31,966
MPSTriangleAccelerationStructure


442
00:12:31,966 --> 00:12:32,366
class.


443
00:12:33,136 --> 00:12:34,306
Again, all we need to do to


444
00:12:34,306 --> 00:12:35,936
create one is provide the same


445
00:12:35,936 --> 00:12:37,196
METAL device we used to create


446
00:12:37,196 --> 00:12:37,926
the intersector.


447
00:12:38,536 --> 00:12:41,716
We then, attach our vertexBuffer


448
00:12:41,716 --> 00:12:43,186
and specify the triangleCount.


449
00:12:43,356 --> 00:12:45,786
And finally, we build the


450
00:12:45,786 --> 00:12:46,846
acceleration structure.


451
00:12:47,536 --> 00:12:48,986
We only need to do this once.


452
00:12:48,986 --> 00:12:50,066
And then, we can reuse the


453
00:12:50,066 --> 00:12:51,746
acceleration structure as many


454
00:12:51,746 --> 00:12:52,536
times as we'd like.


455
00:12:56,616 --> 00:12:57,976
So next, we'll generate primary


456
00:12:57,976 --> 00:12:59,386
rays and write them into our ray


457
00:12:59,386 --> 00:12:59,796
buffer.


458
00:13:01,176 --> 00:13:02,236
To do this, we'll launch a


459
00:13:02,236 --> 00:13:03,766
two-dimensional compute kernel


460
00:13:04,146 --> 00:13:05,466
with one thread per pixel.


461
00:13:06,506 --> 00:13:08,166
Each thread will write this ray


462
00:13:08,166 --> 00:13:09,636
struct into the ray buffer.


463
00:13:10,756 --> 00:13:12,676
We can think about our output


464
00:13:12,676 --> 00:13:14,686
image as floating on a plane in


465
00:13:14,686 --> 00:13:15,356
front of the camera.


466
00:13:17,396 --> 00:13:18,846
Primary rays are emitted from


467
00:13:18,846 --> 00:13:20,196
the camera, so we'll simply set


468
00:13:20,196 --> 00:13:21,226
the origin to the camera


469
00:13:21,226 --> 00:13:21,636
position.


470
00:13:22,746 --> 00:13:24,626
To compute the direction, we'll


471
00:13:24,626 --> 00:13:25,866
find the direction from the


472
00:13:25,866 --> 00:13:27,346
camera position through the


473
00:13:27,346 --> 00:13:28,906
corresponding pixel on the image


474
00:13:28,906 --> 00:13:29,226
plan.


475
00:13:29,406 --> 00:13:33,406
Now that we have our primary


476
00:13:33,406 --> 00:13:35,066
rays, we'll use the intersector


477
00:13:35,066 --> 00:13:36,166
to find the intersections of the


478
00:13:36,166 --> 00:13:36,546
scene.


479
00:13:37,776 --> 00:13:40,286
The encodeIntersection call will


480
00:13:40,286 --> 00:13:41,366
tie together everything we've


481
00:13:41,366 --> 00:13:42,216
created, so far.


482
00:13:43,436 --> 00:13:44,306
First, remember that we'll


483
00:13:44,306 --> 00:13:46,236
encode into a METAL command


484
00:13:46,236 --> 00:13:46,586
buffer.


485
00:13:47,346 --> 00:13:48,816
We, actually, have a couple of


486
00:13:48,816 --> 00:13:49,856
options for what type of


487
00:13:49,856 --> 00:13:51,046
intersection search we'd like to


488
00:13:51,046 --> 00:13:51,306
do.


489
00:13:52,056 --> 00:13:53,106
In this case, we'll just use


490
00:13:53,106 --> 00:13:54,226
nearest, which will find the


491
00:13:54,226 --> 00:13:55,906
closest intersection along each


492
00:13:55,906 --> 00:13:56,176
ray.


493
00:13:56,766 --> 00:13:59,046
We'll then, provide the ray


494
00:13:59,046 --> 00:14:00,276
buffer, which contains the


495
00:14:00,276 --> 00:14:03,596
primary rays we just created, as


496
00:14:03,596 --> 00:14:04,806
well as an intersection buffer,


497
00:14:04,806 --> 00:14:05,486
which will contain the


498
00:14:05,486 --> 00:14:06,496
intersection results.


499
00:14:07,866 --> 00:14:08,816
We, also, need to provide the


500
00:14:08,816 --> 00:14:10,616
rayCount, which in this case, is


501
00:14:10,616 --> 00:14:11,896
just the image width times the


502
00:14:11,896 --> 00:14:12,456
image height.


503
00:14:12,456 --> 00:14:15,096
And finally, we'll provide our


504
00:14:15,096 --> 00:14:16,106
accelerationStructure.


505
00:14:17,756 --> 00:14:18,986
MPS will find the closest


506
00:14:18,986 --> 00:14:20,716
intersection along each ray and


507
00:14:20,716 --> 00:14:21,766
return the results in the


508
00:14:21,766 --> 00:14:22,666
intersection buffer.


509
00:14:23,316 --> 00:14:24,706
So, all that's left is to use


510
00:14:24,706 --> 00:14:26,106
the intersection data to compute


511
00:14:26,106 --> 00:14:26,546
shading.


512
00:14:27,166 --> 00:14:29,956
To do this, we'll launch another


513
00:14:29,956 --> 00:14:30,686
compute kernel.


514
00:14:31,266 --> 00:14:32,816
We can apply lighting and


515
00:14:32,816 --> 00:14:34,426
textures similar to the way that


516
00:14:34,426 --> 00:14:35,616
we would in a fragment shader.


517
00:14:36,066 --> 00:14:37,626
Most of the standard texture and


518
00:14:37,626 --> 00:14:38,846
math functions that are


519
00:14:38,846 --> 00:14:40,356
available in a fragment shader


520
00:14:40,756 --> 00:14:41,656
are, also, available in a


521
00:14:41,656 --> 00:14:42,336
compute kernel.


522
00:14:43,246 --> 00:14:45,126
But shading, typically, depends


523
00:14:45,126 --> 00:14:46,586
on both the intersection point


524
00:14:46,856 --> 00:14:48,226
and vertex attributes, such as


525
00:14:48,266 --> 00:14:49,356
colors and normals.


526
00:14:50,076 --> 00:14:52,076
In a fragment shader the GPU


527
00:14:52,076 --> 00:14:53,426
would interpolate these for us.


528
00:14:53,566 --> 00:14:54,966
But we'll need to interpolate


529
00:14:54,966 --> 00:14:56,256
them ourselves based on the


530
00:14:56,256 --> 00:14:57,086
intersection data.


531
00:14:58,036 --> 00:14:59,946
So, let's first look at how we


532
00:14:59,946 --> 00:15:01,016
can compute the intersection


533
00:15:01,016 --> 00:15:01,346
point.


534
00:15:01,776 --> 00:15:04,776
Remember that a ray is defined


535
00:15:04,776 --> 00:15:06,306
by its origin and direction.


536
00:15:07,736 --> 00:15:11,096
This is the intersection struct


537
00:15:11,226 --> 00:15:12,066
returned to us by the


538
00:15:12,066 --> 00:15:12,666
intersector.


539
00:15:13,226 --> 00:15:15,186
The distance field will tell us


540
00:15:15,256 --> 00:15:16,726
how far we would need to go in


541
00:15:16,726 --> 00:15:18,396
the ray direction to get from


542
00:15:18,396 --> 00:15:19,456
the ray origin to the


543
00:15:19,456 --> 00:15:20,386
intersection point.


544
00:15:20,386 --> 00:15:21,946
And this distance will be


545
00:15:21,946 --> 00:15:23,276
negative if the ray doesn't


546
00:15:23,276 --> 00:15:24,166
intersect anything.


547
00:15:25,396 --> 00:15:28,086
The primitiveIndex tells us


548
00:15:28,086 --> 00:15:29,096
which triangle we hit.


549
00:15:29,696 --> 00:15:31,526
And the last field is what we'll


550
00:15:31,526 --> 00:15:32,886
use to interpolate vertex


551
00:15:32,886 --> 00:15:33,496
attributes.


552
00:15:34,776 --> 00:15:36,566
This field contains the first


553
00:15:36,566 --> 00:15:38,356
barycentric coordinates called U


554
00:15:38,356 --> 00:15:38,796
and V.


555
00:15:39,036 --> 00:15:40,476
And these correspond to the


556
00:15:40,476 --> 00:15:41,676
location of the intersection


557
00:15:41,676 --> 00:15:43,436
point relative to the vertices


558
00:15:43,436 --> 00:15:44,076
of the triangle.


559
00:15:45,306 --> 00:15:46,426
There are, actually, three


560
00:15:46,426 --> 00:15:47,926
barycentric coordinates, but


561
00:15:47,926 --> 00:15:48,836
they add up to one.


562
00:15:49,076 --> 00:15:50,316
So, we can compute the third


563
00:15:50,316 --> 00:15:52,706
coordinate W by subtracting the


564
00:15:52,706 --> 00:15:53,706
first two from one.


565
00:15:55,006 --> 00:15:56,916
If we have a vertex attribute


566
00:15:56,986 --> 00:15:58,356
defined at each vertex of our


567
00:15:58,356 --> 00:16:00,296
triangle, then the interpolated


568
00:16:00,296 --> 00:16:03,346
vertex attribute is just the sum


569
00:16:03,346 --> 00:16:05,466
of the attributes at each vertex


570
00:16:05,696 --> 00:16:06,876
weighted by the barycentric


571
00:16:06,876 --> 00:16:07,396
coordinates.


572
00:16:07,956 --> 00:16:09,766
For example, if we have a color


573
00:16:09,766 --> 00:16:11,466
defined at each vertex, then the


574
00:16:11,466 --> 00:16:13,226
interpolated color is just the


575
00:16:13,226 --> 00:16:14,526
weighted sum of the colors at


576
00:16:14,526 --> 00:16:15,176
each vertex.


577
00:16:15,846 --> 00:16:19,366
So, at this point we've created


578
00:16:19,366 --> 00:16:21,296
a ray intersector and an


579
00:16:21,296 --> 00:16:22,396
acceleration structure.


580
00:16:23,616 --> 00:16:25,226
We then, generated primary rays


581
00:16:25,756 --> 00:16:26,846
and found the intersections with


582
00:16:26,876 --> 00:16:27,356
the scene.


583
00:16:28,336 --> 00:16:29,456
We computed shading at the


584
00:16:29,456 --> 00:16:30,736
intersection points, and then


585
00:16:30,736 --> 00:16:32,156
wrote the shaded color into our


586
00:16:32,156 --> 00:16:32,536
image.


587
00:16:33,026 --> 00:16:33,736
So, let's take a look at the


588
00:16:33,736 --> 00:16:34,176
image.


589
00:16:34,736 --> 00:16:37,156
We can see the geometry


590
00:16:37,156 --> 00:16:38,506
represented by the acceleration


591
00:16:38,506 --> 00:16:39,906
structure, as well as the


592
00:16:39,906 --> 00:16:41,486
interpolated vertex colors and


593
00:16:41,486 --> 00:16:42,586
lighting we just computed.


594
00:16:43,596 --> 00:16:44,736
Now that we have an image on


595
00:16:44,736 --> 00:16:46,186
screen we're ready to add some


596
00:16:46,186 --> 00:16:46,926
additional effects.


597
00:16:48,406 --> 00:16:49,796
So, we'll start by adding


598
00:16:49,796 --> 00:16:50,896
shadows to our image.


599
00:16:51,516 --> 00:16:55,376
To do this, we need to check if


600
00:16:55,376 --> 00:16:57,406
the light can actually reach the


601
00:16:57,406 --> 00:16:59,126
shading point before adding it


602
00:16:59,126 --> 00:16:59,746
to the image.


603
00:17:00,906 --> 00:17:02,106
To do this we can cast


604
00:17:02,106 --> 00:17:03,976
additional shadow rays from the


605
00:17:04,026 --> 00:17:05,296
intersection points towards the


606
00:17:05,296 --> 00:17:05,996
light source.


607
00:17:07,175 --> 00:17:08,965
If a shadow ray doesn't make it


608
00:17:08,965 --> 00:17:10,156
all the way to the light source,


609
00:17:10,215 --> 00:17:11,626
then the original shaded point


610
00:17:11,626 --> 00:17:12,306
wasn't shadow.


611
00:17:12,665 --> 00:17:13,796
So, we shouldn't add its color


612
00:17:13,796 --> 00:17:14,415
to the image.


613
00:17:17,076 --> 00:17:19,106
We'll modify our shading kernel


614
00:17:19,806 --> 00:17:21,185
to write out additional shadow


615
00:17:21,185 --> 00:17:22,695
rays into another METAL buffer.


616
00:17:24,415 --> 00:17:25,445
We'll then, find the


617
00:17:25,445 --> 00:17:26,486
intersections with the scene,


618
00:17:26,486 --> 00:17:26,935
again.


619
00:17:27,526 --> 00:17:29,366
And then, we'll launch one final


620
00:17:29,366 --> 00:17:30,996
kernel which will conditionally


621
00:17:30,996 --> 00:17:32,466
write the shaded color into the


622
00:17:32,466 --> 00:17:34,136
image based on whether or not


623
00:17:34,136 --> 00:17:35,216
the shadow rays intersect at


624
00:17:35,216 --> 00:17:35,486
anything.


625
00:17:36,646 --> 00:17:38,116
So, let's start with the changes


626
00:17:38,116 --> 00:17:38,946
to the shading kernel.


627
00:17:39,546 --> 00:17:42,106
Now, shadow rays are a little


628
00:17:42,106 --> 00:17:43,366
different than primary rays.


629
00:17:43,886 --> 00:17:45,876
First, we need to provide a


630
00:17:45,876 --> 00:17:48,096
maximum intersection distance so


631
00:17:48,096 --> 00:17:49,166
that our shadow rays don't


632
00:17:49,166 --> 00:17:50,306
overshoot the light source.


633
00:17:50,916 --> 00:17:54,106
We also don't need to know which


634
00:17:54,106 --> 00:17:55,396
triangle we hit or what the


635
00:17:55,396 --> 00:17:56,666
barycentric coordinates were.


636
00:17:57,016 --> 00:17:58,146
So, there are some optimizations


637
00:17:58,146 --> 00:17:58,576
we can do.


638
00:17:58,886 --> 00:18:01,876
And finally, remember that we


639
00:18:01,876 --> 00:18:03,186
can't write the shaded color


640
00:18:03,186 --> 00:18:04,736
into the image until we know


641
00:18:04,736 --> 00:18:05,816
whether or not the original


642
00:18:05,816 --> 00:18:07,106
shading point was in shadow.


643
00:18:07,886 --> 00:18:09,386
So, we need a way to pass the


644
00:18:09,386 --> 00:18:10,856
color from the shading kernel


645
00:18:11,146 --> 00:18:12,806
through the intersector, all the


646
00:18:12,806 --> 00:18:14,416
way into the final kernel, which


647
00:18:14,416 --> 00:18:15,346
will update the image.


648
00:18:16,356 --> 00:18:17,806
To do this, we can customize our


649
00:18:17,806 --> 00:18:18,366
ray struct.


650
00:18:20,716 --> 00:18:23,496
So, first we have several


651
00:18:23,496 --> 00:18:24,726
options for what data we


652
00:18:24,726 --> 00:18:25,686
actually provide to the


653
00:18:25,686 --> 00:18:26,316
intersector.


654
00:18:27,166 --> 00:18:28,626
In this case, we'll use a data


655
00:18:28,626 --> 00:18:30,026
type which includes minimum and


656
00:18:30,026 --> 00:18:31,276
maximum distance fields.


657
00:18:32,416 --> 00:18:33,626
MPS will ignore any


658
00:18:33,626 --> 00:18:34,996
intersections outside of this


659
00:18:34,996 --> 00:18:36,356
range, which will prevent our


660
00:18:36,356 --> 00:18:37,876
shadow rays from overshooting


661
00:18:37,956 --> 00:18:39,676
the light source.


662
00:18:40,146 --> 00:18:41,796
Second, if you have


663
00:18:41,796 --> 00:18:43,256
application-specific data


664
00:18:43,306 --> 00:18:45,246
associated with your rays you


665
00:18:45,246 --> 00:18:46,536
can append that data at the end


666
00:18:46,536 --> 00:18:47,946
of the ray struct and provide a


667
00:18:47,946 --> 00:18:48,776
rayStride.


668
00:18:49,766 --> 00:18:51,346
MPS will skip past this data


669
00:18:51,346 --> 00:18:52,306
when reading from your ray


670
00:18:52,306 --> 00:18:52,706
buffer.


671
00:18:53,896 --> 00:18:55,176
In this case, we'll add the


672
00:18:55,176 --> 00:18:56,466
shade of color to the end of the


673
00:18:56,466 --> 00:18:58,096
ray, so that we can propagate it


674
00:18:58,096 --> 00:18:59,546
from the shading kernel through


675
00:18:59,546 --> 00:19:00,386
to the final kernel.


676
00:19:00,956 --> 00:19:03,526
We configure these options on


677
00:19:03,526 --> 00:19:04,406
the ray intersector.


678
00:19:04,966 --> 00:19:07,496
First, we'll set the rayDataType


679
00:19:07,496 --> 00:19:09,166
to match our struct type.


680
00:19:10,056 --> 00:19:12,056
Then, we'll set a rayStride to


681
00:19:12,056 --> 00:19:13,606
skip past the color at the end


682
00:19:13,606 --> 00:19:16,166
of the struct.


683
00:19:16,606 --> 00:19:17,726
Next, we'll run the shadow rays


684
00:19:17,766 --> 00:19:18,626
through the intersector.


685
00:19:19,106 --> 00:19:22,036
This was our original call to


686
00:19:22,036 --> 00:19:22,816
the intersector.


687
00:19:23,566 --> 00:19:24,756
Remember that shadow rays are


688
00:19:24,756 --> 00:19:26,256
only checking for visibility


689
00:19:26,256 --> 00:19:27,556
between the original shading


690
00:19:27,556 --> 00:19:28,586
point and the light source.


691
00:19:28,956 --> 00:19:30,086
So, there are two optimizations


692
00:19:30,086 --> 00:19:30,486
we can do.


693
00:19:31,596 --> 00:19:32,946
First, just like we can


694
00:19:32,946 --> 00:19:35,076
customize the rayDataType, we


695
00:19:35,076 --> 00:19:36,146
can also customize the


696
00:19:36,146 --> 00:19:38,346
intersection data type or what


697
00:19:38,346 --> 00:19:39,586
data is returned to us by the


698
00:19:39,586 --> 00:19:40,206
intersector.


699
00:19:41,516 --> 00:19:43,136
In this case, we only need to


700
00:19:43,136 --> 00:19:44,416
know if the distance is positive


701
00:19:44,416 --> 00:19:46,236
or negative, indicating a hit or


702
00:19:46,236 --> 00:19:46,546
a miss.


703
00:19:47,046 --> 00:19:48,726
So, we can set the intersection


704
00:19:48,726 --> 00:19:50,196
data type to just distance.


705
00:19:50,746 --> 00:19:51,756
This will save some memory


706
00:19:51,756 --> 00:19:53,406
bandwidth reading from and


707
00:19:53,406 --> 00:19:54,626
writing to the intersection


708
00:19:54,626 --> 00:19:54,996
buffer.


709
00:19:55,366 --> 00:19:58,946
Second, because we don't,


710
00:19:58,946 --> 00:19:59,906
actually, need to know which


711
00:19:59,906 --> 00:20:01,676
triangle we hit, we can end the


712
00:20:01,676 --> 00:20:03,086
intersection search as soon as


713
00:20:03,086 --> 00:20:03,976
we hit any triangle.


714
00:20:04,736 --> 00:20:06,466
This is, typically, much faster


715
00:20:06,466 --> 00:20:07,546
than searching for the closest


716
00:20:07,546 --> 00:20:08,206
intersection.


717
00:20:09,186 --> 00:20:10,926
MPS has a special mode for this,


718
00:20:11,056 --> 00:20:12,786
which we can turn on by passing


719
00:20:12,786 --> 00:20:14,906
the any intersectionType instead


720
00:20:15,676 --> 00:20:17,936
of nearest.


721
00:20:18,406 --> 00:20:19,936
Finally, we can launch our last


722
00:20:19,936 --> 00:20:21,386
kernel, which will add the color


723
00:20:21,386 --> 00:20:23,756
to the image.


724
00:20:24,236 --> 00:20:25,886
Each thread will read in one


725
00:20:25,886 --> 00:20:27,906
shadow ray and the corresponding


726
00:20:27,906 --> 00:20:28,756
intersection data.


727
00:20:29,896 --> 00:20:31,526
If the intersection distance was


728
00:20:31,566 --> 00:20:33,216
positive, then the original


729
00:20:33,216 --> 00:20:34,286
intersection point was in


730
00:20:34,286 --> 00:20:34,796
shadow.


731
00:20:35,156 --> 00:20:36,456
So, there's nothing more to do.


732
00:20:37,576 --> 00:20:38,616
Otherwise, the intersection


733
00:20:38,616 --> 00:20:39,766
point wasn't in shadow.


734
00:20:40,716 --> 00:20:42,396
So, we should read in the ray


735
00:20:42,396 --> 00:20:43,896
color and write it into the


736
00:20:43,896 --> 00:20:44,546
output image.


737
00:20:45,456 --> 00:20:46,936
And that's all we need to do to


738
00:20:46,936 --> 00:20:48,096
add shadows to our image.


739
00:20:48,716 --> 00:20:52,016
We can see that each shaded


740
00:20:52,056 --> 00:20:53,476
point is now checking whether or


741
00:20:53,476 --> 00:20:54,826
not the light source is visible


742
00:20:54,826 --> 00:20:56,136
before adding the lighting to


743
00:20:56,136 --> 00:20:56,616
the image.


744
00:20:57,626 --> 00:20:59,056
Because we're using a ray tracer


745
00:20:59,686 --> 00:21:01,026
we can, also, randomly sample


746
00:21:01,026 --> 00:21:02,336
the surface of the light source,


747
00:21:02,516 --> 00:21:03,766
which gives us these nice soft


748
00:21:03,766 --> 00:21:04,236
shadows.


749
00:21:06,756 --> 00:21:09,156
So last, we'll look at secondary


750
00:21:09,786 --> 00:21:09,926
rays.


751
00:21:10,636 --> 00:21:12,626
Remember that secondary rays


752
00:21:12,626 --> 00:21:14,136
simulate light bouncing around


753
00:21:14,136 --> 00:21:14,636
the scene.


754
00:21:15,646 --> 00:21:16,666
All we need to do to add


755
00:21:16,666 --> 00:21:18,626
secondary rays is move all of


756
00:21:18,626 --> 00:21:19,716
our kernels into a loop.


757
00:21:20,136 --> 00:21:21,986
In each iteration we'll choose a


758
00:21:21,986 --> 00:21:23,966
new random direction to continue


759
00:21:23,966 --> 00:21:24,656
they ray's path.


760
00:21:29,756 --> 00:21:31,716
So, modify the shading kernel to


761
00:21:31,716 --> 00:21:33,206
produce the rays for the next


762
00:21:33,406 --> 00:21:34,066
iteration.


763
00:21:35,206 --> 00:21:36,356
Once we finish updating our


764
00:21:36,356 --> 00:21:38,536
image we can simply loop back to


765
00:21:38,536 --> 00:21:39,896
the first intersection test.


766
00:21:40,766 --> 00:21:41,946
And we can repeat this loop


767
00:21:41,946 --> 00:21:43,486
however many times we want rays


768
00:21:43,486 --> 00:21:44,046
to bounce.


769
00:21:46,576 --> 00:21:48,506
So, let's look at the changes to


770
00:21:48,506 --> 00:21:49,236
the shading kernel.


771
00:21:51,276 --> 00:21:53,946
In each iteration we'll move the


772
00:21:53,946 --> 00:21:55,366
ray origin to the intersection


773
00:21:55,366 --> 00:21:55,686
point.


774
00:21:56,256 --> 00:21:58,536
We'll then, choose a random


775
00:21:58,536 --> 00:21:59,916
direction to continue the path.


776
00:22:01,076 --> 00:22:03,646
And finally, we'll multiply the


777
00:22:03,646 --> 00:22:04,936
ray color by the interpolated


778
00:22:04,936 --> 00:22:05,676
vertex color.


779
00:22:06,906 --> 00:22:07,916
This will cause the light to


780
00:22:07,916 --> 00:22:09,406
take on the color of whatever


781
00:22:09,406 --> 00:22:10,806
surface it bounces off of.


782
00:22:11,266 --> 00:22:13,326
In a more advanced application,


783
00:22:13,506 --> 00:22:14,546
this would be a much more


784
00:22:14,546 --> 00:22:15,926
complicated calculation.


785
00:22:16,406 --> 00:22:17,616
But by choosing the random ray


786
00:22:17,616 --> 00:22:19,196
directions, carefully, we can


787
00:22:19,196 --> 00:22:20,076
actually get the rest of the


788
00:22:20,076 --> 00:22:21,306
math to cancel out.


789
00:22:21,866 --> 00:22:23,666
And this works even though we're


790
00:22:23,666 --> 00:22:24,606
working backwards from the


791
00:22:24,606 --> 00:22:26,366
camera as long as we're careful


792
00:22:26,366 --> 00:22:28,196
to tint the direct lighting by


793
00:22:28,196 --> 00:22:29,166
the ray color at each


794
00:22:29,166 --> 00:22:29,976
intersection point.


795
00:22:30,526 --> 00:22:32,736
So, that's all we need to do for


796
00:22:32,736 --> 00:22:33,496
secondary rays.


797
00:22:34,756 --> 00:22:36,446
So, we can see that light has


798
00:22:36,446 --> 00:22:37,506
started to bounce off of the


799
00:22:37,506 --> 00:22:39,256
walls and onto the sides of the


800
00:22:39,256 --> 00:22:40,426
boxes and ceiling.


801
00:22:40,996 --> 00:22:43,396
So, that's it for our example


802
00:22:43,686 --> 00:22:44,596
app.


803
00:22:44,906 --> 00:22:46,026
We started by getting an image


804
00:22:46,026 --> 00:22:48,076
on screen with primary rays and


805
00:22:48,076 --> 00:22:48,596
shading.


806
00:22:49,696 --> 00:22:50,866
Then, we added shadows.


807
00:22:51,376 --> 00:22:53,266
And finally, we simulated light


808
00:22:53,266 --> 00:22:54,256
bouncing around the scene with


809
00:22:54,256 --> 00:22:55,046
secondary rays.


810
00:22:56,226 --> 00:22:58,246
So, let's switch to the demo and


811
00:22:58,246 --> 00:22:59,226
take a look at this running


812
00:22:59,226 --> 00:22:59,536
live.


813
00:23:04,076 --> 00:23:05,106
So, here's the application we


814
00:23:05,106 --> 00:23:06,796
just wrote up and running on the


815
00:23:06,796 --> 00:23:08,546
12.9-inch iPad Pro.


816
00:23:09,466 --> 00:23:10,736
We've, actually, extended this


817
00:23:10,736 --> 00:23:12,656
application to support more


818
00:23:12,656 --> 00:23:14,366
advanced lighting, shading,


819
00:23:14,366 --> 00:23:15,486
textures, and more.


820
00:23:16,126 --> 00:23:17,326
So, let's switch to a more


821
00:23:17,326 --> 00:23:19,326
complicated scene, which used


822
00:23:19,326 --> 00:23:20,236
many of these features.


823
00:23:26,046 --> 00:23:27,296
Here's the Amazon Lumberyard


824
00:23:27,296 --> 00:23:29,086
Bistro scene you saw running in


825
00:23:29,086 --> 00:23:31,146
the State of the Union on four


826
00:23:31,146 --> 00:23:31,836
GPUs.


827
00:23:32,756 --> 00:23:34,346
The scene has almost one million


828
00:23:34,346 --> 00:23:34,976
triangles.


829
00:23:35,506 --> 00:23:36,516
But, even with these advanced


830
00:23:36,516 --> 00:23:37,736
lighting and shading techniques


831
00:23:38,096 --> 00:23:39,346
we're still able to achieve


832
00:23:39,346 --> 00:23:40,666
almost 20 million rays per


833
00:23:40,666 --> 00:23:41,916
second on an iPad Pro.


834
00:23:42,166 --> 00:23:43,216
And that's a combined


835
00:23:43,216 --> 00:23:45,046
measurement including primary,


836
00:23:45,246 --> 00:23:46,636
shadow, and secondary rays.


837
00:23:48,406 --> 00:23:49,676
So, we've created what we think


838
00:23:49,956 --> 00:23:51,986
is an easy to use API that you


839
00:23:51,986 --> 00:23:53,276
can use to start implementing


840
00:23:53,276 --> 00:23:54,296
these types of applications


841
00:23:54,366 --> 00:23:54,696
today.


842
00:23:56,106 --> 00:23:57,166
So, that's if for our demo, for


843
00:23:57,166 --> 00:23:57,416
now.


844
00:23:58,766 --> 00:23:59,546
Thank you.


845
00:24:00,516 --> 00:24:03,026
[ Applause ]


846
00:24:03,526 --> 00:24:04,346
So, don't worry if you didn't


847
00:24:04,346 --> 00:24:05,896
catch all of that because this


848
00:24:05,896 --> 00:24:07,096
application will be available


849
00:24:07,096 --> 00:24:08,416
for download as a sample.


850
00:24:09,156 --> 00:24:10,086
The sample demonstrates


851
00:24:10,086 --> 00:24:11,106
everything I've talked about


852
00:24:11,106 --> 00:24:11,946
today and more.


853
00:24:12,716 --> 00:24:13,686
We recommend that you get


854
00:24:13,686 --> 00:24:14,776
started by downloading the


855
00:24:14,776 --> 00:24:16,246
sample and adding your own


856
00:24:16,246 --> 00:24:18,266
geometry, lighting, shading, and


857
00:24:18,266 --> 00:24:18,716
so on.


858
00:24:19,576 --> 00:24:20,746
There's, also, a lot more to the


859
00:24:20,746 --> 00:24:22,446
API that I didn't have time to


860
00:24:22,446 --> 00:24:23,236
talk about, today.


861
00:24:23,826 --> 00:24:24,766
So, we, also, recommend that you


862
00:24:24,766 --> 00:24:26,296
take a look at the documentation


863
00:24:26,296 --> 00:24:26,776
and headers.


864
00:24:27,896 --> 00:24:29,216
And with that, I'll hand it off


865
00:24:29,216 --> 00:24:30,906
to my colleague, Wayne, who will


866
00:24:30,906 --> 00:24:32,086
talk about how we can extend


867
00:24:32,086 --> 00:24:33,366
this to multiple GPUs.


868
00:24:35,396 --> 00:24:35,886
Thank you.


869
00:24:36,516 --> 00:24:41,666
[ Applause ]


870
00:24:42,166 --> 00:24:42,566
>> Thanks, Sean.


871
00:24:43,076 --> 00:24:44,000
Hi, everyone.


872
00:24:48,046 --> 00:24:49,306
So, say you're working on your


873
00:24:49,306 --> 00:24:49,566
Mac.


874
00:24:50,456 --> 00:24:51,996
It has an internal GPU.


875
00:24:52,556 --> 00:24:53,726
But you've, also, plugged in a


876
00:24:53,726 --> 00:24:54,666
couple or really high


877
00:24:54,666 --> 00:24:56,116
performance eGPUs.


878
00:24:56,586 --> 00:24:58,436
And what we'd like to be able to


879
00:24:58,436 --> 00:25:00,646
do is use all of these GPUs


880
00:25:00,646 --> 00:25:02,356
together to make Ray Tracing go


881
00:25:02,356 --> 00:25:05,336
as fast as we possibly can.


882
00:25:05,336 --> 00:25:06,626
So, how are we going to do this?


883
00:25:06,886 --> 00:25:08,506
Well, there's three things we


884
00:25:08,506 --> 00:25:09,136
need to think about.


885
00:25:10,026 --> 00:25:11,956
First of all, how are we going


886
00:25:11,956 --> 00:25:13,806
to divide up the work between


887
00:25:15,056 --> 00:25:15,176
GPUs?


888
00:25:15,786 --> 00:25:18,586
Secondly, at some point the GPUs


889
00:25:18,586 --> 00:25:19,486
are going to need a way to


890
00:25:19,486 --> 00:25:20,216
exchange data.


891
00:25:20,766 --> 00:25:22,066
So, how are we going to deal


892
00:25:22,066 --> 00:25:23,316
with that?


893
00:25:23,846 --> 00:25:25,346
And finally, we need a way to


894
00:25:25,346 --> 00:25:26,596
keep everything synchronized.


895
00:25:27,046 --> 00:25:28,676
Now, for this, I'll show you how


896
00:25:28,676 --> 00:25:29,756
to use the new METAL Events


897
00:25:29,756 --> 00:25:31,056
feature that we're introducing


898
00:25:31,056 --> 00:25:31,616
here, this week.


899
00:25:32,706 --> 00:25:33,426
So, let's get started.


900
00:25:34,146 --> 00:25:36,676
So, to divide up the work we're


901
00:25:36,676 --> 00:25:37,626
going to use something called


902
00:25:37,626 --> 00:25:38,816
Split Frame Rendering.


903
00:25:39,846 --> 00:25:41,756
The idea here is to partition


904
00:25:41,756 --> 00:25:42,976
our frame into regions.


905
00:25:43,086 --> 00:25:44,576
And then, we'll assign each of


906
00:25:44,576 --> 00:25:45,806
these regions to a different


907
00:25:45,806 --> 00:25:47,386
GPU, so that they can be


908
00:25:47,386 --> 00:25:48,276
rendered in parallel.


909
00:25:49,926 --> 00:25:51,696
Now, each GPU will run the full


910
00:25:51,736 --> 00:25:52,936
rendering pipeline that Sean


911
00:25:52,936 --> 00:25:53,586
described earlier.


912
00:25:54,216 --> 00:25:55,426
So, that's everything from


913
00:25:55,426 --> 00:25:57,156
initial ray generation right


914
00:25:57,156 --> 00:25:58,336
through to shadow rays and


915
00:25:58,336 --> 00:25:58,666
shading.


916
00:26:00,376 --> 00:26:01,956
Now, once all GPUs have finished


917
00:26:02,296 --> 00:26:03,686
we'll pick whichever one is


918
00:26:03,686 --> 00:26:06,006
connected to the display and


919
00:26:06,006 --> 00:26:07,116
we'll copy across all of our


920
00:26:07,116 --> 00:26:08,196
completed regions for


921
00:26:08,196 --> 00:26:08,746
composition.


922
00:26:09,346 --> 00:26:12,136
Now, composition could just be


923
00:26:12,136 --> 00:26:13,656
stitching the regions together


924
00:26:13,656 --> 00:26:15,116
into one frame buffer.


925
00:26:16,046 --> 00:26:17,226
Or you might want to combine


926
00:26:17,226 --> 00:26:18,416
them with the results of a


927
00:26:18,416 --> 00:26:20,076
previous render to refine the


928
00:26:20,076 --> 00:26:21,366
image and remove noise.


929
00:26:21,926 --> 00:26:24,816
Now, before we can render


930
00:26:24,816 --> 00:26:26,346
anything, we need to make sure


931
00:26:26,346 --> 00:26:27,846
that each GPU has a complete


932
00:26:27,846 --> 00:26:28,696
copy of the scene.


933
00:26:30,166 --> 00:26:31,936
Assets, such as your vertex


934
00:26:31,936 --> 00:26:33,476
buffers and your textures need


935
00:26:33,476 --> 00:26:35,316
to be replicated on all GPUs.


936
00:26:36,576 --> 00:26:37,516
And so, do the triangle


937
00:26:37,516 --> 00:26:38,656
acceleration structures that


938
00:26:38,656 --> 00:26:41,086
Sean introduced earlier.


939
00:26:42,126 --> 00:26:44,086
Now, for the acceleration


940
00:26:44,086 --> 00:26:45,906
structures, we really wanted to


941
00:26:45,906 --> 00:26:47,106
avoid you having to build them


942
00:26:47,106 --> 00:26:48,626
from scratch for each GPU.


943
00:26:49,546 --> 00:26:51,876
So, we added an API that enables


944
00:26:51,876 --> 00:26:52,906
you to take an existing


945
00:26:52,906 --> 00:26:54,866
acceleration structure and make


946
00:26:54,866 --> 00:26:56,226
a copy for each GPU that you


947
00:26:56,226 --> 00:26:56,776
want to use.


948
00:26:58,156 --> 00:27:00,386
Now, this copy is nonrecursive.


949
00:27:01,086 --> 00:27:02,146
So, any buffers that you have


950
00:27:02,146 --> 00:27:03,446
attached to your acceleration


951
00:27:03,446 --> 00:27:04,966
structure, for example, your


952
00:27:04,966 --> 00:27:06,556
vertex and your index buffers,


953
00:27:07,626 --> 00:27:08,406
you'll need to copy those


954
00:27:08,406 --> 00:27:08,896
separately.


955
00:27:09,196 --> 00:27:10,446
And then, attach them to the


956
00:27:10,446 --> 00:27:11,706
acceleration structure that we


957
00:27:11,706 --> 00:27:12,286
just created.


958
00:27:12,286 --> 00:27:17,596
So, now that the data is


959
00:27:17,596 --> 00:27:19,076
replicated on all GPUs we're


960
00:27:19,136 --> 00:27:20,116
ready to start rendering.


961
00:27:21,996 --> 00:27:23,286
Now, the interesting thing for


962
00:27:23,286 --> 00:27:25,176
our multi-GPU perspective is


963
00:27:25,256 --> 00:27:26,886
that this part of the pipeline


964
00:27:26,886 --> 00:27:28,376
is virtually unchanged from what


965
00:27:28,376 --> 00:27:29,206
Sean described earlier.


966
00:27:30,246 --> 00:27:31,376
The only difference we need to


967
00:27:31,376 --> 00:27:33,416
make for multi-GPU is to


968
00:27:33,416 --> 00:27:34,816
restrict regeneration to


969
00:27:34,816 --> 00:27:36,156
whichever part of the screen a


970
00:27:36,156 --> 00:27:37,636
particular GPU is working on.


971
00:27:38,486 --> 00:27:39,586
Everything else is the same.


972
00:27:40,466 --> 00:27:42,516
So, for that reason, let's move


973
00:27:42,516 --> 00:27:44,096
straight on to what's, probably,


974
00:27:44,256 --> 00:27:45,176
the trickiest stage for


975
00:27:45,176 --> 00:27:47,416
multi-GPU, and that's its final


976
00:27:47,416 --> 00:27:50,426
composition phase here.


977
00:27:51,396 --> 00:27:53,326
Now, for best performance on


978
00:27:53,326 --> 00:27:55,616
macOS, each GPU will render into


979
00:27:55,616 --> 00:27:56,846
its own private buffer.


980
00:27:57,146 --> 00:27:59,446
And once rendering has finished


981
00:27:59,866 --> 00:28:01,456
we need to copy that buffer over


982
00:28:01,456 --> 00:28:03,136
to whichever GPU we're using for


983
00:28:03,136 --> 00:28:03,636
composition.


984
00:28:04,656 --> 00:28:06,216
Now, we can't copy between the


985
00:28:06,216 --> 00:28:07,886
buffers, directly, because METAL


986
00:28:07,886 --> 00:28:09,346
resources can only be used on


987
00:28:09,346 --> 00:28:10,096
the device that they were


988
00:28:10,096 --> 00:28:10,886
created on.


989
00:28:11,036 --> 00:28:12,776
So, you can't create a buffer on


990
00:28:12,776 --> 00:28:14,416
one GPU, and then try and attach


991
00:28:14,416 --> 00:28:15,576
it to a Blit encoder on a


992
00:28:15,576 --> 00:28:16,296
different GPU.


993
00:28:16,296 --> 00:28:17,416
That's just not going to work.


994
00:28:18,136 --> 00:28:19,986
So, this means that our copies


995
00:28:19,986 --> 00:28:20,986
will need to go through system


996
00:28:20,986 --> 00:28:21,296
memory.


997
00:28:21,906 --> 00:28:24,806
Now, to make this as efficient


998
00:28:24,806 --> 00:28:26,286
as we can, we use the buffer


999
00:28:26,286 --> 00:28:27,506
arrangement that you see here.


1000
00:28:28,136 --> 00:28:30,516
We're going to create two METAL


1001
00:28:30,516 --> 00:28:32,796
buffers; one on each device that


1002
00:28:32,796 --> 00:28:34,686
wrap a common CPU allocation.


1003
00:28:35,726 --> 00:28:37,576
And as the buffers wrap the same


1004
00:28:37,576 --> 00:28:39,676
underlying memory anything that


1005
00:28:39,676 --> 00:28:40,906
is written into the METAL buffer


1006
00:28:40,906 --> 00:28:43,456
on device A is, also, visible to


1007
00:28:43,456 --> 00:28:44,996
the METAL buffer on device B.


1008
00:28:45,586 --> 00:28:48,586
Now, as I mentioned earlier, for


1009
00:28:49,096 --> 00:28:51,296
performance reasons on macOS all


1010
00:28:51,296 --> 00:28:52,866
of the actual rendering work is


1011
00:28:52,906 --> 00:28:54,106
done using private buffers.


1012
00:28:55,166 --> 00:28:56,626
And then, we Blit our completed


1013
00:28:56,626 --> 00:28:58,016
regions through system memory


1014
00:28:58,296 --> 00:28:59,426
when it's time to copy them to a


1015
00:28:59,426 --> 00:29:00,126
different GPU.


1016
00:29:00,566 --> 00:29:03,136
So, here's a quick look at how


1017
00:29:03,136 --> 00:29:03,766
to set this up.


1018
00:29:04,556 --> 00:29:06,266
First, we create our buffer on


1019
00:29:06,266 --> 00:29:07,976
device A, using METAL shared


1020
00:29:07,976 --> 00:29:08,616
storage mode.


1021
00:29:08,896 --> 00:29:11,036
And this allocates system


1022
00:29:11,036 --> 00:29:11,916
memory, internally.


1023
00:29:11,916 --> 00:29:13,786
And we can get appointed to it


1024
00:29:13,896 --> 00:29:15,196
using the .contents method.


1025
00:29:15,736 --> 00:29:19,646
We, then create a buffer on


1026
00:29:19,646 --> 00:29:22,596
device B using the NoCopy API to


1027
00:29:22,596 --> 00:29:23,706
wrap the memory that we just


1028
00:29:23,706 --> 00:29:25,606
allocated to buffer A.


1029
00:29:26,726 --> 00:29:28,096
Now, something to be aware of


1030
00:29:28,146 --> 00:29:30,116
for this API is that the buffer


1031
00:29:30,516 --> 00:29:31,686
needs to be a multiple of page


1032
00:29:31,686 --> 00:29:31,976
size.


1033
00:29:31,976 --> 00:29:33,626
So, you'll need to pad the


1034
00:29:33,626 --> 00:29:34,626
length when you create the


1035
00:29:34,626 --> 00:29:35,186
original buffer.


1036
00:29:35,986 --> 00:29:39,996
So, now that we're able to share


1037
00:29:39,996 --> 00:29:41,686
memory between devices we need


1038
00:29:41,686 --> 00:29:42,966
to think about synchronization.


1039
00:29:43,956 --> 00:29:45,286
Now, to help with this we have


1040
00:29:45,286 --> 00:29:46,746
an example timeline here to help


1041
00:29:46,746 --> 00:29:48,356
us visualize two GPUs running in


1042
00:29:48,356 --> 00:29:48,776
parallel.


1043
00:29:49,206 --> 00:29:51,156
The dark boxes represent command


1044
00:29:51,156 --> 00:29:53,096
buffers and the green boxes


1045
00:29:53,096 --> 00:29:54,046
represent work that we've


1046
00:29:54,046 --> 00:29:55,416
encoded into those command


1047
00:29:55,416 --> 00:29:55,806
buffers.


1048
00:29:56,266 --> 00:29:57,766
For example, using a compute


1049
00:29:57,766 --> 00:29:58,476
command encoder.


1050
00:29:59,466 --> 00:30:01,966
So, the GPU at the top there, is


1051
00:30:01,966 --> 00:30:02,786
going to do some rendering.


1052
00:30:03,416 --> 00:30:05,046
And when it's finished, it'll


1053
00:30:05,046 --> 00:30:06,616
Blit its completed region into


1054
00:30:06,616 --> 00:30:07,546
the shared buffers that we were


1055
00:30:07,546 --> 00:30:08,826
just talking about.


1056
00:30:09,626 --> 00:30:12,486
Now, while that's going on GPU B


1057
00:30:12,486 --> 00:30:13,626
is, also, doing some rendering.


1058
00:30:15,096 --> 00:30:16,326
Now, this is the GPU that we're


1059
00:30:16,326 --> 00:30:17,476
going to use for composition.


1060
00:30:18,146 --> 00:30:19,716
So, at some point it's going to


1061
00:30:19,716 --> 00:30:20,866
need the buffer that was


1062
00:30:20,866 --> 00:30:21,886
produced by GPU A.


1063
00:30:21,886 --> 00:30:23,876
Now, we can see here that we


1064
00:30:23,876 --> 00:30:24,676
have a problem.


1065
00:30:25,466 --> 00:30:27,396
There's no synchronization in


1066
00:30:27,396 --> 00:30:28,036
this area, here.


1067
00:30:28,306 --> 00:30:30,196
So, there's nothing to prevent


1068
00:30:30,196 --> 00:30:31,616
GPU B from trying to read the


1069
00:30:31,676 --> 00:30:33,496
buffer before GPU A has finished


1070
00:30:33,496 --> 00:30:34,006
writing to it.


1071
00:30:35,696 --> 00:30:37,046
Now, to deal with this we can


1072
00:30:37,046 --> 00:30:37,846
use METAL Events.


1073
00:30:39,116 --> 00:30:40,426
With METAL Events, we'll insert


1074
00:30:40,506 --> 00:30:41,956
a wait into the command buffer.


1075
00:30:43,066 --> 00:30:44,576
So, while the GPU is executing,


1076
00:30:44,646 --> 00:30:46,116
it'll reach the wait, and then


1077
00:30:46,116 --> 00:30:47,186
it's just going to stop.


1078
00:30:47,186 --> 00:30:50,096
And what it's waiting for is a


1079
00:30:50,096 --> 00:30:51,526
signal from the other GPU.


1080
00:30:51,976 --> 00:30:55,516
Once that signal is received we


1081
00:30:55,516 --> 00:30:56,936
know that GPU A has finished


1082
00:30:56,936 --> 00:30:58,376
writing to the buffer and it's


1083
00:30:58,376 --> 00:31:00,766
now safe for GPU B to access it.


1084
00:31:01,816 --> 00:31:04,096
So, this is an elegant way to


1085
00:31:04,096 --> 00:31:05,446
fix our synchronization problem.


1086
00:31:06,826 --> 00:31:08,696
But, clearly, having a GPU,


1087
00:31:08,856 --> 00:31:10,496
potentially, a very powerful GPU


1088
00:31:10,496 --> 00:31:11,936
just sitting there waiting is


1089
00:31:12,206 --> 00:31:12,746
not good.


1090
00:31:13,706 --> 00:31:15,106
So, we need to make this wait as


1091
00:31:15,106 --> 00:31:17,056
short as possible and, ideally,


1092
00:31:17,056 --> 00:31:18,626
we want the GPU working instead


1093
00:31:18,626 --> 00:31:19,006
of waiting.


1094
00:31:19,056 --> 00:31:21,726
So, what I'm talking about,


1095
00:31:21,776 --> 00:31:22,946
here, is load balancing.


1096
00:31:23,586 --> 00:31:25,916
So currently, we just split the


1097
00:31:25,916 --> 00:31:27,756
screen equally between GPUs.


1098
00:31:27,916 --> 00:31:29,126
And there's a couple of problems


1099
00:31:29,126 --> 00:31:29,526
with this.


1100
00:31:30,376 --> 00:31:31,846
Firstly, it doesn't take into


1101
00:31:31,846 --> 00:31:33,116
account that you might be using


1102
00:31:33,116 --> 00:31:34,466
GPUs of different performance.


1103
00:31:35,676 --> 00:31:37,276
If one GPU is much faster than


1104
00:31:37,276 --> 00:31:38,156
the other, then it stands to


1105
00:31:38,156 --> 00:31:39,206
reason that, yeah, it's going to


1106
00:31:39,206 --> 00:31:39,926
finish first.


1107
00:31:41,086 --> 00:31:43,386
And the other problem is that


1108
00:31:43,666 --> 00:31:44,696
some parts of the screen are


1109
00:31:44,696 --> 00:31:45,936
more complicated to render than


1110
00:31:45,936 --> 00:31:46,216
others.


1111
00:31:46,216 --> 00:31:46,766
They take longer.


1112
00:31:47,536 --> 00:31:48,586
They might have more complex


1113
00:31:48,586 --> 00:31:50,006
geometry or more complex


1114
00:31:50,006 --> 00:31:50,596
materials.


1115
00:31:52,316 --> 00:31:53,966
So, to fix this, we need to


1116
00:31:53,966 --> 00:31:55,246
adjust our region sizes


1117
00:31:55,246 --> 00:31:55,846
adaptively.


1118
00:31:56,866 --> 00:31:58,406
Now, the aim here is for each


1119
00:31:58,406 --> 00:32:00,056
GPU to take, approximately, the


1120
00:32:00,056 --> 00:32:01,796
same amount of time to render


1121
00:32:01,796 --> 00:32:04,176
its part of the scene.


1122
00:32:04,306 --> 00:32:05,736
Now, the way we do this is we


1123
00:32:05,736 --> 00:32:07,326
start with the fixed partitions


1124
00:32:07,326 --> 00:32:09,096
that you see here, and we render


1125
00:32:09,096 --> 00:32:09,426
a frame.


1126
00:32:09,716 --> 00:32:12,296
And we time how long each GPU is


1127
00:32:12,296 --> 00:32:12,956
working for.


1128
00:32:12,956 --> 00:32:14,836
And then, we use that to decide


1129
00:32:14,836 --> 00:32:16,166
how big a region to give each


1130
00:32:16,166 --> 00:32:17,236
GPU the next time around.


1131
00:32:17,366 --> 00:32:21,276
And we do this the whole time


1132
00:32:21,276 --> 00:32:22,246
your application is running.


1133
00:32:23,166 --> 00:32:24,756
So, it constantly adapts to the


1134
00:32:24,756 --> 00:32:26,036
performance of the GPUs that you


1135
00:32:26,036 --> 00:32:26,676
have connected.


1136
00:32:27,206 --> 00:32:28,686
And wherever you are and


1137
00:32:28,686 --> 00:32:29,596
wherever you're looking in your


1138
00:32:29,596 --> 00:32:29,886
scene.


1139
00:32:30,446 --> 00:32:34,876
So, to measure how hard a GPU is


1140
00:32:34,876 --> 00:32:36,346
working, we use command buffer


1141
00:32:36,346 --> 00:32:37,236
completion handlers.


1142
00:32:38,746 --> 00:32:40,426
Now, completion handler is a


1143
00:32:40,516 --> 00:32:42,206
block of CPU code that you can


1144
00:32:42,206 --> 00:32:43,686
have run after the GPU has


1145
00:32:43,686 --> 00:32:44,916
finished executing your command


1146
00:32:44,916 --> 00:32:45,146
buffer.


1147
00:32:46,826 --> 00:32:49,776
Now, on iOS command buffers have


1148
00:32:49,776 --> 00:32:50,986
a couple of useful properties


1149
00:32:50,986 --> 00:32:52,576
that you can read to find out


1150
00:32:52,576 --> 00:32:53,936
how long it took to run on the


1151
00:32:53,936 --> 00:32:54,266
GPU.


1152
00:32:55,616 --> 00:32:56,726
But these aren't available on


1153
00:32:56,726 --> 00:32:57,366
macOS.


1154
00:32:57,436 --> 00:32:58,616
So, we need to come up with an


1155
00:32:58,616 --> 00:32:59,276
approximation.


1156
00:32:59,456 --> 00:33:02,186
And the way we do this is we


1157
00:33:02,186 --> 00:33:03,846
store the host time when each


1158
00:33:03,846 --> 00:33:04,776
command buffer completion


1159
00:33:04,776 --> 00:33:05,456
handler was called.


1160
00:33:05,526 --> 00:33:07,366
And if you do this for every


1161
00:33:07,366 --> 00:33:09,256
command buffer, you can then use


1162
00:33:09,256 --> 00:33:10,346
the differences between these


1163
00:33:10,346 --> 00:33:11,456
times to figure out how long the


1164
00:33:11,456 --> 00:33:12,376
GPU was running for.


1165
00:33:13,416 --> 00:33:15,976
So, for example, to estimate how


1166
00:33:15,976 --> 00:33:17,106
long the three command buffers


1167
00:33:17,106 --> 00:33:19,096
shown here took execute, we've


1168
00:33:19,096 --> 00:33:20,266
measured the time between the


1169
00:33:20,266 --> 00:33:21,386
completion handler was called


1170
00:33:21,386 --> 00:33:23,356
for command buffer 3 and command


1171
00:33:23,356 --> 00:33:23,816
buffer 0.


1172
00:33:25,276 --> 00:33:27,996
So, that's the theory.


1173
00:33:28,286 --> 00:33:29,586
And now, let's see it in action.


1174
00:33:42,126 --> 00:33:42,326
All right.


1175
00:33:42,326 --> 00:33:43,436
So, this is the Amazon


1176
00:33:43,436 --> 00:33:44,836
Lumberyard Bistro scene that


1177
00:33:44,836 --> 00:33:46,586
Sean was showing you earlier.


1178
00:33:47,586 --> 00:33:48,776
And this time, it's running on a


1179
00:33:48,776 --> 00:33:49,456
MacBook Pro.


1180
00:33:49,456 --> 00:33:52,126
And you can see in the top left


1181
00:33:52,126 --> 00:33:53,176
of the screen here, we have a


1182
00:33:53,176 --> 00:33:54,376
rays per second metric.


1183
00:33:54,896 --> 00:33:56,176
As you can get an idea for how


1184
00:33:56,176 --> 00:33:56,566
it's running.


1185
00:33:57,156 --> 00:33:59,566
So, this includes the primary


1186
00:33:59,566 --> 00:34:01,266
rays, secondary rays, and the


1187
00:34:01,266 --> 00:34:01,756
shadow rays.


1188
00:34:01,756 --> 00:34:02,766
They're all included in this


1189
00:34:02,766 --> 00:34:03,166
metric.


1190
00:34:03,646 --> 00:34:05,396
So, you can see, we're getting


1191
00:34:05,396 --> 00:34:06,796
about 30 million rays per


1192
00:34:06,796 --> 00:34:07,226
second.


1193
00:34:07,376 --> 00:34:09,126
And it'd be nice if we were


1194
00:34:09,126 --> 00:34:10,456
going a little faster.


1195
00:34:10,505 --> 00:34:12,016
So, I'm going to enable one of


1196
00:34:12,016 --> 00:34:13,606
the eGPUs that I have connected,


1197
00:34:13,606 --> 00:34:13,755
here.


1198
00:34:13,886 --> 00:34:18,056
So, you can see from the text


1199
00:34:18,056 --> 00:34:19,206
there, we're now running on an


1200
00:34:19,206 --> 00:34:21,266
RX 580, as well as the internal


1201
00:34:21,266 --> 00:34:21,926
GPU, here.


1202
00:34:22,646 --> 00:34:24,045
And performance has doubled to


1203
00:34:24,045 --> 00:34:25,416
about 60 million rays per


1204
00:34:25,416 --> 00:34:25,806
second.


1205
00:34:26,846 --> 00:34:27,916
And you can also see the green


1206
00:34:27,916 --> 00:34:29,005
lines here that we're using to


1207
00:34:29,005 --> 00:34:30,366
help visualize how the load is


1208
00:34:30,366 --> 00:34:31,576
split between GPUs.


1209
00:34:32,196 --> 00:34:33,795
So, one GPU is rendering


1210
00:34:33,795 --> 00:34:34,886
everything above the line.


1211
00:34:35,176 --> 00:34:36,476
And one GPU is rendering


1212
00:34:36,476 --> 00:34:37,085
everything below.


1213
00:34:37,545 --> 00:34:39,996
So, with the eGPU we're now


1214
00:34:39,996 --> 00:34:41,585
going about twice as fast as we


1215
00:34:41,585 --> 00:34:42,156
were before.


1216
00:34:42,755 --> 00:34:44,906
I was kind of hoping for a bit


1217
00:34:44,906 --> 00:34:45,275
more, there.


1218
00:34:45,826 --> 00:34:47,835
And so, the problem is the eGPU


1219
00:34:47,835 --> 00:34:49,326
is sitting there waiting.


1220
00:34:50,136 --> 00:34:51,016
And that's because we're using


1221
00:34:51,016 --> 00:34:52,045
these fixed partitions.


1222
00:34:52,906 --> 00:34:54,545
So, if we switch on the adaptive


1223
00:34:54,545 --> 00:34:56,286
load balancing, here, you see


1224
00:34:56,366 --> 00:34:58,226
the RX 580 just grabs a big


1225
00:34:58,226 --> 00:34:59,096
chunk of the work, now.


1226
00:34:59,256 --> 00:35:00,676
And we're going much faster than


1227
00:35:00,676 --> 00:35:01,426
we were, previously.


1228
00:35:03,396 --> 00:35:05,626
So, the scene here has


1229
00:35:05,626 --> 00:35:06,606
approximately one million


1230
00:35:06,606 --> 00:35:07,266
triangles.


1231
00:35:07,266 --> 00:35:08,716
And we're now going to switch to


1232
00:35:09,026 --> 00:35:09,816
an outside view.


1233
00:35:09,816 --> 00:35:11,166
It's the same Amazon Lumberyard


1234
00:35:11,166 --> 00:35:13,016
scene but we're outside, now.


1235
00:35:13,336 --> 00:35:14,666
And this scene has approximately


1236
00:35:14,666 --> 00:35:16,306
3 million triangles.


1237
00:35:17,516 --> 00:35:19,516
And I have another GPU sitting


1238
00:35:19,516 --> 00:35:19,706
here.


1239
00:35:19,706 --> 00:35:20,696
So, we'll turn that one on, too.


1240
00:35:21,046 --> 00:35:24,016
And, this time, it's a Vega 64.


1241
00:35:24,356 --> 00:35:26,026
So, you see the Vega grabbing a


1242
00:35:26,116 --> 00:35:27,036
big chunk of the work, there.


1243
00:35:28,266 --> 00:35:30,006
And what's interesting about


1244
00:35:30,006 --> 00:35:31,296
this configuration is we have


1245
00:35:31,296 --> 00:35:32,766
three very different GPUs


1246
00:35:32,766 --> 00:35:33,396
working together.


1247
00:35:33,716 --> 00:35:34,966
They're different architectures


1248
00:35:35,576 --> 00:35:36,376
and they're very different


1249
00:35:36,376 --> 00:35:37,046
performance, too.


1250
00:35:37,046 --> 00:35:38,056
But they're all working together


1251
00:35:38,056 --> 00:35:39,416
to help produce this great


1252
00:35:39,886 --> 00:35:40,000
image.


1253
00:35:43,516 --> 00:35:48,500
[ Applause ]


1254
00:35:51,046 --> 00:35:52,666
So, today we introduced the


1255
00:35:52,666 --> 00:35:54,606
MPSRayIntersector, a new API


1256
00:35:54,606 --> 00:35:56,066
that you can use to accelerate


1257
00:35:56,066 --> 00:35:57,636
ray triangle intersections on


1258
00:35:57,636 --> 00:35:58,156
the GPU.


1259
00:35:58,276 --> 00:36:01,346
As you saw from my demos, it's


1260
00:36:01,346 --> 00:36:03,166
available on all of our iOS and


1261
00:36:03,166 --> 00:36:04,246
macOS platforms.


1262
00:36:04,676 --> 00:36:06,196
And it scales really well as you


1263
00:36:06,196 --> 00:36:09,426
add multiple GPUs on macOS.


1264
00:36:09,786 --> 00:36:11,386
Now, we're really excited to see


1265
00:36:11,386 --> 00:36:12,726
how you use Ray Tracing in your


1266
00:36:12,726 --> 00:36:13,466
applications.


1267
00:36:14,126 --> 00:36:15,936
We used Path Tracing in our


1268
00:36:15,936 --> 00:36:16,636
example, today.


1269
00:36:17,116 --> 00:36:18,216
But there's also hybrid


1270
00:36:18,216 --> 00:36:18,576
rendering.


1271
00:36:18,816 --> 00:36:20,316
You might want to incorporate


1272
00:36:20,316 --> 00:36:21,576
Ray Tracing to do really nice


1273
00:36:21,576 --> 00:36:22,966
looking shadows or ambient


1274
00:36:22,966 --> 00:36:24,246
occlusion or reflections.


1275
00:36:25,176 --> 00:36:26,566
And there's also non-rendering


1276
00:36:26,566 --> 00:36:27,346
in cases.


1277
00:36:27,456 --> 00:36:29,056
For example, autosimulation,


1278
00:36:29,056 --> 00:36:30,846
physics, AI collisionless


1279
00:36:30,846 --> 00:36:31,196
action.


1280
00:36:31,196 --> 00:36:32,246
There's a ton of stuff you can


1281
00:36:32,246 --> 00:36:33,226
do with this.


1282
00:36:34,916 --> 00:36:37,156
So, to help you get started you


1283
00:36:38,626 --> 00:36:40,236
can find sample code on


1284
00:36:40,236 --> 00:36:41,596
developer.apple.com.


1285
00:36:41,596 --> 00:36:42,896
So, be sure to check that out.


1286
00:36:43,476 --> 00:36:45,086
Also, the header files are full


1287
00:36:45,086 --> 00:36:47,476
of documentation and information


1288
00:36:47,476 --> 00:36:48,966
on some additional features that


1289
00:36:48,966 --> 00:36:50,036
we weren't able to cover today.


1290
00:36:51,326 --> 00:36:52,696
And finally, we have our lab


1291
00:36:52,696 --> 00:36:53,786
session tomorrow from 12.


1292
00:36:53,956 --> 00:36:55,736
Sean and I will be on hand to


1293
00:36:55,736 --> 00:36:57,436
talk more about the API and to


1294
00:36:57,656 --> 00:36:58,796
help you get started with Ray


1295
00:36:58,796 --> 00:37:00,086
Tracing in your application.


1296
00:37:00,086 --> 00:37:01,456
So, we hope you can join us for


1297
00:37:02,656 --> 00:37:03,266
that.


1298
00:37:03,266 --> 00:37:04,336
So, thank you, for coming to our


1299
00:37:04,336 --> 00:37:04,646
talk.


1300
00:37:04,646 --> 00:37:06,796
And enjoy the rest of WWDC.


1301
00:37:07,516 --> 00:37:12,506
[ Applause ]

