1
00:00:07,516 --> 00:00:15,516
[ Music ]


2
00:00:16,516 --> 00:00:21,576
[ Applause ]


3
00:00:22,076 --> 00:00:22,436
>> Good morning.


4
00:00:24,016 --> 00:00:25,346
My name is Michael LeHew, and I


5
00:00:25,346 --> 00:00:26,436
worked on the collections for


6
00:00:26,436 --> 00:00:27,726
the foundations team at Apple.


7
00:00:27,726 --> 00:00:30,876
And today, I want to talk about


8
00:00:30,876 --> 00:00:31,946
specific things that you should


9
00:00:31,946 --> 00:00:33,036
know about to ensure that your


10
00:00:33,036 --> 00:00:34,526
use of collections in Swift is


11
00:00:34,526 --> 00:00:35,656
as effective as possible.


12
00:00:36,156 --> 00:00:38,276
I'm going to cover a lot of


13
00:00:38,276 --> 00:00:39,856
territory today about details


14
00:00:39,926 --> 00:00:42,046
and all aspects of collections


15
00:00:42,046 --> 00:00:43,136
available for use in Swift.


16
00:00:43,416 --> 00:00:44,596
We're going to explore some


17
00:00:44,646 --> 00:00:46,616
common pitfalls and how to avoid


18
00:00:46,616 --> 00:00:47,506
them including performance


19
00:00:47,506 --> 00:00:48,756
issues, and I'm also going to


20
00:00:48,756 --> 00:00:50,676
offer very specific advice about


21
00:00:50,676 --> 00:00:51,936
when to choose to use specific


22
00:00:51,936 --> 00:00:52,366
collections.


23
00:00:53,306 --> 00:00:53,996
So let's begin.


24
00:00:54,136 --> 00:00:57,336
I want you to imagine a world, a


25
00:00:57,696 --> 00:00:59,176
world without collections.


26
00:00:59,846 --> 00:01:03,146
And in this world, we may not


27
00:01:03,146 --> 00:01:04,816
have arrays, but it still has


28
00:01:04,926 --> 00:01:07,796
bears, but every time we need


29
00:01:07,796 --> 00:01:10,136
another bear, we're going to


30
00:01:10,136 --> 00:01:11,436
need to define another variable,


31
00:01:12,026 --> 00:01:13,296
and we want to do things with


32
00:01:13,296 --> 00:01:13,726
these bears.


33
00:01:13,726 --> 00:01:14,666
We're going to need to repeat


34
00:01:14,666 --> 00:01:15,266
ourselves.


35
00:01:16,306 --> 00:01:17,106
Pretty scary, right?


36
00:01:18,546 --> 00:01:19,236
It gets worse though.


37
00:01:19,236 --> 00:01:20,596
This world also doesn't have


38
00:01:20,636 --> 00:01:23,196
dictionaries, but thankfully


39
00:01:23,336 --> 00:01:25,016
being clever developers, we can


40
00:01:25,016 --> 00:01:25,766
work around that with the


41
00:01:25,766 --> 00:01:27,936
function, where we painstakingly


42
00:01:27,936 --> 00:01:29,246
define each case that we care


43
00:01:29,246 --> 00:01:31,586
about, and using this function


44
00:01:31,586 --> 00:01:32,546
is very similar to using a


45
00:01:32,546 --> 00:01:34,716
dictionary, except none of those


46
00:01:34,716 --> 00:01:35,926
dynamic capabilities that we


47
00:01:35,926 --> 00:01:36,136
need.


48
00:01:36,666 --> 00:01:37,676
But who likes a mutable state,


49
00:01:37,676 --> 00:01:37,906
right?


50
00:01:38,976 --> 00:01:40,536
Fortunately for us though, we


51
00:01:40,536 --> 00:01:41,356
don't live in this world.


52
00:01:42,146 --> 00:01:43,816
Thankfully our world has bears


53
00:01:43,946 --> 00:01:45,586
and collections along with a


54
00:01:45,646 --> 00:01:47,016
rich first-class syntax for


55
00:01:47,016 --> 00:01:47,546
defining them.


56
00:01:48,076 --> 00:01:51,086
And APIs that help us not repeat


57
00:01:51,086 --> 00:01:53,666
ourselves when we iterate or


58
00:01:53,926 --> 00:01:55,316
retrieve the elements that they


59
00:01:55,316 --> 00:01:55,886
may store.


60
00:01:57,336 --> 00:01:58,916
Collections are so pervasive and


61
00:01:58,916 --> 00:02:00,506
share so many common features


62
00:02:00,506 --> 00:02:01,686
and algorithms that in Swift


63
00:02:01,686 --> 00:02:03,036
they all conform to a common


64
00:02:03,036 --> 00:02:03,476
protocol.


65
00:02:04,036 --> 00:02:06,446
Not surprisingly, it's called


66
00:02:06,446 --> 00:02:06,876
collection.


67
00:02:06,876 --> 00:02:09,186
And in Swift, collections are


68
00:02:09,186 --> 00:02:10,675
sequences whose elements can be


69
00:02:10,675 --> 00:02:12,196
traversed multiple times,


70
00:02:12,426 --> 00:02:13,806
nondestructively, and whose


71
00:02:13,806 --> 00:02:15,106
elements can be accessed via a


72
00:02:15,106 --> 00:02:15,606
subscript.


73
00:02:17,576 --> 00:02:19,106
Let's see, look at how they do


74
00:02:19,106 --> 00:02:20,446
that but considering an abstract


75
00:02:20,446 --> 00:02:21,736
representation of a collection.


76
00:02:23,026 --> 00:02:24,456
This could be an array defined


77
00:02:24,456 --> 00:02:26,006
contiguously in memory, a hash


78
00:02:26,076 --> 00:02:29,246
table, a red black tree, a link


79
00:02:29,246 --> 00:02:30,266
list or anything else that you


80
00:02:30,266 --> 00:02:30,776
can imagine.


81
00:02:31,516 --> 00:02:32,636
What matters is that it supports


82
00:02:32,636 --> 00:02:34,296
the concept of an initial index


83
00:02:34,296 --> 00:02:35,386
called start index.


84
00:02:36,796 --> 00:02:38,426
It can be used to access the


85
00:02:38,426 --> 00:02:39,306
initial element of the


86
00:02:39,306 --> 00:02:39,806
collection.


87
00:02:40,556 --> 00:02:41,736
It has an end index, which


88
00:02:41,736 --> 00:02:42,646
identifies the end of the


89
00:02:42,646 --> 00:02:44,746
collection, and collections


90
00:02:44,746 --> 00:02:46,166
support the ability to iterate


91
00:02:46,166 --> 00:02:47,546
from their start index to their


92
00:02:47,546 --> 00:02:48,286
end index.


93
00:02:49,476 --> 00:02:51,056
They can do this multiple times,


94
00:02:51,426 --> 00:02:52,396
and they also support a


95
00:02:52,396 --> 00:02:54,646
subscript to retrieve elements


96
00:02:54,676 --> 00:02:55,876
from the collection itself.


97
00:02:56,456 --> 00:02:58,336
Let's see what this looks like


98
00:02:58,336 --> 00:02:58,746
in code.


99
00:02:59,736 --> 00:03:00,606
Indeed, if we look at the


100
00:03:00,606 --> 00:03:02,326
definition of collection, it's


101
00:03:02,326 --> 00:03:03,256
declared as a sequence of


102
00:03:03,256 --> 00:03:03,716
elements.


103
00:03:04,836 --> 00:03:05,916
It also has an additional


104
00:03:05,916 --> 00:03:07,736
associated type called index,


105
00:03:07,836 --> 00:03:08,936
which must be comparable.


106
00:03:10,216 --> 00:03:11,656
It offers a subscript to


107
00:03:11,656 --> 00:03:13,316
retrieve elements from, or using


108
00:03:13,316 --> 00:03:15,196
that index, and we define a


109
00:03:15,196 --> 00:03:16,306
start and an end index


110
00:03:16,456 --> 00:03:18,076
identifying the bounds of our


111
00:03:18,076 --> 00:03:18,576
collection.


112
00:03:18,926 --> 00:03:21,076
And finally, we have a function


113
00:03:21,136 --> 00:03:22,766
called index after, which lets


114
00:03:22,766 --> 00:03:24,366
us get from one index to


115
00:03:24,366 --> 00:03:24,656
another.


116
00:03:24,706 --> 00:03:27,096
And this last function is so


117
00:03:27,096 --> 00:03:28,656
important because it allows the


118
00:03:28,656 --> 00:03:30,756
standard library to define many


119
00:03:30,756 --> 00:03:32,136
useful and powerful default


120
00:03:32,136 --> 00:03:33,596
behaviors with the incredible


121
00:03:33,596 --> 00:03:35,006
power of protocol extensions.


122
00:03:35,476 --> 00:03:38,266
Let's look at some of these.


123
00:03:38,426 --> 00:03:39,956
When you conform to collection,


124
00:03:39,956 --> 00:03:41,566
you gain access to an incredible


125
00:03:41,566 --> 00:03:42,916
range of functionality with


126
00:03:42,916 --> 00:03:44,966
properties that let you get the


127
00:03:44,966 --> 00:03:46,296
first and the last element or


128
00:03:46,426 --> 00:03:48,636
identify the count or check to


129
00:03:48,636 --> 00:03:49,706
see if a collection is empty.


130
00:03:50,466 --> 00:03:51,626
You also gain API that lets you


131
00:03:51,626 --> 00:03:52,676
iterate through a Collection


132
00:03:52,776 --> 00:03:54,216
using 4N syntax.


133
00:03:55,216 --> 00:03:56,886
And super useful functions like


134
00:03:56,886 --> 00:03:58,226
map, filter, and reduce.


135
00:03:59,256 --> 00:03:59,976
Now let's go ahead and make


136
00:03:59,976 --> 00:04:01,356
Collection even more powerful by


137
00:04:01,356 --> 00:04:02,426
adding our own extension.


138
00:04:03,736 --> 00:04:05,026
Collection already provides a


139
00:04:05,026 --> 00:04:06,236
way to iterate through every


140
00:04:06,236 --> 00:04:08,786
element, but I want a function


141
00:04:08,786 --> 00:04:09,646
that will let me iterate through


142
00:04:09,646 --> 00:04:11,066
every other element, skipping


143
00:04:11,066 --> 00:04:12,266
some of the values along the way


144
00:04:13,496 --> 00:04:14,616
and will do this by adding an


145
00:04:14,616 --> 00:04:15,626
extension to Collection.


146
00:04:16,036 --> 00:04:16,935
Let's start with the methods


147
00:04:16,935 --> 00:04:17,375
signature.


148
00:04:18,136 --> 00:04:19,136
We're going to call our function


149
00:04:19,266 --> 00:04:20,305
every other, and it's going to


150
00:04:20,305 --> 00:04:21,555
take a closure that will call on


151
00:04:21,555 --> 00:04:23,126
each element that we care about.


152
00:04:24,126 --> 00:04:25,016
We'll get the bounds of our


153
00:04:25,016 --> 00:04:27,486
iteration, and to find another


154
00:04:27,486 --> 00:04:29,236
variable, that starts at the


155
00:04:29,236 --> 00:04:30,326
start, which will mutate along


156
00:04:30,326 --> 00:04:30,826
as we go.


157
00:04:32,106 --> 00:04:33,506
We'll call the closure on the


158
00:04:33,506 --> 00:04:36,016
current element and advance our


159
00:04:36,016 --> 00:04:37,266
current index to the next one.


160
00:04:37,866 --> 00:04:39,076
And we may have invalidated our


161
00:04:39,076 --> 00:04:40,086
index at this point, we may have


162
00:04:40,086 --> 00:04:40,576
reached the end of the


163
00:04:40,576 --> 00:04:41,536
collection, so we need to make


164
00:04:41,536 --> 00:04:43,626
sure that we did that, and if we


165
00:04:43,626 --> 00:04:44,906
did, we can then advance our


166
00:04:44,906 --> 00:04:46,716
index one more time and thus


167
00:04:46,716 --> 00:04:47,886
skip every other element.


168
00:04:48,326 --> 00:04:49,726
And if we call this we see, if


169
00:04:49,726 --> 00:04:50,976
we call this on the close range


170
00:04:51,136 --> 00:04:53,066
from one to ten, we see that we


171
00:04:53,066 --> 00:04:54,236
skip the even elements.


172
00:04:54,646 --> 00:04:56,926
And so we see that Collections


173
00:04:56,926 --> 00:04:58,236
let us describe some really


174
00:04:58,236 --> 00:05:00,616
powerful behavior, but it turns


175
00:05:00,616 --> 00:05:02,216
out collections aren't alone.


176
00:05:02,296 --> 00:05:03,136
In fact, Collection is not the


177
00:05:03,136 --> 00:05:04,086
only protocol that we have.


178
00:05:04,086 --> 00:05:05,526
In Swift, we have access to a


179
00:05:05,636 --> 00:05:07,286
rich hierarchy of collection


180
00:05:07,286 --> 00:05:08,356
protocols, each greatly


181
00:05:08,356 --> 00:05:09,286
improving on the kinds of


182
00:05:09,286 --> 00:05:10,276
assumptions that we can make


183
00:05:10,276 --> 00:05:11,076
about our types.


184
00:05:11,706 --> 00:05:12,576
Let's go ahead and talk about a


185
00:05:12,576 --> 00:05:13,226
couple of these.


186
00:05:13,546 --> 00:05:15,896
We've already established that


187
00:05:15,896 --> 00:05:17,356
Collection lets you go forward


188
00:05:17,356 --> 00:05:19,866
from a given index, but there


189
00:05:19,866 --> 00:05:20,886
are also bidirectional


190
00:05:20,886 --> 00:05:22,406
collections, which let you go in


191
00:05:22,406 --> 00:05:24,826
the other direction.


192
00:05:24,896 --> 00:05:26,086
Now, of course, bidirectional


193
00:05:26,086 --> 00:05:27,196
collections are collections


194
00:05:27,246 --> 00:05:28,636
themselves, and so we can still


195
00:05:28,636 --> 00:05:29,726
iterate forward as well.


196
00:05:31,336 --> 00:05:32,836
The next most flexible form of


197
00:05:32,836 --> 00:05:34,086
collection is what's known as a


198
00:05:34,086 --> 00:05:35,506
random access collection, and


199
00:05:35,506 --> 00:05:36,926
with these, these add the


200
00:05:36,926 --> 00:05:38,266
requirement that it would be


201
00:05:38,266 --> 00:05:40,386
constant time to compute, or


202
00:05:40,386 --> 00:05:41,646
compute another index from


203
00:05:41,646 --> 00:05:42,606
another or to compute the


204
00:05:42,606 --> 00:05:43,886
distance between two indexes.


205
00:05:44,456 --> 00:05:45,856
The compiler cannot enforce


206
00:05:45,926 --> 00:05:47,486
this, and so when you conform to


207
00:05:47,486 --> 00:05:48,466
random acts as a collection,


208
00:05:48,646 --> 00:05:49,756
you're making a promise.


209
00:05:49,996 --> 00:05:51,796
But if you satisfy this promise,


210
00:05:51,796 --> 00:05:52,516
if you can deliver on this


211
00:05:52,516 --> 00:05:53,806
promise, the protocol gives you


212
00:05:53,806 --> 00:05:55,386
the power to access any index in


213
00:05:55,386 --> 00:05:57,186
the collection in constant time.


214
00:05:57,966 --> 00:05:59,046
And of course, random access


215
00:05:59,046 --> 00:06:00,426
collections remain collections,


216
00:06:00,426 --> 00:06:01,316
and so you can still iterate


217
00:06:01,316 --> 00:06:02,536
forward and backward.


218
00:06:02,606 --> 00:06:05,796
Now as Swift developers, we have


219
00:06:05,796 --> 00:06:06,896
access to many useful


220
00:06:06,896 --> 00:06:08,046
collections that conform to


221
00:06:08,046 --> 00:06:10,626
these protocols, collections


222
00:06:10,626 --> 00:06:11,666
such as array, set, and


223
00:06:11,666 --> 00:06:12,186
dictionary.


224
00:06:12,656 --> 00:06:14,836
But thanks to the general


225
00:06:14,836 --> 00:06:15,746
purpose utility of these


226
00:06:15,746 --> 00:06:17,006
protocols, many other types


227
00:06:17,196 --> 00:06:18,696
conform to these collection


228
00:06:18,696 --> 00:06:20,186
protocols as well, such as data,


229
00:06:20,476 --> 00:06:21,416
range, and string.


230
00:06:22,566 --> 00:06:24,356
Or the index collections, and


231
00:06:24,356 --> 00:06:25,546
they all gain access to all of


232
00:06:25,546 --> 00:06:26,816
this rich functionality by


233
00:06:26,816 --> 00:06:28,216
simply conforming to Collection


234
00:06:28,216 --> 00:06:29,036
in their own fashion.


235
00:06:29,346 --> 00:06:31,006
Indeed, once you know how any


236
00:06:31,006 --> 00:06:32,246
one of these types works, you


237
00:06:32,246 --> 00:06:33,616
can apply that knowledge to any


238
00:06:33,616 --> 00:06:35,326
of the others, and there are


239
00:06:35,326 --> 00:06:35,886
quite a few.


240
00:06:35,916 --> 00:06:38,006
So I'm going to talk about the


241
00:06:38,006 --> 00:06:39,586
details about how a type


242
00:06:39,586 --> 00:06:41,166
conforms to Collection, and it


243
00:06:41,166 --> 00:06:43,456
all begins with describing how


244
00:06:43,666 --> 00:06:46,376
it is indexed.


245
00:06:46,446 --> 00:06:47,746
Each collection has its own kind


246
00:06:47,746 --> 00:06:48,336
of index.


247
00:06:48,856 --> 00:06:50,766
And that index must be


248
00:06:50,766 --> 00:06:51,306
comparable.


249
00:06:52,286 --> 00:06:54,306
In some cases, the indices can


250
00:06:54,306 --> 00:06:56,446
look like integers, like arrays,


251
00:06:56,716 --> 00:06:57,566
but just because an index


252
00:06:57,566 --> 00:06:58,736
happens to look like an integer


253
00:06:58,896 --> 00:06:59,956
doesn't mean that you should use


254
00:06:59,956 --> 00:07:00,456
it like one.


255
00:07:01,436 --> 00:07:02,186
Now I want to ask a few


256
00:07:02,186 --> 00:07:03,396
questions that might have


257
00:07:03,396 --> 00:07:04,386
surprising answers.


258
00:07:05,056 --> 00:07:06,116
The first is how do we get the


259
00:07:06,116 --> 00:07:08,926
first element of an array, and


260
00:07:08,996 --> 00:07:10,496
instantly you probably all


261
00:07:10,566 --> 00:07:11,786
thought, well I'll just call


262
00:07:11,786 --> 00:07:12,456
array subzero.


263
00:07:12,526 --> 00:07:14,196
An array's index happens to be


264
00:07:14,196 --> 00:07:14,386
it.


265
00:07:14,766 --> 00:07:16,236
So you can sometimes say this


266
00:07:16,366 --> 00:07:17,586
and get exactly what you intend.


267
00:07:18,036 --> 00:07:19,106
But it isn't the best way to do


268
00:07:19,106 --> 00:07:19,446
this.


269
00:07:19,636 --> 00:07:20,636
I'm going to go ahead and ask


270
00:07:20,676 --> 00:07:22,026
the same question, but this time


271
00:07:22,196 --> 00:07:23,166
about a different collection.


272
00:07:23,666 --> 00:07:26,056
What's the first element of a


273
00:07:26,056 --> 00:07:26,246
set?


274
00:07:26,986 --> 00:07:27,856
Now this might seem like a


275
00:07:27,856 --> 00:07:29,276
really weird question, right?


276
00:07:29,576 --> 00:07:30,356
Sets are unordered.


277
00:07:31,016 --> 00:07:32,236
However, they are collections,


278
00:07:32,376 --> 00:07:33,286
and being collections, you can


279
00:07:33,286 --> 00:07:34,706
iterate through them, and when


280
00:07:34,706 --> 00:07:35,576
you iterate through a set,


281
00:07:35,636 --> 00:07:36,886
you're going to iterate through


282
00:07:36,886 --> 00:07:38,156
one element first, and so that's


283
00:07:38,156 --> 00:07:39,326
really the question we're asking


284
00:07:39,396 --> 00:07:39,586
here.


285
00:07:40,896 --> 00:07:42,026
So can I say set subzero?


286
00:07:42,856 --> 00:07:44,306
Happily, the compiler will say


287
00:07:44,306 --> 00:07:46,986
no, and that's because set's


288
00:07:46,986 --> 00:07:49,346
index type is an int, the type


289
00:07:49,346 --> 00:07:50,446
system wants us to use the


290
00:07:50,446 --> 00:07:52,816
correct index type.


291
00:07:52,996 --> 00:07:54,016
Lucky for us we already know how


292
00:07:54,016 --> 00:07:54,486
to do that.


293
00:07:54,796 --> 00:07:55,796
We know the collection protocol


294
00:07:55,796 --> 00:07:56,856
tells us that all collections


295
00:07:56,856 --> 00:07:58,266
have a start index, so let's go


296
00:07:58,266 --> 00:07:59,286
ahead and use that, and if we do


297
00:07:59,286 --> 00:08:00,496
this, this will actually work


298
00:08:00,496 --> 00:08:01,326
with all collections.


299
00:08:01,496 --> 00:08:03,076
Start index is always going to


300
00:08:03,076 --> 00:08:05,246
be the element of the first item


301
00:08:05,246 --> 00:08:05,966
that you would see when you


302
00:08:05,966 --> 00:08:06,336
iterate.


303
00:08:06,986 --> 00:08:08,056
But there's a nuance to watch


304
00:08:08,056 --> 00:08:09,626
out for when using indices to


305
00:08:09,626 --> 00:08:10,896
directly subscript into any


306
00:08:10,896 --> 00:08:11,356
collection.


307
00:08:11,636 --> 00:08:14,966
And that is, it can crash.


308
00:08:15,216 --> 00:08:17,146
I haven't actually asserted that


309
00:08:17,146 --> 00:08:18,356
these collections have contents


310
00:08:18,356 --> 00:08:20,056
in them, and so when you're, I'm


311
00:08:20,216 --> 00:08:21,276
just using start index, and


312
00:08:21,276 --> 00:08:22,126
these collections could be


313
00:08:22,126 --> 00:08:22,426
empty.


314
00:08:23,636 --> 00:08:24,416
It turns out though that


315
00:08:24,416 --> 00:08:25,616
accessing the first element in a


316
00:08:25,616 --> 00:08:27,996
collection is such a common task


317
00:08:28,206 --> 00:08:30,866
that there's an even better way.


318
00:08:31,076 --> 00:08:32,236
Simply call first.


319
00:08:32,885 --> 00:08:34,346
And if you call first, this is a


320
00:08:34,346 --> 00:08:35,756
lot safer, because the return


321
00:08:35,756 --> 00:08:37,056
time of this is optional,


322
00:08:37,326 --> 00:08:38,676
reflecting the fact that not all


323
00:08:38,676 --> 00:08:39,606
collections have a first


324
00:08:39,606 --> 00:08:39,956
element.


325
00:08:39,956 --> 00:08:43,285
So I have another question.


326
00:08:44,526 --> 00:08:45,696
It's the second element of a


327
00:08:45,696 --> 00:08:46,796
collection, and I want to


328
00:08:46,796 --> 00:08:48,116
emphasize collection here.


329
00:08:48,306 --> 00:08:49,606
It could be any collection, an


330
00:08:49,606 --> 00:08:50,626
array, a set, or something that


331
00:08:50,626 --> 00:08:51,626
doesn't even exist yet.


332
00:08:52,026 --> 00:08:53,796
Let's go ahead and add a new


333
00:08:53,876 --> 00:08:55,106
property to collection via


334
00:08:55,106 --> 00:08:55,976
protocol extension, and we'll


335
00:08:55,976 --> 00:08:57,566
call it second, and just like


336
00:08:57,636 --> 00:08:58,436
first, it's going to return


337
00:08:58,436 --> 00:08:59,556
optional, because not all


338
00:08:59,556 --> 00:09:00,936
collections have two elements.


339
00:09:02,216 --> 00:09:05,806
So, let's try writing this by


340
00:09:05,806 --> 00:09:06,496
subscripting 1.


341
00:09:06,846 --> 00:09:08,636
But here our zero-based indexing


342
00:09:08,636 --> 00:09:09,596
instincts are going to lead us


343
00:09:09,596 --> 00:09:11,056
astray, and then we'll be caught


344
00:09:11,056 --> 00:09:12,716
by the compiler again.


345
00:09:13,596 --> 00:09:14,906
We want this code to work with


346
00:09:14,906 --> 00:09:16,366
every collection, and not all


347
00:09:16,366 --> 00:09:17,636
collections use integers to


348
00:09:17,636 --> 00:09:18,156
index.


349
00:09:18,636 --> 00:09:19,946
So let's try a different


350
00:09:19,946 --> 00:09:20,336
approach.


351
00:09:21,226 --> 00:09:22,456
What I really want is one


352
00:09:22,456 --> 00:09:24,526
greater than the start index.


353
00:09:25,396 --> 00:09:26,806
But lucky here, the compiler


354
00:09:26,806 --> 00:09:27,886
will catch this as well.


355
00:09:29,126 --> 00:09:30,956
You can't add 1 to an arbitrary


356
00:09:30,956 --> 00:09:31,496
index type.


357
00:09:31,666 --> 00:09:32,826
Index types are supposed to be


358
00:09:32,826 --> 00:09:34,056
opaque or can be opaque.


359
00:09:34,056 --> 00:09:36,496
And what we really need to be


360
00:09:36,496 --> 00:09:37,836
doing here is we need to be


361
00:09:37,836 --> 00:09:38,826
using the API provided by the


362
00:09:38,826 --> 00:09:40,126
collection protocol to do this.


363
00:09:40,126 --> 00:09:41,456
So let's go ahead and do this.


364
00:09:42,746 --> 00:09:44,626
I commented out a sketch of the


365
00:09:44,626 --> 00:09:45,436
things that we're going to need


366
00:09:45,436 --> 00:09:46,216
to do to find the second


367
00:09:46,216 --> 00:09:46,596
element.


368
00:09:47,246 --> 00:09:48,066
The very first thing that we


369
00:09:48,066 --> 00:09:48,966
need to do is we need to check


370
00:09:48,966 --> 00:09:49,866
to see if the collection is


371
00:09:49,906 --> 00:09:50,226
empty.


372
00:09:51,076 --> 00:09:52,056
Collections are empty when their


373
00:09:52,056 --> 00:09:53,236
start index is exactly


374
00:09:53,236 --> 00:09:54,616
equivalent to their end index.


375
00:09:54,906 --> 00:09:56,106
So let's check for that and


376
00:09:56,106 --> 00:09:57,796
return nil, because such a


377
00:09:57,796 --> 00:10:00,536
collection doesn't have a second


378
00:10:00,536 --> 00:10:00,866
element.


379
00:10:01,486 --> 00:10:04,166
Oh, and so now we can assume


380
00:10:04,166 --> 00:10:05,486
that our collection has one


381
00:10:05,486 --> 00:10:06,156
element in it.


382
00:10:06,596 --> 00:10:09,356
We can use index after to get


383
00:10:09,356 --> 00:10:10,666
the second element or the second


384
00:10:10,666 --> 00:10:12,316
index, but we need to make sure


385
00:10:12,316 --> 00:10:14,286
that that index is valid, and


386
00:10:14,286 --> 00:10:15,206
let's see this visually.


387
00:10:15,326 --> 00:10:16,506
We advance after, but if the


388
00:10:16,506 --> 00:10:17,646
collection only had one element


389
00:10:17,646 --> 00:10:18,856
in it, we have now actually


390
00:10:18,856 --> 00:10:19,966
produced an invalid index, and


391
00:10:19,966 --> 00:10:20,886
if we tried to subscript with


392
00:10:20,886 --> 00:10:22,076
that index, we'd get that fatal


393
00:10:22,076 --> 00:10:23,056
error that we saw just a moment


394
00:10:23,056 --> 00:10:23,246
ago.


395
00:10:23,696 --> 00:10:24,786
So we check for it to be valid,


396
00:10:24,786 --> 00:10:25,796
and this is very similar to the


397
00:10:25,796 --> 00:10:26,066
empty [inaudible].


398
00:10:26,296 --> 00:10:27,756
We just make sure that our index


399
00:10:28,096 --> 00:10:29,376
is not equal to the end index


400
00:10:29,516 --> 00:10:30,096
returning nil.


401
00:10:30,626 --> 00:10:31,786
Again, because two-element


402
00:10:31,786 --> 00:10:33,276
collections don't have a, or


403
00:10:33,276 --> 00:10:34,336
one-element collections don't


404
00:10:34,336 --> 00:10:35,196
have a second element.


405
00:10:35,996 --> 00:10:36,956
At this point, we have all the


406
00:10:36,956 --> 00:10:38,296
assumptions we need to know that


407
00:10:38,296 --> 00:10:39,386
our collection has at least two


408
00:10:39,386 --> 00:10:40,746
elements in it, and so we're


409
00:10:40,746 --> 00:10:41,696
safe to use the subscript


410
00:10:41,696 --> 00:10:42,696
operator with that index,


411
00:10:43,906 --> 00:10:44,856
retrieving the value that we


412
00:10:44,856 --> 00:10:45,236
desire.


413
00:10:45,236 --> 00:10:48,736
Now, it turns out, or that looks


414
00:10:48,736 --> 00:10:50,436
like a lot of code, but it's


415
00:10:50,506 --> 00:10:51,576
worth pointing out that this


416
00:10:51,576 --> 00:10:53,016
general purpose index math will


417
00:10:53,016 --> 00:10:54,546
work with any collection, which


418
00:10:54,546 --> 00:10:56,266
is pretty awesome, and it turns


419
00:10:56,266 --> 00:10:57,786
out Swift has a better way to do


420
00:10:57,786 --> 00:10:58,106
this though.


421
00:10:58,856 --> 00:11:00,216
There's something called slices,


422
00:11:00,606 --> 00:11:01,716
but before I show how to do it


423
00:11:01,756 --> 00:11:02,946
with slices, I want to talk


424
00:11:02,946 --> 00:11:04,826
about what slices are and how


425
00:11:04,826 --> 00:11:05,000
they work.


426
00:11:08,266 --> 00:11:10,946
Slices are a type that describe


427
00:11:10,946 --> 00:11:11,946
only part of a collection.


428
00:11:13,176 --> 00:11:14,476
And every slice has their own


429
00:11:14,476 --> 00:11:17,606
start and end index, and slices


430
00:11:17,606 --> 00:11:18,556
exist separately from the


431
00:11:18,556 --> 00:11:19,956
collections, from their


432
00:11:19,986 --> 00:11:20,916
originating collection.


433
00:11:21,336 --> 00:11:22,526
And what makes slices so


434
00:11:22,526 --> 00:11:23,746
efficient is they occupy no


435
00:11:23,746 --> 00:11:24,406
extra storage.


436
00:11:24,536 --> 00:11:25,806
They simply refer back to the


437
00:11:25,806 --> 00:11:28,856
original collection, and when


438
00:11:28,856 --> 00:11:30,416
slices are subscripted, they


439
00:11:30,416 --> 00:11:31,586
read out of the original buffer.


440
00:11:32,806 --> 00:11:33,736
And they can do this because


441
00:11:34,796 --> 00:11:36,046
they share the same indices as


442
00:11:36,046 --> 00:11:37,016
their underlying collection.


443
00:11:37,466 --> 00:11:38,286
And let's take a look at how


444
00:11:38,286 --> 00:11:38,706
that works.


445
00:11:38,706 --> 00:11:39,806
We can prove this to ourselves.


446
00:11:40,136 --> 00:11:41,976
We'll start with an array, and


447
00:11:41,976 --> 00:11:43,296
we'll ask that array to drop its


448
00:11:43,296 --> 00:11:45,356
first element, producing a slice


449
00:11:45,386 --> 00:11:46,286
that's one element shorter.


450
00:11:46,636 --> 00:11:47,916
And because we care about


451
00:11:48,116 --> 00:11:49,546
proving about the indices, we'll


452
00:11:49,546 --> 00:11:50,926
actually get the second index of


453
00:11:50,926 --> 00:11:52,836
the array by asking to advance


454
00:11:53,046 --> 00:11:54,576
one after the start index, and


455
00:11:54,576 --> 00:11:55,426
then we'll compare those.


456
00:11:55,466 --> 00:11:58,446
And indeed, they are the same.


457
00:11:58,546 --> 00:11:59,696
Now this dropfirst function


458
00:11:59,696 --> 00:12:00,836
looks exactly like we need to


459
00:12:00,836 --> 00:12:01,836
succinctly get the second


460
00:12:01,836 --> 00:12:02,816
element of our collection.


461
00:12:03,796 --> 00:12:04,816
So let's go back to our previous


462
00:12:04,816 --> 00:12:05,806
solution, and see how much more


463
00:12:05,806 --> 00:12:06,616
expressive we can be with


464
00:12:06,616 --> 00:12:07,146
slices.


465
00:12:08,396 --> 00:12:10,536
Remember all that fancy index


466
00:12:10,536 --> 00:12:11,166
[inaudible] code we had to write


467
00:12:11,166 --> 00:12:11,516
earlier?


468
00:12:12,806 --> 00:12:14,166
Well, by using dropfirst, we're


469
00:12:14,166 --> 00:12:15,326
going to let slices take care of


470
00:12:15,326 --> 00:12:16,686
all that fancy index bounds


471
00:12:16,686 --> 00:12:17,386
checking for us.


472
00:12:17,736 --> 00:12:19,156
And since first returns an


473
00:12:19,156 --> 00:12:21,606
optional, this will work as


474
00:12:21,606 --> 00:12:23,556
expected with empty and single


475
00:12:23,556 --> 00:12:24,486
element collections.


476
00:12:25,116 --> 00:12:26,206
Let's visualize what's happening


477
00:12:26,206 --> 00:12:26,376
here.


478
00:12:27,686 --> 00:12:29,156
We start with an array, and we


479
00:12:29,156 --> 00:12:30,496
form a slice by dropping the


480
00:12:30,496 --> 00:12:31,096
first element.


481
00:12:32,386 --> 00:12:34,906
We then use the first property


482
00:12:35,696 --> 00:12:37,626
to subscript into the slice,


483
00:12:37,776 --> 00:12:38,716
retrieving the element from the


484
00:12:38,716 --> 00:12:39,416
original collection.


485
00:12:39,536 --> 00:12:40,826
Now I don't know about you, but


486
00:12:40,826 --> 00:12:42,996
I'd much rather maintain this


487
00:12:43,616 --> 00:12:44,126
code.


488
00:12:44,946 --> 00:12:46,026
Now every type is free to


489
00:12:46,026 --> 00:12:47,446
describe its own slice type, and


490
00:12:47,446 --> 00:12:48,046
many do.


491
00:12:48,596 --> 00:12:50,076
For instance, arrays define


492
00:12:50,486 --> 00:12:51,766
array slices that are especially


493
00:12:51,766 --> 00:12:52,846
attuned to the most common use


494
00:12:52,846 --> 00:12:54,446
cases that arrays work with.


495
00:12:54,976 --> 00:12:57,396
Similarly, string defines a


496
00:12:57,396 --> 00:12:59,096
substring slice type, and


497
00:12:59,096 --> 00:13:00,706
substrings, again, are tuned to


498
00:13:00,706 --> 00:13:01,806
the special cases that are most


499
00:13:01,806 --> 00:13:02,396
common with strings.


500
00:13:03,406 --> 00:13:06,196
Some types, like set, will make


501
00:13:06,196 --> 00:13:07,746
use of the generalized slice


502
00:13:07,846 --> 00:13:08,766
type defined in the standard


503
00:13:08,766 --> 00:13:09,106
library.


504
00:13:09,256 --> 00:13:10,096
That's because sets are


505
00:13:10,096 --> 00:13:10,516
unordered.


506
00:13:10,516 --> 00:13:11,506
There's not very much else that


507
00:13:11,506 --> 00:13:11,886
they can do.


508
00:13:11,886 --> 00:13:12,806
They just basically need to


509
00:13:12,806 --> 00:13:13,976
maintain a start and an end


510
00:13:13,976 --> 00:13:14,906
index [inaudible] to the


511
00:13:14,906 --> 00:13:15,896
original collection.


512
00:13:16,906 --> 00:13:18,576
Data and range on the other hand


513
00:13:18,576 --> 00:13:20,426
are their own slice types, and


514
00:13:20,426 --> 00:13:21,736
so there's a lot of options that


515
00:13:21,736 --> 00:13:22,326
you have here.


516
00:13:22,756 --> 00:13:24,106
And there's one more thing about


517
00:13:24,106 --> 00:13:25,166
slices that I want to talk about


518
00:13:25,166 --> 00:13:25,846
before we move on.


519
00:13:26,366 --> 00:13:28,576
Let's suppose that we had a


520
00:13:28,716 --> 00:13:29,986
really large collection, like


521
00:13:30,176 --> 00:13:31,276
thousands and thousands and


522
00:13:31,276 --> 00:13:32,166
thousands of elements.


523
00:13:32,806 --> 00:13:34,016
And we add a couple of small


524
00:13:34,016 --> 00:13:34,976
slices to parts of that


525
00:13:34,976 --> 00:13:35,476
collection.


526
00:13:36,666 --> 00:13:37,746
It's important to remember that


527
00:13:37,746 --> 00:13:39,586
the slice keeps the entirety of


528
00:13:39,586 --> 00:13:41,506
the originating collection alive


529
00:13:41,506 --> 00:13:43,206
as long as the slice is around.


530
00:13:43,286 --> 00:13:44,506
And this can lead to surprising


531
00:13:44,506 --> 00:13:44,996
problems.


532
00:13:45,226 --> 00:13:46,426
Let see how this works in code.


533
00:13:47,836 --> 00:13:49,296
Let's suppose I have an


534
00:13:49,296 --> 00:13:50,196
extension on an array that


535
00:13:50,196 --> 00:13:51,226
allows me to return the first


536
00:13:51,226 --> 00:13:53,816
half, and I'm using the droplast


537
00:13:53,816 --> 00:13:55,236
function here to do so.


538
00:13:55,806 --> 00:13:56,806
And we have an array of eight


539
00:13:56,806 --> 00:13:58,096
numbers, and we call our


540
00:13:58,096 --> 00:14:00,526
extension, producing the slice,


541
00:14:00,976 --> 00:14:01,986
and then to try to get rid of


542
00:14:01,986 --> 00:14:03,326
that original storage of eight


543
00:14:03,386 --> 00:14:05,006
numbers, I go ahead and assign


544
00:14:05,006 --> 00:14:06,026
that array to an empty array.


545
00:14:06,546 --> 00:14:08,786
Our first clue that something


546
00:14:09,296 --> 00:14:11,096
interesting is happening occurs


547
00:14:11,096 --> 00:14:12,246
when we ask our slice for its


548
00:14:12,246 --> 00:14:12,816
first element.


549
00:14:13,536 --> 00:14:14,636
We're somehow able to return


550
00:14:14,636 --> 00:14:16,576
one, even though we threw away


551
00:14:16,576 --> 00:14:18,876
the storage for the original


552
00:14:18,876 --> 00:14:19,086
array.


553
00:14:19,596 --> 00:14:20,906
Either there was a copy or


554
00:14:20,906 --> 00:14:22,336
something magical is going on.


555
00:14:23,356 --> 00:14:25,946
And so if we wanted to eliminate


556
00:14:25,946 --> 00:14:27,566
that buffer though, and oh the


557
00:14:27,566 --> 00:14:28,646
magic that's actually going on


558
00:14:28,646 --> 00:14:29,466
is that we're holding onto the


559
00:14:29,466 --> 00:14:29,796
buffer.


560
00:14:30,166 --> 00:14:31,196
And so if we wanted to eliminate


561
00:14:31,196 --> 00:14:32,196
that, what we could do is we


562
00:14:32,196 --> 00:14:34,136
could form an actual copy of the


563
00:14:34,136 --> 00:14:36,166
array from the slice, and then


564
00:14:36,166 --> 00:14:37,826
if we set that slice to an empty


565
00:14:37,826 --> 00:14:39,666
array itself, that copy would


566
00:14:39,666 --> 00:14:40,306
still be valid.


567
00:14:41,466 --> 00:14:42,346
Let's visualize what just


568
00:14:42,346 --> 00:14:42,606
happened.


569
00:14:43,106 --> 00:14:44,546
We started with an array.


570
00:14:45,096 --> 00:14:46,346
We then formed a slice on the


571
00:14:46,346 --> 00:14:47,886
first half of that array.


572
00:14:49,576 --> 00:14:52,146
We then created a copy of that,


573
00:14:52,506 --> 00:14:53,586
setting the array to be empty


574
00:14:53,906 --> 00:14:54,816
and setting that slice to be


575
00:14:54,816 --> 00:14:55,176
empty.


576
00:14:55,176 --> 00:14:57,936
And only after we did that did


577
00:14:57,936 --> 00:14:59,046
the underlying storage go away.


578
00:14:59,046 --> 00:15:02,716
So in this matter, slices sort


579
00:15:02,716 --> 00:15:03,876
of work like lazy copies.


580
00:15:04,256 --> 00:15:05,966
You get to choose when you make


581
00:15:05,966 --> 00:15:07,416
a copy of the elements yourself,


582
00:15:08,246 --> 00:15:09,016
and it turns out that this


583
00:15:09,016 --> 00:15:10,646
concept of being lazy and doing


584
00:15:10,646 --> 00:15:12,946
something later is really useful


585
00:15:12,946 --> 00:15:14,156
in other contexts too.


586
00:15:15,566 --> 00:15:17,386
One such context is function


587
00:15:17,386 --> 00:15:17,746
calls.


588
00:15:18,816 --> 00:15:20,316
Now function calls in Swift are


589
00:15:20,316 --> 00:15:21,216
eager by default.


590
00:15:22,056 --> 00:15:23,326
That is, they consume their


591
00:15:23,326 --> 00:15:25,626
input and return their output as


592
00:15:25,696 --> 00:15:26,156
demanded.


593
00:15:27,056 --> 00:15:28,236
Consider this example.


594
00:15:28,596 --> 00:15:29,776
We start with a range from one


595
00:15:29,776 --> 00:15:31,506
to 4000, and ranges are a really


596
00:15:31,556 --> 00:15:32,836
succinct way of representing a


597
00:15:32,836 --> 00:15:33,516
lot of numbers.


598
00:15:33,906 --> 00:15:35,266
It's just a start and an end,


599
00:15:35,266 --> 00:15:36,586
and it knows how to produce


600
00:15:36,846 --> 00:15:36,936
them.


601
00:15:37,336 --> 00:15:38,516
We then map this though


602
00:15:38,516 --> 00:15:39,836
multiplying each value by two,


603
00:15:39,836 --> 00:15:40,916
and so we've now actually


604
00:15:40,916 --> 00:15:42,026
allocated an array of 4000


605
00:15:42,026 --> 00:15:43,536
elements and performed our


606
00:15:43,536 --> 00:15:45,456
mapping function on each of


607
00:15:45,456 --> 00:15:45,626
them.


608
00:15:46,396 --> 00:15:47,676
We then filter that down to four


609
00:15:47,676 --> 00:15:48,126
elements.


610
00:15:48,746 --> 00:15:49,586
And so at this point, we've


611
00:15:49,586 --> 00:15:50,476
actually gone ahead and


612
00:15:50,476 --> 00:15:53,746
allocated 4004, you know, space


613
00:15:53,746 --> 00:15:56,636
for 4004 elements, but we only


614
00:15:56,636 --> 00:15:57,696
really needed the final four.


615
00:15:58,216 --> 00:16:01,256
And that's an awful lot of


616
00:16:01,256 --> 00:16:02,786
intermediate computation that


617
00:16:02,786 --> 00:16:03,936
maybe we don't always desire.


618
00:16:04,546 --> 00:16:05,586
It would be great if there was a


619
00:16:05,586 --> 00:16:06,636
way just to not do any of it,


620
00:16:07,066 --> 00:16:08,246
unless it was absolutely needed.


621
00:16:08,736 --> 00:16:11,316
And Swift's answer for that is


622
00:16:11,316 --> 00:16:12,616
called being lazy, just like in


623
00:16:12,616 --> 00:16:12,966
real life.


624
00:16:14,756 --> 00:16:15,736
We'll start as we did before


625
00:16:15,736 --> 00:16:18,296
with the range, and then we'll


626
00:16:18,296 --> 00:16:19,706
tell that range to be lazy.


627
00:16:19,706 --> 00:16:20,746
And when we do this, what


628
00:16:20,746 --> 00:16:23,076
happens is we wrap the original


629
00:16:23,076 --> 00:16:25,026
collection with a lazy


630
00:16:25,026 --> 00:16:26,586
collection, and when we perform


631
00:16:26,586 --> 00:16:27,996
operations on this lazy


632
00:16:27,996 --> 00:16:29,036
collection, what's going to


633
00:16:29,036 --> 00:16:30,276
happen is we're going to wrap it


634
00:16:30,276 --> 00:16:30,566
again.


635
00:16:30,566 --> 00:16:32,176
And so when we wrap the, when we


636
00:16:32,176 --> 00:16:33,236
call map on it, we actually


637
00:16:33,536 --> 00:16:34,096
aren't mapping.


638
00:16:34,346 --> 00:16:35,166
We're not doing anything with


639
00:16:35,166 --> 00:16:36,156
that closure other than storing


640
00:16:36,156 --> 00:16:37,306
it for later should we ever need


641
00:16:37,306 --> 00:16:37,746
to use it.


642
00:16:38,566 --> 00:16:40,396
Further, if I filter that lazy


643
00:16:40,396 --> 00:16:41,806
map collection, the filter


644
00:16:41,806 --> 00:16:43,546
simply wraps the map collection,


645
00:16:43,806 --> 00:16:44,816
noting that it's going to filter


646
00:16:44,816 --> 00:16:46,236
later on demand, but not right


647
00:16:46,236 --> 00:16:46,476
now.


648
00:16:47,896 --> 00:16:49,426
Now let's go ahead and ask our


649
00:16:49,426 --> 00:16:50,696
lazy filter collection for it's


650
00:16:50,696 --> 00:16:51,326
first element.


651
00:16:55,236 --> 00:16:58,056
When we do this, we'll start by


652
00:16:58,056 --> 00:16:59,006
asking the lazy filter


653
00:16:59,006 --> 00:16:59,776
collection for it's first


654
00:16:59,776 --> 00:17:01,406
element, but the lazy filter


655
00:17:01,406 --> 00:17:02,286
collection doesn't know.


656
00:17:02,996 --> 00:17:04,175
It wraps something that might


657
00:17:04,256 --> 00:17:04,435
know.


658
00:17:05,026 --> 00:17:06,006
And so it'll defer to the map


659
00:17:06,086 --> 00:17:06,536
collection.


660
00:17:06,596 --> 00:17:08,356
And the map collection also


661
00:17:08,596 --> 00:17:09,756
doesn't know it's first element,


662
00:17:10,205 --> 00:17:11,326
but it wraps a collection that


663
00:17:11,326 --> 00:17:12,876
might, and indeed, the range


664
00:17:12,876 --> 00:17:13,756
knows it's first element.


665
00:17:14,925 --> 00:17:16,296
The first element of the range


666
00:17:16,356 --> 00:17:17,816
is the value one, which it


667
00:17:17,816 --> 00:17:18,826
returns to the lazy map


668
00:17:18,876 --> 00:17:21,226
collection where now the lazy


669
00:17:21,226 --> 00:17:22,215
map collection can actually


670
00:17:22,215 --> 00:17:24,296
perform it's closure, computing


671
00:17:24,296 --> 00:17:26,126
the value 2, which it returns to


672
00:17:26,126 --> 00:17:27,506
the lazy filter collection as a


673
00:17:27,656 --> 00:17:28,716
candidatefirst element.


674
00:17:29,346 --> 00:17:31,096
Now lucky for us in this case, 2


675
00:17:31,096 --> 00:17:32,586
happens to be less than 10, and


676
00:17:32,586 --> 00:17:33,696
so the lazy filter collection


677
00:17:33,696 --> 00:17:35,076
finds it first element on the


678
00:17:35,076 --> 00:17:37,006
first try, which it returns back


679
00:17:37,006 --> 00:17:37,506
to its caller.


680
00:17:38,056 --> 00:17:40,096
Now that's a lot of different


681
00:17:40,096 --> 00:17:40,736
computation.


682
00:17:41,426 --> 00:17:43,346
And I mentioned that lazy aims


683
00:17:43,346 --> 00:17:44,906
to only do calculation as needed


684
00:17:44,906 --> 00:17:46,626
on demand, but another thing


685
00:17:46,626 --> 00:17:47,716
that it avoids is creating


686
00:17:47,716 --> 00:17:48,586
intermediate storage.


687
00:17:49,446 --> 00:17:51,216
So I want to show an example of


688
00:17:52,096 --> 00:17:52,236
that.


689
00:17:52,286 --> 00:17:53,426
Let's suppose we had an array of


690
00:17:53,426 --> 00:17:54,406
different kind of bears.


691
00:17:55,296 --> 00:17:57,206
However, I want to point out


692
00:17:57,206 --> 00:17:58,196
that some of these bears are


693
00:17:58,196 --> 00:17:58,636
redundant.


694
00:17:59,416 --> 00:18:00,176
We already know that they're


695
00:18:00,176 --> 00:18:00,706
bears.


696
00:18:01,016 --> 00:18:01,796
They don't need to tell us


697
00:18:01,796 --> 00:18:02,336
again.


698
00:18:03,376 --> 00:18:04,576
So let's write some code to find


699
00:18:04,576 --> 00:18:05,756
those silly, redundant bears,


700
00:18:05,756 --> 00:18:07,356
and we'll do this using a lazy


701
00:18:07,356 --> 00:18:08,366
filter, as before.


702
00:18:08,366 --> 00:18:11,996
And in this case, producing a


703
00:18:11,996 --> 00:18:13,206
lazy filter is going to be a


704
00:18:13,206 --> 00:18:14,676
lazy filter collection that


705
00:18:14,746 --> 00:18:16,156
wraps an array of strings.


706
00:18:16,716 --> 00:18:17,946
In our closer here, were going


707
00:18:17,946 --> 00:18:19,396
to print out which bear we're


708
00:18:19,396 --> 00:18:21,056
currently iterating on before we


709
00:18:21,056 --> 00:18:21,836
do our predicate check.


710
00:18:21,836 --> 00:18:23,006
And we're doing this because I


711
00:18:23,006 --> 00:18:24,146
want to understand how filter


712
00:18:24,146 --> 00:18:25,096
works a little better, and then


713
00:18:25,096 --> 00:18:26,806
we'll call first, and when we do


714
00:18:26,806 --> 00:18:28,116
this, we'll defer to the lazy


715
00:18:28,116 --> 00:18:31,446
filter collection, and then the


716
00:18:31,446 --> 00:18:32,726
lazy filter collection will in


717
00:18:32,776 --> 00:18:33,966
turn defer to the original


718
00:18:33,966 --> 00:18:37,226
storage where we'll print out


719
00:18:37,326 --> 00:18:41,476
Grizzly, check the predicate,


720
00:18:42,016 --> 00:18:43,496
which in this case is false,


721
00:18:43,496 --> 00:18:44,406
Grizzly does not contain the


722
00:18:44,406 --> 00:18:45,636
word bear, and advance on to


723
00:18:45,636 --> 00:18:45,976
panda.


724
00:18:47,336 --> 00:18:51,046
When we get to panda, when we


725
00:18:51,046 --> 00:18:52,456
get to panda, we'll again print


726
00:18:52,746 --> 00:18:54,596
out panda, check to see if it


727
00:18:54,596 --> 00:18:55,936
contains the word bear, and


728
00:18:55,936 --> 00:18:56,926
advance on to spectacle.


729
00:18:57,996 --> 00:19:00,006
Spectacle gets printed, also


730
00:19:00,006 --> 00:19:00,996
doesn't contain the word bear,


731
00:19:01,146 --> 00:19:02,346
and we advance finally to gummy


732
00:19:02,346 --> 00:19:04,936
bears, which mercifully has the


733
00:19:04,936 --> 00:19:07,046
word bear in it, and which the


734
00:19:07,046 --> 00:19:08,316
lazy filter collection can now


735
00:19:08,346 --> 00:19:10,666
return to its caller.


736
00:19:12,046 --> 00:19:12,976
Now what would happen if we


737
00:19:12,976 --> 00:19:14,106
called first again?


738
00:19:15,196 --> 00:19:18,476
Well, it's the same story.


739
00:19:18,906 --> 00:19:19,896
We ask the lazy filter


740
00:19:19,896 --> 00:19:21,536
collection, which defers to the


741
00:19:21,536 --> 00:19:22,676
underlying collection, which


742
00:19:22,676 --> 00:19:23,926
repeats that calculation,


743
00:19:24,796 --> 00:19:25,836
returning it to its caller.


744
00:19:26,066 --> 00:19:29,046
Now this might not typically be


745
00:19:29,046 --> 00:19:30,626
what you want, and so if you


746
00:19:30,626 --> 00:19:31,506
find yourself needing to


747
00:19:31,506 --> 00:19:32,586
repeatedly ask the lazy


748
00:19:32,586 --> 00:19:33,576
collection to calculate its


749
00:19:33,576 --> 00:19:35,066
result, there's a way to make


750
00:19:35,066 --> 00:19:35,976
sure that that happens just


751
00:19:35,976 --> 00:19:36,356
once.


752
00:19:36,876 --> 00:19:38,836
We can ensure that the lazy


753
00:19:38,836 --> 00:19:40,176
collection is iterated exactly


754
00:19:40,176 --> 00:19:42,116
once by creating a new nonlazy


755
00:19:42,176 --> 00:19:44,466
collection from the lazy, and


756
00:19:44,466 --> 00:19:46,156
when you do this, it will still


757
00:19:46,156 --> 00:19:47,306
defer to the lazy collection,


758
00:19:47,786 --> 00:19:48,586
but now the iteration will


759
00:19:48,586 --> 00:19:50,466
proceed through the entirety of


760
00:19:50,466 --> 00:19:51,686
your underlying collection,


761
00:19:53,536 --> 00:19:55,116
producing essentially, you know,


762
00:19:55,116 --> 00:19:56,706
the nonlazy version of that lazy


763
00:19:56,706 --> 00:19:57,376
calculation.


764
00:19:57,446 --> 00:19:59,096
And so in this case, we get an


765
00:19:59,096 --> 00:20:00,266
array containing the string


766
00:20:00,266 --> 00:20:00,776
gummy bears.


767
00:20:01,466 --> 00:20:02,646
And if we print the first


768
00:20:02,646 --> 00:20:03,976
element of that ray, we don't


769
00:20:03,976 --> 00:20:05,176
need to consult the closure at


770
00:20:05,176 --> 00:20:06,106
all or the lazy collection at


771
00:20:06,106 --> 00:20:06,246
all.


772
00:20:06,246 --> 00:20:07,376
We basically stamped out the


773
00:20:07,376 --> 00:20:08,986
laziness and now have an eager


774
00:20:08,986 --> 00:20:09,226
array.


775
00:20:11,676 --> 00:20:13,156
So when should we be lazy?


776
00:20:14,156 --> 00:20:15,586
Well, lazy collections are a


777
00:20:15,586 --> 00:20:16,616
really great way to eliminate


778
00:20:16,616 --> 00:20:17,896
the overhead of chained maps and


779
00:20:17,896 --> 00:20:18,406
filters.


780
00:20:18,686 --> 00:20:19,566
They excel when you find


781
00:20:19,566 --> 00:20:20,826
yourself only needing part of


782
00:20:20,826 --> 00:20:21,666
the result of a collection


783
00:20:21,666 --> 00:20:24,116
calculation, or we should avoid


784
00:20:24,116 --> 00:20:26,006
using lazy if your closures have


785
00:20:26,276 --> 00:20:27,726
side effects, and your closures


786
00:20:27,726 --> 00:20:28,946
should rarely have side effects.


787
00:20:29,686 --> 00:20:31,406
And be sure to reify back, or I


788
00:20:31,406 --> 00:20:32,526
should say, be sure to consider


789
00:20:32,526 --> 00:20:33,856
reifying back into a regular


790
00:20:33,856 --> 00:20:35,146
collection when you cross API


791
00:20:35,146 --> 00:20:35,586
boundaries.


792
00:20:36,196 --> 00:20:37,046
Lazy should often be an


793
00:20:37,046 --> 00:20:38,026
implementation detail.


794
00:20:38,546 --> 00:20:40,996
Now up until now, we've been


795
00:20:40,996 --> 00:20:42,226
able to do a lot of cool things


796
00:20:42,336 --> 00:20:43,616
with just mutable collections,


797
00:20:44,926 --> 00:20:46,426
but of course Swift lets us


798
00:20:46,426 --> 00:20:47,696
mutate our collections as well.


799
00:20:49,106 --> 00:20:50,036
Let's talk about the two kinds


800
00:20:50,036 --> 00:20:51,206
of collections that we haven't


801
00:20:51,206 --> 00:20:52,386
talked about yet.


802
00:20:52,936 --> 00:20:54,556
The first of these is mutable


803
00:20:54,556 --> 00:20:54,976
collection.


804
00:20:56,036 --> 00:20:56,856
This adds a setter to the


805
00:20:56,856 --> 00:20:58,006
subscript so that you can change


806
00:20:58,006 --> 00:20:59,316
the contents of a collection but


807
00:20:59,316 --> 00:20:59,866
not its length.


808
00:21:00,476 --> 00:21:01,146
And you have to be able to do


809
00:21:01,146 --> 00:21:01,976
this in constant time.


810
00:21:05,356 --> 00:21:07,846
The next is called a Range


811
00:21:07,846 --> 00:21:08,856
Replaceable Collection, and this


812
00:21:08,856 --> 00:21:09,726
is the kind of collection that


813
00:21:09,726 --> 00:21:11,196
you get when you can remove


814
00:21:11,196 --> 00:21:13,596
elements from a collection or


815
00:21:13,596 --> 00:21:14,196
insert them.


816
00:21:14,326 --> 00:21:16,916
And now I want to talk about one


817
00:21:16,916 --> 00:21:18,326
of the questions I get asked all


818
00:21:19,176 --> 00:21:20,206
the time.


819
00:21:20,416 --> 00:21:21,806
Why does my perfectly reasonable


820
00:21:21,806 --> 00:21:22,646
collection code crash?


821
00:21:23,736 --> 00:21:24,796
And like all good question


822
00:21:24,796 --> 00:21:26,066
answers, I almost always follow


823
00:21:26,066 --> 00:21:26,986
up with a few questions of my


824
00:21:26,986 --> 00:21:27,206
own.


825
00:21:28,436 --> 00:21:29,246
Sometimes I start with the


826
00:21:29,246 --> 00:21:30,186
classic, well what are you


827
00:21:30,186 --> 00:21:30,706
trying to do?


828
00:21:30,896 --> 00:21:32,986
And I usually quickly follow up


829
00:21:32,986 --> 00:21:34,026
with, well how are you using


830
00:21:34,026 --> 00:21:34,756
your collections?


831
00:21:35,156 --> 00:21:36,056
Are you mutating them?


832
00:21:36,236 --> 00:21:36,786
Are you sure you aren't


833
00:21:36,786 --> 00:21:37,806
accessing your collections for


834
00:21:37,806 --> 00:21:38,366
multiple threads?


835
00:21:38,976 --> 00:21:40,366
And I ask these questions


836
00:21:40,366 --> 00:21:42,836
because their answers often lead


837
00:21:42,836 --> 00:21:44,186
to the root cause of the


838
00:21:44,456 --> 00:21:44,776
problem.


839
00:21:44,776 --> 00:21:46,696
Well, let's begin with the


840
00:21:46,696 --> 00:21:47,556
assumption that threads aren't


841
00:21:47,556 --> 00:21:47,866
involved.


842
00:21:48,276 --> 00:21:49,146
I'm not ready to think about


843
00:21:49,146 --> 00:21:49,516
threads yet.


844
00:21:49,516 --> 00:21:51,996
It's not even 9:30.


845
00:21:52,176 --> 00:21:54,026
Suppose we had an array, and we


846
00:21:54,026 --> 00:21:55,716
get the index of an element that


847
00:21:55,716 --> 00:21:57,576
we know is there, in this case


848
00:21:57,576 --> 00:21:58,076
the value e.


849
00:21:58,346 --> 00:21:59,396
And then we mutate the


850
00:21:59,396 --> 00:22:00,546
collection, say by removing its


851
00:22:00,546 --> 00:22:03,146
first element, and we go ahead


852
00:22:03,146 --> 00:22:04,796
and print the element associated


853
00:22:04,796 --> 00:22:05,576
with that index.


854
00:22:06,206 --> 00:22:07,076
Well when we do this,


855
00:22:07,076 --> 00:22:09,526
unfortunately this will produce


856
00:22:09,526 --> 00:22:10,366
a fatal error.


857
00:22:11,796 --> 00:22:13,226
The index is no longer valid.


858
00:22:13,326 --> 00:22:14,826
In fact, the index became


859
00:22:14,826 --> 00:22:16,306
invalid the moment we mutated


860
00:22:16,306 --> 00:22:16,946
our collection.


861
00:22:17,466 --> 00:22:20,676
A far safer approach would be to


862
00:22:20,676 --> 00:22:22,586
mutate our collection first and


863
00:22:22,586 --> 00:22:24,196
then calculate the index.


864
00:22:24,196 --> 00:22:27,356
It's worth pointing out that


865
00:22:27,356 --> 00:22:28,566
mutation always invalidates


866
00:22:28,566 --> 00:22:29,006
indices.


867
00:22:29,066 --> 00:22:30,116
This doesn't just apply to


868
00:22:30,116 --> 00:22:30,496
arrays.


869
00:22:31,146 --> 00:22:32,206
Let's take a look at how this


870
00:22:32,376 --> 00:22:33,266
problem could manifest with


871
00:22:33,266 --> 00:22:33,866
dictionaries.


872
00:22:35,036 --> 00:22:35,816
Let's suppose that we have a


873
00:22:35,816 --> 00:22:36,936
dictionary showing a few of a


874
00:22:36,936 --> 00:22:37,966
bear's favorite things.


875
00:22:39,096 --> 00:22:40,056
We'll grab the index of our


876
00:22:40,056 --> 00:22:41,586
bear's favorite food and print


877
00:22:41,586 --> 00:22:43,316
it out, confirming that, indeed,


878
00:22:43,316 --> 00:22:43,706
it's salmon.


879
00:22:45,036 --> 00:22:46,486
Next, we'll add a couple more


880
00:22:46,486 --> 00:22:47,466
favorite things that this bear


881
00:22:47,466 --> 00:22:49,226
has, and then we'll make sure


882
00:22:49,226 --> 00:22:50,106
that our favorite food is still


883
00:22:50,106 --> 00:22:50,376
salmon.


884
00:22:50,376 --> 00:22:52,446
And we'll see that, wait a


885
00:22:52,446 --> 00:22:53,836
minute, our favorite good isn't


886
00:22:53,886 --> 00:22:55,136
hibernation, it's salmon.


887
00:22:55,436 --> 00:22:58,076
And just like arrays, we


888
00:22:58,076 --> 00:22:59,576
invalidated our index the moment


889
00:22:59,576 --> 00:23:00,646
we mutated the dictionary.


890
00:23:01,466 --> 00:23:02,446
It's also worth pointing out


891
00:23:02,736 --> 00:23:03,726
that this code can crash.


892
00:23:05,146 --> 00:23:06,186
So how do we go about fixing


893
00:23:06,186 --> 00:23:06,516
this?


894
00:23:07,606 --> 00:23:08,926
Well, it turns out it's the same


895
00:23:08,926 --> 00:23:10,266
exact fix that we used with the


896
00:23:10,266 --> 00:23:10,496
array.


897
00:23:11,276 --> 00:23:12,286
We just simply recompute the


898
00:23:12,286 --> 00:23:13,256
index after we mutate.


899
00:23:13,696 --> 00:23:15,386
Well, one thing to keep in mind


900
00:23:15,626 --> 00:23:16,486
that when you're recomputing


901
00:23:16,486 --> 00:23:17,896
indices this is something that


902
00:23:17,896 --> 00:23:18,916
can sometimes be expensive.


903
00:23:18,916 --> 00:23:20,896
Some index search methods take


904
00:23:20,976 --> 00:23:21,676
linear time.


905
00:23:22,226 --> 00:23:23,496
And so you want to take care to


906
00:23:23,496 --> 00:23:24,766
only find the indices that you


907
00:23:25,206 --> 00:23:25,306
need.


908
00:23:26,596 --> 00:23:27,936
So here's my advice if you want


909
00:23:27,936 --> 00:23:28,866
to avoid finding yourself in


910
00:23:28,866 --> 00:23:30,046
these kinds of situations.


911
00:23:30,456 --> 00:23:32,196
Remember that mutation almost


912
00:23:32,196 --> 00:23:33,546
always invalidates your indices.


913
00:23:33,986 --> 00:23:35,586
You might get away with it


914
00:23:35,586 --> 00:23:36,986
sometimes, but it's really best


915
00:23:36,986 --> 00:23:38,066
to just treat this as a hard


916
00:23:38,066 --> 00:23:38,346
rule.


917
00:23:38,636 --> 00:23:39,936
You'll be much happier for it.


918
00:23:40,926 --> 00:23:42,256
Also remember that slices hold


919
00:23:42,256 --> 00:23:44,136
on to the underlying original


920
00:23:44,276 --> 00:23:45,416
state of the collection even


921
00:23:45,416 --> 00:23:46,976
after it was mutated, and


922
00:23:46,976 --> 00:23:48,586
because of that, really think


923
00:23:48,586 --> 00:23:50,136
twice about holding onto indices


924
00:23:50,136 --> 00:23:51,786
or slices when the underlying


925
00:23:51,786 --> 00:23:52,626
collection is mutable.


926
00:23:53,776 --> 00:23:54,816
And keep in mind that index


927
00:23:54,816 --> 00:23:56,556
computation can sometimes take a


928
00:23:56,556 --> 00:23:57,756
nontrivial amount of time.


929
00:23:59,246 --> 00:24:00,516
So take care to only calculate


930
00:24:00,516 --> 00:24:01,446
indices as needed.


931
00:24:01,956 --> 00:24:04,146
So a little bit later, let's


932
00:24:04,176 --> 00:24:04,816
bring threads into the


933
00:24:04,816 --> 00:24:05,296
discussion.


934
00:24:05,786 --> 00:24:06,576
I mentioned that one of the


935
00:24:06,576 --> 00:24:07,966
questions that I ask is are your


936
00:24:08,046 --> 00:24:09,866
threads accessible for multiple


937
00:24:09,866 --> 00:24:10,166
threads?


938
00:24:10,456 --> 00:24:13,256
And the reason why I ask this is


939
00:24:13,256 --> 00:24:14,646
because our collections assume


940
00:24:14,646 --> 00:24:15,686
that you will access them from a


941
00:24:15,686 --> 00:24:16,416
single thread.


942
00:24:17,156 --> 00:24:18,746
And this is a really good thing


943
00:24:18,746 --> 00:24:19,916
for reasons of performance.


944
00:24:20,516 --> 00:24:21,376
It makes it so that all


945
00:24:21,376 --> 00:24:22,696
single-threaded use cases don't


946
00:24:22,696 --> 00:24:24,716
have to pay the tax of locks or


947
00:24:24,716 --> 00:24:26,416
any of those other primitives


948
00:24:26,416 --> 00:24:27,386
that you could use to ensure


949
00:24:27,386 --> 00:24:29,076
mutual exclusion.


950
00:24:30,226 --> 00:24:31,196
And when threads are involved,


951
00:24:31,356 --> 00:24:32,746
only developers using the


952
00:24:32,746 --> 00:24:33,786
collections will have all the


953
00:24:33,786 --> 00:24:35,066
information needed to restrict


954
00:24:35,066 --> 00:24:36,556
access with the appropriate lock


955
00:24:36,556 --> 00:24:38,056
or a serial queue at a much


956
00:24:38,106 --> 00:24:39,346
higher level abstraction than us


957
00:24:39,346 --> 00:24:40,466
lowly framework developers could


958
00:24:40,466 --> 00:24:40,956
ever offer.


959
00:24:40,956 --> 00:24:43,596
So let's see what these kinds of


960
00:24:43,596 --> 00:24:44,356
problems could look like.


961
00:24:45,536 --> 00:24:46,546
Let's suppose we have an array


962
00:24:46,546 --> 00:24:47,596
that we aim to fill up with


963
00:24:47,596 --> 00:24:49,896
sleeping bears, and to simulate


964
00:24:49,896 --> 00:24:52,026
each bear being their own bear


965
00:24:52,026 --> 00:24:52,926
and in charge of themselves,


966
00:24:52,926 --> 00:24:53,796
we're going to get access to a


967
00:24:53,886 --> 00:24:56,356
concurrent dispatch queue that


968
00:24:56,356 --> 00:24:57,496
we'll use to tell each bear to


969
00:24:57,496 --> 00:24:58,036
go to sleep.


970
00:24:58,156 --> 00:24:59,936
And because this is a concurrent


971
00:24:59,936 --> 00:25:01,196
dispatch queue, it's some time


972
00:25:01,196 --> 00:25:02,456
helpful to like imagine the code


973
00:25:02,456 --> 00:25:04,086
running at the same time, which


974
00:25:04,086 --> 00:25:05,466
I'll simulate by putting them on


975
00:25:05,466 --> 00:25:06,176
the same line.


976
00:25:06,986 --> 00:25:08,086
And later in our application,


977
00:25:08,086 --> 00:25:09,036
let's go ahead and check in on


978
00:25:09,036 --> 00:25:11,376
those sleeping bears, and


979
00:25:11,376 --> 00:25:13,506
sometimes we'll see grandpa and


980
00:25:13,556 --> 00:25:14,476
cubs snoozing happily.


981
00:25:15,136 --> 00:25:17,086
Other times, cub will go to


982
00:25:17,086 --> 00:25:18,276
sleep first, and then it'll be


983
00:25:18,276 --> 00:25:18,636
grandpa.


984
00:25:19,516 --> 00:25:20,936
Sometimes, quite mysteriously,


985
00:25:21,166 --> 00:25:22,966
only grandpa is sleeping in.


986
00:25:23,506 --> 00:25:25,166
And other times, it'll be the


987
00:25:25,226 --> 00:25:28,226
cub, and sometimes our program


988
00:25:28,226 --> 00:25:29,986
just up and crashes, and nobody


989
00:25:30,086 --> 00:25:32,046
bear's getting any sleep.


990
00:25:32,216 --> 00:25:33,246
All of these possibilities


991
00:25:33,246 --> 00:25:34,356
suggest that there's a possible


992
00:25:34,356 --> 00:25:36,306
race condition, and indeed, it


993
00:25:36,356 --> 00:25:37,336
seems likely given all the


994
00:25:37,336 --> 00:25:39,326
potential threads involved in


995
00:25:39,326 --> 00:25:40,146
this example.


996
00:25:41,116 --> 00:25:41,946
And we can prove this to


997
00:25:41,946 --> 00:25:42,916
ourselves using the thread


998
00:25:42,916 --> 00:25:44,196
sanitizer or TSAN that's


999
00:25:44,196 --> 00:25:45,106
included within Xcode.


1000
00:25:45,606 --> 00:25:47,406
And if we were to do so, we'd


1001
00:25:47,406 --> 00:25:48,376
get output that kind of looks


1002
00:25:48,376 --> 00:25:50,836
like this, and indeed, TSAN


1003
00:25:50,836 --> 00:25:51,676
would catch the race.


1004
00:25:51,676 --> 00:25:53,586
It would tell us there's a Swift


1005
00:25:53,586 --> 00:25:54,066
access race.


1006
00:25:54,626 --> 00:25:55,796
It would tell us which threads


1007
00:25:55,796 --> 00:25:58,016
are involved and give us a


1008
00:25:58,016 --> 00:25:59,076
summary at the end telling us


1009
00:25:59,126 --> 00:26:00,346
which line to actually go start


1010
00:26:00,346 --> 00:26:01,256
looking for our problem.


1011
00:26:02,336 --> 00:26:03,336
And all that evidence is


1012
00:26:03,336 --> 00:26:04,226
actually going to be really


1013
00:26:04,226 --> 00:26:06,946
helpful to find the bug.


1014
00:26:06,946 --> 00:26:07,746
So we've proven that there's a


1015
00:26:07,746 --> 00:26:08,156
bug here.


1016
00:26:08,416 --> 00:26:10,376
TSAN has never lied in my


1017
00:26:10,376 --> 00:26:11,256
experience with them.


1018
00:26:12,616 --> 00:26:14,036
So we can fix this by


1019
00:26:14,036 --> 00:26:15,446
eliminating the bears' ability


1020
00:26:15,446 --> 00:26:16,466
to go to sleep at the same time,


1021
00:26:16,846 --> 00:26:17,826
and we'll do that with a serial


1022
00:26:17,826 --> 00:26:18,456
dispatch queue.


1023
00:26:19,736 --> 00:26:20,846
And now only one bear can go to


1024
00:26:20,846 --> 00:26:21,446
sleep at a time.


1025
00:26:21,946 --> 00:26:22,846
And so if we peek in on our


1026
00:26:22,846 --> 00:26:25,236
sleeping bears again now, taking


1027
00:26:25,236 --> 00:26:26,516
care to do so on the appropriate


1028
00:26:26,516 --> 00:26:28,926
queue, we see that sure enough


1029
00:26:29,226 --> 00:26:30,496
grandpa and cub are snoozing


1030
00:26:30,496 --> 00:26:31,586
away peacefully like we


1031
00:26:31,586 --> 00:26:32,006
expected.


1032
00:26:33,936 --> 00:26:35,306
So my advice for working with


1033
00:26:35,306 --> 00:26:36,526
collections for multiple threads


1034
00:26:36,976 --> 00:26:38,336
is try to isolate your data so


1035
00:26:38,336 --> 00:26:39,296
that it can only be seen from a


1036
00:26:39,296 --> 00:26:40,856
single thread, and when you


1037
00:26:40,856 --> 00:26:42,906
can't do that, make sure that


1038
00:26:42,906 --> 00:26:43,766
you have an appropriate form in


1039
00:26:43,766 --> 00:26:45,126
mutual exclusion, such as a


1040
00:26:45,126 --> 00:26:46,726
serial dispatch queue or locks.


1041
00:26:47,816 --> 00:26:49,016
And always use the thread


1042
00:26:49,016 --> 00:26:50,226
sanitizer to double check your


1043
00:26:50,226 --> 00:26:50,476
work.


1044
00:26:50,876 --> 00:26:52,376
It's far better to catch bugs


1045
00:26:52,406 --> 00:26:53,426
before they ship in your app


1046
00:26:53,816 --> 00:26:54,236
than after.


1047
00:26:54,236 --> 00:26:56,496
And I have a little bit more


1048
00:26:56,496 --> 00:26:57,496
advice for working with mutable


1049
00:26:57,496 --> 00:26:58,046
collections.


1050
00:26:59,476 --> 00:27:01,166
The first of which is if you can


1051
00:27:01,166 --> 00:27:02,676
avoid it, don't use mutable


1052
00:27:02,676 --> 00:27:03,366
state at all.


1053
00:27:04,456 --> 00:27:05,706
So far all the difficulties that


1054
00:27:05,706 --> 00:27:06,906
I've described have come about


1055
00:27:06,906 --> 00:27:07,916
because we've been working with


1056
00:27:07,916 --> 00:27:08,526
mutable state.


1057
00:27:08,926 --> 00:27:10,066
You can avoid all the potential


1058
00:27:10,066 --> 00:27:11,356
for this complexity by avoiding


1059
00:27:11,356 --> 00:27:12,686
mutable collections in the first


1060
00:27:12,686 --> 00:27:13,096
place.


1061
00:27:13,866 --> 00:27:14,976
Many times you can actually


1062
00:27:14,976 --> 00:27:16,116
emulate the mutations that you


1063
00:27:16,116 --> 00:27:18,026
want to perform by using a slice


1064
00:27:18,766 --> 00:27:20,676
or using a lazy wrapper, and


1065
00:27:20,676 --> 00:27:21,666
it's almost always easier to


1066
00:27:21,666 --> 00:27:22,796
understand data that cannot


1067
00:27:22,856 --> 00:27:23,316
change.


1068
00:27:23,626 --> 00:27:25,416
And thanks to mutability being


1069
00:27:25,576 --> 00:27:27,066
built into Swift, the compiler


1070
00:27:27,066 --> 00:27:28,196
will help you if you're leaving


1071
00:27:28,196 --> 00:27:29,276
a state mutable when you're not


1072
00:27:29,276 --> 00:27:30,726
actually mutating it.


1073
00:27:32,436 --> 00:27:33,756
Now I have one more piece of


1074
00:27:33,756 --> 00:27:35,486
advice that actually concerns


1075
00:27:35,486 --> 00:27:36,746
how best to use mutable state


1076
00:27:36,746 --> 00:27:38,656
when you have to.


1077
00:27:38,856 --> 00:27:39,656
And that's when you're forming


1078
00:27:39,656 --> 00:27:40,396
new collections.


1079
00:27:40,606 --> 00:27:41,606
You can help performance if


1080
00:27:41,606 --> 00:27:42,786
you're lucky enough to know an


1081
00:27:42,786 --> 00:27:45,246
exact count or a really good


1082
00:27:45,246 --> 00:27:46,156
approximation of how many


1083
00:27:46,156 --> 00:27:47,056
elements you're actually going


1084
00:27:47,056 --> 00:27:47,226
to need.


1085
00:27:47,776 --> 00:27:49,326
Most collection APIs have a way


1086
00:27:49,326 --> 00:27:50,466
of being able to provide this


1087
00:27:50,536 --> 00:27:51,756
hint, and when you do this, you


1088
00:27:51,756 --> 00:27:53,136
get exactly the size you need


1089
00:27:53,136 --> 00:27:53,846
with no overhead.


1090
00:27:54,496 --> 00:27:56,146
If you don't, our collections


1091
00:27:56,146 --> 00:27:57,286
are general purpose tools.


1092
00:27:58,106 --> 00:27:59,036
They're meant to work on a wide


1093
00:27:59,036 --> 00:28:00,126
variety of cases, and as you


1094
00:28:00,126 --> 00:28:01,656
incrementally add elements, you


1095
00:28:01,656 --> 00:28:03,736
may actually end up over


1096
00:28:03,736 --> 00:28:04,816
allocating the amount of storage


1097
00:28:04,816 --> 00:28:06,706
that you need, but taking care


1098
00:28:06,706 --> 00:28:07,726
that you don't over estimate


1099
00:28:07,726 --> 00:28:09,226
when providing such hints,


1100
00:28:09,446 --> 00:28:10,186
because otherwise you'll find


1101
00:28:10,186 --> 00:28:11,156
yourself in the same exactly


1102
00:28:11,156 --> 00:28:12,116
situation where you're using up


1103
00:28:12,116 --> 00:28:13,366
more storage than you actually


1104
00:28:13,876 --> 00:28:13,966
need.


1105
00:28:14,756 --> 00:28:16,216
And now, I want to move on to my


1106
00:28:16,216 --> 00:28:17,266
final topic for today.


1107
00:28:17,266 --> 00:28:20,196
And that's the wide range of


1108
00:28:20,196 --> 00:28:20,986
collections that become


1109
00:28:20,986 --> 00:28:22,876
available for you when you


1110
00:28:22,876 --> 00:28:24,166
import Foundation and when you


1111
00:28:24,166 --> 00:28:25,756
should consider using them.


1112
00:28:26,456 --> 00:28:28,286
In addition to the standard


1113
00:28:28,286 --> 00:28:29,266
library collections, when you


1114
00:28:29,266 --> 00:28:30,606
import Foundation, you gain


1115
00:28:30,606 --> 00:28:31,546
access to the great


1116
00:28:31,546 --> 00:28:32,806
reference-type collections that


1117
00:28:32,806 --> 00:28:34,216
objective C developers have been


1118
00:28:34,216 --> 00:28:35,076
using for decades.


1119
00:28:35,076 --> 00:28:37,636
And many of these also gain


1120
00:28:37,636 --> 00:28:39,636
conformance in Swift and thus


1121
00:28:39,636 --> 00:28:40,816
behave just the collections that


1122
00:28:40,816 --> 00:28:41,636
we've been talking about.


1123
00:28:42,356 --> 00:28:43,246
That said, there are a couple


1124
00:28:43,246 --> 00:28:44,136
important things to keep in


1125
00:28:44,136 --> 00:28:44,426
mind.


1126
00:28:44,906 --> 00:28:48,046
First thing to keep in mind is


1127
00:28:48,046 --> 00:28:48,676
that these NS [inaudible]


1128
00:28:48,726 --> 00:28:50,376
collections are reference types.


1129
00:28:50,556 --> 00:28:51,616
And this is best examined by


1130
00:28:51,616 --> 00:28:52,696
considering an example.


1131
00:28:53,636 --> 00:28:54,546
We're going to define value


1132
00:28:54,636 --> 00:28:55,596
types and reference types and do


1133
00:28:55,596 --> 00:28:57,196
the same things with them on two


1134
00:28:57,196 --> 00:28:57,476
sides.


1135
00:28:58,406 --> 00:28:59,536
So with our value type, we'll


1136
00:28:59,536 --> 00:29:00,196
call it x.


1137
00:29:00,196 --> 00:29:01,456
It will be an array of strings.


1138
00:29:02,476 --> 00:29:04,466
We get an empty array called x.


1139
00:29:05,076 --> 00:29:06,206
With a reference type, we get an


1140
00:29:06,206 --> 00:29:08,306
empty array, but x is pointing


1141
00:29:08,306 --> 00:29:08,606
to it.


1142
00:29:10,036 --> 00:29:12,086
We then mutate that array with


1143
00:29:12,086 --> 00:29:12,656
the value type.


1144
00:29:12,656 --> 00:29:14,086
That array is mutated in line.


1145
00:29:14,736 --> 00:29:16,326
With the reference type, that


1146
00:29:16,486 --> 00:29:17,786
array is, the reference, the


1147
00:29:17,786 --> 00:29:19,646
array that is being referenced


1148
00:29:19,696 --> 00:29:20,816
is mutated in line.


1149
00:29:21,406 --> 00:29:22,286
We add another variable.


1150
00:29:22,556 --> 00:29:24,376
With the value type, something


1151
00:29:24,376 --> 00:29:25,276
really special happens.


1152
00:29:25,546 --> 00:29:26,316
We actually don't copy the


1153
00:29:26,316 --> 00:29:27,156
storage at this point.


1154
00:29:27,396 --> 00:29:29,766
Why is an array that knows that


1155
00:29:29,766 --> 00:29:30,926
its storage is actually owned by


1156
00:29:30,926 --> 00:29:31,056
x?


1157
00:29:31,056 --> 00:29:33,366
And why is that actually going


1158
00:29:33,436 --> 00:29:34,666
to perform that copy until


1159
00:29:34,666 --> 00:29:35,536
either of those collections is


1160
00:29:35,536 --> 00:29:35,916
mutated.


1161
00:29:36,676 --> 00:29:37,456
The reference type is a little


1162
00:29:37,456 --> 00:29:37,956
bit different.


1163
00:29:38,946 --> 00:29:40,616
Y is just another pointer to the


1164
00:29:40,616 --> 00:29:41,666
same underlying array.


1165
00:29:43,096 --> 00:29:44,516
So let's go ahead and mutate y.


1166
00:29:44,656 --> 00:29:45,516
We'll put another bear in that


1167
00:29:45,516 --> 00:29:45,786
array.


1168
00:29:46,126 --> 00:29:47,266
With the value type what happens


1169
00:29:47,546 --> 00:29:48,786
is first we invoke that copy on


1170
00:29:48,786 --> 00:29:49,336
write machinery.


1171
00:29:49,486 --> 00:29:51,256
We're writing to a y, so we need


1172
00:29:51,256 --> 00:29:53,816
to copy it, and then we can


1173
00:29:53,816 --> 00:29:54,966
insert the next bear.


1174
00:29:55,146 --> 00:29:57,106
With the reference, it's a


1175
00:29:57,106 --> 00:29:57,826
little bit simpler.


1176
00:29:58,056 --> 00:29:58,846
There's only one array.


1177
00:29:59,216 --> 00:30:00,756
We simply put the panda in the


1178
00:30:00,756 --> 00:30:00,946
array.


1179
00:30:01,576 --> 00:30:04,006
There's a second thing that you


1180
00:30:04,006 --> 00:30:05,306
need to keep in mind when


1181
00:30:05,306 --> 00:30:07,466
working with the foundation


1182
00:30:07,466 --> 00:30:08,586
collections in Swift.


1183
00:30:08,816 --> 00:30:11,696
And that is, all objective-C


1184
00:30:11,696 --> 00:30:13,416
APIs in Swift appear as Swift


1185
00:30:13,546 --> 00:30:14,616
native value types.


1186
00:30:14,926 --> 00:30:15,856
And this is actually really


1187
00:30:15,856 --> 00:30:16,986
wonderful because it let's code


1188
00:30:16,986 --> 00:30:18,706
in each language speak naturally


1189
00:30:18,706 --> 00:30:19,596
with the types that they work


1190
00:30:19,596 --> 00:30:19,926
with best.


1191
00:30:21,046 --> 00:30:21,846
But how can this work?


1192
00:30:22,216 --> 00:30:22,946
The two languages have


1193
00:30:22,946 --> 00:30:23,526
completely different


1194
00:30:23,526 --> 00:30:24,426
implementations for these


1195
00:30:24,426 --> 00:30:24,866
collections.


1196
00:30:25,976 --> 00:30:27,986
And the reason why it works is


1197
00:30:27,986 --> 00:30:28,886
something known as bridging.


1198
00:30:29,566 --> 00:30:30,526
Bridging is how we convert


1199
00:30:30,526 --> 00:30:31,416
between the two different


1200
00:30:31,776 --> 00:30:33,266
runtime representations, and


1201
00:30:33,266 --> 00:30:33,886
this is something that's


1202
00:30:33,926 --> 00:30:35,036
necessary because Swift and


1203
00:30:35,036 --> 00:30:36,736
objective-C, I'm sure you've


1204
00:30:36,736 --> 00:30:37,946
noticed, are very different


1205
00:30:37,946 --> 00:30:39,686
languages with very different


1206
00:30:39,686 --> 00:30:41,236
compile and runtime features.


1207
00:30:42,326 --> 00:30:43,436
And while we've optimized


1208
00:30:43,436 --> 00:30:44,976
bridging to be as fast as it can


1209
00:30:44,976 --> 00:30:46,186
be, it's not free.


1210
00:30:46,546 --> 00:30:48,146
There will always be a cost when


1211
00:30:48,146 --> 00:30:48,886
bridging between the two


1212
00:30:48,886 --> 00:30:49,466
languages.


1213
00:30:50,656 --> 00:30:52,066
So what happens when we bridge?


1214
00:30:52,836 --> 00:30:54,206
Well, when we bridge between the


1215
00:30:54,206 --> 00:30:55,606
language, we have dispersed set


1216
00:30:55,606 --> 00:30:57,166
up new storage, equivalent


1217
00:30:57,166 --> 00:30:58,376
storage, so if you're taking n


1218
00:30:58,376 --> 00:30:59,246
things in one language, you'll


1219
00:30:59,246 --> 00:31:00,806
take up n space in the next one.


1220
00:31:01,206 --> 00:31:02,296
Then we need to go element by


1221
00:31:02,296 --> 00:31:04,806
element and convert potentially


1222
00:31:04,806 --> 00:31:05,376
between them, and this


1223
00:31:05,436 --> 00:31:06,276
per-element bridging can


1224
00:31:06,276 --> 00:31:06,976
sometimes be recursive.


1225
00:31:07,076 --> 00:31:08,886
For instance, if I have an array


1226
00:31:08,886 --> 00:31:10,226
of strings, first we'll bridge


1227
00:31:10,226 --> 00:31:11,406
the array, and then we'll bridge


1228
00:31:11,446 --> 00:31:12,786
each individual string.


1229
00:31:12,966 --> 00:31:14,746
And when this happens at the


1230
00:31:14,746 --> 00:31:15,606
boundary between the two


1231
00:31:15,606 --> 00:31:16,996
languages, we call it eager


1232
00:31:16,996 --> 00:31:17,366
bridging.


1233
00:31:17,836 --> 00:31:19,996
And collections will always be


1234
00:31:19,996 --> 00:31:21,036
bridged eagerly when the


1235
00:31:21,036 --> 00:31:22,846
elements of the collection need


1236
00:31:22,846 --> 00:31:23,536
bridging as well.


1237
00:31:23,536 --> 00:31:25,506
And this arises most often with


1238
00:31:25,536 --> 00:31:27,316
dictionaries keyed by strings.


1239
00:31:27,846 --> 00:31:29,926
When collection bridging is not


1240
00:31:29,966 --> 00:31:31,446
eager, we call it lazy.


1241
00:31:31,526 --> 00:31:32,416
And this happens when the


1242
00:31:32,416 --> 00:31:33,636
element types of the collection


1243
00:31:33,776 --> 00:31:35,296
aren't bridged themselves, such


1244
00:31:35,376 --> 00:31:36,016
as NSViews.


1245
00:31:36,526 --> 00:31:37,816
In this case, bridging will be


1246
00:31:38,056 --> 00:31:39,566
deferred until the collection is


1247
00:31:39,566 --> 00:31:40,746
actually first used.


1248
00:31:40,966 --> 00:31:42,276
Let's make this concrete with


1249
00:31:42,276 --> 00:31:42,826
some examples.


1250
00:31:43,596 --> 00:31:44,356
We'll first consider an


1251
00:31:44,356 --> 00:31:45,896
objective-C API describing an


1252
00:31:45,896 --> 00:31:46,926
NSArray of NSDatas.


1253
00:31:47,866 --> 00:31:49,566
Now NSArray is bridged to array,


1254
00:31:49,566 --> 00:31:51,076
and NSData is bridged to


1255
00:31:51,076 --> 00:31:51,856
value-type data.


1256
00:31:52,086 --> 00:31:53,606
And so such a collection would


1257
00:31:53,606 --> 00:31:54,396
be bridged eagerly.


1258
00:31:54,616 --> 00:31:57,016
I mentioned a moment ago that


1259
00:31:57,016 --> 00:31:58,126
NSViews are not bridged in


1260
00:31:58,126 --> 00:31:58,466
Swift.


1261
00:31:58,466 --> 00:32:00,206
They remain reference types in


1262
00:32:00,206 --> 00:32:00,516
Swift.


1263
00:32:00,516 --> 00:32:02,556
And so an NSArray of NSViews


1264
00:32:03,186 --> 00:32:04,186
will be lazily bridged.


1265
00:32:04,406 --> 00:32:05,436
The bridging won't happen until


1266
00:32:05,436 --> 00:32:07,626
you first access or try to use


1267
00:32:07,626 --> 00:32:08,806
that array.


1268
00:32:10,556 --> 00:32:13,066
And finally, an NSDictionary


1269
00:32:13,066 --> 00:32:15,336
with keys that are NS strings


1270
00:32:15,336 --> 00:32:17,666
will be bridged eagerly because


1271
00:32:17,666 --> 00:32:18,756
the strings need to come across


1272
00:32:18,846 --> 00:32:21,346
in Swift as value-type strings.


1273
00:32:22,336 --> 00:32:22,996
So now that we know what


1274
00:32:22,996 --> 00:32:24,616
bridging is, how it works, and


1275
00:32:24,616 --> 00:32:26,166
when it happens, we can move on


1276
00:32:26,166 --> 00:32:27,146
to the most important question


1277
00:32:27,146 --> 00:32:28,956
of all, which is when should you


1278
00:32:28,956 --> 00:32:29,586
care about it.


1279
00:32:29,736 --> 00:32:30,506
And the answer is really


1280
00:32:30,506 --> 00:32:31,116
straightforward.


1281
00:32:31,416 --> 00:32:32,466
When you measure it negatively


1282
00:32:32,466 --> 00:32:33,966
impacting your app.


1283
00:32:35,676 --> 00:32:36,906
Specifically, when you take a


1284
00:32:37,026 --> 00:32:37,856
time profile or trace an


1285
00:32:37,856 --> 00:32:39,206
instrument, pay special


1286
00:32:39,206 --> 00:32:40,416
attention to where your code


1287
00:32:40,416 --> 00:32:41,736
crosses between the languages,


1288
00:32:41,946 --> 00:32:42,956
especially when this happens


1289
00:32:42,956 --> 00:32:44,236
inside a loop.


1290
00:32:44,956 --> 00:32:45,736
Some bridging is going to


1291
00:32:45,736 --> 00:32:47,196
happen, and that's totally okay.


1292
00:32:47,596 --> 00:32:48,586
What you're looking for though


1293
00:32:48,976 --> 00:32:50,456
is a disproportionate amount of


1294
00:32:50,526 --> 00:32:51,626
time or a surprising amount of


1295
00:32:51,696 --> 00:32:53,106
time spent in code that you


1296
00:32:53,106 --> 00:32:54,486
didn't write that has the word


1297
00:32:54,486 --> 00:32:55,026
bridge in it.


1298
00:32:56,556 --> 00:32:57,346
Let's look at a concrete


1299
00:32:57,406 --> 00:32:58,376
example.


1300
00:32:58,886 --> 00:33:00,186
Suppose I have a manuscript for


1301
00:33:00,186 --> 00:33:01,746
a great children's story that


1302
00:33:01,746 --> 00:33:02,646
I'm working on, but it's really


1303
00:33:02,646 --> 00:33:03,516
long, so I'm only going to show


1304
00:33:03,516 --> 00:33:05,086
a little bit here, but to really


1305
00:33:05,086 --> 00:33:07,486
make it pop, I want to make


1306
00:33:07,756 --> 00:33:09,646
every word or every instance of


1307
00:33:09,646 --> 00:33:11,006
the word brown actually be the


1308
00:33:11,006 --> 00:33:12,596
color brown, and in the interest


1309
00:33:12,596 --> 00:33:13,636
of space, I'm only going to show


1310
00:33:13,636 --> 00:33:14,636
highlighting the first word.


1311
00:33:14,846 --> 00:33:17,386
To do this, I'm going to use an


1312
00:33:17,386 --> 00:33:18,486
NS mutable attributed string.


1313
00:33:18,806 --> 00:33:21,666
I'll pass my story in there.


1314
00:33:21,926 --> 00:33:23,566
And then using the attributed


1315
00:33:23,566 --> 00:33:25,266
strings string property, I'll


1316
00:33:25,266 --> 00:33:26,416
ask for the range of the Swift


1317
00:33:26,416 --> 00:33:28,206
string brown, which will produce


1318
00:33:28,206 --> 00:33:29,886
a range of strings native index


1319
00:33:29,886 --> 00:33:30,086
type.


1320
00:33:30,656 --> 00:33:32,466
And as mutable string works with


1321
00:33:32,556 --> 00:33:33,626
NS ranges, and so I'll use the


1322
00:33:33,626 --> 00:33:34,916
convenience initializer that we


1323
00:33:34,916 --> 00:33:37,526
introduced last year to convert


1324
00:33:37,586 --> 00:33:39,626
to an NS range, and this, I'm


1325
00:33:39,626 --> 00:33:41,756
calling again attributed strings


1326
00:33:41,926 --> 00:33:43,606
string property to do the


1327
00:33:43,606 --> 00:33:44,006
conversion.


1328
00:33:44,296 --> 00:33:45,296
And then we'll color the first


1329
00:33:45,466 --> 00:33:46,396
instance of the word brown.


1330
00:33:47,156 --> 00:33:48,206
And when I go to run this code,


1331
00:33:48,206 --> 00:33:49,636
I notice it's a little slow.


1332
00:33:50,916 --> 00:33:52,526
So I profile it.


1333
00:33:52,526 --> 00:33:54,516
And I see that, to my surprise,


1334
00:33:54,516 --> 00:33:55,296
I thought all the time would be


1335
00:33:55,296 --> 00:33:56,436
spent coloring the word brown,


1336
00:33:56,436 --> 00:33:57,306
but indeed, it's actually


1337
00:33:57,306 --> 00:33:58,366
computing the indices, and why


1338
00:33:58,366 --> 00:33:58,676
is that?


1339
00:33:59,306 --> 00:34:01,416
And the reason for that is that


1340
00:34:01,416 --> 00:34:02,256
we're actually bridging our


1341
00:34:02,256 --> 00:34:03,766
string multiple times across


1342
00:34:03,766 --> 00:34:04,306
languages.


1343
00:34:04,576 --> 00:34:05,976
Mutable attributed string is an


1344
00:34:05,976 --> 00:34:08,295
objective-C reference type, and


1345
00:34:08,295 --> 00:34:09,766
so when we're asking for the


1346
00:34:09,766 --> 00:34:10,826
string property, we're actually


1347
00:34:10,826 --> 00:34:11,646
having to convert from an


1348
00:34:11,646 --> 00:34:12,366
NSString to a string.


1349
00:34:12,585 --> 00:34:15,326
And we're doing it once here


1350
00:34:15,326 --> 00:34:16,335
when we calculated the first


1351
00:34:16,335 --> 00:34:17,505
range, and we're doing it a


1352
00:34:17,505 --> 00:34:18,466
second time when we convert for


1353
00:34:18,466 --> 00:34:19,166
the NSRange.


1354
00:34:19,516 --> 00:34:21,726
You can imagine how expensive


1355
00:34:21,766 --> 00:34:22,996
this would be if we did this in


1356
00:34:22,996 --> 00:34:24,505
a loop looking for all the text


1357
00:34:24,505 --> 00:34:24,886
to color.


1358
00:34:24,886 --> 00:34:26,556
Now let's look into why this is


1359
00:34:26,556 --> 00:34:26,946
happening.


1360
00:34:27,556 --> 00:34:28,876
Every time I call text.string,


1361
00:34:29,206 --> 00:34:30,545
we start in a Swift execution


1362
00:34:30,585 --> 00:34:31,106
context.


1363
00:34:31,795 --> 00:34:33,025
However, the implementation of


1364
00:34:33,025 --> 00:34:34,056
NSMutableAttributedString is


1365
00:34:34,056 --> 00:34:35,496
objective-C, and so in order to


1366
00:34:35,496 --> 00:34:37,076
provide the result, we actually


1367
00:34:37,076 --> 00:34:38,466
have to consult the original


1368
00:34:38,466 --> 00:34:39,085
implementation.


1369
00:34:40,436 --> 00:34:41,716
The original implementation


1370
00:34:41,716 --> 00:34:43,596
returns an NSString, which is


1371
00:34:43,596 --> 00:34:44,856
the reference type, and so when


1372
00:34:44,856 --> 00:34:46,606
return to string, it needs to be


1373
00:34:47,565 --> 00:34:48,996
bridged, graphing cluster by


1374
00:34:48,996 --> 00:34:51,295
graphing cluster, character by


1375
00:34:51,295 --> 00:34:51,775
character.


1376
00:34:51,775 --> 00:34:55,085
And bridging happens whether


1377
00:34:55,646 --> 00:34:57,596
it's a return type or a


1378
00:34:57,596 --> 00:34:58,000
parameter.


1379
00:35:01,246 --> 00:35:02,336
So now that we know those


1380
00:35:02,456 --> 00:35:04,706
details, we can make, now we can


1381
00:35:04,706 --> 00:35:06,176
actually make this a little bit


1382
00:35:06,176 --> 00:35:06,366
better.


1383
00:35:06,466 --> 00:35:07,526
Let's just bridge once.


1384
00:35:07,836 --> 00:35:11,116
And let's remeasure our code and


1385
00:35:11,116 --> 00:35:12,256
see that indeed we've improved


1386
00:35:12,256 --> 00:35:13,126
our performance by half.


1387
00:35:13,696 --> 00:35:14,996
But it turns out this year we


1388
00:35:14,996 --> 00:35:15,676
can do a little better.


1389
00:35:16,676 --> 00:35:18,286
Oh, and also, now we're not


1390
00:35:18,286 --> 00:35:19,076
bridging where we do that.


1391
00:35:19,546 --> 00:35:20,626
But this year we can do a little


1392
00:35:20,626 --> 00:35:21,036
bit better.


1393
00:35:21,616 --> 00:35:23,126
This year, if we actually


1394
00:35:23,266 --> 00:35:24,256
[inaudible] to an NSString when


1395
00:35:24,256 --> 00:35:25,436
we ask for the text.string's


1396
00:35:25,466 --> 00:35:26,356
property, when we get the


1397
00:35:26,356 --> 00:35:28,246
variable out, no bridging is


1398
00:35:28,246 --> 00:35:29,176
actually going to occur.


1399
00:35:30,656 --> 00:35:32,486
And further, by doing so, now


1400
00:35:32,486 --> 00:35:35,216
that string is an NSString, when


1401
00:35:35,216 --> 00:35:36,356
we call the range of property,


1402
00:35:36,436 --> 00:35:37,406
we're actually going to get an


1403
00:35:37,406 --> 00:35:39,996
NSRange out of it automatically.


1404
00:35:39,996 --> 00:35:40,956
We won't need to do any of the


1405
00:35:40,956 --> 00:35:42,116
range conversion between Swift


1406
00:35:42,116 --> 00:35:44,896
native types and the NS ranges,


1407
00:35:44,896 --> 00:35:46,466
which is pretty excellent.


1408
00:35:46,646 --> 00:35:47,526
So let's measure this code and


1409
00:35:47,526 --> 00:35:48,966
see how it is, and sure enough,


1410
00:35:49,206 --> 00:35:49,936
this looks pretty good.


1411
00:35:50,156 --> 00:35:51,226
Much, much faster than the, you


1412
00:35:51,226 --> 00:35:52,816
know, almost 800 milliseconds


1413
00:35:52,816 --> 00:35:53,516
that we were consuming


1414
00:35:53,516 --> 00:35:54,126
previously.


1415
00:35:54,346 --> 00:35:56,396
However, I do want to point out


1416
00:35:56,396 --> 00:35:57,366
that we're still bridging here.


1417
00:35:57,656 --> 00:35:58,896
And it's a teeny, tiny bridge,


1418
00:35:59,616 --> 00:36:00,346
but we're still bridging.


1419
00:36:01,406 --> 00:36:03,456
Brown here is a Swift value type


1420
00:36:03,456 --> 00:36:03,786
string.


1421
00:36:04,956 --> 00:36:07,976
And every time we call into the


1422
00:36:07,976 --> 00:36:09,526
objective-C API range of


1423
00:36:09,606 --> 00:36:10,376
[inaudible] NSString, we're


1424
00:36:10,376 --> 00:36:11,896
actually going to bridge that


1425
00:36:11,896 --> 00:36:13,236
teeny, tiny string back to an


1426
00:36:13,236 --> 00:36:13,686
NSString.


1427
00:36:14,966 --> 00:36:15,886
This is inexpensive in this


1428
00:36:15,886 --> 00:36:16,066
case.


1429
00:36:16,066 --> 00:36:17,546
I'm only doing it once, but you


1430
00:36:17,606 --> 00:36:18,696
can imagine, if this was in a


1431
00:36:18,696 --> 00:36:20,206
loop, that small amount would


1432
00:36:20,206 --> 00:36:21,006
add up over time.


1433
00:36:21,156 --> 00:36:23,246
And so you want to take care to


1434
00:36:23,476 --> 00:36:24,486
avoid bridging the same small


1435
00:36:24,486 --> 00:36:25,246
strings repeatedly.


1436
00:36:25,546 --> 00:36:26,446
However, before you do such


1437
00:36:26,446 --> 00:36:28,056
optimizations, always measure.


1438
00:36:29,476 --> 00:36:30,516
And so now that we've seen the


1439
00:36:30,516 --> 00:36:31,406
details of bridging, I want to


1440
00:36:31,406 --> 00:36:32,346
offer a little bit of advice


1441
00:36:32,346 --> 00:36:33,616
about when to use Foundation


1442
00:36:33,616 --> 00:36:34,196
collections.


1443
00:36:34,686 --> 00:36:36,836
You should consider using them


1444
00:36:36,946 --> 00:36:38,106
explicitly when you need a


1445
00:36:38,106 --> 00:36:39,096
collection with reference


1446
00:36:39,096 --> 00:36:39,756
semantics.


1447
00:36:40,606 --> 00:36:41,496
Don't need to write one of those


1448
00:36:41,496 --> 00:36:42,596
for yourself, we already have


1449
00:36:42,666 --> 00:36:43,326
many great ones.


1450
00:36:43,326 --> 00:36:44,956
You should also use it when


1451
00:36:44,956 --> 00:36:45,796
you're working with types that


1452
00:36:45,796 --> 00:36:46,876
you know to be reference types.


1453
00:36:47,076 --> 00:36:48,636
Things like NS proxies or core


1454
00:36:48,636 --> 00:36:49,716
data managed objects.


1455
00:36:49,956 --> 00:36:52,066
And the final time to consider


1456
00:36:52,066 --> 00:36:53,386
using them is when you're round


1457
00:36:53,386 --> 00:36:54,816
tripping with objective-C code,


1458
00:36:55,216 --> 00:36:56,486
but I'd recommend strongly doing


1459
00:36:56,486 --> 00:36:58,416
this only after you've measured


1460
00:36:58,416 --> 00:36:59,506
and identified that bridging is


1461
00:36:59,506 --> 00:37:00,516
indeed the culprit for whatever


1462
00:37:00,516 --> 00:37:01,546
performance problems you may be


1463
00:37:01,546 --> 00:37:01,906
seeing.


1464
00:37:03,396 --> 00:37:05,076
And now, we've reached the end


1465
00:37:05,076 --> 00:37:06,416
of today's dive into the


1466
00:37:06,416 --> 00:37:07,906
incredible power of our world's


1467
00:37:07,906 --> 00:37:08,786
collections in Swift.


1468
00:37:08,836 --> 00:37:10,946
I want you to use this new-found


1469
00:37:10,946 --> 00:37:12,356
understanding to review your


1470
00:37:12,356 --> 00:37:13,656
existing use of collections.


1471
00:37:14,046 --> 00:37:15,086
Look for places where you can


1472
00:37:15,086 --> 00:37:16,316
improve your code through more


1473
00:37:16,316 --> 00:37:17,716
effective use of indices and


1474
00:37:17,716 --> 00:37:18,196
slices.


1475
00:37:18,926 --> 00:37:19,756
Measure your code.


1476
00:37:20,656 --> 00:37:21,716
And look for places where you


1477
00:37:21,716 --> 00:37:23,586
could benefit by being lazy or


1478
00:37:24,196 --> 00:37:25,786
by tuning how you bridge.


1479
00:37:26,966 --> 00:37:28,526
Use the thread sanitizer to help


1480
00:37:28,556 --> 00:37:30,766
audit your mutable state, and


1481
00:37:30,766 --> 00:37:31,866
further hone your mastery of


1482
00:37:31,866 --> 00:37:33,066
collections by apply all the


1483
00:37:33,066 --> 00:37:34,256
concepts discussed today in


1484
00:37:34,306 --> 00:37:36,646
Playgrounds and you own apps.


1485
00:37:37,876 --> 00:37:38,986
Be sure to visit our last few


1486
00:37:38,986 --> 00:37:39,946
labs today if you have any


1487
00:37:39,946 --> 00:37:41,016
questions about collections.


1488
00:37:41,166 --> 00:37:41,796
We're here to help.


1489
00:37:42,676 --> 00:37:43,666
Thank you so much for you time.


1490
00:37:43,836 --> 00:37:44,856
Now go out and be effective.


1491
00:37:45,508 --> 00:37:47,508
[ Applause ]

