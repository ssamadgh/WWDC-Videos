1
00:00:24,116 --> 00:00:24,536
>> ANDERS BERTELRUD:
Good morning.


2
00:00:25,316 --> 00:00:26,326
My name is Anders.


3
00:00:26,326 --> 00:00:28,736
I would like to welcome
you to session 404,


4
00:00:29,266 --> 00:00:30,266
App Thinning in Xcode.


5
00:00:30,266 --> 00:00:33,926
Now, app thinning
has been mentioned


6
00:00:33,926 --> 00:00:35,626
on this stage several
times this week,


7
00:00:35,746 --> 00:00:38,506
but judging from your questions
and the number of questions


8
00:00:38,506 --> 00:00:40,316
in the lab yesterday, a lot


9
00:00:40,316 --> 00:00:41,716
of you are interested
and have questions.


10
00:00:42,496 --> 00:00:45,036
So we are going to go into a
lot more detail in this session.


11
00:00:45,886 --> 00:00:47,536
In particular we
are going to talk


12
00:00:47,536 --> 00:00:51,046
about how app thinning
affects today's app


13
00:00:51,046 --> 00:00:52,116
distribution pipeline.


14
00:00:52,536 --> 00:00:54,796
We'll look at how it works today
and how it is being improved.


15
00:00:56,126 --> 00:00:58,376
We are going to talk about
what you can do in order


16
00:00:58,376 --> 00:01:01,036
to make app thinning as
efficient as possible.


17
00:01:01,556 --> 00:01:03,616
And to make your apps
as small as possible.


18
00:01:03,616 --> 00:01:06,936
Then we are going to talk
about what this means


19
00:01:06,936 --> 00:01:09,186
for your work flow
as you develop


20
00:01:09,186 --> 00:01:13,666
and test your applications and
submit them to the App Store.


21
00:01:13,876 --> 00:01:15,456
So very quickly let's
take a look


22
00:01:15,456 --> 00:01:17,916
at how app distribution
works today.


23
00:01:17,946 --> 00:01:20,516
You use Xcode and
build and iOS app.


24
00:01:21,216 --> 00:01:23,876
You test it and submit
it to the App Store.


25
00:01:25,196 --> 00:01:27,216
When you submit it,
the app is signed


26
00:01:27,216 --> 00:01:30,086
with the developer certificate
so we know it came from you.


27
00:01:30,636 --> 00:01:33,976
After it has been approved,
the App Store re-signs it


28
00:01:34,066 --> 00:01:37,456
with the store certificate and
hosts it for apps to download.


29
00:01:39,836 --> 00:01:43,696
So along comes a device
and downloads your app.


30
00:01:43,696 --> 00:01:47,486
What it gets is exactly the
same thing as what you uploaded.


31
00:01:47,856 --> 00:01:49,486
Let's take a look
at what's in that.


32
00:01:50,126 --> 00:01:52,636
First of all, there's your
executable code, of course.


33
00:01:53,116 --> 00:01:56,106
And there's resources, broadly
everything can be categorized


34
00:01:56,726 --> 00:01:57,956
into that.


35
00:01:58,156 --> 00:02:01,146
Some of your apps are code
heavy, have a lot of code


36
00:02:01,146 --> 00:02:04,366
and not so many resources
and others are the other way


37
00:02:04,366 --> 00:02:07,266
around where they are media
rich and have some code


38
00:02:07,336 --> 00:02:08,316
but it's mostly assets.


39
00:02:09,166 --> 00:02:13,926
We are going to take a look
at one of those as an example.


40
00:02:14,006 --> 00:02:17,996
Now, with your code you
most likely have 64-bit


41
00:02:17,996 --> 00:02:19,106
and 32-bit versions.


42
00:02:19,106 --> 00:02:20,826
In fact, you may have RMV7.


43
00:02:20,946 --> 00:02:26,786
RMV7 has NRV 64 slices in order
to run as well as possible


44
00:02:26,786 --> 00:02:29,336
on all the hardware
that Apple shares.


45
00:02:29,886 --> 00:02:34,436
Of course, your assets, if
you have images, you will want


46
00:02:34,436 --> 00:02:39,516
to use 1X, 2X, and 3X, Retina,
art work to look as great


47
00:02:39,516 --> 00:02:43,956
as possible on every
type of device.


48
00:02:44,116 --> 00:02:46,226
You may further differentiate
the art work


49
00:02:46,406 --> 00:02:48,416
so that you have some
for the iPhone idiom


50
00:02:48,636 --> 00:02:49,966
and others for the iPad idiom.


51
00:02:50,536 --> 00:02:57,756
If you have a game or other 3D
graphics oriented app, maybe 1X,


52
00:02:57,796 --> 00:03:01,626
2X doesn't mean as much to
you as text compression does


53
00:03:02,296 --> 00:03:04,376
and number of polygons.


54
00:03:04,946 --> 00:03:09,236
In fact, if you want to
take advantage of OpenGL AS


55
00:03:09,236 --> 00:03:11,416
and metal, you may
have different assets,


56
00:03:11,416 --> 00:03:14,666
different textures for that, and
you may further differentiate


57
00:03:14,666 --> 00:03:18,406
between low quality and high
quality so you run as well


58
00:03:18,406 --> 00:03:20,336
as possible and look
as great as possible


59
00:03:20,336 --> 00:03:23,276
on whatever device you have
depending on the memory


60
00:03:23,276 --> 00:03:24,306
and graphics capability.


61
00:03:24,306 --> 00:03:28,176
You probably have audio as
well and you may differentiate


62
00:03:28,176 --> 00:03:29,636
that too in terms of bit rates.


63
00:03:30,206 --> 00:03:35,436
Of course, there's other data
such as the levels of your game.


64
00:03:35,736 --> 00:03:38,446
Or if you have a
documented application,


65
00:03:38,446 --> 00:03:40,486
you might have templates
and other information


66
00:03:40,906 --> 00:03:43,976
that doesn't make sense to
differentiate by device.


67
00:03:43,976 --> 00:03:46,876
It is the same for all devices.


68
00:03:46,966 --> 00:03:49,026
And many real world
apps actually have a bit


69
00:03:49,026 --> 00:03:49,476
of everything.


70
00:03:49,986 --> 00:03:54,336
So you may have spent a lot of
good effort categorizing things


71
00:03:54,336 --> 00:03:57,286
into asset catalogs,
annotating your assets


72
00:03:57,286 --> 00:03:59,426
so the right ones get
loaded on the right device.


73
00:03:59,986 --> 00:04:00,836
That's great.


74
00:04:01,016 --> 00:04:04,056
That's actually what app
slicing takes advantage of.


75
00:04:04,816 --> 00:04:06,416
If you have an ipad Mini,


76
00:04:07,696 --> 00:04:14,916
at runtime it will load the RMV7
slice, for the iPad, et cetera.


77
00:04:14,916 --> 00:04:18,676
What we are doing with app
slicing is making the runtime


78
00:04:18,676 --> 00:04:22,125
decision of what assets to load,
moving that up into the store.


79
00:04:22,886 --> 00:04:26,946
Right now the content goes onto
the device, always is stored


80
00:04:26,946 --> 00:04:29,056
on the device, even though
it will never be loaded


81
00:04:29,386 --> 00:04:34,886
on an iPad 1, so the RM 64 slice
won't get used on the ipad Mini.


82
00:04:35,516 --> 00:04:38,206
Therefore, why send it at all?


83
00:04:39,916 --> 00:04:42,806
So in the store, it is going


84
00:04:42,806 --> 00:04:48,036
to prebuild a version
tailored for the ipad Mini.


85
00:04:48,236 --> 00:04:50,686
Same thing with an iPhone 6+.


86
00:04:50,686 --> 00:04:53,786
In that case, we have 3X
art work, RM 64, et cetera.


87
00:04:54,396 --> 00:04:55,926
Similar thing.


88
00:04:55,926 --> 00:04:57,266
What is important to note here,


89
00:04:57,266 --> 00:05:01,686
you still will be uploading
one universal app with all


90
00:05:01,686 --> 00:05:05,346
of the different variants of
art work and other resources


91
00:05:05,746 --> 00:05:08,576
as you have today, and
it is in the App Store


92
00:05:08,576 --> 00:05:10,386
that the slicing happens.


93
00:05:11,096 --> 00:05:14,396
And what the App Store
does actually is to look


94
00:05:14,396 --> 00:05:17,146
at all the different device
traits of the different devices


95
00:05:17,206 --> 00:05:18,566
that your app can support.


96
00:05:19,186 --> 00:05:21,476
Then it looks at the
actual content of your app


97
00:05:21,876 --> 00:05:25,436
to see how you annotated
it with 1X, 2X, et cetera,


98
00:05:25,436 --> 00:05:29,846
and it builds premade, separate
IPAs that get downloaded.


99
00:05:30,256 --> 00:05:33,096
Let's take a look at an
example you've seen already,


100
00:05:33,556 --> 00:05:38,076
which is demo box, which was
shown in the state of the union.


101
00:05:38,076 --> 00:05:40,086
In this case, we have an app


102
00:05:40,436 --> 00:05:44,026
that is 74-megabytes
when built universal.


103
00:05:44,136 --> 00:05:47,916
That is for all architectures
and for all types of devices.


104
00:05:49,416 --> 00:05:52,856
And by thinning it
out, we get between 16


105
00:05:52,856 --> 00:05:55,466
and 29-megabytes,
22 on the average.


106
00:05:55,466 --> 00:05:58,446
This is an app that
we run the slicing on.


107
00:05:58,806 --> 00:06:00,886
There is actually 19 different
variants that are produced


108
00:06:00,886 --> 00:06:02,896
for all the various
combinations of traits.


109
00:06:03,266 --> 00:06:07,626
All of that happens invisibly
to you or without your effort.


110
00:06:07,626 --> 00:06:10,366
That happens just by how
you annotated your contents


111
00:06:10,366 --> 00:06:10,966
of the app.


112
00:06:11,286 --> 00:06:13,676
So that's one level of savings.


113
00:06:13,676 --> 00:06:14,866
That's pretty good.


114
00:06:14,866 --> 00:06:15,996
Can we do better?


115
00:06:16,456 --> 00:06:18,196
Of course, the answer is yes.


116
00:06:18,806 --> 00:06:20,996
There are some things
that we want


117
00:06:20,996 --> 00:06:23,256
to have all the time
on the device.


118
00:06:23,506 --> 00:06:24,896
So the code, for one thing.


119
00:06:25,366 --> 00:06:28,306
Then there may be some art work,
like a story board that is shown


120
00:06:28,306 --> 00:06:32,626
when you launch your app or
some art work for a main menu,


121
00:06:32,626 --> 00:06:34,156
let's say, that you'll
always want to have there.


122
00:06:35,066 --> 00:06:38,396
Then there are these
other things that yeah,


123
00:06:38,566 --> 00:06:41,436
this app will need, but it is
not going to need it right now.


124
00:06:41,606 --> 00:06:44,836
A typical example that you've
heard before is level 19


125
00:06:44,836 --> 00:06:45,376
of a game.


126
00:06:45,826 --> 00:06:47,406
The user who is beginning


127
00:06:47,406 --> 00:06:49,616
to just play level 1 is
not going to need that yet.


128
00:06:50,596 --> 00:06:52,016
There are other examples, too.


129
00:06:52,016 --> 00:06:53,756
There could be media
rich templates


130
00:06:53,756 --> 00:06:55,416
if you have a document
rich application.


131
00:06:55,776 --> 00:06:58,536
You may want to ship
a lot of those.


132
00:06:58,766 --> 00:07:02,306
In order to provide a rich
experience, you may have a lot


133
00:07:02,306 --> 00:07:04,476
of templates, but they
might take a lot of space.


134
00:07:04,476 --> 00:07:05,836
You may want to load
those on-demand.


135
00:07:06,236 --> 00:07:11,376
Same with audio for instruments,
those kinds of things.


136
00:07:11,376 --> 00:07:13,556
There is a good example
of tutorial


137
00:07:13,606 --> 00:07:16,136
that the user may watch once,
and you don't want it to take


138
00:07:16,136 --> 00:07:17,366
up space on the device anymore.


139
00:07:18,276 --> 00:07:21,246
If we take a look at one of
the slices that we talked


140
00:07:21,246 --> 00:07:24,006
about before, it already
has been thinned down,


141
00:07:24,006 --> 00:07:25,916
sliced so it has
one architecture


142
00:07:26,286 --> 00:07:32,346
and it has one quality
variant of every type of asset.


143
00:07:33,356 --> 00:07:36,686
The next level of partitioning
we can do is something


144
00:07:36,686 --> 00:07:41,526
that only you know based on the
particular domain of your app,


145
00:07:41,796 --> 00:07:44,466
which is what you are going
to need at any given time,


146
00:07:44,646 --> 00:07:46,536
because that is based on
the logic in your code.


147
00:07:47,356 --> 00:07:51,336
So in this example,
we have images,


148
00:07:51,676 --> 00:07:53,586
Metal shaders, those
kind of things.


149
00:07:53,926 --> 00:07:55,986
We can divide those into
those that are shared


150
00:07:56,096 --> 00:07:59,256
and always needed that we want
to keep in the app itself.


151
00:07:59,806 --> 00:08:02,316
We can have things
that come in on demand.


152
00:08:03,506 --> 00:08:09,756
By splitting this up, then you
can actually shrink the base


153
00:08:09,756 --> 00:08:12,166
footprint of your app and
still have access to content.


154
00:08:13,376 --> 00:08:16,746
In this particular case, the
asset packs that are built


155
00:08:16,786 --> 00:08:20,116
by Xcode based on your
asset tags get moved off.


156
00:08:20,726 --> 00:08:23,826
They are stored separately
from your IPA in the App Store.


157
00:08:24,916 --> 00:08:26,936
You can download them on-demand.


158
00:08:27,546 --> 00:08:29,326
You can designate some
of them as being part


159
00:08:29,326 --> 00:08:31,946
of the initial download so when
the user downloads the appear


160
00:08:31,946 --> 00:08:34,196
app and see the progress
bar go to 100 percent,


161
00:08:34,956 --> 00:08:37,206
by the time they are ready
to startnusing your app,


162
00:08:37,306 --> 00:08:39,116
they already have some
of the initial content.


163
00:08:40,126 --> 00:08:43,976
You can bring in more
content on-demand as needed.


164
00:08:44,536 --> 00:08:48,156
Now, this is not stored in
your app's bundle on the device


165
00:08:48,156 --> 00:08:51,606
and also not on the container
that gets backed up to iCloud.


166
00:08:51,716 --> 00:08:55,306
This is stored in memory
managed by the system


167
00:08:55,906 --> 00:08:58,456
that can cache the
on-demand resources


168
00:08:58,456 --> 00:09:00,726
from the different
applications on the device.


169
00:09:01,896 --> 00:09:03,246
So now in this case if you,


170
00:09:03,246 --> 00:09:06,426
in this scenario we
actually have space


171
00:09:06,426 --> 00:09:07,956
to have more than three levels.


172
00:09:07,956 --> 00:09:10,226
We can have more levels
than would normally fit


173
00:09:10,226 --> 00:09:11,816
if you didn't use
on-demand resources.


174
00:09:12,506 --> 00:09:15,736
When we bring in level 4, the
system can automatically get rid


175
00:09:15,736 --> 00:09:20,096
of the least recentl used asset
pack containing your level


176
00:09:20,096 --> 00:09:20,936
1 resources.


177
00:09:21,616 --> 00:09:22,636
Same thing for level 5.


178
00:09:23,746 --> 00:09:26,646
Of course, if the user hasn't
used your app for awhile


179
00:09:26,816 --> 00:09:29,616
and some other app needs to
download on-demand resources,


180
00:09:29,976 --> 00:09:31,346
it can reclaim the space.


181
00:09:31,346 --> 00:09:32,736
When your app is used again,


182
00:09:32,736 --> 00:09:35,806
it will be downloaded
one more time.


183
00:09:36,026 --> 00:09:38,706
So some things about
on-demand resources.


184
00:09:39,486 --> 00:09:43,036
You build asset packs by
tagging assets in Xcode.


185
00:09:43,036 --> 00:09:45,216
You saw a brief demo
of this in the state


186
00:09:45,216 --> 00:09:47,296
of the union yesterday.


187
00:09:47,726 --> 00:09:49,126
And there will be
a whole session


188
00:09:49,126 --> 00:09:50,816
on on-demand resources
later today.


189
00:09:50,816 --> 00:09:56,796
Asset packs can contain
any nonexecutable assets.


190
00:09:57,586 --> 00:10:00,696
App slicing works on
the asset catalogs


191
00:10:00,696 --> 00:10:01,896
in the assets you've
put in there.


192
00:10:02,246 --> 00:10:04,586
For on-demand resources you
can have any loose files


193
00:10:04,586 --> 00:10:06,556
and tag them, and they will
be part of the asset packs,


194
00:10:06,626 --> 00:10:08,286
downloaded from the App Store.


195
00:10:08,286 --> 00:10:09,606
They're hosted by the App Store.


196
00:10:10,026 --> 00:10:12,846
You submit it all together
to the App Store as part


197
00:10:12,846 --> 00:10:16,216
of one IPA, but the App
Store splits it apart


198
00:10:17,206 --> 00:10:18,326
and hosts it separately.


199
00:10:19,586 --> 00:10:22,806
They are downloaded when
needed based on your code.


200
00:10:23,186 --> 00:10:24,926
They are reclaimed as necessary.


201
00:10:26,276 --> 00:10:29,156
And they are sliced just
like all the other content.


202
00:10:29,706 --> 00:10:32,306
So you can put asset
packs in there.


203
00:10:32,426 --> 00:10:37,286
In fact, if you tag assets
that are in asset packs,


204
00:10:37,286 --> 00:10:42,296
Xcode will automatically build
them for you in asset catalogs.


205
00:10:42,826 --> 00:10:47,236
Let's take a look at
the size savings --


206
00:10:47,236 --> 00:10:51,076
oh, right, there will be
a session this afternoon


207
00:10:51,076 --> 00:10:53,166
which will be in
Pacific Heights at 4:30.


208
00:10:54,186 --> 00:10:56,996
Let's take a look at what kind
of slice savings we get then.


209
00:10:57,116 --> 00:11:00,386
After slicing, we had
on average 22 megabytes


210
00:11:00,386 --> 00:11:02,546
for one of the slices.


211
00:11:03,336 --> 00:11:06,076
In this case, we get
down to between 11


212
00:11:06,076 --> 00:11:08,016
and 18-megabytes
depending on the device


213
00:11:08,406 --> 00:11:11,556
for the core application and
the assets themselves are


214
00:11:11,556 --> 00:11:12,856
between 5 and 11.


215
00:11:13,356 --> 00:11:16,336
The point is that
not all of those are


216
00:11:16,566 --> 00:11:18,206
on the device at the same time.


217
00:11:19,016 --> 00:11:21,716
So the sum total is about
eight megabytes in this case.


218
00:11:21,716 --> 00:11:23,716
This is a fairly small
app that you can see


219
00:11:23,716 --> 00:11:27,206
that for a large application
especially one with lots


220
00:11:27,816 --> 00:11:31,706
of media, the savings
really add up.


221
00:11:32,526 --> 00:11:33,666
Some obvious advantages


222
00:11:33,666 --> 00:11:36,466
of making your app smaller
is a better user experience.


223
00:11:36,876 --> 00:11:39,606
There are affordable devices
that have eight gigabytes


224
00:11:39,706 --> 00:11:42,496
of storage, and you really want
to make the most use of that.


225
00:11:42,596 --> 00:11:43,996
You don't want anything
on the device


226
00:11:43,996 --> 00:11:47,166
that isn't actually
going to be needed.


227
00:11:47,776 --> 00:11:51,446
By using app thinning, you can
support more of those devices.


228
00:11:52,646 --> 00:11:55,956
Also this means shorter
download times, less to send


229
00:11:55,956 --> 00:11:57,306
over the wire which is great.


230
00:11:57,856 --> 00:12:00,386
That makes it easier for you
to stay under the 100-megabyte


231
00:12:00,826 --> 00:12:04,646
over the air size limit,
the cellular limit.


232
00:12:05,966 --> 00:12:07,616
What this means really
for you is


233
00:12:07,616 --> 00:12:10,756
that you can support more types
of devices with less compromise.


234
00:12:10,756 --> 00:12:13,746
If you have been thinking about
I really want to use Metal


235
00:12:13,746 --> 00:12:16,616
and run great on high powered
devices but I also want


236
00:12:16,616 --> 00:12:20,036
to be able to use the
less powerful devices,


237
00:12:20,036 --> 00:12:23,696
have customers run well
on those, what do I do?


238
00:12:23,836 --> 00:12:25,946
This frees you from
some of that compromise.


239
00:12:25,946 --> 00:12:30,606
You can now submit, it matters
a lot less how much you submit


240
00:12:30,606 --> 00:12:36,116
to the store as it does what
each user gets from the store.


241
00:12:37,316 --> 00:12:38,226
What this means for you


242
00:12:38,226 --> 00:12:42,226
in the longer term is you
can actually now use some


243
00:12:42,226 --> 00:12:44,666
of that reclaimed space
to add those features


244
00:12:44,666 --> 00:12:46,546
that you couldn't fit
in because of size.


245
00:12:47,016 --> 00:12:49,056
This doesn't mean you
make it huge again,


246
00:12:49,356 --> 00:12:52,236
but it means it is less
compromise for you when you look


247
00:12:52,236 --> 00:12:57,596
at your size versus the things
you want to put into your app.


248
00:12:57,996 --> 00:13:01,476
So after that overview, I
would like to ask Patrick,


249
00:13:01,586 --> 00:13:03,266
my colleague Patrick Heynen
to come in and give you some


250
00:13:03,266 --> 00:13:03,976
of the details on
how to do that.


251
00:13:04,516 --> 00:13:09,906
[Applause]


252
00:13:10,406 --> 00:13:11,696
>> PATRICK HEYNEN:
Thank you, Anders.


253
00:13:11,766 --> 00:13:12,426
Hi. I'm Patrick Heynen.


254
00:13:12,426 --> 00:13:13,746
I would like to talk
a little bit more


255
00:13:13,746 --> 00:13:17,176
in detail about asset slicing.


256
00:13:17,476 --> 00:13:18,216
How does it work?


257
00:13:20,546 --> 00:13:22,576
Well, I'm happy to
say that asset slicing


258
00:13:22,576 --> 00:13:24,376
and app thinning have
been seamlessly integrated


259
00:13:24,376 --> 00:13:27,456
into all the build, publish and
export and workflows of Xcode


260
00:13:27,456 --> 00:13:28,866
that you may already be familiar


261
00:13:28,866 --> 00:13:30,376
with in building
your applications.


262
00:13:32,026 --> 00:13:34,636
All that really happens


263
00:13:34,636 --> 00:13:37,606
to actually make you
realize asset slicing


264
00:13:37,606 --> 00:13:39,656
and app thinning is that
we do a post process


265
00:13:39,786 --> 00:13:42,426
of your build products,
of your asset catalog


266
00:13:42,526 --> 00:13:47,096
and executable files
to tailor the variants


267
00:13:47,096 --> 00:13:48,276
for all the different devices


268
00:13:48,276 --> 00:13:49,196
that you are trying
to build for.


269
00:13:51,216 --> 00:13:53,526
So what do you need to do?


270
00:13:54,646 --> 00:13:58,186
Well, the good news is that you
are probably doing it already,


271
00:13:58,326 --> 00:13:59,146
or doing it already.


272
00:13:59,916 --> 00:14:03,756
If you have been developing
iOS apps for a while,


273
00:14:03,756 --> 00:14:06,276
you have already been
incorporating 1X, 2X,


274
00:14:06,276 --> 00:14:09,106
and 3X art work to capture
the range of displays


275
00:14:09,446 --> 00:14:14,136
on the embedded devices and may
even be using asset catalogs


276
00:14:14,136 --> 00:14:16,776
which have been around
since iOS 7.


277
00:14:18,516 --> 00:14:20,226
That's really all
you need to have.


278
00:14:20,906 --> 00:14:24,176
What are asset catalogs
and what role do they play?


279
00:14:25,206 --> 00:14:26,886
Asset catalogues are a facility


280
00:14:26,886 --> 00:14:29,046
to organize your
resources according


281
00:14:29,046 --> 00:14:31,346
to the relevant device
traits of those resources


282
00:14:31,346 --> 00:14:33,246
that they are important
and pertinent for.


283
00:14:34,956 --> 00:14:36,336
There's an important note here.


284
00:14:37,226 --> 00:14:39,046
In order to take
advantage of app thinning,


285
00:14:39,336 --> 00:14:42,746
your resources must be
contained within asset catalogs.


286
00:14:43,186 --> 00:14:45,116
We do not thin loose resources.


287
00:14:45,836 --> 00:14:50,196
This is not as strong a
constraint as you might imagine.


288
00:14:50,196 --> 00:14:51,446
I'll get to that
in a little moment.


289
00:14:51,886 --> 00:14:52,956
It is an important note.


290
00:14:54,746 --> 00:14:56,416
So I mentioned device traits.


291
00:14:56,876 --> 00:15:00,656
So in the asset catalog
world, devices have a key set


292
00:15:00,656 --> 00:15:03,656
of characteristics for which
assets can be optimized for.


293
00:15:04,166 --> 00:15:06,286
These include things that
you are familiar with,


294
00:15:06,286 --> 00:15:11,016
screen resolutions, 2X and
3X and also device family.


295
00:15:11,416 --> 00:15:15,756
Whether it is an iPad or
an iPhone device idiom.


296
00:15:16,336 --> 00:15:22,446
New to iOS 9 in Xcode 7, we
are also exposing a new set


297
00:15:22,446 --> 00:15:24,316
of device traits that are based


298
00:15:24,316 --> 00:15:26,656
on the hardware characteristics
of our devices.


299
00:15:27,276 --> 00:15:30,926
In particular, graphics
capabilities and memory levels.


300
00:15:31,696 --> 00:15:33,556
This really arises
out of two needs.


301
00:15:33,556 --> 00:15:37,296
One, the range of devices we
support now have a huge range


302
00:15:37,506 --> 00:15:38,966
of performance characteristics,


303
00:15:38,966 --> 00:15:41,516
different between the lowest end
device and highest end device.


304
00:15:41,516 --> 00:15:45,296
It is not the case that a single
resource is appropriate for all


305
00:15:45,706 --> 00:15:47,666
of those classes of devices.


306
00:15:47,726 --> 00:15:50,856
It becomes really hard to make
the right compromise in terms


307
00:15:50,856 --> 00:15:53,986
of what your end user
experience is going to be.


308
00:15:53,986 --> 00:15:55,966
The same goes for memory levels


309
00:15:55,966 --> 00:15:58,686
between the low end
and high end devices.


310
00:15:58,686 --> 00:16:00,776
The new device traits
allow you to tailor assets


311
00:16:01,136 --> 00:16:04,966
to those different capabilities.


312
00:16:04,966 --> 00:16:08,076
What kind of content goes
into an asset catalog?


313
00:16:09,586 --> 00:16:12,356
Well, the most popular
by far is the one


314
00:16:12,356 --> 00:16:15,436
that we debuted asset catalogs
with, and that's named images.


315
00:16:16,906 --> 00:16:21,656
This basically is your art work
resources for your application


316
00:16:22,586 --> 00:16:26,586
in typically bitmap resources
or vectors, in the png,


317
00:16:26,586 --> 00:16:30,016
jpg or pdf format that you
integrate into your project.


318
00:16:30,466 --> 00:16:34,876
These get compiled into an
optimized delivery format using


319
00:16:34,876 --> 00:16:36,236
advanced compression codex


320
00:16:36,296 --> 00:16:40,226
with really good space saving
characteristics and delivered


321
00:16:40,226 --> 00:16:46,076
to your application
through the UI kit APIs.


322
00:16:46,296 --> 00:16:52,986
New to iOS 9 and Xcode
7 is a new data class,


323
00:16:53,606 --> 00:16:54,886
at least one new data class.


324
00:16:55,476 --> 00:16:56,746
That is name data.


325
00:16:57,746 --> 00:16:58,456
What is this for?


326
00:16:59,366 --> 00:17:03,216
Name data allows you to
store arbitrary file content.


327
00:17:04,586 --> 00:17:06,626
Now, this in fact
alleviates some


328
00:17:06,626 --> 00:17:08,256
of the concern you might
have had at my statement


329
00:17:08,256 --> 00:17:10,656
that we only thin asset
catalogue based content.


330
00:17:10,925 --> 00:17:14,465
You ask: What if I'm trying to
thin non-image based resources?


331
00:17:14,636 --> 00:17:15,955
That is what name data is for.


332
00:17:16,236 --> 00:17:19,175
It allows you to put any
arbitrary file content stored


333
00:17:19,175 --> 00:17:22,226
in your asset catalog
and classified according


334
00:17:22,226 --> 00:17:24,715
to those hardware capabilities
I mentioned to you earlier.


335
00:17:27,195 --> 00:17:30,516
And then at runtime you use
the new NS DataAsset class


336
00:17:30,596 --> 00:17:34,796
in the UI kit in OS X, by the
way, to retrieve this content


337
00:17:34,796 --> 00:17:35,686
into your application.


338
00:17:37,096 --> 00:17:39,596
Brief side bar here
for a moment.


339
00:17:39,826 --> 00:17:44,306
The asset catalog features
I'm describing, the name data


340
00:17:44,306 --> 00:17:48,246
and some of the ones coming up,
are available in OS X as well.


341
00:17:48,466 --> 00:17:50,326
We don't thin applications
for OS X,


342
00:17:50,326 --> 00:17:52,856
but since at the catalog store
our source artifact formats are


343
00:17:52,856 --> 00:17:55,296
intended to capture your
sources across all your targets,


344
00:17:55,296 --> 00:17:57,186
including possibly
OS X and Watch.


345
00:17:57,666 --> 00:17:59,266
All these features work there.


346
00:17:59,266 --> 00:18:01,486
The APIs are present
on all the platforms.


347
00:18:01,936 --> 00:18:04,096
Just the thinning is
particular to iOS.


348
00:18:04,706 --> 00:18:05,476
Side bar end.


349
00:18:07,166 --> 00:18:10,896
There's another new exciting
data class that we introduced


350
00:18:11,126 --> 00:18:14,246
in Xcode 7 and iOS 9 and
that's Sprite atlases.


351
00:18:15,366 --> 00:18:18,726
What this represents is
an exciting combination


352
00:18:19,026 --> 00:18:24,236
of asset catalogs and
SpriteKit, allowing you


353
00:18:24,236 --> 00:18:27,346
to organize your image
assets in the normal way


354
00:18:27,346 --> 00:18:29,136
in asset catalogs,
and group them,


355
00:18:29,386 --> 00:18:32,136
name them into a Sprite atlas,


356
00:18:32,536 --> 00:18:36,086
and what this does is
automatically creates texture


357
00:18:36,086 --> 00:18:38,416
atlases at build time
that you can retrieve


358
00:18:38,476 --> 00:18:42,166
through the SK texture atlas
class from those image assets.


359
00:18:42,866 --> 00:18:44,296
The key thing here is,


360
00:18:44,686 --> 00:18:49,156
if you have done all the usual
organization on iPhone, iPad,


361
00:18:50,036 --> 00:18:52,886
it will automatically
create a thinned version


362
00:18:53,406 --> 00:18:58,886
of those compiled texture
atlases and treat those


363
00:18:58,886 --> 00:19:02,436
as thinnable resources that
will be thinned automatically


364
00:19:02,706 --> 00:19:04,886
by the App Store and by the
other workflows I'm going


365
00:19:04,886 --> 00:19:07,806
to talk about in a moment.


366
00:19:07,956 --> 00:19:12,356
So how do we get from asset
catalogs to app thinning?


367
00:19:12,456 --> 00:19:13,476
Well, it is really quite simple


368
00:19:13,506 --> 00:19:14,616
and you may have
guessed it already.


369
00:19:15,196 --> 00:19:18,176
Every asset in the asset catalog
has trademark up information


370
00:19:18,456 --> 00:19:20,396
that describes what
characteristics


371
00:19:20,436 --> 00:19:23,046
that resource is
pertinent and useful for.


372
00:19:23,676 --> 00:19:28,136
At build time when we
do the post processing,


373
00:19:28,676 --> 00:19:30,956
these traits are used
to route those resources


374
00:19:30,956 --> 00:19:32,706
to the relevant thinned
app variants.


375
00:19:32,706 --> 00:19:35,566
It's as simple as that.


376
00:19:35,636 --> 00:19:37,336
I would like to point
out an important note.


377
00:19:37,336 --> 00:19:40,526
Asset catalogs have
been around for awhile.


378
00:19:40,526 --> 00:19:42,206
They have always given
you the ability at runtime


379
00:19:42,206 --> 00:19:44,846
to select the right resource
appropriate at runtime


380
00:19:44,846 --> 00:19:47,986
to the device that's
requesting that resource.


381
00:19:48,566 --> 00:19:50,516
It is this very same algorithm


382
00:19:50,516 --> 00:19:53,776
and the very same selection
criteria used to do the routing


383
00:19:53,776 --> 00:19:55,166
of the rich thinned
app variants.


384
00:19:55,386 --> 00:19:58,136
If your application is behaving
correctly today on a range


385
00:19:58,136 --> 00:20:01,156
of devices, odds are it will
work well with app thinning,


386
00:20:01,656 --> 00:20:03,966
because it is reallythe
same mechanism.


387
00:20:04,716 --> 00:20:08,786
Okay. I mentioned
the word organization


388
00:20:08,996 --> 00:20:11,176
in conjunction a
little while ago.


389
00:20:11,226 --> 00:20:13,676
I would like to emphasize
that for a moment.


390
00:20:14,126 --> 00:20:18,046
Cataloging efficiently in asset
catalogs is absolutely key.


391
00:20:18,936 --> 00:20:19,536
Why is that?


392
00:20:19,936 --> 00:20:23,516
Because a robust mark up
of your resources means


393
00:20:23,516 --> 00:20:25,036
that there is less redundancy


394
00:20:25,036 --> 00:20:27,326
in the slice application
variants that are produced.


395
00:20:28,066 --> 00:20:31,106
You don't have extra
payload being produced


396
00:20:31,106 --> 00:20:34,926
in those app variants that
are never going to be used


397
00:20:34,926 --> 00:20:37,916
at runtime on the target device
that app variant is built for.


398
00:20:39,366 --> 00:20:42,586
For example, even though it
might have worked perfectly


399
00:20:42,586 --> 00:20:46,206
before, it may not make sense
to leave an asset as universal


400
00:20:46,206 --> 00:20:48,086
if they are only used
on one device family.


401
00:20:48,326 --> 00:20:52,056
Consider, for example, some
button art work for a pop


402
00:20:52,056 --> 00:20:54,826
over UI for your iPad
version of your app,


403
00:20:54,826 --> 00:20:57,306
but that never gets presented


404
00:20:57,306 --> 00:20:59,116
on the iPhone versions
of the application.


405
00:20:59,396 --> 00:21:00,876
It would have worked
fine before to have it


406
00:21:00,876 --> 00:21:02,606
as a universal asset
and drop it in there.


407
00:21:02,886 --> 00:21:06,356
However, it may now be a good
idea to revisit and categorize


408
00:21:06,356 --> 00:21:08,746
that appropriately so you
don't have it delivered


409
00:21:08,746 --> 00:21:10,116
to the iPhone versions
of your apps


410
00:21:10,406 --> 00:21:14,316
where it doesn't
make much sense.


411
00:21:14,316 --> 00:21:17,616
Okay. So those are the basics.


412
00:21:17,616 --> 00:21:19,986
Those are the theories
of how this system works.


413
00:21:19,986 --> 00:21:23,786
Let's get practical and talk
about some real world workflows


414
00:21:23,826 --> 00:21:25,016
and how this impacts them.


415
00:21:25,876 --> 00:21:28,566
Let's talk first about creation.


416
00:21:28,566 --> 00:21:30,136
How do you create
asset catalogs?


417
00:21:30,796 --> 00:21:34,246
The predominant way in which you
create asset catalog content is


418
00:21:34,246 --> 00:21:36,346
through the asset
catalog editor in Xcode.


419
00:21:38,076 --> 00:21:41,346
This is easy to use user
interface in the IDE.


420
00:21:41,346 --> 00:21:44,566
You may be familiar with it.


421
00:21:44,566 --> 00:21:49,996
All it takes to create a new
asset is to add a new item,


422
00:21:51,846 --> 00:21:53,606
and there's a range
you can see here.


423
00:21:53,606 --> 00:21:56,606
Here we see the data sets, image
sets, Sprite atlases as well


424
00:21:56,606 --> 00:21:59,196
as the other data types
for other platforms.


425
00:21:59,196 --> 00:22:04,046
When you add this to your
project, you are presented


426
00:22:04,046 --> 00:22:06,656
with an organization array
and spectrum on the left


427
00:22:06,656 --> 00:22:09,206
that shows you the device traits
that you can catalogue under,


428
00:22:09,206 --> 00:22:12,746
and expose how varied
and diverse you want


429
00:22:12,746 --> 00:22:14,136
to provide resources for.


430
00:22:14,706 --> 00:22:18,166
You drop your assets into
the appropriate wells,


431
00:22:18,586 --> 00:22:23,056
and you are off to the
races, and you're done.


432
00:22:23,276 --> 00:22:23,956
So that's great.


433
00:22:24,006 --> 00:22:25,086
That's really easy to use.


434
00:22:25,986 --> 00:22:30,066
What if your team cannot use
Xcode for asset production?


435
00:22:30,506 --> 00:22:34,636
What if you are a game studio
that has a heavy investment


436
00:22:34,636 --> 00:22:36,736
in an existing asset
tool chain or pipeline


437
00:22:36,936 --> 00:22:39,496
where it is not practical
to put Xcode in front


438
00:22:39,496 --> 00:22:42,046
of the content engineers or the
designers that are producing


439
00:22:42,046 --> 00:22:45,556
and are needing to attribute
the art work appropriately?


440
00:22:46,726 --> 00:22:50,086
I'm happy to say that
we consider this,


441
00:22:50,646 --> 00:22:53,716
and we carefully designed
the asset catalog feature


442
00:22:53,716 --> 00:22:56,506
in conjunction with thinning
to accommodate these scenarios.


443
00:22:57,986 --> 00:23:00,166
Specifically, we've
designed it in a way


444
00:23:00,166 --> 00:23:03,946
where it should be very easy to
export image sets and data sets


445
00:23:03,946 --> 00:23:05,526
from existing asset pipelines.


446
00:23:06,796 --> 00:23:07,996
How are we going
to accomplish this?


447
00:23:07,996 --> 00:23:11,806
We are going to do this
through the XC asset source


448
00:23:11,836 --> 00:23:12,716
artifact format.


449
00:23:13,386 --> 00:23:16,296
I'm happy to say that we
are going to be documenting


450
00:23:16,706 --> 00:23:19,646
and publishing to allow
external tool chains


451
00:23:19,646 --> 00:23:22,856
to implement this format easily.


452
00:23:23,446 --> 00:23:27,376
Now, it really is
not much of a format


453
00:23:27,376 --> 00:23:30,216
because it is a simple folder
structure in JSON markup


454
00:23:30,216 --> 00:23:31,336
and really easy to work with.


455
00:23:32,146 --> 00:23:37,806
I want to emphasize, this is
not some kind of import format


456
00:23:37,806 --> 00:23:40,546
that you sort of create and
then you import into Xcode


457
00:23:40,546 --> 00:23:42,086
and then it becomes
a project artifact.


458
00:23:42,386 --> 00:23:44,776
This is literally the
source artifact format


459
00:23:44,776 --> 00:23:46,936
that the Xcode build
system works with natively


460
00:23:47,466 --> 00:23:49,266
at build time to process


461
00:23:49,266 --> 00:23:51,356
and produce your final
runtime artifacts.


462
00:23:52,426 --> 00:23:56,306
Let's take a look at what
this means in detail.


463
00:23:56,876 --> 00:24:00,006
We take the previous example


464
00:24:00,006 --> 00:24:02,536
of the AirPlay icon
art work and look.


465
00:24:02,536 --> 00:24:03,966
This is what it looks
like on disk.


466
00:24:04,006 --> 00:24:05,156
This is in fact the format.


467
00:24:05,726 --> 00:24:06,336
Very simple.


468
00:24:06,916 --> 00:24:09,496
All it consists of is a
folder naming convention,


469
00:24:09,496 --> 00:24:10,866
consisting of the
name of the asset,


470
00:24:10,866 --> 00:24:13,456
this is the name you
retrieve it from in code


471
00:24:13,546 --> 00:24:18,506
with UI image names, and
then the individual art work


472
00:24:18,506 --> 00:24:21,096
resources contained
within that folder.


473
00:24:21,876 --> 00:24:24,476
And I want to point out that
even though this particular


474
00:24:24,476 --> 00:24:27,626
example uses a pretty well-known
semi-canonical file naming


475
00:24:27,626 --> 00:24:30,306
convention for showing scale
factor and device idiom,


476
00:24:30,886 --> 00:24:33,976
there is no requirement
to have any specific file


477
00:24:33,976 --> 00:24:34,556
naming convention.


478
00:24:34,556 --> 00:24:36,756
You can use whatever is
natural to your workflow


479
00:24:36,756 --> 00:24:38,416
or tool chain or
whatever you like.


480
00:24:39,276 --> 00:24:39,946
Why is that?


481
00:24:40,496 --> 00:24:42,896
Because there's this all
important third element


482
00:24:42,976 --> 00:24:45,276
to this design, which is
the contents.JSON file.


483
00:24:45,856 --> 00:24:50,366
The contents.JSON
file is the file


484
00:24:50,366 --> 00:24:52,666
that contains all the
asset markup information


485
00:24:52,666 --> 00:24:54,026
and joins everything together


486
00:24:54,026 --> 00:24:56,876
and tells the system
what traits are relevant


487
00:24:56,936 --> 00:24:59,346
for a particular resource.


488
00:25:00,126 --> 00:25:01,846
So if we were to actually look


489
00:25:01,846 --> 00:25:06,186
at the AirPlay icon
example we showed


490
00:25:06,186 --> 00:25:08,916
in the Xcode editor before,
this is what it looks like.


491
00:25:09,416 --> 00:25:11,316
As you can see, it
is straightforward.


492
00:25:11,316 --> 00:25:14,316
It is just an array of
the individual images.


493
00:25:14,316 --> 00:25:18,706
You can see the individual file
names and then the device idiom


494
00:25:18,776 --> 00:25:20,656
and scale factor
markup information.


495
00:25:21,306 --> 00:25:24,146
These properties, these key
value pairs that you see here,


496
00:25:24,146 --> 00:25:26,106
these are the things
that will be documented


497
00:25:26,106 --> 00:25:27,836
in the SES source
artifact format.


498
00:25:28,626 --> 00:25:33,436
Taking the example one
level further, name data,


499
00:25:33,576 --> 00:25:36,626
what we call data sets,
look unsurprisingly similar.


500
00:25:37,376 --> 00:25:39,506
Again, the file names are


501
00:25:39,506 --> 00:25:42,786
for the individual resources are
there and then the attribution


502
00:25:42,786 --> 00:25:45,206
of universal type
identifier and memory


503
00:25:45,276 --> 00:25:48,666
or graphics future set class.


504
00:25:50,216 --> 00:25:52,396
And you can see it is really
quite easy to work with.


505
00:25:52,396 --> 00:25:54,326
You can see from
the way this works,


506
00:25:54,326 --> 00:25:56,886
how they join the file
names with the properties


507
00:25:57,326 --> 00:26:00,056
that this is why it doesn't
matter what file name you put


508
00:26:00,056 --> 00:26:03,236
into those data sets
and image sets.


509
00:26:03,336 --> 00:26:07,776
What is important is that you
get this contents.JSON correct.


510
00:26:08,776 --> 00:26:10,576
What does this allow you to do?


511
00:26:10,576 --> 00:26:12,236
What is this for?


512
00:26:12,776 --> 00:26:16,056
I would like to work through
a hypothetical example here


513
00:26:16,056 --> 00:26:18,486
of image set creation
with Xcode.


514
00:26:18,986 --> 00:26:20,456
The hypothetical
workflow I'm going


515
00:26:20,456 --> 00:26:22,986
to show here is using the
PhotoShop CC generator


516
00:26:22,986 --> 00:26:23,606
in PhotoShop.


517
00:26:26,526 --> 00:26:29,766
So let's say your designer
created beautiful art work


518
00:26:29,766 --> 00:26:32,696
and they decided iPads
are going to be blue today


519
00:26:32,696 --> 00:26:33,886
and iPhones will be red.


520
00:26:33,886 --> 00:26:35,106
That's just the way we roll.


521
00:26:35,726 --> 00:26:37,466
Designers do that sometimes.


522
00:26:37,596 --> 00:26:41,526
They have the beautiful
master file and they set


523
00:26:41,526 --> 00:26:44,206
out all these variants here.


524
00:26:44,446 --> 00:26:47,186
They actually set
their master file


525
00:26:47,186 --> 00:26:49,316
up with a generator workflow,


526
00:26:49,316 --> 00:26:50,996
turned on image asset
generation,


527
00:26:51,456 --> 00:26:53,766
and have their layer
list constructed


528
00:26:53,946 --> 00:26:57,496
with the appropriate naming
coventions and default layer


529
00:26:57,896 --> 00:27:00,216
to export directly
into an image set,


530
00:27:00,996 --> 00:27:03,996
and they have a special hacked
version of the generator


531
00:27:04,396 --> 00:27:07,456
that they carefully extended,
this is the hypothetical piece


532
00:27:07,456 --> 00:27:10,836
of my example, to
produce the contents.JSON.


533
00:27:10,836 --> 00:27:15,096
Here is what the output would
be from the PhotoShop workflow.


534
00:27:15,546 --> 00:27:17,506
For those who used
generator before,


535
00:27:17,816 --> 00:27:20,656
the photo layout
will be familiar.


536
00:27:20,656 --> 00:27:21,706
There is the assets folder.


537
00:27:21,996 --> 00:27:25,556
Inside is the image
set that was generated,


538
00:27:25,656 --> 00:27:30,566
all of the different art work
entities and the contents.JSON.


539
00:27:30,566 --> 00:27:34,006
All of that is required to make
this work is drag that image set


540
00:27:34,006 --> 00:27:35,626
over and drop it
into the folder,


541
00:27:35,626 --> 00:27:39,766
underneath the XE assets folder
and you're off to the races.


542
00:27:40,326 --> 00:27:42,986
That's it.


543
00:27:43,356 --> 00:27:46,256
A few words about this
kind of dynamic integration


544
00:27:46,256 --> 00:27:47,186
with your Xcode project.


545
00:27:48,076 --> 00:27:50,906
The only requirement is


546
00:27:50,906 --> 00:27:53,656
that your project must
have an XE asset folder.


547
00:27:53,946 --> 00:27:55,176
That's really the
only requirement


548
00:27:55,176 --> 00:27:58,396
from a project file level, from
an Xcode project file level.


549
00:27:59,656 --> 00:28:04,976
Anything contained within that
can have an arbitrary hierarchy,


550
00:28:04,976 --> 00:28:05,856
arbitrary structure.


551
00:28:06,446 --> 00:28:09,896
It has to conform to the image
set and data set, you can nest


552
00:28:09,926 --> 00:28:12,456
that arbitrarily deep and you
can use your own file system


553
00:28:12,456 --> 00:28:14,406
organization underneath that.


554
00:28:14,406 --> 00:28:18,016
At build time, Xcode
will recursively descend


555
00:28:18,256 --> 00:28:21,066
that hierarchy, discover all
the image sets and data sets,


556
00:28:21,066 --> 00:28:24,366
the spread atlases and
automatically build them,


557
00:28:24,656 --> 00:28:27,476
providing that you
authored the image sets


558
00:28:27,476 --> 00:28:31,316
and data sets correctly.


559
00:28:32,316 --> 00:28:34,386
Now we know how to
create asset catalogs.


560
00:28:35,106 --> 00:28:38,786
Let's move to the
next step, building.


561
00:28:39,246 --> 00:28:40,716
So perhaps the most common


562
00:28:40,716 --> 00:28:43,216
and most important
build workflow is just


563
00:28:43,216 --> 00:28:44,676
when you are sitting
there working


564
00:28:44,676 --> 00:28:47,116
on your app you have a tether
device or you are working


565
00:28:47,116 --> 00:28:49,346
in a simulator, working
on a feature.


566
00:28:49,756 --> 00:28:51,296
How does thinning apply
in that situation?


567
00:28:52,026 --> 00:28:54,596
I'm happy to say that the build


568
00:28:54,596 --> 00:28:57,496
and run workflow
automatically thins resources


569
00:28:57,496 --> 00:29:01,666
for the currently active
run destination in Xcode.


570
00:29:02,706 --> 00:29:05,106
So what this means is that
every time you hit build,


571
00:29:05,106 --> 00:29:08,406
it is actually only going
to consider and produce


572
00:29:08,406 --> 00:29:12,336
and automatically create the
proper runtime asset catalog


573
00:29:12,696 --> 00:29:15,666
for the target device
that you are using.


574
00:29:16,296 --> 00:29:19,876
And this is supported
for all simulator


575
00:29:19,876 --> 00:29:21,386
and device run destinations.


576
00:29:22,476 --> 00:29:24,256
So it is a really great way


577
00:29:24,256 --> 00:29:28,166
to immediately take
advantage of thinning.


578
00:29:29,676 --> 00:29:33,056
This functionality is also
triggered by or controlled


579
00:29:33,056 --> 00:29:35,076
by a new build setting
that has been exposed


580
00:29:35,076 --> 00:29:37,466
in the asset catalog
sections of the target editor.


581
00:29:37,466 --> 00:29:40,326
It is called enable building
only active resources.


582
00:29:40,816 --> 00:29:42,486
This is handy.


583
00:29:42,536 --> 00:29:45,206
What if you're trying to figure


584
00:29:45,206 --> 00:29:47,896
out if a problem is being
introduced by thinning


585
00:29:47,896 --> 00:29:49,826
or what the impact of
thinning is overall


586
00:29:49,826 --> 00:29:51,146
on a particular target device.


587
00:29:51,666 --> 00:29:57,406
You can toggle this on
and off for that purpose.


588
00:29:57,596 --> 00:29:59,926
Some other benefits of
this build workflow is


589
00:29:59,926 --> 00:30:02,496
that it dramatically
can speed up iterative


590
00:30:02,496 --> 00:30:04,726
or incremental builds especially


591
00:30:04,726 --> 00:30:06,486
if your application
is very content heavy.


592
00:30:06,946 --> 00:30:11,146
It really only processes
and works with the resources


593
00:30:11,146 --> 00:30:13,506
that are appropriate for that
target device at the time.


594
00:30:13,506 --> 00:30:15,406
It doesn't have to go through
everything like it used


595
00:30:15,406 --> 00:30:17,046
to before when it was
building universal,


596
00:30:17,426 --> 00:30:19,366
a universal version
of your application.


597
00:30:20,836 --> 00:30:22,576
Another key benefit
is this allows you


598
00:30:22,576 --> 00:30:25,356
to easily test the impact
of cataloging changes


599
00:30:25,666 --> 00:30:26,646
on the thinned outputs


600
00:30:26,646 --> 00:30:28,516
for a particular device
or set of devices.


601
00:30:28,946 --> 00:30:32,046
If you are trying to understand
the impact of the sizing


602
00:30:32,046 --> 00:30:35,586
of your overall built
application or other aspects


603
00:30:35,586 --> 00:30:38,846
of your user experience, you can
make those cataloging changes


604
00:30:38,956 --> 00:30:41,436
quickly, build and
run for that device


605
00:30:41,436 --> 00:30:43,736
and then check other
devices by switching


606
00:30:43,736 --> 00:30:47,136
between the other devices and
the run destination in Xcode


607
00:30:47,416 --> 00:30:53,366
and test those changes
fairly quickly and easily.


608
00:30:53,736 --> 00:30:54,716
Now we've covered build.


609
00:30:55,726 --> 00:30:56,506
What's next?


610
00:30:56,696 --> 00:30:57,946
Well, distribution.


611
00:30:57,996 --> 00:31:01,986
This is the essential
step involved


612
00:31:02,036 --> 00:31:03,256
with thinned applications.


613
00:31:05,626 --> 00:31:08,416
Now, there are many
ways that we allow you


614
00:31:08,416 --> 00:31:10,216
to distribute your
iOS applications.


615
00:31:11,116 --> 00:31:13,246
Enable you to distribute
your iOS applications.


616
00:31:13,606 --> 00:31:15,786
The biggest and most
significant one, of course,


617
00:31:15,786 --> 00:31:18,086
is the one that your end
users, the customers are using


618
00:31:18,696 --> 00:31:19,786
through the App Store purchase.


619
00:31:20,166 --> 00:31:21,586
This is the mechanism
Anders alluded


620
00:31:21,586 --> 00:31:25,646
to where you supply
your universal IPA.


621
00:31:26,236 --> 00:31:27,376
The store does the work,


622
00:31:27,486 --> 00:31:30,636
processes all the
thinned variants.


623
00:31:30,636 --> 00:31:32,006
When the user is
purchasing the app,


624
00:31:32,036 --> 00:31:34,906
it's going to automatically
select the right device variant


625
00:31:34,906 --> 00:31:36,466
from the store, and
download and installs it.


626
00:31:36,466 --> 00:31:37,536
You're done, fully automatic.


627
00:31:38,206 --> 00:31:38,896
Nothing to worry about.


628
00:31:39,946 --> 00:31:42,926
Before you release the
application, you may want


629
00:31:42,926 --> 00:31:45,196
to make that same exact
experience available


630
00:31:45,196 --> 00:31:47,696
to your beta C testers.


631
00:31:48,286 --> 00:31:50,556
We will be supporting test
distribution through --


632
00:31:50,556 --> 00:31:52,876
thinned distribution
through TestFlight as well.


633
00:31:52,876 --> 00:31:58,486
Then, of course, there is ad
hoc and enterprise distribution


634
00:31:58,486 --> 00:32:00,906
which is a very common way for
you to distribute applications


635
00:32:01,246 --> 00:32:03,936
in your organization or to
your team for QA testing


636
00:32:03,936 --> 00:32:04,666
or that kind of thing.


637
00:32:05,516 --> 00:32:08,806
That's an incredibly
important way of distribution.


638
00:32:09,216 --> 00:32:12,166
We have built thinning
support into that as well.


639
00:32:12,406 --> 00:32:15,826
Finally, there's the Xcode
service and ECos server.


640
00:32:16,586 --> 00:32:18,946
That has been upgraded


641
00:32:18,946 --> 00:32:21,556
to support distributing
thinned applications as well.


642
00:32:21,966 --> 00:32:25,486
I'll go into some
details in a moment.


643
00:32:25,826 --> 00:32:29,706
All of the methods I
outlined are fairly automatic.


644
00:32:29,706 --> 00:32:31,796
You don't have to
really do much.


645
00:32:31,796 --> 00:32:34,396
Ad hoc enterprise solution
is something I want


646
00:32:34,396 --> 00:32:35,626
to focus on for a moment.


647
00:32:35,626 --> 00:32:39,456
That is the one where you will
be hosting this distribution


648
00:32:39,866 --> 00:32:43,076
flow yourself and you may need
to understand some of the pieces


649
00:32:43,076 --> 00:32:44,826
of how this is put
together and how it works.


650
00:32:45,436 --> 00:32:46,216
Let's talk about that.


651
00:32:46,216 --> 00:32:46,836
How does that work?


652
00:32:48,776 --> 00:32:52,356
Well, one functionality
we've added to Xcode is


653
00:32:52,356 --> 00:32:53,586
that you can now export


654
00:32:53,586 --> 00:32:55,686
for a specific device
from the organizer.


655
00:32:56,546 --> 00:32:58,856
This is great if you are
trying to test a build


656
00:32:58,856 --> 00:33:01,066
or hand off a build to
somebody with a specific device.


657
00:33:01,066 --> 00:33:03,126
You can immediately
create an IPA


658
00:33:03,126 --> 00:33:05,506
for that specific device
directly from the organizer,


659
00:33:06,066 --> 00:33:10,806
correctly provisioned
for that device.


660
00:33:10,946 --> 00:33:14,776
Coming in a future seed we
will be providing you a way


661
00:33:15,166 --> 00:33:17,716
to export all of the
thinned variants for all


662
00:33:17,716 --> 00:33:21,006
of the compatible devices giving
you one complete distribution


663
00:33:21,006 --> 00:33:22,986
unit for all the possible
supportive devices


664
00:33:22,986 --> 00:33:25,856
of your application
for a given release.


665
00:33:26,136 --> 00:33:27,086
This is important.


666
00:33:27,086 --> 00:33:31,116
You may not know or be
able to generate all


667
00:33:31,116 --> 00:33:32,926
of the thinned variants
for all the devices.


668
00:33:32,926 --> 00:33:35,256
You want to get the full set.


669
00:33:35,706 --> 00:33:39,186
What this will do
is actually process


670
00:33:39,246 --> 00:33:41,736
that universal app build
archive that you have,


671
00:33:42,256 --> 00:33:46,406
produce all of the thinned
variants that are appropriate


672
00:33:46,406 --> 00:33:49,646
for all of the different
compatible devices and put them


673
00:33:49,646 --> 00:33:51,896
into one set of products.


674
00:33:52,446 --> 00:33:57,076
But now you've got a big
bushel full of applications.


675
00:33:57,966 --> 00:34:03,106
You may ask yourself how do
I get the right application


676
00:34:03,106 --> 00:34:04,076
to the right device?


677
00:34:04,496 --> 00:34:05,866
That's kind of a
big problem now.


678
00:34:06,636 --> 00:34:09,656
Well, the most common way that
apps are delivered to devices


679
00:34:09,656 --> 00:34:11,036
with enterprise and
ad hoc, of course,


680
00:34:11,036 --> 00:34:12,266
is over the air installation.


681
00:34:12,266 --> 00:34:15,606
I would like to go through
that and how that works


682
00:34:15,606 --> 00:34:16,456
with thinning for a moment.


683
00:34:16,936 --> 00:34:20,456
The first step is to save for ad
hoc or enterprise distribution.


684
00:34:20,985 --> 00:34:25,136
It is important here that
you include the distribution


685
00:34:25,136 --> 00:34:28,456
manifest option, the check
box on the lower left there.


686
00:34:29,775 --> 00:34:30,576
What does this do?


687
00:34:32,146 --> 00:34:35,616
Well, what this does is
when Xcode is generating


688
00:34:35,616 --> 00:34:37,606
that exported set of IPAs,


689
00:34:37,606 --> 00:34:42,346
it is going to generate a
manifest list containing URLs


690
00:34:42,346 --> 00:34:44,396
for each of the app
variants that it produces.


691
00:34:45,306 --> 00:34:49,186
What's more, it is going
to index all of these URLs


692
00:34:49,306 --> 00:34:52,386
by the supported product
type of that app variant.


693
00:34:53,876 --> 00:34:59,376
The impact of this is that when
a device tries to pull that,


694
00:34:59,376 --> 00:35:00,736
tries to install
one of the apps,


695
00:35:01,066 --> 00:35:05,256
using the over the air
manifest PO list, it will walk


696
00:35:05,256 --> 00:35:08,136
through the list, find the
appropriate URL for its device,


697
00:35:08,236 --> 00:35:11,936
product type, and install
it and pull that one down.


698
00:35:12,376 --> 00:35:12,926
That's how it works.


699
00:35:13,126 --> 00:35:15,296
This is a mechanism
conceptually very similar


700
00:35:15,616 --> 00:35:17,206
to what actually
happens with the store


701
00:35:17,676 --> 00:35:18,706
with your thinned application,


702
00:35:19,036 --> 00:35:21,466
but all of these moving
pieces are all hosted by you


703
00:35:21,866 --> 00:35:24,496
on your Web server and
through the mechanisms produced


704
00:35:24,496 --> 00:35:25,046
by Xcode.


705
00:35:25,586 --> 00:35:28,746
What if we take it
one step even further?


706
00:35:30,006 --> 00:35:32,676
That's what the Xcode server
continuous integration


707
00:35:32,676 --> 00:35:33,326
service does.


708
00:35:33,906 --> 00:35:39,676
What Xcode server
does is it turns all


709
00:35:39,676 --> 00:35:41,296
of this mechanism
I just described


710
00:35:41,296 --> 00:35:43,566
into one turnkey solution
for building, hosting


711
00:35:43,566 --> 00:35:44,946
and distributing thinned apps,


712
00:35:45,166 --> 00:35:49,156
including hosting
on-demand asset packs.


713
00:35:50,926 --> 00:35:52,556
It is quite simple.


714
00:35:52,846 --> 00:35:56,606
The Xcode server, you set up
your integration box in Xcode


715
00:35:56,606 --> 00:35:59,386
in conjunction with your
Xcode server deployment.


716
00:35:59,896 --> 00:36:03,996
The bot builds your application
automatically, produces all


717
00:36:03,996 --> 00:36:06,466
of the variants, produces
the manifest P list


718
00:36:07,066 --> 00:36:10,026
and even wraps a nice
Web service around it


719
00:36:10,026 --> 00:36:13,406
where you point the device
at the Xcode server website


720
00:36:13,406 --> 00:36:17,086
and select a particular build,
all you need to do is click


721
00:36:17,086 --> 00:36:18,886
on the install button and all


722
00:36:18,886 --> 00:36:21,406
of the mechanism I previously
described of referencing


723
00:36:21,406 --> 00:36:23,786
through the manifest P list,
pulling the appropriate variant,


724
00:36:23,786 --> 00:36:25,476
it all happens automatically.


725
00:36:26,546 --> 00:36:28,406
It is simple as pointing
your device at the


726
00:36:28,406 --> 00:36:30,086
to the Web server
portal and going.


727
00:36:30,716 --> 00:36:33,856
I encourage you if
you want to get a feel


728
00:36:33,856 --> 00:36:37,586
for how everything moves around,
when it becomes available,


729
00:36:37,586 --> 00:36:39,166
I encourage you to look at this.


730
00:36:39,166 --> 00:36:41,546
This is the same
pattern you might use


731
00:36:41,546 --> 00:36:45,446
to build your own
enterprise distribution


732
00:36:45,446 --> 00:36:47,926
or ad hoc distribution workflow
where you host things yourself.


733
00:36:48,906 --> 00:36:50,166
None of these pieces are things


734
00:36:50,166 --> 00:36:51,606
that you couldn't
build yourself.


735
00:36:52,476 --> 00:36:56,506
The Xcode service, to
wrap that piece up,


736
00:36:56,506 --> 00:36:59,606
is a streamlined
installation method


737
00:36:59,896 --> 00:37:02,636
for thinned app variants using
the over the air manifest.


738
00:37:03,426 --> 00:37:09,406
Nice, simple solution, one stop.


739
00:37:09,606 --> 00:37:13,526
Okay. So now we've talked about
how to create asset catalogs


740
00:37:13,526 --> 00:37:14,586
to enable app slicing.


741
00:37:15,026 --> 00:37:17,656
We talked about how
that integrates


742
00:37:17,656 --> 00:37:19,616
with your build workflows
and we talked


743
00:37:19,616 --> 00:37:21,306
about the different
methods for distribution


744
00:37:21,306 --> 00:37:22,906
and how app thinning
interacts with those.


745
00:37:23,866 --> 00:37:25,226
With that I will hand it back


746
00:37:25,226 --> 00:37:26,906
over to Anders for
the conclusion.


747
00:37:28,516 --> 00:37:31,526
[Applause]


748
00:37:32,026 --> 00:37:32,626
>> ANDERS BERTELRUD:
Thank you, Patrick.


749
00:37:33,716 --> 00:37:35,556
All right.


750
00:37:35,676 --> 00:37:39,136
So in this session we have seen
quickly how the app distribution


751
00:37:39,136 --> 00:37:44,726
workflow works today, how app
thinning is improving on that;


752
00:37:45,756 --> 00:37:49,276
the ways in which you can
help this be more efficient


753
00:37:49,276 --> 00:37:52,846
by tagging your assets
properly and by using some


754
00:37:52,846 --> 00:37:55,136
of the distribution
features we have.


755
00:37:56,466 --> 00:37:59,556
And what this means for your
workflow in terms of testing


756
00:37:59,556 --> 00:38:00,886
and then submitting
to the App Store.


757
00:38:01,736 --> 00:38:03,886
So a bit of a call
to action here.


758
00:38:04,476 --> 00:38:05,316
What you should do,


759
00:38:05,716 --> 00:38:08,456
keep creating tailored
versions of assets.


760
00:38:08,526 --> 00:38:11,296
That's great because you want
your app to look its very best


761
00:38:11,296 --> 00:38:13,876
and run its very best
on every kind of device.


762
00:38:13,976 --> 00:38:16,366
With app thinning we are
freeing you a little bit


763
00:38:16,366 --> 00:38:19,406
from the size restriction
of uploading now.


764
00:38:20,056 --> 00:38:21,986
Every user is going to
get only what they need.


765
00:38:23,206 --> 00:38:26,066
Keep creating tailored
versions of assets.


766
00:38:26,186 --> 00:38:29,566
Use the asset catalogs
to organize your assets.


767
00:38:29,686 --> 00:38:33,416
You can now also put data
and Sprite atlases in there


768
00:38:33,416 --> 00:38:37,296
and have those tailored for the
device as Patrick mentioned.


769
00:38:39,346 --> 00:38:42,316
Also test your thinned
app variants using Xcode.


770
00:38:42,756 --> 00:38:44,376
This will become important now


771
00:38:44,376 --> 00:38:45,896
because we are only
delivering the bits


772
00:38:45,966 --> 00:38:47,326
that every device needs.


773
00:38:47,406 --> 00:38:51,316
You can do this using Xcode's
destination as Patrick mentioned


774
00:38:51,376 --> 00:38:56,236
and using Xcode server to
build the various thin variants


775
00:38:56,236 --> 00:38:58,706
and testing them
on real devices.


776
00:38:59,276 --> 00:39:06,416
And take advantage of on-demand
resources to tag your assets


777
00:39:06,506 --> 00:39:08,726
and to have those
built into asset packs


778
00:39:08,726 --> 00:39:10,936
for later on-demand loading.


779
00:39:12,356 --> 00:39:17,546
I want to call out a
couple of places to go


780
00:39:17,546 --> 00:39:18,616
for more information here.


781
00:39:18,946 --> 00:39:21,046
One is the app thinning guide,


782
00:39:21,236 --> 00:39:23,496
the chapter in the
app distribution guide


783
00:39:24,096 --> 00:39:27,296
that you will find on the
developer website at Apple,


784
00:39:27,646 --> 00:39:30,296
and the other is the asset
catalogue format documentation


785
00:39:30,296 --> 00:39:32,596
that's going to be put up on
the Apple developer website.


786
00:39:33,136 --> 00:39:36,216
We have related sessions.


787
00:39:36,216 --> 00:39:37,846
The first couple of
ones have already been,


788
00:39:37,846 --> 00:39:39,076
but you can catch them on video.


789
00:39:39,886 --> 00:39:43,066
There is another one, What's
New In SpriteKit that is going


790
00:39:43,066 --> 00:39:45,586
to talk about this
some more starting


791
00:39:45,586 --> 00:39:49,066
in 20 minutes in Mission.


792
00:39:49,066 --> 00:39:51,326
It focuses on the
on-demand resources part


793
00:39:51,586 --> 00:39:53,356
in Pacific Heights
at 4:30 today,


794
00:39:53,356 --> 00:39:54,846
so I encourage you
all to check that out.


795
00:39:55,396 --> 00:39:59,986
And DemoBots will be talked
about in greater detail


796
00:40:00,446 --> 00:40:02,736
in Mission tomorrow at 1:30.


797
00:40:03,686 --> 00:40:04,696
We have a couple of labs.


798
00:40:05,006 --> 00:40:07,896
Come down and see us in the
Labs to learn more about this


799
00:40:07,896 --> 00:40:09,706
and have a great
rest of the WWDC.


800
00:40:10,516 --> 00:40:15,500
[Applause]

