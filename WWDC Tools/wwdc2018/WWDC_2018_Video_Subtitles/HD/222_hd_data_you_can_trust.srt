1
00:00:07,516 --> 00:00:14,500
[ Music ]


2
00:00:22,516 --> 00:00:27,876
[ Applause ]


3
00:00:28,376 --> 00:00:29,146
>> Good morning, everyone.


4
00:00:30,056 --> 00:00:30,976
Thank you all for joining me,


5
00:00:31,116 --> 00:00:32,256
even before the coffee's kicked


6
00:00:32,256 --> 00:00:32,466
in.


7
00:00:33,286 --> 00:00:34,696
My name is Itai and I work on


8
00:00:34,696 --> 00:00:35,456
the foundation team.


9
00:00:36,676 --> 00:00:37,556
In this session, I'd like to


10
00:00:37,556 --> 00:00:39,106
talk to you about how the data


11
00:00:39,106 --> 00:00:40,246
that flows through your app can


12
00:00:40,246 --> 00:00:41,916
affect it, and how you can


13
00:00:41,916 --> 00:00:43,336
better protect your customers by


14
00:00:43,336 --> 00:00:44,806
building trust in that data.


15
00:00:45,926 --> 00:00:46,526
Let's get started.


16
00:00:47,116 --> 00:00:49,696
Apps don't live in a vacuum.


17
00:00:50,536 --> 00:00:51,546
In order for your apps to do


18
00:00:51,546 --> 00:00:52,946
something useful, they have to


19
00:00:52,946 --> 00:00:54,286
draw in data from external


20
00:00:54,286 --> 00:00:55,686
sources, like the disc, or the


21
00:00:55,686 --> 00:00:56,846
network, or your customers


22
00:00:56,846 --> 00:00:57,416
themselves.


23
00:00:57,956 --> 00:00:59,156
And then do something meaningful


24
00:00:59,156 --> 00:01:00,656
with that data, and then present


25
00:01:00,656 --> 00:01:01,466
it to your customers.


26
00:01:02,886 --> 00:01:04,006
In order for that data to be


27
00:01:04,226 --> 00:01:05,856
consumable, it has to come in


28
00:01:05,856 --> 00:01:07,416
some known format or structure.


29
00:01:08,756 --> 00:01:11,796
What happens when it doesn't?


30
00:01:11,886 --> 00:01:13,776
Usually, this means the data is


31
00:01:13,776 --> 00:01:15,326
corrupted, or invalid in some


32
00:01:15,326 --> 00:01:16,196
way and can be ignored.


33
00:01:17,566 --> 00:01:19,486
But sometimes, this data can


34
00:01:19,856 --> 00:01:21,296
invalidate assumptions that your


35
00:01:21,296 --> 00:01:23,346
app makes, and it can cause your


36
00:01:23,346 --> 00:01:25,326
app to misbehave, or maybe even


37
00:01:25,326 --> 00:01:25,746
crash.


38
00:01:26,386 --> 00:01:29,126
This can be a bad experience for


39
00:01:29,126 --> 00:01:30,506
your customers who might have to


40
00:01:30,506 --> 00:01:32,056
wait for your app to get updated


41
00:01:32,056 --> 00:01:32,706
in the app store.


42
00:01:33,566 --> 00:01:34,556
And it's an even worse


43
00:01:34,556 --> 00:01:36,076
experience if it's a crash on


44
00:01:36,076 --> 00:01:37,436
launch, because they can't even


45
00:01:37,436 --> 00:01:38,076
use the app.


46
00:01:38,666 --> 00:01:39,896
And, in the meantime, while


47
00:01:39,896 --> 00:01:41,176
you're waiting, you'll get a


48
00:01:41,176 --> 00:01:42,386
wave of one-star reviews.


49
00:01:43,126 --> 00:01:43,996
It's a bad experience for


50
00:01:43,996 --> 00:01:44,306
everyone.


51
00:01:46,136 --> 00:01:47,386
This is something to be even


52
00:01:47,386 --> 00:01:48,736
more cognizant of, if you're a


53
00:01:48,736 --> 00:01:49,486
framework author.


54
00:01:50,056 --> 00:01:51,356
Because it's not just one app


55
00:01:51,486 --> 00:01:52,706
that could possibly be affected,


56
00:01:53,026 --> 00:01:54,776
but maybe many apps.


57
00:01:56,416 --> 00:01:57,626
Today, we're going to be talking


58
00:01:57,626 --> 00:01:58,276
about trust.


59
00:01:59,186 --> 00:02:00,236
And specifically, we're going to


60
00:02:00,236 --> 00:02:02,026
be talking about how to build


61
00:02:02,026 --> 00:02:03,886
trust in data, by making sure of


62
00:02:03,886 --> 00:02:04,406
two things.


63
00:02:05,796 --> 00:02:07,026
One, that the data that we're


64
00:02:07,026 --> 00:02:08,166
going to be using, hasn't been


65
00:02:08,166 --> 00:02:10,726
modified from underneath us, and


66
00:02:10,726 --> 00:02:12,266
two that it contains what we


67
00:02:12,266 --> 00:02:14,236
expect it to in the format and


68
00:02:14,236 --> 00:02:15,066
structure that we want.


69
00:02:16,676 --> 00:02:19,266
So, we'll do just that by taking


70
00:02:19,266 --> 00:02:20,816
a look at the lifecycle of our


71
00:02:20,816 --> 00:02:22,786
data, and what we can validate


72
00:02:22,786 --> 00:02:24,526
about that data at every stage


73
00:02:24,526 --> 00:02:25,146
in the lifecycle.


74
00:02:26,726 --> 00:02:28,836
Then, we'll see what sort of


75
00:02:28,836 --> 00:02:30,286
type-level validation we can


76
00:02:30,286 --> 00:02:31,606
apply with the NS Secure coding


77
00:02:31,606 --> 00:02:32,016
protocol.


78
00:02:32,096 --> 00:02:33,986
And then apply those same


79
00:02:33,986 --> 00:02:35,626
concepts to codable types.


80
00:02:37,116 --> 00:02:40,256
Let's get started.


81
00:02:40,366 --> 00:02:41,536
In order to talk about data,


82
00:02:41,656 --> 00:02:42,576
we're going to want to build a


83
00:02:42,576 --> 00:02:44,426
mental model of the forms that


84
00:02:44,426 --> 00:02:46,426
data can take within our app.


85
00:02:47,566 --> 00:02:49,626
At the most basic level, data


86
00:02:49,626 --> 00:02:51,786
makes its way into our app as a


87
00:02:51,786 --> 00:02:52,756
stream of bites.


88
00:02:54,336 --> 00:02:55,396
There's not much we can tell


89
00:02:55,396 --> 00:02:56,426
about this data at this stage


90
00:02:56,426 --> 00:02:58,156
without looking at it, but this


91
00:02:58,156 --> 00:03:00,976
we'll call raw data.


92
00:03:01,646 --> 00:03:03,416
Now, to get working with that


93
00:03:03,416 --> 00:03:04,466
data, we need to make sure it


94
00:03:04,536 --> 00:03:06,276
conforms to that known format or


95
00:03:06,276 --> 00:03:06,756
structure.


96
00:03:07,406 --> 00:03:08,946
And in this case, each of those


97
00:03:08,946 --> 00:03:10,906
code points correspond into a


98
00:03:11,006 --> 00:03:13,426
UTF code point, and sorry, one


99
00:03:13,426 --> 00:03:14,186
moment, let me make that a


100
00:03:14,186 --> 00:03:14,876
little bit more readable.


101
00:03:15,416 --> 00:03:16,496
It looks like this is JSON.


102
00:03:17,036 --> 00:03:18,946
And so, once we've made sure


103
00:03:18,946 --> 00:03:20,336
that that data conforms to some


104
00:03:20,336 --> 00:03:21,266
format that we want to work


105
00:03:21,266 --> 00:03:23,106
with, we'll call this formatted


106
00:03:24,506 --> 00:03:24,626
data.


107
00:03:24,976 --> 00:03:26,536
Now, formatted data, on its own


108
00:03:26,896 --> 00:03:28,176
doesn't mean much, until we


109
00:03:28,286 --> 00:03:29,836
create primitive values out of


110
00:03:29,836 --> 00:03:31,366
it, strings, and arrays, and


111
00:03:31,366 --> 00:03:32,676
dictionaries that we can then


112
00:03:32,676 --> 00:03:34,246
use as building blocks for


113
00:03:34,246 --> 00:03:35,036
further algorithms.


114
00:03:35,556 --> 00:03:36,816
So, this we'll call our


115
00:03:36,816 --> 00:03:38,076
primitive data.


116
00:03:39,086 --> 00:03:40,696
Now, there's building blocks we


117
00:03:40,696 --> 00:03:41,876
most often want to work with,


118
00:03:41,946 --> 00:03:43,566
not as just primitive values,


119
00:03:43,936 --> 00:03:45,296
but as our own model types.


120
00:03:46,546 --> 00:03:47,996
So, once we do that, we'll make


121
00:03:48,056 --> 00:03:49,456
use of this as we're going to


122
00:03:49,456 --> 00:03:51,376
call, structure data.


123
00:03:52,016 --> 00:03:54,166
Now, these forms of data in our


124
00:03:54,316 --> 00:03:56,876
apps, form an abstraction


125
00:03:57,346 --> 00:03:57,826
timeline.


126
00:03:59,076 --> 00:04:00,826
Raw data is the least abstract


127
00:04:00,826 --> 00:04:01,846
data that we're going to work


128
00:04:01,846 --> 00:04:03,306
with, and our own structured


129
00:04:03,306 --> 00:04:04,386
model types are the most


130
00:04:04,386 --> 00:04:04,916
abstract.


131
00:04:05,476 --> 00:04:07,266
So, our goal for today is to


132
00:04:07,266 --> 00:04:08,736
take that data as far along the


133
00:04:08,736 --> 00:04:09,916
spectrum as we can.


134
00:04:10,546 --> 00:04:12,096
Now, our apps can stop at any


135
00:04:12,096 --> 00:04:13,256
point, make use of the data,


136
00:04:13,296 --> 00:04:14,156
however, we see fit.


137
00:04:14,256 --> 00:04:15,566
But we really want to work with


138
00:04:15,566 --> 00:04:16,846
our own model types wherever


139
00:04:16,846 --> 00:04:17,286
possible.


140
00:04:18,356 --> 00:04:19,995
Now, the goal for today is to


141
00:04:19,995 --> 00:04:21,696
not just go as far along the


142
00:04:21,696 --> 00:04:23,076
abstraction spectrum as we can,


143
00:04:23,316 --> 00:04:25,546
but to build trust as we do so.


144
00:04:26,466 --> 00:04:27,516
At every stage, the data is


145
00:04:27,516 --> 00:04:28,716
going to get more complicated,


146
00:04:28,786 --> 00:04:30,216
and there's going to be more


147
00:04:30,216 --> 00:04:31,346
that we need to validate about


148
00:04:31,346 --> 00:04:31,413
it.


149
00:04:31,413 --> 00:04:32,966
But once we do that, there's


150
00:04:32,966 --> 00:04:33,836
also going to be more that we


151
00:04:33,836 --> 00:04:35,696
can trust about it.


152
00:04:36,116 --> 00:04:37,686
Now, for our use case today,


153
00:04:37,686 --> 00:04:38,596
we're not really going to be


154
00:04:38,596 --> 00:04:39,696
talking about formatted data.


155
00:04:40,046 --> 00:04:41,626
Very often it's just a stepping


156
00:04:41,626 --> 00:04:42,956
stone between raw and primitive


157
00:04:42,956 --> 00:04:43,916
data, and you don't work with it


158
00:04:43,916 --> 00:04:44,326
directly.


159
00:04:45,256 --> 00:04:47,606
For instance, given raw data,


160
00:04:47,746 --> 00:04:49,256
foundations JSON serialization


161
00:04:49,256 --> 00:04:50,256
will give you primitive data


162
00:04:50,256 --> 00:04:50,516
back.


163
00:04:50,876 --> 00:04:52,276
You don't see just the formatted


164
00:04:52,276 --> 00:04:53,206
date directly, and you won't


165
00:04:53,206 --> 00:04:54,766
make use of it.


166
00:04:54,976 --> 00:04:56,066
So, today we'll just be talking


167
00:04:56,066 --> 00:04:57,676
about raw, primitive, and


168
00:04:57,676 --> 00:04:58,256
structured data.


169
00:05:00,186 --> 00:05:01,186
Now, let's start by talking


170
00:05:01,186 --> 00:05:01,776
about raw data.


171
00:05:02,836 --> 00:05:04,996
Again, as we mentioned, raw data


172
00:05:04,996 --> 00:05:06,486
is just a stream of bytes that's


173
00:05:06,486 --> 00:05:08,496
made its way into your app.


174
00:05:08,496 --> 00:05:10,296
Until you inspect that data and


175
00:05:10,296 --> 00:05:11,586
you give it meaning, there's not


176
00:05:11,586 --> 00:05:13,266
much you can do with it.


177
00:05:13,766 --> 00:05:15,686
Now, we might care to know what


178
00:05:15,716 --> 00:05:17,316
we can take a look at about that


179
00:05:17,316 --> 00:05:18,296
data before we start


180
00:05:18,296 --> 00:05:18,906
interpreting it.


181
00:05:19,366 --> 00:05:20,466
Is it even safe to do that?


182
00:05:22,016 --> 00:05:23,106
One thing we can validate about


183
00:05:23,106 --> 00:05:24,476
this data before making use of


184
00:05:24,476 --> 00:05:25,146
it is its length.


185
00:05:26,306 --> 00:05:27,776
Say your app expects to load a


186
00:05:27,776 --> 00:05:29,396
1-kilobyte file from disc, but


187
00:05:29,396 --> 00:05:31,096
finds a 1-gigabyte file in disc.


188
00:05:32,226 --> 00:05:33,376
Does it make sense to even load


189
00:05:33,376 --> 00:05:34,436
that data in the first place,


190
00:05:34,436 --> 00:05:35,176
and start reading it?


191
00:05:36,016 --> 00:05:38,366
Almost certainly not.


192
00:05:38,666 --> 00:05:39,736
Now, sometimes we might not be


193
00:05:39,736 --> 00:05:41,216
able to have length expectations


194
00:05:41,216 --> 00:05:41,796
about the data.


195
00:05:42,286 --> 00:05:43,476
Maybe it's external data we


196
00:05:43,476 --> 00:05:43,956
don't own.


197
00:05:43,956 --> 00:05:44,906
We don't' know how much data


198
00:05:44,906 --> 00:05:45,426
there could be.


199
00:05:46,366 --> 00:05:48,336
But in some cases, we might also


200
00:05:48,336 --> 00:05:49,966
be able to verify a checksum, or


201
00:05:49,966 --> 00:05:51,436
a cryptographic signature that


202
00:05:51,716 --> 00:05:53,336
represents what the data might


203
00:05:53,336 --> 00:05:54,346
look like, even if we don't know


204
00:05:54,346 --> 00:05:54,956
what's inside.


205
00:05:56,046 --> 00:05:57,516
Checksum is built by hashing all


206
00:05:57,516 --> 00:05:57,956
of the data.


207
00:05:58,056 --> 00:05:59,836
And if any bit in the data


208
00:05:59,836 --> 00:06:01,196
changes, either due to a


209
00:06:01,196 --> 00:06:02,726
potential malicious third party,


210
00:06:03,166 --> 00:06:04,796
or just regular data corruption,


211
00:06:04,796 --> 00:06:06,196
bad blocks on disc, a bad


212
00:06:06,196 --> 00:06:06,946
network connection.


213
00:06:07,306 --> 00:06:08,996
If any one of the bits flips in


214
00:06:08,996 --> 00:06:10,906
that data, it will invalidate


215
00:06:10,906 --> 00:06:12,216
the checksum, or the signature.


216
00:06:12,556 --> 00:06:13,516
And we'll know before even


217
00:06:13,516 --> 00:06:15,016
reading any of those bytes, that


218
00:06:15,016 --> 00:06:16,456
the data is incorrect, and you


219
00:06:16,456 --> 00:06:18,746
shouldn't trust it.


220
00:06:19,396 --> 00:06:21,106
Now, we also don't always have a


221
00:06:21,106 --> 00:06:21,576
checksum.


222
00:06:21,576 --> 00:06:22,706
Maybe it's data we don't own,


223
00:06:22,706 --> 00:06:23,606
where you can't get that ahead


224
00:06:23,606 --> 00:06:23,986
of time.


225
00:06:23,986 --> 00:06:25,706
So, at this stage, there isn't


226
00:06:25,706 --> 00:06:27,146
much we can do with this data,


227
00:06:27,826 --> 00:06:29,186
besides read it and inspect it.


228
00:06:29,186 --> 00:06:32,346
And so, once we do that, we can


229
00:06:32,346 --> 00:06:34,376
get primitive data out.


230
00:06:34,736 --> 00:06:36,286
Now, as we've mentioned, we can


231
00:06:36,286 --> 00:06:38,036
take that raw data and pass it


232
00:06:38,036 --> 00:06:39,576
through, usually deserialize it,


233
00:06:39,636 --> 00:06:40,616
like foundations JSON


234
00:06:40,616 --> 00:06:41,316
serialization.


235
00:06:42,856 --> 00:06:44,156
When we do that, we'll get inert


236
00:06:44,156 --> 00:06:45,556
strings and dictionaries and


237
00:06:45,556 --> 00:06:46,846
arrays of numbers back out that


238
00:06:46,846 --> 00:06:47,456
we can use.


239
00:06:47,666 --> 00:06:49,406
And if this process exceeds, we


240
00:06:49,406 --> 00:06:50,596
know two things about that data.


241
00:06:52,316 --> 00:06:53,716
One, that the data was indeed in


242
00:06:53,716 --> 00:06:54,656
the correct format that we


243
00:06:54,656 --> 00:06:55,126
expected.


244
00:06:55,306 --> 00:06:56,696
For instance, XML data won't


245
00:06:56,696 --> 00:06:58,096
pass through JSON serialization.


246
00:06:58,736 --> 00:07:00,936
And two, if we trust the


247
00:07:00,936 --> 00:07:03,386
deserializer, we know that the


248
00:07:03,386 --> 00:07:04,966
run-time objects we get back out


249
00:07:04,966 --> 00:07:05,806
are going to be valid.


250
00:07:06,476 --> 00:07:07,746
Again, foundations JSON


251
00:07:07,746 --> 00:07:08,906
serialization will always give


252
00:07:08,906 --> 00:07:09,976
you strings and numbers and


253
00:07:09,976 --> 00:07:11,186
arrays that you can actually


254
00:07:11,186 --> 00:07:11,436
work with.


255
00:07:12,156 --> 00:07:13,586
It's individual values that we


256
00:07:13,586 --> 00:07:14,076
can trust.


257
00:07:14,596 --> 00:07:16,746
But at this stage, we might


258
00:07:16,746 --> 00:07:18,796
wonder okay how can we make use


259
00:07:18,796 --> 00:07:19,826
of this data, or what can we


260
00:07:19,826 --> 00:07:21,106
trust about it, and what


261
00:07:21,106 --> 00:07:22,416
validation do we still need to


262
00:07:23,746 --> 00:07:23,813
do?


263
00:07:24,736 --> 00:07:26,376
Well, we don't actually know


264
00:07:26,646 --> 00:07:28,006
much about the contents of this


265
00:07:28,006 --> 00:07:29,486
data yet until we start looking


266
00:07:29,486 --> 00:07:29,696
at it.


267
00:07:29,696 --> 00:07:31,506
And in fact, we might not know


268
00:07:31,506 --> 00:07:32,706
anything about the structure of


269
00:07:32,706 --> 00:07:33,966
the data until we start


270
00:07:33,966 --> 00:07:34,556
inspecting it.


271
00:07:34,956 --> 00:07:36,066
If you've ever worked with


272
00:07:36,066 --> 00:07:37,496
dynamic deserialization in this


273
00:07:37,496 --> 00:07:38,216
way, you'll know that there's a


274
00:07:38,216 --> 00:07:39,666
lot of downcasting from anys.


275
00:07:40,466 --> 00:07:41,946
There's no upfront expectation


276
00:07:41,946 --> 00:07:42,866
what the data can be because


277
00:07:42,866 --> 00:07:43,796
it's very generalized.


278
00:07:44,326 --> 00:07:45,396
And so, we'll want to check to


279
00:07:45,396 --> 00:07:47,256
see what the data contains and


280
00:07:47,256 --> 00:07:47,906
how we can work with it.


281
00:07:49,166 --> 00:07:50,586
So, let's motivate this with an


282
00:07:50,586 --> 00:07:50,966
example.


283
00:07:51,896 --> 00:07:52,896
I've been working with an app


284
00:07:52,896 --> 00:07:54,406
lately called Sell My Old Junk,


285
00:07:54,826 --> 00:07:56,686
which allows me to sell my old


286
00:07:56,686 --> 00:07:57,946
junk to some friends and family.


287
00:07:58,396 --> 00:07:59,986
And when one of them opens up my


288
00:08:00,106 --> 00:08:02,716
app, my app makes a request to


289
00:08:02,716 --> 00:08:03,256
my server.


290
00:08:03,966 --> 00:08:05,876
Which requests a list of


291
00:08:05,926 --> 00:08:06,986
products that are currently


292
00:08:06,986 --> 00:08:08,166
available for sale to my friends


293
00:08:08,166 --> 00:08:08,546
and family.


294
00:08:09,646 --> 00:08:11,156
When the server receives this


295
00:08:11,156 --> 00:08:12,636
request, it responses with JSON,


296
00:08:13,026 --> 00:08:13,986
that indicates here are the


297
00:08:13,986 --> 00:08:16,576
products available to sell.


298
00:08:17,296 --> 00:08:18,956
Now, this is what an API


299
00:08:18,956 --> 00:08:20,186
response from my server might


300
00:08:20,186 --> 00:08:20,576
look like.


301
00:08:21,576 --> 00:08:22,606
It's an array of product


302
00:08:22,606 --> 00:08:23,836
listings, which have some


303
00:08:23,836 --> 00:08:24,716
interesting fields that you


304
00:08:24,716 --> 00:08:25,516
might care to look at.


305
00:08:26,766 --> 00:08:29,116
For instance, each listing has a


306
00:08:29,366 --> 00:08:29,986
product ID.


307
00:08:30,166 --> 00:08:31,776
A positive integer that uniquely


308
00:08:31,776 --> 00:08:32,686
identifies the product.


309
00:08:33,076 --> 00:08:34,275
And in my case, these are


310
00:08:34,275 --> 00:08:35,986
sequential integer IDs.


311
00:08:37,346 --> 00:08:38,905
Every listing also has a name


312
00:08:38,905 --> 00:08:39,706
and a description which are


313
00:08:39,706 --> 00:08:40,196
strings.


314
00:08:40,196 --> 00:08:41,306
And there are a few other type


315
00:08:41,306 --> 00:08:42,366
fields here that we might care


316
00:08:42,366 --> 00:08:42,756
to look at.


317
00:08:43,846 --> 00:08:45,216
For instance, there's a field


318
00:08:45,386 --> 00:08:46,506
that's a Boolean that indicates


319
00:08:46,506 --> 00:08:47,586
whether or not this listing has


320
00:08:47,586 --> 00:08:48,236
already been sold.


321
00:08:48,796 --> 00:08:50,716
And there's some internal


322
00:08:50,716 --> 00:08:51,386
structure here.


323
00:08:51,476 --> 00:08:52,626
This list of tags, which are


324
00:08:52,626 --> 00:08:53,726
strings, which we might care to


325
00:08:53,726 --> 00:08:54,066
use.


326
00:08:55,496 --> 00:08:57,216
There are also a few fields


327
00:08:57,216 --> 00:08:58,256
here, which come to us as


328
00:08:58,256 --> 00:08:59,736
strings, but really represent


329
00:08:59,806 --> 00:09:01,026
other forms of data that we


330
00:09:01,026 --> 00:09:01,676
might care to look at.


331
00:09:02,136 --> 00:09:04,376
For instance, URLs and dates.


332
00:09:05,116 --> 00:09:06,736
So, let's make use of this data.


333
00:09:07,856 --> 00:09:09,876
In my app, I can fetch that data


334
00:09:09,876 --> 00:09:11,156
from the network say with URL


335
00:09:11,156 --> 00:09:12,776
session, and wherever possible


336
00:09:12,776 --> 00:09:13,716
I'll validate the length.


337
00:09:13,716 --> 00:09:15,026
Maybe my server can produce a


338
00:09:15,056 --> 00:09:16,136
checksum that I can validate.


339
00:09:16,196 --> 00:09:17,416
Or a cryptographic signature.


340
00:09:17,986 --> 00:09:21,236
Once I've done that, I can take


341
00:09:21,266 --> 00:09:22,906
the data and pass it off JSON


342
00:09:22,906 --> 00:09:23,586
serialization.


343
00:09:24,626 --> 00:09:26,286
If deserializing the data fails,


344
00:09:26,546 --> 00:09:27,816
JSON serialization will throw an


345
00:09:27,816 --> 00:09:28,086
error.


346
00:09:28,196 --> 00:09:29,316
Will check and then catch and


347
00:09:29,316 --> 00:09:29,616
handle.


348
00:09:30,026 --> 00:09:31,216
May display dialogue to my


349
00:09:31,216 --> 00:09:31,726
customers.


350
00:09:32,936 --> 00:09:34,876
Again, in our purlins of the


351
00:09:34,876 --> 00:09:36,536
day, we've just taken raw data


352
00:09:37,076 --> 00:09:38,116
and carried along it the


353
00:09:38,116 --> 00:09:39,486
abstraction spectrum to


354
00:09:39,486 --> 00:09:40,056
primitive data.


355
00:09:40,746 --> 00:09:41,786
And if anything went wrong, we


356
00:09:41,786 --> 00:09:42,696
can handle that failure.


357
00:09:44,016 --> 00:09:45,576
So, now we need to make use of


358
00:09:45,576 --> 00:09:45,936
this data.


359
00:09:46,106 --> 00:09:47,026
How can we consume it?


360
00:09:47,786 --> 00:09:49,856
Well, JSON is an any variable


361
00:09:49,856 --> 00:09:51,246
that contains the actual values.


362
00:09:52,006 --> 00:09:53,586
So, I can downcast it to the


363
00:09:53,586 --> 00:09:54,566
array of dictionaries that I


364
00:09:54,566 --> 00:09:55,306
expect it to be.


365
00:09:56,556 --> 00:09:57,866
Now, this part of my app cares


366
00:09:57,866 --> 00:09:58,956
only about product listings that


367
00:09:58,956 --> 00:09:59,706
are related to music.


368
00:10:00,446 --> 00:10:02,126
So, will filter out any products


369
00:10:02,126 --> 00:10:03,246
that don't contain the music


370
00:10:03,246 --> 00:10:03,546
tag.


371
00:10:03,546 --> 00:10:04,676
And here, I have that


372
00:10:04,676 --> 00:10:05,316
substructure.


373
00:10:05,316 --> 00:10:06,416
That list of tags, which will


374
00:10:06,416 --> 00:10:08,256
downcast an array of strings and


375
00:10:08,256 --> 00:10:11,386
make use of it, right.


376
00:10:11,596 --> 00:10:14,696
Whoops. Each of those forced


377
00:10:14,696 --> 00:10:16,176
downcasts, actually contains a


378
00:10:16,176 --> 00:10:17,146
hidden fatal error.


379
00:10:18,236 --> 00:10:19,736
If either of those casts fails


380
00:10:20,046 --> 00:10:21,996
because the API changed or the


381
00:10:21,996 --> 00:10:23,326
data changed along the way


382
00:10:23,326 --> 00:10:24,506
before it made into my app,


383
00:10:24,586 --> 00:10:26,266
again due to data corruption or


384
00:10:26,266 --> 00:10:28,496
malicious changing, those


385
00:10:28,496 --> 00:10:29,486
downcasts will fail.


386
00:10:29,516 --> 00:10:31,566
And when they do fail, they'll


387
00:10:31,876 --> 00:10:33,136
abort, and they'll crash my app.


388
00:10:33,206 --> 00:10:34,006
And again, that's a bad


389
00:10:34,006 --> 00:10:35,226
experience for my customers.


390
00:10:35,656 --> 00:10:37,526
Let's take a look at how this


391
00:10:37,526 --> 00:10:37,976
could happen.


392
00:10:38,986 --> 00:10:40,266
So, here again is that sample


393
00:10:40,476 --> 00:10:41,336
API response.


394
00:10:42,166 --> 00:10:43,466
And we'll take a look at the


395
00:10:43,466 --> 00:10:44,466
list of tags here.


396
00:10:45,216 --> 00:10:47,616
And say that second tag in there


397
00:10:48,146 --> 00:10:48,806
is modified.


398
00:10:49,506 --> 00:10:50,966
Instead of a string, we have a


399
00:10:50,966 --> 00:10:51,346
number.


400
00:10:51,636 --> 00:10:52,796
It's maliciously changed by a


401
00:10:52,796 --> 00:10:54,146
third-party, or maybe again due


402
00:10:54,146 --> 00:10:55,206
to regular data corruption.


403
00:10:55,206 --> 00:10:57,666
We can't always tell.


404
00:10:57,876 --> 00:10:59,836
Downcasting this list of tags


405
00:11:00,126 --> 00:11:01,646
will fail because they're not


406
00:11:01,646 --> 00:11:03,246
strings and we never checked to


407
00:11:03,376 --> 00:11:04,516
make sure they work before we


408
00:11:04,516 --> 00:11:04,846
cast.


409
00:11:06,706 --> 00:11:08,206
So, to avoid this, our main


410
00:11:08,206 --> 00:11:09,476
tenant for the day will always


411
00:11:09,476 --> 00:11:11,616
be validate first, execute


412
00:11:11,616 --> 00:11:11,886
later.


413
00:11:13,186 --> 00:11:14,216
Instead of asserting that you


414
00:11:14,216 --> 00:11:15,206
know what the structure of the


415
00:11:15,206 --> 00:11:16,776
data is, check first.


416
00:11:17,436 --> 00:11:18,436
Don't blindly assume.


417
00:11:19,426 --> 00:11:20,246
So, let's see how we can do


418
00:11:20,246 --> 00:11:21,316
that.


419
00:11:21,646 --> 00:11:22,926
So, here again is that first


420
00:11:22,926 --> 00:11:23,926
forced downcast.


421
00:11:24,266 --> 00:11:25,376
And instead of forcibly


422
00:11:25,376 --> 00:11:27,646
downcasting these values, I can


423
00:11:27,646 --> 00:11:29,466
conditionally downcast.


424
00:11:32,336 --> 00:11:35,756
This allows me to validate that


425
00:11:35,756 --> 00:11:37,366
the data actually contains what


426
00:11:37,366 --> 00:11:39,696
I want and if that cast fails,


427
00:11:40,716 --> 00:11:41,936
well I can handle that error


428
00:11:41,936 --> 00:11:42,966
instead of fatally erroring.


429
00:11:44,486 --> 00:11:45,666
Now, similarly, later


430
00:11:46,306 --> 00:11:47,476
downcasting that list of


431
00:11:47,476 --> 00:11:49,136
strings, instead of forcibly


432
00:11:49,136 --> 00:11:50,766
downcasting, again I can


433
00:11:50,766 --> 00:11:52,106
conditionally downcast.


434
00:11:52,536 --> 00:11:53,596
And in this case, instead of


435
00:11:53,666 --> 00:11:55,396
throwing an error, I can give a


436
00:11:55,396 --> 00:11:56,606
default value that allows


437
00:11:56,606 --> 00:11:57,696
execution to continue.


438
00:11:57,846 --> 00:11:59,526
In this case, I'll simply ignore


439
00:11:59,526 --> 00:12:01,046
any product listings that don't


440
00:12:01,046 --> 00:12:02,416
have a valid list of tags.


441
00:12:03,226 --> 00:12:04,336
I could throw an error, but in


442
00:12:04,336 --> 00:12:07,356
this case, I chose not to.


443
00:12:07,876 --> 00:12:09,456
Now, type validation isn't the


444
00:12:09,456 --> 00:12:10,986
only form of validation that you


445
00:12:10,986 --> 00:12:12,546
want to perform at this stage.


446
00:12:13,106 --> 00:12:14,986
For instance, if that had been


447
00:12:14,986 --> 00:12:16,266
replaced by null, which is


448
00:12:16,266 --> 00:12:18,856
totally valid in JSON, I


449
00:12:19,096 --> 00:12:20,556
would've seen a similar crash.


450
00:12:21,876 --> 00:12:23,876
In Swift strong static type


451
00:12:23,876 --> 00:12:25,176
system nullability is part of


452
00:12:25,176 --> 00:12:25,556
the type.


453
00:12:25,556 --> 00:12:27,346
And indeed, you can't downcast


454
00:12:27,346 --> 00:12:28,166
null to a string.


455
00:12:28,616 --> 00:12:30,416
And so, again, this cast would


456
00:12:30,806 --> 00:12:32,356
have failed.


457
00:12:32,896 --> 00:12:34,696
Now, even if all of these values


458
00:12:34,696 --> 00:12:35,746
are of the correct type and


459
00:12:35,746 --> 00:12:37,186
nullability, there's other forms


460
00:12:37,186 --> 00:12:38,136
of validations that we should


461
00:12:38,136 --> 00:12:38,786
care about here.


462
00:12:39,626 --> 00:12:41,236
For instance, I said that each


463
00:12:41,296 --> 00:12:42,666
product listing has a positive


464
00:12:42,666 --> 00:12:43,196
integer ID.


465
00:12:43,196 --> 00:12:44,246
In my case, they're all


466
00:12:44,246 --> 00:12:45,296
sequential integers.


467
00:12:45,966 --> 00:12:47,076
Does it make sense for one of


468
00:12:47,076 --> 00:12:48,216
these IDs to be negative?


469
00:12:49,206 --> 00:12:49,926
No, it doesn't.


470
00:12:49,926 --> 00:12:51,366
But even if it is always


471
00:12:51,366 --> 00:12:53,026
positive, does it make sense for


472
00:12:53,026 --> 00:12:54,486
it to be such a large positive


473
00:12:54,486 --> 00:12:55,176
integer value?


474
00:12:55,976 --> 00:12:57,406
I'm not selling that many


475
00:12:57,406 --> 00:12:57,776
things.


476
00:12:58,036 --> 00:12:58,786
So, no it doesn't.


477
00:12:58,786 --> 00:12:59,886
and in this case, this might be


478
00:12:59,886 --> 00:13:01,376
due to somebody trying to cause


479
00:13:01,376 --> 00:13:02,986
overflow in my app.


480
00:13:03,586 --> 00:13:04,426
This is something you need to


481
00:13:04,426 --> 00:13:05,066
watch out for.


482
00:13:07,026 --> 00:13:08,526
Now similar to range validation


483
00:13:08,526 --> 00:13:09,486
is length validation.


484
00:13:10,146 --> 00:13:12,176
Again, every product listing has


485
00:13:12,176 --> 00:13:12,786
a description.


486
00:13:12,786 --> 00:13:14,466
Does it make sense for that


487
00:13:14,466 --> 00:13:15,496
description to be empty?


488
00:13:16,876 --> 00:13:18,096
Well, in my case, I know that


489
00:13:18,096 --> 00:13:19,456
anytime I upload a product


490
00:13:19,456 --> 00:13:21,456
listing, I'm always going to put


491
00:13:21,456 --> 00:13:22,206
a description in there.


492
00:13:22,206 --> 00:13:23,456
So, in my case, no it doesn't


493
00:13:23,456 --> 00:13:26,266
make sense for it to be empty.


494
00:13:26,326 --> 00:13:27,556
But even if it's not empty, does


495
00:13:27,556 --> 00:13:28,496
it make sense for it to be the


496
00:13:28,496 --> 00:13:29,706
full length and contents of


497
00:13:29,706 --> 00:13:30,516
"Romeo and Juliet?"


498
00:13:31,286 --> 00:13:32,786
Also no, it doesn't make sense.


499
00:13:32,786 --> 00:13:34,326
Something here's gone wrong and


500
00:13:34,326 --> 00:13:37,596
I need to look for that.


501
00:13:38,056 --> 00:13:39,166
Now, there's additional forms of


502
00:13:39,166 --> 00:13:40,166
validation that we really do


503
00:13:40,166 --> 00:13:40,806
care about here.


504
00:13:40,966 --> 00:13:42,286
Even if all of these fields are


505
00:13:42,286 --> 00:13:44,366
right type, nullability, and fit


506
00:13:44,366 --> 00:13:45,286
within the range and length that


507
00:13:45,286 --> 00:13:47,266
we expect, their values and


508
00:13:47,266 --> 00:13:48,596
contents are also equally


509
00:13:48,596 --> 00:13:48,986
important.


510
00:13:50,136 --> 00:13:51,836
Every product listing has a URL


511
00:13:51,836 --> 00:13:53,096
that I can send a customer to


512
00:13:53,096 --> 00:13:54,346
see more information about that


513
00:13:54,346 --> 00:13:54,986
product listing.


514
00:13:56,036 --> 00:13:57,306
This comes to me as a string,


515
00:13:57,866 --> 00:13:59,376
but it actually has to contain a


516
00:13:59,376 --> 00:13:59,596
URL.


517
00:13:59,596 --> 00:14:00,966
Does it make sense for it to be


518
00:14:01,356 --> 00:14:02,406
any arbitrary string?


519
00:14:02,896 --> 00:14:04,916
No, and in my case, I want to


520
00:14:04,916 --> 00:14:05,876
make sure that it actually


521
00:14:05,876 --> 00:14:06,706
represents a URL.


522
00:14:07,646 --> 00:14:09,366
But more importantly, just


523
00:14:09,366 --> 00:14:10,646
because it looks like a URL,


524
00:14:10,646 --> 00:14:11,956
doesn't mean it will point to my


525
00:14:11,956 --> 00:14:12,426
domain.


526
00:14:12,916 --> 00:14:13,916
And this is something I care


527
00:14:13,916 --> 00:14:14,866
very deeply about.


528
00:14:14,866 --> 00:14:16,976
I really, really want to keep my


529
00:14:16,976 --> 00:14:17,736
customers safe.


530
00:14:17,736 --> 00:14:19,466
I don't want to possibly send


531
00:14:19,466 --> 00:14:21,266
them to a phishing domain, which


532
00:14:21,266 --> 00:14:23,056
could look like mine, but not


533
00:14:23,056 --> 00:14:23,936
really be my site.


534
00:14:25,426 --> 00:14:26,476
So, this is something that I


535
00:14:26,476 --> 00:14:29,046
care about watching out for.


536
00:14:29,546 --> 00:14:30,986
Now, lastly, even if each of


537
00:14:30,986 --> 00:14:32,656
these fields is valid on its


538
00:14:32,656 --> 00:14:34,126
own, sometimes the relationships


539
00:14:34,126 --> 00:14:35,376
between fields that matters.


540
00:14:36,956 --> 00:14:38,026
For instance, each product


541
00:14:38,026 --> 00:14:39,186
listing has a date when it was


542
00:14:39,186 --> 00:14:40,446
created, and a date when it was


543
00:14:40,446 --> 00:14:41,126
last updated.


544
00:14:42,226 --> 00:14:43,276
Each of these can be valid on


545
00:14:43,276 --> 00:14:44,486
their own, but does it make


546
00:14:44,486 --> 00:14:45,566
sense for the date that it was


547
00:14:45,566 --> 00:14:47,256
last updated to come before when


548
00:14:47,256 --> 00:14:47,936
it was created?


549
00:14:49,106 --> 00:14:50,716
No. And in my case, this might


550
00:14:50,716 --> 00:14:51,636
not open a security


551
00:14:51,636 --> 00:14:52,406
vulnerability in my app.


552
00:14:52,406 --> 00:14:54,436
But this is something that maybe


553
00:14:54,436 --> 00:14:55,536
you watch out for because it's a


554
00:14:55,536 --> 00:14:56,946
good indicator that something's


555
00:14:56,946 --> 00:14:57,946
gone wrong, and maybe I


556
00:14:57,946 --> 00:14:58,966
shouldn't trust this data.


557
00:14:58,966 --> 00:15:01,736
So, let's take a look at how we


558
00:15:01,736 --> 00:15:03,216
can start doing that.


559
00:15:03,656 --> 00:15:04,726
Here, I've started writing a


560
00:15:04,726 --> 00:15:05,836
function which will take one


561
00:15:05,836 --> 00:15:07,106
such listing and start


562
00:15:07,106 --> 00:15:08,366
validating all of the contents.


563
00:15:09,476 --> 00:15:10,836
So, I'll take a listing, and


564
00:15:10,836 --> 00:15:12,056
I'll start pulling out the


565
00:15:12,056 --> 00:15:12,666
product ID.


566
00:15:13,386 --> 00:15:15,436
And we've learned here not to


567
00:15:15,436 --> 00:15:17,136
forcibly downcast this ID to an


568
00:15:17,166 --> 00:15:18,836
Int, but conditionally downcast.


569
00:15:19,166 --> 00:15:20,766
And if the cast fails the guard


570
00:15:20,766 --> 00:15:21,876
will fail and will throw an


571
00:15:21,876 --> 00:15:22,126
error.


572
00:15:22,216 --> 00:15:24,676
Now I don't want to stop there,


573
00:15:24,676 --> 00:15:25,746
I want to perform the range


574
00:15:25,746 --> 00:15:27,266
validation that ensures that


575
00:15:27,266 --> 00:15:28,626
product ID is also valid.


576
00:15:28,626 --> 00:15:30,066
That it's positive and not too


577
00:15:30,066 --> 00:15:30,466
large.


578
00:15:30,606 --> 00:15:31,616
And again, if something goes


579
00:15:31,616 --> 00:15:36,386
wrong, I'll throw an error.


580
00:15:37,006 --> 00:15:38,636
Now, later on I might care to


581
00:15:38,636 --> 00:15:39,706
check out that URL.


582
00:15:39,766 --> 00:15:41,466
And again, I'll downcast it to a


583
00:15:41,466 --> 00:15:42,916
string, instead of forcibly


584
00:15:42,916 --> 00:15:43,466
downcast.


585
00:15:44,236 --> 00:15:45,436
And here, I can check the link.


586
00:15:45,626 --> 00:15:46,836
In this case, I know my server


587
00:15:46,836 --> 00:15:48,276
will never produce URLs that are


588
00:15:48,276 --> 00:15:48,806
too long.


589
00:15:49,156 --> 00:15:50,966
So, if I find a really long URL,


590
00:15:50,966 --> 00:15:52,296
I'll know that it's invalid.


591
00:15:54,096 --> 00:15:55,726
Once I've validated that, I can


592
00:15:55,726 --> 00:15:57,206
send it off to the URL type to


593
00:15:57,206 --> 00:15:58,376
perform that domain-specific


594
00:15:58,376 --> 00:15:59,276
validation to make sure it


595
00:15:59,276 --> 00:16:00,816
actually is a URL, and not just


596
00:16:00,816 --> 00:16:01,486
a garbage string.


597
00:16:01,786 --> 00:16:02,846
And again, if anything goes


598
00:16:02,916 --> 00:16:04,006
wrong, I'll throw an error.


599
00:16:04,586 --> 00:16:06,806
But, again, I don't want to stop


600
00:16:06,806 --> 00:16:08,456
there, once I have an actual


601
00:16:08,456 --> 00:16:09,926
URL, I want to make sure it


602
00:16:09,926 --> 00:16:11,376
points to my domain and not a


603
00:16:11,376 --> 00:16:13,016
phishing domain, so I'll keep


604
00:16:13,016 --> 00:16:15,206
working with that.


605
00:16:15,406 --> 00:16:16,736
Now, at this point, I can apply


606
00:16:16,736 --> 00:16:17,886
the same types of validation to


607
00:16:17,886 --> 00:16:18,716
the other fields here.


608
00:16:18,966 --> 00:16:20,096
And again, if anything goes


609
00:16:20,096 --> 00:16:20,936
wrong, I'll throw an error.


610
00:16:21,466 --> 00:16:22,936
But once I have this function, I


611
00:16:22,936 --> 00:16:24,686
can apply it to all the product


612
00:16:24,686 --> 00:16:25,866
listings that I've loaded from


613
00:16:25,866 --> 00:16:26,256
the payload.


614
00:16:26,466 --> 00:16:29,436
And again, I'll stop executing


615
00:16:29,886 --> 00:16:33,716
if anything goes wrong.


616
00:16:33,916 --> 00:16:35,426
Now, this is how we can work to


617
00:16:35,426 --> 00:16:36,476
validate primitive data.


618
00:16:37,256 --> 00:16:38,256
But as we just saw, primitive


619
00:16:38,256 --> 00:16:39,306
data can be very general.


620
00:16:40,706 --> 00:16:43,906
A string can be a string, but it


621
00:16:43,906 --> 00:16:45,416
can also be a date.


622
00:16:45,756 --> 00:16:48,376
And it can also be a URL.


623
00:16:50,236 --> 00:16:52,086
Sometimes we care to work with


624
00:16:52,126 --> 00:16:53,466
data with the semantics that


625
00:16:53,556 --> 00:16:54,356
matter to us.


626
00:16:54,796 --> 00:16:55,986
We wanted to make sure that the


627
00:16:55,986 --> 00:16:57,866
host of that URL was our domain,


628
00:16:57,866 --> 00:16:59,116
and we can't do that with just a


629
00:16:59,116 --> 00:16:59,796
regular string.


630
00:17:01,536 --> 00:17:03,026
Similarly, a dictionary can


631
00:17:03,026 --> 00:17:04,846
represent a model like a listing


632
00:17:04,846 --> 00:17:06,616
here, or it can represent


633
00:17:06,616 --> 00:17:07,976
arbitrary customer data that we


634
00:17:07,976 --> 00:17:08,746
know nothing about.


635
00:17:10,136 --> 00:17:11,366
Instead of performing the same


636
00:17:11,366 --> 00:17:12,726
validations everywhere to make


637
00:17:12,726 --> 00:17:13,896
sure all the fields that we care


638
00:17:13,896 --> 00:17:15,665
about are there, isn't it nicer


639
00:17:15,665 --> 00:17:16,476
to work with our own model


640
00:17:16,476 --> 00:17:18,386
types, where that guarantee is


641
00:17:18,386 --> 00:17:19,016
always present?


642
00:17:19,556 --> 00:17:23,326
It is. And in our case, we want


643
00:17:23,326 --> 00:17:24,665
to work with structured data


644
00:17:24,705 --> 00:17:25,776
wherever possible.


645
00:17:25,876 --> 00:17:27,165
We can use primitive date as a


646
00:17:27,165 --> 00:17:28,356
building block to get there.


647
00:17:28,356 --> 00:17:29,516
But we want to work with that


648
00:17:29,516 --> 00:17:30,046
form of data.


649
00:17:31,286 --> 00:17:32,116
So, let's take a look at how we


650
00:17:32,116 --> 00:17:35,506
can do that.


651
00:17:35,506 --> 00:17:37,366
Elsewhere in my app, I have a


652
00:17:37,366 --> 00:17:38,836
purchase type, which does just


653
00:17:38,836 --> 00:17:39,166
this.


654
00:17:40,556 --> 00:17:41,436
When a customer makes a


655
00:17:41,436 --> 00:17:43,416
purchase, I store that data to


656
00:17:43,416 --> 00:17:44,866
disc, so that later, when they


657
00:17:44,866 --> 00:17:46,016
open the app, even if they're


658
00:17:46,016 --> 00:17:47,176
not connected to the network,


659
00:17:47,496 --> 00:17:48,426
they can view their purchase


660
00:17:48,426 --> 00:17:48,796
history.


661
00:17:50,096 --> 00:17:51,576
Each purchase keeps track of the


662
00:17:51,576 --> 00:17:52,446
product listing it was


663
00:17:52,446 --> 00:17:54,846
associated with, and when the


664
00:17:54,846 --> 00:17:55,946
purchase was made, and a


665
00:17:55,946 --> 00:17:56,386
receipt.


666
00:17:57,366 --> 00:17:59,476
I can save it to disc in this


667
00:17:59,476 --> 00:18:01,496
way using NS coding and NS key


668
00:18:01,496 --> 00:18:02,076
to archiver.


669
00:18:02,106 --> 00:18:03,026
And I'll archive it.


670
00:18:04,076 --> 00:18:05,876
But as we saw, when we unarchive


671
00:18:05,876 --> 00:18:07,506
data, and we handle raw and


672
00:18:07,506 --> 00:18:09,106
primitive data, we want to


673
00:18:09,106 --> 00:18:09,566
validate it.


674
00:18:10,746 --> 00:18:12,036
So, let's do that by taking a


675
00:18:12,036 --> 00:18:13,186
look at how doing it with coder


676
00:18:13,246 --> 00:18:13,756
here could work.


677
00:18:14,276 --> 00:18:15,416
If you've ever written in a note


678
00:18:15,416 --> 00:18:16,306
with coder, this might look


679
00:18:16,306 --> 00:18:16,956
familiar to you.


680
00:18:17,746 --> 00:18:19,396
We'll start by decoding the


681
00:18:19,396 --> 00:18:20,206
product listing.


682
00:18:20,426 --> 00:18:21,296
And again, we've learned to


683
00:18:21,296 --> 00:18:23,086
conditionally downcast, instead


684
00:18:23,086 --> 00:18:24,216
of forcibly downcasting.


685
00:18:25,106 --> 00:18:26,346
And if something goes wrong,


686
00:18:26,396 --> 00:18:27,446
well this is a fail-able


687
00:18:27,446 --> 00:18:28,746
initializer, we'll simply return


688
00:18:28,746 --> 00:18:29,306
nil, right?


689
00:18:30,686 --> 00:18:32,526
if decoding succeeds, I'll


690
00:18:32,526 --> 00:18:33,996
assign this to my property, and


691
00:18:34,246 --> 00:18:34,836
I'll keep going.


692
00:18:35,686 --> 00:18:36,766
I'll do the same thing with the


693
00:18:36,766 --> 00:18:37,696
purchase data, and again,


694
00:18:37,746 --> 00:18:38,886
conditionally downcast to a


695
00:18:38,886 --> 00:18:39,176
date.


696
00:18:39,286 --> 00:18:40,456
If something goes wrong, I'll


697
00:18:40,516 --> 00:18:41,776
fail, and so on.


698
00:18:41,776 --> 00:18:43,216
And repeat this for each of the


699
00:18:43,216 --> 00:18:44,546
fields in my type.


700
00:18:45,396 --> 00:18:47,056
When I want to save one of these


701
00:18:47,096 --> 00:18:49,116
purchases to the history, well I


702
00:18:49,116 --> 00:18:50,136
have a function, which does


703
00:18:50,136 --> 00:18:50,516
this.


704
00:18:50,906 --> 00:18:53,806
It archives a purchase to binary


705
00:18:53,806 --> 00:18:54,086
data.


706
00:18:54,226 --> 00:18:56,556
And then, I can save it out to


707
00:18:56,556 --> 00:18:57,956
disc, or shrill that data off


708
00:18:57,956 --> 00:18:59,106
into database or similar.


709
00:18:59,226 --> 00:19:02,176
When I want to load that data


710
00:19:02,176 --> 00:19:03,736
back, well I can do the same


711
00:19:03,736 --> 00:19:03,996
thing.


712
00:19:03,996 --> 00:19:06,226
I can get that raw data and then


713
00:19:06,226 --> 00:19:06,976
pass it along to


714
00:19:06,976 --> 00:19:08,476
KeyedUnarchiver, to get an


715
00:19:08,476 --> 00:19:10,786
object back out.


716
00:19:11,436 --> 00:19:12,506
Now, as we've said, at every


717
00:19:12,586 --> 00:19:14,046
point here, the data is getting


718
00:19:14,046 --> 00:19:14,856
more complicated.


719
00:19:15,346 --> 00:19:16,426
There might be more to validate


720
00:19:16,426 --> 00:19:17,756
about it before we can trust it,


721
00:19:17,866 --> 00:19:18,466
just as well.


722
00:19:18,466 --> 00:19:20,466
So, you might wonder, okay,


723
00:19:20,466 --> 00:19:21,226
what's the catch here?


724
00:19:21,776 --> 00:19:22,596
What else is there left to


725
00:19:22,596 --> 00:19:22,986
validate?


726
00:19:22,986 --> 00:19:25,486
And this downcast, here is a


727
00:19:25,486 --> 00:19:25,986
good hint.


728
00:19:26,646 --> 00:19:29,436
Note that this downcast happens


729
00:19:29,686 --> 00:19:31,166
after we've unarchived an


730
00:19:31,166 --> 00:19:31,566
object.


731
00:19:32,636 --> 00:19:33,866
How could this ever fail?


732
00:19:35,196 --> 00:19:36,076
It's a good indicator that


733
00:19:36,076 --> 00:19:37,206
something else might be going on


734
00:19:37,206 --> 00:19:37,326
here.


735
00:19:37,676 --> 00:19:40,696
So, let's take a look at that.


736
00:19:40,696 --> 00:19:41,726
This is an abstract


737
00:19:41,726 --> 00:19:42,776
representation of what these


738
00:19:42,776 --> 00:19:44,336
model objects might look like in


739
00:19:44,336 --> 00:19:44,866
my archive.


740
00:19:46,246 --> 00:19:47,706
Here we have all the fields that


741
00:19:47,706 --> 00:19:48,666
we cared about in coding.


742
00:19:49,106 --> 00:19:50,216
And each of them contains their


743
00:19:50,216 --> 00:19:51,636
own structure, and substructure,


744
00:19:51,636 --> 00:19:53,256
and contents, and so on.


745
00:19:53,796 --> 00:19:55,846
But, interestingly here this


746
00:19:55,846 --> 00:19:57,766
representation also contains the


747
00:19:57,766 --> 00:19:59,576
name of the class of this


748
00:19:59,576 --> 00:19:59,976
object.


749
00:20:01,136 --> 00:20:02,156
Let's take a look at how


750
00:20:02,156 --> 00:20:03,546
KeyedUnarchiver can make use of


751
00:20:03,546 --> 00:20:04,216
this information.


752
00:20:05,346 --> 00:20:07,136
So, we have a decode call we're


753
00:20:07,136 --> 00:20:07,876
currently making.


754
00:20:08,486 --> 00:20:09,876
And this under the hood creates


755
00:20:09,876 --> 00:20:11,126
a KeyedUnarchiver, and decodes


756
00:20:11,126 --> 00:20:13,346
an object for the object key.


757
00:20:14,196 --> 00:20:15,666
When you perform this in


758
00:20:15,666 --> 00:20:17,086
KeyedUnarchiver, KeyedUnarchiver


759
00:20:17,086 --> 00:20:18,596
finds that class name in the


760
00:20:18,596 --> 00:20:20,636
object in the archive and pulls


761
00:20:20,636 --> 00:20:20,926
it out.


762
00:20:21,666 --> 00:20:23,396
And dynamically finds a class


763
00:20:23,396 --> 00:20:25,506
with that same name in your app.


764
00:20:26,046 --> 00:20:28,896
It then allocates an instance of


765
00:20:28,896 --> 00:20:30,756
that class and then initializes


766
00:20:30,756 --> 00:20:32,726
it to allow it to decode its own


767
00:20:32,726 --> 00:20:33,236
contents.


768
00:20:34,416 --> 00:20:36,026
Afterwards, it awakens the


769
00:20:36,026 --> 00:20:37,186
object to give it a chance to


770
00:20:37,186 --> 00:20:38,746
finalize its state.


771
00:20:40,336 --> 00:20:42,336
Now, this works great for our


772
00:20:42,336 --> 00:20:42,906
objects.


773
00:20:43,336 --> 00:20:45,096
But now, we might wonder what


774
00:20:45,096 --> 00:20:46,176
happens if the data is


775
00:20:46,176 --> 00:20:47,776
maliciously changed to contain


776
00:20:47,776 --> 00:20:50,226
an object of a class that we


777
00:20:50,956 --> 00:20:51,486
didn't expect?


778
00:20:51,486 --> 00:20:52,656
Well, this whole process that we


779
00:20:52,656 --> 00:20:54,656
just performed happened on a


780
00:20:54,656 --> 00:20:55,256
different type.


781
00:20:56,486 --> 00:20:58,616
We just allocated, initialized


782
00:20:58,616 --> 00:21:00,746
and awoke an object of a class


783
00:21:00,746 --> 00:21:01,546
that we didn't expect.


784
00:21:02,896 --> 00:21:03,906
What kind of effect can this


785
00:21:03,906 --> 00:21:05,826
have in our app?


786
00:21:06,106 --> 00:21:07,326
Well, as we saw before, the


787
00:21:07,326 --> 00:21:08,626
conditional downcast here,


788
00:21:08,896 --> 00:21:10,006
prevents us from accidentally


789
00:21:10,086 --> 00:21:11,216
using an object of this


790
00:21:11,216 --> 00:21:12,246
unexpected class.


791
00:21:12,696 --> 00:21:13,796
We're only going to work with


792
00:21:13,796 --> 00:21:15,146
objects of the types that we did


793
00:21:15,146 --> 00:21:15,566
expect.


794
00:21:15,976 --> 00:21:17,636
The downcast fails, well we'll


795
00:21:17,636 --> 00:21:17,936
fail.


796
00:21:20,476 --> 00:21:22,516
But decoding one such object can


797
00:21:22,516 --> 00:21:23,846
have a lasting impact in our


798
00:21:24,136 --> 00:21:24,476
app.


799
00:21:24,686 --> 00:21:27,036
Say that class has an alloc


800
00:21:27,036 --> 00:21:28,306
method, which changes global


801
00:21:28,306 --> 00:21:28,626
state.


802
00:21:28,696 --> 00:21:30,146
Maybe it allocates a singleton


803
00:21:30,146 --> 00:21:33,306
or changes some global data.


804
00:21:33,476 --> 00:21:34,796
Even though we throw the object


805
00:21:34,796 --> 00:21:36,346
away, if this fails, this can


806
00:21:36,346 --> 00:21:37,686
have a lasting impact in our


807
00:21:37,936 --> 00:21:38,006
app.


808
00:21:38,006 --> 00:21:39,716
And can cause differing behavior


809
00:21:39,846 --> 00:21:41,196
somewhere else and an archive


810
00:21:41,196 --> 00:21:43,076
can be maliciously constructed


811
00:21:43,076 --> 00:21:44,506
in this way to cause this to


812
00:21:44,506 --> 00:21:45,416
happen in our apps.


813
00:21:46,246 --> 00:21:47,806
So, how can we validate the data


814
00:21:47,806 --> 00:21:48,796
to prevent this from happening?


815
00:21:49,946 --> 00:21:51,196
This is exactly where the


816
00:21:51,196 --> 00:21:52,416
NSSecureCoding protocol comes


817
00:21:52,416 --> 00:21:52,516
in.


818
00:21:53,886 --> 00:21:55,566
NSSecureCoding is a protocol


819
00:21:55,966 --> 00:21:58,126
inheriting from NSCoding, whose


820
00:21:58,126 --> 00:22:00,536
goal is to prevent exactly this


821
00:22:00,536 --> 00:22:02,256
sort of attack.


822
00:22:02,966 --> 00:22:04,756
By allowing you to pass in type


823
00:22:04,756 --> 00:22:07,546
information upfront, it prevents


824
00:22:07,546 --> 00:22:08,926
arbitrary code execution by


825
00:22:08,926 --> 00:22:10,296
validating the contents of the


826
00:22:10,296 --> 00:22:11,966
archive to make sure it only


827
00:22:11,966 --> 00:22:13,246
contains the types that you


828
00:22:13,926 --> 00:22:14,166
expect.


829
00:22:15,356 --> 00:22:17,126
The hallmark introduction of


830
00:22:17,126 --> 00:22:18,666
NSSecureCoding were two


831
00:22:18,666 --> 00:22:20,136
alternative methods to decode


832
00:22:20,136 --> 00:22:22,016
object for key, which allow you


833
00:22:22,016 --> 00:22:23,356
to pass that type information


834
00:22:23,356 --> 00:22:23,786
upfront.


835
00:22:24,586 --> 00:22:26,056
And using that type information,


836
00:22:26,056 --> 00:22:27,276
NSKeyedUnarchiver can keep you


837
00:22:27,276 --> 00:22:27,636
safe.


838
00:22:29,016 --> 00:22:29,806
So, let's take a look at the


839
00:22:29,806 --> 00:22:31,016
current decode object for key


840
00:22:31,016 --> 00:22:31,666
call that we have.


841
00:22:32,136 --> 00:22:34,506
This top level decode.


842
00:22:34,756 --> 00:22:36,176
Now, here, if instead we use the


843
00:22:36,176 --> 00:22:37,806
variant that allows us to pass


844
00:22:37,806 --> 00:22:39,136
in the class upfront, in this


845
00:22:39,136 --> 00:22:39,986
case, we want to decode a


846
00:22:39,986 --> 00:22:42,566
purchase, instead of performing


847
00:22:42,566 --> 00:22:43,716
this whole process and whatever


848
00:22:43,796 --> 00:22:46,256
is in the archive, you can first


849
00:22:46,336 --> 00:22:47,666
gate it on a class check.


850
00:22:49,196 --> 00:22:50,276
Let's examine this class check


851
00:22:50,276 --> 00:22:50,746
for a moment.


852
00:22:51,236 --> 00:22:54,506
At every stage in decoding, if


853
00:22:54,506 --> 00:22:55,466
secure coding is on,


854
00:22:55,736 --> 00:22:57,106
NSKeyedUnarchiver maintains a


855
00:22:57,106 --> 00:22:58,676
list of classes, which are valid


856
00:22:58,676 --> 00:22:59,206
to decode.


857
00:22:59,786 --> 00:23:02,246
When we make such a call,


858
00:23:02,636 --> 00:23:04,456
NSKeyedUnarchiver, takes the


859
00:23:04,456 --> 00:23:06,606
object that we used, this class,


860
00:23:07,056 --> 00:23:08,516
and constructs an allowed class


861
00:23:08,516 --> 00:23:09,706
list from it.


862
00:23:10,296 --> 00:23:12,626
When we go ahead and decode an


863
00:23:12,626 --> 00:23:14,306
object from an archive, it's


864
00:23:14,306 --> 00:23:16,016
class is first checked against


865
00:23:16,016 --> 00:23:16,936
the allowed class list.


866
00:23:17,286 --> 00:23:19,626
And if it isn't present, the


867
00:23:19,626 --> 00:23:20,886
decode call will be rejected.


868
00:23:21,556 --> 00:23:24,436
Now, if the class of the object


869
00:23:24,436 --> 00:23:25,906
that we find in the archive is


870
00:23:25,906 --> 00:23:26,966
in the allowed class list,


871
00:23:27,556 --> 00:23:28,566
there's a few checks that we


872
00:23:28,566 --> 00:23:29,196
need to perform.


873
00:23:30,246 --> 00:23:31,726
Specifically, we'll need to make


874
00:23:31,726 --> 00:23:33,276
sure that this class itself also


875
00:23:33,276 --> 00:23:34,596
conforms to NSSecureCoding.


876
00:23:35,906 --> 00:23:37,666
If it doesn't, we can't be sure


877
00:23:37,666 --> 00:23:38,896
that it itself will be able to


878
00:23:38,896 --> 00:23:40,546
further securely decode its own


879
00:23:40,546 --> 00:23:41,146
contents.


880
00:23:41,496 --> 00:23:43,086
And so, we can't safely decode


881
00:23:43,086 --> 00:23:43,996
one of these objects.


882
00:23:44,996 --> 00:23:46,256
In our case, the purchase class


883
00:23:46,316 --> 00:23:46,506
will.


884
00:23:46,776 --> 00:23:47,976
And so, it's safe to decode and


885
00:23:47,976 --> 00:23:48,706
keep track of it.


886
00:23:49,746 --> 00:23:51,086
Now, there's two other checks


887
00:23:51,086 --> 00:23:51,716
that are related to


888
00:23:51,716 --> 00:23:52,856
superclass-subclass


889
00:23:53,256 --> 00:23:54,006
relationships.


890
00:23:54,576 --> 00:23:56,906
If you have two classes, one of


891
00:23:56,906 --> 00:23:58,226
which is a subclass of another,


892
00:23:58,586 --> 00:24:00,636
both conforming to NSCoding, and


893
00:24:00,636 --> 00:24:01,846
the superclass adopts


894
00:24:01,846 --> 00:24:04,066
NSSecureCoding conformance, the


895
00:24:04,066 --> 00:24:05,516
subclass will inherit that


896
00:24:05,516 --> 00:24:06,176
conformance.


897
00:24:06,786 --> 00:24:09,436
Now, the subclass may never have


898
00:24:09,436 --> 00:24:11,406
had a chance to rewrite its init


899
00:24:11,406 --> 00:24:12,656
with coder to do the secure


900
00:24:12,656 --> 00:24:12,986
thing.


901
00:24:13,756 --> 00:24:14,956
And so, we have an escape hatch


902
00:24:15,586 --> 00:24:15,676
here.


903
00:24:16,816 --> 00:24:18,126
The support secure coding


904
00:24:18,126 --> 00:24:19,386
method, allows you to say,


905
00:24:19,386 --> 00:24:21,226
actually I don't really support


906
00:24:21,226 --> 00:24:22,936
secure coding, and you can turn


907
00:24:22,936 --> 00:24:25,136
this off to say, I'm not ready


908
00:24:26,456 --> 00:24:26,566
yet.


909
00:24:26,776 --> 00:24:28,826
Alternatively, if you still say


910
00:24:28,826 --> 00:24:30,466
yes, we have to make sure that


911
00:24:30,466 --> 00:24:32,736
you either inherited the full


912
00:24:32,736 --> 00:24:34,276
conformance to NSSecureCoding


913
00:24:34,276 --> 00:24:36,256
from the superclass, or that you


914
00:24:36,256 --> 00:24:38,086
overrode both of the methods to


915
00:24:38,086 --> 00:24:40,126
indicate yes I really do support


916
00:24:40,126 --> 00:24:40,796
secure coding.


917
00:24:40,986 --> 00:24:43,696
There isn't a mismatch here.


918
00:24:44,166 --> 00:24:45,716
In our case, purchase meets both


919
00:24:45,716 --> 00:24:47,106
of these requirements and so we


920
00:24:47,106 --> 00:24:49,186
can safely decode it from the


921
00:24:49,756 --> 00:24:49,986
archive.


922
00:24:50,946 --> 00:24:52,826
Now, we go ahead and decode a


923
00:24:52,886 --> 00:24:54,976
purchase, it itself decodes a


924
00:24:54,976 --> 00:24:55,416
listing.


925
00:24:55,416 --> 00:24:56,806
And it can make use of the same


926
00:24:56,806 --> 00:24:58,206
type of call to indicate that it


927
00:24:58,206 --> 00:24:58,906
wants a listing.


928
00:24:59,486 --> 00:25:01,786
When it does that


929
00:25:02,076 --> 00:25:03,536
NSKeyedUnarchiver uses that


930
00:25:03,536 --> 00:25:05,146
class to build a new allowed


931
00:25:05,146 --> 00:25:05,826
class list.


932
00:25:06,236 --> 00:25:07,226
And everything is checked


933
00:25:07,226 --> 00:25:08,286
against this new version of the


934
00:25:08,286 --> 00:25:08,606
list.


935
00:25:09,916 --> 00:25:10,946
We go ahead and decode an


936
00:25:10,946 --> 00:25:12,316
object, the same checks are


937
00:25:12,316 --> 00:25:13,476
performed and in this case a


938
00:25:13,476 --> 00:25:14,876
listing is still valid to


939
00:25:15,426 --> 00:25:15,586
decode.


940
00:25:17,236 --> 00:25:19,816
But again, if we try to decode


941
00:25:19,816 --> 00:25:21,506
an object of an unexpected class


942
00:25:21,566 --> 00:25:22,656
that's not in the list, it will


943
00:25:22,656 --> 00:25:23,226
be rejected.


944
00:25:23,796 --> 00:25:27,186
Let's take a look at what that


945
00:25:27,186 --> 00:25:28,286
rejection might look like.


946
00:25:28,506 --> 00:25:30,256
And this is called decoding


947
00:25:30,256 --> 00:25:31,046
failure and there are a few


948
00:25:31,046 --> 00:25:32,356
other types of failures that we


949
00:25:32,356 --> 00:25:33,576
might care to look at.


950
00:25:33,746 --> 00:25:35,176
So, when secure coding is on, we


951
00:25:35,176 --> 00:25:36,276
might be able to see secure


952
00:25:36,276 --> 00:25:37,726
coding violations in cases like


953
00:25:37,726 --> 00:25:37,986
this.


954
00:25:37,986 --> 00:25:39,016
But there's other forms of


955
00:25:39,016 --> 00:25:39,716
failure here, too.


956
00:25:40,916 --> 00:25:42,956
For example, a type mismatch can


957
00:25:42,956 --> 00:25:44,556
happen if you try to decode an


958
00:25:44,556 --> 00:25:45,696
object and instead there's a


959
00:25:45,696 --> 00:25:47,066
primitive value, like an integer


960
00:25:47,066 --> 00:25:48,466
in the archive at that location.


961
00:25:49,116 --> 00:25:50,356
Or, you try to decode a


962
00:25:50,356 --> 00:25:52,396
primitive, like an integer, and


963
00:25:52,396 --> 00:25:54,146
instead we find an object or a


964
00:25:54,146 --> 00:25:55,376
primitive of an incompatible


965
00:25:55,476 --> 00:25:56,126
type like double.


966
00:25:57,026 --> 00:25:58,006
These can cause decoding


967
00:25:58,006 --> 00:25:58,456
failures.


968
00:25:59,996 --> 00:26:01,936
There's another form of failure


969
00:26:01,936 --> 00:26:02,606
that can happen here.


970
00:26:02,956 --> 00:26:04,106
And that's archive corruption.


971
00:26:04,106 --> 00:26:05,436
If the archive itself is too


972
00:26:05,436 --> 00:26:07,356
corrupted and doesn't follow the


973
00:26:07,356 --> 00:26:08,336
expected format for


974
00:26:08,336 --> 00:26:09,866
NSKeyedUnarchiver, well we won't


975
00:26:09,866 --> 00:26:11,256
be able to decode anything, and


976
00:26:11,256 --> 00:26:13,246
so you'll get that same sort of


977
00:26:13,976 --> 00:26:14,166
failure.


978
00:26:14,906 --> 00:26:17,166
Now, what happens on failure is


979
00:26:17,166 --> 00:26:18,666
decided by the decoding failure


980
00:26:18,666 --> 00:26:20,286
policy on the Unarchiver.


981
00:26:20,786 --> 00:26:21,606
There's two options here.


982
00:26:22,886 --> 00:26:23,946
On failure, we can either raise


983
00:26:23,946 --> 00:26:26,586
an exception or store


984
00:26:26,586 --> 00:26:27,836
information about what happened


985
00:26:27,836 --> 00:26:28,976
and continue execution.


986
00:26:29,926 --> 00:26:31,456
Raising exceptions is currently


987
00:26:31,456 --> 00:26:31,916
the default.


988
00:26:32,466 --> 00:26:35,766
So, if we have a call, again


989
00:26:35,766 --> 00:26:36,776
this is our call from earlier,


990
00:26:36,776 --> 00:26:37,846
trying to decode a listing.


991
00:26:38,116 --> 00:26:39,826
And we find an object of an


992
00:26:39,826 --> 00:26:41,296
unexpected class in the archive,


993
00:26:42,146 --> 00:26:43,256
under the hood this calls the


994
00:26:43,256 --> 00:26:44,816
failWithError method, on the


995
00:26:44,816 --> 00:26:47,036
Unarchiver and passes in an


996
00:26:47,036 --> 00:26:48,466
error that indicates what went


997
00:26:48,466 --> 00:26:49,046
wrong and where.


998
00:26:50,246 --> 00:26:51,146
Now, under the hood,


999
00:26:51,146 --> 00:26:52,946
failWithError has a decision to


1000
00:26:52,946 --> 00:26:53,136
make.


1001
00:26:54,056 --> 00:26:55,566
If the decoding failure policy


1002
00:26:55,566 --> 00:26:57,256
is to raise exceptions, it will


1003
00:26:57,706 --> 00:26:58,476
raise exceptions.


1004
00:26:59,336 --> 00:27:00,326
If you're writing a Swift app,


1005
00:27:00,326 --> 00:27:01,156
this is something you have to be


1006
00:27:01,156 --> 00:27:01,656
mindful of.


1007
00:27:02,406 --> 00:27:03,956
Swift can't catch Objective-C or


1008
00:27:03,956 --> 00:27:06,046
C++ exceptions, and so this can


1009
00:27:06,046 --> 00:27:07,146
lead to a fatal error in your


1010
00:27:07,146 --> 00:27:07,296
app.


1011
00:27:07,296 --> 00:27:08,946
Now again, this can lead to a


1012
00:27:08,946 --> 00:27:10,936
crash and a bad experience our


1013
00:27:10,936 --> 00:27:11,426
customers.


1014
00:27:11,976 --> 00:27:14,946
If the decoding failure policy


1015
00:27:14,946 --> 00:27:16,526
to set error and return, the


1016
00:27:16,526 --> 00:27:17,596
error will be assigned to the


1017
00:27:17,596 --> 00:27:18,886
Unarchiver's error property.


1018
00:27:19,436 --> 00:27:20,906
And execution has to continue.


1019
00:27:21,556 --> 00:27:22,666
And in this case, because


1020
00:27:22,666 --> 00:27:24,296
execution does continue, the


1021
00:27:24,296 --> 00:27:25,526
decode call has to return


1022
00:27:25,966 --> 00:27:27,376
something, and so it will return


1023
00:27:27,376 --> 00:27:29,086
nil to indicate that nothing


1024
00:27:29,086 --> 00:27:29,726
could be decoded.


1025
00:27:30,096 --> 00:27:32,666
And as mentioned, if you're


1026
00:27:32,666 --> 00:27:33,996
decoding a primitive type, here


1027
00:27:33,996 --> 00:27:35,876
and we find an object or a


1028
00:27:35,876 --> 00:27:36,896
primitive type that's


1029
00:27:36,896 --> 00:27:38,996
incompatible, the same series of


1030
00:27:38,996 --> 00:27:39,966
steps has to happened.


1031
00:27:39,966 --> 00:27:41,006
And in this case, instead of


1032
00:27:41,006 --> 00:27:42,356
returning nil, we'll simply


1033
00:27:42,356 --> 00:27:43,606
return 0.


1034
00:27:44,236 --> 00:27:49,116
Now failWithError is API on


1035
00:27:49,146 --> 00:27:50,716
NSKeyedUnarchiver, and we urge


1036
00:27:50,716 --> 00:27:52,296
you to use in your own code to


1037
00:27:52,296 --> 00:27:53,616
indicate when failures happen


1038
00:27:53,726 --> 00:27:54,806
and what went wrong.


1039
00:27:55,636 --> 00:27:56,966
Instead of simply returning nil,


1040
00:27:57,216 --> 00:27:58,976
failWithError first to record


1041
00:27:58,976 --> 00:27:59,686
that information.


1042
00:28:00,256 --> 00:28:02,156
If you do, there are a few


1043
00:28:02,156 --> 00:28:03,066
things to keep in mind.


1044
00:28:04,466 --> 00:28:05,716
If the decoding failure policy


1045
00:28:05,716 --> 00:28:07,166
is to set an error, and return,


1046
00:28:07,536 --> 00:28:08,546
you have to keep in mind, that


1047
00:28:08,546 --> 00:28:09,826
once an error is set on


1048
00:28:09,826 --> 00:28:11,186
Unarchiver, it won't later be


1049
00:28:11,186 --> 00:28:11,596
reset.


1050
00:28:11,746 --> 00:28:14,616
And that's because one decoding


1051
00:28:14,616 --> 00:28:16,366
failure often leads to a cascade


1052
00:28:16,366 --> 00:28:17,306
of decoding failures.


1053
00:28:17,406 --> 00:28:18,516
And we don't want to lose sight


1054
00:28:18,516 --> 00:28:21,796
of what originally went wrong.


1055
00:28:22,356 --> 00:28:24,226
Second, keep in mind that any


1056
00:28:24,226 --> 00:28:25,776
given failWithError call, can


1057
00:28:25,776 --> 00:28:26,976
either throw an exception or


1058
00:28:26,976 --> 00:28:29,026
continue execution, so you have


1059
00:28:29,026 --> 00:28:30,276
to keep both of those options in


1060
00:28:30,276 --> 00:28:30,526
mind.


1061
00:28:30,686 --> 00:28:31,666
Especially if you're working


1062
00:28:31,666 --> 00:28:32,286
Objective-C.


1063
00:28:32,286 --> 00:28:33,206
Maybe you can catch the


1064
00:28:33,206 --> 00:28:33,656
exception.


1065
00:28:34,266 --> 00:28:35,146
So, there's things to handle


1066
00:28:35,146 --> 00:28:35,266
there.


1067
00:28:35,886 --> 00:28:38,206
And lastly, keeping an eye out


1068
00:28:38,326 --> 00:28:40,176
for nil, or 0 return values.


1069
00:28:40,456 --> 00:28:41,806
This could either happen because


1070
00:28:41,806 --> 00:28:43,106
of a decoding failure, if the


1071
00:28:43,226 --> 00:28:44,406
decoding failure policy is to


1072
00:28:44,406 --> 00:28:45,486
set an error and return.


1073
00:28:46,006 --> 00:28:47,276
Or, the data could have just


1074
00:28:47,276 --> 00:28:47,806
been missing.


1075
00:28:48,166 --> 00:28:50,266
Or, even encoded as nil or 0.


1076
00:28:51,056 --> 00:28:52,566
So, to disambiguate between


1077
00:28:52,566 --> 00:28:53,706
these cases, check the error


1078
00:28:53,706 --> 00:28:54,786
property on the Unarchiver.


1079
00:28:54,856 --> 00:28:58,636
All right, so that was a lot of


1080
00:28:58,636 --> 00:28:59,196
information.


1081
00:28:59,926 --> 00:29:01,116
Let's distill this down into a


1082
00:29:01,116 --> 00:29:02,326
checklist to see how we can


1083
00:29:02,326 --> 00:29:03,826
adopt NSSecureCoding on our own


1084
00:29:03,826 --> 00:29:04,206
types.


1085
00:29:05,406 --> 00:29:06,726
We'll start by converting all


1086
00:29:06,726 --> 00:29:08,516
decode object for key calls to


1087
00:29:08,516 --> 00:29:09,466
the variant which allows us to


1088
00:29:09,466 --> 00:29:10,906
pass in that type information up


1089
00:29:10,906 --> 00:29:11,196
front.


1090
00:29:11,196 --> 00:29:13,516
And then, if something goes


1091
00:29:13,516 --> 00:29:14,846
wrong instead of just returning


1092
00:29:14,846 --> 00:29:16,176
nil, let's failWithError to


1093
00:29:16,176 --> 00:29:17,006
indicate what happened.


1094
00:29:17,736 --> 00:29:19,466
And lastly, this is a great


1095
00:29:19,466 --> 00:29:21,006
opportunity to audit for further


1096
00:29:21,006 --> 00:29:22,356
points of failure, where we


1097
00:29:22,356 --> 00:29:23,576
weren't performing validation


1098
00:29:23,576 --> 00:29:23,916
before.


1099
00:29:24,826 --> 00:29:26,506
So, let's do just that.


1100
00:29:27,036 --> 00:29:29,076
So, here again is a decode call


1101
00:29:29,186 --> 00:29:30,026
to decode a listing.


1102
00:29:30,426 --> 00:29:31,366
And you'll notice that if we


1103
00:29:31,426 --> 00:29:32,946
pass in that type information up


1104
00:29:32,946 --> 00:29:34,746
front, the conditional downcast


1105
00:29:34,746 --> 00:29:35,496
later can go away.


1106
00:29:36,926 --> 00:29:38,056
There's a generic overload of


1107
00:29:38,056 --> 00:29:39,626
this method, which when given


1108
00:29:39,626 --> 00:29:40,946
the type information statically


1109
00:29:41,176 --> 00:29:42,776
causes you to not have to


1110
00:29:42,776 --> 00:29:44,066
conditionally downcast anymore.


1111
00:29:44,146 --> 00:29:45,376
You'll always get an object of


1112
00:29:45,376 --> 00:29:47,316
that class.


1113
00:29:47,586 --> 00:29:49,416
Now, again, as we said, instead


1114
00:29:49,416 --> 00:29:50,756
of returning nil on failure, we


1115
00:29:50,756 --> 00:29:51,986
want to fail meaningfully.


1116
00:29:52,536 --> 00:29:53,876
So, here we can fail with an


1117
00:29:53,876 --> 00:29:55,536
error to indicate what went


1118
00:29:55,536 --> 00:29:56,086
wrong and where.


1119
00:29:56,086 --> 00:29:58,656
And in this case, we can use one


1120
00:29:58,656 --> 00:29:59,676
of the conveniences on


1121
00:29:59,676 --> 00:30:01,126
CocoaError to return a


1122
00:30:01,126 --> 00:30:02,346
meaningful error that has a good


1123
00:30:02,346 --> 00:30:03,496
localized description for our


1124
00:30:03,496 --> 00:30:04,566
customers and that indicates


1125
00:30:04,566 --> 00:30:06,976
what went wrong.


1126
00:30:07,046 --> 00:30:07,766
We can always add a debug


1127
00:30:07,766 --> 00:30:09,406
description for ourselves, to


1128
00:30:09,406 --> 00:30:10,646
later log if we care to.


1129
00:30:10,766 --> 00:30:11,846
But this is the core.


1130
00:30:12,126 --> 00:30:13,606
We want to failWithError before


1131
00:30:13,606 --> 00:30:14,136
returning nil.


1132
00:30:14,676 --> 00:30:18,526
And then, later on, again, we


1133
00:30:18,526 --> 00:30:19,826
were decoding the purchase date.


1134
00:30:20,306 --> 00:30:22,206
And here, there is a great


1135
00:30:22,206 --> 00:30:23,726
opportunity to add further


1136
00:30:23,726 --> 00:30:24,826
validation where we weren't


1137
00:30:24,826 --> 00:30:25,216
before.


1138
00:30:26,616 --> 00:30:28,056
Here, if we can decode a date,


1139
00:30:28,056 --> 00:30:29,276
well, I was simply storing the


1140
00:30:29,276 --> 00:30:29,756
property.


1141
00:30:30,516 --> 00:30:31,806
But instead, I want to make sure


1142
00:30:31,806 --> 00:30:32,926
that that date is valid.


1143
00:30:33,406 --> 00:30:34,356
For instance, a purchase


1144
00:30:34,356 --> 00:30:35,686
couldn't possibly had been made


1145
00:30:35,736 --> 00:30:37,026
before my app went live on the


1146
00:30:37,026 --> 00:30:37,516
app store.


1147
00:30:37,516 --> 00:30:38,676
So, this is something you could


1148
00:30:38,676 --> 00:30:38,936
check.


1149
00:30:39,286 --> 00:30:40,266
And again, if something goes


1150
00:30:40,266 --> 00:30:42,286
wrong here, we want to fail with


1151
00:30:42,286 --> 00:30:43,096
a meaningful error.


1152
00:30:44,236 --> 00:30:45,256
In this case, it wasn't that the


1153
00:30:45,256 --> 00:30:46,656
data was missing, it was that


1154
00:30:46,656 --> 00:30:47,786
the data was corrupted or


1155
00:30:47,786 --> 00:30:48,656
invalid in some way.


1156
00:30:48,656 --> 00:30:49,736
And so, we'll indicate just


1157
00:30:49,736 --> 00:30:49,926
that.


1158
00:30:49,966 --> 00:30:54,786
Now, that we've gone ahead and


1159
00:30:54,786 --> 00:30:56,136
done exactly this on our type,


1160
00:30:56,796 --> 00:30:58,716
we can go ahead and claim that


1161
00:30:58,716 --> 00:30:59,836
it supports secure coding.


1162
00:31:00,576 --> 00:31:02,266
And lastly, conform to the


1163
00:31:02,266 --> 00:31:03,976
NSSecureCoding protocol instead


1164
00:31:03,976 --> 00:31:05,536
to indicate to the runtime that


1165
00:31:05,536 --> 00:31:06,506
this is what we intended.


1166
00:31:06,506 --> 00:31:07,846
It really does support secure


1167
00:31:07,846 --> 00:31:08,126
coding.


1168
00:31:08,836 --> 00:31:11,526
And after that, well,


1169
00:31:12,146 --> 00:31:13,006
congratulations.


1170
00:31:13,006 --> 00:31:14,366
We've earned our NSSecureCoding


1171
00:31:14,366 --> 00:31:14,666
badge.


1172
00:31:15,026 --> 00:31:15,876
Physical badge is sold


1173
00:31:15,876 --> 00:31:16,276
separately.


1174
00:31:18,046 --> 00:31:20,606
Now, we think it's so important


1175
00:31:20,606 --> 00:31:21,856
for you to earn your own


1176
00:31:21,856 --> 00:31:23,276
NSSecureCoding badges and use


1177
00:31:23,276 --> 00:31:25,036
them that this year, we've added


1178
00:31:25,086 --> 00:31:26,776
new API and NSKeyedUnarchiver to


1179
00:31:26,776 --> 00:31:28,426
make sure that NSSecureCoding is


1180
00:31:28,426 --> 00:31:29,506
done wherever possible.


1181
00:31:31,276 --> 00:31:32,456
This new initializer and


1182
00:31:32,456 --> 00:31:33,936
convenience methods, turns on


1183
00:31:33,936 --> 00:31:35,746
secure coding by default and


1184
00:31:35,746 --> 00:31:37,126
sets the default decoding


1185
00:31:37,126 --> 00:31:38,516
failure policy to set error in


1186
00:31:38,516 --> 00:31:38,866
return.


1187
00:31:39,346 --> 00:31:40,236
So, unless you change the


1188
00:31:40,236 --> 00:31:41,536
decoding failure policy on your


1189
00:31:41,536 --> 00:31:42,576
own, you don't have to worry


1190
00:31:42,576 --> 00:31:43,736
about exceptions in Swift.


1191
00:31:43,736 --> 00:31:47,316
And indeed, the old initializer


1192
00:31:47,316 --> 00:31:48,776
and convenience methods are


1193
00:31:48,776 --> 00:31:50,186
deprecated in favor of these


1194
00:31:50,186 --> 00:31:50,736
versions.


1195
00:31:50,956 --> 00:31:51,996
So, we really want you to use


1196
00:31:51,996 --> 00:31:52,146
them.


1197
00:31:53,726 --> 00:31:55,106
And similarly, we've introduced


1198
00:31:55,106 --> 00:31:56,066
the same APIs on


1199
00:31:56,096 --> 00:31:58,066
NSKeyedUnarchiver, to make it


1200
00:31:58,066 --> 00:31:58,996
easier for you to turn


1201
00:31:58,996 --> 00:32:00,426
SecureCoding on when archiving.


1202
00:32:00,426 --> 00:32:01,636
And this is equally important


1203
00:32:02,116 --> 00:32:03,386
because it makes sure you can't


1204
00:32:03,386 --> 00:32:05,026
accidentally archive an object


1205
00:32:05,336 --> 00:32:06,336
which doesn't conform to


1206
00:32:06,336 --> 00:32:07,136
NSSecureCoding.


1207
00:32:07,406 --> 00:32:08,616
And you wouldn't later able to


1208
00:32:08,616 --> 00:32:09,096
decode it.


1209
00:32:10,096 --> 00:32:11,786
And again, the old initializer


1210
00:32:11,786 --> 00:32:12,816
and convenience methods are


1211
00:32:12,816 --> 00:32:13,386
deprecated.


1212
00:32:13,896 --> 00:32:14,856
And so, this means that if you


1213
00:32:14,856 --> 00:32:15,996
have old code that looks like


1214
00:32:16,036 --> 00:32:19,026
this, well turn on SecureCoding


1215
00:32:19,026 --> 00:32:19,716
when archiving.


1216
00:32:20,446 --> 00:32:21,716
And switch to the convenience


1217
00:32:21,716 --> 00:32:22,986
methods that allow you to pass


1218
00:32:22,986 --> 00:32:23,946
in that type information


1219
00:32:23,946 --> 00:32:24,346
upfront.


1220
00:32:25,606 --> 00:32:26,826
This way, you can actually make


1221
00:32:26,826 --> 00:32:28,166
use of your SecureCoding badge.


1222
00:32:28,676 --> 00:32:29,486
Make sure you've earned it.


1223
00:32:31,116 --> 00:32:32,636
Now, if you can't yet support


1224
00:32:32,636 --> 00:32:33,956
SecureCoding, because your types


1225
00:32:33,956 --> 00:32:35,876
can't conform, or they,


1226
00:32:35,876 --> 00:32:37,226
themselves depend on types which


1227
00:32:37,226 --> 00:32:38,596
don't yet conform, that's okay.


1228
00:32:38,706 --> 00:32:39,996
You can still use these methods.


1229
00:32:40,756 --> 00:32:42,666
On nCode, simply turn off the


1230
00:32:42,666 --> 00:32:43,756
secure coding requirement.


1231
00:32:44,226 --> 00:32:45,396
And on decode, these


1232
00:32:45,396 --> 00:32:46,666
conveniences always have


1233
00:32:46,666 --> 00:32:47,586
SecureCoding enabled.


1234
00:32:48,836 --> 00:32:50,096
So, instead use the new


1235
00:32:50,096 --> 00:32:51,196
initializer to create a


1236
00:32:51,196 --> 00:32:52,816
KeyedUnarchiver, and then turn


1237
00:32:52,816 --> 00:32:54,476
SecureCoding off, manually.


1238
00:32:55,776 --> 00:32:56,536
This also gives you the


1239
00:32:56,536 --> 00:32:58,026
opportunity to reset the


1240
00:32:58,026 --> 00:32:59,456
decoding failure policy back to


1241
00:32:59,456 --> 00:33:01,586
the old default in case you need


1242
00:33:02,386 --> 00:33:02,466
it.


1243
00:33:02,966 --> 00:33:03,806
Once you have such an


1244
00:33:03,806 --> 00:33:05,416
Unarchiver, well you can decode


1245
00:33:05,416 --> 00:33:06,026
as usual.


1246
00:33:06,686 --> 00:33:09,916
Now, if you're working on a


1247
00:33:09,916 --> 00:33:11,976
Swift app, NSSecureCoding isn't


1248
00:33:11,976 --> 00:33:13,306
the only way for you to convert


1249
00:33:13,306 --> 00:33:14,836
your own model types to external


1250
00:33:14,836 --> 00:33:17,016
representations and back.


1251
00:33:17,726 --> 00:33:18,906
Last year with Swift 4, we


1252
00:33:18,906 --> 00:33:20,246
introduced the Codable protocols


1253
00:33:20,246 --> 00:33:21,636
which make it easier to do just


1254
00:33:21,636 --> 00:33:21,836
that.


1255
00:33:21,836 --> 00:33:24,696
And importantly, all the design


1256
00:33:24,696 --> 00:33:26,026
decisions that made their way


1257
00:33:26,186 --> 00:33:28,126
into NSSecureCoding were also


1258
00:33:28,126 --> 00:33:29,646
present in Codable from day one.


1259
00:33:30,796 --> 00:33:32,956
Specifically, Codable never


1260
00:33:32,956 --> 00:33:34,166
writes type information into


1261
00:33:34,166 --> 00:33:34,806
archives.


1262
00:33:35,096 --> 00:33:36,146
So, there's nothing to trust


1263
00:33:36,146 --> 00:33:36,576
later on.


1264
00:33:36,576 --> 00:33:38,796
By requiring you to pass in


1265
00:33:38,796 --> 00:33:40,446
static type information upfront


1266
00:33:40,446 --> 00:33:41,976
about what you expect to decode,


1267
00:33:42,376 --> 00:33:43,696
you can prevent exactly this


1268
00:33:43,696 --> 00:33:44,966
sort of attack.


1269
00:33:45,776 --> 00:33:47,396
Now, Codable also comes with


1270
00:33:47,426 --> 00:33:48,196
conveniences.


1271
00:33:48,196 --> 00:33:49,626
If you have a type whose fields


1272
00:33:49,626 --> 00:33:51,366
are all themselves codable, well


1273
00:33:51,366 --> 00:33:52,406
you'll get a synthesized


1274
00:33:52,406 --> 00:33:53,706
implementation of the init from


1275
00:33:53,706 --> 00:33:54,886
and encode to requirements.


1276
00:33:55,806 --> 00:33:56,716
And the synthesized


1277
00:33:56,716 --> 00:33:58,086
implementation gives you type


1278
00:33:58,086 --> 00:33:59,236
and nullability checking for


1279
00:33:59,236 --> 00:33:59,546
free.


1280
00:34:00,236 --> 00:34:01,696
But as we saw, most types


1281
00:34:01,696 --> 00:34:03,276
require additional validation if


1282
00:34:03,276 --> 00:34:04,596
they come from external sources,


1283
00:34:04,626 --> 00:34:05,446
just like ours do.


1284
00:34:06,586 --> 00:34:07,896
So, we need to further validate


1285
00:34:07,896 --> 00:34:08,156
those.


1286
00:34:09,366 --> 00:34:11,585
So, we can do that for our own


1287
00:34:11,585 --> 00:34:12,856
types by overwriting in it with


1288
00:34:13,085 --> 00:34:13,916
init from decoder.


1289
00:34:13,996 --> 00:34:15,985
And in this case, again, here's


1290
00:34:15,985 --> 00:34:17,466
that JSON response from earlier.


1291
00:34:17,656 --> 00:34:18,996
And I can trivially turn it into


1292
00:34:18,996 --> 00:34:20,386
a Codable type by simply


1293
00:34:20,386 --> 00:34:21,376
creating a type with all the


1294
00:34:21,376 --> 00:34:22,366
same name fields.


1295
00:34:23,726 --> 00:34:24,606
Because all these fields are


1296
00:34:24,606 --> 00:34:26,216
codable, I get that free


1297
00:34:26,216 --> 00:34:27,545
implementation of init from and


1298
00:34:27,545 --> 00:34:27,996
encode to.


1299
00:34:28,886 --> 00:34:30,005
But, I want to override init


1300
00:34:30,005 --> 00:34:31,436
from to make sure I'm performing


1301
00:34:31,436 --> 00:34:32,596
the same validation that I was


1302
00:34:32,596 --> 00:34:33,516
before with the primitive


1303
00:34:33,516 --> 00:34:33,936
values.


1304
00:34:34,676 --> 00:34:36,716
So, I can do that here, the same


1305
00:34:36,716 --> 00:34:36,886
way.


1306
00:34:38,536 --> 00:34:40,926
Where my old code decoded the ID


1307
00:34:41,016 --> 00:34:42,866
from the payload by downcasting


1308
00:34:42,866 --> 00:34:44,846
to an int, I can do similarly


1309
00:34:44,896 --> 00:34:46,646
here by decoding an int from the


1310
00:34:46,646 --> 00:34:47,025
decoder.


1311
00:34:48,496 --> 00:34:50,366
If the type found in the payload


1312
00:34:50,676 --> 00:34:52,226
is of a different type or is


1313
00:34:52,226 --> 00:34:53,315
missing, this will throw an


1314
00:34:53,315 --> 00:34:54,295
error that indicates what


1315
00:34:54,295 --> 00:34:54,656
happened.


1316
00:34:55,246 --> 00:34:58,866
Now, more important than that is


1317
00:34:58,866 --> 00:35:00,166
my own validation that I added


1318
00:35:00,166 --> 00:35:01,186
in that validate method.


1319
00:35:01,926 --> 00:35:03,406
Here, I want to make sure I keep


1320
00:35:03,406 --> 00:35:04,816
performing that same validation


1321
00:35:04,816 --> 00:35:06,336
to make sure the ID is valid.


1322
00:35:06,546 --> 00:35:07,336
And here, I can use a


1323
00:35:07,336 --> 00:35:08,616
convenience method to throw a


1324
00:35:08,616 --> 00:35:10,096
meaningful error that indicates


1325
00:35:10,976 --> 00:35:12,946
what happened.


1326
00:35:13,476 --> 00:35:14,866
Now, later in that validate


1327
00:35:14,866 --> 00:35:16,316
function I might've pulled that


1328
00:35:16,316 --> 00:35:18,026
creation date out as a string


1329
00:35:18,026 --> 00:35:19,616
and then had to pass it along to


1330
00:35:19,616 --> 00:35:22,586
a date formatter to get a valid


1331
00:35:22,586 --> 00:35:25,186
date back out.


1332
00:35:25,396 --> 00:35:26,836
Here, because we can use JSON


1333
00:35:26,836 --> 00:35:29,156
decoder, we can simply decode a


1334
00:35:29,156 --> 00:35:30,336
date directly, we don't have to


1335
00:35:30,336 --> 00:35:31,416
worry about that type


1336
00:35:31,446 --> 00:35:31,926
conversion.


1337
00:35:32,766 --> 00:35:34,266
We can use JSON decoders date


1338
00:35:34,296 --> 00:35:36,556
decoding policy to indicate what


1339
00:35:36,556 --> 00:35:37,816
sort of conversion can happen


1340
00:35:37,816 --> 00:35:37,936
here.


1341
00:35:38,186 --> 00:35:40,386
And this is nice because this


1342
00:35:40,386 --> 00:35:41,636
conversion became a one-liner.


1343
00:35:42,796 --> 00:35:44,626
And, the other decode call is


1344
00:35:44,626 --> 00:35:46,156
also a one-liner, which makes it


1345
00:35:46,156 --> 00:35:47,496
easy for me to focus on the


1346
00:35:47,496 --> 00:35:48,946
types of validation that I care


1347
00:35:49,536 --> 00:35:49,726
about.


1348
00:35:51,056 --> 00:35:52,706
Now, later on in the validate


1349
00:35:52,706 --> 00:35:53,786
function, I might have also


1350
00:35:53,786 --> 00:35:55,316
pulled out that substructure of


1351
00:35:55,316 --> 00:35:57,126
tags out as an array of strings,


1352
00:35:57,336 --> 00:35:58,876
and later had to map those


1353
00:35:58,876 --> 00:36:00,496
strings to my own type, maybe


1354
00:36:00,586 --> 00:36:02,026
for further validation later on.


1355
00:36:04,026 --> 00:36:05,736
Here, again with Codable, I have


1356
00:36:05,736 --> 00:36:07,286
the benefit of tag conforming to


1357
00:36:07,286 --> 00:36:08,126
Codable itself.


1358
00:36:08,126 --> 00:36:09,806
And so, I can just decode an


1359
00:36:09,806 --> 00:36:10,816
array of tags directly.


1360
00:36:11,726 --> 00:36:12,846
This happens automatically.


1361
00:36:12,846 --> 00:36:14,356
And instead of focusing on the


1362
00:36:14,356 --> 00:36:15,456
type conversion, allows me to


1363
00:36:15,456 --> 00:36:16,776
focus on the validation that


1364
00:36:16,776 --> 00:36:17,386
matters to me.


1365
00:36:18,236 --> 00:36:19,416
This lets me make sure that this


1366
00:36:19,466 --> 00:36:20,686
data is data I can trust.


1367
00:36:24,156 --> 00:36:25,966
We talked about a lot today.


1368
00:36:27,196 --> 00:36:28,636
We started with raw data and


1369
00:36:28,636 --> 00:36:30,326
carried it all away across the


1370
00:36:30,326 --> 00:36:31,776
abstraction spectrum to our own


1371
00:36:31,776 --> 00:36:32,476
model types.


1372
00:36:32,716 --> 00:36:34,486
And along the way we saw how to


1373
00:36:34,486 --> 00:36:38,456
build trust into that data by


1374
00:36:38,676 --> 00:36:40,496
validating a checksum, or the


1375
00:36:40,496 --> 00:36:42,056
length on that raw data, we made


1376
00:36:42,056 --> 00:36:43,366
sure that it was valid to work


1377
00:36:43,366 --> 00:36:45,226
with an inspect, and even check


1378
00:36:45,716 --> 00:36:46,666
whether it conforms to some


1379
00:36:46,666 --> 00:36:47,046
format.


1380
00:36:47,356 --> 00:36:48,556
Once we've made sure that it


1381
00:36:48,556 --> 00:36:50,746
conforms to a known format, we


1382
00:36:50,746 --> 00:36:52,636
knew that that formatted data


1383
00:36:52,636 --> 00:36:54,376
was valid to work with and pull


1384
00:36:54,446 --> 00:36:55,466
primitive values out of.


1385
00:36:57,196 --> 00:36:59,106
By validating the contents and


1386
00:36:59,106 --> 00:37:00,476
structure of those primitive


1387
00:37:00,476 --> 00:37:02,006
values, we made sure that it was


1388
00:37:02,006 --> 00:37:03,346
valid to work with them to turn


1389
00:37:03,346 --> 00:37:05,026
them into our own model types.


1390
00:37:06,476 --> 00:37:07,966
By validating the semantics and


1391
00:37:07,966 --> 00:37:09,216
relationships between those


1392
00:37:09,216 --> 00:37:10,846
model types, we made sure that


1393
00:37:10,846 --> 00:37:12,166
they were valid to work with and


1394
00:37:12,166 --> 00:37:13,076
that they were data we could


1395
00:37:13,766 --> 00:37:13,946
trust.


1396
00:37:15,216 --> 00:37:16,746
So, where to go from here?


1397
00:37:18,116 --> 00:37:19,136
Well, now that you know all of


1398
00:37:19,136 --> 00:37:20,346
this, I encourage you to go and


1399
00:37:20,346 --> 00:37:21,926
look at your code and do just


1400
00:37:21,926 --> 00:37:22,286
this.


1401
00:37:23,386 --> 00:37:26,426
Validate data at every stage in


1402
00:37:26,426 --> 00:37:27,476
the lifecycle of that data.


1403
00:37:28,046 --> 00:37:29,406
Check for types and nullability.


1404
00:37:29,646 --> 00:37:30,916
But more importantly, range, and


1405
00:37:30,916 --> 00:37:32,186
length, and domain-specific


1406
00:37:32,186 --> 00:37:32,926
applications.


1407
00:37:33,516 --> 00:37:35,956
If you have NSCoding types,


1408
00:37:36,246 --> 00:37:37,736
audit those types and earn your


1409
00:37:37,796 --> 00:37:38,816
NSSecureCoding badge.


1410
00:37:38,936 --> 00:37:40,186
And don't just earn it, use it.


1411
00:37:40,286 --> 00:37:41,786
Turn on secure coding wherever


1412
00:37:41,786 --> 00:37:42,146
you can.


1413
00:37:43,656 --> 00:37:45,596
And lastly, for new data types,


1414
00:37:45,666 --> 00:37:47,556
adopt Codable where possible and


1415
00:37:47,556 --> 00:37:48,826
make sure to perform that


1416
00:37:48,826 --> 00:37:49,456
validation.


1417
00:37:50,246 --> 00:37:51,556
Make sure you're only ever


1418
00:37:51,556 --> 00:37:53,826
working with data you can trust.


1419
00:37:54,936 --> 00:37:56,026
For more information about


1420
00:37:56,026 --> 00:37:57,926
Codable, specifically, see last


1421
00:37:57,926 --> 00:37:58,976
year's talk about What's New in


1422
00:37:58,976 --> 00:37:59,486
Foundation.


1423
00:37:59,716 --> 00:38:01,076
But if you have more questions


1424
00:38:01,076 --> 00:38:02,346
about this topic or want to come


1425
00:38:02,346 --> 00:38:04,136
to us for help on how to apply


1426
00:38:04,136 --> 00:38:05,626
this in your own apps, come to


1427
00:38:05,626 --> 00:38:06,766
our lab later today, we have a


1428
00:38:06,766 --> 00:38:07,816
foundation lab, where we can


1429
00:38:07,816 --> 00:38:09,446
help you do just that.


1430
00:38:10,096 --> 00:38:11,636
With that, I'd like to say thank


1431
00:38:11,636 --> 00:38:12,066
you very much.


1432
00:38:13,266 --> 00:38:13,716
Have a great day.


1433
00:38:14,516 --> 00:38:17,500
[ Applause ]

