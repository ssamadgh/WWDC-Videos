1
00:00:07,516 --> 00:00:15,500
[ Music ]


2
00:00:21,516 --> 00:00:27,776
[ Applause ]


3
00:00:28,276 --> 00:00:28,666
>> Thank you.


4
00:00:29,326 --> 00:00:30,746
My name is Dan Omachi, I'm an


5
00:00:30,746 --> 00:00:32,036
engineer in Apple's Metal


6
00:00:32,086 --> 00:00:32,946
Ecosystem Team.


7
00:00:33,606 --> 00:00:35,536
Now my main role on that team is


8
00:00:35,536 --> 00:00:37,136
to help developers learn Metal


9
00:00:37,136 --> 00:00:38,346
and have a great experience


10
00:00:38,346 --> 00:00:38,766
using it.


11
00:00:39,476 --> 00:00:41,326
But prior to this I worked on


12
00:00:41,326 --> 00:00:43,456
Apple's OpenGL and OpenGL ES


13
00:00:43,636 --> 00:00:44,686
frameworks for many years.


14
00:00:45,086 --> 00:00:46,716
And even before joining Apple I


15
00:00:46,716 --> 00:00:47,746
worked on a couple of other


16
00:00:47,746 --> 00:00:48,936
OpenGL implementations.


17
00:00:50,926 --> 00:00:53,286
So I'm really proud of what


18
00:00:53,446 --> 00:00:55,576
we've accomplished with OpenGL


19
00:00:55,736 --> 00:00:57,866
over the past years, but I'm


20
00:00:57,866 --> 00:00:59,976
also really excited about the


21
00:00:59,976 --> 00:01:02,166
direction Metal's taking us.


22
00:01:02,936 --> 00:01:04,726
Today my colleague Sukanya


23
00:01:04,726 --> 00:01:05,906
Sudugu and I are going to give


24
00:01:05,906 --> 00:01:07,556
you a brief introduction to


25
00:01:07,556 --> 00:01:10,066
Metal and provide some guidance


26
00:01:10,456 --> 00:01:12,526
about how you can easily port


27
00:01:12,526 --> 00:01:15,156
your OpenGL apps over.


28
00:01:15,386 --> 00:01:16,906
Now this is particularly


29
00:01:16,906 --> 00:01:19,016
important this year because as


30
00:01:19,016 --> 00:01:20,876
announced in yesterday's state


31
00:01:20,876 --> 00:01:23,466
of the union OpenGL, openGL ES


32
00:01:23,676 --> 00:01:25,366
and OpenCL are deprecated.


33
00:01:26,336 --> 00:01:28,206
Now existing and soon-to-be


34
00:01:28,206 --> 00:01:30,346
launched apps can still use


35
00:01:30,716 --> 00:01:35,006
OpenGL ES on tvOS and iOS12 and


36
00:01:35,636 --> 00:01:40,706
OpenGL and OpenCL on macOS 10.14


37
00:01:40,706 --> 00:01:43,326
Mojave and this will remain so


38
00:01:43,926 --> 00:01:44,626
for some time.


39
00:01:45,476 --> 00:01:48,286
However, new projects should


40
00:01:48,286 --> 00:01:49,906
target Metal from their


41
00:01:49,906 --> 00:01:50,486
inception.


42
00:01:51,026 --> 00:01:51,886
So if you're not already


43
00:01:51,886 --> 00:01:53,446
familiar with Metal, then it's


44
00:01:53,446 --> 00:01:54,156
time to get started.


45
00:01:55,806 --> 00:01:56,886
Before you rip out all of your


46
00:01:56,886 --> 00:01:58,416
OpenGL code and start porting it


47
00:01:58,416 --> 00:01:59,526
all to Metal you've got a few


48
00:01:59,526 --> 00:02:00,446
options to consider.


49
00:02:01,376 --> 00:02:03,156
Apple offers several high-level


50
00:02:03,226 --> 00:02:04,906
frameworks that do rendering,


51
00:02:05,466 --> 00:02:06,446
different kinds of rendering,


52
00:02:06,836 --> 00:02:08,846
SpriteKit for 2D games, SceneKit


53
00:02:08,846 --> 00:02:10,756
for some 3D, Core Image for


54
00:02:10,756 --> 00:02:11,966
great effects.


55
00:02:13,526 --> 00:02:15,456
Also, each of the major


56
00:02:15,566 --> 00:02:17,366
third-party game engines already


57
00:02:17,366 --> 00:02:19,176
use Metal as their primary


58
00:02:19,176 --> 00:02:19,596
renderer.


59
00:02:20,776 --> 00:02:22,886
But you may decide that these


60
00:02:22,886 --> 00:02:24,426
approaches just aren't for you


61
00:02:24,756 --> 00:02:25,866
and the path forward is to do it


62
00:02:25,866 --> 00:02:28,086
yourself in Metal, that's what


63
00:02:28,086 --> 00:02:30,416
we'll talk about today.


64
00:02:30,566 --> 00:02:31,746
So let's start out with Metal


65
00:02:31,746 --> 00:02:33,416
design and some fundamental


66
00:02:33,416 --> 00:02:33,966
concepts.


67
00:02:35,536 --> 00:02:37,246
So OpenGL was originally


68
00:02:37,246 --> 00:02:39,326
designed 25 years ago and its


69
00:02:39,366 --> 00:02:41,286
core reflects the origins of


70
00:02:41,286 --> 00:02:42,736
hardware accelerated 3D


71
00:02:42,736 --> 00:02:43,226
graphics.


72
00:02:44,696 --> 00:02:46,676
So updates with new versions and


73
00:02:46,676 --> 00:02:48,266
extensions have really served us


74
00:02:48,266 --> 00:02:49,766
well by exposing new GPU


75
00:02:49,836 --> 00:02:51,146
features and performance


76
00:02:51,146 --> 00:02:51,666
techniques.


77
00:02:52,806 --> 00:02:54,436
However, there are still some


78
00:02:54,436 --> 00:02:56,276
fundamental design choices that


79
00:02:56,276 --> 00:02:58,016
no longer apply to current


80
00:02:58,016 --> 00:02:58,396
hardware.


81
00:03:00,856 --> 00:03:02,326
The OpenGL pipeline was


82
00:03:02,326 --> 00:03:03,826
originally an entirely fixed


83
00:03:03,826 --> 00:03:05,746
function and although today


84
00:03:05,746 --> 00:03:07,526
OpenGL supports a programmable


85
00:03:07,526 --> 00:03:09,726
pipeline it doesn't neatly match


86
00:03:09,786 --> 00:03:12,826
that of modern GPUs.


87
00:03:13,036 --> 00:03:15,356
Also, asynchronous processing is


88
00:03:15,356 --> 00:03:16,726
not a core feature of the API,


89
00:03:17,476 --> 00:03:18,436
there are a number of features


90
00:03:18,436 --> 00:03:19,576
which allude to the fact that


91
00:03:19,576 --> 00:03:20,656
the GPU works in parallel with


92
00:03:20,656 --> 00:03:22,076
your app but much of this is


93
00:03:22,076 --> 00:03:22,586
implicit.


94
00:03:23,046 --> 00:03:26,586
And 25 years ago only the most


95
00:03:26,586 --> 00:03:27,766
expensive workstations and


96
00:03:27,766 --> 00:03:29,186
servers had multiple cores.


97
00:03:29,676 --> 00:03:30,956
So designing an efficient


98
00:03:30,956 --> 00:03:32,716
multithreading model wasn't a


99
00:03:32,716 --> 00:03:33,216
priority.


100
00:03:33,216 --> 00:03:37,516
So back in 2014, it was clear to


101
00:03:37,516 --> 00:03:39,116
us that a new application


102
00:03:39,116 --> 00:03:40,286
interface for the GPU was


103
00:03:40,286 --> 00:03:40,836
necessary.


104
00:03:41,696 --> 00:03:42,856
Obviously, we needed an


105
00:03:42,856 --> 00:03:44,176
interface that could efficiently


106
00:03:44,176 --> 00:03:45,406
harness the GPU's power.


107
00:03:46,576 --> 00:03:48,076
To do that the app needed the


108
00:03:48,076 --> 00:03:49,826
CPU out of the way so the GPU


109
00:03:49,826 --> 00:03:51,946
could do its thing.


110
00:03:52,146 --> 00:03:53,836
But when an app needs the CPU


111
00:03:53,836 --> 00:03:54,976
for rendering it needs to be


112
00:03:54,976 --> 00:03:56,466
able to use all of the CPU,


113
00:03:56,906 --> 00:03:58,176
including its multiple cores.


114
00:03:59,626 --> 00:04:01,146
If the interface needed to be


115
00:04:01,146 --> 00:04:02,416
predictable to prevent


116
00:04:02,716 --> 00:04:04,056
developers from falling into


117
00:04:04,136 --> 00:04:08,586
hidden pitfalls in the API every


118
00:04:08,586 --> 00:04:09,926
call should have an obvious


119
00:04:09,926 --> 00:04:12,146
consequence and few operations


120
00:04:12,206 --> 00:04:13,846
should be performed implicitly.


121
00:04:14,336 --> 00:04:16,476
Part of this predictability


122
00:04:16,576 --> 00:04:17,805
would be the need to control


123
00:04:17,805 --> 00:04:19,916
where resources were placed and


124
00:04:19,956 --> 00:04:21,826
if and when synchronization was


125
00:04:21,826 --> 00:04:22,376
necessary.


126
00:04:22,966 --> 00:04:26,156
Now Apple had a few other


127
00:04:26,156 --> 00:04:26,686
requirements.


128
00:04:27,896 --> 00:04:29,456
We wanted this interface to be


129
00:04:29,456 --> 00:04:31,416
approachable, it needed to have


130
00:04:31,416 --> 00:04:32,536
the right balance between


131
00:04:32,536 --> 00:04:34,306
low-level control and clear


132
00:04:34,306 --> 00:04:36,436
usage because the easier it is


133
00:04:36,436 --> 00:04:37,556
for you to understand something


134
00:04:37,876 --> 00:04:39,156
the more effectively and


135
00:04:39,206 --> 00:04:40,566
efficiently you can use it.


136
00:04:41,976 --> 00:04:43,766
And of course, we designed Metal


137
00:04:43,766 --> 00:04:46,516
to map well to all modern GPUs.


138
00:04:46,516 --> 00:04:49,486
In particular, we knew that


139
00:04:49,486 --> 00:04:50,446
hardware coming down the


140
00:04:50,496 --> 00:04:52,666
pipeline needed software that


141
00:04:52,666 --> 00:04:53,216
could push it.


142
00:04:53,906 --> 00:04:55,556
This included the Apple designed


143
00:04:55,696 --> 00:04:58,486
GPU of the A11 bionic.


144
00:04:59,956 --> 00:05:01,326
So how is Metal different than


145
00:05:01,326 --> 00:05:01,736
OpenGL?


146
00:05:02,196 --> 00:05:03,556
Well you perform the most


147
00:05:03,626 --> 00:05:06,036
expensive operations less often.


148
00:05:07,046 --> 00:05:08,236
Objects are designed in such a


149
00:05:08,236 --> 00:05:09,916
way that API state can be


150
00:05:09,916 --> 00:05:12,226
translated and prepackaged into


151
00:05:12,226 --> 00:05:13,926
GPU commands at creation.


152
00:05:15,726 --> 00:05:17,406
This way, there's much less cost


153
00:05:17,406 --> 00:05:18,556
to use them later on when


154
00:05:18,556 --> 00:05:19,266
actually rendering.


155
00:05:20,576 --> 00:05:21,656
The graphics pipeline with


156
00:05:21,686 --> 00:05:23,286
Vertex and fragment shaders also


157
00:05:23,286 --> 00:05:24,756
reflects the modern GPU.


158
00:05:25,716 --> 00:05:27,396
So it's less costly to translate


159
00:05:27,516 --> 00:05:29,526
the API's configuration to GP


160
00:05:29,526 --> 00:05:29,986
commands.


161
00:05:31,236 --> 00:05:32,926
This doesn't mean the pipeline


162
00:05:32,926 --> 00:05:34,296
is entirely different or


163
00:05:34,296 --> 00:05:35,666
requires some whole new way of


164
00:05:35,666 --> 00:05:36,026
thinking.


165
00:05:36,946 --> 00:05:38,256
The main difference in Metal is


166
00:05:38,256 --> 00:05:39,406
that the grouping of the


167
00:05:39,436 --> 00:05:41,686
pipeline stages into objects is


168
00:05:41,686 --> 00:05:43,326
more efficient, not that the


169
00:05:43,326 --> 00:05:45,396
pipeline itself is changed.


170
00:05:46,816 --> 00:05:49,366
Metal also has a clear model for


171
00:05:49,366 --> 00:05:50,616
multithreaded execution.


172
00:05:51,496 --> 00:05:52,356
There are a number of different


173
00:05:52,356 --> 00:05:53,976
ways for applications to drive


174
00:05:53,976 --> 00:05:55,796
the GPU from different threads,


175
00:05:56,286 --> 00:05:57,906
but for each there are explicit


176
00:05:57,996 --> 00:05:59,456
but unconstraining rules to do


177
00:05:59,456 --> 00:05:59,686
this.


178
00:06:01,036 --> 00:06:02,546
Additionally, the most commonly


179
00:06:02,546 --> 00:06:03,836
used objects like textures,


180
00:06:03,936 --> 00:06:05,936
buffers and shaders can safely


181
00:06:05,936 --> 00:06:07,346
and efficiently be used across


182
00:06:07,406 --> 00:06:07,726
threads.


183
00:06:08,526 --> 00:06:10,156
Metal does not need to perform


184
00:06:10,326 --> 00:06:11,776
any expensive internal logging


185
00:06:11,776 --> 00:06:13,306
operations to prevent these


186
00:06:13,306 --> 00:06:14,546
objects from getting into some


187
00:06:14,546 --> 00:06:15,456
invalid state.


188
00:06:17,516 --> 00:06:19,616
Finally, the execution model


189
00:06:19,616 --> 00:06:21,036
reflects what really goes on


190
00:06:21,076 --> 00:06:22,696
between software and the GPU.


191
00:06:23,266 --> 00:06:24,926
Many of the implicit operations


192
00:06:25,046 --> 00:06:26,406
performed by OpenGL are


193
00:06:26,406 --> 00:06:28,116
explicitly performed by an


194
00:06:28,116 --> 00:06:29,886
application using Metal.


195
00:06:30,636 --> 00:06:31,836
This allows you to make


196
00:06:31,836 --> 00:06:33,666
intelligent decisions as to when


197
00:06:33,666 --> 00:06:35,966
and how your app uses the GPU.


198
00:06:36,946 --> 00:06:37,966
It also means there's less


199
00:06:37,966 --> 00:06:39,036
software between your


200
00:06:39,036 --> 00:06:40,586
application and the GPU.


201
00:06:41,216 --> 00:06:43,286
Most Metal calls go directly to


202
00:06:43,286 --> 00:06:45,096
the GPU driver and that driver


203
00:06:45,096 --> 00:06:46,726
also needs to do less processing


204
00:06:46,726 --> 00:06:48,746
to translate from API calls to


205
00:06:48,746 --> 00:06:49,526
GPU commands.


206
00:06:51,216 --> 00:06:52,216
So let's dive in and see how


207
00:06:52,216 --> 00:06:52,636
this works.


208
00:06:53,256 --> 00:06:56,466
All GL calls are performed on an


209
00:06:56,466 --> 00:06:57,506
OpenGL context.


210
00:06:57,916 --> 00:06:59,846
The context does a ton of


211
00:06:59,846 --> 00:07:01,966
things, it tracks API state, it


212
00:07:02,166 --> 00:07:03,766
manages OpenGL objects and other


213
00:07:03,766 --> 00:07:05,246
memory, and translates and


214
00:07:05,246 --> 00:07:06,506
submits GPU commands.


215
00:07:07,366 --> 00:07:09,066
Metal splits all of these jobs


216
00:07:09,066 --> 00:07:10,626
of an OpenGL context into a


217
00:07:10,626 --> 00:07:12,956
number of smaller objects.


218
00:07:14,056 --> 00:07:16,336
The first object that creates is


219
00:07:16,336 --> 00:07:18,616
a Metal device which is an


220
00:07:18,716 --> 00:07:20,626
abstract representation of a


221
00:07:20,776 --> 00:07:21,686
physical GPU.


222
00:07:22,256 --> 00:07:26,286
The device creates objects such


223
00:07:26,286 --> 00:07:27,646
as textures, buffers and


224
00:07:27,646 --> 00:07:29,216
pipeline objects which contain


225
00:07:29,216 --> 00:07:29,906
shaders.


226
00:07:31,026 --> 00:07:32,886
It also creates a key object


227
00:07:33,136 --> 00:07:34,636
called a Metal command queue.


228
00:07:35,196 --> 00:07:37,816
The command queue really only


229
00:07:37,816 --> 00:07:39,796
has one job, to create a


230
00:07:39,796 --> 00:07:41,176
sequence of command buffers.


231
00:07:41,956 --> 00:07:43,506
Here we've created one command


232
00:07:43,506 --> 00:07:44,856
buffer and a command buffer is


233
00:07:44,856 --> 00:07:46,706
simply a list of GPU commands


234
00:07:46,956 --> 00:07:48,956
that your app will fill and send


235
00:07:48,956 --> 00:07:50,146
to the GPU for execution.


236
00:07:51,166 --> 00:07:52,836
Typically your app will create a


237
00:07:52,836 --> 00:07:54,926
single command buffer per frame,


238
00:07:55,016 --> 00:07:55,866
however, there are some


239
00:07:55,866 --> 00:07:57,566
situations where it makes sense


240
00:07:57,696 --> 00:08:00,166
to create two or three in a


241
00:08:00,696 --> 00:08:00,886
frame.


242
00:08:01,026 --> 00:08:02,256
But an app doesn't write these


243
00:08:02,256 --> 00:08:03,606
commands directly to the command


244
00:08:03,606 --> 00:08:05,216
buffer, instead it creates a


245
00:08:05,216 --> 00:08:06,586
Metal command encoder.


246
00:08:07,886 --> 00:08:09,356
The command encoder translates


247
00:08:09,446 --> 00:08:11,686
API calls into GPU instructions


248
00:08:11,906 --> 00:08:13,006
and writes them to the command


249
00:08:13,006 --> 00:08:13,266
buffer.


250
00:08:14,336 --> 00:08:15,666
After a series of commands have


251
00:08:15,666 --> 00:08:17,426
been encoded your app will end


252
00:08:17,426 --> 00:08:18,916
encoding and release the encoder


253
00:08:18,916 --> 00:08:19,336
object.


254
00:08:20,536 --> 00:08:21,586
There are actually a couple


255
00:08:21,586 --> 00:08:22,756
different kind of encoders and


256
00:08:22,756 --> 00:08:24,146
your app can create new encoders


257
00:08:24,146 --> 00:08:25,106
from the command buffer to


258
00:08:25,146 --> 00:08:25,876
encode more commands.


259
00:08:31,156 --> 00:08:32,616
Now it's important to note that


260
00:08:32,616 --> 00:08:34,346
up until now on this diagram the


261
00:08:34,346 --> 00:08:36,186
GPU hasn't done any work.


262
00:08:37,106 --> 00:08:38,666
Metal has created objects and


263
00:08:38,666 --> 00:08:40,726
encoded commands all with the


264
00:08:40,775 --> 00:08:41,145
CPU.


265
00:08:41,876 --> 00:08:43,166
It's only after your app has


266
00:08:43,216 --> 00:08:45,356
finished encoding commands and


267
00:08:45,356 --> 00:08:46,356
committed the command buffer


268
00:08:47,446 --> 00:08:49,226
that the GPU begins to work and


269
00:08:49,226 --> 00:08:51,376
executes those commands.


270
00:08:52,576 --> 00:08:54,566
You can also encode commands to


271
00:08:54,566 --> 00:08:56,226
multiple command buffers in


272
00:08:56,266 --> 00:08:57,816
parallel on separate threads.


273
00:08:58,466 --> 00:09:02,056
Now I've already spoken about


274
00:09:02,056 --> 00:09:03,876
how the command queue produces a


275
00:09:03,876 --> 00:09:06,276
sequence of command buffers and


276
00:09:06,276 --> 00:09:07,606
that you create a command


277
00:09:07,606 --> 00:09:09,286
encoder from a command buffer.


278
00:09:10,196 --> 00:09:11,216
Let's take a closer look at


279
00:09:11,216 --> 00:09:13,096
these encoder objects used to


280
00:09:13,096 --> 00:09:14,466
write to our command buffers.


281
00:09:15,726 --> 00:09:17,036
There are three main types.


282
00:09:18,096 --> 00:09:18,986
There's the Render Command


283
00:09:18,986 --> 00:09:20,606
Encoder whose commands resemble


284
00:09:20,606 --> 00:09:22,266
that of an OpenGL command string


285
00:09:22,356 --> 00:09:23,776
where you set state, bind


286
00:09:23,776 --> 00:09:25,316
objects, and issue draw calls.


287
00:09:26,446 --> 00:09:27,736
There's the Blit Command Encoder


288
00:09:27,906 --> 00:09:29,306
with which you can issue texture


289
00:09:29,306 --> 00:09:31,246
and buffer copy operations.


290
00:09:31,576 --> 00:09:32,786
You can also use it to generate


291
00:09:32,786 --> 00:09:34,526
Mipmap for textures and transfer


292
00:09:34,566 --> 00:09:36,156
pixel data from buffers similar


293
00:09:36,156 --> 00:09:38,076
to how glReadPixels operates


294
00:09:38,076 --> 00:09:39,656
with OpenGL's pixel buffer


295
00:09:39,656 --> 00:09:40,266
objects.


296
00:09:40,806 --> 00:09:43,496
And then there's the Compute


297
00:09:43,756 --> 00:09:46,076
Command Encoder which allows you


298
00:09:46,076 --> 00:09:48,466
to dispatch commute kernels.


299
00:09:49,316 --> 00:09:50,826
The Render Command Encoder is


300
00:09:50,826 --> 00:09:51,746
probably the encoder you'll


301
00:09:51,746 --> 00:09:53,356
become most familiar with as


302
00:09:53,356 --> 00:09:54,346
it's responsible for the


303
00:09:54,346 --> 00:09:56,206
majority of operations that a


304
00:09:56,206 --> 00:09:57,976
graphic centric app needs.


305
00:09:59,306 --> 00:10:00,816
The set of commands encoded into


306
00:10:00,816 --> 00:10:01,966
a Render Command Encoder is


307
00:10:02,006 --> 00:10:03,686
often referred to as a Render


308
00:10:03,686 --> 00:10:03,836
Pass.


309
00:10:05,406 --> 00:10:06,576
In a Render Pass you set up


310
00:10:06,576 --> 00:10:08,016
render objects for the graphics


311
00:10:08,016 --> 00:10:10,236
pipeline and issue draw commands


312
00:10:10,676 --> 00:10:11,586
with those objects.


313
00:10:12,226 --> 00:10:13,726
This includes operations similar


314
00:10:13,726 --> 00:10:15,946
to glDrawArrays and


315
00:10:15,946 --> 00:10:18,696
glDrawElements and other OpenGL


316
00:10:18,816 --> 00:10:19,566
draw commands.


317
00:10:21,006 --> 00:10:22,416
Each Render Command Encoder is


318
00:10:22,416 --> 00:10:24,156
strongly associated with a set


319
00:10:24,306 --> 00:10:25,126
of render targets.


320
00:10:26,976 --> 00:10:28,806
And the render target is simply


321
00:10:28,806 --> 00:10:30,306
a texture that can be drawn to.


322
00:10:30,846 --> 00:10:32,636
This includes color, depth and


323
00:10:32,666 --> 00:10:34,166
stencil textures, as well as


324
00:10:34,166 --> 00:10:35,356
multi-sample textures.


325
00:10:36,436 --> 00:10:37,606
You specify a set of render


326
00:10:37,606 --> 00:10:38,976
targets when you create a render


327
00:10:38,976 --> 00:10:40,686
command encoder from a command


328
00:10:42,196 --> 00:10:42,336
buffer.


329
00:10:42,516 --> 00:10:43,906
And all draw commands are


330
00:10:43,906 --> 00:10:45,596
directed to these targets for


331
00:10:45,596 --> 00:10:47,036
the lifetime of the encoder.


332
00:10:48,506 --> 00:10:49,826
To direct commands to a new set


333
00:10:49,826 --> 00:10:51,396
of targets you end encoding with


334
00:10:51,396 --> 00:10:52,886
a current render command encoder


335
00:10:53,116 --> 00:10:55,536
and create a new encoder with


336
00:10:55,536 --> 00:10:56,256
new targets.


337
00:10:57,216 --> 00:10:58,836
This creates a very clear


338
00:10:58,836 --> 00:11:01,076
delineation between commands


339
00:11:01,126 --> 00:11:02,916
directed to different sets of


340
00:11:02,916 --> 00:11:03,506
render targets.


341
00:11:04,186 --> 00:11:06,196
Let's talk a little bit about


342
00:11:06,506 --> 00:11:07,896
the object you'll use for


343
00:11:07,896 --> 00:11:08,256
rendering.


344
00:11:09,446 --> 00:11:10,476
Metal has a number of similar


345
00:11:10,476 --> 00:11:11,276
objects to OpenGL.


346
00:11:11,276 --> 00:11:14,346
There are textures, buffers,


347
00:11:15,136 --> 00:11:17,846
samplers and pipeline state


348
00:11:17,846 --> 00:11:19,666
objects which resemble OpenGL's


349
00:11:19,696 --> 00:11:22,086
program objects, and also depth


350
00:11:22,206 --> 00:11:23,766
stencil state objects which


351
00:11:23,766 --> 00:11:24,966
don't really exists in OpenGL


352
00:11:25,176 --> 00:11:26,706
but are just the containers for


353
00:11:26,706 --> 00:11:28,156
the same depth and stencil state


354
00:11:28,396 --> 00:11:29,346
that OpenGL's got.


355
00:11:31,496 --> 00:11:32,996
One significant difference


356
00:11:33,076 --> 00:11:35,556
between OpenGL and Metal objects


357
00:11:35,906 --> 00:11:37,616
are how they are created and


358
00:11:37,616 --> 00:11:37,866
managed.


359
00:11:39,176 --> 00:11:40,336
The objects are all created from


360
00:11:40,336 --> 00:11:41,756
a device object so they're


361
00:11:41,756 --> 00:11:43,426
associated with a single GPU.


362
00:11:44,716 --> 00:11:46,156
You set most of an object state


363
00:11:46,276 --> 00:11:48,316
when you create it by specifying


364
00:11:48,646 --> 00:11:50,186
properties in a descriptor


365
00:11:50,186 --> 00:11:50,656
object.


366
00:11:51,936 --> 00:11:53,656
All states set when the object


367
00:11:53,656 --> 00:11:55,166
is created is fixed and


368
00:11:55,166 --> 00:11:55,596
immutable.


369
00:11:56,946 --> 00:11:58,306
Although the state of textures


370
00:11:58,306 --> 00:11:59,856
and buffers are fixed upon


371
00:11:59,856 --> 00:12:02,226
creation, data contained by


372
00:12:02,226 --> 00:12:03,976
these objects can be changed.


373
00:12:04,626 --> 00:12:07,296
Metal can do all the expensive


374
00:12:07,446 --> 00:12:09,016
setup for an object once when


375
00:12:09,016 --> 00:12:09,596
it's created.


376
00:12:10,396 --> 00:12:12,146
OpenGL's mutable model makes it


377
00:12:12,176 --> 00:12:13,766
completely possible that if your


378
00:12:13,766 --> 00:12:15,186
app touches a little piece of


379
00:12:15,186 --> 00:12:18,176
state the recompilation of that


380
00:12:18,176 --> 00:12:19,206
object may occur.


381
00:12:19,946 --> 00:12:21,256
And even if your app doesn't


382
00:12:21,256 --> 00:12:23,846
change an object state OpenGL


383
00:12:23,846 --> 00:12:25,176
needs to check a hierarchy of


384
00:12:25,226 --> 00:12:26,856
flags to confirm this before


385
00:12:26,856 --> 00:12:27,326
drawing.


386
00:12:28,186 --> 00:12:30,596
So with this immutable model


387
00:12:30,596 --> 00:12:32,176
Metal never needs to check for


388
00:12:32,176 --> 00:12:34,106
object state changes make draw


389
00:12:34,106 --> 00:12:36,016
calls much faster.


390
00:12:37,556 --> 00:12:39,166
Additionally, objects can be


391
00:12:39,256 --> 00:12:41,106
efficiently used across threads,


392
00:12:41,516 --> 00:12:42,756
Metal never needs to lock an


393
00:12:42,756 --> 00:12:43,746
object to prevent it from


394
00:12:43,746 --> 00:12:44,996
getting into an invalid state


395
00:12:45,146 --> 00:12:45,956
from a change on another thread.


396
00:12:51,306 --> 00:12:52,826
So let's talk about porting.


397
00:12:52,826 --> 00:12:57,256
Here is the typical phase, here


398
00:12:57,256 --> 00:12:59,286
are typical phases of a


399
00:12:59,286 --> 00:13:00,226
rendering application.


400
00:13:01,046 --> 00:13:02,166
You build the app compiling


401
00:13:02,166 --> 00:13:03,746
source and bundling your assets.


402
00:13:04,696 --> 00:13:05,926
Start up and initializing it.


403
00:13:06,306 --> 00:13:07,796
Loading the assets and


404
00:13:07,796 --> 00:13:09,666
initializing objects that will


405
00:13:09,666 --> 00:13:11,386
persist for the lifetime of your


406
00:13:11,386 --> 00:13:11,986
application.


407
00:13:13,236 --> 00:13:14,966
And you repeatedly render


408
00:13:15,456 --> 00:13:16,976
setting up state, issuing many


409
00:13:16,976 --> 00:13:19,336
draw calls, and presenting frame


410
00:13:19,486 --> 00:13:19,986
after frame.


411
00:13:20,676 --> 00:13:23,816
I'll talk about developing for


412
00:13:23,816 --> 00:13:25,686
Metal in the earlier stages of


413
00:13:25,686 --> 00:13:26,796
the application's lifetime,


414
00:13:28,316 --> 00:13:29,806
including building shaders


415
00:13:29,806 --> 00:13:31,176
offline and creating object's


416
00:13:31,176 --> 00:13:32,136
initialization.


417
00:13:33,256 --> 00:13:34,666
And Sukanya will describe how to


418
00:13:34,666 --> 00:13:36,396
port your per frame rendering


419
00:13:36,396 --> 00:13:36,656
code.


420
00:13:38,676 --> 00:13:39,936
So let's start out with


421
00:13:39,936 --> 00:13:41,706
application build time which is


422
00:13:41,706 --> 00:13:43,166
where shaders are typically


423
00:13:43,226 --> 00:13:43,736
compiled.


424
00:13:44,896 --> 00:13:46,246
We'll begin with a look at the


425
00:13:46,246 --> 00:13:47,006
shading language.


426
00:13:47,866 --> 00:13:49,006
The Metal shading language is


427
00:13:49,126 --> 00:13:50,476
based on C++.


428
00:13:50,936 --> 00:13:53,316
So just like C++ you can create


429
00:13:53,386 --> 00:13:55,206
classes, templates, structures,


430
00:13:55,606 --> 00:13:57,336
define enums and namespaces.


431
00:13:58,466 --> 00:14:00,156
Like GLSL there are built-in


432
00:14:00,156 --> 00:14:02,796
vector and matrix types, and


433
00:14:02,796 --> 00:14:04,176
numerous built-in functions and


434
00:14:04,176 --> 00:14:05,856
operators commonly used for


435
00:14:05,856 --> 00:14:06,436
graphics.


436
00:14:06,486 --> 00:14:09,236
And there are classes to specify


437
00:14:09,316 --> 00:14:11,006
sampler state and operate on


438
00:14:11,006 --> 00:14:11,426
textures.


439
00:14:12,966 --> 00:14:13,986
The best way to describe the


440
00:14:13,986 --> 00:14:15,166
language is just to show you.


441
00:14:15,396 --> 00:14:17,166
So here is a vertex and fragment


442
00:14:17,166 --> 00:14:17,846
shader pair.


443
00:14:19,336 --> 00:14:20,966
The vertex keyword at the


444
00:14:20,966 --> 00:14:22,516
function at the top specifies


445
00:14:22,586 --> 00:14:24,196
that that function is a vertex


446
00:14:24,196 --> 00:14:25,886
shader, likewise for the


447
00:14:25,886 --> 00:14:27,496
fragment keyword for the


448
00:14:27,496 --> 00:14:28,306
function at the bottom.


449
00:14:29,706 --> 00:14:31,366
Note that they have custom names


450
00:14:31,426 --> 00:14:33,226
unlike GLSL where every shader


451
00:14:33,266 --> 00:14:34,116
is just called main.


452
00:14:34,756 --> 00:14:35,726
This is important because it


453
00:14:35,726 --> 00:14:37,166
allows you to build large


454
00:14:37,166 --> 00:14:38,976
libraries of unique shaders


455
00:14:39,206 --> 00:14:40,966
using names to indicate what


456
00:14:41,026 --> 00:14:41,506
they do.


457
00:14:41,936 --> 00:14:44,446
Anything passed from your


458
00:14:44,446 --> 00:14:46,176
application is an argument to


459
00:14:46,176 --> 00:14:47,266
one of these shaders.


460
00:14:48,026 --> 00:14:49,316
There aren't any loose variables


461
00:14:49,316 --> 00:14:50,486
outside of functions as there


462
00:14:50,486 --> 00:14:51,416
are with GLSL.


463
00:14:52,486 --> 00:14:53,786
As you can see, there are these


464
00:14:53,846 --> 00:14:55,216
bracketed symbols next to each


465
00:14:55,216 --> 00:14:55,646
parameter.


466
00:14:56,226 --> 00:14:58,136
These are attribute specifiers


467
00:14:58,386 --> 00:14:59,946
which extend upon the C++


468
00:14:59,946 --> 00:15:01,656
language to indicate special


469
00:15:01,656 --> 00:15:02,236
variables.


470
00:15:03,456 --> 00:15:05,666
So this vertex ID attribute


471
00:15:05,746 --> 00:15:07,446
indicates that this VID


472
00:15:07,446 --> 00:15:08,576
parameter should contain the


473
00:15:08,666 --> 00:15:11,126
index of the current vertex when


474
00:15:11,126 --> 00:15:12,826
this vertex executes.


475
00:15:13,196 --> 00:15:14,906
It's used down here in two


476
00:15:14,906 --> 00:15:17,166
places to index into an array of


477
00:15:17,166 --> 00:15:17,676
vertices.


478
00:15:18,226 --> 00:15:20,636
These parameters here with a


479
00:15:20,636 --> 00:15:22,866
buffer attribute specifier these


480
00:15:22,866 --> 00:15:24,186
indicate that these variables


481
00:15:24,226 --> 00:15:26,106
are filled by buffer's objects


482
00:15:26,246 --> 00:15:27,436
set in the Metal API.


483
00:15:27,436 --> 00:15:29,596
I'll talk more about how the


484
00:15:29,596 --> 00:15:31,106
Metal API relates to these in


485
00:15:31,106 --> 00:15:31,596
just a minute.


486
00:15:32,266 --> 00:15:33,626
But first let's take a closer


487
00:15:33,626 --> 00:15:34,926
look at some of the types used


488
00:15:34,926 --> 00:15:35,136
here.


489
00:15:36,056 --> 00:15:37,776
Now these are all custom types


490
00:15:38,366 --> 00:15:39,386
that you would define.


491
00:15:40,406 --> 00:15:41,656
The vertices parameter here is


492
00:15:41,656 --> 00:15:43,606
defined as a pointer to a vertex


493
00:15:43,606 --> 00:15:45,656
type and its definition is right


494
00:15:45,656 --> 00:15:45,886
here.


495
00:15:46,706 --> 00:15:48,836
The structure has two members, a


496
00:15:48,836 --> 00:15:50,586
model position member and a


497
00:15:50,586 --> 00:15:51,736
texture coordinate member.


498
00:15:52,446 --> 00:15:54,116
It defines the layout and memory


499
00:15:54,146 --> 00:15:56,186
of each vertex in a vertex array


500
00:15:56,526 --> 00:15:58,096
passed into this vertex shader.


501
00:15:59,836 --> 00:16:01,336
Let's look at this vertex output


502
00:16:01,336 --> 00:16:02,946
type returned by our vertex


503
00:16:02,946 --> 00:16:03,186
shader.


504
00:16:03,776 --> 00:16:06,506
Its definition here specifies


505
00:16:06,506 --> 00:16:07,736
what's passed down for the


506
00:16:07,736 --> 00:16:09,186
rasterization stage and


507
00:16:09,186 --> 00:16:10,466
eventually to the fragment


508
00:16:10,466 --> 00:16:10,806
program.


509
00:16:11,336 --> 00:16:13,756
The four-component


510
00:16:13,756 --> 00:16:15,146
floating-point member named


511
00:16:15,186 --> 00:16:17,396
clipPos has this position


512
00:16:17,396 --> 00:16:18,766
attribute specifier next to it.


513
00:16:19,336 --> 00:16:20,756
This indicates that this member


514
00:16:20,756 --> 00:16:22,096
will serve as the output


515
00:16:22,136 --> 00:16:23,746
position of our vertex shader.


516
00:16:25,116 --> 00:16:26,376
This texCoord member which


517
00:16:26,376 --> 00:16:27,326
doesn't have an attribute


518
00:16:27,326 --> 00:16:30,096
specifier defaults to a variable


519
00:16:30,306 --> 00:16:31,656
that will be interpolated with


520
00:16:31,656 --> 00:16:34,986
the texture coordinate values of


521
00:16:34,986 --> 00:16:36,726
other vertices defining the


522
00:16:36,726 --> 00:16:38,616
rasterized triangle much like a


523
00:16:38,616 --> 00:16:39,986
varying in GLSL.


524
00:16:41,616 --> 00:16:42,616
Let's take a look at some of the


525
00:16:42,616 --> 00:16:43,786
parameters of our fragment


526
00:16:43,786 --> 00:16:44,046
shader.


527
00:16:45,146 --> 00:16:46,796
So we're using this vertexOutput


528
00:16:46,796 --> 00:16:48,966
struct that we just looked at


529
00:16:49,406 --> 00:16:50,846
down here as an input to our


530
00:16:51,076 --> 00:16:51,716
fragment shader.


531
00:16:52,336 --> 00:16:53,966
And it gives us the interpolated


532
00:16:54,006 --> 00:16:55,446
texture coordinate that we


533
00:16:55,716 --> 00:16:57,346
constructed in the vertex shader


534
00:16:58,486 --> 00:17:00,206
and we use it here to sample


535
00:17:00,366 --> 00:17:02,966
from a texture.


536
00:17:03,086 --> 00:17:04,586
In our application code which is


537
00:17:04,586 --> 00:17:06,486
written in Objective-C we use a


538
00:17:06,486 --> 00:17:08,316
Render Command Encoder to map


539
00:17:08,406 --> 00:17:10,226
objects to shader parameters.


540
00:17:12,915 --> 00:17:15,016
The index argument with each of


541
00:17:15,016 --> 00:17:16,396
these calls are similar to


542
00:17:16,396 --> 00:17:18,316
OpenGL's attribute indices,


543
00:17:18,366 --> 00:17:19,935
vertex attribute indices, and


544
00:17:19,935 --> 00:17:20,715
textured units.


545
00:17:21,336 --> 00:17:23,415
They specify indices which map


546
00:17:23,526 --> 00:17:25,296
to indices in our shader


547
00:17:25,296 --> 00:17:25,836
parameters.


548
00:17:27,026 --> 00:17:29,056
So by calling the encoder's set


549
00:17:29,106 --> 00:17:30,526
fragment buffer method with an


550
00:17:30,526 --> 00:17:33,046
index of three we map this my


551
00:17:33,046 --> 00:17:35,346
uniform buffer object to the


552
00:17:35,346 --> 00:17:37,446
uniform's parameter of our


553
00:17:37,446 --> 00:17:38,936
encoder, of our shader.


554
00:17:39,536 --> 00:17:42,326
We make similar calls to set our


555
00:17:42,326 --> 00:17:44,836
texture and sampler objects.


556
00:17:50,396 --> 00:17:52,096
Now I want to talk about one


557
00:17:52,096 --> 00:17:53,996
library that's incredibly useful


558
00:17:54,106 --> 00:17:55,606
for shader development.


559
00:17:57,236 --> 00:17:58,576
This is called SIMD.


560
00:17:58,896 --> 00:18:00,666
Now SIMD is actually a library


561
00:18:00,966 --> 00:18:02,616
that's separate from Metal and


562
00:18:03,126 --> 00:18:04,656
is used in many orthogonal


563
00:18:04,716 --> 00:18:05,246
frameworks.


564
00:18:05,836 --> 00:18:07,366
But it was built with Metal in


565
00:18:07,366 --> 00:18:07,686
mind.


566
00:18:08,936 --> 00:18:10,886
SIMD defines vector and matrix


567
00:18:10,886 --> 00:18:12,786
types commonly used to implement


568
00:18:13,286 --> 00:18:15,056
graphics algorithms, so this


569
00:18:15,056 --> 00:18:16,036
includes three and four


570
00:18:16,036 --> 00:18:17,846
component vector types and three


571
00:18:17,846 --> 00:18:19,796
by three and four by four matrix


572
00:18:19,796 --> 00:18:19,976
types.


573
00:18:24,046 --> 00:18:24,906
One of the nicest features of


574
00:18:24,906 --> 00:18:26,676
this library is that you can use


575
00:18:26,676 --> 00:18:30,496
it to share code between your


576
00:18:30,496 --> 00:18:33,306
application code and your


577
00:18:33,306 --> 00:18:34,966
shading language code.


578
00:18:35,596 --> 00:18:37,216
This is really useful because


579
00:18:37,216 --> 00:18:38,856
you can define the layout of


580
00:18:38,926 --> 00:18:39,986
data passed from your


581
00:18:39,986 --> 00:18:42,066
application to your shaders with


582
00:18:42,066 --> 00:18:43,426
structures using these types.


583
00:18:44,046 --> 00:18:44,766
Here's how it works.


584
00:18:45,996 --> 00:18:47,276
You create a structure with data


585
00:18:47,346 --> 00:18:48,216
you'd like to pass from your


586
00:18:48,216 --> 00:18:49,516
application to your shaders.


587
00:18:49,836 --> 00:18:51,396
So for instance, if you want to


588
00:18:51,396 --> 00:18:52,536
pass down a model view


589
00:18:52,536 --> 00:18:55,206
projection matrix to the and the


590
00:18:55,206 --> 00:18:56,646
position of the SIMD primary


591
00:18:56,646 --> 00:18:58,696
light source you can use SIMD


592
00:18:58,696 --> 00:19:00,856
types in your structure to do


593
00:19:01,376 --> 00:19:01,546
this.


594
00:19:01,976 --> 00:19:02,746
You put the structure's


595
00:19:02,746 --> 00:19:05,106
definition and a header which


596
00:19:05,106 --> 00:19:06,366
you would include in both your


597
00:19:06,366 --> 00:19:08,466
application code and Metal


598
00:19:08,466 --> 00:19:08,796
files.


599
00:19:09,116 --> 00:19:10,756
This way the data layout used by


600
00:19:10,756 --> 00:19:12,566
your shaders matches what you've


601
00:19:12,566 --> 00:19:14,036
set in your code because they're


602
00:19:14,036 --> 00:19:15,286
using the same types.


603
00:19:16,686 --> 00:19:18,296
This makes bugs due to layout


604
00:19:18,296 --> 00:19:19,976
mismatches much less common.


605
00:19:24,046 --> 00:19:25,556
One of the key ways in which


606
00:19:25,556 --> 00:19:27,716
Metal achieves its efficiency is


607
00:19:27,716 --> 00:19:29,976
by doing work earlier and less


608
00:19:30,026 --> 00:19:30,456
frequently.


609
00:19:31,376 --> 00:19:33,426
So you'll use Xcode to compile


610
00:19:33,426 --> 00:19:34,896
Metal shader files when you


611
00:19:34,896 --> 00:19:35,856
build your application.


612
00:19:36,986 --> 00:19:38,206
This runs a front-end


613
00:19:38,206 --> 00:19:39,866
compilation performing string


614
00:19:39,866 --> 00:19:41,826
parsing, shader analysis, and


615
00:19:41,826 --> 00:19:43,226
some basic optimizations.


616
00:19:43,986 --> 00:19:45,526
It converts your code into a


617
00:19:45,526 --> 00:19:46,796
binary intermediate


618
00:19:46,796 --> 00:19:48,856
representation that is usable on


619
00:19:48,856 --> 00:19:49,456
any hardware.


620
00:19:50,456 --> 00:19:52,566
Actual GPU machine code isn't


621
00:19:52,566 --> 00:19:54,156
built until your app runs on the


622
00:19:54,156 --> 00:19:54,976
user's system.


623
00:19:55,516 --> 00:19:56,726
But this removes half the


624
00:19:56,726 --> 00:19:58,796
compiled time needed when your


625
00:19:58,796 --> 00:19:58,976
app runs.


626
00:19:59,996 --> 00:20:02,886
The built intermediate


627
00:20:02,886 --> 00:20:05,286
representation binary is


628
00:20:05,376 --> 00:20:07,656
archived into a Metal library


629
00:20:07,656 --> 00:20:07,926
file.


630
00:20:08,576 --> 00:20:10,376
Xcode will compile all the Metal


631
00:20:10,376 --> 00:20:11,656
shader source files into a


632
00:20:11,776 --> 00:20:13,856
default Metal library, placing


633
00:20:13,856 --> 00:20:16,256
it into your app bundle for


634
00:20:16,256 --> 00:20:17,276
retrieval at runtime.


635
00:20:17,936 --> 00:20:20,686
In addition to having Xcode


636
00:20:20,686 --> 00:20:23,286
built shaders you also can build


637
00:20:23,286 --> 00:20:24,266
shaders during your app's


638
00:20:24,266 --> 00:20:24,726
runtime.


639
00:20:26,126 --> 00:20:27,436
Some OpenGL apps construct


640
00:20:27,436 --> 00:20:28,446
shaders at runtime by


641
00:20:28,546 --> 00:20:30,096
concatenating strings or running


642
00:20:30,096 --> 00:20:31,286
a source code generator of some


643
00:20:31,286 --> 00:20:31,616
kind.


644
00:20:32,646 --> 00:20:33,846
For those gathering all of the


645
00:20:33,846 --> 00:20:35,376
shaders at build time can be a


646
00:20:35,376 --> 00:20:35,826
challenge.


647
00:20:36,846 --> 00:20:38,756
But for bring up purposes or if


648
00:20:38,856 --> 00:20:40,476
built time compilation just


649
00:20:40,476 --> 00:20:41,486
isn't possible for your app


650
00:20:41,876 --> 00:20:43,486
Metal is able to compile shaders


651
00:20:43,486 --> 00:20:45,326
from source at runtime just like


652
00:20:45,326 --> 00:20:45,836
OpenGL.


653
00:20:46,386 --> 00:20:49,346
However, there are a number of


654
00:20:49,346 --> 00:20:50,896
disadvantages to this, most


655
00:20:50,896 --> 00:20:52,416
obviously you give up on the


656
00:20:52,416 --> 00:20:53,636
performance savings of keeping


657
00:20:53,636 --> 00:20:54,986
this work off the user's system.


658
00:20:56,216 --> 00:20:57,206
You won't see any shader


659
00:20:57,206 --> 00:20:58,546
compilation errors at built time


660
00:20:58,546 --> 00:20:59,716
so you'll only find out about


661
00:20:59,716 --> 00:21:00,776
them when you run your app.


662
00:21:01,896 --> 00:21:03,436
Finally, if you compile at


663
00:21:03,436 --> 00:21:04,766
runtime you can't include


664
00:21:04,766 --> 00:21:06,246
headers in your shaders, so you


665
00:21:06,246 --> 00:21:07,526
can't share types between your


666
00:21:07,526 --> 00:21:09,396
shaders or your application


667
00:21:09,396 --> 00:21:09,686
code.


668
00:21:10,236 --> 00:21:12,776
If you use runtime share


669
00:21:12,776 --> 00:21:14,546
compilation to get your app up


670
00:21:14,546 --> 00:21:16,066
and running quickly I strongly


671
00:21:16,066 --> 00:21:18,146
encourage you to spend some time


672
00:21:18,146 --> 00:21:19,086
getting your shaders to build


673
00:21:19,086 --> 00:21:19,966
within Xcode.


674
00:21:20,586 --> 00:21:21,676
This way you can benefit from


675
00:21:21,676 --> 00:21:23,056
not only the runtime performance


676
00:21:23,056 --> 00:21:24,246
savings but also these


677
00:21:24,246 --> 00:21:25,546
conveniences in shader


678
00:21:25,546 --> 00:21:26,046
development.


679
00:21:26,526 --> 00:21:29,426
Let's move onto the steps your


680
00:21:29,426 --> 00:21:30,646
app will need to take to


681
00:21:30,646 --> 00:21:31,946
initialize your Metal renderer,


682
00:21:32,186 --> 00:21:33,376
so this includes creating a


683
00:21:33,376 --> 00:21:34,246
number of objects.


684
00:21:34,746 --> 00:21:36,286
I'll start out with the devices


685
00:21:36,286 --> 00:21:37,666
and command queues and then I'll


686
00:21:37,666 --> 00:21:39,826
describe how to create objects


687
00:21:39,826 --> 00:21:40,966
for your assets, including


688
00:21:40,966 --> 00:21:42,936
textures, buffers and pipeline


689
00:21:42,936 --> 00:21:43,426
objects.


690
00:21:45,046 --> 00:21:47,566
So devices and queues.


691
00:21:47,726 --> 00:21:49,246
These are the first objects


692
00:21:49,366 --> 00:21:50,016
you'll create.


693
00:21:50,636 --> 00:21:53,506
The device is an abstract


694
00:21:53,506 --> 00:21:54,866
representation of a GPU.


695
00:21:56,226 --> 00:21:57,346
It's responsible for creating


696
00:21:57,346 --> 00:21:58,436
objects that are used for


697
00:21:58,436 --> 00:21:59,416
rendering including these


698
00:21:59,456 --> 00:22:00,956
textures, buffers and pipeline


699
00:22:00,956 --> 00:22:01,386
objects.


700
00:22:02,846 --> 00:22:04,506
In iOS since there's only ever


701
00:22:04,506 --> 00:22:06,826
one GPU there's only one device


702
00:22:06,826 --> 00:22:08,626
you can get, but on macOS


703
00:22:08,916 --> 00:22:10,356
systems can have multiple


704
00:22:10,356 --> 00:22:12,216
devices since there may be both


705
00:22:12,216 --> 00:22:14,126
an integrated and discrete GPU


706
00:22:14,126 --> 00:22:16,026
and even multiple eGPUs.


707
00:22:17,236 --> 00:22:18,286
Usually though, getting the


708
00:22:18,286 --> 00:22:20,146
default device is sufficient for


709
00:22:20,146 --> 00:22:21,126
most applications.


710
00:22:21,886 --> 00:22:23,776
And getting this device is


711
00:22:23,826 --> 00:22:25,216
really simple, you call


712
00:22:25,276 --> 00:22:26,876
MTLCreateSystem


713
00:22:26,876 --> 00:22:27,616
DefaultDevice.


714
00:22:28,296 --> 00:22:31,136
One of the first things you'll


715
00:22:31,136 --> 00:22:33,396
do with this device is create a


716
00:22:33,396 --> 00:22:33,966
command queue.


717
00:22:35,746 --> 00:22:37,416
The queue is used mostly in your


718
00:22:37,416 --> 00:22:38,736
applications render loop to


719
00:22:38,736 --> 00:22:40,036
obtain command buffers each


720
00:22:40,086 --> 00:22:41,536
frame, but you want to create


721
00:22:41,536 --> 00:22:42,836
the command queue at


722
00:22:42,996 --> 00:22:43,826
initialization.


723
00:22:45,036 --> 00:22:46,176
Typically, a single queue is


724
00:22:46,176 --> 00:22:48,006
sufficient but more complex apps


725
00:22:48,276 --> 00:22:49,926
that execute many tasks in


726
00:22:49,926 --> 00:22:51,566
parallel may need multiple


727
00:22:51,596 --> 00:22:51,986
queues.


728
00:22:53,206 --> 00:22:54,696
Creating a queue is also really


729
00:22:54,696 --> 00:22:56,666
simple, you call newCommandQueue


730
00:22:56,906 --> 00:22:57,936
with the device you just


731
00:22:57,936 --> 00:22:58,336
created.


732
00:22:58,956 --> 00:22:59,996
And once you've got your queue


733
00:23:00,276 --> 00:23:01,716
you can get command buffers for


734
00:23:01,716 --> 00:23:02,306
your render loop.


735
00:23:02,806 --> 00:23:06,846
Let's move on building your


736
00:23:06,846 --> 00:23:07,546
render objects.


737
00:23:08,216 --> 00:23:10,546
I'm going to talk about creating


738
00:23:10,736 --> 00:23:12,106
three types of objects used for


739
00:23:12,106 --> 00:23:13,936
rendering, textures, buffers and


740
00:23:13,936 --> 00:23:14,426
pipelines.


741
00:23:15,496 --> 00:23:17,846
Let's start with textures.


742
00:23:18,106 --> 00:23:19,466
As mentioned earlier, you create


743
00:23:19,466 --> 00:23:20,726
render objects from a device


744
00:23:20,726 --> 00:23:21,066
object.


745
00:23:22,416 --> 00:23:23,756
You'll use a descriptor object


746
00:23:23,756 --> 00:23:24,836
to create most of these.


747
00:23:25,546 --> 00:23:26,916
Descriptors are really simple


748
00:23:26,916 --> 00:23:28,356
objects without any true


749
00:23:28,356 --> 00:23:28,756
methods.


750
00:23:29,296 --> 00:23:30,586
They only contain properties


751
00:23:30,586 --> 00:23:31,856
needed for object setup.


752
00:23:33,146 --> 00:23:34,526
So for example, to create a


753
00:23:34,526 --> 00:23:35,836
texture you'd use a texture


754
00:23:35,836 --> 00:23:36,326
descriptor.


755
00:23:37,076 --> 00:23:38,306
You specify the properties that


756
00:23:38,306 --> 00:23:39,386
you'd like the created texture


757
00:23:39,386 --> 00:23:39,666
to have.


758
00:23:40,186 --> 00:23:41,406
So things like the type of


759
00:23:41,436 --> 00:23:43,396
texture, 2D, 3D, cubeMap.


760
00:23:44,146 --> 00:23:45,296
The texture's dimensions and the


761
00:23:45,296 --> 00:23:46,486
number of Mipmaps you'd like it


762
00:23:46,486 --> 00:23:47,286
to have.


763
00:23:47,286 --> 00:23:49,746
And the pixel format of data in


764
00:23:50,676 --> 00:23:51,576
the texture.


765
00:23:51,706 --> 00:23:53,416
Once you've set the desired


766
00:23:53,416 --> 00:23:54,346
values for each of the


767
00:23:54,346 --> 00:23:56,076
properties you call a method on


768
00:23:56,076 --> 00:23:58,026
the device to create a usable


769
00:23:58,026 --> 00:23:58,856
texture object.


770
00:24:00,816 --> 00:24:03,156
This also allocates the memory


771
00:24:03,266 --> 00:24:04,726
backing the texture image.


772
00:24:06,086 --> 00:24:07,166
Once you've created the object


773
00:24:07,166 --> 00:24:07,946
you no longer need the


774
00:24:07,946 --> 00:24:09,286
descriptor as it's only used for


775
00:24:09,286 --> 00:24:10,126
object creation.


776
00:24:11,256 --> 00:24:12,296
And properties you set in the


777
00:24:12,296 --> 00:24:13,506
descriptor are locked and can no


778
00:24:13,506 --> 00:24:14,396
longer be changed.


779
00:24:15,766 --> 00:24:17,056
However, the contents of the


780
00:24:17,056 --> 00:24:18,726
texture image can be modified.


781
00:24:18,756 --> 00:24:21,816
So I want to talk about one


782
00:24:21,816 --> 00:24:22,816
property you'll set in the


783
00:24:22,816 --> 00:24:24,096
texture descriptor and you'll


784
00:24:24,096 --> 00:24:25,876
also use when creating a buffer.


785
00:24:26,626 --> 00:24:28,166
This is called the storage mode.


786
00:24:29,286 --> 00:24:30,366
As mentioned, when you create a


787
00:24:30,366 --> 00:24:31,966
texture object Metal allocates


788
00:24:31,966 --> 00:24:33,366
memory for it right then and


789
00:24:33,366 --> 00:24:33,596
there.


790
00:24:34,106 --> 00:24:35,276
The storage mode property tells


791
00:24:35,276 --> 00:24:36,696
Metal in which pool memory it


792
00:24:36,696 --> 00:24:37,406
should be allocated.


793
00:24:38,576 --> 00:24:40,056
The simplest option shared


794
00:24:40,056 --> 00:24:42,436
storage mode gives both the CPU


795
00:24:42,876 --> 00:24:44,046
and the GPU access.


796
00:24:44,656 --> 00:24:46,076
For buffers this means you get a


797
00:24:46,076 --> 00:24:47,666
pointer to the memory backing


798
00:24:47,666 --> 00:24:48,156
the object.


799
00:24:48,996 --> 00:24:50,166
Protectors, this means you can


800
00:24:50,166 --> 00:24:51,926
call certain easy-to-use methods


801
00:24:52,196 --> 00:24:53,806
to set and retrieve data from


802
00:24:53,806 --> 00:24:54,196
the texture.


803
00:24:54,736 --> 00:24:57,246
You can use private storage mode


804
00:24:57,246 --> 00:24:58,836
which only gives the GPU access


805
00:24:58,926 --> 00:25:00,486
to the data, this allows the


806
00:25:00,486 --> 00:25:01,356
Metal to apply some


807
00:25:01,356 --> 00:25:03,906
optimizations it would be unable


808
00:25:03,906 --> 00:25:05,786
to if the CPU also had access to


809
00:25:05,786 --> 00:25:06,206
that data.


810
00:25:06,896 --> 00:25:08,776
But only the GPU can directly


811
00:25:08,886 --> 00:25:10,636
fill the contents of this type


812
00:25:10,636 --> 00:25:11,096
of texture.


813
00:25:12,606 --> 00:25:14,016
You can indirectly fill data


814
00:25:14,206 --> 00:25:15,996
from the CPU using a blit


815
00:25:15,996 --> 00:25:17,786
encoder to copy from a second


816
00:25:18,076 --> 00:25:19,526
intermediate resource using


817
00:25:19,526 --> 00:25:21,026
shared storage.


818
00:25:22,446 --> 00:25:23,966
On devices with dedicated video


819
00:25:23,966 --> 00:25:25,656
memory setting the resource to


820
00:25:25,656 --> 00:25:27,306
use private storage allocates it


821
00:25:27,306 --> 00:25:28,396
in video memory only.


822
00:25:30,396 --> 00:25:32,776
Finally, on macOS you can use a


823
00:25:32,866 --> 00:25:34,056
third storage mode called


824
00:25:34,056 --> 00:25:34,756
managed storage.


825
00:25:35,696 --> 00:25:37,796
This allows both the GPU and CPU


826
00:25:37,826 --> 00:25:39,066
to access the object data.


827
00:25:39,776 --> 00:25:40,946
And on systems with dedicated


828
00:25:40,946 --> 00:25:43,226
video memory Metal may create a


829
00:25:43,226 --> 00:25:44,476
mirrored memory backing for


830
00:25:44,476 --> 00:25:46,056
efficient access by both


831
00:25:46,056 --> 00:25:46,696
processors.


832
00:25:47,926 --> 00:25:49,396
Because of this, explicit calls


833
00:25:49,396 --> 00:25:51,166
are necessary to ensure data is


834
00:25:51,236 --> 00:25:53,476
synchronized for GPU and CPU


835
00:25:53,476 --> 00:25:53,876
access.


836
00:25:58,126 --> 00:25:59,486
Here's an example of creating a


837
00:25:59,486 --> 00:26:00,376
texture object.


838
00:26:00,816 --> 00:26:04,256
First you create a texture


839
00:26:04,256 --> 00:26:06,126
descriptor and set a number of


840
00:26:06,126 --> 00:26:07,966
properties in it, including the


841
00:26:07,966 --> 00:26:08,586
storage mode.


842
00:26:09,106 --> 00:26:12,836
And then we create a texture


843
00:26:13,586 --> 00:26:14,556
using the device.


844
00:26:15,916 --> 00:26:17,166
To fill a texture's image data


845
00:26:17,316 --> 00:26:18,936
we calculate the bytes per row


846
00:26:19,886 --> 00:26:21,336
and just like with GLText


847
00:26:21,336 --> 00:26:23,056
[inaudible] we specify a region


848
00:26:23,056 --> 00:26:23,466
to load.


849
00:26:26,196 --> 00:26:27,536
And then we call the texture


850
00:26:27,536 --> 00:26:29,506
object's replace region method


851
00:26:29,756 --> 00:26:31,596
which copies the data into the


852
00:26:31,596 --> 00:26:32,676
texture from a pointer we


853
00:26:32,676 --> 00:26:32,926
supply.


854
00:26:37,046 --> 00:26:38,266
Now there are a few notable


855
00:26:38,266 --> 00:26:39,396
differences between OpenGL and


856
00:26:39,396 --> 00:26:40,446
Metal texture objects.


857
00:26:40,816 --> 00:26:42,556
While OpenGL does have a sampler


858
00:26:42,556 --> 00:26:43,886
object they are optional.


859
00:26:44,406 --> 00:26:45,576
Wrap modes and filters can be


860
00:26:45,576 --> 00:26:46,826
set in the texture's object


861
00:26:46,826 --> 00:26:47,886
itself in OpenGL.


862
00:26:48,276 --> 00:26:49,736
In Metal you need to create a


863
00:26:49,816 --> 00:26:51,376
separate sampler object or


864
00:26:51,376 --> 00:26:53,576
specify sampler parameters in


865
00:26:54,206 --> 00:26:55,096
your shaders.


866
00:26:55,786 --> 00:26:57,336
Texture image data is not


867
00:26:57,416 --> 00:26:57,946
flipped in Metal.


868
00:26:58,496 --> 00:27:00,996
OpenGL uses a bottom-left origin


869
00:27:01,306 --> 00:27:02,826
while Metal uses a top-left


870
00:27:02,826 --> 00:27:03,196
origin.


871
00:27:03,196 --> 00:27:04,426
So make sure you're aware of the


872
00:27:04,426 --> 00:27:05,736
difference when loading your


873
00:27:05,736 --> 00:27:06,266
textures.


874
00:27:06,686 --> 00:27:09,696
Desktop OpenGL also performs


875
00:27:09,796 --> 00:27:10,866
conversions when the data


876
00:27:10,916 --> 00:27:13,376
supplied is in a different


877
00:27:13,376 --> 00:27:15,016
format than the internal format.


878
00:27:16,456 --> 00:27:18,106
However Metal similar to OpenGL


879
00:27:18,206 --> 00:27:20,346
ES does not, so you'll need to


880
00:27:20,346 --> 00:27:21,406
make sure your assets are


881
00:27:21,436 --> 00:27:23,436
already in the proper format or


882
00:27:23,696 --> 00:27:25,146
implement paths to perform


883
00:27:25,176 --> 00:27:25,696
conversions.


884
00:27:29,066 --> 00:27:32,316
Let's move on to buffers.


885
00:27:32,456 --> 00:27:34,266
Metal uses buffers for all


886
00:27:34,266 --> 00:27:34,976
unstructured data.


887
00:27:41,456 --> 00:27:42,406
They're really similar to


888
00:27:42,406 --> 00:27:44,716
OpenGL's vertex, element and


889
00:27:44,816 --> 00:27:45,646
uniform buffers.


890
00:27:45,926 --> 00:27:47,076
So if you're already using these


891
00:27:47,076 --> 00:27:48,456
buffers in OpenGL you'll have an


892
00:27:48,506 --> 00:27:50,126
easier time with your port.


893
00:27:51,506 --> 00:27:52,686
Creating a buffer is pretty


894
00:27:52,686 --> 00:27:54,456
simple with a device you call


895
00:27:54,516 --> 00:27:55,986
newBufferWithLength specifying


896
00:27:55,986 --> 00:27:57,146
the size of the buffer you want.


897
00:27:57,826 --> 00:27:59,626
You also specify a storage mode.


898
00:28:00,986 --> 00:28:01,996
You load a buffer through the


899
00:28:02,036 --> 00:28:03,506
contents property, which is


900
00:28:03,506 --> 00:28:05,026
simply a void pointer to the


901
00:28:05,026 --> 00:28:06,186
memory backing the buffer.


902
00:28:07,276 --> 00:28:08,706
To Metal's core the data is


903
00:28:08,706 --> 00:28:10,076
completely unstructured, so it's


904
00:28:10,076 --> 00:28:11,896
up to you to define the layout


905
00:28:12,196 --> 00:28:14,066
in your application and share


906
00:28:14,066 --> 00:28:14,296
your code.


907
00:28:15,086 --> 00:28:16,746
Here we're casting the contents


908
00:28:16,826 --> 00:28:18,486
pointer to a structure which


909
00:28:18,486 --> 00:28:20,546
uses some of the SIMD types I


910
00:28:20,546 --> 00:28:21,236
mentioned earlier.


911
00:28:21,236 --> 00:28:23,796
We set the members of the


912
00:28:23,796 --> 00:28:25,466
structure which fills in the


913
00:28:25,466 --> 00:28:26,936
buffer's data using the layout


914
00:28:26,936 --> 00:28:28,286
or application as is defined


915
00:28:28,606 --> 00:28:29,816
with the structure's definition.


916
00:28:31,306 --> 00:28:32,506
As mentioned earlier, you can


917
00:28:32,506 --> 00:28:34,026
share a structure's definition


918
00:28:34,276 --> 00:28:35,406
between your application and


919
00:28:35,406 --> 00:28:36,736
share code which ensures the


920
00:28:36,736 --> 00:28:38,216
layouts match between these two


921
00:28:38,216 --> 00:28:38,886
components.


922
00:28:39,466 --> 00:28:44,846
A common mistake is a mismatch


923
00:28:44,886 --> 00:28:46,456
between buffer data and how it's


924
00:28:46,456 --> 00:28:48,226
interpreted in the shader due to


925
00:28:48,356 --> 00:28:49,556
an assumption or due to


926
00:28:49,556 --> 00:28:51,196
assumptions about alignment.


927
00:28:52,136 --> 00:28:53,476
For instance, you might assume


928
00:28:53,476 --> 00:28:54,496
that the shading language's


929
00:28:54,826 --> 00:28:57,256
float3 type consumes only 12


930
00:28:57,296 --> 00:28:57,576
bytes.


931
00:28:58,266 --> 00:29:00,506
Three 4 byte components is 12


932
00:29:00,506 --> 00:29:01,096
bytes right.


933
00:29:01,936 --> 00:29:03,436
Well if you pack your data that


934
00:29:03,436 --> 00:29:04,716
way you'll run into trouble


935
00:29:05,356 --> 00:29:06,586
because the shading language


936
00:29:06,666 --> 00:29:08,296
actually interprets a float3 as


937
00:29:08,296 --> 00:29:09,586
consuming 16 bytes.


938
00:29:10,336 --> 00:29:11,236
That's because the types are


939
00:29:11,236 --> 00:29:12,936
kept as stricter alignments for


940
00:29:12,936 --> 00:29:16,366
CPU and GPU optimal CPU and GPU


941
00:29:16,366 --> 00:29:16,816
usage.


942
00:29:18,026 --> 00:29:19,626
Similar problems often occur


943
00:29:19,996 --> 00:29:21,176
with three by three matrices.


944
00:29:22,316 --> 00:29:23,936
If you really want to tack, if


945
00:29:23,936 --> 00:29:26,046
you really want to pack data


946
00:29:26,186 --> 00:29:28,996
tightly there are pack types


947
00:29:28,996 --> 00:29:30,416
available in the Metal shading


948
00:29:30,416 --> 00:29:30,776
language.


949
00:29:31,246 --> 00:29:33,126
After passing a pack data in a


950
00:29:33,126 --> 00:29:34,596
buffer your shader code would


951
00:29:34,596 --> 00:29:37,356
need to pack data, would you


952
00:29:37,356 --> 00:29:38,846
need to pass that packed data to


953
00:29:38,846 --> 00:29:40,686
a regular vector before it can


954
00:29:40,686 --> 00:29:42,236
perform operations on that data.


955
00:29:43,716 --> 00:29:45,436
So when you're bringing up your


956
00:29:45,436 --> 00:29:48,446
application I recommend using


957
00:29:48,756 --> 00:29:49,956
the most convenient storage


958
00:29:49,956 --> 00:29:50,376
modes.


959
00:29:51,396 --> 00:29:53,436
This makes it more easy to


960
00:29:53,466 --> 00:29:55,486
access the data in those


961
00:29:55,486 --> 00:29:55,976
resources.


962
00:29:57,006 --> 00:29:58,676
So in iOS create all textures


963
00:29:58,676 --> 00:29:59,696
and buffers with


964
00:30:00,086 --> 00:30:00,976
StorageModeShared.


965
00:30:02,386 --> 00:30:03,726
On macOS you can't use


966
00:30:03,726 --> 00:30:05,076
StorageModeShared with textures,


967
00:30:05,246 --> 00:30:07,146
but StorageModeManaged does make


968
00:30:07,146 --> 00:30:08,526
image data access easier,


969
00:30:08,856 --> 00:30:10,426
although private storage is most


970
00:30:10,426 --> 00:30:10,846
optimal.


971
00:30:16,046 --> 00:30:16,996
You can use StorageModeShared


972
00:30:16,996 --> 00:30:19,216
with buffers on macOS, but be


973
00:30:19,216 --> 00:30:19,906
careful with this.


974
00:30:20,526 --> 00:30:22,456
If you mix data that both the


975
00:30:22,576 --> 00:30:26,066
CPU and GPU needs access to with


976
00:30:26,066 --> 00:30:28,336
data only the GPU needs access


977
00:30:28,376 --> 00:30:29,456
to it can be difficult to


978
00:30:29,456 --> 00:30:31,246
detangle these two types of data


979
00:30:31,246 --> 00:30:33,046
later on and put them in


980
00:30:33,046 --> 00:30:34,286
separate memory pools.


981
00:30:34,906 --> 00:30:37,816
Now that I've described a little


982
00:30:37,816 --> 00:30:39,166
bit about creating textures and


983
00:30:39,166 --> 00:30:41,186
buffer objects directly I'd like


984
00:30:41,186 --> 00:30:42,106
to mention the MetalKit


985
00:30:42,156 --> 00:30:43,526
framework which can easily


986
00:30:43,526 --> 00:30:44,676
create textures and vertex


987
00:30:44,676 --> 00:30:46,156
buffers from common file


988
00:30:46,216 --> 00:30:46,606
formats.


989
00:30:47,146 --> 00:30:48,336
There's a texture loading class


990
00:30:48,626 --> 00:30:50,286
and some functionality to create


991
00:30:50,286 --> 00:30:52,216
Metal buffer backed meshes


992
00:30:52,376 --> 00:30:53,936
loaded by Model I/O.


993
00:30:58,046 --> 00:30:59,106
Let's talk about shaders and the


994
00:30:59,106 --> 00:31:00,506
render pipeline objects that


995
00:31:00,506 --> 00:31:02,036
contain them.


996
00:31:02,776 --> 00:31:04,046
You create one of these pipeline


997
00:31:04,046 --> 00:31:05,766
state objects using a render


998
00:31:05,766 --> 00:31:07,096
pipeline descriptor object.


999
00:31:08,466 --> 00:31:10,116
The object contains a vertex and


1000
00:31:10,116 --> 00:31:11,066
fragment shader pair.


1001
00:31:12,446 --> 00:31:13,886
It also specifies the layout of


1002
00:31:13,886 --> 00:31:15,516
vertices feeding the vertex


1003
00:31:16,286 --> 00:31:16,416
shader.


1004
00:31:17,066 --> 00:31:19,506
And also blend state and the


1005
00:31:19,586 --> 00:31:21,586
pixel formats of render targets


1006
00:31:21,866 --> 00:31:23,706
that the fragment and shader can


1007
00:31:23,706 --> 00:31:24,136
render to.


1008
00:31:25,666 --> 00:31:27,206
Just like with the texture


1009
00:31:27,206 --> 00:31:28,556
object you call method on the


1010
00:31:28,556 --> 00:31:30,136
device which will produce an


1011
00:31:30,136 --> 00:31:31,996
immutable render state pipeline


1012
00:31:31,996 --> 00:31:32,406
object.


1013
00:31:33,706 --> 00:31:34,926
And also like a texture object


1014
00:31:35,056 --> 00:31:36,306
you only need the descriptor to


1015
00:31:36,306 --> 00:31:37,546
create that object.


1016
00:31:38,156 --> 00:31:40,456
Here's some code showing how to


1017
00:31:40,456 --> 00:31:41,726
build these pipeline state


1018
00:31:41,726 --> 00:31:42,226
objects.


1019
00:31:43,536 --> 00:31:44,916
Before you create the pipeline,


1020
00:31:45,096 --> 00:31:47,456
you'll need to get the shaders


1021
00:31:47,456 --> 00:31:48,686
out of a Metal library.


1022
00:31:49,256 --> 00:31:51,446
This line here loads the default


1023
00:31:51,446 --> 00:31:53,816
Metal library that we built in


1024
00:31:54,416 --> 00:31:54,586
Xcode.


1025
00:31:54,726 --> 00:31:56,616
For this library you can obtain


1026
00:31:56,616 --> 00:31:58,316
your vertex and fragment shader


1027
00:31:59,116 --> 00:32:00,726
using their function names.


1028
00:32:01,906 --> 00:32:03,146
You create a render pipeline


1029
00:32:03,146 --> 00:32:05,316
descriptor object where you set


1030
00:32:05,316 --> 00:32:06,866
these shading functions and also


1031
00:32:06,866 --> 00:32:08,826
specify render target pixel


1032
00:32:08,826 --> 00:32:09,356
formats.


1033
00:32:10,306 --> 00:32:12,336
Finally, you use the device with


1034
00:32:12,336 --> 00:32:13,726
the descriptor object we've set


1035
00:32:13,726 --> 00:32:16,176
up to produce a pipeline state


1036
00:32:16,826 --> 00:32:17,026
object.


1037
00:32:18,136 --> 00:32:19,836
The most significant difference


1038
00:32:19,866 --> 00:32:21,906
between the OpenGL and Metal


1039
00:32:21,936 --> 00:32:25,316
graphics pipelines is that while


1040
00:32:25,316 --> 00:32:26,856
an OpenGL program object


1041
00:32:26,896 --> 00:32:28,196
contains just a vertex and


1042
00:32:28,226 --> 00:32:29,906
fragment shader pair Metal


1043
00:32:29,946 --> 00:32:31,816
pipeline objects also include a


1044
00:32:31,816 --> 00:32:33,536
vertex layout, blend state, and


1045
00:32:33,536 --> 00:32:34,726
render target pixel format.


1046
00:32:35,566 --> 00:32:36,776
So you need to know all of these


1047
00:32:36,816 --> 00:32:38,886
things before you build a


1048
00:32:39,696 --> 00:32:39,896
pipeline.


1049
00:32:40,016 --> 00:32:41,576
Having these extra pieces of


1050
00:32:41,646 --> 00:32:43,166
state in the pipeline enables


1051
00:32:43,166 --> 00:32:44,886
Metal to fully compile shaders


1052
00:32:44,886 --> 00:32:46,746
into GPU machine code upon


1053
00:32:46,816 --> 00:32:47,576
object creation.


1054
00:32:48,116 --> 00:32:49,006
This is something that's not


1055
00:32:49,006 --> 00:32:50,326
possible with OpenGL's program


1056
00:32:50,326 --> 00:32:50,836
objects.


1057
00:32:51,706 --> 00:32:52,796
Now you'll need to build a


1058
00:32:52,796 --> 00:32:54,146
system that allows you to create


1059
00:32:54,146 --> 00:32:55,896
pipelines when you initialize


1060
00:32:55,896 --> 00:32:56,086
your app.


1061
00:32:57,266 --> 00:32:58,236
It helps if you can choose a


1062
00:32:58,236 --> 00:32:59,816
canonical vertex layout and a


1063
00:32:59,816 --> 00:33:01,546
limited set of render targets.


1064
00:33:02,156 --> 00:33:03,766
This reduces the combinations of


1065
00:33:03,766 --> 00:33:05,486
state your app uses and the


1066
00:33:05,486 --> 00:33:07,116
number of pipeline objects


1067
00:33:07,556 --> 00:33:07,706
needed.


1068
00:33:08,976 --> 00:33:10,786
However, not everyone knows up


1069
00:33:10,846 --> 00:33:12,286
front which pipelines their app


1070
00:33:12,286 --> 00:33:12,656
will need.


1071
00:33:13,286 --> 00:33:14,666
A common first step in porting


1072
00:33:14,666 --> 00:33:16,306
an app to Metal is to keep a


1073
00:33:16,306 --> 00:33:17,786
dictionary of pipelines you've


1074
00:33:17,786 --> 00:33:18,396
already made.


1075
00:33:19,326 --> 00:33:20,566
As your app encounters new


1076
00:33:20,566 --> 00:33:22,196
combinations of state it can


1077
00:33:22,196 --> 00:33:23,836
build and store pipelines using


1078
00:33:23,836 --> 00:33:25,326
the descriptors as keys.


1079
00:33:26,626 --> 00:33:28,206
Keep in mind this solution I


1080
00:33:28,206 --> 00:33:30,326
mentioned is kind of a hack and


1081
00:33:30,326 --> 00:33:31,406
you want to avoid shipping your


1082
00:33:31,406 --> 00:33:31,856
app with it.


1083
00:33:32,426 --> 00:33:33,856
This is because creating any of


1084
00:33:33,856 --> 00:33:35,316
these objects is expensive.


1085
00:33:36,346 --> 00:33:37,196
When you create a pipeline


1086
00:33:37,196 --> 00:33:39,336
object the GPU compiler kicks in


1087
00:33:39,336 --> 00:33:41,396
and translates and optimizes the


1088
00:33:41,396 --> 00:33:42,786
shader's binary intermediate


1089
00:33:42,786 --> 00:33:44,636
representation to machine code.


1090
00:33:45,386 --> 00:33:46,356
If your app creates these


1091
00:33:46,386 --> 00:33:47,986
just-in-time during its render


1092
00:33:47,986 --> 00:33:51,046
loop you're likely to see stalls


1093
00:33:51,356 --> 00:33:53,046
and a reduced frame rate for a


1094
00:33:53,046 --> 00:33:55,786
short period of time.


1095
00:33:55,986 --> 00:33:57,366
Allocating memory for textures


1096
00:33:57,366 --> 00:33:58,906
and buffers is also an expensive


1097
00:33:58,906 --> 00:34:00,526
operation, that's not even


1098
00:34:00,526 --> 00:34:01,586
accounting for the processing


1099
00:34:01,586 --> 00:34:02,896
required to fill in these


1100
00:34:02,896 --> 00:34:03,726
resources with data.


1101
00:34:04,946 --> 00:34:06,076
However, once you've created


1102
00:34:06,076 --> 00:34:07,866
these objects using them in your


1103
00:34:07,866 --> 00:34:09,646
render loop requires very little


1104
00:34:09,746 --> 00:34:11,045
CPU over [inaudible] since so


1105
00:34:11,045 --> 00:34:12,966
much is done up front.


1106
00:34:14,176 --> 00:34:15,485
With that I'd like to hand it


1107
00:34:15,485 --> 00:34:16,716
over to Sukanya who will talk


1108
00:34:16,716 --> 00:34:17,735
about porting your render loop.


1109
00:34:18,516 --> 00:34:22,545
[ Applause ]


1110
00:34:23,045 --> 00:34:24,065
>> Good evening everyone, I am


1111
00:34:24,065 --> 00:34:25,886
Sukanya Sudugu, GPU software


1112
00:34:25,886 --> 00:34:26,856
engineer at Apple.


1113
00:34:27,646 --> 00:34:29,696
I am super excited to share some


1114
00:34:29,696 --> 00:34:31,496
of our porting experience with


1115
00:34:31,496 --> 00:34:32,976
you, so let's continue porting.


1116
00:34:35,876 --> 00:34:37,096
Dan already talked about


1117
00:34:37,096 --> 00:34:39,496
application setup, so by now you


1118
00:34:39,496 --> 00:34:40,795
would have built all your


1119
00:34:40,795 --> 00:34:43,596
shaders and also created all


1120
00:34:43,596 --> 00:34:45,216
persistent objects needed for


1121
00:34:45,216 --> 00:34:46,275
frame generation.


1122
00:34:47,196 --> 00:34:48,656
So now let's dive into your


1123
00:34:48,656 --> 00:34:50,795
application's render loop which


1124
00:34:50,795 --> 00:34:52,516
is the code that runs for every


1125
00:34:52,516 --> 00:34:52,926
frame.


1126
00:34:53,186 --> 00:34:55,996
With Metal you will explicitly


1127
00:34:55,996 --> 00:34:57,616
manage the asynchronous nature


1128
00:34:57,616 --> 00:34:59,556
of GPU's execution in your


1129
00:34:59,556 --> 00:35:00,196
render loop.


1130
00:35:00,876 --> 00:35:03,156
So this includes obtaining and


1131
00:35:03,206 --> 00:35:04,826
submitting command buffers to


1132
00:35:04,826 --> 00:35:06,426
GPU with the list of GPU


1133
00:35:06,426 --> 00:35:06,736
commands.


1134
00:35:06,736 --> 00:35:10,046
And updating your resources in


1135
00:35:10,046 --> 00:35:12,206
such a way that allows the GPU


1136
00:35:12,206 --> 00:35:13,926
to asynchronously read from it


1137
00:35:14,566 --> 00:35:16,086
which you have written in your


1138
00:35:16,176 --> 00:35:16,726
render loop.


1139
00:35:17,266 --> 00:35:19,526
And encoding render passes by


1140
00:35:19,526 --> 00:35:20,686
creating render command


1141
00:35:20,686 --> 00:35:21,326
encoders.


1142
00:35:21,936 --> 00:35:24,636
And finally, presenting your


1143
00:35:24,636 --> 00:35:25,776
frames to the display.


1144
00:35:25,776 --> 00:35:29,196
So let's first talk about this


1145
00:35:29,196 --> 00:35:30,356
command buffer object.


1146
00:35:32,396 --> 00:35:34,066
One of the key changes from


1147
00:35:34,066 --> 00:35:36,536
OpenGL is that Metal provides


1148
00:35:36,606 --> 00:35:38,196
explicit control over command


1149
00:35:38,196 --> 00:35:40,366
buffers, which means it's up to


1150
00:35:40,366 --> 00:35:42,396
you to create these command


1151
00:35:42,396 --> 00:35:44,106
buffers and you can decide when


1152
00:35:44,106 --> 00:35:45,766
to commit them to GPU for its


1153
00:35:45,766 --> 00:35:46,486
execution.


1154
00:35:47,306 --> 00:35:49,496
So the straightforward thing to


1155
00:35:49,496 --> 00:35:51,056
do is to create one command


1156
00:35:51,056 --> 00:35:52,476
buffer which will render your


1157
00:35:52,476 --> 00:35:53,236
whole frame.


1158
00:35:53,946 --> 00:35:55,796
And once your application is up


1159
00:35:55,796 --> 00:35:57,916
and running and if you perhaps


1160
00:35:57,916 --> 00:35:59,816
see some idle time on GPU, then


1161
00:35:59,816 --> 00:36:01,976
you might want to consider


1162
00:36:02,146 --> 00:36:03,396
splitting your frame across


1163
00:36:03,396 --> 00:36:04,606
multiple command buffers.


1164
00:36:05,006 --> 00:36:08,086
And then the GPU can get started


1165
00:36:08,086 --> 00:36:09,796
executing one command buffer


1166
00:36:10,086 --> 00:36:11,486
while CPU is encoding the


1167
00:36:11,486 --> 00:36:11,886
others.


1168
00:36:13,346 --> 00:36:15,106
Alternatively, splitting your


1169
00:36:15,106 --> 00:36:17,386
frame encoding across multiple


1170
00:36:17,386 --> 00:36:19,136
threads requires you to create


1171
00:36:19,136 --> 00:36:20,436
one command buffer per thread.


1172
00:36:20,436 --> 00:36:23,196
But keep in mind that there is


1173
00:36:23,196 --> 00:36:25,056
some additional CPU cost


1174
00:36:25,056 --> 00:36:26,666
associated with each command


1175
00:36:26,666 --> 00:36:27,056
buffer.


1176
00:36:27,496 --> 00:36:29,446
So you should be using as few as


1177
00:36:29,516 --> 00:36:30,066
possible.


1178
00:36:32,216 --> 00:36:34,306
Metal also provides an API to


1179
00:36:34,356 --> 00:36:36,436
register a completion callback,


1180
00:36:37,136 --> 00:36:38,846
which will be involved when GPU


1181
00:36:38,846 --> 00:36:41,006
completes executing this command


1182
00:36:41,006 --> 00:36:41,386
buffer.


1183
00:36:41,986 --> 00:36:43,686
So let me show you all these


1184
00:36:43,686 --> 00:36:44,766
APIs in action.


1185
00:36:45,216 --> 00:36:48,316
So you will have created command


1186
00:36:48,316 --> 00:36:49,516
queue in your application


1187
00:36:49,516 --> 00:36:50,856
initialization method.


1188
00:36:51,356 --> 00:36:53,246
Now in render loop you will use


1189
00:36:53,246 --> 00:36:55,676
it to obtain command buffer by


1190
00:36:55,676 --> 00:36:56,876
calling its command buffer


1191
00:36:56,876 --> 00:36:57,386
method.


1192
00:36:57,946 --> 00:37:00,156
Now you will encode commands


1193
00:37:00,156 --> 00:37:01,156
into this command buffer.


1194
00:37:01,156 --> 00:37:03,086
I'll talk more about this


1195
00:37:03,146 --> 00:37:04,616
encoder shortly.


1196
00:37:05,936 --> 00:37:06,936
But when you are finished


1197
00:37:06,936 --> 00:37:08,846
encoding you will call commit


1198
00:37:08,846 --> 00:37:11,446
method so that this command


1199
00:37:11,446 --> 00:37:13,136
buffer will be submitted to GPU


1200
00:37:13,386 --> 00:37:14,366
for its execution.


1201
00:37:14,366 --> 00:37:17,846
Now you have two options for


1202
00:37:17,916 --> 00:37:19,686
what to do while this command


1203
00:37:19,686 --> 00:37:21,806
buffer is being executed on GPU.


1204
00:37:22,316 --> 00:37:25,526
You can wait by calling this


1205
00:37:25,526 --> 00:37:27,436
waitUntilCompleted method which


1206
00:37:27,436 --> 00:37:29,256
is similar to glFinish in


1207
00:37:29,256 --> 00:37:29,956
OpenGL.


1208
00:37:30,896 --> 00:37:33,026
This method will synchronously


1209
00:37:33,026 --> 00:37:35,456
wait and only returns when all


1210
00:37:35,456 --> 00:37:36,636
the commands in the command


1211
00:37:36,636 --> 00:37:38,296
buffer has been executed by the


1212
00:37:38,296 --> 00:37:38,806
GPU.


1213
00:37:40,916 --> 00:37:44,816
Alternatively, before you commit


1214
00:37:44,816 --> 00:37:46,206
this command buffer to GPU you


1215
00:37:46,206 --> 00:37:48,566
can add a completion handler,


1216
00:37:49,406 --> 00:37:51,286
which will be invoked when GPU


1217
00:37:51,286 --> 00:37:52,916
is done executing this command


1218
00:37:52,916 --> 00:37:53,296
buffer.


1219
00:37:53,946 --> 00:37:56,476
This allows CPU and GPU to


1220
00:37:56,476 --> 00:37:57,576
execute in parallel.


1221
00:37:58,456 --> 00:38:00,486
Also this allows us to track and


1222
00:38:00,486 --> 00:38:02,116
efficiently update shared


1223
00:38:02,116 --> 00:38:04,236
resources whose data is changing


1224
00:38:04,236 --> 00:38:05,076
every frame.


1225
00:38:05,556 --> 00:38:08,676
Since we are here let's talk


1226
00:38:08,676 --> 00:38:09,876
more about these resource


1227
00:38:09,876 --> 00:38:12,486
updates and see how we can make


1228
00:38:12,486 --> 00:38:13,796
them efficient using this


1229
00:38:13,796 --> 00:38:14,656
completion handler.


1230
00:38:14,656 --> 00:38:18,626
So almost all applications will


1231
00:38:18,626 --> 00:38:21,066
be pushing new data to GPU every


1232
00:38:21,066 --> 00:38:21,436
frame.


1233
00:38:21,926 --> 00:38:24,206
For example, new shaded uniforms


1234
00:38:24,316 --> 00:38:25,716
needed for animations.


1235
00:38:26,256 --> 00:38:29,146
In Metal CPU can write to this


1236
00:38:29,146 --> 00:38:31,776
shared resources anytime even if


1237
00:38:31,886 --> 00:38:33,966
GP is accessing the same memory


1238
00:38:35,206 --> 00:38:36,276
at the same time.


1239
00:38:37,376 --> 00:38:38,876
Metal does not protect you


1240
00:38:38,876 --> 00:38:40,456
against these data-races.


1241
00:38:41,256 --> 00:38:44,176
This compares to OpenGL which by


1242
00:38:44,176 --> 00:38:45,666
default prevents these


1243
00:38:45,666 --> 00:38:48,056
data-races either by waiting for


1244
00:38:48,056 --> 00:38:50,676
the GPU workloads to finish or


1245
00:38:50,676 --> 00:38:53,166
by doing extra copies, which may


1246
00:38:53,166 --> 00:38:54,586
not be optimal for your


1247
00:38:54,586 --> 00:38:55,376
application.


1248
00:38:56,256 --> 00:38:58,756
With Metal you can implement any


1249
00:38:58,756 --> 00:39:01,546
optimal synchronization strategy


1250
00:39:01,546 --> 00:39:02,566
which suits best for your


1251
00:39:02,566 --> 00:39:03,376
applications.


1252
00:39:04,256 --> 00:39:06,966
So in most cases, best approach


1253
00:39:07,026 --> 00:39:08,686
is to multi-buffer your shared


1254
00:39:08,686 --> 00:39:11,706
resources so that CPU and GPU


1255
00:39:11,706 --> 00:39:13,286
are never trying to access the


1256
00:39:13,286 --> 00:39:15,136
same buffer simultaneously.


1257
00:39:17,436 --> 00:39:19,916
So let's see an example, you


1258
00:39:19,916 --> 00:39:22,126
have an OpenGL application and


1259
00:39:22,126 --> 00:39:24,676
you just ported it to Metal and


1260
00:39:24,736 --> 00:39:26,296
it is using single buffer for


1261
00:39:26,296 --> 00:39:28,956
these dynamic data updates and


1262
00:39:28,956 --> 00:39:30,386
you did not implement any


1263
00:39:30,386 --> 00:39:32,766
synchronization method yet in


1264
00:39:32,766 --> 00:39:34,306
your application, then here's


1265
00:39:34,306 --> 00:39:36,356
what will happen.


1266
00:39:36,906 --> 00:39:38,316
Your application will write to


1267
00:39:38,316 --> 00:39:39,956
that buffer while generating


1268
00:39:39,956 --> 00:39:41,866
commands for the first frame and


1269
00:39:41,866 --> 00:39:43,336
then submits this command buffer


1270
00:39:43,336 --> 00:39:45,426
to GPU.


1271
00:39:45,426 --> 00:39:47,406
Then GPU when it is executing


1272
00:39:47,406 --> 00:39:48,876
this command buffer will try to


1273
00:39:48,876 --> 00:39:49,896
read from this buffer.


1274
00:39:50,436 --> 00:39:53,796
And while you're updating the


1275
00:39:53,796 --> 00:39:55,446
same buffer for the next frame


1276
00:39:55,686 --> 00:39:57,486
GPU is still reading from this


1277
00:39:57,486 --> 00:39:57,816
buffer.


1278
00:39:58,076 --> 00:40:01,266
So this is clearly a race


1279
00:40:01,266 --> 00:40:03,236
condition and the results are


1280
00:40:03,236 --> 00:40:03,806
undefined.


1281
00:40:03,806 --> 00:40:06,826
There are a few potential fixes


1282
00:40:07,356 --> 00:40:09,066
which you can implement in your


1283
00:40:09,066 --> 00:40:09,806
application.


1284
00:40:10,396 --> 00:40:13,386
The simplest is to call the


1285
00:40:13,386 --> 00:40:14,396
command buffer's


1286
00:40:14,396 --> 00:40:16,736
waitUntilCompleted method after


1287
00:40:16,736 --> 00:40:17,306
every frame.


1288
00:40:18,516 --> 00:40:22,556
But this waits for the GPU to


1289
00:40:22,556 --> 00:40:24,246
finish reading before you


1290
00:40:24,246 --> 00:40:25,706
override this buffer for the


1291
00:40:25,706 --> 00:40:26,296
next frame.


1292
00:40:27,096 --> 00:40:30,936
But as you can see, here this is


1293
00:40:30,936 --> 00:40:32,866
a very poor utilization of both


1294
00:40:33,036 --> 00:40:35,606
CPU and GPU, so this is not


1295
00:40:35,606 --> 00:40:37,376
something you want to do in your


1296
00:40:37,466 --> 00:40:38,166
shipping code.


1297
00:40:38,936 --> 00:40:40,756
But it is very useful to get


1298
00:40:40,756 --> 00:40:42,426
your Metal application up and


1299
00:40:42,426 --> 00:40:42,856
running.


1300
00:40:43,746 --> 00:40:45,976
And even to detect that if your


1301
00:40:45,976 --> 00:40:47,766
application really indeed has


1302
00:40:47,766 --> 00:40:49,716
these kind of data conflicts.


1303
00:40:51,756 --> 00:40:54,366
The efficient way to synchronize


1304
00:40:54,366 --> 00:40:55,926
your resource updates is to use


1305
00:40:55,926 --> 00:40:56,826
multiple buffers.


1306
00:40:57,546 --> 00:40:58,906
So in this case we will use


1307
00:40:58,956 --> 00:41:00,526
three buffers to triple buffer


1308
00:41:00,526 --> 00:41:02,126
our dynamic data updates.


1309
00:41:02,816 --> 00:41:04,756
So in frame 1 we will write to a


1310
00:41:04,756 --> 00:41:06,846
buffer and then the GPU will


1311
00:41:06,846 --> 00:41:07,516
read from it.


1312
00:41:08,206 --> 00:41:10,166
And in frame 2 we will write to


1313
00:41:10,166 --> 00:41:11,856
another buffer avoiding this


1314
00:41:11,856 --> 00:41:12,666
race condition.


1315
00:41:13,326 --> 00:41:15,246
Similarly, in frame 3 we will


1316
00:41:15,246 --> 00:41:18,146
write the third buffer.


1317
00:41:18,346 --> 00:41:20,176
But now we have used up all


1318
00:41:20,176 --> 00:41:21,836
three buffers and exhausted our


1319
00:41:21,836 --> 00:41:22,406
buffer pool.


1320
00:41:23,526 --> 00:41:25,246
We need to wait for the GPU to


1321
00:41:25,246 --> 00:41:27,166
finish the frame 1 so that we


1322
00:41:27,166 --> 00:41:28,616
can reuse it for frame 4.


1323
00:41:29,186 --> 00:41:33,736
Now this completion handler will


1324
00:41:33,736 --> 00:41:35,906
come handy, it will let us know


1325
00:41:35,906 --> 00:41:38,046
when GPU has done executing this


1326
00:41:38,096 --> 00:41:38,406
frame.


1327
00:41:39,096 --> 00:41:41,396
So when frame 1 is done we can


1328
00:41:41,396 --> 00:41:43,586
reuse its buffer for frame 4 and


1329
00:41:44,396 --> 00:41:44,916
so on.


1330
00:41:44,916 --> 00:41:48,696
So let's look at a sample.


1331
00:41:49,226 --> 00:41:52,916
For triple buffer implementation


1332
00:41:53,326 --> 00:41:55,316
outside your render loop first


1333
00:41:55,316 --> 00:41:56,996
we will create a FIFO queue of


1334
00:41:57,086 --> 00:41:57,726
three buffers.


1335
00:41:58,286 --> 00:42:01,006
And we also need a


1336
00:42:01,006 --> 00:42:02,616
frameBoundarySemaphore which is


1337
00:42:02,616 --> 00:42:04,466
initialized to start value as 3.


1338
00:42:05,096 --> 00:42:06,906
So this says semaphore will be


1339
00:42:06,906 --> 00:42:09,276
signaled at each frame boundary,


1340
00:42:09,576 --> 00:42:11,246
that is when GPU finishes


1341
00:42:11,246 --> 00:42:14,046
executing a frame allowing the


1342
00:42:14,046 --> 00:42:17,466
CPU to reuse its buffer.


1343
00:42:17,466 --> 00:42:19,826
Also initialize buffer index to


1344
00:42:19,826 --> 00:42:22,706
point to the current frame's


1345
00:42:23,336 --> 00:42:23,466
buffer.


1346
00:42:23,806 --> 00:42:26,386
And in our render loop before we


1347
00:42:26,386 --> 00:42:28,006
write to a buffer we need to


1348
00:42:28,006 --> 00:42:30,006
first ensure that its


1349
00:42:30,006 --> 00:42:31,276
corresponding frame has


1350
00:42:31,326 --> 00:42:33,176
completed its execution on the


1351
00:42:33,376 --> 00:42:33,926
GPU.


1352
00:42:34,366 --> 00:42:35,836
So at the beginning of the frame


1353
00:42:36,236 --> 00:42:37,386
we wait on our


1354
00:42:37,386 --> 00:42:38,656
frameBoundarySemaphore.


1355
00:42:39,696 --> 00:42:41,386
Once the semaphore is signaled


1356
00:42:41,506 --> 00:42:42,786
indicating that the current


1357
00:42:42,786 --> 00:42:44,166
frame has completed its


1358
00:42:44,166 --> 00:42:46,126
execution on GPU now it's safe


1359
00:42:47,536 --> 00:42:50,846
to grab its buffer and reuse for


1360
00:42:50,846 --> 00:42:51,716
new frame data.


1361
00:42:52,406 --> 00:42:55,426
And we will now encode some


1362
00:42:55,426 --> 00:42:57,846
commands to bind this buffer to


1363
00:42:58,886 --> 00:42:59,176
GPU.


1364
00:42:59,176 --> 00:43:01,186
And before we commit this


1365
00:43:01,186 --> 00:43:03,066
command buffer to GPU we will


1366
00:43:03,066 --> 00:43:05,156
add a completion handler to this


1367
00:43:05,156 --> 00:43:06,556
command buffer for this frame.


1368
00:43:07,186 --> 00:43:10,066
After adding completion handler


1369
00:43:10,066 --> 00:43:11,166
we will commit this command


1370
00:43:11,166 --> 00:43:12,026
buffer to GPU.


1371
00:43:12,926 --> 00:43:16,036
Now once GPU finishes executing


1372
00:43:16,036 --> 00:43:17,806
this frame our completion


1373
00:43:17,806 --> 00:43:19,846
handler will be invoked which


1374
00:43:19,846 --> 00:43:21,486
will then signal this frame


1375
00:43:21,486 --> 00:43:22,006
semaphore.


1376
00:43:23,766 --> 00:43:26,156
This allows CPU to reuse its


1377
00:43:26,186 --> 00:43:27,986
buffer for new frame encoding.


1378
00:43:28,786 --> 00:43:30,666
So this was a simple triple


1379
00:43:30,666 --> 00:43:32,196
buffer implementation which you


1380
00:43:32,196 --> 00:43:33,846
can adopt for handling any


1381
00:43:33,846 --> 00:43:35,996
dynamic data resource updates.


1382
00:43:36,476 --> 00:43:39,376
Now that we have our command


1383
00:43:39,376 --> 00:43:41,426
buffer and also, we have handled


1384
00:43:41,726 --> 00:43:44,246
our resource updates let's talk


1385
00:43:44,246 --> 00:43:46,136
more about render pass encoders


1386
00:43:46,626 --> 00:43:48,306
which you will use to encode


1387
00:43:48,306 --> 00:43:49,796
your draw calls.


1388
00:43:50,276 --> 00:43:52,496
As Dan mentioned earlier,


1389
00:43:52,496 --> 00:43:56,906
command encoders translate API


1390
00:43:57,146 --> 00:43:59,046
calls into GPU hardware commands


1391
00:43:59,046 --> 00:43:59,926
in a command buffer.


1392
00:43:59,926 --> 00:44:02,936
I will be talking about render


1393
00:44:02,936 --> 00:44:04,626
command encoders which provides


1394
00:44:04,626 --> 00:44:06,656
APIs for typical graphics,


1395
00:44:06,816 --> 00:44:08,216
operations like setting your


1396
00:44:08,216 --> 00:44:10,186
pipelines, texture buffer


1397
00:44:10,186 --> 00:44:11,696
objects, and also issuing the


1398
00:44:11,696 --> 00:44:12,276
draw calls.


1399
00:44:12,786 --> 00:44:16,816
So when creating your encoder


1400
00:44:16,966 --> 00:44:18,336
you need to first set the render


1401
00:44:18,336 --> 00:44:18,906
targets.


1402
00:44:18,936 --> 00:44:20,756
So here is a render pass


1403
00:44:20,756 --> 00:44:22,396
descriptor where you will set


1404
00:44:22,396 --> 00:44:24,746
the render targets and then ask


1405
00:44:24,746 --> 00:44:26,586
the command buffer to create a


1406
00:44:26,586 --> 00:44:28,256
new encoder for this render


1407
00:44:28,256 --> 00:44:28,706
pass.


1408
00:44:29,366 --> 00:44:31,186
And now you can use this encoder


1409
00:44:31,186 --> 00:44:33,256
to encode your draw calls.


1410
00:44:35,136 --> 00:44:37,946
One key change from OpenGL is in


1411
00:44:38,106 --> 00:44:40,666
Metal once the encoder is


1412
00:44:40,666 --> 00:44:42,736
created you cannot change its


1413
00:44:42,736 --> 00:44:45,606
render targets because GPU


1414
00:44:45,696 --> 00:44:47,646
performs much better when it


1415
00:44:47,646 --> 00:44:49,776
sees a largest span of draw


1416
00:44:49,776 --> 00:44:51,436
calls which are rendering to the


1417
00:44:51,436 --> 00:44:53,106
same set of render targets.


1418
00:44:54,046 --> 00:44:56,906
So Metal API reflects this by


1419
00:44:57,246 --> 00:44:59,876
giving an explicit start and end


1420
00:44:59,956 --> 00:45:00,906
to a render pass.


1421
00:45:01,316 --> 00:45:03,636
Now all the draws issued by this


1422
00:45:03,636 --> 00:45:05,596
encoder will be rendering to


1423
00:45:05,596 --> 00:45:06,936
these render targets.


1424
00:45:08,566 --> 00:45:09,816
When you want to draw to a


1425
00:45:09,816 --> 00:45:11,406
different set of render targets


1426
00:45:11,576 --> 00:45:13,246
then you end this render pass


1427
00:45:13,246 --> 00:45:14,226
and start a new one.


1428
00:45:14,756 --> 00:45:18,936
And here is where we are


1429
00:45:18,936 --> 00:45:20,286
creating a render pass


1430
00:45:20,286 --> 00:45:22,916
descriptor and binding color and


1431
00:45:22,916 --> 00:45:23,876
depth attachments.


1432
00:45:25,166 --> 00:45:27,036
Now you can use that descriptor


1433
00:45:27,086 --> 00:45:29,026
and create a render command


1434
00:45:29,026 --> 00:45:29,716
encoder.


1435
00:45:30,436 --> 00:45:33,116
Now all the draws issued by this


1436
00:45:33,116 --> 00:45:34,506
encoder will be rendering to


1437
00:45:34,506 --> 00:45:34,966
these targets.


1438
00:45:37,216 --> 00:45:39,426
Additionally, in Metal you can


1439
00:45:39,426 --> 00:45:41,856
also provide load and store


1440
00:45:41,856 --> 00:45:43,546
actions for these attachments


1441
00:45:43,786 --> 00:45:45,526
for optional GPU bandwidth


1442
00:45:45,526 --> 00:45:46,126
usage.


1443
00:45:48,236 --> 00:45:50,076
So these load and store actions


1444
00:45:50,076 --> 00:45:52,086
allow you to control how the


1445
00:45:52,086 --> 00:45:53,796
texture contents will be handled


1446
00:45:53,956 --> 00:45:55,486
before and after a rendered


1447
00:45:55,526 --> 00:45:55,876
pass.


1448
00:45:56,266 --> 00:45:59,016
So here we have color and depth


1449
00:45:59,016 --> 00:46:01,856
attachments for a render pass.


1450
00:46:02,066 --> 00:46:03,856
If it specified the load action


1451
00:46:03,856 --> 00:46:05,906
as clear for both of these


1452
00:46:05,906 --> 00:46:08,346
render targets the GPU will


1453
00:46:08,386 --> 00:46:09,836
first clear their contents.


1454
00:46:10,266 --> 00:46:13,246
Then the GPU will execute


1455
00:46:13,246 --> 00:46:14,556
commands in this encoder


1456
00:46:14,556 --> 00:46:15,686
rendering to these render


1457
00:46:15,686 --> 00:46:16,346
targets.


1458
00:46:16,886 --> 00:46:19,616
Now you can specify the store


1459
00:46:19,616 --> 00:46:21,026
actions to be performed at the


1460
00:46:21,136 --> 00:46:22,176
end of the render pass.


1461
00:46:22,536 --> 00:46:24,486
Here for the color buffer since


1462
00:46:24,486 --> 00:46:25,996
the store action is store it


1463
00:46:25,996 --> 00:46:28,656
will preserve the contents of


1464
00:46:28,686 --> 00:46:30,256
this color buffer at the end of


1465
00:46:30,256 --> 00:46:30,966
the render pass.


1466
00:46:31,576 --> 00:46:33,006
And for the depth attachment,


1467
00:46:33,006 --> 00:46:35,286
since we said store action as


1468
00:46:35,286 --> 00:46:37,176
don't care it will discard its


1469
00:46:37,176 --> 00:46:37,786
contents.


1470
00:46:39,006 --> 00:46:40,876
So these texture load and stores


1471
00:46:40,876 --> 00:46:42,806
are expensive GPU operations


1472
00:46:42,806 --> 00:46:44,376
that consumes memory bandwidth.


1473
00:46:44,946 --> 00:46:47,346
So choose clear and don't care


1474
00:46:47,346 --> 00:46:48,416
wherever possible.


1475
00:46:48,976 --> 00:46:51,816
And here is how you set your


1476
00:46:51,896 --> 00:46:52,246
action.


1477
00:46:52,526 --> 00:46:54,876
In this example we specify clear


1478
00:46:54,876 --> 00:46:57,246
as a load action and set the


1479
00:46:57,286 --> 00:46:57,966
clear color.


1480
00:46:59,186 --> 00:47:00,806
And here we specify store action


1481
00:47:00,806 --> 00:47:01,236
as store.


1482
00:47:01,806 --> 00:47:03,656
Similarly, you can specify load


1483
00:47:03,656 --> 00:47:05,636
and store action for each of the


1484
00:47:05,636 --> 00:47:07,196
render targets you set in this


1485
00:47:07,196 --> 00:47:08,326
render pass descriptor.


1486
00:47:08,926 --> 00:47:11,936
So that's how we configured our


1487
00:47:11,936 --> 00:47:12,896
render targets.


1488
00:47:12,946 --> 00:47:16,596
Now you can create the encoder


1489
00:47:16,596 --> 00:47:19,076
from this descriptor and we can


1490
00:47:19,076 --> 00:47:20,526
start encoding draw calls.


1491
00:47:21,886 --> 00:47:23,606
But before that I want to show


1492
00:47:23,606 --> 00:47:25,756
you some OpenGL commands and


1493
00:47:25,756 --> 00:47:27,326
they will show you their Metal


1494
00:47:27,326 --> 00:47:28,146
equivalents.


1495
00:47:28,686 --> 00:47:31,976
So this is a typical OpenGL draw


1496
00:47:31,976 --> 00:47:32,626
sequence.


1497
00:47:33,156 --> 00:47:36,526
In this segment first we bind a


1498
00:47:36,526 --> 00:47:38,776
frame buffer which will set all


1499
00:47:38,776 --> 00:47:39,826
the render targets.


1500
00:47:41,096 --> 00:47:42,966
Then we bind our program which


1501
00:47:42,966 --> 00:47:45,056
contains vertex and fragment


1502
00:47:45,536 --> 00:47:45,676
shader.


1503
00:47:46,226 --> 00:47:48,206
And we bind vertex buffer


1504
00:47:48,206 --> 00:47:49,676
containing vertex data.


1505
00:47:50,136 --> 00:47:53,036
And then we bind another buffer


1506
00:47:53,036 --> 00:47:54,576
containing all the uniforms.


1507
00:47:55,416 --> 00:47:57,686
And then we'll set a texture to


1508
00:47:57,686 --> 00:47:58,536
sample from.


1509
00:47:59,776 --> 00:48:00,916
And finally, we draw.


1510
00:48:01,546 --> 00:48:03,956
So here is the Metal equivalent,


1511
00:48:04,566 --> 00:48:05,956
it's a few more lines of code


1512
00:48:05,996 --> 00:48:07,936
since it's explicit but it's


1513
00:48:07,936 --> 00:48:09,766
actually very similar to OpenGL.


1514
00:48:10,586 --> 00:48:11,866
First, we create a render


1515
00:48:11,866 --> 00:48:13,336
command encoder using render


1516
00:48:13,336 --> 00:48:15,456
pass descriptor which has our


1517
00:48:15,456 --> 00:48:16,346
render targets.


1518
00:48:17,696 --> 00:48:19,296
Then we set a pipeline object


1519
00:48:19,296 --> 00:48:20,506
which has our shaders.


1520
00:48:21,836 --> 00:48:24,606
Then we set a buffer for


1521
00:48:24,606 --> 00:48:26,276
accessing our vertex shader and


1522
00:48:26,676 --> 00:48:27,836
this happens to contain the


1523
00:48:27,836 --> 00:48:29,226
vertices we will draw with.


1524
00:48:30,436 --> 00:48:32,316
Note that the Metal doesn't


1525
00:48:32,316 --> 00:48:33,846
distinguish between buffers


1526
00:48:33,846 --> 00:48:36,026
containing uniforms or those


1527
00:48:36,026 --> 00:48:37,176
containing vertices.


1528
00:48:37,816 --> 00:48:40,276
So we will use the same API to


1529
00:48:40,276 --> 00:48:41,386
set uniform buffer.


1530
00:48:41,386 --> 00:48:44,026
So here the first call will give


1531
00:48:44,026 --> 00:48:46,026
buffer access to vertex shader


1532
00:48:46,026 --> 00:48:47,236
while the second call will give


1533
00:48:47,236 --> 00:48:48,746
access to the fragment shader.


1534
00:48:49,286 --> 00:48:52,166
Next, we set a texture for our


1535
00:48:52,166 --> 00:48:54,026
fragment shader to sample from.


1536
00:48:54,516 --> 00:48:56,556
And then we draw.


1537
00:48:57,076 --> 00:48:59,846
And once we are done encoding


1538
00:48:59,846 --> 00:49:01,456
commands we will indicate this


1539
00:49:01,456 --> 00:49:03,396
to Metal by calling endEncoding


1540
00:49:03,396 --> 00:49:05,376
on the encoder object.


1541
00:49:06,196 --> 00:49:07,916
So this was a simple example of


1542
00:49:07,916 --> 00:49:09,406
a metal render pass.


1543
00:49:09,926 --> 00:49:12,926
Now that we have a complete


1544
00:49:12,926 --> 00:49:14,696
render pass let's see how to get


1545
00:49:14,696 --> 00:49:16,286
these renderings onto the


1546
00:49:16,286 --> 00:49:16,806
display.


1547
00:49:17,336 --> 00:49:21,526
With OpenGL you present your


1548
00:49:21,526 --> 00:49:23,156
rendered frame onto the screen


1549
00:49:23,436 --> 00:49:25,336
but you don't explicitly manage


1550
00:49:25,336 --> 00:49:27,996
the system's render buffers also


1551
00:49:27,996 --> 00:49:29,006
known as drawables.


1552
00:49:30,336 --> 00:49:32,126
But with Metal to get your


1553
00:49:32,126 --> 00:49:34,476
content displayed on the screen


1554
00:49:34,906 --> 00:49:36,186
first you need to obtain the


1555
00:49:36,186 --> 00:49:37,516
special textures called


1556
00:49:37,516 --> 00:49:39,116
drawables from the system.


1557
00:49:39,746 --> 00:49:41,676
So you can use a MetalKit view


1558
00:49:41,816 --> 00:49:42,756
which will provide you a


1559
00:49:42,756 --> 00:49:44,846
drawable texture for each frame.


1560
00:49:45,426 --> 00:49:46,886
And once you obtain this


1561
00:49:46,886 --> 00:49:49,276
drawable you can encode render


1562
00:49:49,276 --> 00:49:51,226
passes and render to these


1563
00:49:51,226 --> 00:49:53,096
drawables just like you would


1564
00:49:53,096 --> 00:49:54,586
render to any other texture.


1565
00:49:55,126 --> 00:49:57,766
However, unlike other textures


1566
00:49:57,766 --> 00:49:59,236
now you can present this


1567
00:49:59,236 --> 00:49:59,976
drawable to your view.


1568
00:50:00,096 --> 00:50:02,506
So let me show you a code


1569
00:50:02,506 --> 00:50:02,996
sample.


1570
00:50:03,516 --> 00:50:06,196
First, I want to mention that


1571
00:50:06,196 --> 00:50:07,886
these drawables are limited


1572
00:50:08,166 --> 00:50:10,696
shade system resources, so you


1573
00:50:10,696 --> 00:50:12,206
should hold on to them as


1574
00:50:12,206 --> 00:50:13,536
briefly as possible.


1575
00:50:14,236 --> 00:50:15,776
This means that you should


1576
00:50:15,776 --> 00:50:18,096
encode all your offscreen render


1577
00:50:18,126 --> 00:50:20,016
passes before you acquire a


1578
00:50:20,016 --> 00:50:20,606
drawable.


1579
00:50:21,906 --> 00:50:23,626
Then you can create a MetalKit


1580
00:50:23,626 --> 00:50:26,856
view for either a fully


1581
00:50:26,856 --> 00:50:29,206
populated render pass descriptor


1582
00:50:29,466 --> 00:50:30,926
which you can directly use to


1583
00:50:30,926 --> 00:50:33,836
create encoders, which is what


1584
00:50:33,836 --> 00:50:36,336
you see here or you can ask for


1585
00:50:36,336 --> 00:50:37,746
a specific texture using


1586
00:50:37,976 --> 00:50:41,626
view.currentDrawable property.


1587
00:50:41,626 --> 00:50:42,706
And then you can build your own


1588
00:50:42,706 --> 00:50:44,276
render pass descriptor around


1589
00:50:45,016 --> 00:50:45,086
it.


1590
00:50:47,136 --> 00:50:48,846
Once you are finished encoding


1591
00:50:48,846 --> 00:50:50,496
your frame you can call the


1592
00:50:50,496 --> 00:50:51,896
command buffer's present


1593
00:50:51,896 --> 00:50:53,456
drawable method which puts your


1594
00:50:53,456 --> 00:50:55,626
drawable onto the screen when


1595
00:50:55,626 --> 00:50:57,466
GPU finishes executing this


1596
00:50:57,466 --> 00:50:58,166
command buffer.


1597
00:50:58,986 --> 00:51:00,946
So now once GPU is done


1598
00:51:00,946 --> 00:51:02,586
executing this frame you should


1599
00:51:02,586 --> 00:51:04,116
see your frame on the display.


1600
00:51:04,646 --> 00:51:07,606
So that was our quick tour to


1601
00:51:07,606 --> 00:51:09,286
get your renderings onto the


1602
00:51:09,286 --> 00:51:10,596
display with Metal.


1603
00:51:11,156 --> 00:51:13,856
But I have a few more tips to


1604
00:51:13,856 --> 00:51:14,166
share.


1605
00:51:15,366 --> 00:51:17,296
It is possible to port one


1606
00:51:17,966 --> 00:51:19,596
render pass at a time into


1607
00:51:19,596 --> 00:51:19,936
Metal.


1608
00:51:19,936 --> 00:51:21,436
The IOSurface and CVPixelBuffer


1609
00:51:21,436 --> 00:51:25,696
APIs can be used to create a


1610
00:51:25,726 --> 00:51:27,596
texture which can be shared


1611
00:51:27,596 --> 00:51:29,266
between OpenGL and Metal.


1612
00:51:30,376 --> 00:51:32,586
This will allow you to render to


1613
00:51:32,586 --> 00:51:34,596
a texture in OpenGL and then


1614
00:51:34,596 --> 00:51:36,746
read from it in Metal or vice


1615
00:51:36,746 --> 00:51:36,926
versa.


1616
00:51:36,926 --> 00:51:39,876
So some of the applications can


1617
00:51:39,876 --> 00:51:41,616
leverage this to port


1618
00:51:41,616 --> 00:51:43,476
incrementally, especially with


1619
00:51:43,756 --> 00:51:45,076
plugin architectures which are


1620
00:51:45,076 --> 00:51:46,466
built around OpenGL.


1621
00:51:47,206 --> 00:51:49,546
So there is a sample code linked


1622
00:51:49,686 --> 00:51:51,796
to this session showing exactly


1623
00:51:51,796 --> 00:51:52,846
on how to do this.


1624
00:51:55,416 --> 00:51:56,796
Now that you have a Metal


1625
00:51:56,796 --> 00:51:58,806
application you can adopt all


1626
00:51:58,806 --> 00:51:59,906
new Metal features.


1627
00:52:01,076 --> 00:52:03,046
If your application is CPU bound


1628
00:52:03,046 --> 00:52:05,436
then multithreading your CPU


1629
00:52:05,436 --> 00:52:07,006
encoding work can help.


1630
00:52:07,746 --> 00:52:09,636
You can encode multiple command


1631
00:52:09,636 --> 00:52:11,316
buffers simultaneously on


1632
00:52:11,316 --> 00:52:12,346
separate threads.


1633
00:52:12,926 --> 00:52:14,776
You can even split single


1634
00:52:14,776 --> 00:52:16,556
command buffer encoding across


1635
00:52:16,556 --> 00:52:18,346
multiple threads using parallel


1636
00:52:18,346 --> 00:52:18,976
render command encoder.


1637
00:52:25,046 --> 00:52:26,926
Also, GPUs compute by planned


1638
00:52:26,926 --> 00:52:29,236
processing APIs is built right


1639
00:52:29,236 --> 00:52:30,186
into Metal.


1640
00:52:30,776 --> 00:52:32,946
You can use GPU in whole new


1641
00:52:32,946 --> 00:52:33,536
ways.


1642
00:52:34,046 --> 00:52:36,666
To start with instead of CPU you


1643
00:52:36,666 --> 00:52:38,976
can leverage compute pipeline to


1644
00:52:38,976 --> 00:52:40,746
generate graphics GPU data.


1645
00:52:41,336 --> 00:52:43,616
By letting GPU to generate its


1646
00:52:43,616 --> 00:52:45,346
own data you're not only


1647
00:52:45,346 --> 00:52:47,846
reducing the CPU utilization and


1648
00:52:47,846 --> 00:52:49,776
synchronization points now you


1649
00:52:49,776 --> 00:52:50,796
are freeing up the data


1650
00:52:50,796 --> 00:52:52,106
bandwidth to GPU.


1651
00:52:53,176 --> 00:52:54,946
Now with this high bandwidth


1652
00:52:55,246 --> 00:52:56,846
compute processor you can


1653
00:52:56,846 --> 00:52:58,456
implement many more complex


1654
00:52:58,456 --> 00:52:58,966
algorithms like these.


1655
00:53:03,356 --> 00:53:05,256
Metal supports many more great


1656
00:53:05,296 --> 00:53:07,216
features which you can adopt in


1657
00:53:07,216 --> 00:53:08,886
your application to improve its


1658
00:53:08,886 --> 00:53:09,706
performance.


1659
00:53:10,256 --> 00:53:13,556
In addition, as part of your


1660
00:53:13,596 --> 00:53:15,186
porting process we highly


1661
00:53:15,186 --> 00:53:17,406
encourage to use our Metal


1662
00:53:17,406 --> 00:53:19,096
powerful debugging and


1663
00:53:19,096 --> 00:53:21,226
optimization tools which are


1664
00:53:21,256 --> 00:53:23,456
integrated right into Xcode.


1665
00:53:24,446 --> 00:53:26,476
So Metal has a great API


1666
00:53:26,476 --> 00:53:28,536
validation layer that will print


1667
00:53:28,796 --> 00:53:30,816
detailed information about any


1668
00:53:30,816 --> 00:53:33,176
improper API usage and also


1669
00:53:33,176 --> 00:53:34,756
suggests some potential fixes.


1670
00:53:36,316 --> 00:53:38,826
This is a GPU debugger which


1671
00:53:38,826 --> 00:53:40,536
gives you a capability to step


1672
00:53:40,596 --> 00:53:42,706
through your Metal calls and


1673
00:53:42,706 --> 00:53:44,466
view how your frame is being


1674
00:53:44,466 --> 00:53:45,816
rendered step-by-step.


1675
00:53:46,726 --> 00:53:48,796
You can view all the resources


1676
00:53:48,796 --> 00:53:50,246
associated with your frame.


1677
00:53:50,926 --> 00:53:53,116
It also provides the GPU expert


1678
00:53:53,166 --> 00:53:54,436
tips based on your resource


1679
00:53:54,436 --> 00:53:55,036
usage.


1680
00:53:55,586 --> 00:53:58,916
For this year we have also added


1681
00:53:58,916 --> 00:54:00,556
shader debugging capability


1682
00:54:00,916 --> 00:54:02,326
where you can debug your shader


1683
00:54:02,326 --> 00:54:03,486
functions just like other


1684
00:54:03,486 --> 00:54:04,006
functions.


1685
00:54:04,516 --> 00:54:07,686
We also added a shader profiler


1686
00:54:07,956 --> 00:54:09,646
which showing a rich set of


1687
00:54:09,646 --> 00:54:11,266
performance metrics related to


1688
00:54:11,266 --> 00:54:11,936
your shaders.


1689
00:54:12,046 --> 00:54:15,556
And also, a dependency viewer


1690
00:54:15,556 --> 00:54:17,156
which allows you to evaluate


1691
00:54:17,156 --> 00:54:18,626
dependencies between the render


1692
00:54:18,626 --> 00:54:22,096
passes and you can potentially


1693
00:54:22,096 --> 00:54:24,336
merge any redundant render


1694
00:54:24,336 --> 00:54:26,726
passes to improve your


1695
00:54:26,726 --> 00:54:27,976
application's performance.


1696
00:54:30,216 --> 00:54:32,166
And finally, the Metal system


1697
00:54:32,166 --> 00:54:33,966
trace tool in instruments will


1698
00:54:33,966 --> 00:54:36,696
give you a complete view of your


1699
00:54:36,736 --> 00:54:38,486
application's behavior and


1700
00:54:38,486 --> 00:54:40,276
performance so we highly


1701
00:54:40,276 --> 00:54:42,396
recommend using these tools to


1702
00:54:42,396 --> 00:54:44,146
ease your porting effort.


1703
00:54:45,296 --> 00:54:47,906
Wrapping it up, OpenGL and


1704
00:54:47,906 --> 00:54:49,536
OpenCL are deprecated.


1705
00:54:49,536 --> 00:54:52,656
They are still around but we are


1706
00:54:52,656 --> 00:54:54,466
discouraging their future use.


1707
00:54:54,826 --> 00:54:56,526
It is time to adopt Metal.


1708
00:54:57,216 --> 00:54:59,106
We have full suite of developer


1709
00:54:59,106 --> 00:55:00,806
tools, a lot of experience


1710
00:55:00,806 --> 00:55:02,896
helping many teams successfully


1711
00:55:02,896 --> 00:55:04,616
go through this effort and come


1712
00:55:04,616 --> 00:55:06,376
out with substantially improved


1713
00:55:06,376 --> 00:55:07,006
performance.


1714
00:55:07,736 --> 00:55:09,236
I'm hoping the information we


1715
00:55:09,236 --> 00:55:10,846
shared today will give you


1716
00:55:10,846 --> 00:55:12,356
smooth porting experience.


1717
00:55:12,866 --> 00:55:15,846
And we are very happy to talk to


1718
00:55:15,846 --> 00:55:17,376
you about your applications and


1719
00:55:17,376 --> 00:55:18,836
how to get them up and running


1720
00:55:18,836 --> 00:55:19,406
with Metal.


1721
00:55:20,006 --> 00:55:21,776
So we will be available tomorrow


1722
00:55:21,776 --> 00:55:23,506
afternoon at OpenGL to Metal


1723
00:55:23,666 --> 00:55:25,736
porting lab and there are many


1724
00:55:25,736 --> 00:55:27,696
upcoming sessions on Metal.


1725
00:55:28,006 --> 00:55:29,426
I recommend attending these


1726
00:55:29,426 --> 00:55:31,546
sessions to learn more about how


1727
00:55:31,546 --> 00:55:33,106
to debug and optimize your


1728
00:55:33,106 --> 00:55:34,466
applications with Metal.


1729
00:55:36,106 --> 00:55:37,866
With that I thank you all for


1730
00:55:37,866 --> 00:55:39,706
attending and I hope you enjoy


1731
00:55:39,706 --> 00:55:40,716
the rest of your week.


1732
00:55:41,516 --> 00:55:44,500
[ Applause ]

